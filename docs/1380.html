<html>
<head>
<title>Exploring IOTA #ICT-3, Reverse engineering the code Part-2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索IOTA #ICT-3，逆向工程代码第2部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/exploring-iota-ict-reverse-engineering-the-code-part-2-bfa3cc1fba88?source=collection_archive---------4-----------------------#2018-08-22">https://medium.com/coinmonks/exploring-iota-ict-reverse-engineering-the-code-part-2-bfa3cc1fba88?source=collection_archive---------4-----------------------#2018-08-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="8e11" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">深入探究ICT (IOTA控制的代理)的这个小小的代码库。试图找出无效事务通过ICT和IRI的原因(IOTA参考实施)。最后讨论ICT测试阶段的下一步是什么。</h2></div><p id="bab0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu"> ICT </strong>测试阶段0.1.1被<strong class="jk hu">CfB</strong>(<strong class="jk hu">C</strong>ome-<strong class="jk hu">f</strong>rom-<strong class="jk hu">B</strong>eyond)停止一周，要求参与者将其<strong class="jk hu"> ICT </strong>客户端从主网络及其连接的节点断开。在一个多星期的时间里，你可以跟踪一些测试人员，确认大约一个月前在七月下旬发生的不一致。但是<strong class="jk hu"> <em class="ki">为什么</em> </strong>和<strong class="jk hu"> <em class="ki">接下来的</em> </strong>是什么将在后面讨论。<br/>现在，我们深入探究为什么<strong class="jk hu"> ICT </strong>在0.1.1测试阶段会随着时间的推移表现不佳，原因是无效的事务，这些事务本不应该被<strong class="jk hu"> ICT </strong>或<strong class="jk hu">IRI</strong>(OTA<strong class="jk hu">R</strong>reference<strong class="jk hu">I</strong>implementation是保存分布式纠结的节点软件)。</p><p id="8bfe" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">重新编译的ict-0.1.1的源代码可以在这里找到(不用担心CfB说我们可以在他即将发布时公开代码…因为有新的测试阶段进入，下一个版本可能会有很大的变化)。</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div class="fe ff kj"><img src="../Images/c00179ccefce8300d92001f5c0ffa835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*HIO3aXxsCo0lpf7yG85ugw.png"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Come-from-Beyond statement exposing the code base</figcaption></figure><div class="kv kw fm fo kx ky"><a href="https://github.com/jhab82/ict-0.1.1_jhab82" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab ej"><div class="la ab lb cl cj lc"><h2 class="bd hu fv z el ld eo ep le er et hs dt translated">jhab82/ict-0.1.1_jhab82</h2><div class="lf l"><h3 class="bd b fv z el ld eo ep le er et ek translated">ict-0.1.1_jhab82 -用CFR在线java反编译器反编译ict-0.1.1</h3></div><div class="lg l"><p class="bd b gc z el ld eo ep le er et ek translated">github.com</p></div></div><div class="lh l"><div class="li l lj lk ll lh lm kp ky"/></div></div></a></div><p id="3c89" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当我们开始对<strong class="jk hu"> ICT </strong> 0.1.1进行alpha测试时，虽然我的<strong class="jk hu"> ICT </strong>至少连接了4个邻居<strong class="jk hu"> IRI </strong>节点，但在某些阶段它并没有真正处于活动状态。我说的主动是指我的ICT几乎不会对邻居说闲话。</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff ln"><img src="../Images/ace5d720c8696f10cd2d06e0f6305578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqW9q3zxjBxTnGsPh9nheA.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">7 days ICT performing on the f1-micro cloud instance. The first 2–3 days almost no outbound Tx as of invalid transaction getting gossiped.</figcaption></figure><p id="2992" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了分析原因，我们需要了解<strong class="jk hu"> ICT </strong>逻辑停止向其邻居发送<strong class="jk hu">UDP</strong>(<strong class="jk hu">U</strong>ser<strong class="jk hu">D</strong>atagram<strong class="jk hu">P</strong>rotocol)数据包的原因。</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/829dc5e44ff27292d59e88a32c63e790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*9Dz2T_zEnQJLzfue9PnGxw.png"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Sharing the analysis on DISCORD #ICT channel</figcaption></figure><p id="e7fa" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我发现无效发送计数器在每个时期都是活动的(在<strong class="jk hu"> ICT </strong>复位并重新开始之前的每分钟处理)。检查逻辑<strong class="jk hu"> IRI </strong>节点(<strong class="jk hu"> ICT </strong>连接到)被忽略，一旦<strong class="jk hu"> ICT </strong>发现无效Tx，则进一步共享其Tx。</p><p id="bd64" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这意味着根据识别出无效Tx的时间，不发送Tx。在我们的例子中，在一个时期中已经过了几秒钟之后，出现无效的Tx。这导致几乎没有出站流量</p><p id="26d4" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在重新编译了<code class="eh ke kf kg kh b">Trasaction.java </code>并在该类中添加了一些允许我检查Tx为什么无效的行之后，我得出结论，所有的无效都是由比</p><figure class="kk kl km kn fq ko"><div class="bz el l di"><div class="lt lu l"/></div></figure><p id="f8a1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通过使用下面的命令，我们获得了人类可读格式的时间戳。</p><pre class="kk kl km kn fq lv kh lw lx aw ly dt"><span id="e93d" class="lz ma ht kh b fv mb mc l md me">$date -d @1508760000<br/><strong class="kh hu">Mon Oct 23 12:00:00 UTC 2017</strong></span></pre><p id="6bca" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我在下面的命令上面添加了一个<code class="eh ke kf kg kh b">if</code>语句</p><pre class="kk kl km kn fq lv kh lw lx aw ly dt"><span id="2f7c" class="lz ma ht kh b fv mb mc l md me">System.out.println(Converter.trytes(trits,0,8019));</span></pre><p id="2756" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">并且能够检索到无效的Tx，这使得<strong class="jk hu"> ICT </strong>停止了闲聊。原来这一次臭名昭著的<code class="eh ke kf kg kh b">FPS</code>捆绑包让<strong class="jk hu"> ICT </strong>停止了八卦</p><pre class="kk kl km kn fq lv kh lw lx aw ly dt"><span id="74fe" class="lz ma ht kh b fv mb mc l md me">BUNDLE: FPSJJPZO9LGRIZLLHTNCBEELJHKJSPXJDXLFGKPTTTXZMAZZNKIXHQTTOPURGGVLKNZVAS9FTCUFUIMB9</span></pre><div class="kv kw fm fo kx ky"><a href="https://thetangle.org/bundle/FPSJJPZO9LGRIZLLHTNCBEELJHKJSPXJDXLFGKPTTTXZMAZZNKIXHQTTOPURGGVLKNZVAS9FTCUFUIMB9" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab ej"><div class="la ab lb cl cj lc"><h2 class="bd hu fv z el ld eo ep le er et hs dt translated">捆绑包fpsjjpzo 9 lgrizllhtncbeeljhkjspxjdxlfgkptttxzmazznkixhqttopurggvlknzvas 9 ftcuuimb 9</h2><div class="lf l"><h3 class="bd b fv z el ld eo ep le er et ek translated">编辑描述</h3></div><div class="lg l"><p class="bd b gc z el ld eo ep le er et ek translated">thetangle.org</p></div></div></div></a></div><p id="eeff" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">查看事务对象(您可以通过使用<code class="eh ke kf kg kh b">iota.utils.transactionObject(TxInTrytes)</code>将trytes转换为下面的表示来更好地了解事务)</p><pre class="kk kl km kn fq lv kh lw lx aw ly dt"><span id="740a" class="lz ma ht kh b fv mb mc l md me">{ hash: 'ZQNFEEIHXB9LEHAUDYMEDQCKA9CGYHIYORBYJTZ9XUDULKWAE9KDBXG9DVQEHPMFWZRUEKDVXJLCA9999',<br/>  signatureMessageFragment: 'KTCNPN...(shortened)...UOZ',<br/>  address: 'JNYEGRFRQQNYQNMJV9YRPRWMEGBZYLNHURIGEGQWF9AISLMQEUZOEBDBQYETETKEBLUQNGVAOGWXHQKEY',<br/>  value: 0,<br/>  obsoleteTag: '999999999999999999999999999',<br/> <strong class="kh hu"> timestamp: 1507219591,</strong><br/>  currentIndex: 2,<br/>  lastIndex: 3,<br/>  bundle: 'FPSJJPZO9LGRIZLLHTNCBEELJHKJSPXJDXLFGKPTTTXZMAZZNKIXHQTTOPURGGVLKNZVAS9FTCUFUIMB9',<br/>  trunkTransaction: 'NEJKMDKIPBRISDEXICIXGMNCGTV9NGKLMPNIOUWESVIIUQFOEQQHZEENBWFWLAIFREZBYRNJWOISZ9999',<br/>  branchTransaction: 'SIQJAMJKQISZGI9J9JAKFSGVLAPLMMBVJEXLSQLLEZQTIKQPQTBZ9JFIARRFKRMLMXZNQUVEFJYEA9999',<br/>  tag: '999999999999999999999999999',<br/>  attachmentTimestamp: 1531119376226,<br/>  attachmentTimestampLowerBound: 0,<br/>  attachmentTimestampUpperBound: 12,<br/>  nonce: 'BFA999GC99IPA99999999999999' }</span></pre><p id="0614" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如上所述，此Tx的时间戳在允许的时间戳之前，允许的时间戳会抛出错误并从那一刻起忽略此节点。</p><pre class="kk kl km kn fq lv kh lw lx aw ly dt"><span id="2c51" class="lz ma ht kh b fv mb mc l md me">$ date -d @1507219591<br/>Thu Oct  5 16:06:31 UTC 2017</span></pre><p id="f7f1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这是通过检查邻居的无效事务计数器是否超过零来实现的。如果是这种情况，则再次进入while循环(由<code class="eh ke kf kg kh b">continue;</code>实现)</p><pre class="kk kl km kn fq lv kh lw lx aw ly dt"><span id="08f6" class="lz ma ht kh b fv mb mc l md me">101  if (neighbor2.numberOfInvalidTransactions != 0) {<br/>102      continue;<br/>103  }</span></pre><p id="23de" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">并且这是计数器增加到1的地方(计数器不会超过1，因为循环像上面的语句一样被中断。)</p><figure class="kk kl km kn fq ko"><div class="bz el l di"><div class="lt lu l"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Snippet of ICT.java where neighbors with invalid Tx got ignored in the epoch</figcaption></figure><p id="a38e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">看一下<code class="eh ke kf kg kh b">FPS</code>包，它显然是在10月5日发行的，直到现在仍然有重新连接。在某个点上，捆绑包停止重新连接，并且<strong class="jk hu"> ICT </strong>无效Tx计数器保持为0，网络再次变得健康。</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/71fe0397a1b1fea83c713b4d5fb9e68d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*5iTrXT14yGwr-17agg0k8Q.png"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Yellow marked the invalid Tx counter getting 0 again after the FPS stopped getting reattached</figcaption></figure><p id="89d0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这就给我们留下了疑问，为什么<strong class="jk hu"> IRI </strong>首先会通过那些无效的Tx。在我看来，这些问题的答案应该在IRI的源代码中找到。</p><p id="5a45" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">前往<a class="ae mg" href="https://github.com/iotaledger/iri" rel="noopener ugc nofollow" target="_blank">https://github.com/iotaledger/iri</a>并在代码库中搜索<code class="eh ke kf kg kh b">Timestamp</code>——我们希望找出<strong class="jk hu"> IRI </strong>根据时间戳决定忽略事务的地方。</p><p id="3e60" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">经过一些尝试(目前没有可用的代码文档)，我找到了类<code class="eh ke kf kg kh b">TransactionValidator.java</code>。下面是布尔函数<code class="eh ke kf kg kh b">hasInvalidTimestamp(TransactionViewModel transactionViewModel)</code>一旦交易时间戳满足列出的标准，返回true，其中之一是它需要大于<code class="eh ke kf kg kh b">snapshotTimestampMs</code></p><pre class="kk kl km kn fq lv kh lw lx aw ly dt"><span id="2ad7" class="lz ma ht kh b fv mb mc l md me"><strong class="kh hu">return transactionViewModel.getAttachmentTimestamp() &lt; snapshotTimestampMs</strong>                || transactionViewModel.getAttachmentTimestamp() &gt; System.currentTimeMillis() + MAX_TIMESTAMP_FUTURE_MS;</span></pre><p id="73f3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">哪个是根据<code class="eh ke kf kg kh b">IOTA.java</code></p><pre class="kk kl km kn fq lv kh lw lx aw ly dt"><span id="db8c" class="lz ma ht kh b fv mb mc l md me">long snapshotTimestamp = configuration.longNum(Configuration.DefaultConfSettings.SNAPSHOT_TIME);</span></pre><p id="96b8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">而<code class="eh ke kf kg kh b">Configuration.java</code>此刻</p><pre class="kk kl km kn fq lv kh lw lx aw ly dt"><span id="cc41" class="lz ma ht kh b fv mb mc l md me">public static final String GLOBAL_SNAPSHOT_TIME = "1531148400";</span></pre><p id="0f45" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">但是这并没有告诉我们所有时间戳较低的事务都应该被IRI忽略。</p><p id="18d5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们在<code class="eh ke kf kg kh b">Node.java</code>中找到一个函数<code class="eh ke kf kg kh b">preProcessReceivedData(...)</code>，它应该预处理来自其邻居的输入事务。它循环通过所有邻居IP，并且仅在发送者的IP地址<code class="eh ke kf kg kh b">senderAddress</code>匹配邻居的IP时才继续。该步骤实际上忽略了来自其他IP的所有要进一步处理的传入数据包。然后是一些随机丢弃的交易——还不知道目的。</p><p id="2723" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在那之后的<code class="eh ke kf kg kh b">try {} </code>声明</p><ul class=""><li id="a5ff" class="mh mi ht jk b jl jm jo jp jr mj jv mk jz ml kd mm mn mo mp dt translated">从事务消息中创建散列</li><li id="4a13" class="mh mi ht jk b jl mq jo mr jr ms jv mt jz mu kd mm mn mo mp dt translated">检查交易最近是否被看过<code class="eh ke kf kg kh b">recentSeenBytes</code></li></ul><p id="6507" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">只有当事务没有被缓存时，事务才会被验证。对象<code class="eh ke kf kg kh b">TransactionModel</code>被创建，然后进入验证运行，一旦事务的时间戳早于<code class="eh ke kf kg kh b">GLOBAL_SNAPSHOT_TIME</code>，我们之前的异常将被抛出。这个例外状况会被拦截</p><pre class="kk kl km kn fq lv kh lw lx aw ly dt"><span id="e270" class="lz ma ht kh b fv mb mc l md me">} catch (final TransactionValidator.StaleTimestampException e) {</span></pre><p id="4a32" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">并增加该邻居的<code class="eh ke kf kg kh b">numberOfInvalidTransaction++</code>。</p><div class="kv kw fm fo kx ky"><a href="https://github.com/iotaledger/iri/blob/d59de9fbaa2432a7123d9a4d65a1555241fcd934/src/main/java/com/iota/iri/network/Node.java" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab ej"><div class="la ab lb cl cj lc"><h2 class="bd hu fv z el ld eo ep le er et hs dt translated">iota分类账/iri</h2><div class="lf l"><h3 class="bd b fv z el ld eo ep le er et ek translated">参考实现</h3></div><div class="lg l"><p class="bd b gc z el ld eo ep le er et ek translated">github.com</p></div></div><div class="lh l"><div class="mv l lj lk ll lh lm kp ky"/></div></div></a></div><p id="1e3a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">整个验证和预处理是通过实际事务的散列来处理的。当<code class="eh ke kf kg kh b">runValidation</code>抛出时间戳异常时，该事务应该从事务队列中删除，以便进一步处理:</p><pre class="kk kl km kn fq lv kh lw lx aw ly dt"><span id="8f2f" class="lz ma ht kh b fv mb mc l md me">transactionRequester.clearTransactionRequest(receivedTransactionHash);</span></pre><p id="b8db" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">显然，Tx首先不应该被发送，这通过<strong class="jk hu"> IRI </strong>中的实现是显而易见的。我仍然不知道这个bug在哪里。这可能有许多原因，但一个可能的解释是错误的交易没有从队列中删除，因此被进一步处理。另一种可能是<code class="eh ke kf kg kh b">preProcessReceiveData</code>被绕过。</p><p id="e15a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">由于我仍然没有完整的节点积极参与到这个问题中，所以我无法调试这种情况。我想我会把这个问题留到下次——也许在下一个<strong class="jk hu"> IRI </strong>版本中已经解决了，或者它实际上不是一个bug而是一个特性😅</p></div><div class="ab cl mw mx hb my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hm hn ho hp hq"><p id="d17d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">总结一下:</strong>我已经看过了<strong class="jk hu"> ICT </strong>和<strong class="jk hu"> IRI </strong> java代码，对这两种实现的机制有了更多的理解——特别是在识别无效交易方面。</p><p id="90eb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当<strong class="jk hu"> ICT </strong>向其邻居闲聊有效事务时，它会在60年代的剩余时间里忽略具有无效事务的邻居。这导致<strong class="jk hu"> ICT </strong>在测试阶段0.1.1的一段时间内表现很差(就不八卦Tx而言),因为事务一直通过带有无效时间戳的<strong class="jk hu"> IRI </strong>。</p><p id="d747" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">CfB本人证实，那些Tx不应该被<strong class="jk hu"> IRI </strong>分享，我在上面的文章中试图找到原因。不幸的是，我不能完全找出原因，但概述了问题，并深入到代码中应该排除它的地方。</p></div><div class="ab cl mw mx hb my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hm hn ho hp hq"><h2 id="7b77" class="lz ma ht bd nd ne nf ng nh ni nj nk nl jr nm nn no jv np nq nr jz ns nt nu nv dt translated">ICT的下一步是什么</h2><p id="0b4e" class="pw-post-body-paragraph ji jj ht jk b jl nw iu jn jo nx ix jq jr ny jt ju jv nz jx jy jz oa kb kc kd hm dt translated">如前所述，ict-0.1.1的测试已经停止，第二个测试阶段也随之宣布。</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div class="fe ff ob"><img src="../Images/a0e684e9bd07de181890d4b795ff3e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*3VpOE76s3vcVfwnZySIoUw.png"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Screen from Discord</figcaption></figure><p id="bba8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">第二测试阶段显然不应有任何与信通技术相连的IRI节点，而应只有与信通技术相连的信通技术。交易结构将会改变，只有验证该结构的ICT参与者才能参与。这听起来像是我们在测试经济整合的概念。这里，网络参与者处于独立于ICT的集群中，但仍通过互联网处理他们的交易。</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div class="fe ff oc"><img src="../Images/4a19993e666afd24f11b4a6d8d6a56e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*2cVv7MPrgB7G4g-yb_AX1Q.png"/></div></figure><p id="95da" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">什么时候？目前还不是很清楚。首先需要调整最终IOTA Tx结构，然后需要更改ICT代码，特别是<code class="eh ke kf kg kh b">Transaction.java</code>。</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div class="fe ff od"><img src="../Images/25fd36c498b8b6385591c75fc25e463b.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*xo4qiBW7VWzt6Kxuiy4Shw.png"/></div></figure><p id="aace" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">除了新的Tx结构，CfB还想测试垃圾邮件发送者对网络的干扰。他将提供一个java垃圾邮件发送器，然后用于扰乱网络(甚至FPGA F <strong class="jk hu">现场可编程门阵列</strong>家伙<em class="ki"> </em>也应该加入聚会。)</p><p id="db67" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">最后是一些建议，哪些攻击交易最有可能通过ICT的保护。<strong class="jk hu">非常期待前进。要了解CfB在这里谈论的是哪种保护👌</strong></p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div class="fe ff oe"><img src="../Images/abdad632774b025a9a7fd6da32ba7a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*wRQR0xEH36cYC-cBU2_6EQ.png"/></div></figure><p id="7f98" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">最初，我猜想ICT的第二测试阶段应该在主网上继续进行，但是对于Roman Semko的流行节点软件(Hercules)的自动共享功能(Nelson)是否会潜在地干扰网络性能存在争议。</p><p id="a79f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我没理解错的话，罗曼想出了一个解决方案，他四处打听邻居，想把Node连接到哪里。</p><p id="9daa" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="ki">对于每个人来说，运行自己的节点来手动设置邻居是一个更大的难题。如果没有邻居，你就无法接收网络的交易，也根本无法支持这种纠结。罗曼很早就明白了这种麻烦，他实现了一种自动功能，让邻居按照一定的标准进行轮换。最重要的是，你不必知道其他节点运营商，也不需要disrupt，只需要在#nodesharing下问一问，谁想把你添加为邻居。</em></p><p id="8455" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为什么这个功能不是设计意图在正式的IOTA常见问题解答中解释。</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div class="fe ff of"><img src="../Images/a8ba09f714bb9e376ab7f3861b0e3d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*Z_lddB7oCtkE5crPpq14vw.png"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Screen from IOTA official FAQ</figcaption></figure><p id="9bd3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">注意，IOTA本身已经在2016年尝试了自动共享(对等点发现)，但由于相同的已解释的缺点而终止</p><div class="kv kw fm fo kx ky"><a href="https://forum.iota.org/t/discussion-removing-peer-discovery/939" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab ej"><div class="la ab lb cl cj lc"><h2 class="bd hu fv z el ld eo ep le er et hs dt translated">讨论:删除对等发现</h2><div class="lf l"><h3 class="bd b fv z el ld eo ep le er et ek translated">过去几周，我们推出了Peer Discovery，旨在让IOTA更易于人类使用。现在……</h3></div><div class="lg l"><p class="bd b gc z el ld eo ep le er et ek translated">forum.iota.org</p></div></div><div class="lh l"><div class="og l lj lk ll lh lm kp ky"/></div></div></a></div><p id="d1c8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">说到ICT，我猜CfB喜欢启用一个限制流入Txs的功能。</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div class="fe ff oh"><img src="../Images/6b76012ead50c38084dea0263ed17b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*7tdBcugTwvHN2Vss2uIPYw.png"/></div></figure><p id="c28a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">由于一篇有趣的复杂论文，有一些关于网络拓扑在无线网络设置中应该是什么样子的证明(我试图阅读并理解这篇论文证明了什么，但我无法通过第一张图片)。据我所知，他们已经研究了<em class="ki">平均一致性算法</em>——如果网络拓扑保持不变且简单，离散数量的测量节点会更好地收敛于关于其平均测量值的一致性。</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div class="fe ff oi"><img src="../Images/7d569ac60fcc9ff3fb894c84b1e08212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*9aSwetxdBZeU4Vupnpr6Fg.png"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek"><a class="ae mg" href="https://www3.nd.edu/~mhaenggi/pubs/jstsp11.pdf" rel="noopener ugc nofollow" target="_blank">https://www3.nd.edu/~mhaenggi/pubs/jstsp11.pdf</a></figcaption></figure><p id="c301" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">看来罗曼的对等点发现应用短期内不会停止，而且大部分网络参与者都是通过互联网上的自动共享来连接的，这样一来，tangle main net——ICT的第二个测试阶段就转移到了它自己的网络上。</p><p id="83f5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了排除自动共享<strong class="jk hu">带来的任何干扰，ICT </strong>需要自己的网络，而这个网络应该是未来物联网世界的最佳代表。该网络将基于唯一的交易模型结构，其将排除任何主网络Tx。</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div class="fe ff oj"><img src="../Images/33908f80d9f56152e4793d98f7b40bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*9LrFrHJfBlrc5mYnpdk40w.png"/></div></figure><p id="4a68" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">此外，对于<strong class="jk hu">EC(E</strong>economic<strong class="jk hu">C</strong>光彩)和无线自组织网络，也有一些看法，因为后者将有<strong class="jk hu"> NBPoW (N </strong>网络<strong class="jk hu"> B </strong>环绕<strong class="jk hu"> P </strong>屋顶<strong class="jk hu"> W </strong>工作)来保护它。在物联网环境中，只有无线网络覆盖范围内的设备才能进行对等通信。</p><p id="6598" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果你继续关注CfB过去的对话以及他对这个PoW <em class="ki">的实现，“一个节点在某个时间间隔内占据某个范围的EM频谱的能力就是一种反Sybil措施。频谱是非常稀缺的资源(@FCC可以确认)……”</em></p><p id="8fb9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu"> ICT </strong>的目的和功能变得更加明确了。</p><figure class="kk kl km kn fq ko fe ff paragraph-image"><div class="fe ff ok"><img src="../Images/8be8b2d337cb7235a571d76c891e215a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*E0rgCqgIWux9ALWp64hbJg.png"/></div></figure></div><div class="ab cl mw mx hb my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hm hn ho hp hq"><p id="4bb9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这里的前两篇文章是<strong class="jk hu"> ICT </strong> side exploration:</p><div class="kv kw fm fo kx ky"><a rel="noopener follow" target="_blank" href="/coinmonks/exploring-iota-ict-1-running-ict-on-a-cloud-computer-bc3d96b246ea"><div class="kz ab ej"><div class="la ab lb cl cj lc"><h2 class="bd hu fv z el ld eo ep le er et hs dt translated">探索IOTA #ICT-1，在云计算机上测试ICT</h2><div class="lf l"><h3 class="bd b fv z el ld eo ep le er et ek translated">IOTA受控代理(ICT)已在官方discord渠道发布测试。我会告诉你如何运行…</h3></div><div class="lg l"><p class="bd b gc z el ld eo ep le er et ek translated">medium.com</p></div></div><div class="lh l"><div class="ol l lj lk ll lh lm kp ky"/></div></div></a></div><div class="kv kw fm fo kx ky"><a rel="noopener follow" target="_blank" href="/coinmonks/exploring-iota-ict-2-reverse-engineering-the-code-1-ecda56d4908"><div class="kz ab ej"><div class="la ab lb cl cj lc"><h2 class="bd hu fv z el ld eo ep le er et hs dt translated">探索IOTA ICT，逆向工程代码第1部分</h2><div class="lf l"><h3 class="bd b fv z el ld eo ep le er et ek translated">我们探索如何在公开的基于web的java反编译程序的帮助下反编译java源代码。然后…</h3></div><div class="lg l"><p class="bd b gc z el ld eo ep le er et ek translated">medium.com</p></div></div><div class="lh l"><div class="om l lj lk ll lh lm kp ky"/></div></div></a></div><p id="2f58" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果你喜欢自己探索IOTA，你可以从这里开始你的第一笔自助交易。</p><div class="kv kw fm fo kx ky"><a rel="noopener follow" target="_blank" href="/coinmonks/exploring-iota-1-getting-a-linux-terminal-on-cloud-google-com-and-sending-a-transaction-d7b9f1ce100a"><div class="kz ab ej"><div class="la ab lb cl cj lc"><h2 class="bd hu fv z el ld eo ep le er et hs dt translated">探索IOTA # 1——在google cloud上获得一个linux终端并发送一个事务</h2><div class="lf l"><h3 class="bd b fv z el ld eo ep le er et ek translated">这篇文章应该给你，不管你的工具和硬件，获得第一手的交易…</h3></div><div class="lg l"><p class="bd b gc z el ld eo ep le er et ek translated">medium.com</p></div></div><div class="lh l"><div class="on l lj lk ll lh lm kp ky"/></div></div></a></div><p id="b628" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">期待大家的评论、质疑和指正👍</p><p id="b0ad" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">干杯，<br/>陈安</p><blockquote class="oo"><p id="7e4c" class="op oq ht bd or os ot ou ov ow ox kd ek translated"><a class="ae mg" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="oz pa pb pc pd ko fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff oy"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>