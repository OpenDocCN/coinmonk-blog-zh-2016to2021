<html>
<head>
<title>A Box detection algorithm for any image containing boxes.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种适用于任何包含盒子的图像的盒子检测算法。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-box-detection-algorithm-for-any-image-containing-boxes-756c15d7ed26?source=collection_archive---------0-----------------------#2018-07-22">https://medium.com/coinmonks/a-box-detection-algorithm-for-any-image-containing-boxes-756c15d7ed26?source=collection_archive---------0-----------------------#2018-07-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="2e95" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当您处理光学字符识别(OCR)或任何数据或对象识别问题时，首先要做的是预处理。这里的预处理是指提取我们的信息所在的位置。提取位置后，任何机器算法都将在该图像上执行。</p><p id="5c2e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当您必须检测位于任何表格/框或行列格式中的对象时，问题就出现了。如果图像是这样的，那么你必须检测盒子并一个接一个地提取它们。现在，应该对所有图像进行精确处理。例如，请参见下图:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/071453db147a685f70b4faa2d2635519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*WbdgnoJtNDuTF2qmjVHVUg.jpeg"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Example of an image for extracting information.</figcaption></figure><p id="61cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这张图片中，我想对所有的等式进行光学字符识别。我想提取每个细胞一个接一个(不是任何空白)来检测数字。提取每个细胞后，我将对所有的数字进行分割，并应用我的ML模型进行识别。对于这个算法，我们将通过使用opencv和numpy来使用python语言。让我们开始一个一个地提取每个细胞:</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ka kb l"/></div></figure><p id="efba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先导入一些库:</p><pre class="jp jq jr js fq kc kd ke kf aw kg dt"><span id="2e36" class="kh ki ht kd b fv kj kk l kl km">import cv2<br/>import numpy as np</span></pre><p id="82fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在读取图像，将其转换为灰度，进行阈值处理并反转图像。</p><pre class="jp jq jr js fq kc kd ke kf aw kg dt"><span id="db02" class="kh ki ht kd b fv kj kk l kl km"># Read the image<br/>img = cv2.imread(img_for_box_extraction_path, 0)<br/> <br/># Thresholding the image<br/>(thresh, img_bin) = cv2.threshold(img, 128, 255,cv2.THRESH_BINARY|     cv2.THRESH_OTSU)</span><span id="49e8" class="kh ki ht kd b fv kn kk l kl km"># Invert the image<br/>img_bin = 255-img_bin <br/>cv2.imwrite("Image_bin.jpg",img_bin)</span></pre><p id="877b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以我们的图像看起来像这样:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/051258a4a16a5a529eddbadb2a895b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*1y4hcWFYc5Cr_slP8CUJAQ.jpeg"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">image_bin.jpg</figcaption></figure><p id="d55e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们需要检测盒子。为此，我们将使用形态学运算。为此，我们将根据图像的宽度来定义矩形核的长度。我们将定义两个内核。1)内核检测水平线。2)内核检测垂直线。</p><pre class="jp jq jr js fq kc kd ke kf aw kg dt"><span id="68fd" class="kh ki ht kd b fv kj kk l kl km"># Defining a kernel length<br/>kernel_length = np.array(img).shape[1]//80<br/> <br/># A verticle kernel of (1 X kernel_length), which will detect all the verticle lines from the image.<br/>verticle_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, kernel_length))</span><span id="3b46" class="kh ki ht kd b fv kn kk l kl km"># A horizontal kernel of (kernel_length X 1), which will help to detect all the horizontal line from the image.<br/>hori_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (kernel_length, 1))</span><span id="1e4a" class="kh ki ht kd b fv kn kk l kl km"># A kernel of (3 X 3) ones.<br/>kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))</span></pre><p id="9c70" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，在定义了内核之后，我们将进行形态学操作来检测垂直线和水平线。下面的代码显示了包含垂直线的图像。</p><pre class="jp jq jr js fq kc kd ke kf aw kg dt"><span id="369e" class="kh ki ht kd b fv kj kk l kl km"># Morphological operation to detect vertical lines from an image<br/>img_temp1 = cv2.erode(img_bin, verticle_kernel, iterations=3)<br/>verticle_lines_img = cv2.dilate(img_temp1, verticle_kernel, iterations=3)<br/>cv2.imwrite("verticle_lines.jpg",verticle_lines_img)</span><span id="a51f" class="kh ki ht kd b fv kn kk l kl km"># Morphological operation to detect horizontal lines from an image<br/>img_temp2 = cv2.erode(img_bin, hori_kernel, iterations=3)<br/>horizontal_lines_img = cv2.dilate(img_temp2, hori_kernel, iterations=3)<br/>cv2.imwrite("horizontal_lines.jpg",horizontal_lines_img)</span></pre><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/82b1dc01d6643b271ed5ce3eaddda294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*uSKlfvhKABhvXeJx1Ygz9g.jpeg"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Image containing vertical lines</figcaption></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/4ef9129d9522d3ba26fca4737e576221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*EMDD_nPZyHOb4GuHU4ZeXw.jpeg"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Image containing horizontal lines</figcaption></figure><p id="39b9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们将添加这两个图像。这将只有盒子，写在盒子里的信息将被删除。因此，我们可以准确地检测到盒子，并且不会出现错误的盒子提取噪声。</p><pre class="jp jq jr js fq kc kd ke kf aw kg dt"><span id="cd1a" class="kh ki ht kd b fv kj kk l kl km"># Weighting parameters, this will decide the quantity of an image to be added to make a new image.<br/>alpha = 0.5<br/>beta = 1.0 - alpha</span><span id="fc58" class="kh ki ht kd b fv kn kk l kl km"># This function helps to add two image with specific weight parameter to get a third image as summation of two image.<br/>img_final_bin = cv2.addWeighted(verticle_lines_img, alpha, horizontal_lines_img, beta, 0.0)<br/>img_final_bin = cv2.erode(~img_final_bin, kernel, iterations=2)<br/>(thresh, img_final_bin) = cv2.threshold(img_final_bin, 128,255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)<br/>cv2.imwrite("img_final_bin.jpg",img_final_bin)Thank</span></pre><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/4b71530002e6097e23d385a2572cbbd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*Q3pRWrS7Cx5U9MPs-UmDOg.jpeg"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Final image containing only boxes</figcaption></figure><p id="c5f2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们将应用findContours()方法到这个图像。这将找到所有的盒子，我们将从上到下对它们进行排序。为了对轮廓进行排序，我们将使用<a class="ae ko" href="https://www.pyimagesearch.com/2015/04/20/sorting-contours-using-python-and-opencv/" rel="noopener ugc nofollow" target="_blank">https://www . pyimagesearch . com/2015/04/20/sorting-contours-using-python-and-opencv/</a>提供的函数。我们将使用自上而下的方法。</p><pre class="jp jq jr js fq kc kd ke kf aw kg dt"><span id="a362" class="kh ki ht kd b fv kj kk l kl km"># Find contours for image, which will detect all the boxes<br/>im2, contours, hierarchy = cv2.findContours(img_final_bin, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><span id="5636" class="kh ki ht kd b fv kn kk l kl km"># Sort all the contours by top to bottom.<br/>(contours, boundingBoxes) = sort_contours(contours, method="top-to-bottom")</span></pre><p id="afa1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在循环所有的轮廓，找到所有盒子的位置，裁剪出有矩形的部分，保存到一个文件夹中。</p><pre class="jp jq jr js fq kc kd ke kf aw kg dt"><span id="83ed" class="kh ki ht kd b fv kj kk l kl km">idx = 0<br/>    for c in contours:<br/>        # Returns the location and width,height for every contour<br/>        x, y, w, h = cv2.boundingRect(c)<br/>        if (w &gt; 80 and h &gt; 20) and w &gt; 3*h:<br/>            idx += 1<br/>            new_img = img[y:y+h, x:x+w]<br/>            cv2.imwrite(cropped_dir_path+str(idx) + '.png', new_img)</span><span id="3b37" class="kh ki ht kd b fv kn kk l kl km"># If the box height is greater then 20, widht is &gt;80, then only save it as a box in "cropped/" folder.<br/>        if (w &gt; 80 and h &gt; 20) and w &gt; 3*h:<br/>            idx += 1<br/>            new_img = img[y:y+h, x:x+w]<br/>            cv2.imwrite(cropped_dir_path+str(idx) + '.png', new_img)</span></pre><p id="344e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在完成了！。检查你的文件夹，你会看到包含每个提取框的图像。像这样:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff kp"><img src="../Images/1fdc7e9c6e2a5b2ffee4bce84b75bbd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*GWJe2l9f6TpRh6rTdIxf2g.png"/></div></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/837bd88eaaa75797995b9107381aac62.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*eiuFA-VnmKHwEawt0pO1QA.png"/></div></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/c8f8c477797d5dc008403faaea96fcc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*yqKGDK8z-iG-mfuPMB9w4A.png"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Extracted images</figcaption></figure><p id="8b31" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，现在您可以使用这些图像进行进一步的实现。您可以通过增加来更改kernel_length参数，以便在非常大的图像中获得良好的输出。</p><p id="3ba4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="kr">注:</em> </strong>该方法适用于任何地方，检测从OMR表到任何excel表的数据。这种方法使用正常的形态学操作，并且它擦除了所有的内部信息，因此不会有噪声进入盒子的错误检测。您可以使用下面的方法作为预处理，并获得良好的输出。:)</p><p id="1501" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">盒子检测的完整代码在这里:</p><pre class="jp jq jr js fq kc kd ke kf aw kg dt"><span id="9bf4" class="kh ki ht kd b fv kj kk l kl km">import cv2<br/>import numpy as npThank</span><span id="7dbf" class="kh ki ht kd b fv kn kk l kl km">def box_extraction(img_for_box_extraction_path, cropped_dir_path):</span><span id="98f5" class="kh ki ht kd b fv kn kk l kl km">img = cv2.imread(img_for_box_extraction_path, 0)  # Read the image<br/>    (thresh, img_bin) = cv2.threshold(img, 128, 255,<br/>                                      cv2.THRESH_BINARY | cv2.THRESH_OTSU)  # Thresholding the image<br/>    img_bin = 255-img_bin  # Invert the image</span><span id="daee" class="kh ki ht kd b fv kn kk l kl km">cv2.imwrite("Image_bin.jpg",img_bin)<br/>   <br/>    # Defining a kernel length<br/>    kernel_length = np.array(img).shape[1]//40<br/>     <br/>    # A verticle kernel of (1 X kernel_length), which will detect all the verticle lines from the image.<br/>    verticle_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, kernel_length))<br/>    # A horizontal kernel of (kernel_length X 1), which will help to detect all the horizontal line from the image.<br/>    hori_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (kernel_length, 1))<br/>    # A kernel of (3 X 3) ones.<br/>    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))</span><span id="a525" class="kh ki ht kd b fv kn kk l kl km"># Morphological operation to detect verticle lines from an image<br/>    img_temp1 = cv2.erode(img_bin, verticle_kernel, iterations=3)<br/>    verticle_lines_img = cv2.dilate(img_temp1, verticle_kernel, iterations=3)<br/>    cv2.imwrite("verticle_lines.jpg",verticle_lines_img)</span><span id="e7e5" class="kh ki ht kd b fv kn kk l kl km"># Morphological operation to detect horizontal lines from an image<br/>    img_temp2 = cv2.erode(img_bin, hori_kernel, iterations=3)<br/>    horizontal_lines_img = cv2.dilate(img_temp2, hori_kernel, iterations=3)<br/>    cv2.imwrite("horizontal_lines.jpg",horizontal_lines_img)</span><span id="a782" class="kh ki ht kd b fv kn kk l kl km"># Weighting parameters, this will decide the quantity of an image to be added to make a new image.<br/>    alpha = 0.5<br/>    beta = 1.0 - alpha<br/>    # This function helps to add two image with specific weight parameter to get a third image as summation of two image.<br/>    img_final_bin = cv2.addWeighted(verticle_lines_img, alpha, horizontal_lines_img, beta, 0.0)<br/>    img_final_bin = cv2.erode(~img_final_bin, kernel, iterations=2)<br/>    (thresh, img_final_bin) = cv2.threshold(img_final_bin, 128, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)</span><span id="9b6c" class="kh ki ht kd b fv kn kk l kl km"># For Debugging<br/>    # Enable this line to see verticle and horizontal lines in the image which is used to find boxes<br/>    cv2.imwrite("img_final_bin.jpg",img_final_bin)<br/>    # Find contours for image, which will detect all the boxes<br/>    im2, contours, hierarchy = cv2.findContours(<br/>        img_final_bin, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)<br/>    # Sort all the contours by top to bottom.<br/>    (contours, boundingBoxes) = sort_contours(contours, method="top-to-bottom")</span><span id="3706" class="kh ki ht kd b fv kn kk l kl km">idx = 0<br/>    for c in contours:<br/>        # Returns the location and width,height for every contour<br/>        x, y, w, h = cv2.boundingRect(c)</span><span id="0390" class="kh ki ht kd b fv kn kk l kl km"># If the box height is greater then 20, widht is &gt;80, then only save it as a box in "cropped/" folder.<br/>        if (w &gt; 80 and h &gt; 20) and w &gt; 3*h:<br/>            idx += 1<br/>            new_img = img[y:y+h, x:x+w]<br/>            cv2.imwrite(cropped_dir_path+str(idx) + '.png', new_img)</span><span id="b24e" class="kh ki ht kd b fv kn kk l kl km">box_extraction("41.jpg", "./Cropped/")</span></pre><p id="5890" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你可以在这里看到完整的源代码:</p><div class="ks kt fm fo ku kv"><a href="https://github.com/KananVyas/BoxDetection" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab ej"><div class="kx ab ky cl cj kz"><h2 class="bd hu fv z el la eo ep lb er et hs dt translated">KananVyas/BoxDetection</h2><div class="lc l"><h3 class="bd b fv z el la eo ep lb er et ek translated">一个用于任何包含盒子的图像的盒子检测算法。</h3></div><div class="ld l"><p class="bd b gc z el la eo ep lb er et ek translated">github.com</p></div></div><div class="le l"><div class="lf l lg lh li le lj ju kv"/></div></div></a></div><p id="3d32" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">谢谢大家！</p><blockquote class="lk"><p id="13fe" class="ll lm ht bd ln lo lp lq lr ls lt jn ek translated">加入Coinmonks <a class="ae ko" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ko" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae ko" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="kh ki ht bd lu lv lw lx ly lz ma mb mc jb md me mf jf mg mh mi jj mj mk ml mm dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="mn mo ht is b it mp ix mq jb mr jf ms jj mt jn mu mv mw mx dt translated"><a class="ae ko" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae ko" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="14e6" class="mn mo ht is b it my ix mz jb na jf nb jj nc jn mu mv mw mx dt translated"><a class="ae ko" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae ko" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="mn mo ht is b it my ix mz jb na jf nb jj nc jn mu mv mw mx dt translated"><a class="ae ko" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae ko" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="f33b" class="mn mo ht is b it my ix mz jb na jf nb jj nc jn mu mv mw mx dt translated"><a class="ae ko" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">加密交换</a> | <a class="ae ko" rel="noopener" href="/coinmonks/buy-bitcoin-in-india-feb50ddfef94">印度的加密应用</a></li><li id="47a8" class="mn mo ht is b it my ix mz jb na jf nb jj nc jn mu mv mw mx dt translated">开发人员的最佳加密API</li><li id="c5cd" class="mn mo ht is b it my ix mz jb na jf nb jj nc jn mu mv mw mx dt translated">最佳<a class="ae ko" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">加密贷款平台</a></li></ul></div></div>    
</body>
</html>