<html>
<head>
<title>Implementing Merkle Tree and Patricia Trie</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现Merkle树和Patricia Trie</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/implementing-merkle-tree-and-patricia-trie-b8badd6d9591?source=collection_archive---------0-----------------------#2020-03-10">https://medium.com/coinmonks/implementing-merkle-tree-and-patricia-trie-b8badd6d9591?source=collection_archive---------0-----------------------#2020-03-10</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="e539" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">本文涵盖了Merkle Tree和Patricia Trie在Node.js中的实现，还涵盖了这两种数据结构的一些理论方面。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/dad4756ef91c97f24db204f81aecf0e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2fvmjCzu8wQQ4ta9EHEkMA.jpeg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Photo by <a class="ae jy" href="https://unsplash.com/@jeremybishop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jeremy Bishop</a> on <a class="ae jy" href="https://unsplash.com/s/photos/tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6e10" class="jz ka ht bd kb kc kd ke kf kg kh ki kj iz kk ja kl jc km jd kn jf ko jg kp kq dt translated">介绍</h1><p id="f39c" class="pw-post-body-paragraph kr ks ht kt b ku kv iu kw kx ky ix kz la lb lc ld le lf lg lh li lj lk ll lm hm dt translated">Merkle和Patricia是以太坊区块链中最常用的两种数据结构，布隆过滤器紧随其后。在这篇文章中，我将涵盖以下内容:</p><ol class=""><li id="14ab" class="ln lo ht kt b ku lp kx lq la lr le ls li lt lm lu lv lw lx dt translated">关于默克尔树和帕特里夏尝试</li><li id="63fe" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">算法</li><li id="cf30" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">Node.js中的实现</li></ol></div><div class="ab cl md me hb mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hm hn ho hp hq"><h1 id="6d0b" class="jz ka ht bd kb kc mk ke kf kg ml ki kj iz mm ja kl jc mn jd kn jf mo jg kp kq dt translated">默克尔树</h1><p id="5c67" class="pw-post-body-paragraph kr ks ht kt b ku kv iu kw kx ky ix kz la lb lc ld le lf lg lh li lj lk ll lm hm dt translated">默克尔树不是计算机科学中的新概念，它已经存在了几十年，起源于密码学领域。</p><p id="8b72" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">简而言之，默克尔树本质上是一种树数据结构，其中数据存储在叶节点中，非叶节点存储数据的散列，每个非叶节点是其下两个节点的组合散列值。</p><p id="fc2e" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">数学上，它可以表示为</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/298d712633c52e8aa7639057b3ddafb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*8QaHU1UGOfJWLNPVoyMy0w.jpeg"/></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Computing the value of each node in a Merkel Tree</figcaption></figure><p id="7228" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated"><strong class="kt hu">例如:</strong>给定一个字母表，从中创建一个默克尔树。</p><p id="ef84" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">树的最底层将包含所有字母作为叶节点。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mt"><img src="../Images/a2739829f1420a2e9130d222870b2cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Z7r4Gfjnl_wcMkDcFEWeg.jpeg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Lowest layer of the tree would contain the data in each node</figcaption></figure><p id="a6ef" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">上面的层包含它的哈希值。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mu"><img src="../Images/4cddc5ca5653bc732ae91ccde38c2fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T75YmaGKr3Rkoc8FjDcxIA.jpeg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">The layer above the leaf node has the hash values of leaf node data</figcaption></figure><p id="f0e4" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">第二层之后的层中的节点包含子节点的哈希值。通常，我们从第二层中取出两个节点，并将它们组合起来形成另一个节点。我们也可以采用两个以上的节点，但二进制默克尔树是其中最简单的，增加节点的度数只会增加计算和算法的复杂性。</p><p id="fb48" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">如果我们有偶数个节点，我们取2个连续的节点并形成父层。但是如果我们有奇数个节点，我们取两个连续的节点，直到剩下一个来形成父层，然后我们通过将散列复制到父层来重复剩余的节点。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mv"><img src="../Images/00795ebe0d579223d464c06a0245a5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pteLSEjj_AyxurpqPhN8bA.jpeg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Layer 3 has the hash of the values of the 2 consecutive nodes of layer 2 and in case we have odd nodes in a layer the last node is repeated</figcaption></figure><p id="76ab" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">类似地，使用第三层的值形成第四层。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mw"><img src="../Images/4f7de2896c40a446ac2b779261921243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HcGy-UdgGvhg-mFG78VXEQ.jpeg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">The fourth layer is formed by the hash of the values of the 2 consecutive nodes of layer 2</figcaption></figure><p id="e095" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">最后一层或Merkel树的根由最顶层剩余的最后两个节点的散列值形成。在任何情况下，奇数或偶数叶节点，我们总是在最顶层有两个节点。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mx"><img src="../Images/d6988c9960b3568c2383196d58ec0fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdTlPP6LQk_qlhzKP5V7OQ.jpeg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Merkel Tree formed by the five letters</figcaption></figure><h2 id="5214" class="my ka ht bd kb mz na nb kf nc nd ne kj la nf ng kl le nh ni kn li nj nk kp nl dt translated">确认</h2><p id="2502" class="pw-post-body-paragraph kr ks ht kt b ku kv iu kw kx ky ix kz la lb lc ld le lf lg lh li lj lk ll lm hm dt translated">默克尔树的重要性在于其高效验证数据的能力。给定列表中的任何数据，我们可以在<em class="nm"> O(h) </em>时间复杂度中验证该数据是否有效。此外，我们不需要整个名单来核实。</p><p id="d04f" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">默克尔树的一种更简单的形式是散列链或简单的<a class="ae jy" href="https://blog.coincodecap.com/tag/blockchain/" rel="noopener ugc nofollow" target="_blank">区块链</a>，其中每个节点都有前一个节点值的散列。如果我们篡改中间的任何节点，我们可以在<em class="nm"> O(n) </em>时间内识别该节点是否被篡改。哈希链中的验证可以通过计算所有节点的哈希来执行，从所讨论的节点开始，直到结束。在需要验证多个节点的情况下，我们从所有可疑节点中第一个节点开始，然后计算最后一个节点的哈希。现在我们有了最后一个节点的散列，我们可以比较并检查这个散列是否匹配。散列链看起来很简单，但对于大型数据对象来说并不是一个有效的选择。因为我们需要整个链实际存在来验证数据，这也使得散列链空间效率低下。</p><p id="a2e2" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">默克尔树中的验证却不是这样。为了说明验证过程，考虑下面的例子。</p><p id="a54a" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated"><em class="nm">假设我从另一台服务器收到一个数据C。假设这是C。我们想验证C '没有被篡改。我们拥有列表中所有数据的默克尔树。</em></p><p id="514f" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">在散列链的情况下，我们需要整个数据列表来验证C '是正确的。在默克尔树中，我们只需要哈希值。下图说明了在没有其他可用数据对象情况下，我们如何验证C'。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/5993b84de500dcf502f0cb6ed260f563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*HwZtuEwJVDvEJio4OOCKpw.jpeg"/></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Verifying C’ by hashing all the nodes that lead us to the root</figcaption></figure><ol class=""><li id="4974" class="ln lo ht kt b ku lp kx lq la lr le ls li lt lm lu lv lw lx dt translated">找到C '在列表中的位置。大概是通过id搜索。</li><li id="18e6" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">计算C '的散列值</li><li id="fb72" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">通过将当前节点与其邻居(如果位置为奇数，则为下一个，如果位置为偶数，则为上一个)进行哈希运算来计算父节点的值，并将父节点设置为当前节点。</li><li id="f41e" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">重复步骤3，直到我们找到根</li><li id="3132" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">将该根与前一根进行比较，如果它们匹配，则C '</li></ol><p id="a1d3" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">将新根与现有根进行比较。如果新的根匹配，那么C '本质上是C，没有被篡改。</p><p id="6d6e" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">为了验证哈希链中的数据，我们需要<em class="nm"> O(n) </em>时间，因为我们将在最坏的情况下计算<em class="nm"> n </em>个哈希，而在默克尔树的情况下，相同的数据可以在<em class="nm"> O(logn) </em>时间内验证，因为我们只计算<em class="nm"> logn </em>个哈希。</p><h2 id="d93e" class="my ka ht bd kb mz na nb kf nc nd ne kj la nf ng kl le nh ni kn li nj nk kp nl dt translated">算法</h2><p id="367f" class="pw-post-body-paragraph kr ks ht kt b ku kv iu kw kx ky ix kz la lb lc ld le lf lg lh li lj lk ll lm hm dt translated">本节以数学形式描述了用于在默克尔树中创建和验证的算法。</p><p id="e8bb" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated"><strong class="kt hu">创作</strong></p><p id="722c" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">如前所述，默克尔树是通过从每层取两个节点并散列它们以创建父节点来创建的。通过以矩阵形式表示该树，我们可以用数学方法将其写为:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff no"><img src="../Images/1c3f3f0541d25f0b4e22056f55065317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EA7FYersQE_oS6SLBuxlNQ.jpeg"/></div></div></figure><p id="561c" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated"><em class="nm">这使得树根在树[0][0] </em>处可用</p><p id="bab5" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated"><strong class="kt hu">验证</strong></p><p id="a8d4" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">验证是一种自下而上的方法，我们从数据开始，找到它的哈希，计算父项，并继续下去，直到找到根。数学上，我们可以表达如下:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff np"><img src="../Images/4fc112c1f2146602330e715cce08814d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gGD-kH3a1_CoYeHyYLeodA.jpeg"/></div></div></figure><h2 id="3d40" class="my ka ht bd kb mz na nb kf nc nd ne kj la nf ng kl le nh ni kn li nj nk kp nl dt translated"><strong class="ak">实施</strong></h2><p id="a7f1" class="pw-post-body-paragraph kr ks ht kt b ku kv iu kw kx ky ix kz la lb lc ld le lf lg lh li lj lk ll lm hm dt translated">我们将在Node.js中实现一个默克尔树</p><p id="d220" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated"><strong class="kt hu">先决条件</strong></p><ol class=""><li id="f4e8" class="ln lo ht kt b ku lp kx lq la lr le ls li lt lm lu lv lw lx dt translated">节点. js</li><li id="9f95" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">VS代码</li><li id="9da7" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">咖啡</li></ol><p id="213e" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated"><strong class="kt hu">代码</strong></p><p id="956c" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">创建您的项目目录并放入cd。</p><pre class="jj jk jl jm fq nq nr ns nt aw nu dt"><span id="7463" class="my ka ht nr b fv nv nw l nx ny">mkdir merkel-and-patricia &amp;&amp; cd merkel-and-patricia</span></pre><p id="ff67" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">打开此目录中的VS代码</p><pre class="jj jk jl jm fq nq nr ns nt aw nu dt"><span id="5cc2" class="my ka ht nr b fv nv nw l nx ny">code .</span></pre><p id="1f1f" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">在实现我们的之前，我们需要创建一个函数来散列数据。因此，创建一个名为<code class="eh nz oa ob nr b">helper.js</code>的文件，并在其中包含以下代码。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="6075" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">我们将使用这个文件在项目的其余部分散列我们的数据。接下来，我们将创建我们的事务类。</p><p id="39ac" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">事务类将包含以下属性:</p><ol class=""><li id="439b" class="ln lo ht kt b ku lp kx lq la lr le ls li lt lm lu lv lw lx dt translated">到</li><li id="17d8" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">从</li><li id="4cf0" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">数量</li><li id="21a6" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">身份证明（identification）</li><li id="86cf" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">混杂</li></ol><p id="0b63" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">创建一个文件<code class="eh nz oa ob nr b">Transaction.js</code>，并在其中添加以下代码。</p><p id="94e0" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated"><strong class="kt hu">待办事项</strong>:交易类</p><p id="c45b" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">函数<code class="eh nz oa ob nr b">getCount</code>和<code class="eh nz oa ob nr b">incrementCount</code>用于为交易提供一个id。<em class="nm">你可以用uuids来代替这个。</em></p><p id="7fb1" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">为了存储所有的事务，我们将创建一个包含一系列事务的事务列表类。</p><p id="51b4" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">创建一个文件<code class="eh nz oa ob nr b">TransactionList.js</code>，并在其中添加以下代码。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="a987" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">我们有散列函数和数据。让我们实现默克尔树。</p><p id="36de" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">创建一个名为<code class="eh nz oa ob nr b">MerkelTree.js</code>的文件，并创建一个只有属性<code class="eh nz oa ob nr b">root</code>的MerkelTree类，这个属性是保存整个树的矩阵。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="19b9" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">在这个类中，创建一个名为<code class="eh nz oa ob nr b">createTree</code>的方法，它只接受参数TransactionList实例，并从中创建一个默克尔树。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="9fdb" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated"><code class="eh nz oa ob nr b">createTree</code>方法将首先把<code class="eh nz oa ob nr b">transactionList</code>添加到最底层，事务散列就在它们上面。接下来，它将从最顶层取出两个项目，并将它们散列在一起并保存在临时列表中，直到覆盖了所有项目，如果只剩下一个项目，则将它直接推入临时数组，并将临时列表<code class="eh nz oa ob nr b">temp</code>添加到<code class="eh nz oa ob nr b">root</code>的开头。重复该过程，直到根的第一个项目的长度等于1，这将表明我们已经找到了根散列。</p><p id="9f94" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">现在我们已经创建了一棵树。让我们编写一个方法来验证事务。</p><p id="a20c" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">验证将使用上述相同的算法，取相邻节点和要验证的节点，对它们进行哈希运算，然后移至父层，执行相同的操作，但要验证的节点将使用我们之前计算的哈希。</p><p id="58a6" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">在merkel树类中创建一个函数<code class="eh nz oa ob nr b">verfiy</code>,采用单个参数，一个事务。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="a92f" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">我们的MerkleTree类完成了。下面是该类的完整代码。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="b701" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">为了测试功能，在根目录中创建一个js文件，将其命名为<code class="eh nz oa ob nr b">test.js</code>，并在其中添加以下代码。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="33d5" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">它应该打印以下输出:</p><pre class="jj jk jl jm fq nq nr ns nt aw nu dt"><span id="24de" class="my ka ht nr b fv nv nw l nx ny">Element found at: 2<br/>Valid<br/>Element found at: 2<br/>Not Valid</span></pre><p id="c25d" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">您可以取消控制台日志的注释，以打印整个根事务和被篡改的事务。</p><p id="6c8f" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">这就完成了关于默克尔树的部分。下一位是帕特丽夏·特里。</p></div><div class="ab cl md me hb mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hm hn ho hp hq"><h1 id="c865" class="jz ka ht bd kb kc mk ke kf kg ml ki kj iz mm ja kl jc mn jd kn jf mo jg kp kq dt translated">帕特丽夏试图</h1><p id="63e7" class="pw-post-body-paragraph kr ks ht kt b ku kv iu kw kx ky ix kz la lb lc ld le lf lg lh li lj lk ll lm hm dt translated">Patricia树是n叉树，与Merkel树不同，它用于存储数据而不是验证。</p><p id="555e" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">简单地说，Patricia Tries是一种树形数据结构，其中所有数据都存储在叶节点中，其中每个非叶节点都是标识数据的唯一字符串中的一个字符。使用唯一的字符串，我们通过字符节点导航，最终到达数据。</p><p id="5562" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated"><strong class="kt hu"> <em class="nm"> Patricia Trie就像一个散列表，但有一些细微的区别。</em> </strong></p><p id="75f8" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">让我们看一个例子。考虑以下词语:</p><p id="9c00" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated"><em class="nm">猫，猫，汽车，狗，狗狗，狗狗，蚂蚁</em></p><p id="2810" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">存储这些项目的patricia trie将如下所示:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff oe"><img src="../Images/9b930bea3464759c4edffedb5c5d2c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*aFObxyazYJ4nDhUN6mNApQ.jpeg"/></div></figure><p id="47ad" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">值为<strong class="kt hu"> END </strong>的节点表示到目前为止遍历的路径实际上是一个单词。那些没有<strong class="kt hu"> END </strong>子节点的节点表示该单词不存在。</p><p id="cd20" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">例如，在上图中，单词<strong class="kt hu"> ANT </strong>出现在trie中，因为“T”后面有<strong class="kt hu"> END </strong>节点。类似地，对于<strong class="kt hu"> CATS </strong>，结束节点出现在S之后，这使得它成为trie中的一个单词。有趣的是，如果我们像CAT一样在前面放一个END节点，我们将有两个单词存储在同一个路径中，但是我们可以通过不遍历到底部并检查END是否存在于两者之间来访问CAT。</p><p id="cecd" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">狗狗、DOGS和狗狗也是如此。对于DOG，我们将只有一个返回值，因为它有一个结束节点。但是如果我们用DOG作为前缀搜索patricia，我们将得到三个返回值。也就是说，这里使用深度优先搜索。</p><p id="4491" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated"><a class="ae jy" href="https://blog.coincodecap.com/tag/ethereum/" rel="noopener ugc nofollow" target="_blank">以太坊</a>使用Patricia tries来存储块中的交易、交易收据和维护网络状态。</p><h2 id="a700" class="my ka ht bd kb mz na nb kf nc nd ne kj la nf ng kl le nh ni kn li nj nk kp nl dt translated">储存；储备</h2><p id="db35" class="pw-post-body-paragraph kr ks ht kt b ku kv iu kw kx ky ix kz la lb lc ld le lf lg lh li lj lk ll lm hm dt translated">对于存储数据对象，我们不需要像单词那样的前缀。由于我们的数据对象要么是事务，要么是块，我们用来在trie中存储数据的所有“唯一字符串”都是事务散列或块散列，长度总是相同的，所以我们不需要担心前缀。</p><p id="ad99" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">如果我们为事务创建一个Patricia trie，它应该如下所示，尽管要大得多:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff of"><img src="../Images/dfbc9bd160c33ac6835a900ce75e3eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NR4IizqvH6wC4wEY6dqidQ.jpeg"/></div></div></figure><p id="a47b" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">每个事务散列将包含数字或字符(取决于算法)。对于sha256，我们将使用32个字符长的哈希。如果我们假设散列只由0–9和A-Z组成，那么patricia trie中的每个节点将有35个子节点。从根开始，我们将向下遍历，同时将每个字符与节点值进行匹配，直到获得事务数据对象为止。</p><h2 id="e0d0" class="my ka ht bd kb mz na nb kf nc nd ne kj la nf ng kl le nh ni kn li nj nk kp nl dt translated">算法</h2><p id="2ac7" class="pw-post-body-paragraph kr ks ht kt b ku kv iu kw kx ky ix kz la lb lc ld le lf lg lh li lj lk ll lm hm dt translated">我们可以说，trie中的每个节点本身就是一个哈希表，它将一个字符作为键，将另一个哈希表作为值。所有的操作、插入、删除和访问都需要花费<em class="nm"> O(h) </em>，其中<em class="nm"> h </em>是哈希的长度或者在我们的例子中是树的深度。</p><p id="8929" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">通过使用这个定义，我们可以编写以下算法来将数据存储在trie中:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff og"><img src="../Images/ad851279716f969aba8ae971621eb2a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*OWgVNxF1Xe2JOE_rzJgXvw.jpeg"/></div></figure><p id="97f1" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">在这个算法中，我们创建一个空的键-值对对象，遍历散列的整个长度，并将每个字符集的值作为一个新的empyt键-值对对象。同样，对于每个字符，我们将curr映射设置为下一个映射。最后，当我们创建了整个分支后，我们用最后一个节点键“data”来设置最后的数据。</p><p id="f3fe" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">在访问时，我们返回键“数据”的最后一个映射的值，在删除时，我们只删除给定散列的叶节点。</p><h2 id="cd81" class="my ka ht bd kb mz na nb kf nc nd ne kj la nf ng kl le nh ni kn li nj nk kp nl dt translated"><strong class="ak">实施</strong></h2><p id="e00b" class="pw-post-body-paragraph kr ks ht kt b ku kv iu kw kx ky ix kz la lb lc ld le lf lg lh li lj lk ll lm hm dt translated">本节提供了在Node.js中实现上述Patricia Trie算法。创建一个文件<code class="eh nz oa ob nr b">PatriciTrie.js</code>并在其中添加以下代码。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="d319" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">方法<code class="eh nz oa ob nr b">add, get</code>和<code class="eh nz oa ob nr b">remove</code>顾名思义，分别向trie树插入事务、从trie树访问事务和从trie树删除事务。</p><p id="1245" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">让我们测试一下这个功能。将以下内容添加到我们之前创建的<code class="eh nz oa ob nr b">test.js</code>文件中。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oc od l"/></div></figure><p id="311b" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">运行这个文件，您应该会得到类似于下面的输出:</p><pre class="jj jk jl jm fq nq nr ns nt aw nu dt"><span id="adf9" class="my ka ht nr b fv nv nw l nx ny">$ node test<br/>Transaction {<br/>  to: 0.01106239432861833,<br/>  from: 0.774577364867872,<br/>  amount: 0.7140173399739937,<br/>  id: 0,<br/>  hash:<br/>   'e4bc0c48be1ad748af6dbc714ddf49d3b76643a491d068a5f1494c84b54971ad' }     <br/>true<br/>null<br/>null<br/>false</span></pre><p id="a9df" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">这就完成了帕特丽夏尝试的部分。</p><h1 id="8b94" class="jz ka ht bd kb kc kd ke kf kg kh ki kj iz kk ja kl jc km jd kn jf ko jg kp kq dt translated">延长</h1><p id="a580" class="pw-post-body-paragraph kr ks ht kt b ku kv iu kw kx ky ix kz la lb lc ld le lf lg lh li lj lk ll lm hm dt translated">您可以通过实现以下内容来进一步扩展此项目:</p><ol class=""><li id="b1a6" class="ln lo ht kt b ku lp kx lq la lr le ls li lt lm lu lv lw lx dt translated">实施区块链与默克尔树和帕特里夏尝试。</li><li id="c4bb" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">使用Patricia Trie实现状态。</li><li id="7299" class="ln lo ht kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx dt translated">在<a class="ae jy" href="https://blog.coincodecap.com/tag/blockchain/" rel="noopener ugc nofollow" target="_blank">区块链</a>以外的区域测试两种数据结构的工作情况。</li></ol></div><div class="ab cl md me hb mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hm hn ho hp hq"><p id="d240" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated">在本文中，我们实现了一个在<a class="ae jy" href="https://blog.coincodecap.com/tag/ethereum/" rel="noopener ugc nofollow" target="_blank">以太坊</a>中使用的基本Merkel树和Patricia Trie。<strong class="kt hu">文章的代码可以在我的</strong> <a class="ae jy" href="https://github.com/kashishkhullar/merkel-and-patricia" rel="noopener ugc nofollow" target="_blank"> <strong class="kt hu"> github资源库</strong> </a> <strong class="kt hu">中找到。</strong></p><p id="2f90" class="pw-post-body-paragraph kr ks ht kt b ku lp iu kw kx lq ix kz la mp lc ld le mq lg lh li mr lk ll lm hm dt translated"><em class="nm">感谢您阅读本文。如果你对这篇文章有任何问题，请留下评论，如果你喜欢它，请鼓掌。</em></p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff oh"><img src="../Images/e9dbce386c4f90837b5db529a4c87766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fZu_SfnNF6m_BGbXlsl-A@2x.png"/></div></a></figure><blockquote class="oi"><p id="0626" class="oj ok ht bd ol om on oo op oq or lm ek translated"><a class="ae jy" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="ot ou ov ow ox jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff os"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>