<html>
<head>
<title>Compile Solidity Smart Contract for AION on a non Ubuntu OS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在非Ubuntu操作系统上为AION编译Solidity Smart契约</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/compile-solidity-smart-contract-for-aion-on-a-non-ubuntu-os-8aa5dba21dd8?source=collection_archive---------7-----------------------#2018-10-19">https://medium.com/coinmonks/compile-solidity-smart-contract-for-aion-on-a-non-ubuntu-os-8aa5dba21dd8?source=collection_archive---------7-----------------------#2018-10-19</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="3c4a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">AION区块链节点目前仅在Ubuntu 16.04或更高版本上受支持。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/48f3aaf75938f7ee366ec59a103425b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*R_guLBxOq-I8uPF4oqcHMg.png"/></div></figure><p id="b056" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，如果您是智能合约开发人员，并且使用其他操作系统，如Mac OS、Windows或其他Linux版本，您必须使用web3或Java RPC调用进行智能合约编译。</p><p id="6043" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">另一个选择是，泰坦套件IDE【https://titan-suite.com/】<a class="ae jo" href="https://titan-suite.com/" rel="noopener ugc nofollow" target="_blank">(T3)，它提供了一个基于浏览器的编辑器。这是一个nodeJS应用程序，您需要提供一个指向AION内核的web3 rpc端点。</a></p><p id="2901" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是，如果您喜欢在不受支持的平台上从命令行编译您的智能合约，并且不连接到AION内核，有一种方法可以做到这一点。</p><p id="6ff7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你可以使用docker image来实现。我用Ubuntu 16.04和aion fastvm (0.3.1) + solidity创建了一个轻量级docker映像。<br/>让我来解释一下怎么做。</p><p id="af3e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">先决条件:</strong> <br/> &gt;安装Docker引擎<br/> &gt;启动Docker守护进程。</p><p id="54e1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">步骤:(一次流程)</strong></p><p id="d3f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">&gt;从docker Hub获取AION fastvm和solidity编译器所需的Docker映像。</p><pre class="jq jr js jt fq jx jy jz ka aw kb dt"><span id="37d7" class="kc kd ht jy b fv ke kf l kg kh">$&gt; docker pull satran004/aion-fastvm:0.3.1</span></pre><p id="f1cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">&gt;为docker命令创建一个别名，该命令将用于编译solidity源代码。所以你不需要在将来输入一个很长的命令。</p><pre class="jq jr js jt fq jx jy jz ka aw kb dt"><span id="5271" class="kc kd ht jy b fv ke kf l kg kh">$&gt; alias solc='docker run --rm -v "$(pwd):/src" satran004/aion-fastvm:0.3.1 solc'</span></pre><p id="2282" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="ki">注:</em> </strong> <em class="ki">我在Mac和Linux上测试过这个。但是windows测试仍然悬而未决，因为我现在没有Windows系统的机器。但是对于windows，您可能需要对上面用于windows环境的命令中的“${pwd}”做一个小的更改。将它替换为windows等效路径或工作文件夹的绝对路径。</em></p><p id="6a55" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在有趣的部分:)</p><p id="06d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">&gt;转到合同源文件文件夹，尝试像使用标准solc命令一样编译合同源文件。</p><pre class="jq jr js jt fq jx jy jz ka aw kb dt"><span id="7980" class="kc kd ht jy b fv ke kf l kg kh">$&gt; solc --abi --bin -o &lt;output_path&gt; &lt;solidity_file&gt;</span></pre><p id="2792" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">例如:</strong></p><pre class="jq jr js jt fq jx jy jz ka aw kb dt"><span id="ffe4" class="kc kd ht jy b fv ke kf l kg kh">$&gt; solc --abi --bin -o .  Math.sol</span></pre><p id="0062" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="ki">注意:</em> </strong> <em class="ki">源文件可以存在于你工作目录下的一个嵌套文件夹中。在这种情况下，您需要传递源文件的相对路径。此外，输出目录应该是工作目录中的嵌套目录。</em></p><p id="f366" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是一个可用于测试的样本可靠性契约的源代码。(数学求解)</p><pre class="jq jr js jt fq jx jy jz ka aw kb dt"><span id="0b9c" class="kc kd ht jy b fv ke kf l kg kh">pragma solidity ^0.4.10;<br/>  <br/>contract Math {<br/><br/>    function sum(uint n) returns (uint) {<br/>        uint s = 0;<br/>        for (uint i = 1; i &lt;= n; i++) {<br/>            s += i;<br/>        }<br/>        return s;<br/>    }<br/>}</span></pre><p id="6385" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您尝试编译没有"<strong class="is hu"> -o" </strong>选项的文件，编译输出将直接打印在控制台中。</p><pre class="jq jr js jt fq jx jy jz ka aw kb dt"><span id="0583" class="kc kd ht jy b fv ke kf l kg kh">$&gt; solc --abi --bin Math.sol</span><span id="d177" class="kc kd ht jy b fv kj kf l kg kh"><strong class="jy hu">Output :</strong></span><span id="6a1a" class="kc kd ht jy b fv kj kf l kg kh">$&gt; ======= Math.sol:Math =======<br/>Binary: <br/>605060405234156100105760006000fd5b610015565b60cb806100236000396000f30060506040526000356c01000000000000000000000000900463ffffffff16806357a7744b14603157602b565b60006000fd5b3415603c5760006000fd5b605060048080359060100190919050506066565b6040518082815260100191505060405180910390f35b60006000600060009150600190505b8381111515609157808201915081505b80806001019150506075565b8192506098565b50509190505600a165627a7a72305820c77f0903a9175d19c703e8dcc1c546a9db9bea00b647bb07ea4b867d298018f00029<br/>Contract JSON ABI <br/>[{"constant":false,"inputs":[{"name":"n","type":"uint128"}],"name":"sum","outputs":[{"name":"","type":"uint128"}],"payable":false,"type":"function"}]</span></pre><h1 id="9dc1" class="kk kd ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">那么下一步是什么？</h1><p id="d863" class="pw-post-body-paragraph iq ir ht is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hm dt translated">Java开发人员大多依赖IDE (Intellij，Eclipse等)。)并构建像Maven、Gradle这样的开发工具。这些工具为java开发生态系统提供了巨大的开发者体验和价值。</p><p id="f647" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">那么，为什么不使用这些经过验证的工具，尝试在java开发和solidity契约开发之间架起一座桥梁呢？因此，如果你像我一样是企业java背景的开发人员，你会对熟悉的工具感到如鱼得水。</p><p id="16c8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我刚刚开始开发一个<a class="ae jo" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu"> Gradle </strong> </a>插件，它可以自动完成上述所有步骤。唯一的先决条件是docker安装。</p><p id="5a13" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以这里的想法是支持一个类似于maven约定的项目结构。并使用Gradle作为基于智能合同的项目的构建工具。</p><pre class="jq jr js jt fq jx jy jz ka aw kb dt"><span id="0454" class="kc kd ht jy b fv ke kf l kg kh">- project_folder<br/>  - src<br/>      - main<br/>          - solidity<br/>               - Math.sol<br/>               - Mycontract.sol<br/>      - test</span><span id="e52b" class="kc kd ht jy b fv kj kf l kg kh">   build.gradle<br/>   ...    </span></pre><p id="e560" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">gradle插件将支持类似于<strong class="is hu"> compileJava </strong>的<strong class="is hu"> compileSolidity </strong>等任务。额外的任务，如创建一个发行版，并将其推送到像nexus这样的存储库，也可以通过使用一些现有的插件来实现。这可以在以后通过像Jenkins这样的CI / CD工具进行扩展。</p><p id="087f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还需要探索是否可以提供一个测试/沙盒环境(区块链的精简版本或仅fastvm环境)，该环境可用于以可预测和最快的方式在开发人员工作站上测试智能合同。我确信那也是可能的。所以我会继续在插件中寻找支持的方法。类似以太坊生态系统使用的<a class="ae jo" href="https://truffleframework.com/" rel="noopener ugc nofollow" target="_blank"> Tuffle </a>中的Ganache。</p><p id="b6f7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，请继续关注这个空间，获取更多更新。用于智能合同编译的Gradle插件的初始版本应该很快就会出来。</p><p id="8f0c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="ki">资源:</em></p><p id="8f02" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">https://github.com/satran004/aion-fastvm-docker</p><blockquote class="lm"><p id="f35a" class="ln lo ht bd lp lq lr ls lt lu lv jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="lx ly lz ma mb ju fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lw"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>