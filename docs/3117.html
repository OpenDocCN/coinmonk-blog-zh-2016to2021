<html>
<head>
<title>Solidity Smart Contract Tutorial With Building Real-World DAPP — Part 3: Create a Request for Freelancer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建真实世界DAPP的Solidity智能合同教程—第3部分:为自由职业者创建请求</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-smart-contract-tutorial-with-building-real-world-dapp-part-3-create-a-request-for-ead40e83384f?source=collection_archive---------0-----------------------#2020-07-03">https://medium.com/coinmonks/solidity-smart-contract-tutorial-with-building-real-world-dapp-part-3-create-a-request-for-ead40e83384f?source=collection_archive---------0-----------------------#2020-07-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/5580542a81937307feef80ed56b3eebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sxM9BGI8itEDeTtDxmHo5A.jpeg"/></div></div></figure><p id="5a75" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上一篇文章的<a class="ae jz" rel="noopener" href="/coinmonks/solidity-smart-contract-tutorial-with-building-real-world-dapp-part-2-create-your-first-contract-e7cd4fdf4e98">中，我们创建了我们的第一个智能契约，并为它定义了一个构造函数。在构造函数中，我们使用msg.sender获得了契约创建者的地址。<br/>我们还学习了solidity中的变量类型以及可以为变量和函数定义的各种可见性。</a></p><p id="cdc5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在本文中，我们开始学习solidity中的支付。然后，我们将使用<code class="eh ka kb kc kd b">struct</code>在solidity中创建我们自己的自定义类型。我们还将学习如何在修饰词的帮助下处理实度中的错误！</p><h2 id="b8a0" class="ke kf ht bd kg kh ki kj kk kl km kn ko jm kp kq kr jq ks kt ku ju kv kw kx ky dt translated">开始吧！</h2><p id="61f1" class="pw-post-body-paragraph jb jc ht jd b je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ld jw jx jy hm dt translated">正如我所说的，我们可以使用msg.sender访问事务的发送者。<br/>任何时候，当我们想要与区块链交互时，我们都需要创建一个事务。我们可能会向朋友发送一些加密货币，部署一个智能合约，或者调用一个函数来更改区块链中的一些数据。</p><p id="b427" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">那么，我们怎样才能得到事务中发送的醚的数量呢？(本例为合同部署交易)</p><h2 id="450e" class="ke kf ht bd kg kh ki kj kk kl km kn ko jm kp kq kr jq ks kt ku ju kv kw kx ky dt translated">智能合同支付</h2><p id="3765" class="pw-post-body-paragraph jb jc ht jd b je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ld jw jx jy hm dt translated">我们可以使用<code class="eh ka kb kc kd b">msg</code>全局变量的另一个属性来获取事务中已经发送的以太网的数量。是<code class="eh ka kb kc kd b">msg.value</code>。关于付款，我们还应该考虑另一件事。我们必须在我们的功能上做一些改变，才能得到醚。</p><p id="a362" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在solidity smart合同中，您将面临两种情况来接收乙醚。<br/> 1。有时你的契约中有一个函数可以接收以太。在这种情况下，您需要创建函数并将其标记为应付款。<br/>因此，该功能将能够接收醚。<br/>比如你有一个<code class="eh ka kb kc kd b">buyAsset()</code>函数。顾名思义，它需要接收一些醚。</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="45ff" class="ke kf ht kd b fv lm ln l lo lp">function buyAsset() public payable {</span><span id="d6f0" class="ke kf ht kd b fv lq ln l lo lp">   uint256 value = msg.value;</span><span id="639b" class="ke kf ht kd b fv lq ln l lo lp">   // Do some validation to make sure value is greater than 0<br/>   // .<br/>   // .<br/>   // .<br/>   // Buy asset</span><span id="bffd" class="ke kf ht kd b fv lq ln l lo lp">}</span></pre><p id="b7bb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">如果在调用非付费函数时发送以太网，交易将被拒绝。</strong></p><p id="6195" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">2.您可能希望为社区提供您的智能合同地址。因此，每个人都可以将乙醚从他们的钱包转移到您的智能合约中，而无需调用任何函数。要将这个特性添加到您的合同中，您需要用<code class="eh ka kb kc kd b">fallback</code>关键字或<code class="eh ka kb kc kd b">receive</code>关键字定义一个函数。<br/>这两个函数都不能有参数，不能返回任何东西，必须有外部可见性！</p><p id="4c11" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">回退函数<br/> </strong>如果其他函数都不匹配给定的函数签名，或者根本没有提供数据，并且没有<code class="eh ka kb kc kd b">receive</code>函数，则在调用合同时执行该函数。<code class="eh ka kb kc kd b">fallback</code>函数总是接收数据，但是为了也接收以太网，它必须被标记为payable。</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="096e" class="ke kf ht kd b fv lm ln l lo lp"><br/> fallback() external payable {<br/>    uint256 value = msg.value; <br/> }<br/></span></pre><p id="d607" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">接收函数<br/> </strong>在普通以太网传输中执行。如果不存在这样的函数，但存在一个可支付的<code class="eh ka kb kc kd b">fallback</code>函数，则在普通以太网传输中将调用回退函数。如果既不存在一个<code class="eh ka kb kc kd b">receive</code>以太，也不存在一个可支付的<code class="eh ka kb kc kd b">fallback</code>函数，那么契约就不能通过常规事务接收以太，并抛出一个异常。</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="35d7" class="ke kf ht kd b fv lm ln l lo lp"><br/> receive() external payable {<br/>    uint256 value = msg.value; <br/> }</span></pre><p id="e355" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">就像我说的，如果我们在我们的契约中加入<code class="eh ka kb kc kd b">receive</code>或<code class="eh ka kb kc kd b">fallback</code>函数，人们就不需要调用一个函数来传递Ethers。他们只需要我们的合同地址，就可以用他们的以太坊钱包发送以太。例如，我们决定为一个慈善机构筹集资金。给想支持我们的人提供我们的个人账号地址不靠谱。相反，我们可以创建一个带有一些逻辑的智能合同，向人们展示这些钱将如何使用。然后，为人们提供合同地址。他们可以检查合同，如果合同逻辑足够公平，他们可以向合同地址发送一些以太网。</p><p id="66ab" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">所以，如你所见，有很多方法可以解决问题。对吗？<br/>我希望雇主能够在创建合同时发送一些以太网，因此，我需要将我的构造函数标记为一个可支付函数。<br/>雇主可能还想在部署后发送更多乙醚。所以，我们可以简单地添加一个<code class="eh ka kb kc kd b">receive</code>函数，这样每个人(包括雇主)都可以发送Ethers来签约。</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="36d1" class="ke kf ht kd b fv lm ln l lo lp">       address public employer;       <br/>       address public freelancer;<br/>       uint public deadline;<br/>       uint public price;</span><span id="85b4" class="ke kf ht kd b fv lq ln l lo lp">constructor(address _freelancer, uint256 _deadline) public payable {<br/>        employer = msg.sender;<br/>        freelancer = _freelancer;<br/>        deadline = _deadline;<br/>        price = msg.value;<br/>    }<br/></span><span id="82fc" class="ke kf ht kd b fv lq ln l lo lp">receive() external payable {<br/>        price += msg.value; <br/>    }</span></pre><p id="b580" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您还可以创建一个自定义函数，例如addMoreEther()函数，并将其标记为应付款。所以雇主可以调用这个函数，以防更多的醚转移到合同中！这取决于你的商业逻辑！有很多方法可以解决编程中的问题。😎</p></div><div class="ab cl lr ls hb lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hm hn ho hp hq"><p id="1f0d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我们有一份合同，上面有我们的关键信息:<br/>自由职业者地址<br/>雇主地址<br/>截止日期<br/>项目费用</p><p id="2b23" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果你不知道我们的项目目标，最好看一下<a class="ae jz" rel="noopener" href="/@bitnician/solidity-smart-contract-tutorial-with-building-full-stack-dapp-part-1-introduction-65988e83b4a3">第一部分</a>。在这个阶段，自由职业者可以开始做项目，因为他/她已经能够检查智能合同余额和截止日期。<br/>假设项目是全栈DAPP项目。自由职业者可能会在完成用户界面后要求一些费用。<br/>在<code class="eh ka kb kc kd b">freelancer</code>创建请求后，<code class="eh ka kb kc kd b">employer</code>可以解锁请求，然后，<code class="eh ka kb kc kd b">freelancer</code>可以提取他/她请求的费用。让我们把这个特点加到我们的合同里。</p><p id="e24e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该请求有4个属性。<br/><code class="eh ka kb kc kd b">title</code>和<code class="eh ka kb kc kd b">amount</code>。我们还需要知道请求的状态。可能是一个<code class="eh ka kb kc kd b">lock/unlock</code>，也可能是<code class="eh ka kb kc kd b">paid/unpaid</code>。</p><h2 id="5b27" class="ke kf ht bd kg kh ki kj kk kl km kn ko jm kp kq kr jq ks kt ku ju kv kw kx ky dt translated"><strong class="ak">结构</strong></h2><p id="08a6" class="pw-post-body-paragraph jb jc ht jd b je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ld jw jx jy hm dt translated">如果有经验丰富的开发者，应该对<code class="eh ka kb kc kd b">struct</code>比较熟悉。<br/> A <code class="eh ka kb kc kd b">struct</code>只是solidity中的另一种数据类型。这是一个自定义类型，您可以在其中定义名称和相关属性。它几乎就像javascript中的一个对象。<br/>让我们为自由职业者请求创建一个结构:</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="6123" class="ke kf ht kd b fv lm ln l lo lp">struct Request {<br/> string title;<br/> uint256 amount;<br/> bool locked;<br/> bool paid;<br/> }</span></pre><p id="7962" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">自由职业者可以在合同中创建多个请求。例如，当后端完成时，他/她可能会创建另一个请求。所以我们可以将请求存储在一个包装器中！</p><h2 id="f0e3" class="ke kf ht bd kg kh ki kj kk kl km kn ko jm kp kq kr jq ks kt ku ju kv kw kx ky dt translated">排列</h2><p id="be8a" class="pw-post-body-paragraph jb jc ht jd b je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ld jw jx jy hm dt translated">An <code class="eh ka kb kc kd b">array</code>是每一种编程语言的关键概念之一。在坚固性方面，我们有<code class="eh ka kb kc kd b">fixed array</code>和<code class="eh ka kb kc kd b">dynamic array</code>。我们还需要定义什么样的数据将被存储在<code class="eh ka kb kc kd b">array</code>中。<br/>例如，我们有一个<code class="eh ka kb kc kd b">fixed array</code>，最多可存储3个<code class="eh ka kb kc kd b">string</code>:</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="b2c6" class="ke kf ht kd b fv lm ln l lo lp">string[3] myArray</span></pre><p id="2fe2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">或者我们可以有一个<code class="eh ka kb kc kd b">dynamic array</code>来保存<code class="eh ka kb kc kd b">addresses</code>:</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="a709" class="ke kf ht kd b fv lm ln l lo lp">address[] myArray</span></pre><p id="0409" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我们的项目中，我们需要一个<code class="eh ka kb kc kd b">dynamic array</code>来保存我们的自定义<code class="eh ka kb kc kd b">Request</code>类型。</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="4b9d" class="ke kf ht kd b fv lm ln l lo lp">Request[] public requests;</span></pre><p id="015a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，我们创建了一个名为<code class="eh ka kb kc kd b">Request</code>的自定义类型，并将它们放入名为<code class="eh ka kb kc kd b">requests</code>的数组中。我们还为<code class="eh ka kb kc kd b">array</code>定义了一个可见性类型。公开是可以的，但是你也可以把它定义为私有或者内部的。<br/>现在，让我们定义一个函数来创建一个请求，并在请求<code class="eh ka kb kc kd b">array</code>中推送它们。</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="139a" class="ke kf ht kd b fv lm ln l lo lp">function createRequest(string memory _title, uint256 _amount) public<br/>{<br/>   Request memory request = Request({<br/>      title: _title,<br/>      amount: _amount,<br/>      locked: true,<br/>      paid: false<br/>    });</span><span id="5359" class="ke kf ht kd b fv lq ln l lo lp">   requests.push(request);<br/>}</span></pre><p id="b700" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上面的函数中，有一个名为<code class="eh ka kb kc kd b">request</code>的类型为<code class="eh ka kb kc kd b">Request</code>的<em class="ly">内存</em>变量，它已经被我们的请求属性填充。<br/>然后，就一直推到阵中。</p></div><div class="ab cl lr ls hb lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hm hn ho hp hq"><p id="8681" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，这是一个很好的时间来学习关于可靠性的<strong class="jd hu">验证</strong>。如您所见，每个人都可以调用该函数。我们需要检查自由职业者是否调用这个函数。我们知道在我们的合同中有一个名为<code class="eh ka kb kc kd b">freelancer</code>的变量保存着自由职业者的地址。我们还知道<code class="eh ka kb kc kd b">msg.sender</code>，它帮助我们获得函数调用者的地址。因此，我们可以编写一个简单的<code class="eh ka kb kc kd b">if/else</code>函数来检查<code class="eh ka kb kc kd b">freelancer</code>是否等于<code class="eh ka kb kc kd b">msg.sender</code>，但是，在solidity中还有一些其他的错误处理方法。</p><h2 id="3bca" class="ke kf ht bd kg kh ki kj kk kl km kn ko jm kp kq kr jq ks kt ku ju kv kw kx ky dt translated">错误处理</h2><p id="cf8b" class="pw-post-body-paragraph jb jc ht jd b je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ld jw jx jy hm dt translated">首先，我们来回答这个问题:当出现错误时会发生什么？</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="8669" class="ke kf ht kd b fv lm ln l lo lp">function foo() public{<br/>    // Do stuff!<br/>    <br/>    value = 10;</span><span id="9fc8" class="ke kf ht kd b fv lq ln l lo lp">    // BOOOOM! error<br/>}</span></pre><p id="f51b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当错误发生时，所有的东西都将被取消，例如，在上面的函数中，<code class="eh ka kb kc kd b">value</code>的值不再是10。</p><p id="6078" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">用<code class="eh ka kb kc kd b">require</code>要求<br/> </strong>，我们可以<strong class="jd hu">处理在一个糟糕的智能合约的生命周期中正常发生的</strong>错误。例如，我们期望自由职业者调用一个函数。其他任何人都可能调用该函数，因此，我们将使用require来检查条件。<br/> <code class="eh ka kb kc kd b">require(msg.sender == freelancer, ‘The error message…!’);</code></p><p id="6007" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">用<code class="eh ka kb kc kd b">assert</code>断言</strong> <br/>，我们正在测试不应该发生的<strong class="jd hu">错误。如果发生了那种错误，那就意味着你的合同有问题。<br/>例如，<code class="eh ka kb kc kd b">value</code>不应该等于10，如果最终等于10，则表示有bug: <br/> <code class="eh ka kb kc kd b"> assert(a !=10 );</code></strong></p><p id="a420" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">另一个例子，如果你在一个太大的或者负的索引上访问一个<code class="eh ka kb kc kd b">array</code>。(即x[i]其中i &gt; = x.length或i &lt; 0)这种情况下，你的契约中有bug，可以用assert检查这类bug！</p><p id="89fd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> Revert </strong> <br/>在其他编程语言中，通常使用<code class="eh ka kb kc kd b">throw</code>关键字抛出错误。在坚固性上我们用<code class="eh ka kb kc kd b">revert</code>！<br/>例如:</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="5db4" class="ke kf ht kd b fv lm ln l lo lp">if(a != 1){<br/>  revert(‘The value should be equal to 1’)<br/>}</span></pre><p id="2a02" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你可以简单的用<code class="eh ka kb kc kd b">require</code>代替上面写的函数:<br/> <code class="eh ka kb kc kd b">require(a == 1, ‘The value should be equal to 1’ )</code></p></div><div class="ab cl lr ls hb lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hm hn ho hp hq"><p id="7b36" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里有一点我想提一下:<strong class="jd hu">不要在区块链上存储不必要的数据！<br/> </strong>当<code class="eh ka kb kc kd b">freelancer</code>创建一个<code class="eh ka kb kc kd b">request</code>的时候，我们真的不需要存储<code class="eh ka kb kc kd b">request</code>的<code class="eh ka kb kc kd b">title</code>。标题其实并不是一件很重要的事情。出于教育目的，我添加了<code class="eh ka kb kc kd b">request</code>的<code class="eh ka kb kc kd b">title</code>。我们可以将这种数据存储在中央数据库中。</p><p id="ecec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在某些情况下，您可能会面临在区块链上存储多个字符串的情况。例如，您可能想要存储一个人的全名和他/她的身份号码。在这种情况下，您可以<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat" rel="noopener ugc nofollow" target="_blank">串联</a>字符串，并从串联结果中创建一个散列。然后，将散列存储在区块链上。通过这样做，你可以最小化需要存储的数据。此外，您不应该在区块链上存储任何个人信息。没有人希望他/她的个人信息被公开存储在一个终生保存数据的系统上！🤨</p><p id="ce83" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们还应该尝试编写简短的错误消息。不要写<em class="ly">‘只有管理员可以调用这个函数’</em>，而直接写<em class="ly">‘只有管理员’</em>🤓</p></div><div class="ab cl lr ls hb lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hm hn ho hp hq"><p id="fe14" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">好了，让我们回到我们的<code class="eh ka kb kc kd b">createRequest</code>函数。我们可以添加一个<code class="eh ka kb kc kd b">if/else</code>块，并用<code class="eh ka kb kc kd b">revert()</code>或简单地使用<code class="eh ka kb kc kd b">require()</code>来处理错误。</p><p id="7185" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我通常在合同中使用<code class="eh ka kb kc kd b">require()</code>:</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="92e1" class="ke kf ht kd b fv lm ln l lo lp">function createRequest(string memory _title, uint256 _amount) public<br/>{</span><span id="b056" class="ke kf ht kd b fv lq ln l lo lp">   require(msg.sender == freelancer, "Only Freelancer!");</span><span id="dcc8" class="ke kf ht kd b fv lq ln l lo lp">   Request memory request = Request({<br/>      title: _title,<br/>      amount: _amount,<br/>      locked: true,<br/>      paid: false<br/>    });</span><span id="97c8" class="ke kf ht kd b fv lq ln l lo lp">   requests.push(request);<br/>}</span></pre><p id="4368" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">稍后，我们将定义一些其他功能，这些功能也仅限于<code class="eh ka kb kc kd b">freelancer</code>。在所有这些函数中添加带有相同错误消息的相同<code class="eh ka kb kc kd b">require()</code>并不是最佳做法。<br/>在solidity中，我们可以定义一个<code class="eh ka kb kc kd b">modifier</code>函数来帮助我们不再重复<code class="eh ka kb kc kd b">require()</code>函数。</p><h2 id="3556" class="ke kf ht bd kg kh ki kj kk kl km kn ko jm kp kq kr jq ks kt ku ju kv kw kx ky dt translated">修饰语</h2><p id="f47f" class="pw-post-body-paragraph jb jc ht jd b je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ld jw jx jy hm dt translated">它在功能上创建附加特征或对功能施加一些限制。我们简单地定义我们的逻辑，然后在修饰符的末尾添加一个<code class="eh ka kb kc kd b">_</code>。<code class="eh ka kb kc kd b">_</code>是原始功能将被执行的地方(在这种情况下，原始功能是<code class="eh ka kb kc kd b">createRequest()</code></p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="f8ac" class="ke kf ht kd b fv lm ln l lo lp"><strong class="kd hu">modifier</strong> onlyFreelancer() {<br/>        require(msg.sender == freelancer, "Only Freelancer!");<br/>        _;<br/>    }</span></pre><p id="0653" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我们在限制于<code class="eh ka kb kc kd b">freelancer</code>的每个函数上使用这个<code class="eh ka kb kc kd b">modifier</code>:</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="a9a3" class="ke kf ht kd b fv lm ln l lo lp">function <strong class="kd hu"><em class="ly">createRequest</em></strong>(string memory _title, uint256 _amount) <br/>public <strong class="kd hu"><em class="ly">onlyFreelancer</em></strong> {</span><span id="33ff" class="ke kf ht kd b fv lq ln l lo lp">Request memory request = Request({<br/>      title: _title,<br/>      amount: _amount,<br/>      locked: true,<br/>      paid: false<br/>    });</span><span id="f6ad" class="ke kf ht kd b fv lq ln l lo lp">requests.push(request);<br/>}</span></pre><p id="b76f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们已经学会了如何创建我们自己的修改器。还有像<code class="eh ka kb kc kd b">view</code>、<code class="eh ka kb kc kd b">pure</code>这样的坚固性内置<code class="eh ka kb kc kd b">modifiers</code>。我们将在本文中了解它们。</p></div><div class="ab cl lr ls hb lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hm hn ho hp hq"><p id="9dbd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如我在上一篇文章中提到的，当我们创建一个状态变量时，solidity会自动为我们创建一个getter函数。在本文中，我们创建了一个名为<code class="eh ka kb kc kd b">requests</code>的公共状态变量，它包含所有请求的数组。<br/>这意味着我们访问一个名为requests的getter函数。但是，它不会返回整个数组。您应该传递索引，它将返回结果。我们将在部署契约时看到它是如何工作的，但是现在，让我们创建一个函数来为我们返回整个数组。</p><pre class="le lf lg lh fq li kd lj lk aw ll dt"><span id="172b" class="ke kf ht kd b fv lm ln l lo lp">function getAllRequests() public <strong class="kd hu">view</strong> returns (Request[] memory) {<br/>        return requests;<br/> }</span></pre><h2 id="4981" class="ke kf ht bd kg kh ki kj kk kl km kn ko jm kp kq kr jq ks kt ku ju kv kw kx ky dt translated">观点和纯粹</h2><ul class=""><li id="d990" class="lz ma ht jd b je kz ji la jm mb jq mc ju md jy me mf mg mh dt translated">在可靠性方面，我们对只读函数使用<code class="eh ka kb kc kd b">view</code>修饰符。这种功能不会改变区块链上的任何东西。</li><li id="03c2" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated">另一个修改器是<code class="eh ka kb kc kd b">pure</code>。我们将这个修饰符用于只使用函数的参数返回值而没有任何副作用(引入外部变量并改变它)的函数。我们将在本教程的下一部分使用它。</li></ul><h2 id="c2b5" class="ke kf ht bd kg kh ki kj kk kl km kn ko jm kp kq kr jq ks kt ku ju kv kw kx ky dt translated">返回</h2><p id="d50b" class="pw-post-body-paragraph jb jc ht jd b je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ld jw jx jy hm dt translated">如果函数要返回任何东西，我们只需要定义将返回哪种类型。在我们的函数中，我们将返回一个<code class="eh ka kb kc kd b">Request</code>类型的数组。(<code class="eh ka kb kc kd b">Request</code>类型是我们借助<code class="eh ka kb kc kd b">struct</code>关键字构建的定制类型)。</p><p id="58ce" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我知道混音IDE显示了一个错误。这个错误告诉我们，solidity不能返回自定义类型的数组(就像我们的<code class="eh ka kb kc kd b">Request</code>类型)。</p><p id="cd02" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如您看到的错误消息，您需要在代码的顶部添加一行:</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mn"><img src="../Images/55993a81751136d74094d18f9a6183d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gU-74eA-S7sKPuR15rADw.png"/></div></div></figure><p id="d296" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你应该在<code class="eh ka kb kc kd b">pragma solidity 0.6.9</code>下面加上<code class="eh ka kb kc kd b">pragma experimental ABIEncoderV2</code>。它允许将结构、嵌套和动态变量传递到函数中，从函数中返回，以及由事件发出。(稍后我们将了解事件)</p><p id="5794" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，是时候部署我们的合同了。正如您所记得的，我们将构造函数标记为一个可支付函数。因此，我们可以在部署合同时发送一些乙醚。<br/>我将向合同发送3份乙醚。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mn"><img src="../Images/c30270f233cb959886d532c153b5eebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YMoxpnuBVM_3h8Nui76Rag.png"/></div></div></figure><p id="72fe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如你已经知道的，你需要通过自由职业者的地址和项目截止日期。这里你不应该再为自由职业者添加一个随机地址了。<br/> 你需要复制一个已经存在于你的Remix IDE中的地址。这个地址将是我们的<code class="eh ka kb kc kd b">freelancer</code>地址，我们必须使用这个<code class="eh ka kb kc kd b">address</code>来创建一个<code class="eh ka kb kc kd b">request</code>。<br/>我将使用第一个地址来部署我的合同。那将是我的<code class="eh ka kb kc kd b">employer</code>，在部署契约的同时复制第二个地址并作为参数传递。它将被存储在<code class="eh ka kb kc kd b">freelancer</code>变量中。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mn"><img src="../Images/56a9ba3492245ebb86e31fd6ac67473c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4p5uqvywrQHscRNU0x_VpA.png"/></div></div></figure><p id="3ea2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于<code class="eh ka kb kc kd b">deadline</code>，它只需要一个uint值。为了获得更好的体验，我们可以传递一个Unix时间戳:<em class="ly"> 1593774875 </em></p><p id="8171" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们点击部署按钮，测试我们的合同🔥</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mn"><img src="../Images/ac9473e8bf575489c90ec221ef86c780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*khipBPKsiEwiQjbfcI6qkg.png"/></div></div></figure><p id="0043" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">项目已经部署，正如你所看到的，从部署者账户中扣除了将近3 ether。你在以太坊区块链进行的每一项操作都需要一些费用。这就是部署者帐户有96.9个以太网而不是97个以太网的原因。<br/>这个<a class="ae jz" href="https://github.com/crytic/evm-opcodes" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>有以太坊区块链交易手续费如何计算的好信息。您还将在接下来的文章中学习如何降低交易费用。</p><p id="be2a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，让我们从区块链中读取存储的数据。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mn"><img src="../Images/afaa10d3455a9f7ed2f519362b75ae3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TsGiwi-pCcGK1T9wV-zVYw.png"/></div></div></figure><p id="27f6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如您所见，我们将3个以太网传递给智能合约。这些醚会转化为wai，然后储存在区块链中。在<a class="ae jz" href="https://www.etherchain.org/tools/unitConverter" rel="noopener ugc nofollow" target="_blank">这个</a>网站上，你可以看到以太的所有单位。</p><p id="3d31" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我将使用我的智能合约功能来存储和读取一个<code class="eh ka kb kc kd b">request</code>。请记住将Remix帐户更改为自由职业者帐户，否则，您无法创建请求，因为我们的<code class="eh ka kb kc kd b">createRequest()</code>被限制为<code class="eh ka kb kc kd b">freelancer.</code> <br/>我的请求的标题是<em class="ly">‘前端’</em>并且金额是<em class="ly"> 10000000000000000魏</em> (1乙醚)</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mn"><img src="../Images/2efadba333320cf65917940eb3065834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8xzaBF0oOKWlHhLd2G6_gw.png"/></div></div></figure><p id="d326" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">大家还记得，最初，我们在部署到合同时，为转移3个以太网而将值输入填充为3。现在，您可以用另一个数字填充输入值，然后点击transact按钮。这是我们使用<code class="eh ka kb kc kd b">receive</code>功能在合同中添加的功能。如您所见，我已向合同发送了1份乙醚，余额更新为4份乙醚(400000000000000000魏)🙂</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mn"><img src="../Images/a9698d6ee9ed8a518d339202c1c7cabf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxVLfxIoWNYxQ1mysykedw.png"/></div></div></figure><h1 id="6fdb" class="mo kf ht bd kg mp mq mr kk ms mt mu ko mv mw mx kr my mz na ku nb nc nd kx ne dt translated">结论</h1><p id="2031" class="pw-post-body-paragraph jb jc ht jd b je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ld jw jx jy hm dt translated">现在你已经知道如何使用<code class="eh ka kb kc kd b">struct</code>在solidity中创建你的自定义类型，并且可以使用<code class="eh ka kb kc kd b">arrays</code>了。你熟悉了<code class="eh ka kb kc kd b">payable</code>的功能，并在你的合同中增加了接收乙醚的功能。<br/>你对solidity中的错误处理有很好的了解。你已经定义了你自己的<code class="eh ka kb kc kd b">modifier</code>，并且使用了诸如<code class="eh ka kb kc kd b">view</code>和<code class="eh ka kb kc kd b">pure</code>这样的坚固性内置修改器。<br/>作为区块链开发者，还有一些你需要知道的关键信息，我会在我的文章中一点一点地提到它们🙂</p><h1 id="5330" class="mo kf ht bd kg mp mq mr kk ms mt mu ko mv mw mx kr my mz na ku nb nc nd kx ne dt translated">项目源代码</h1><p id="efac" class="pw-post-body-paragraph jb jc ht jd b je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ld jw jx jy hm dt translated">可以在我的GitHub repo中找到该项目的源代码:<br/><a class="ae jz" href="https://github.com/bitnician/Delance-truffle" rel="noopener ugc nofollow" target="_blank"><strong class="jd hu">https://github.com/bitnician/Delance-truffle</strong></a></p><p id="d297" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">每一课都会有自己的分支。</p></div><div class="ab cl lr ls hb lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hm hn ho hp hq"><p id="ece5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我叫贝扎德。我是一名区块链开发人员，拥有为企业区块链平台开发以太坊和Hyperledger fabric的经验。你可以通过我的用户名在twitter上找到我:<a class="ae jz" href="https://twitter.com/bitnician" rel="noopener ugc nofollow" target="_blank"> Bitnician </a>。<br/>欢迎在这里或twitter上提出任何问题。</p><figure class="le lf lg lh fq iu"><div class="bz el l di"><div class="nf ng l"/></div></figure><h2 id="51a7" class="ke kf ht bd kg kh ki kj kk kl km kn ko jm kp kq kr jq ks kt ku ju kv kw kx ky dt translated">另外，阅读</h2><ul class=""><li id="0bc7" class="lz ma ht jd b je kz ji la jm mb jq mc ju md jy me mf mg mh dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/whats-the-best-crypto-trading-bot-in-2020-top-8-bitcoin-trading-bot-c16adeb13317">最佳加密交易机器人</a></li><li id="51e2" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated">最好的比特币<a class="ae jz" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069?source=friends_link&amp;sk=324dd9ff8556ab578d71e7ad7658ad7c">硬件钱包</a></li><li id="4268" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">密码本交易平台</a></li><li id="69bb" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated">最好的<a class="ae jz" rel="noopener" href="/coinmonks/best-crypto-tax-tool-for-my-money-72d4b430816b">加密税务软件</a></li><li id="7c4f" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/the-best-crypto-trading-platforms-in-2020-the-definitive-guide-updated-c72f8b874555">最佳加密交易平台</a></li><li id="3524" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/best-wallets-to-use-uniswap-e91a6385d9e8">unis WAP最佳钱包</a></li><li id="97a4" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated">最佳<a class="ae jz" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">加密贷款平台</a></li><li id="9922" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/blockfi-vs-celsius-vs-hodlnaut-8a1cc8c26630">block fi vs Celsius</a>vs Hodlnaut</li><li id="ab33" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/ledger-vs-trezor-best-hardware-wallet-to-secure-cryptocurrency-22c7a3fd391e">莱杰vs特雷佐</a></li><li id="cfcc" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/defi-future-10-promising-projects-in-the-defi-world-ff2b697ab006">顶级DeFi项目</a></li><li id="a1cf" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated">Bitsgap评论——一个轻松赚钱的加密交易机器人</li><li id="2401" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/quadency-review-a-crypto-trading-automation-platform-3068eaa374e1"> Quadency Review </a> -为专业人士打造的加密交易机器人</li><li id="2791" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated"><a class="ae jz" href="https://blog.coincodecap.com/3commas-review-an-excellent-crypto-trading-bot" rel="noopener ugc nofollow" target="_blank">3商业评论</a> |一款优秀的密码交易机器人</li><li id="4582" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/cryptohopper-vs-3commas-vs-shrimpy-a2c16095b8fe"> 3Commas vs Cryptohopper </a></li><li id="eb27" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated">Bitmex上的<a class="ae jz" rel="noopener" href="/coinmonks/the-idiots-guide-to-margin-trading-on-bitmex-dbbd7742c6fc?source=friends_link&amp;sk=7bfa99d2a181142510c8442c8ddb0786">保证金交易指南</a></li><li id="aaab" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/the-definitive-guide-to-crypto-swing-trading-7e4af6496d4d?source=friends_link&amp;sk=70448050bd9323b42f63bfc0bb1e60d1">加密摇摆交易权威指南</a></li><li id="cfc6" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/bitmex-advanced-margin-trading-guide-2270c195ce25?source=friends_link&amp;sk=1d986cca731f5084b9a2db4a4bc4a7ad"> Bitmex高级保证金交易指南</a></li><li id="6e2e" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">开发人员的最佳加密API</a></li><li id="b037" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/crypto-arbitrage-guide-how-to-make-money-as-a-beginner-62bfe5c868f6">加密套利</a>指南:新手如何赚钱</li><li id="b46f" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated">顶级<a class="ae jz" href="https://blog.coincodecap.com/bitcoin-node-solutions" rel="noopener ugc nofollow" target="_blank">比特币节点</a>提供商</li><li id="0966" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated">最佳加密制图工具</li><li id="ef45" class="lz ma ht jd b je mi ji mj jm mk jq ml ju mm jy me mf mg mh dt translated">了解比特币的<a class="ae jz" rel="noopener" href="/coinmonks/what-are-the-best-books-to-learn-bitcoin-409aeb9aff4b">最佳书籍有哪些？</a></li></ul><blockquote class="nh"><p id="b751" class="ni nj ht bd nk nl nm nn no np nq jy ek translated"><a class="ae jz" href="https://coincodecap.com?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ns nt nu nv nw iu fe ff paragraph-image"><a href="https://coincodecap.com?utm_source=coinmonks"><div class="fe ff nr"><img src="../Images/160ce73bd06d46c2250251e7d5969f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*BoDnKUyK8p4hitHAJZ5Pdw.png"/></div></a></figure></div></div>    
</body>
</html>