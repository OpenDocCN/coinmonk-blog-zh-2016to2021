<html>
<head>
<title>Learn Solidity. Shark of The Pool — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学扎实。泳池里的鲨鱼——第一部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-shark-of-the-pool-part-1-ac0f733eecdd?source=collection_archive---------0-----------------------#2018-04-16">https://medium.com/coinmonks/learn-solidity-shark-of-the-pool-part-1-ac0f733eecdd?source=collection_archive---------0-----------------------#2018-04-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/9bbc01aafa66a981be17676180d9b188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rf__8xWSTniXUDcGvnC3Hw.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek"><a class="ae jf" href="https://www.pexels.com/photo/code-coding-computer-data-574070/" rel="noopener ugc nofollow" target="_blank">Image source</a></figcaption></figure><p id="712b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在本系列中，我们将使用Solidity smart contracts基于以太坊区块链创建一个简单的Dapp。在后面的部分中，我们将看到如何测试和部署契约。我们还将创建React Web应用程序，并使用MetaMask进行区块链交易，以获得功能齐全的Dapp。</p><p id="707e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在<a class="ae jf" href="http://34.210.217.34/" rel="noopener ugc nofollow" target="_blank">这个地址</a>上可以获得Dapp 的演示。</p><p id="be31" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">所有的<strong class="ji hu">源代码</strong>都可以在<a class="ae jf" href="https://github.com/joze144/pool-shark" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中免费获得。</p><p id="c346" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">加入我们:<a class="ae jf" href="https://solidity_devs.select.id/bjxx" rel="noopener ugc nofollow" target="_blank"> Solidity开发社区，了解更多信息</a></p><blockquote class="ke"><p id="7588" class="kf kg ht bd kh ki kj kk kl km kn kd ek translated"><a class="ae jf" href="https://coincodecap.com" rel="noopener ugc nofollow" target="_blank">发现并回顾最佳区块链软件</a></p></blockquote><h1 id="8bc2" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">Dapp的目标</h1><p id="8c51" class="pw-post-body-paragraph jg jh ht ji b jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd hm dt translated">我把这个Dapp命名为“泳池鲨鱼”，但是它到底是做什么的呢？Dapp的目标很简单，我希望能够创建一个游泳池，人们可以贡献他们宝贵的以太。收款期是有期限的，超过期限就不能再往池子里存款了。</p><p id="7828" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当设定的截止日期到期时，我们希望看到谁是池中的鲨鱼，或最大的贡献者。那个地址的所有者，我们将称他为鲨鱼，是赢家，可以提取所有收集的资金。</p><h1 id="89ce" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll dt translated">智能合同</h1><p id="9e0b" class="pw-post-body-paragraph jg jh ht ji b jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd hm dt translated">让我们直接进入正题。我将假设读者不是第一次接触Solidity，并且可以跟随我完成开发。否则，<a class="ae jf" href="https://solidity.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> Solidity documentation </a>就是你的朋友。我也强烈推荐使用<a class="ae jf" href="http://truffleframework.com/" rel="noopener ugc nofollow" target="_blank">松露框架</a>和浏览<a class="ae jf" href="http://truffleframework.com/tutorials/" rel="noopener ugc nofollow" target="_blank">他们的教程</a>。</p><p id="2002" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">目标看起来很简单，但是当你开始从发展的角度考虑时，它可能不是那么简单。我们需要的是把逻辑分成几个模块。</p><h2 id="201f" class="lu kp ht bd kq lv lw lx ku ly lz ma ky jr mb mc lc jv md me lg jz mf mg lk mh dt translated">联营合同</h2><p id="f8cb" class="pw-post-body-paragraph jg jh ht ji b jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd hm dt translated">Pool将完全按照我们前面描述的那样工作。池合同接受存款，并在收款期间安全地存储它们。截止日期后，它拒绝任何进一步的存款，并允许为池中的鲨鱼提取资金。</p><p id="9e35" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们首先定义接口。接口是Solidity开发的重要部分。为了更好地了解为什么你应该使用它们，我推荐<a class="ae jf" href="https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88" rel="noopener ugc nofollow" target="_blank">这篇由<a class="mi mj gr" href="https://medium.com/u/899aa52b377e?source=post_page-----ac0f733eecdd--------------------------------" rel="noopener" target="_blank">埃琳娜·迪米特罗娃</a>撰写的精彩文章</a>。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="a847" class="lu kp ht mp b fv mt mu l mv mw"><strong class="mp hu">pragma </strong>solidity ^0.4.21;<br/><br/><strong class="mp hu">contract </strong>iPool {<br/>    <strong class="mp hu">function </strong>() <strong class="mp hu">public payable</strong>;<br/><br/>    <strong class="mp hu">function </strong>withdraw() <strong class="mp hu">public returns </strong>(<strong class="mp hu">bool </strong>success);<br/>}</span></pre><p id="34fa" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">但是你可能会问，我们没有忘记存款功能吗？定金是合同的直接交易。它在无名称函数中处理。不要忘记<strong class="ji hu">应付款</strong>关键字，允许函数接收以太的函数修饰符。<a class="ae jf" rel="noopener" href="/@kidinamoto/payable-keyword-in-solidity-375b5c9044df">关于主题</a>的更多信息，作者<a class="mi mj gr" href="https://medium.com/u/bdde9b38adcd?source=post_page-----ac0f733eecdd--------------------------------" rel="noopener" target="_blank"> Sophie Wong </a>。</p><p id="eda4" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们希望存款和取款功能有时间限制。为此，我们将在定时契约中为函数创建<a class="ae jf" href="http://solidity.readthedocs.io/en/v0.4.21/contracts.html#function-modifiers" rel="noopener ugc nofollow" target="_blank">修饰符。它们在被修改的函数执行之前被执行，是放置函数执行约束的好地方。</a></p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="deed" class="lu kp ht mp b fv mt mu l mv mw"><strong class="mp hu">pragma </strong>solidity ^0.4.21;<br/><br/><strong class="mp hu">contract </strong>Timed {<br/><br/>    <strong class="mp hu">uint256 public </strong>deadline;<br/><br/>    <strong class="mp hu">modifier </strong>onlyWhileOpen {<br/>        require(block.timestamp &lt;= deadline);<br/>        _;<br/>    }<br/><br/>    <strong class="mp hu">modifier </strong>onlyWhileClosed {<br/>        require(block.timestamp &gt; deadline);<br/>        _;<br/>    }<br/>}</span></pre><p id="d4cf" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们在这里使用了一些奇特的东西，所以让我们解释一下:</p><ul class=""><li id="6ed4" class="mx my ht ji b jj jk jn jo jr mz jv na jz nb kd nc nd ne nf dt translated"><strong class="ji hu"> block.timestamp </strong>以历元秒为单位提供当前块时间</li><li id="a340" class="mx my ht ji b jj ng jn nh jr ni jv nj jz nk kd nc nd ne nf dt translated"><strong class="ji hu">修改器</strong>创建用于功能的修改器</li><li id="033f" class="mx my ht ji b jj ng jn nh jr ni jv nj jz nk kd nc nd ne nf dt translated"><strong class="ji hu">_；</strong>此语句后，修改功能的工作流程继续</li></ul><p id="870b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在让我们进入池实现部分。首先让我们创建构造函数</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="fa8c" class="lu kp ht mp b fv mt mu l mv mw"><strong class="mp hu">contract </strong>Pool <strong class="mp hu">is </strong>iPool, Timed {<br/>    <strong class="mp hu">using </strong>SafeMath <strong class="mp hu">for uint256</strong>;<br/><br/>    <strong class="mp hu">string public </strong>name;<br/>    <strong class="mp hu">address public </strong>token;<br/>    <strong class="mp hu">uint256 public </strong>rate;<br/><br/>    <strong class="mp hu">function </strong>Pool(<strong class="mp hu">string </strong>_name, <strong class="mp hu">uint256 </strong>_rate, <strong class="mp hu">uint256 </strong>_deadline) <strong class="mp hu">public </strong>{<br/>        require(_rate &gt; 0);<br/>        require(_deadline &gt; block.timestamp);<br/>        name = _name;<br/>        rate = _rate;<br/>        deadline = _deadline;<br/>        token = <strong class="mp hu">new </strong>FishToken(_deadline);<br/>    }</span></pre><p id="931e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">构造函数创建将与该池关联的FishToken实例。FishToken将用于存款跟踪和鲨鱼选择。</p><p id="9757" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们必须在调用构造函数时做一些检查。截止日期必须大于当前时间，奖励分配率必须大于0。</p><p id="fcab" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们看看存款功能</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="b9c4" class="lu kp ht mp b fv mt mu l mv mw"><strong class="mp hu">function </strong>() <strong class="mp hu">public payable </strong>onlyWhileOpen {<br/>    require(msg.value &gt; 0);<br/>    <strong class="mp hu">uint256 </strong>rewardTokens = rate.mul(msg.value);<br/>    require(iFishToken(token).issueTokens(msg.sender, rewardTokens));<br/>}</span></pre><p id="de6a" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这么简单对吧？实际上，它所做的只是根据设定的汇率计算收到的令牌，并触发FishToken合约上的发行功能。现在我们可以看到如何应用函数修饰符。<strong class="ji hu"> onlyWhileOpen </strong>修饰符将在函数执行之前执行，如果时间超过截止日期，将抛出错误。</p><p id="59ed" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">和我们的取款功能</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="beaa" class="lu kp ht mp b fv mt mu l mv mw"><strong class="mp hu">function </strong>withdraw() <strong class="mp hu">public </strong>onlyWhileClosed <strong class="mp hu">returns </strong>(<strong class="mp hu">bool </strong>success) {<br/>    <strong class="mp hu">if</strong>(iFishToken(token).isShark(msg.sender)) {<br/>       msg.sender.transfer(<strong class="mp hu">address</strong>(this).balance);<br/>        <strong class="mp hu">return true</strong>;<br/>    }<br/>    <strong class="mp hu">return false</strong>;<br/>}</span></pre><p id="6cb3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">撤回功能仅在关闭修改器时由<strong class="ji hu">修改。它还执行检查，如果发送者想要撤回是真正的鲨鱼。如果是的话，他会得到泳池合同的所有乙醚。幸运的家伙！</strong></p><p id="3338" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这就是泳池合同，它有足够多的逻辑，我们不想进一步复杂化的事情。让我们进入最复杂的部分，我们的鱼叉合同。</p><h2 id="2772" class="lu kp ht bd kq lv lw lx ku ly lz ma ky jr mb mc lc jv md me lg jz mf mg lk mh dt translated">鱼类代币合同</h2><p id="fa19" class="pw-post-body-paragraph jg jh ht ji b jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd hm dt translated">现在，我们想记录乙醚的贡献，并确定鲨鱼。这是Dapp中最复杂的部分，所以如果看起来逻辑不清楚，不要绝望。我首先使用了一个标准的令牌契约，并做了很多修改以适应这个Dapp的需要。</p><p id="066e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我将合同命名为FishToken，因为它跟踪池中的鱼，并确定其中的鲨鱼。</p><p id="e5b7" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因此，让我们为这个契约定义一个接口</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="6e94" class="lu kp ht mp b fv mt mu l mv mw"><strong class="mp hu">contract </strong>iFishToken {<br/><br/>    <strong class="mp hu">function </strong>balanceOf(<strong class="mp hu">address </strong>_owner) <strong class="mp hu">public view returns </strong>(<strong class="mp hu">uint256 </strong>balance);<br/><br/>    <strong class="mp hu">function </strong>transfer(<strong class="mp hu">address </strong>_to, <strong class="mp hu">uint256 </strong>_amount) <strong class="mp hu">public returns </strong>(<strong class="mp hu">bool </strong>success);<br/><br/>    <strong class="mp hu">function </strong>issueTokens(<strong class="mp hu">address </strong>_beneficiary, <strong class="mp hu">uint256 </strong>_amount) <strong class="mp hu">public returns </strong>(<strong class="mp hu">bool </strong>success);<br/><br/>    <strong class="mp hu">function </strong>getShark() <strong class="mp hu">public view returns </strong>(<strong class="mp hu">address </strong>sharkAddress, <strong class="mp hu">uint256 </strong>sharkBalance);<br/><br/>    <strong class="mp hu">function </strong>isShark(<strong class="mp hu">address </strong>_address) <strong class="mp hu">public view returns </strong>(<strong class="mp hu">bool </strong>success);<br/><br/>    <em class="nl">/// @notice Event propagated on every executed transaction<br/>    </em><strong class="mp hu">event </strong>LogTransfer(<strong class="mp hu">address </strong>indexed _from, <strong class="mp hu">address </strong>indexed _to, <strong class="mp hu">uint256 </strong>_value);<br/><br/>    <em class="nl">/// @notice Event propagated when new deposit is made to the pool<br/>    </em><strong class="mp hu">event </strong>LogIssue(<strong class="mp hu">address </strong>indexed _member, <strong class="mp hu">uint256 </strong>_value);<br/><br/>    <em class="nl">/// @notice Event propagated when new address has the most tokens<br/>    </em><strong class="mp hu">event </strong>LogNewShark(<strong class="mp hu">address </strong>indexed _shark, <strong class="mp hu">uint256 </strong>_value);<br/>}</span></pre><p id="a884" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我知道，太多了。让我们过一遍。构造函数的首次实现</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="c5e1" class="lu kp ht mp b fv mt mu l mv mw"><strong class="mp hu">contract </strong>FishToken <strong class="mp hu">is </strong>iFishToken, Ownable, Timed {<br/>    <strong class="mp hu">using </strong>SafeMath <strong class="mp hu">for uint256</strong>;<br/><br/>    <strong class="mp hu">uint8 public </strong>decimals;                <em class="nl">//How many decimals to show<br/>    </em><strong class="mp hu">address public </strong>currentShark;<br/>    <strong class="mp hu">uint256 public </strong>totalSupply;<br/>    <strong class="mp hu">mapping</strong>(<strong class="mp hu">address </strong>=&gt; <strong class="mp hu">uint256</strong>) <strong class="mp hu">public </strong>balances;<br/><br/>    <strong class="mp hu">mapping</strong>(<strong class="mp hu">address </strong>=&gt; <strong class="mp hu">bool</strong>) <strong class="mp hu">public </strong>participantsMap;<br/>    <strong class="mp hu">address</strong>[] <strong class="mp hu">public </strong>participantsArray;<br/><br/>    <strong class="mp hu">function </strong>FishToken(<strong class="mp hu">uint256 </strong>_deadline) <strong class="mp hu">public </strong>{<br/>        deadline = _deadline;<br/>        totalSupply = 0;<br/>        currentShark = msg.sender;<br/>        owner = msg.sender;<br/>    }</span></pre><p id="a9cf" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">函数<strong class="ji hu"> balanceOf() </strong>和<strong class="ji hu"> transfer() </strong>类似于经典的令牌函数。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="caec" class="lu kp ht mp b fv mt mu l mv mw"><strong class="mp hu">function </strong>transfer(<strong class="mp hu">address </strong>_to, <strong class="mp hu">uint256 </strong>_value) <strong class="mp hu">public </strong>onlyWhileOpen <strong class="mp hu">returns </strong>(<strong class="mp hu">bool </strong>success) {<br/>    <strong class="mp hu">if </strong>(balances[msg.sender] &lt; _value || balances[_to] + _value &lt;= balances[_to]) {<br/>        <strong class="mp hu">return false</strong>;<br/>    }<br/>    addToParticipants(_to);<br/>    balances[msg.sender] = balances[msg.sender].sub(_value);<br/>    balances[_to] = balances[_to].add(_value);<br/><br/>    emit LogTransfer(msg.sender, _to, _value);<br/><br/>    determineNewShark();<br/><br/>    <strong class="mp hu">return true</strong>;<br/>}</span><span id="f64d" class="lu kp ht mp b fv nm mu l mv mw"><strong class="mp hu">function </strong>balanceOf(<strong class="mp hu">address </strong>_owner) <strong class="mp hu">public view returns </strong>(<strong class="mp hu">uint256 </strong>balance) {<br/>    <strong class="mp hu">return </strong>balances[_owner];<br/>}</span></pre><p id="75e0" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">他们所做的是使参与者之间的奖励令牌转移，并检查当前余额。仅当打开修饰符时，才使用<strong class="ji hu">修改转移，这意味着转移仅在收集期内是可能的。这样，如果从多个地址投稿，用户可以聚合收到的令牌。或者给另一个人代币。</strong></p><p id="c8dd" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们使用zeppelin-solidity库中的<a class="ae jf" href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol" rel="noopener ugc nofollow" target="_blank"> SafeMath库进行数学运算。此外，当事务发生时，我们会发出日志事件。事件是与客户端应用程序进行交互的一种很好的方式。您可以创建侦听器并侦听协定上发出的事件。这样，当事情发生时，您可以获得推送事件，而不需要定期查询合同。</a></p><p id="601c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">函数<strong class="ji hu"> addToParticipants() </strong>和<strong class="ji hu"> determineNewShark() </strong>，用于鲨鱼选择。每当令牌分发发生变化时，我们都需要找到新的shark。</p><p id="4c4b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">接下来是函数<strong class="ji hu"> issueTokens() </strong></p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="0404" class="lu kp ht mp b fv mt mu l mv mw"><strong class="mp hu">function </strong>issueTokens(<strong class="mp hu">address </strong>_beneficiary, <strong class="mp hu">uint256 </strong>_amount) <strong class="mp hu">public </strong>onlyOwner onlyWhileOpen <strong class="mp hu">returns </strong>(<strong class="mp hu">bool </strong>success) {<br/>    <strong class="mp hu">if</strong>(balances[_beneficiary] + _amount &lt;= balances[_beneficiary]) {<br/>        <strong class="mp hu">return false</strong>;<br/>    }<br/>    addToParticipants(_beneficiary);<br/>    balances[_beneficiary] = _amount.add(balances[_beneficiary]);<br/>    totalSupply = _amount.add(totalSupply);<br/><br/>    emit LogIssue(_beneficiary, _amount);<br/><br/>    determineNewShark();<br/><br/>    <strong class="mp hu">return true</strong>;<br/>}</span></pre><p id="5842" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">函数<strong class="ji hu"> issueToken() </strong>由池合同触发。因为我们使用池契约创建了FishToken契约，所以该契约成为所有者。用<strong class="ji hu"> onlyOwner </strong>修饰符修改<strong class="ji hu"> issueTokens() </strong>，makes仅在从创建FishToken契约的池契约调用时执行。这意味着只有母池合同可以发行新令牌。</p><p id="9e3f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">对于Ownable contract，我使用了来自zeppelin-solidity仓库的那个。他们有很多合同，你可以在自己的Dapps中使用。</p><p id="f745" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">发行代币非常简单。我们增加了地址和总供给的平衡。我们必须再次调用函数<strong class="ji hu"> addToParticipants() </strong>和<strong class="ji hu"> determineNewShark() </strong>，因为令牌分发的状态发生了变化，我们必须检查Shark是否发生了变化。</p><p id="39b9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们还发出事件<strong class="ji hu">logisue()</strong>，这将有助于我们使用客户端应用程序。</p><h2 id="04b4" class="lu kp ht bd kq lv lw lx ku ly lz ma ky jr mb mc lc jv md me lg jz mf mg lk mh dt translated">确定鲨鱼</h2><p id="6ab5" class="pw-post-body-paragraph jg jh ht ji b jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd hm dt translated">该函数驻留在FishToken合同中。该算法的基本思想是，记录所有可能有令牌的地址。这是在participantsArray中完成的。为了避免在<strong class="ji hu">分词短语</strong>中出现双重插入，我们还增加了<strong class="ji hu">分词短语</strong>，对于添加到数组中的地址，该短语被设置为true。</p><p id="373b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要确定鲨鱼，我们只需循环通过<strong class="ji hu"> participantsArray </strong>并将令牌最多的一个设置为鲨鱼。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="2263" class="lu kp ht mp b fv mt mu l mv mw"><strong class="mp hu">mapping</strong>(<strong class="mp hu">address </strong>=&gt; <strong class="mp hu">bool</strong>) <strong class="mp hu">public </strong>participantsMap;<br/><strong class="mp hu">address</strong>[] <strong class="mp hu">public </strong>participantsArray;</span><span id="1ab7" class="lu kp ht mp b fv nm mu l mv mw"><strong class="mp hu">function </strong>determineNewShark() <strong class="mp hu">internal </strong>{<br/>    <strong class="mp hu">address </strong>shark = participantsArray[0];<br/>    <strong class="mp hu">uint </strong>arrayLength = participantsArray.length;<br/>    <strong class="mp hu">for </strong>(<strong class="mp hu">uint </strong>i=1; i &lt; arrayLength; i++) {<br/>        <strong class="mp hu">if </strong>(balances[shark] &lt; balances[participantsArray[i]]) {<br/>            shark = participantsArray[i];<br/>        }<br/>    }<br/><br/>    <strong class="mp hu">if</strong>(currentShark != shark) {<br/>        currentShark = shark;<br/>        emit LogNewShark(shark, balances[shark]);<br/>    }<br/>}<br/><br/><strong class="mp hu">function </strong>addToParticipants(<strong class="mp hu">address </strong>_address) <strong class="mp hu">internal returns </strong>(<strong class="mp hu">bool </strong>success) {<br/>    <strong class="mp hu">if</strong>(participantsMap[_address]) {<br/>        <strong class="mp hu">return false</strong>;<br/>    }<br/>    participantsMap[_address] = <strong class="mp hu">true</strong>;<br/>    participantsArray.push(_address);<br/>    <strong class="mp hu">return true</strong>;<br/>}</span></pre><p id="5a4f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这些功能被设置为内部功能，这意味着它们只能由合同中的另一个功能触发，而不能作为合同上的一项交易。</p><p id="55fc" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">每当令牌分发的状态改变时，我们必须确定新的Shark。这意味着我们必须对每次交易或令牌发放进行重新计算。</p><h1 id="c41c" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll dt translated"><strong class="ak">结论</strong></h1><p id="fe46" class="pw-post-body-paragraph jg jh ht ji b jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd hm dt translated">开始吧，我们已经创建了一个功能齐全的Dapp，它可以跟踪Ether对池的贡献，并确定Shark是其中最大的贡献者。我们已经启用了地址间奖励令牌的转移，这意味着您可以和一个朋友一起参与，也可以使用多个地址。</p><p id="9fab" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你在我的代码中发现任何错误吗？您看到优化它的方法了吗？请让我知道，我很想听听你的反馈！</p><p id="fe4f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">Dapp演示版</strong>可在<a class="ae jf" href="http://34.210.217.34/" rel="noopener ugc nofollow" target="_blank">这个地址</a>上获得。</p><p id="220d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">所有<strong class="ji hu">源代码</strong>都可以在<a class="ae jf" href="https://github.com/joze144/pool-shark" rel="noopener ugc nofollow" target="_blank">这个GitHub库中</a>免费获得。</p><h2 id="fc27" class="lu kp ht bd kq lv lw lx ku ly lz ma ky jr mb mc lc jv md me lg jz mf mg lk mh dt translated">该系列的部分:</h2><ul class=""><li id="f0c2" class="mx my ht ji b jj lm jn ln jr nn jv no jz np kd nc nd ne nf dt translated"><strong class="ji hu">第一部分-稳健智能合同</strong></li><li id="6351" class="mx my ht ji b jj ng jn nh jr ni jv nj jz nk kd nc nd ne nf dt translated"><a class="ae jf" rel="noopener" href="/@jozhe/testing-solidity-dapp-sotp-part-2-9685b3375aaf">第2部分-检测稠度Dapp </a></li><li id="af72" class="mx my ht ji b jj ng jn nh jr ni jv nj jz nk kd nc nd ne nf dt translated"><a class="ae jf" rel="noopener" href="/@jozhe/node-js-backend-service-for-ethereum-dapp-sotp-part-3-2d3aa5ec50e9">第3部分-淋巴结。Solidity Dapp的JS后端服务</a></li><li id="8211" class="mx my ht ji b jj ng jn nh jr ni jv nj jz nk kd nc nd ne nf dt translated"><a class="ae jf" rel="noopener" href="/@jozhe/react-web-dapp-with-metamask-web3-sotp-part-4-f252ebe8d07f">第4部分-让Web应用与元掩码Web3反应</a></li></ul><figure class="mk ml mm mn fq iu fe ff paragraph-image"><a href="http://bit.ly/2G71Sp7"><div class="fe ff nq"><img src="../Images/449450761cd76f44f9ae574333f9e9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKX2mtg7p1lOs7JmosPLsA.png"/></div></a></figure></div></div>    
</body>
</html>