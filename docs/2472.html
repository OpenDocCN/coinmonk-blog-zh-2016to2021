<html>
<head>
<title>A Formal Model in K of the Beacon Chain: Ethereum 2.0’s Primary Proof-of-Stake Blockchain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">信标链K中的正式模型:以太坊2.0的主要利害关系证明区块链</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-formal-model-in-k-of-the-beacon-chain-ethereum-2-0s-primary-proof-of-stake-blockchain-429883e316b9?source=collection_archive---------1-----------------------#2019-10-22">https://medium.com/coinmonks/a-formal-model-in-k-of-the-beacon-chain-ethereum-2-0s-primary-proof-of-stake-blockchain-429883e316b9?source=collection_archive---------1-----------------------#2019-10-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="6693" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">作者:Musab A. Alturki，Denis Bogdanas，Chris Hathhorn和Daejun Park</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/5e22211ad156bf67d4f24f4807e4e165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vVY0Gar9Bslqr6l2.png"/></div></div></figure><p id="87e2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">随着即将到来的2.0版本(代号为Serenity)的重大更新，<a class="ae kq" href="https://docs.ethhub.io/ethereum-roadmap/ethereum-2.0/" rel="noopener ugc nofollow" target="_blank">以太坊</a>正在过渡到一个分片的、利益相关(PoS)共识机制。它带来了更好的能效、安全性和可扩展性。以太坊2.0的特定PoS协议被称为信标链。</p><p id="7670" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们很高兴地报告<a class="ae kq" href="https://runtimeverification.com" rel="noopener ugc nofollow" target="_blank">运行时验证</a>和<a class="ae kq" href="https://www.ethereum.org" rel="noopener ugc nofollow" target="_blank">以太坊基金会</a>之间正在进行的合作中的第一个里程碑，以建立一个用于建模和验证信标链的正式框架。我们已经在<a class="ae kq" href="http://www.kframework.org" rel="noopener ugc nofollow" target="_blank"> K框架</a>中完成了信标链的可执行形式化模型。K规范<a class="ae kq" href="https://github.com/runtimeverification/beacon-chain-spec" rel="noopener ugc nofollow" target="_blank">和描述这项工作的</a><a class="ae kq" href="https://github.com/runtimeverification/beacon-chain-spec/blob/master/report/bck-report.pdf" rel="noopener ugc nofollow" target="_blank">技术报告</a>都可以在网上找到。</p><p id="4270" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">那么信标链是什么？它在K中的模型是如何开发出来的？为什么这种发展很重要？</p><h1 id="5775" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">简而言之，信标链</h1><p id="f193" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">信标链是即将推出的<a class="ae kq" href="https://docs.ethhub.io/ethereum-roadmap/ethereum-2.0" rel="noopener ugc nofollow" target="_blank">以太坊2.0 </a>的PoS协议层。该协议主要负责在参与该协议的网络中的所有节点之间达成关于系统状态的共识。</p><p id="510f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在协议中被称为验证者的参与节点主要通过建议新的信标块或投票支持现有的信标块来对系统的分布式操作做出贡献，这取决于节点的当前状态。信标块主要封装了发布到网络的一组投票。该协议管理如何选择验证者来提议和投票给块，以确保每个验证者都有公平的机会做出贡献。</p><p id="0dc8" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">对信标块的投票被称为证明。证明是共识机制的基本组成部分。通过信标块的证明:</p><ul class=""><li id="c010" class="lo lp ht jw b jx jy ka kb kd lq kh lr kl ls kp lt lu lv lw dt translated">验证器证明块是有效的，并且它应该被附加到链上；</li><li id="8eea" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">如果链已经分叉成多个分支(根据<a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/blob/dev/specs/core/0_fork-choice.md" rel="noopener ugc nofollow" target="_blank">分叉选择规则</a>)，验证器通过识别块应该被附加到哪里来为“规范的块链”投票；</li><li id="7e96" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">验证器有助于决定块的终结性，这是一个告诉我们什么时候信标块可以被认为是最终的，因此不应该被还原的过程(根据<a class="ae kq" href="http://arxiv.org/abs/1710.09437" rel="noopener ugc nofollow" target="_blank">卡斯珀·FFG</a>)；</li><li id="43fa" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">如果块不属于主链，验证器会投票给块的碎片。直观地说，碎片是一个链接到信标链的独立链，可以通过系统中验证器的子集与状态中的其他碎片并行处理，显著提高系统一次处理更多事务的能力，从而提高其可伸缩性(参见<a class="ae kq" href="https://github.com/ethereum/wiki/wiki/Sharding-FAQ" rel="noopener ugc nofollow" target="_blank">碎片和交叉链接</a>)。</li></ul><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mc"><img src="../Images/2281df8f99dc9631d1a1ba4325cc7ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mB-ZJWJ1cOGoY70B.png"/></div></div></figure><p id="a2e0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">最后，遵循协议并做出明智决定的验证者将获得乙醚奖励，作为红利分发，以鼓励正确的行为。另一方面，一个偏离协议或者行为不稳定的验证器可能会受到惩罚，比如拒绝给它分红，或者在某些严重的情况下，削减它的股份。这种奖惩系统有助于使恶意用户在经济上无法成功攻击系统(参见<a class="ae kq" href="https://notes.ethereum.org/@vbuterin/rkhCgQteN?type=view" rel="noopener ugc nofollow" target="_blank"> Serenity Design基本原理注释</a>)。</p><p id="0f3d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">信标链目前由以太坊基金会开发的Python <a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/blob/dev/specs/core/0_beacon-chain.md" rel="noopener ugc nofollow" target="_blank">“以太坊2.0阶段0 —信标链”</a>中的参考实现定义。</p><p id="ee7b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">定义协议操作的实现的主要组件是信标链状态转换功能<code class="eh md me mf mg b"><a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/blob/dev/specs/core/0_beacon-chain.md" rel="noopener ugc nofollow" target="_blank">state_transition</a></code>。该函数实现的相关部分摘录如下:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/7452101f05ac7dceab697a92b808b78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zgM1-CUURkB_l4wj.png"/></div></div></figure><p id="97f7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">处理开始于起源状态(已经处理了起源信标块的状态)。给定要处理的下一个信标块，并假设该块是有效的，信标链状态转换功能将给定的信标链状态(前状态)转换成新的状态(后状态)。这种后状态反映了以下结果:</p><ol class=""><li id="5f4c" class="lo lp ht jw b jx jy ka kb kd lq kh lr kl ls kp mh lu lv lw dt translated">说明(潜在的)丢失的块；(<code class="eh md me mf mg b">process_slots</code>)；</li><li id="374d" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp mh lu lv lw dt translated">处理程序块的内容(<code class="eh md me mf mg b">process_block</code>)。</li></ol><p id="07c9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">关于转换功能和信标链操作的更详细的描述可以在<a class="ae kq" href="https://notes.ethereum.org/@djrtwo/ByHlx-j6V?type=view" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="3c07" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">用K语言建模信标链</h1><p id="3440" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">我们在这项工作中的目标是建立一个信标链的正式模型，该模型尽可能与<a class="ae kq" href="https://github.com/ethereum/eth2.0-specs" rel="noopener ugc nofollow" target="_blank">“以太坊2.0阶段0规范”</a>给出的参考实现相对应，以便实现以下任务:</p><ul class=""><li id="bddf" class="lo lp ht jw b jx jy ka kb kd lq kh lr kl ls kp lt lu lv lw dt translated">模拟或动画显示信标链状态转换功能的执行；</li><li id="d502" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">从信标链测试套件运行现有测试；</li><li id="9ea6" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">分析现有测试套件的代码覆盖率，并用新的测试来改进它。</li></ul><p id="448d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><a class="ae kq" href="http://www.kframework.org" rel="noopener ugc nofollow" target="_blank"> K </a>是实现这一目标的一个非常合适的框架，因为它支持信标链的正式模型的开发，其特征在于:</p><ol class=""><li id="2fd8" class="lo lp ht jw b jx jy ka kb kd lq kh lr kl ls kp mh lu lv lw dt translated">可通过K工具中的模式重写来执行，以便从规范中直接获得信标链状态转移函数的解释器(无需额外成本)；</li><li id="542c" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp mh lu lv lw dt translated">具体，因为它的规范直接对应于系统的Python实现(对一些特定的抽象取模，比如签名验证)。</li></ol><p id="82cd" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">K模型还为更精细的验证任务铺平了道路，如可达性分析和演绎验证，但这些是正在进行和未来工作的一部分，将在其他地方描述。</p><p id="56c9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在项目的Github库中可以获得K版本模型的完整规范，以及一份更详细描述这项工作的<a class="ae kq" href="https://github.com/runtimeverification/beacon-chain-spec/blob/master/report/bck-report.pdf" rel="noopener ugc nofollow" target="_blank">技术报告</a>。</p><h1 id="cd10" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">信标链在K中是如何建模的？</h1><p id="0710" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">非常一般地，信标链在K中被建模为状态转换系统，其状态是信标链状态，并且其转换由主信标链状态转换函数定义。</p><p id="a5d4" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在K中，信标链状态被指定为由(可能嵌套的)单元组成的配置，其中每个单元表示定义协议所需的配置的语义元素。例如，下面的摘录显示了<code class="eh md me mf mg b">&lt;beacon-chain/&gt;</code>配置的两个单元:<code class="eh md me mf mg b">&lt;k/&gt;</code>单元，它是一个保存要执行的程序(计算)的特殊单元，以及<code class="eh md me mf mg b">&lt;state/&gt;</code>单元，它包含信标链状态的所有结构元素(下面只显示了三个，三个点表示省略的单元):</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/2c567a1359f9623b8059bb7b52ea951d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kNdEwem6Yi0HmgId.png"/></div></div></figure><p id="5d47" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">信标链状态转移函数由K中的算子指定，该算子将由当前信标链配置建模的信标链前状态转换成由结果K配置建模的信标链后状态。运算符声明如下:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/a48c349a3a76ff4dfa538cf69faf21fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BvxSpbN6Qbw8hI8J.png"/></div></div></figure><p id="c5d4" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如上所述，涉及到两个主要的连续步骤:<code class="eh md me mf mg b">process_slots</code>和<code class="eh md me mf mg b">process_block</code>。使用操作符<code class="eh md me mf mg b">~&gt;</code>，K中命令的排序自然被指定为在延续之上堆叠计算。例如，使用以下K规则来定义状态转移函数:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/bdc6bf17a5d4a3b1f107b53b133c298e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l2Zguki836gXUjVx.png"/></div></div></figure><p id="3dba" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">只有当<code class="eh md me mf mg b">process_slots</code>成功终止时，由<code class="eh md me mf mg b">process_block</code>定义的下一个计算才会发生，它捕获预期的语义。</p><p id="29bd" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在开发转换函数的语义规范时，我们面临的一个挑战是Python语义丰富的表达式和命令式编程风格与K的语言定义结构和声明式规范风格之间的不匹配。在这个开发过程中，我们已经确定了一些模式，以及如何在K中优雅地指定它们，例如上面描述的用于排序的堆栈计算结构。其他模式更复杂，不匹配更明显，例如列表理解表达式，它在信标链的引用实现中被大量使用。在这些情况下，这种编码通常非常冗长，但是如果不在k中定义一个中间语言结构，这种编码是不可避免的。<a class="ae kq" href="https://github.com/runtimeverification/beacon-chain-spec/blob/master/report/bck-report.pdf" rel="noopener ugc nofollow" target="_blank">技术报告</a>详细介绍了这些模式以及它们是如何被指定的。</p><h1 id="7da5" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">验证模型</h1><p id="00d4" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">以太坊基金会为信标链提供了丰富的<a class="ae kq" href="https://github.com/ethereum/eth2.0-spec-tests" rel="noopener ugc nofollow" target="_blank">测试套件。除了作为Python实现的调试工具，测试套件还被第三方生产客户端开发人员用来确保与参考实现的一致性。测试套件由3000多个不同的单元测试组成。</a></p><p id="bc40" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">给定开发K模型的抽象级别，信标链的标准测试套件中的测试可以直接在模型中执行，而不需要任何工具。这被证明是非常宝贵的，因为它提供了一种机制来验证模型，并确保模型与参考实现一致，就像验证其他生产实现一样。所有的测试都可以按照<a class="ae kq" href="https://github.com/runtimeverification/beacon-chain-spec" rel="noopener ugc nofollow" target="_blank">项目的存储库</a>中给出的指令自动运行。</p><h1 id="bd0b" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">扩展测试覆盖范围</h1><p id="1e30" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">标准信标链测试套件的设计目的是使用Python可用的代码覆盖率分析工具来最大化代码覆盖率。然而，Python的覆盖范围通常是相当粗粒度的；它没有区分语义丰富的Python结构(比如列表理解表达式)的各个执行分支。</p><p id="6fa5" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">k提供了一个不同的基于规则的覆盖率分析工具。它检测在执行中是否应用了规则(如果是，应用了多少次)。使用这种基于K的工具的语义覆盖已经被证明在其他语言的上下文中是有用的，比如JavaScript，我们在所有浏览器中都发现了新的错误(这些结果在<a class="ae kq" href="http://dx.doi.org/10.1145/2737924.2737991" rel="noopener ugc nofollow" target="_blank"> PLDI的论文</a>中有描述)。</p><p id="0fc7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">因此，我们的计划是评估标准Python代码覆盖率确保语义覆盖率的情况，并查看基于规则的覆盖率分析是否可以揭示标准Python代码覆盖率工具未检测到的任何未覆盖的功能。事实上，分析揭示了测试没有覆盖或者没有充分覆盖的执行路径，而Python的覆盖率没有检测到这些路径。这些检测中的大部分是在复杂行为的规范中，就像在列表理解表达式和复杂循环中通常遇到的那些。</p><p id="45b1" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">下面是由K coverage工具生成的覆盖率分析报告的快照，显示了一个没有在测试套件中的任何测试中应用的规则。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/da701364efb88a9617c338ae02e7c924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lX1FlATmLanm2Uwj.png"/></div></div></figure><h1 id="df8a" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">走向</h1><p id="482e" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">信标链的可执行K模型是实现正式验证信标链及其参考实现的基本安全性和活性属性的最终目标的第一步，但也是关键的一步。事实上，如果没有一个可信的、正式的系统模型来验证，形式验证的问题是没有意义的。除了执行状态转换功能、运行测试和分析测试覆盖的能力之外，这里给出的K形式模型还可以用于陈述和验证在这个低抽象级别上可表达的低级别不变量。</p><p id="b989" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">然而，信标链是一个非常复杂的协议。在这个低抽象层次上直接验证安全性和活性这样的高级属性通常是不可行的。相反，通常采用抽象提炼技术。因此，我们的计划是遵循以下方法:</p><ol class=""><li id="b8ba" class="lo lp ht jw b jx jy ka kb kd lq kh lr kl ls kp mh lu lv lw dt translated">构建这个具体模型的抽象，保留协议的核心共识机制；</li><li id="c7a5" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp mh lu lv lw dt translated">在抽象模型上证明期望的属性；</li><li id="27a0" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp mh lu lv lw dt translated">表明这些属性在具体模型中得以保留。</li></ol><p id="7734" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们期待着继续与以太坊基金会在这项工作上的合作。为此，我们非常荣幸地与以太坊基金会的以下专家合作:Danny Ryan、Carl Beekhuizen和Martin Lundfall。</p></div><div class="ab cl mi mj hb mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hm hn ho hp hq"><p id="50d7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><em class="mp">原载于2019年10月22日</em><a class="ae kq" href="https://runtimeverification.com/blog/a-formal-model-in-k-of-the-beacon-chain-ethereum-2-0s-primary-proof-of-stake-blockchain/" rel="noopener ugc nofollow" target="_blank"><em class="mp">【https://runtimeverification.com】</em></a><em class="mp">。</em></p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff mq"><img src="../Images/673b3528e0b341cca62769c9baa632cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bcTJUjFtXf1QtlWzlS04XQ.jpeg"/></div></a></figure><blockquote class="mr"><p id="00bd" class="ms mt ht bd mu mv mw mx my mz na kp ek translated"><a class="ae kq" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nc nd ne nf ng jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nb"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>