<html>
<head>
<title>How VivoPay Leveraged the Secure Enclave and CryptoKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">VivoPay如何利用Secure Enclave和CryptoKit</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-vivopay-leveraged-the-secure-enclave-and-cryptokit-8f0adf865f99?source=collection_archive---------2-----------------------#2020-09-23">https://medium.com/coinmonks/how-vivopay-leveraged-the-secure-enclave-and-cryptokit-8f0adf865f99?source=collection_archive---------2-----------------------#2020-09-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/47578eebce2922c25a16b2426a018d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*oSZghn2_yVX48zyjQwrADA.jpeg"/></div><figcaption class="ix iy fg fe ff iz ja bd b be z ek">Apple’s T2 Secure Enclave chip in an Intel Mac (the Secure Enclave in iOS devices and Apple Silicon Macs is integrated in Apple’s Axx SoC)</figcaption></figure><p id="2107" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">VivoPay是一个极其安全的加密钱包，利用了现代移动设备和MAC电脑中的安全飞地以及苹果新的CryptoKit框架。</p><h1 id="518b" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">安全飞地</h1><p id="d8a5" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">Secure Enclave是Android、iPhone、iPad和MAC中的一个芯片，可以保护你的生物统计数据，如FaceID和TouchID。开发人员也可以访问Secure Enclave，它可以处理少量有用的加密功能:</p><ul class=""><li id="6c4e" class="ld le ht jd b je jf ji jj jm lf jq lg ju lh jy li lj lk ll dt translated">生成私钥(并派生公钥)并存储在安全飞地中生成的私钥(不能存储在安全飞地之外生成的私钥)</li><li id="9748" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">通过向安全区域发送明文来加密数据(明文)。安全飞地将发回加密数据(密文)</li><li id="3bd6" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">通过向安全区域发送密文来解密数据。安全区域将发送回原始的纯文本。</li><li id="3f54" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">通过将数据(散列)发送到安全区域来创建签名。安全区域会发回一个签名</li><li id="5fab" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">通过将数据(散列)和签名发送到Secure Enclave来验证签名。安全区域将返回true或false。</li></ul><p id="3fa8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">那么，让Secure Enclave创建一个Harmony One私钥就这么简单吗？不完全是。原来安全的Enclave芯片(安卓和苹果都有)使用与区块链不同的曲线。这使得在安全的飞地为区块链创造关键配对变得不可能。</p><p id="c974" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">此外，因为私钥不能从安全区域导出，所以没有办法备份私钥。如果设备丢失或损坏，私钥将永远丢失。因此，即使这是可能的(这是不可能的),它可能仍然不是一个好主意。</p><p id="bdb9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">附带说明:如果你真的想的话，可以使用安全飞地从头开始建造一个区块链。早在2018年，我就创造了一个用于教育目的的区块链<a class="ae jz" href="https://github.com/VivoPay/NaiveSwiftCoin" rel="noopener ugc nofollow" target="_blank"/>,它就是这么做的。</p><p id="6852" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在VivoPay中，我们使用Secure Enclave来加密和解密钱包文件，因此钱包文件只能在创建它的设备上使用。这提高了安全性。我们使用苹果的低级安全框架来保证Enclave计算的安全。</p><p id="315e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们还使用名为CryptoKit的高级框架来加密备份文件(如果用户使用默认备份而不是恢复短语)。</p><h1 id="cb8d" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">苹果密码套件</h1><p id="8f9b" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">当苹果在2019年推出CryptoKit时，出现了一些混乱。有些人(还有出版物！)认为这意味着苹果接受了加密货币，CryptoKit是一个加密货币框架。不幸的是，正如我在推特风暴中解释的那样，情况并非如此。相反，CryptoKit为Secure Enclave的一些基本功能提供了一个高级接口，如创建私钥(与区块链不兼容)和旨在建立SSL通信的基本加密和签名。</p><p id="d347" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在VivoPay中，我们在默认模式下使用CryptoKit对钱包备份文件进行加密(高级模式强制用户<a class="ae jz" rel="noopener" href="/@ronaldmannak/how-we-made-vivopay-crypto-wallet-super-easy-to-use-c5f5faa53b70">写下恢复短语</a>)。在<a class="ae jz" href="https://github.com/VivoPay/VivoPayEncryption" rel="noopener ugc nofollow" target="_blank"> VivoPay加密源代码</a>中，相关文件是Shared/Encryption/BackupEncryption . swift，加密和解密存储在一个简单的结构中，叫做backup Encryption，在文件底部的扩展中有一个方便的CryptoKit类SymmetricKey的init。</p><p id="73fa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">备份加密文件包含三种方法:</p><ul class=""><li id="5706" class="ld le ht jd b je jf ji jj jm lf jq lg ju lh jy li lj lk ll dt translated">根据用户选择的密码创建对称密钥</li><li id="9bd5" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">使用对称密钥加密钱包</li><li id="9fab" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">使用对称密钥解密钱包</li></ul><p id="724d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们使用256位密钥进行对称加密，并通过调用SymmetricKey便利初始化器来创建一个密钥。因为密码可能短于256位(=32个字节)，所以我们采用密码的SHA256哈希，并使用哈希的前32个字节作为密钥。</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="4fab" class="ma kb ht lw b fv mb mc l md me"><strong class="lw hu">init</strong>(password: String) {</span><span id="16f2" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    let</strong> hash = SHA256.hash(data: password.data(using: .utf8)!)</span><span id="92eb" class="ma kb ht lw b fv mf mc l md me">    // Convert the SHA256 to a string. This will be a 64 byte string</span><span id="a211" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    let</strong> hashString = hash.map { String(format: "%02hhx", $0) }.joined()</span><span id="870b" class="ma kb ht lw b fv mf mc l md me">    // Convert to 32 bytes / 256 bits</span><span id="ca25" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    let</strong> subString = String(hashString.prefix(32))</span><span id="f78b" class="ma kb ht lw b fv mf mc l md me">    // Convert the substring to data</span><span id="520a" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    let</strong> keyData = subString.data(using: .utf8)!</span><span id="7ead" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    self</strong>.init(data: keyData)</span><span id="3828" class="ma kb ht lw b fv mf mc l md me">}</span></pre><p id="18e9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦创建了密钥，它就可以用于对称加密和解密(在对称密码中)。CryptoKit提供两种对称密码:高级加密标准(AES)密码和ChaCha20-Poly1305密码。ChaChaPoly针对移动使用进行了优化，因此我们选择在VivoPay中使用ChaChaPoly。</p><p id="ccb3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有了SymmetricKey便利的init，加密变得很简单:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="bcaa" class="ma kb ht lw b fv mb mc l md me"><strong class="lw hu">func</strong> encrypt(<strong class="lw hu">_</strong> clearText: String, with password: String) <strong class="lw hu">throws</strong> -&gt; Data {</span><span id="11d8" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    let</strong> key = SymmetricKey(password: password)</span><span id="6344" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    let</strong> data = clearText.data(using: .utf8)!</span><span id="c9d1" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    return</strong> <strong class="lw hu">try</strong> ChaChaPoly.seal(data, using: key).combined</span><span id="39e1" class="ma kb ht lw b fv mf mc l md me">}</span></pre><p id="228d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">解密也是。ChaChaPoly将加密数据(密文)存储在一个“密封盒”容器中。容器包含密文本身和一个随机数。nonce是一个自动随机生成的数字，以避免在双方交换数据的情况下出现重复(它与我们的用例无关)。nonce还使得并行加密和解密数据部分成为可能，这是个好消息，但超出了本文的范围。</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="f43d" class="ma kb ht lw b fv mb mc l md me"><strong class="lw hu">func</strong> decrypt(<strong class="lw hu">_</strong> cipherText: Data, with password: String) <strong class="lw hu">throws</strong> -&gt; String? {</span><span id="f947" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    let</strong> key = SymmetricKey(password: password)</span><span id="a5f4" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    let</strong> sealedBox = <strong class="lw hu">try</strong> ChaChaPoly.SealedBox(combined: cipherText)</span><span id="603f" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    let</strong> decryptedData = <strong class="lw hu">try</strong> ChaChaPoly.open(sealedBox, using: key)</span><span id="91ec" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    return</strong> String(data: decryptedData, encoding: .utf8)</span><span id="1996" class="ma kb ht lw b fv mf mc l md me">}</span></pre><p id="b6a5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">仅此而已。这就是创建密码加密备份所需的全部代码。</p><p id="e9f0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于对称密钥可以在任何地方使用密码创建，并且不存储在安全区域中，因此任何人都可以在任何设备上使用密码对加密数据进行加密。这正是我们需要的备份，但这不是我们想要的钱包文件本身。</p><h1 id="8133" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">苹果的安全框架</h1><p id="1d6f" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">与其他钱包相比，在不同设备之间复制钱包文件是不可行的。加密的钱包文件总是与创建该文件的设备相关联。如果您想要在多个设备上使用同一个钱包，您必须使用iCloud上的恢复短语或备份文件来恢复钱包。这样VivoPay比其他软件钱包更安全。</p><p id="dddb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了实现这一点，钱包文件必须通过在安全区域中创建和存储的对称密钥或者属于在安全区域中创建和存储的私钥的公钥来加密。不幸的是，CryptoKit并没有为此提供API，我们将不得不退回到低级别的安全框架。</p><p id="3e72" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">步骤类似于CryptoKit，但是代码更加精细。你会在<a class="ae jz" href="https://github.com/VivoPay/VivoPayEncryption" rel="noopener ugc nofollow" target="_blank"> VivoPay加密源代码</a>中找到相关代码:相关文件为Shared/Encryption/wallet Encryption . swift。</p><p id="5e1b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您可能会注意到文件中有一个<code class="eh mg mh mi lw b">import CryptoKit </code>语句。这是因为我们使用了CryptoKit中的一个快捷方式:<code class="eh mg mh mi lw b">SecureEnclave.isAvailable</code></p><p id="83ea" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该代码包含一个备用钥匙串，以防设备没有安全区域(如没有T1或T2芯片的iPod Touch或Macs)</p><p id="abec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后，代码设置所有需要的属性(下面的代码中没有显示，但是在<a class="ae jz" href="https://github.com/VivoPay/VivoPayEncryption" rel="noopener ugc nofollow" target="_blank">演示项目</a>中有)来创建一个私钥。</p><p id="57f8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">私钥是用函数<code class="eh mg mh mi lw b">SecKeyCreateRandomKey</code>生成的，公钥是通过调用<code class="eh mg mh mi lw b">SecKeyCopyPublicKey</code>从私钥中导出的。注意，公钥对象包含公钥，但是<code class="eh mg mh mi lw b">SecKeyCreateRandomKey</code>返回的私钥对象不包含私钥。相反，该对象包含对保留在安全区域中的私钥的引用。</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="7071" class="ma kb ht lw b fv mb mc l md me"><strong class="lw hu">fileprivate</strong> <strong class="lw hu">func</strong> createKeys() <strong class="lw hu">throws</strong>  -&gt; (public: SecKey, private: SecKey?) {</span><span id="0d78" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    var</strong> error: Unmanaged&lt;CFError&gt;?</span><span id="ac05" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    let</strong> privateKeyAccessControl: SecAccessControlCreateFlags = SecureEnclave.isAvailable ?  [.userPresence, .privateKeyUsage] : [.userPresence]</span><span id="1b07" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    guard</strong> <strong class="lw hu">let</strong> privateKeyAccess = SecAccessControlCreateWithFlags(kCFAllocatorDefault, kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly, privateKeyAccessControl, &amp;error) <strong class="lw hu">else</strong> {<br/><strong class="lw hu">        throw</strong> error!.takeRetainedValue() <strong class="lw hu">as</strong> Error<br/>    }</span><span id="a23a" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    var</strong> privateKeyAttributes: [String: <strong class="lw hu">Any</strong>] = [<br/>        ...<br/>    ]</span><span id="239f" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    var</strong> commonKeyAttributes: [String: <strong class="lw hu">Any</strong>] = [<br/>        ...<br/>    ]</span><span id="1ef0" class="ma kb ht lw b fv mf mc l md me">    // Create new private key using attributes defined above<strong class="lw hu"><br/>    guard</strong> <strong class="lw hu">let</strong> privateKey = SecKeyCreateRandomKey(commonKeyAttributes <strong class="lw hu">as</strong> CFDictionary, &amp;error) <strong class="lw hu">else</strong> {<br/>        <strong class="lw hu">throw</strong> error!.takeRetainedValue() <strong class="lw hu">as</strong> Error<br/>    }</span><span id="d7b0" class="ma kb ht lw b fv mf mc l md me">    // Derive public key<strong class="lw hu"><br/>    guard</strong> <strong class="lw hu">let</strong> publicKey = SecKeyCopyPublicKey(privateKey) <strong class="lw hu">else</strong> {<br/>        <strong class="lw hu">throw</strong> VivoError.encryption("Error creating public key")<br/>    }</span><span id="97dd" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    return</strong> (public: publicKey, private: privateKey)</span><span id="cf16" class="ma kb ht lw b fv mf mc l md me">}</span></pre><p id="d13e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可以用方法<code class="eh mg mh mi lw b">loadKey</code>检索和恢复对私钥和公钥的引用。LoadKey创建一个查询，并使用函数<code class="eh mg mh mi lw b">SecItemCopyMatching</code>将查询发送到安全区域。</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="93f4" class="ma kb ht lw b fv mb mc l md me"><strong class="lw hu">fileprivate</strong> <strong class="lw hu">func</strong> loadKey() <strong class="lw hu">throws</strong> -&gt; SecKey? {</span><span id="dfeb" class="ma kb ht lw b fv mf mc l md me">    // Create query<br/>    <strong class="lw hu">var</strong> query: [String: <strong class="lw hu">Any</strong>] = [<br/>        kSecClass <strong class="lw hu">as</strong> String: kSecClassKey,<br/>        kSecAttrApplicationTag <strong class="lw hu">as</strong> String: "vivopaydemo",<br/>        kSecAttrKeyType <strong class="lw hu">as</strong> String: kSecAttrKeyTypeECSECPrimeRandom,<br/>        kSecReturnRef <strong class="lw hu">as</strong> String: <strong class="lw hu">true<br/>    ]</strong></span><span id="88a2" class="ma kb ht lw b fv mf mc l md me">    // Use secure enclave if possible<br/>    <strong class="lw hu">if</strong> SecureEnclave.isAvailable {<br/>        query[kSecAttrTokenID <strong class="lw hu">as</strong> String] = kSecAttrTokenIDSecureEnclave<br/>    }</span><span id="f4bc" class="ma kb ht lw b fv mf mc l md me">    // Obtain reference to private key<br/>    <strong class="lw hu">var</strong> key: CFTypeRef?<br/>    <strong class="lw hu">if</strong> SecItemCopyMatching(query <strong class="lw hu">as</strong> CFDictionary, &amp;key) == errSecSuccess {<br/>        <strong class="lw hu">return</strong> (key <strong class="lw hu">as</strong>! SecKey)<br/>    }</span><span id="623b" class="ma kb ht lw b fv mf mc l md me">    // No existing key was found<br/>    <strong class="lw hu">return</strong> <strong class="lw hu">nil</strong></span><span id="ef8a" class="ma kb ht lw b fv mf mc l md me">}</span></pre><p id="c196" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">加密如下:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="b5f6" class="ma kb ht lw b fv mb mc l md me"><strong class="lw hu">func</strong> encrypt(<strong class="lw hu">_</strong> data: Data) <strong class="lw hu">throws</strong> -&gt; Data {</span><span id="b9c7" class="ma kb ht lw b fv mf mc l md me">    // Verify public key can be used to encrypt<br/>    <strong class="lw hu">guard</strong> SecKeyIsAlgorithmSupported(publicKey, .encrypt, WalletEncryption.encryptionAlgorithm) <strong class="lw hu">else</strong> {<br/>        <strong class="lw hu">throw</strong> VivoError.encryption("Error verifying public key")<br/>    }</span><span id="ec04" class="ma kb ht lw b fv mf mc l md me">    // Encrypt<br/>    <strong class="lw hu">var</strong> error: Unmanaged&lt;CFError&gt;?<br/>    <strong class="lw hu">guard</strong> <strong class="lw hu">let</strong> cipherText = SecKeyCreateEncryptedData(publicKey, WalletEncryption.encryptionAlgorithm, data <strong class="lw hu">as</strong> CFData, &amp;error) <strong class="lw hu">as</strong> Data? <strong class="lw hu">else</strong> {<br/>        <strong class="lw hu">throw</strong> error!.takeRetainedValue() <strong class="lw hu">as</strong> Error<br/>    }</span><span id="49b4" class="ma kb ht lw b fv mf mc l md me"><strong class="lw hu">    return</strong> cipherText<br/>}</span></pre><p id="1807" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">解密也非常简单:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="2d31" class="ma kb ht lw b fv mb mc l md me"><strong class="lw hu">func</strong> decrypt(<strong class="lw hu">_</strong> cipherText: Data) <strong class="lw hu">throws</strong> -&gt; Data {</span><span id="0286" class="ma kb ht lw b fv mf mc l md me">    // Verify private key can be used to decrypt<br/>    <strong class="lw hu">guard</strong> <strong class="lw hu">let</strong> privateKey = privateKey, SecKeyIsAlgorithmSupported(privateKey, .decrypt, WalletEncryption.encryptionAlgorithm) <strong class="lw hu">else</strong> {<br/>        <strong class="lw hu">throw</strong> VivoError.encryption("Error fetching private key")<br/>    }</span><span id="a891" class="ma kb ht lw b fv mf mc l md me">    // Decrypt data<br/>    <strong class="lw hu">var</strong> error: Unmanaged&lt;CFError&gt;?<br/>    <strong class="lw hu">guard</strong> <strong class="lw hu">let</strong> clearText = SecKeyCreateDecryptedData(privateKey, WalletEncryption.encryptionAlgorithm, cipherText <strong class="lw hu">as</strong> CFData, &amp;error) <strong class="lw hu">as</strong> Data? <strong class="lw hu">else</strong> {<br/>        <strong class="lw hu">throw</strong> error!.takeRetainedValue() <strong class="lw hu">as</strong> Error<br/>    }</span><span id="b9b1" class="ma kb ht lw b fv mf mc l md me">    // Return clear text<br/>    <strong class="lw hu">return</strong> data<br/>}</span></pre><p id="6a6b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该代码包含一个未使用的<code class="eh mg mh mi lw b">deleteKey</code>方法，该方法对于试验和调试演示代码很有用。</p><h1 id="893c" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">接下来去哪里？</h1><ul class=""><li id="ab49" class="ld le ht jd b je ky ji kz jm mj jq mk ju ml jy li lj lk ll dt translated">阅读<a class="ae jz" href="https://medium.com/p/c5f5faa53b70/edit" rel="noopener">我们如何创建一个超级易用的加密钱包</a></li><li id="4468" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">阅读<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/@ronaldmannak/how-we-created-an-insanely-secure-crypto-wallet-617917063a06">我们如何创造了一个非常安全的加密钱包</a></li><li id="332d" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">阅读<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/@ronaldmannak/vivopay-introduction-to-key-management-80e971459d68"> VivoPay密钥管理简介</a></li><li id="0a15" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">了解VivoPay的<a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/@ronaldmannak/vivo-pay-a-zero-knowledge-payment-system-727997e4d25f">零知识支付系统</a>的未来</li><li id="3b1d" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">下载<a class="ae jz" href="https://github.com/VivoPay/VivoPayEncryption" rel="noopener ugc nofollow" target="_blank"> VivoPayEncryption演示app </a>(需要iOS 14和Xcode 12)。</li><li id="65cf" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">注册<a class="ae jz" href="https://vivopay.me" rel="noopener ugc nofollow" target="_blank"> VivoPay更新</a></li></ul><h2 id="d607" class="ma kb ht bd kc mm mn mo kg mp mq mr kk jm ms mt ko jq mu mv ks ju mw mx kw my dt translated">另外，阅读</h2><ul class=""><li id="02dc" class="ld le ht jd b je ky ji kz jm mj jq mk ju ml jy li lj lk ll dt translated">最好的<a class="ae jz" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="b851" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">密码本交易平台</a></li><li id="ae2d" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">最好的<a class="ae jz" rel="noopener" href="/coinmonks/best-crypto-tax-tool-for-my-money-72d4b430816b">加密税务软件</a></li><li id="92e4" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/the-best-crypto-trading-platforms-in-2020-the-definitive-guide-updated-c72f8b874555">最佳加密交易平台</a></li><li id="d8fc" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">最佳加密贷款平台</li><li id="4f10" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" href="https://bitquery.io/blog/best-blockchain-analysis-tools-and-software" rel="noopener ugc nofollow" target="_blank">最佳区块链分析工具</a></li><li id="d432" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/crypto-arbitrage-guide-how-to-make-money-as-a-beginner-62bfe5c868f6">加密套利</a>指南:新手如何赚钱</li><li id="aa54" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">最佳<a class="ae jz" rel="noopener" href="/coinmonks/what-are-the-best-charting-platforms-for-cryptocurrency-trading-85aade584d80">加密制图工具</a></li><li id="15e1" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/ledger-vs-trezor-best-hardware-wallet-to-secure-cryptocurrency-22c7a3fd391e">莱杰vs特雷佐</a></li><li id="56fd" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">了解比特币最好的<a class="ae jz" rel="noopener" href="/coinmonks/what-are-the-best-books-to-learn-bitcoin-409aeb9aff4b">书籍有哪些？</a></li><li id="170f" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/3commas-review-an-excellent-crypto-trading-bot-2020-1313a58bec92">3商业评论</a></li><li id="d145" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/aax-exchange-review-2021-67c5ea09330c"> AAX交易所评论</a> |推荐代码、交易费用、利弊</li><li id="54f9" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/deribit-review-options-fees-apis-and-testnet-2ca16c4bbdb2"> Deribit审查</a> |选项、费用、API和Testnet</li><li id="e34b" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/ftx-crypto-exchange-review-53664ac1198f"> FTX密码交易所评论</a></li><li id="d0c3" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/ngrave-zero-review-c465cf8307fc">n零审核</a></li><li id="1310" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/bybit-exchange-review-dbd570019b71"> Bybit交换审查</a></li><li id="8b1e" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/cryptohopper-vs-3commas-vs-shrimpy-a2c16095b8fe"> 3Commas vs Cryptohopper </a></li><li id="b18b" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">最好的比特币<a class="ae jz" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069?source=friends_link&amp;sk=324dd9ff8556ab578d71e7ad7658ad7c">硬件钱包</a></li><li id="e7b1" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">最佳<a class="ae jz" href="https://blog.coincodecap.com/best-monero-wallets" rel="noopener ugc nofollow" target="_blank"> monero钱包</a></li><li id="747f" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" href="https://blog.coincodecap.com/ledger-nano-s-vs-x" rel="noopener ugc nofollow" target="_blank">莱杰nano s vs x </a></li><li id="ace6" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" href="https://blog.coincodecap.com/bitsgap-3commas-quadency" rel="noopener ugc nofollow" target="_blank">bits gap vs 3 commas vs quad ency</a></li><li id="a274" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" href="https://blog.coincodecap.com/ledger-nano-s-vs-trezor-one-ledger-nano-x-trezor-t" rel="noopener ugc nofollow" target="_blank">莱杰纳米S vs特雷佐one vs特雷佐T vs莱杰纳米X </a></li><li id="44f0" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/blockfi-vs-celsius-vs-hodlnaut-8a1cc8c26630">block fi vs Celsius</a>vs Hodlnaut</li><li id="52d0" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">Bitsgap评论——一个轻松赚钱的加密交易机器人</li><li id="92c0" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">为专业人士设计的加密交易机器人</li><li id="22eb" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/primexbt-review-88e0815be858"> PrimeXBT审查</a> |杠杆交易、费用和交易</li><li id="62d2" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/ellipal-titan-review-85e9071dd029">埃利帕尔泰坦评论</a></li><li id="1a26" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" href="https://blog.coincodecap.com/secux-stone-hardware-wallet-review" rel="noopener ugc nofollow" target="_blank"> SecuX Stone评论</a></li><li id="31ff" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/blockfi-review-53096053c097"> BlockFi评论</a> |赚取高达8.6%的加密利息</li></ul></div></div>    
</body>
</html>