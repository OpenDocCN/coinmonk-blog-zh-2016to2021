<html>
<head>
<title>Testing time-dependent logic in Ethereum Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试以太坊智能合约中的时间相关逻辑</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/testing-time-dependent-logic-in-ethereum-smart-contracts-1b24845c7f72?source=collection_archive---------1-----------------------#2018-02-26">https://medium.com/coinmonks/testing-time-dependent-logic-in-ethereum-smart-contracts-1b24845c7f72?source=collection_archive---------1-----------------------#2018-02-26</a></blockquote><div><div class="eg hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fn fp hv hw ff fg paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="ff fg hs"><img src="../Images/b823d64f9618320eb42edb986d8d24fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tdWEXS_UcFVpUZ-lgiCv7A.jpeg"/></div></div><figcaption class="id ie fh ff fg if ig bd b be z el">A mechanical watch is a more dependable measure of time than a blockchain timestamp, so long as I keep wearing it.</figcaption></figure><div class=""/><p id="f172" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">写一个可靠的合同，只允许在特定的时间限制内执行特定的动作，这种情况并不少见。这方面的流行例子包括<a class="ae ke" href="https://github.com/OpenZeppelin/zeppelin-solidity" rel="noopener ugc nofollow" target="_blank">open zeppelin</a>T0】合同。</p><p id="ac19" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当测试建立在<code class="ei kf kg kh ki b">TimedCrowdsale</code>之上的合同时，你可能会遇到这样的情况，你测试的行为(比如，退款的分配)只有在众筹有<code class="ei kf kg kh ki b">closed</code>时才能被测试。</p><p id="ead4" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">该合同具有以下功能:</p><pre class="kj kk kl km fr kn ki ko kp aw kq dt"><span id="27a6" class="kr ks ij ki b fw kt ku l kv kw">function hasClosed() public view returns (bool) {<br/>    return now &gt; closingTime;<br/>}</span></pre><p id="79bb" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这将检查<code class="ei kf kg kh ki b">now</code>的值，并将其与合同的<code class="ei kf kg kh ki b">closingTime</code>时间戳进行比较。</p><p id="2c1c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">OpenZeppelin还提供了一个非常常用的<code class="ei kf kg kh ki b">FinalizableCrowdsale</code>契约，它扩展了<code class="ei kf kg kh ki b">TimedCrowdsale</code>。通常，要实现这一点，您需要覆盖从<code class="ei kf kg kh ki b">finalize</code>函数调用的<code class="ei kf kg kh ki b">finalization</code>函数，如下所示:</p><pre class="kj kk kl km fr kn ki ko kp aw kq dt"><span id="9e34" class="kr ks ij ki b fw kt ku l kv kw">function finalize() onlyOwner public {<br/>    require(!isFinalized);<br/>    require(hasClosed());<br/>    finalization();<br/>    Finalized();<br/>    isFinalized = true;<br/>}</span></pre><p id="dbab" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了对您自己的<code class="ei kf kg kh ki b">finalization</code>函数进行单元测试，您需要确保<code class="ei kf kg kh ki b">hasClosed()</code>返回true。这意味着你需要弯曲时间。</p><blockquote class="kx"><p id="75f3" class="ky kz ij bd la lb lc ld le lf lg kd el translated">还念:最好的<a class="ae ke" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069?source=friends_link&amp;sk=324dd9ff8556ab578d71e7ad7658ad7c">硬件钱包</a></p></blockquote><h1 id="4400" class="lh ks ij bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md dt translated">时间是什么？</h1><p id="b69d" class="pw-post-body-paragraph jg jh ij ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">大多数编程环境都有时间的概念。例如，在Javascript中，您总是可以通过<code class="ei kf kg kh ki b">const now = Date.now()</code>获得当前时间。这会根据执行脚本的计算机中的时钟，将当前的<em class="mj"> Unix纪元</em>时间(<a class="ae ke" href="https://www.epochconverter.com" rel="noopener ugc nofollow" target="_blank">自1970年1月1日</a>以来的毫秒数)分配给变量<code class="ei kf kg kh ki b">now</code>。</p><p id="076d" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然而，在以太坊智能合约中，时间的处理方式略有不同。在Solidity语言中，<code class="ei kf kg kh ki b">now</code>实际上是对当前块的<code class="ei kf kg kh ki b">timestamp</code>的简写引用，这是从<em class="mj"> Unix纪元</em>以来的秒数，该函数的事务被记录到区块链。因此，该时间完全取决于挖掘该特定块的机器中的时钟。</p><p id="474c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一般来说，矿工需要一个精确的时钟。如果你的时钟与其他矿工的时钟不同步超过12秒，那么<a class="ae ke" href="http://www.ethdocs.org/en/latest/network/connecting-to-the-network.html#common-problems-with-connectivity" rel="noopener ugc nofollow" target="_blank">你将很难连接到同伴</a>。矿工操纵时间是值得警惕的事情。通常不鼓励依赖高度精确的时间戳的逻辑。</p><p id="7918" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以太坊虚拟机只要求一个块的时间戳大于引用的前一个块的时间戳。在最初的以太坊白皮书中提到将时间戳限制为15分钟，但是这个信息已经过时了。最新的文件《以太坊黄皮书》取消了15分钟的限制。</p><blockquote class="kx"><p id="5556" class="ky kz ij bd la lb lc ld le lf lg kd el translated">参见<a class="ae ke" href="https://github.com/ethereum/yellowpaper" rel="noopener ugc nofollow" target="_blank">https://github.com/ethereum/yellowpaper</a>中的块标题有效性(第4.4.4节，等式48)</p></blockquote><p id="5e59" class="pw-post-body-paragraph jg jh ij ji b jj mk jl jm jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd hn dt translated">然而，在大多数情况下，如果时间戳相差几分钟，这并不是一个大问题。</p><h1 id="8b3e" class="lh ks ij bd li lj lk ll lm ln lo lp lq lr mp lt lu lv mq lx ly lz mr mb mc md dt translated">测试时间。</h1><p id="318e" class="pw-post-body-paragraph jg jh ij ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated"><a class="ae ke" href="http://truffleframework.com" rel="noopener ugc nofollow" target="_blank"> Truffle </a>允许你使用标准<code class="ei kf kg kh ki b"><a class="ae ke" href="https://mochajs.org" rel="noopener ugc nofollow" target="_blank">mochajs</a></code>单元测试框架的改编版本来编写智能合约的测试。您<a class="ae ke" rel="noopener" href="/level-k/testing-smart-contracts-with-truffle-7849b3d9961">可以用Javascript </a>编写这些测试，并利用<em class="mj"> Mocha </em>提供的所有模式，例如<code class="ei kf kg kh ki b">before</code>块，并将测试分解成<code class="ei kf kg kh ki b">contexts</code>。</p><p id="6b7a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">比方说，我在一个合同中实现了自己的<code class="ei kf kg kh ki b">finalization</code>功能，通过添加一个<code class="ei kf kg kh ki b">overpaymentVault</code>来扩展<code class="ei kf kg kh ki b">FinalizableCrowdsale</code>，这是一个特殊的钱包，可以存放人们发送的超出indivudual限额的邮件。一旦众筹上线，我们希望允许人们提取他们多付的钱，所以我们如下增强了<code class="ei kf kg kh ki b">finalization</code>功能:</p><pre class="kj kk kl km fr kn ki ko kp aw kq dt"><span id="f63d" class="kr ks ij ki b fw kt ku l kv kw">function finalization() internal {<br/>    overpaymentVault.enableRefunds();<br/>    super.finalization();<br/>}</span></pre><p id="8752" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">并覆盖标准的<code class="ei kf kg kh ki b">claimRefund</code>功能:</p><pre class="kj kk kl km fr kn ki ko kp aw kq dt"><span id="263d" class="kr ks ij ki b fw kt ku l kv kw">function claimRefund() public {<br/>    require(isFinalized);<br/>    if (!goalReached() &amp;&amp; vault.deposited(msg.sender) != 0) {<br/>        vault.refund(msg.sender);<br/>    }<br/>    if (overpaymentVault.deposited(msg.sender) != 0) {<br/>        overpaymentVault.refund(msg.sender);<br/>    }<br/>}</span></pre><p id="cf24" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了测试，我们需要能够完成合同。因为<code class="ei kf kg kh ki b">finalization</code>是内部函数；我们不能直接从单元测试中测试它。因此，为了测试<code class="ei kf kg kh ki b">claimRefund</code>，我们需要首先调用<code class="ei kf kg kh ki b">finalize</code>，这意味着众筹需要<code class="ei kf kg kh ki b">hasClosed()</code>返回<code class="ei kf kg kh ki b">true</code>。</p><h1 id="93bd" class="lh ks ij bd li lj lk ll lm ln lo lp lq lr mp lt lu lv mq lx ly lz mr mb mc md dt translated">把时钟往前拨。</h1><p id="13a4" class="pw-post-body-paragraph jg jh ij ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">为了在测试中向前调时钟，我编写了一个名为<code class="ei kf kg kh ki b">timeTravel</code>的小助手工具，它通过向区块链发送<code class="ei kf kg kh ki b">evm_increaseTime</code>指令来指示矿工向前调时钟。这<em class="mj">不是</em>标准的EVM指令，而是添加到<a class="ae ke" href="https://github.com/trufflesuite/ganache-cli" rel="noopener ugc nofollow" target="_blank"> Ganache </a>中的东西，Ganache 被<em class="mj"> Truffle </em>内部用作测试区块链。</p><blockquote class="ms mt mu"><p id="a8bb" class="jg jh mj ji b jj jk jl jm jn jo jp jq mv js jt ju mw jw jx jy mx ka kb kc kd hn dt translated"><code class="ei kf kg kh ki b">evm_increaseTime</code>:时间向前跳跃。接受一个参数，即以秒为单位增加的时间量。返回总时间调整，以秒为单位。</p></blockquote><p id="52c0" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="mj"> Ganache </em>还提供了另一个非标准指令<code class="ei kf kg kh ki b">evm_mine</code>，简单的强制开采一个区块。</p><p id="ba2b" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">结合起来，这些指令可以使用<code class="ei kf kg kh ki b">web3</code>发送，以迫使区块链在时间上向前行进。</p><pre class="kj kk kl km fr kn ki ko kp aw kq dt"><span id="39df" class="kr ks ij ki b fw kt ku l kv kw">const jsonrpc = '2.0'</span><span id="e84e" class="kr ks ij ki b fw my ku l kv kw">const id = 0</span><span id="9a12" class="kr ks ij ki b fw my ku l kv kw">const send = (method, params = []) =&gt;<br/>  web3.currentProvider.send({ id, jsonrpc, method, params })</span><span id="fbd1" class="kr ks ij ki b fw my ku l kv kw">const timeTravel = async seconds =&gt; {<br/>  await send('evm_increaseTime', [seconds])<br/>  await send('evm_mine')<br/>}</span><span id="d1c6" class="kr ks ij ki b fw my ku l kv kw">module.exports = timeTravel</span></pre><p id="11a0" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我可以这样使用它:</p><pre class="kj kk kl km fr kn ki ko kp aw kq dt"><span id="3273" class="kr ks ij ki b fw kt ku l kv kw">contract('MyCrowdsale', accounts =&gt; {<br/>  const [<br/>    wallet,<br/>    overpaymentWallet,<br/>    punter<br/>  ] = accounts.slice(1)</span><span id="4d6f" class="kr ks ij ki b fw my ku l kv kw">  let crowdsale<br/>  let token<br/>  let refunded</span><span id="404f" class="kr ks ij ki b fw my ku l kv kw">  openingTime = Math.floor(new Date().getTime() / 1000)<br/>  closingTime = openingTime + SECONDS_IN_A_DAY</span><span id="6c00" class="kr ks ij ki b fw my ku l kv kw">  const rate = toWei(0.5)<br/>  const amount = toWei(1.2)<br/>  const expectedMax = amount.minus(rate.times(2))<br/>  const goal = toWei(1)</span><span id="dcc1" class="kr ks ij ki b fw my ku l kv kw">  before(async () =&gt; {<br/>    token = await MintableToken.new()<br/>    crowdsale = await MyCrowdsale.new(<br/>      openingTime,<br/>      closingTime,<br/>      wallet,<br/>      overpaymentWallet,<br/>      token.address,<br/>      rate,<br/>      goal<br/>    )</span><span id="4a22" class="kr ks ij ki b fw my ku l kv kw">    await crowdsale.buyTokens(<br/>      punter, { value: amount, from: punter })<br/><strong class="ki ik">    await timeTravel(SECONDS_IN_A_DAY * 2)<br/></strong>    await crowdsale.finalize()<br/>    const balance = web3.eth.getBalance(punter)<br/>    await crowdsale.claimRefund({ from: punter })<br/>    const newBalance = web3.eth.getBalance(punter)<br/>    refunded = newBalance.minus(balance)<br/>  })</span><span id="e532" class="kr ks ij ki b fw my ku l kv kw">  it('claimRefund refunds the overpayment', () =&gt; {<br/>    // not exact as gas costs can vary slightly<br/>    assert.isTrue(refunded.gt(0) &amp;&amp; refunded.lt(expectedMax))<br/>  })<br/>})</span></pre><h1 id="b45e" class="lh ks ij bd li lj lk ll lm ln lo lp lq lr mp lt lu lv mq lx ly lz mr mb mc md dt translated">但是你回不去了！</h1><p id="b934" class="pw-post-body-paragraph jg jh ij ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated"><em class="mj">时间行程</em>测试<strong class="ji ik">必须最后运行</strong> <strong class="ji ik">。一旦你把钟往前拨，你就不能再往回拨了。这是有问题的，因为您无法预测测试运行的顺序。测试确实在单个<code class="ei kf kg kh ki b">contract</code>块中以可预测的顺序运行，但是一旦你开始将你的测试分成多个文件，使用它们自己的<code class="ei kf kg kh ki b">contract</code>块，你就失去了预测顺序的能力。这意味着您的测试可能会以不可预知的方式中断。</strong></p><h1 id="ec6e" class="lh ks ij bd li lj lk ll lm ln lo lp lq lr mp lt lu lv mq lx ly lz mr mb mc md dt translated">测试时间，第二次。</h1><p id="63fb" class="pw-post-body-paragraph jg jh ij ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">事实证明，对大多数合同来说，调整区块链的时钟是多余的。一种更简单的方法是用包含如下函数的高阶模拟契约来扩展您的智能契约:</p><pre class="kj kk kl km fr kn ki ko kp aw kq dt"><span id="3833" class="kr ks ij ki b fw kt ku l kv kw">contract MockMyCrowdsale is MyCrowdsale {<br/>    function turnBackTime(uint256 secs) external {<br/>        openingTime -= secs;<br/>        closingTime -= secs;<br/>    }<br/>}</span></pre><p id="92ed" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然后在上面的测试中，调用<code class="ei kf kg kh ki b">MockMyCrowdsale.new(...)</code>而不是调用:</p><pre class="kj kk kl km fr kn ki ko kp aw kq dt"><span id="0b8c" class="kr ks ij ki b fw kt ku l kv kw"><strong class="ki ik">await timeTravel(SECONDS_IN_A_DAY * 2)</strong></span></pre><p id="9987" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您可以调用:</p><pre class="kj kk kl km fr kn ki ko kp aw kq dt"><span id="342d" class="kr ks ij ki b fw kt ku l kv kw"><strong class="ki ik">await crowdsale.turnBackTime(SECONDS_IN_A_DAY * 2)</strong></span></pre><p id="5706" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，该测试不会破坏您的其他测试的区块链。</p><p id="9f46" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">经过多次试验，我还没有找到一个例子，你实际上需要操纵区块链自己的时间，而不是仅仅覆盖契约自己的特定时间值。</p><h1 id="5908" class="lh ks ij bd li lj lk ll lm ln lo lp lq lr mp lt lu lv mq lx ly lz mr mb mc md dt translated">结论</h1><p id="1bca" class="pw-post-body-paragraph jg jh ij ji b jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd hn dt translated">通过利用<em class="mj"> Ganache </em>以太坊测试网在<em class="mj"> Truffle </em>框架内提供的几个非标准EVM指令，有可能将时间向前滚动，以便测试依赖于时间的逻辑，但这使您的测试非常脆弱。相反，最好使用模拟契约来扩展您正在测试的契约，模拟契约提供了一些函数，您可以使用这些函数来强制内部时间变量保存您需要的任何值。</p><h2 id="7ea9" class="kr ks ij bd li mz na nb lm nc nd ne lq jr nf ng lu jv nh ni ly jz nj nk mc nl dt translated">链接</h2><ul class=""><li id="b6d2" class="nm nn ij ji b jj me jn mf jr no jv np jz nq kd nr ns nt nu dt translated"><a class="ae ke" href="http://truffleframework.com" rel="noopener ugc nofollow" target="_blank">松露框架<br/> </a> <a class="ae ke" href="https://github.com/trufflesuite/ganache-cli" rel="noopener ugc nofollow" target="_blank"> Ganache </a> <br/> <a class="ae ke" rel="noopener" href="/level-k/testing-smart-contracts-with-truffle-7849b3d9961">用松露测试智能合约</a></li><li id="17f7" class="nm nn ij ji b jj nv jn nw jr nx jv ny jz nz kd nr ns nt nu dt translated"><a class="ae ke" href="https://github.com/ethereum/yellowpaper" rel="noopener ugc nofollow" target="_blank">以太坊黄皮书</a></li><li id="889a" class="nm nn ij ji b jj nv jn nw jr nx jv ny jz nz kd nr ns nt nu dt translated">OpenZeppelin的<a class="ae ke" href="https://github.com/OpenZeppelin/zeppelin-solidity" rel="noopener ugc nofollow" target="_blank"> Zeppelin-Solidity </a>合同。</li></ul><p id="f5f2" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">像这样但不是订户？你可以通过<a class="ae ke" href="https://davesag.medium.com/membership" rel="noopener">davesag.medium.com</a>加入来支持作者。</p><blockquote class="kx"><p id="0071" class="ky kz ij bd la lb lc ld le lf lg kd el translated">加入Coinmonks <a class="ae ke" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ke" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae ke" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="kr ks ij bd li mz oa nb lm nc ob ne lq jr oc ng lu jv od ni ly jz oe nk mc nl dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="nm nn ij ji b jj me jn mf jr no jv np jz nq kd nr ns nt nu dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="nm nn ij ji b jj nv jn nw jr nx jv ny jz nz kd nr ns nt nu dt translated"><a class="ae ke" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae ke" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="nm nn ij ji b jj nv jn nw jr nx jv ny jz nz kd nr ns nt nu dt translated"><a class="ae ke" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="450c" class="nm nn ij ji b jj nv jn nw jr nx jv ny jz nz kd nr ns nt nu dt translated"><a class="ae ke" href="https://coincodecap.com/pionex-dual-investment" rel="noopener ugc nofollow" target="_blank"> Pionex双重投资</a> | <a class="ae ke" href="https://coincodecap.com/advcash-review" rel="noopener ugc nofollow" target="_blank"> AdvCash审查</a> | <a class="ae ke" href="https://coincodecap.com/uphold-review" rel="noopener ugc nofollow" target="_blank">支持审查</a></li><li id="4c48" class="nm nn ij ji b jj nv jn nw jr nx jv ny jz nz kd nr ns nt nu dt translated"><a class="ae ke" href="https://coincodecap.com/best-cryptocurrency-apis" rel="noopener ugc nofollow" target="_blank">面向开发者的8个最佳加密货币APIs】</a></li><li id="db49" class="nm nn ij ji b jj nv jn nw jr nx jv ny jz nz kd nr ns nt nu dt translated"><a class="ae ke" href="https://coincodecap.com/uphold-card-review" rel="noopener ugc nofollow" target="_blank">拥护卡审核</a> | <a class="ae ke" href="https://coincodecap.com/trust-wallet-vs-metamask" rel="noopener ugc nofollow" target="_blank">信任钱包vs MetaMask </a></li><li id="0843" class="nm nn ij ji b jj nv jn nw jr nx jv ny jz nz kd nr ns nt nu dt translated"><a class="ae ke" href="https://coincodecap.com/earn-sign-up-bonus" rel="noopener ugc nofollow" target="_blank">赢取注册奖金——10大最佳加密平台</a></li><li id="f33b" class="nm nn ij ji b jj nv jn nw jr nx jv ny jz nz kd nr ns nt nu dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae ke" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="nm nn ij ji b jj nv jn nw jr nx jv ny jz nz kd nr ns nt nu dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">面向开发人员的最佳加密API</a></li><li id="b359" class="nm nn ij ji b jj nv jn nw jr nx jv ny jz nz kd nr ns nt nu dt translated">最佳<a class="ae ke" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="nm nn ij ji b jj nv jn nw jr nx jv ny jz nz kd nr ns nt nu dt translated">杠杆代币的终极指南</li></ul></div></div>    
</body>
</html>