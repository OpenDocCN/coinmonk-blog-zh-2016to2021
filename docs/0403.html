<html>
<head>
<title>ERC865: A case for more user-friendly tokens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ERC865:更加用户友好的令牌</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/erc865-a-case-for-more-user-friendly-tokens-eb68e62a986?source=collection_archive---------3-----------------------#2018-04-30">https://medium.com/coinmonks/erc865-a-case-for-more-user-friendly-tokens-eb68e62a986?source=collection_archive---------3-----------------------#2018-04-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="c479" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jo">该标准提出了一种提取gas的系统，并为令牌持有者提供了在单次交易中以令牌而非gas支付*令牌转移*交易费用的能力。</em></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/4390d78ad117f52cea0d2c1f8bb4683d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ahaoeV7UqOLk2IWnHK3qA.jpeg"/></div></div></figure><h2 id="568a" class="kb kc ht bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv dt translated">以太坊费用:</h2><p id="edf3" class="pw-post-body-paragraph iq ir ht is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hm dt translated">要在区块链以太坊进行任何交易，你必须付费。这笔费用是支付给矿工的采矿交易，把他们分成区块，并确保区块链。<br/>该费用以气(气限*气价)计算，以乙醚支付。</p><p id="2b6c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jo">这就给新用户造成了一些摩擦:<br/> </em> <strong class="is hu"> 1。新用户必须了解以太坊是如何工作的，以便了解燃气价格和燃气成本<br/> 2。他们必须获得必要的乙醚来支付汽油费用</strong></p><p id="5b8c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这两个问题为采用内置令牌的DAPPS设置了不必要的障碍。为了简单起见，这个过程应该被抽象出来，这样用户就可以使用DAPP，而不用担心底层以太网</p><p id="fc47" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ERC865是朝着这个方向迈出的新一步，旨在解决这些问题，并为ERC20令牌传输提供更好的UX。w</p><blockquote class="lb lc ld"><p id="c119" class="iq ir jo is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hm dt translated"><strong class="is hu"> ERC865: <br/>该标准提出了一种提取gas的系统，并为令牌持有者提供了在单次交易中以令牌而非gas支付*令牌转移*交易费用的能力。</strong></p></blockquote><p id="2b36" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">引入一个中间第三方，该第三方愿意接受代币形式的转账费用，并以以太形式将带有必要费用的转账交易转发给区块链。这个过程使用加密签名来保护。</p><p id="8ea4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">规格:</p><ul class=""><li id="136b" class="lh li ht is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp dt translated">答:付款的发送方</li><li id="3486" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp dt translated">b:收款人</li><li id="7333" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp dt translated">d:委托，为A做交易，付油钱</li><li id="15c9" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp dt translated">x:从A发送到B的令牌T的数量</li><li id="e9d5" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp dt translated">y:用令牌T支付的费用，从A到D进行交易</li><li id="1e40" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp dt translated">要发送的令牌</li><li id="5fbd" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp dt translated">现在</li><li id="8b59" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp dt translated">来自发送方的签名消息，包含交易的所有细节</li></ul><p id="b9c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">流程:</strong></p><ol class=""><li id="e664" class="lh li ht is b it iu ix iy jb lj jf lk jj ll jn lv ln lo lp dt translated">用户A选择来自代表D的报价，该报价是1次交易的费用Y的值(取决于气价ETH中的令牌值)。</li><li id="9077" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lv ln lo lp dt translated">使用他们的私钥，用户通过获取有效负载<code class="eh lw lx ly lz b">P{T, B,X, Y, N}</code>的sha3并使用私钥对其签名来生成S。</li><li id="5ebd" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lv ln lo lp dt translated">用户向委托人发送P(未哈希、未签名)和S</li><li id="7adb" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lv ln lo lp dt translated">委托验证Y和D未被更改</li><li id="db75" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lv ln lo lp dt translated">委托人继续从他的账户D<br/>T1】提交交易</li><li id="75d1" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lv ln lo lp dt translated">delegatedTransfer方法重建有效负载P的sha3 H</li><li id="0979" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lv ln lo lp dt translated">然后，我们可以调用ecrecover(S ),确保结果与A匹配，如果是这样，就安全地将X标记从A移动到B，将Y标记从A移动到d。</li></ol><p id="f97c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">技术人员:<br/> <code class="eh lw lx ly lz b">function delegatedTransfer(<br/> bytes _signature,<br/> address _to,<br/> uint256 _value,<br/> uint256 _fee,<br/> uint256 _nonce<br/>) public returns (bool)</code> <br/>由代理调用，执行转接。</p><p id="8c68" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">delegatedTransfer的参考实现:<br/> <code class="eh lw lx ly lz b">function delegatedTransfer(<br/> bytes _signature,<br/> address _to,<br/> uint256 _value,<br/> uint256 _fee,<br/> uint256 _nonce<br/> ) public returns (bool) {<br/> require(_to != address(0));<br/> require(signatures[_signature] == false);<br/> bytes32 hashedTx = transferPreSignedHashing(address(this), _to, _value, _fee, _nonce);<br/> address from = ecrecover(hashedTx, _signature);<br/> require(from != address(0));<br/> balances[from] = balances[from].sub(_value).sub(_fee);<br/> balances[_to] = balances[_to].add(_value);<br/> balances[msg.sender] = balances[msg.sender].add(_fee);<br/> signatures[_signature] = true;<br/> Transfer(from, _to, _value);<br/> Transfer(from, msg.sender, _fee);<br/> TransferPreSigned(from, _to, msg.sender, _value, _fee);<br/> return true;<br/>}</code></p><p id="3101" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh lw lx ly lz b">function transferPreSignedHashing(<br/> address _token,<br/> address _to,<br/> uint256 _value,<br/> uint256 _fee,<br/> uint256 _nonce<br/> ) public pure returns (bytes32)<br/> {<br/> /* “48664c16”: transferPreSignedHashing(address,address,address,uint256,uint256,uint256) */<br/> return keccak256(bytes4(0x48664c16), _token, _to, _value, _fee, _nonce);<br/> }</code></p><p id="58dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">建议:<br/> 1。应该有一种使交易无效的机制。<br/> 2。在交易中应该有一个时间限制的可选条件，以便在指定的时间点之后交易变得无效。这使得在超时之后撤销事务是自动的，并且提供了一种取消机制，而无需发送显式的无效事务</p><p id="2328" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该标准是一个持续的WIP，可在此处找到:<br/> 1。<a class="ae ma" href="https://github.com/ethereum/EIPs/issues/865" rel="noopener ugc nofollow" target="_blank">https://github.com/ethereum/EIPs/issues/865</a>T11】2。<a class="ae ma" href="https://github.com/PROPSProject/props-token-distribution/blob/master/contracts/token/ERC865Token.solhttps://github.com/PROPSProject/props-token-distribution/blob/master/contracts/token/ERC865Token.sol" rel="noopener ugc nofollow" target="_blank">参考实现</a></p></div></div>    
</body>
</html>