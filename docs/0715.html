<html>
<head>
<title>Solidity Bits— storage vs. memory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可靠性位—存储与内存</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-bits-storage-vs-memory-a54a650ea4ff?source=collection_archive---------6-----------------------#2018-06-07">https://medium.com/coinmonks/solidity-bits-storage-vs-memory-a54a650ea4ff?source=collection_archive---------6-----------------------#2018-06-07</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/06492bcdb2610c252cbcdb9a970faa11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bo7gdFz9UhBSkR_KCqYEHA.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek"><a class="ae jf" href="https://4storage.wordpress.com/memory-vs-storage/" rel="noopener ugc nofollow" target="_blank">Photo Credit</a></figcaption></figure><p id="2cc6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在Solidity中编码并不总是直观的，但是很有趣。我不得不思考的一个小挑战是存储和内存的区别。</p><p id="6737" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">想象一个简单的例子，如下所示</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="ab07" class="kn ko ht kj b fv kp kq l kr ks">pragma solidity ^0.4.22;</span><span id="314c" class="kn ko ht kj b fv kt kq l kr ks">contract Fruits {<br/>    string[] public items;</span><span id="2d8e" class="kn ko ht kj b fv kt kq l kr ks">    constructor () public {<br/>        items.push('apple');<br/>        items.push('orange');<br/>    }<br/>}</span></pre><p id="4edb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我要部署此合同，索引为0和1的项目将分别为“apple”和“orange”。很简单。</p><p id="f0fc" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我试图在我的构造函数中创建一个指向<code class="eh ku kv kw kj b">items</code>变量数组的新数组会怎样？似乎很容易。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="c266" class="kn ko ht kj b fv kp kq l kr ks">constructor () public {<br/>  ...<br/>  string[] newItems = items;<br/>}</span></pre><p id="17c1" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">但是等等！我们得到如下警告！</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff kx"><img src="../Images/56d94f04fe7ce2c7efaedd504c47c7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAUJ7F7RslXycOngsmnxHg.png"/></div></div></figure><p id="b7a0" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">明白警告了吗？我也没有。</p><p id="b64b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了充分理解正在发生的事情，让我们讨论一下坚固性是如何解释内存和存储的。</p><h1 id="3693" class="ky ko ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">存储与内存</h1><p id="ec14" class="pw-post-body-paragraph jg jh ht ji b jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">Solidity以两种不同的方式看待存储与内存的关系。</p><ol class=""><li id="f501" class="ma mb ht ji b jj jk jn jo jr mc jv md jz me kd mf mg mh mi dt translated"><strong class="ji hu">合同状态数据</strong></li></ol><ul class=""><li id="1709" class="ma mb ht ji b jj jk jn jo jr mc jv md jz me kd mj mg mh mi dt translated"><strong class="ji hu">存储</strong>:定义在契约内部顶层的变量。(例:<code class="eh ku kv kw kj b">items</code>)</li><li id="1c64" class="ma mb ht ji b jj mk jn ml jr mm jv mn jz mo kd mj mg mh mi dt translated"><strong class="ji hu">内存:</strong>结构(如果你不知道什么是结构，请参考<a class="ae jf" href="http://solidity.readthedocs.io/en/v0.4.21/types.html" rel="noopener ugc nofollow" target="_blank">http://solidity.readthedocs.io/en/v0.4.21/types.html</a></li></ul><p id="2db6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">2.<strong class="ji hu">变量值声明</strong></p><ul class=""><li id="02d0" class="ma mb ht ji b jj jk jn jo jr mc jv md jz me kd mj mg mh mi dt translated">在这种情况下，变量值声明可以定义为存储或内存，这取决于您希望如何保存该变量(下面将进一步解释)</li></ul><p id="03f5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在我们的示例中，<code class="eh ku kv kw kj b">items </code>是水果契约中的一个存储州。有了新的变量<code class="eh ku kv kw kj b">newItems</code>，我们有两个选择，将变量保存在<strong class="ji hu">内存</strong>或<strong class="ji hu">存储中。我将在下面讨论这两个选项。</strong></p><h1 id="035d" class="ky ko ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">作为存储的新项目</h1><p id="acdf" class="pw-post-body-paragraph jg jh ht ji b jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">如果<strong class="ji hu"> newItems </strong>被保存为存储，您必须在<strong class="ji hu"> newItems之前包含关键字<strong class="ji hu"> storage </strong>。</strong>例子如下所示。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="302e" class="kn ko ht kj b fv kp kq l kr ks">string[] storage newItems = items;</span></pre><p id="8d59" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通过增加存储值，警告应该会消失。但是这到底是在做什么呢？通过添加<code class="eh ku kv kw kj b">storage</code>，现在<code class="eh ku kv kw kj b">newItems</code>将<strong class="ji hu">指向</strong>到<code class="eh ku kv kw kj b">items</code>数组。换句话说，你对<code class="eh ku kv kw kj b">newItems</code>所做的任何改变，都会直接影响到<code class="eh ku kv kw kj b">items</code>数组。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="0de3" class="kn ko ht kj b fv kp kq l kr ks">pragma solidity ^0.4.17;</span><span id="4423" class="kn ko ht kj b fv kt kq l kr ks">contract Fruits {<br/>    string[] public items;</span><span id="00d8" class="kn ko ht kj b fv kt kq l kr ks">    constructor () public {<br/>        items.push('apple');<br/>        items.push('orange');<br/>        string[] storage newItems = items;<br/>        newItems[1] = 'lemon';<br/>    }<br/>}</span><span id="a1a1" class="kn ko ht kj b fv kt kq l kr ks">// items[1] will now be lemon<br/>// items[0] will remain the same as 'apple'</span></pre><p id="82e1" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">总之，存储键强制新创建的变量指向状态变量(items)而不是副本。对新变量的任何改变将直接改变合同状态变量的结构。</p><h1 id="b711" class="ky ko ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">作为记忆的新项目</h1><p id="f239" class="pw-post-body-paragraph jg jh ht ji b jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">有一种替代持久性的方法。有一个<code class="eh ku kv kw kj b">memory</code>选项代替了<code class="eh ku kv kw kj b">storage</code>。与指针相反，<code class="eh ku kv kw kj b">memory</code>选项起到了<strong class="ji hu">副本</strong>的作用。因此，使用<code class="eh ku kv kw kj b">memory</code>键并对新创建的变量进行突变不会影响初始状态变量。下面的例子。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="f37e" class="kn ko ht kj b fv kp kq l kr ks">pragma solidity ^0.4.17;</span><span id="9673" class="kn ko ht kj b fv kt kq l kr ks">contract Fruits {<br/>    string[] public items;</span><span id="a304" class="kn ko ht kj b fv kt kq l kr ks">constructor () public {<br/>        items.push('apple');<br/>        items.push('orange');<br/>        string[] memory newItems = items;<br/>        newItems[1] = 'lemon'<br/>    }<br/>}</span><span id="3e9f" class="kn ko ht kj b fv kt kq l kr ks">// items[1] will remain the same as 'orange'<br/>// items[0] will remain the same as 'apple'</span></pre><h1 id="b600" class="ky ko ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">结论</h1><p id="087c" class="pw-post-body-paragraph jg jh ht ji b jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">我希望这能解决关于内存与存储的警告的任何问题。我将存储(状态)视为硬盘，将内存(局部变量，临时)视为RAM。如果您期望创建可以改变状态的函数，那么存储可能是最好的选择。如果您需要数据的副本，但不一定想要操作契约状态，请使用内存。</p><h1 id="09ef" class="ky ko ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">边注</h1><p id="6d41" class="pw-post-body-paragraph jg jh ht ji b jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">传递给契约函数的任何值都将通过内存发送(默认)。接受该参数的函数不会操纵协定状态。下面的例子。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="cc20" class="kn ko ht kj b fv kp kq l kr ks">pragma solidity ^0.4.17;</span><span id="3793" class="kn ko ht kj b fv kt kq l kr ks">contract Fruits {<br/>    string[] public items;</span><span id="1dff" class="kn ko ht kj b fv kt kq l kr ks">    constructor () public {<br/>        items.push('apple');<br/>        items.push('orange');<br/>        <br/>        changeFirstElement(items);<br/>    }<br/>    <br/>    function changeFirstElement(string[] newItems) pure private {<br/>        newItems[0] = 'lemon';<br/>    }<br/>}</span><span id="ddc2" class="kn ko ht kj b fv kt kq l kr ks">// items[1] will remain the same as 'orange'<br/>// items[0] will remain the same as 'apple'</span></pre><p id="eeec" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果需要强制状态改变，可以在参数中添加<code class="eh ku kv kw kj b">storage</code>键。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="0115" class="kn ko ht kj b fv kp kq l kr ks">function changeFirstElement(string[] storage newItems) private {<br/>        newItems[0] = 'lemon';<br/>}</span></pre><p id="33ae" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="mp">鳍</em></p></div></div>    
</body>
</html>