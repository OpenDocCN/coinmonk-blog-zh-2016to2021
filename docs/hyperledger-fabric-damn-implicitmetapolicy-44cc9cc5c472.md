# 超分类帐结构该死的隐式元策略

> 原文：<https://medium.com/coinmonks/hyperledger-fabric-damn-implicitmetapolicy-44cc9cc5c472?source=collection_archive---------2----------------------->

![](img/765278433dae0c90cd6d652a81927a48.png)

[Hyperledger Fabric Image](https://www.hyperledger.org/blog/2018/11/28/conducting-data-with-concerto-and-hyperledger-fabric)

## 1.介绍

> 在本教程中，我们参考一个示例 [configtx.yaml](https://gist.github.com/reasdom/2bdae4ccd97e459e6907f343aaa57f4f) *。*
> 
> 这个样本文件很长，所以我没有嵌入到博文中。我建议您可以**快速看一下**，然后继续，并在需要参考的时候阅读示例 [configtx.yaml](https://gist.github.com/reasdom/2bdae4ccd97e459e6907f343aaa57f4f) 的一些相关部分。另外**我假设你对 Hyperledger Fabric** 有一定程度的了解。

在示例[*configtx . YAML*](https://gist.github.com/reasdom/2bdae4ccd97e459e6907f343aaa57f4f)中，有两种类型的策略*:*

## ***第一种——签名***

*the first type of policy*

## ***第二种类型——***

**the second type of policy**

***签名*类型策略是容易的，而*隐式元*类型策略是抽象的。这个简短的教程是解释 ***如何解释 ImplicitMeta 类型策略*** 。**

> ***假设在本教程中，ImplicitMeta 的名称和 ImplicitMeta 的规则目标始终是同一个**。****
> 
> **例如，第二种策略，“Readers”(第 1 行)和“Readers”(第 3 行)是相同的，尽管它们可能不同。**

## **2.配置的级别**

**在示例[*configtx . yam*](https://gist.github.com/reasdom/2bdae4ccd97e459e6907f343aaa57f4f)*l*中，存在不同级别的配置，其中每个级别代表“访问或配置”项目的不同子集，例如频道更新。**

**下面是那些级别的树形结构表示，按照[*configtx . YAML*](https://gist.github.com/reasdom/2bdae4ccd97e459e6907f343aaa57f4f)*举例。***

**tree structure of levels**

## **3.配置级别的表示**

**根据树结构，有一个标准的方法来表示这些级别。**

**例如，为了表示“订购者”级别，我们使用:**

*   *****频道\订购者*** 。**

**再举一个例子，为了表示“Org1”级别，我们使用:**

*   *****通道\应用\Org1*** 。**

## **4.配置级别策略**

**对于每个级别，都定义了策略来控制该级别“访问或配置”项目的不同访问权限。**

## **5.策略的访问权限类型**

**对于定义的每个策略，都有一个 ***基本访问权限类型*** 与该策略相关联，包括:**

1.  **作家(写作)**
2.  **读者(阅读)**
3.  **管理员(配置)**

**例如，针对读者(要阅读)的策略:**

**Readers policy example (Signature type)**

## **6.隐性元政策解读**

**接下来，假设我们在 ***渠道\应用*** 级别有一个样本策略:**

**Readers policy example (ImplicitMeta type)**

**为了解释这个 *ImplicitMeta* 策略，我们需要:**

## ****(6.1)了解该策略的级别****

**在本示例中， ***通道\应用*****

## ****(6.2)列出下级中*访问权限类型*相同的所有策略，人们称这些列出的策略为*子策略* :****

**在此示例中，这些子策略是级别 ***通道\应用\**** 中的“读者”策略**

**也就是说，**

*   **子策略(a): ***渠道\应用\组织 1 \读者*****
*   **子策略(b): ***渠道\应用\组织 2 \读者*****

## ****(6.3)知道政策的*规则*:****

**在这个示例中，它是一个“任何”策略。**

> **还有“多数”和“全部”。它们的名字应该容易理解。**

## ****(6.4)了解*要求*通过此政策:****

**在这个示例中，要求是，“任何子策略都足够了”。**

**因此，满足子策略(a)和(b)中的任何一个，则满足这个*隐含元*策略。**

## **7.再举一个例子**

**让我们在 ***通道*** 级别(最高级别)再来一个样本:**

## ****(7.1)了解该政策的水平****

**在这个例子中， ***通道*****

## ****(7.2)列出下级中所有具有相同访问权限类型的策略，人们称这些列出的策略为子策略:****

**在此示例中，这些策略是级别 ***通道\**** 中的“管理员”策略**

*   **子策略(a): ***渠道\应用\管理员*****

1.  **→渠道\应用\组织 1 \管理**
2.  **→渠道\应用\组织 2 \管理**

*   **子策略(b): ***渠道\订购者\管理员*****

1.  **→频道\订购者\订购者或\管理员**

## ****(7.3)知道政策的*规则*:****

**在本例中，这是一个“多数”策略。**

## ****(7.4)知道*要求*通过此政策:****

**在这个示例中，需求是“需要满足大多数子策略”。因此，一旦满足了大多数子策略(a)和(b ),那么就满足了这个*隐含元*策略。这里的“多数”是其中的 2 个(即在这种情况下是全部)。**

## **8.奖金 1**

**继续上面的例子，如果我们想要配置(因为它是“管理”策略)信道设置(因为它是在 ***信道*** 级别的策略)，一个可能的通过条件是通过子策略(a)和(b)，因为有 2 个子策略，并且在这种情况下“多数”是它们中的 2 个(全部)。**

**在示例[*configtx . yam*](https://gist.github.com/reasdom/2bdae4ccd97e459e6907f343aaa57f4f)*l*中，子策略(a.1)、(a.2)、(b.1)为*签名*类型策略。**

**换句话说，一个可能的通过条件是收集 org1 admin、org2 admin 和 ordererOrg admin 的签名，然后如果没有其他错误，您可能能够配置通道设置。**

## **9.奖金 2**

**所以，总的来说，解释一个 *ImplicitMeta* 策略的方式有点像“分而治之”。**

**也就是说，为了评估一个 *ImplicitMeta* 策略，我们将它分成更小的部分(子策略)，并尝试解决它们。但是那些较小的部分可能本身就是隐含的元策略，然后我们再次削减…**

**经过一些划分后，那些最低级别的子策略是那些*签名*类型的策略，不需要进一步切割，它们可以立即被解决。**

**最后，我们回到最初的最大问题——我们最初的 *ImplicitMeta* 策略，并组合那些较小问题的解决方案，然后解决最初的最大问题。**

**接下来，是通过还是失败？**

**谢谢！如果你喜欢我的故事， [**请关注我**](/@reasdom) **的新更新！****

## **参考**

**[](https://hyperledger-fabric.readthedocs.io/en/release-1.4/policies.html?highlight=policy) [## Hyperledger 结构中的策略- hyperledger-fabricdocs 主文档

### Hyperledger 结构区块链网络的配置由策略管理。这些政策通常存在于…

hyperledger-fabric . readthedocs . io](https://hyperledger-fabric.readthedocs.io/en/release-1.4/policies.html?highlight=policy) [![](img/449450761cd76f44f9ae574333f9e9af.png)](http://bit.ly/2G71Sp7)**