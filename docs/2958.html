<html>
<head>
<title>From Stack Machine to Functional Machine: Step 2 — Currying</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从堆叠机器到功能机器:步骤2—curry</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/from-stack-machine-to-functional-machine-step-2-currying-f26c7f8b7220?source=collection_archive---------0-----------------------#2020-04-28">https://medium.com/coinmonks/from-stack-machine-to-functional-machine-step-2-currying-f26c7f8b7220?source=collection_archive---------0-----------------------#2020-04-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/3518aa52911d01d65fafbbc5fe0a4d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*sBi2POjV8lfq2QidZH0ltw.png"/></div></figure><p id="e766" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><a class="ae jv" href="https://github.com/loredanacirstea/articles/blob/master/articles/FromStackMachineToFunctionalMachine_Step2_Currying.md" rel="noopener ugc nofollow" target="_blank">在Github上阅读</a>。</p><p id="f01c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">标签:<code class="eh jw jx jy jz b">Taylor</code>、<code class="eh jw jx jy jz b">Ethereum</code>、<code class="eh jw jx jy jz b">Solidity</code>、<code class="eh jw jx jy jz b">Yul</code>、<code class="eh jw jx jy jz b">eWasm</code>、<code class="eh jw jx jy jz b">WebAssembly</code></p><p id="4573" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这是我在CEST时间4月29日星期三下午2:50:00<a class="ae jv" href="https://solidity-summit.ethereum.org" rel="noopener ugc nofollow" target="_blank">Solidity Summit</a>上的演讲的逐步介绍。<a class="ae jv" href="https://docs.google.com/spreadsheets/d/1ylkaTYKx9TbAifCgyH2jN9SKJKrYfzab9zzTZgSL44g/edit#gid=0" rel="noopener ugc nofollow" target="_blank">议程</a>。</p><h1 id="3b71" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">环境</h1><p id="dfe2" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">为了说明我们的旅程，我们将使用<a class="ae jv" href="https://solidity.readthedocs.io/en/v0.6.4/yul.html" rel="noopener ugc nofollow" target="_blank"> Yul语言</a>(编译成以太坊1.0和Wasm字节码)。</p><p id="b2b1" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">如果你想运行这些例子，可以用<a class="ae jv" href="https://remix.ethereum.org" rel="noopener ugc nofollow" target="_blank">https://remix.ethereum.org</a>来完成:</p><ul class=""><li id="df74" class="ld le ht iz b ja jb je jf ji lf jm lg jq lh ju li lj lk ll dt translated">选择Yul作为编译语言，使用原始的<code class="eh jw jx jy jz b">calldata</code>输入，使用调试器检查返回值。</li><li id="2345" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated">使用Yul+插件来编译、部署和交互(您需要注释掉<code class="eh jw jx jy jz b">mslice</code>助手函数)</li></ul><p id="9bb2" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">下面的代码示例也可以在<a class="ae jv" href="https://gist.github.com/loredanacirstea/1aa18e33342b862d8dc76c01b12b7dbc" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/loredanacistea/1 aa 18 e 33342 b 862d 8 DC 76 c 01 b 12 b 7 DBC</a>找到。</p><h1 id="ec5f" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">先决条件</h1><p id="b980" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">阅读上一篇文章<a class="ae jv" rel="noopener" href="/@loredana.cirstea/from-stack-machine-to-functional-machine-step-1-fd2f12a372e2">从栈机到功能机:第一步(递归应用)</a>。</p><h1 id="db06" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">Currying</h1><p id="0baa" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">Currying是一种将接受多个参数的函数分解成一系列函数的技术，每个函数接受一个或多个参数。</p><p id="edee" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">因此，我们可以把<code class="eh jw jx jy jz b">const sum = (a, b) =&gt; a + b</code>写成:</p><pre class="lr ls lt lu fq lv jz lw lx aw ly dt"><span id="89cc" class="lz kb ht jz b fv ma mb l mc md">const sumCurried = a =&gt; b =&gt; a + b</span><span id="810e" class="lz kb ht jz b fv me mb l mc md">const sumPartial = sumCurried(64)<br/>sumPartial(32) // returns 96</span></pre><p id="ffae" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在我们可以在代码的其他地方重用<code class="eh jw jx jy jz b">sumPartial</code>，例如，作为<code class="eh jw jx jy jz b">map</code>函数的参数:<code class="eh jw jx jy jz b">map(array, sumPartial)</code>。</p><p id="7d9f" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在我们的链上解释类型系统Taylor中，通过currying，我们可以定义类型的类。<code class="eh jw jx jy jz b">uint</code>本身是一个部分应用的函数，现在我们可以像<code class="eh jw jx jy jz b">uint(256)</code>一样重用这个函数，我们将得到一个具体的类型。</p><h1 id="9921" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">弹性系数</h1><p id="846b" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">curry和de-curry是实现更好的人机交流的重要工具。</p><p id="377f" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">如果人类习惯于arity 2: <code class="eh jw jx jy jz b">sum(a, b)</code>的和函数，通过currying，计算机会将其解释为arity 1: <code class="eh jw jx jy jz b">sum(a)(b)</code>的函数的组合</p><p id="f412" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">如果有一族arity <code class="eh jw jx jy jz b">n</code>的函数，arity <code class="eh jw jx jy jz b">n+1</code>的覆盖函数可以被构造成使得任何一个初始函数都通过进行选择的附加自变量来调用。<br/>拥有动态arity可能会使函数更加直观:</p><pre class="lr ls lt lu fq lv jz lw lx aw ly dt"><span id="779d" class="lz kb ht jz b fv ma mb l mc md">sum[arity n+1] = sum[arity n](last_argument)</span><span id="a6fb" class="lz kb ht jz b fv me mb l mc md">sum(2,3,4,5) = sum(2,3,4)(5) = … = sum(2)(3)(4)(5)</span></pre><h1 id="d9b6" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">以太坊虚拟机和WASM中的Currying</h1><p id="2863" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">Yul允许我们直接使用堆栈和内存，所以我们有足够的自由在运行时实现currying系统。</p><p id="a63a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们所需要做的就是在内存中维护一个空间，我们的curried函数就在那里。在下面的代码中，我们将把每个指向一个可定制函数的内存指针视为该可定制函数的签名。</p><p id="e1cd" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在内存指针处，我们将找到底层函数的签名，以及部分应用的参数。在上面的例子中，这意味着<code class="eh jw jx jy jz b">&lt;sumCurried_signature&gt;0000000000000000000000000000000000000000000000000000000000000040</code> ( <code class="eh jw jx jy jz b">64 = 0x40</code>)。</p><p id="88e1" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在，我们可以在其他函数中使用curried函数的签名，我们将在我们的<a class="ae jv" rel="noopener" href="/@loredana.cirstea/from-stack-machine-to-functional-machine-step-1-fd2f12a372e2"> <strong class="iz hu">第一步</strong> </a>文章中给出的<code class="eh jw jx jy jz b">recursive apply</code>代码的基础上进行构建。</p><p id="554a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">下面的代码允许我们递归地应用一系列函数，其中每个函数的输出都作为输入提供给下一个函数。</p><p id="9b67" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们有:</p><ul class=""><li id="f404" class="ld le ht iz b ja jb je jf ji lf jm lg jq lh ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">executeNative</code>中的一些“原生”函数，比如<code class="eh jw jx jy jz b">sum</code> ( <code class="eh jw jx jy jz b">0xeeeeeeee</code>)、<code class="eh jw jx jy jz b">recursiveApply</code> ( <code class="eh jw jx jy jz b">0xcccccccc</code>)、<code class="eh jw jx jy jz b">curry</code> ( <code class="eh jw jx jy jz b">0xbbbbbbbb</code>)。我们会用多个<code class="eh jw jx jy jz b">steps</code>来调用<code class="eh jw jx jy jz b">recursiveApply</code>，每个步骤都是一个有一些输入的函数。</li><li id="6f8a" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">executeCurriedFunction</code>，知道如何处理定制函数</li><li id="793e" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">executeInternal</code>，它知道如何区分一个“原生”和一个curried函数。</li></ul><h2 id="e4ce" class="lz kb ht bd kc mf mg mh kg mi mj mk kk ji ml mm ko jm mn mo ks jq mp mq kw mr dt translated">Currying示例:sum(64，32)</h2><p id="c9ef" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated"><code class="eh jw jx jy jz b">calldata</code>将是:<code class="eh jw jx jy jz b">0xffffffffcccccccc000000020000002800000020bbbbbbbbeeeeeeee00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000020</code></p><pre class="lr ls lt lu fq lv jz lw lx aw ly dt"><span id="0bdd" class="lz kb ht jz b fv ma mb l mc md">ffffffff - the main execute function cccccccc - recursiveApply<br/>00000002 - number of steps for recursiveApply<br/>00000028 - data length in bytes for the first step<br/>00000020 - data length in bytes for the second step<br/>bbbbbbbb - second step starts here, with the signature for the curry function<br/>eeeeeeee - sum function signature 0000000000000000000000000000000000000000000000000000000000000040<br/>   - partially applied argument for sum: 64 0000000000000000000000000000000000000000000000000000000000000020<br/>   - second step, with the second sum argument: 32</span></pre><h2 id="514c" class="lz kb ht bd kc mf mg mh kg mi mj mk kk ji ml mm ko jm mn mo ks jq mp mq kw mr dt translated">程序流程</h2><figure class="lr ls lt lu fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="fe ff ms"><img src="../Images/498eddb4d9b7815ffd75d67b8e36c3fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Oyv3j3nUPBESJyJL.png"/></div></div></figure><p id="9b8a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">开始呼叫</strong></p><ul class=""><li id="81ab" class="ld le ht iz b ja jb je jf ji lf jm lg jq lh ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">execute</code>函数用<code class="eh jw jx jy jz b">000000020000002800000020bbbbbbbbeeeeeeee00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000020</code>调用<code class="eh jw jx jy jz b">recursiveApply</code></li><li id="6e79" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">recursiveApply</code>分解步骤并运行每一步，将每一步的输出输入下一步</li></ul><p id="d0f7" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">第一步</strong></p><ul class=""><li id="19b6" class="ld le ht iz b ja jb je jf ji lf jm lg jq lh ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">recursiveApply</code>用<code class="eh jw jx jy jz b">bbbbbbbbeeeeeeee0000000000000000000000000000000000000000000000000000000000000040</code>调用<code class="eh jw jx jy jz b">executeInternal</code></li><li id="f831" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">executeInternal</code>看到签名是4个字节，调用<code class="eh jw jx jy jz b">executeNative</code>，转发所有数据</li><li id="9a34" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">executeNative</code>解包<code class="eh jw jx jy jz b">0xbbbbbbbb</code>签名，程序到达<code class="eh jw jx jy jz b">curry</code>功能。</li><li id="3a98" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">curry</code>将虚拟的、简化的函数签名<code class="eh jw jx jy jz b">0xeeeeeeee</code>和部分应用的参数<code class="eh jw jx jy jz b">0x0000000000000000000000000000000000000000000000000000000000000040</code> ( <code class="eh jw jx jy jz b">64</code>)存储在内存指针中，并将该指针写入<code class="eh jw jx jy jz b">output_ptr</code></li><li id="7c00" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated">程序返回到<code class="eh jw jx jy jz b">recursiveApply</code>，准备输出作为下一步的输入</li></ul><p id="7850" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">第二步</strong></p><ul class=""><li id="1af4" class="ld le ht iz b ja jb je jf ji lf jm lg jq lh ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">recursiveApply</code>用<code class="eh jw jx jy jz b">&lt;sumPartial_pointer&gt;0000000000000000000000000000000000000000000000000000000000000020</code>称呼<code class="eh jw jx jy jz b">executeInternal</code></li><li id="c0c0" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">executeInternal</code>看到签名是32字节，调用<code class="eh jw jx jy jz b">executeCurried</code>，转发所有数据</li><li id="5a8c" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">executeCurried</code>用<code class="eh jw jx jy jz b">0xeeeeeeee0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000020</code>调用<code class="eh jw jx jy jz b">executeInternal</code>，将修改后的函数数据与新输入合并</li><li id="6820" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">executeInternal</code>看到签名是4个字节并调用<code class="eh jw jx jy jz b">executeNative</code></li><li id="a8f6" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">executeNative</code>解包<code class="eh jw jx jy jz b">0xeeeeeeee</code>签名，程序到达<code class="eh jw jx jy jz b">sum</code>功能</li><li id="2fcc" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated"><code class="eh jw jx jy jz b">sum</code>将两个自变量相加，并将答案写入<code class="eh jw jx jy jz b">output_ptr</code>内存指针。</li><li id="99ea" class="ld le ht iz b ja lm je ln ji lo jm lp jq lq ju li lj lk ll dt translated">程序返回到结果点<code class="eh jw jx jy jz b">recursiveApply</code>和<code class="eh jw jx jy jz b">output_ptr</code></li></ul><p id="9e25" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">返回</strong></p><ul class=""><li id="4617" class="ld le ht iz b ja jb je jf ji lf jm lg jq lh ju li lj lk ll dt translated">程序返回到<code class="eh jw jx jy jz b">execute</code>，并返回来自<code class="eh jw jx jy jz b">output_ptr</code>的结果</li></ul><pre class="lr ls lt lu fq lv jz lw lx aw ly dt"><span id="5aab" class="lz kb ht jz b fv ma mb l mc md">object "ContractB" {<br/>  code {<br/>      datacopy(0, dataoffset("Runtime"), datasize("Runtime"))<br/>      return(0, datasize("Runtime"))<br/>  }<br/>  object "Runtime" {<br/>    code {<br/>      let _calldata := 2048<br/>      let _output_pointer := 0</span><span id="1f67" class="lz kb ht jz b fv me mb l mc md">      // This is where we keep our virtual functions<br/>      // generated at runtime as partial function applications<br/>      let _virtual_fns := 1024</span><span id="0e6b" class="lz kb ht jz b fv me mb l mc md">      calldatacopy(_calldata, 0, calldatasize())</span><span id="df65" class="lz kb ht jz b fv me mb l mc md">      let fn_sig := mslice(_calldata, 4)</span><span id="fdf0" class="lz kb ht jz b fv me mb l mc md">      switch fn_sig</span><span id="f185" class="lz kb ht jz b fv me mb l mc md">      // execute function<br/>      case 0xffffffff {<br/>        let internal_fn_sig := mslice(add(_calldata, 4), 4)<br/>        let input_pointer := add(_calldata, 8)<br/>        let input_size := sub(calldatasize(), 4)</span><span id="2f02" class="lz kb ht jz b fv me mb l mc md">        let result_length := executeNative(<br/>            internal_fn_sig,<br/>            input_pointer,<br/>            input_size,<br/>            _output_pointer,<br/>            _virtual_fns<br/>        )<br/>        return (_output_pointer, result_length)<br/>      }<br/>      // other cases/function signatures<br/>      default {<br/>        mslicestore(_output_pointer, 0xeee1, 2)<br/>        revert(_output_pointer, 2)<br/>      }</span><span id="e63f" class="lz kb ht jz b fv me mb l mc md">      function executeNative(<br/>        fsig,<br/>        input_ptr,<br/>        input_size,<br/>        output_ptr,<br/>        virtual_fns<br/>      ) -&gt; result_length {<br/>        switch fsig</span><span id="4958" class="lz kb ht jz b fv me mb l mc md">        // sum: a + b<br/>        case 0xeeeeeeee {<br/>          let a := mload(input_ptr)<br/>          let b := mload(add(input_ptr, 32))<br/>          mstore(output_ptr, add(a, b))<br/>          result_length := 32<br/>        }</span><span id="b5d4" class="lz kb ht jz b fv me mb l mc md">        // recursiveApply<br/>        case 0xcccccccc {<br/>          // e.g. 2 steps:<br/>          // 000000020000002800000020<br/>          // bbbbbbbbeeeeeeee000000000000000000000000000000000000000000000000000000000000004<br/>          // 00000000000000000000000000000000000000000000000000000000000000020</span><span id="1536" class="lz kb ht jz b fv me mb l mc md">          // number of execution steps<br/>          let count := mslice(input_ptr, 4)</span><span id="ec96" class="lz kb ht jz b fv me mb l mc md">          // offsets/size in bytes for each step<br/>          let offsets_start := add(input_ptr, 4)<br/>          let input_inner := add(offsets_start, mul(count, 4))</span><span id="8483" class="lz kb ht jz b fv me mb l mc md">          let temporary_ptr := 0x80<br/>          let existent_input_size := 0</span><span id="d167" class="lz kb ht jz b fv me mb l mc md">          for { let i := 0 } lt(i, count) { i := add(i, 1) } {<br/>            let step_length := mslice(<br/>                add(offsets_start, mul(i, 4)),<br/>                4<br/>            )</span><span id="ee9d" class="lz kb ht jz b fv me mb l mc md">            // add current input after previous return value<br/>            mmultistore(<br/>              add(temporary_ptr, existent_input_size),<br/>              input_inner,<br/>              step_length<br/>            )</span><span id="bea7" class="lz kb ht jz b fv me mb l mc md">            result_length := executeInternal(<br/>              temporary_ptr,<br/>              add(existent_input_size, step_length),<br/>              output_ptr,<br/>              virtual_fns<br/>            )</span><span id="5c62" class="lz kb ht jz b fv me mb l mc md">            // move termporary input after previous data<br/>            temporary_ptr := add(temporary_ptr, step_length)</span><span id="033e" class="lz kb ht jz b fv me mb l mc md">            // store output as new input for the next step<br/>            mmultistore(temporary_ptr, output_ptr, result_length)<br/>            existent_input_size := result_length</span><span id="9272" class="lz kb ht jz b fv me mb l mc md">            // move input pointer to the next step<br/>            input_inner := add(input_inner, step_length)<br/>          }<br/>        }</span><span id="fd24" class="lz kb ht jz b fv me mb l mc md">        // curry: fsig, partial application argument<br/>        case 0xbbbbbbbb {<br/>          // first 32 bytes is the next free memory pointer<br/>          let fpointer := mload(virtual_fns)<br/>          if eq(fpointer, 0) {<br/>              fpointer := add(virtual_fns, 32)<br/>          }</span><span id="4b69" class="lz kb ht jz b fv me mb l mc md">          let internal_fsig := mslice(input_ptr, 4)<br/>          let arg := mload(add(input_ptr, 4))</span><span id="7e96" class="lz kb ht jz b fv me mb l mc md">          // virtual function marker<br/>          mslicestore(fpointer, 0xfefe, 2)</span><span id="f20d" class="lz kb ht jz b fv me mb l mc md">          // add input size (so we know how much to read)<br/>          mstore(add(fpointer, 2), input_size)</span><span id="546e" class="lz kb ht jz b fv me mb l mc md">          // store the actual data - partial application argument<br/>          mmultistore(add(fpointer, 34), input_ptr, input_size)</span><span id="285f" class="lz kb ht jz b fv me mb l mc md">          // update the free memory pointer for our curried functions references<br/>          mstore(virtual_fns, add(fpointer, 38))</span><span id="36c2" class="lz kb ht jz b fv me mb l mc md">          // return the virtual function pointer<br/>          mstore(output_ptr, fpointer)<br/>          result_length := 32<br/>        }<br/>        // other cases/function signatures<br/>        default {<br/>          // revert with error code<br/>          mslicestore(output_ptr, 0xeee2, 2)<br/>          revert(output_ptr, 2)<br/>        }<br/>      }</span><span id="ee50" class="lz kb ht jz b fv me mb l mc md">      function executeInternal(<br/>        input_ptr,<br/>        input_size,<br/>        output_ptr,<br/>        virtual_fns<br/>      ) -&gt; result_length {<br/>        let fsig, offset := getfSig(input_ptr)</span><span id="f1f4" class="lz kb ht jz b fv me mb l mc md">      switch offset<br/>        case 4 {<br/>          result_length := executeNative(<br/>            fsig,<br/>            add(input_ptr, offset),<br/>            sub(input_size, offset),<br/>            output_ptr,<br/>            virtual_fns<br/>          )<br/>        }<br/>        case 32 {<br/>          result_length := executeCurriedFunction(<br/>            fsig,<br/>            add(input_ptr, offset),<br/>            sub(input_size, offset),<br/>            output_ptr,<br/>            virtual_fns<br/>          )<br/>        }<br/>        default {<br/>          // revert with error code<br/>          mslicestore(output_ptr, 0xeee3, 2)<br/>          revert(output_ptr, 2)<br/>        }<br/>      }</span><span id="1776" class="lz kb ht jz b fv me mb l mc md">      function getfSig(input_ptr) -&gt; fsig, offset {<br/>        fsig := mslice(input_ptr, 4)<br/>        offset := 4<br/>        let fpointer := mload(input_ptr)</span><span id="1429" class="lz kb ht jz b fv me mb l mc md">        if lt(fpointer, 10000000) {<br/>          // check if the curried function marker exists<br/>          if eq(mslice(fpointer, 2), 0xfefe) {<br/>            fsig := fpointer<br/>            offset := 32<br/>          }<br/>        }<br/>      }</span><span id="2b8d" class="lz kb ht jz b fv me mb l mc md">     function executeCurriedFunction(<br/>        fpointer,<br/>        input_ptr,<br/>        input_size,<br/>        output_ptr,<br/>        virtual_fns<br/>      ) -&gt; result_length {<br/>        // first 32 bytes are the input size<br/>        let new_input_size := mload(add(fpointer, 2))</span><span id="7ae0" class="lz kb ht jz b fv me mb l mc md">        // exclude input size from input ptr<br/>        let new_input_ptr := add(fpointer, 34)</span><span id="8e26" class="lz kb ht jz b fv me mb l mc md">        // store the inputs for the curried function after the curried function arguments<br/>        // effectively composing the input for the actual function that we need to run<br/>        mmultistore(add(new_input_ptr, new_input_size), input_ptr, input_size)<br/>        new_input_size := add(new_input_size, input_size)</span><span id="7a97" class="lz kb ht jz b fv me mb l mc md">        result_length := executeInternal(<br/>          new_input_ptr,<br/>          new_input_size,<br/>          output_ptr,<br/>          virtual_fns<br/>        )<br/>      }</span><span id="74cc" class="lz kb ht jz b fv me mb l mc md">      function mslice(position, length) -&gt; result {<br/>        result := div(<br/>          mload(position),<br/>          exp(2, sub(256, mul(length, 8)))<br/>        )<br/>      }</span><span id="4220" class="lz kb ht jz b fv me mb l mc md">      function mslicestore(_ptr, val, length) {<br/>        let slot := 32<br/>        mstore(_ptr, shl(mul(sub(slot, length), 8), val))<br/>      }</span><span id="9fe0" class="lz kb ht jz b fv me mb l mc md">      function mmultistore(_ptr_target, _ptr_source, sizeBytes) {<br/>        let slot := 32<br/>        let size := div(sizeBytes, slot)</span><span id="019b" class="lz kb ht jz b fv me mb l mc md">        for { let i := 0 } lt(i, size)  { i := add(i, 1) } {<br/>          mstore(<br/>            add(_ptr_target, mul(i, slot)),<br/>            mload(add(_ptr_source, mul(i, slot)))<br/>          )<br/>        }</span><span id="7ccf" class="lz kb ht jz b fv me mb l mc md">      let current_length :=  mul(size, slot)<br/>        let remaining := sub(sizeBytes, current_length)<br/>        if gt(remaining, 0) {<br/>          mslicestore(<br/>            add(_ptr_target, current_length),<br/>            mslice(add(_ptr_source, current_length), remaining),<br/>            remaining<br/>          )<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="ea4d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">拥有一种处理函数的技术(在运行时)是将堆栈机器转变为功能机器的第二步。</p><p id="0b96" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">当用作<code class="eh jw jx jy jz b">map</code>或<code class="eh jw jx jy jz b">reduce</code>参数时，部分应用的函数可能非常重要，允许您编写可扩展的代码。</p><h1 id="eac3" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">下一步:第三步</h1><p id="67cb" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">下一步，我们将向您展示如何在这个递归引擎中使用高阶函数。</p><p id="86f9" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">阅读步骤3: <a class="ae jv" rel="noopener" href="/@loredana.cirstea/from-stack-machine-to-functional-machine-step-3-higher-order-functions-18fb751066ec"> <strong class="iz hu">从堆叠机到功能机:步骤3(高阶功能)</strong> </a></p></div><div class="ab cl mx my hb mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hm hn ho hp hq"><p id="97c2" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><em class="ne">原载于</em><a class="ae jv" href="https://github.com/loredanacirstea/articles/blob/master/articles/FromStackMachineToFunctionalMachine_Step2_Currying.md" rel="noopener ugc nofollow" target="_blank"><em class="ne">https://github.com</em></a><em class="ne">。</em></p><blockquote class="nf"><p id="3e9b" class="ng nh ht bd ni nj nk nl nm nn no ju ek translated"><a class="ae jv" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nq nr ns nt nu iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff np"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>