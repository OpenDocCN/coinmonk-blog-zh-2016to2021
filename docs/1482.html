<html>
<head>
<title>Ethernaut Lvl 19 MagicNumber Walkthrough: How to deploy contracts using raw assembly opcodes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ethernaut Lvl 19 MagicNumber演练:如何使用原始程序集操作码部署协定</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2?source=collection_archive---------1-----------------------#2018-09-10">https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2?source=collection_archive---------1-----------------------#2018-09-10</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="b826" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">这是一个围绕<a class="ae ji" href="https://openzeppelin.org/" rel="noopener ugc nofollow" target="_blank"> Zeppelin </a>团队的<a class="ae ji" href="https://ethernaut.zeppelin.solutions/" rel="noopener ugc nofollow" target="_blank">智能合约安全拼图</a>的<a class="ae ji" rel="noopener" href="/@nicolezhu">深度系列</a>。我们学习关键的可靠性概念，以便100%靠自己解决难题。</h2></div><p id="d62e" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">这个级别需要一些汇编编程来将一个微小的契约部署到EVM。</p></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff km"><img src="../Images/d7ca92f66cd659701c2b909c58fb894c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Wrb7z3W6AMtjH6IKJYowg.jpeg"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Let’s break this down :)</figcaption></figure><h1 id="bc8b" class="lc ld ht bd le lf lg lh li lj lk ll lm iz ln ja lo jc lp jd lq jf lr jg ls lt dt translated">合同创建期间发生了什么</h1><p id="3311" class="pw-post-body-paragraph jj jk ht jl b jm lu iu jo jp lv ix jr js lw ju jv jw lx jy jz ka ly kc kd ke hm dt translated">回想一下，在<a class="ae ji" rel="noopener" href="/coinmonks/ethernaut-lvl-14-gatekeeper-2-walkthrough-how-contracts-initialize-and-how-to-do-bitwise-ddac8ad4f0fd">合同初始化</a>期间，发生了以下情况:</p><p id="5a77" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">1.<strong class="jl hu">首先，用户或合约向以太坊网络发送交易。</strong>本交易包含数据，但无收款人地址。这种格式向EVM表明这是一个<code class="eh lz ma mb mc b">contract creation</code>，而不是一个常规的发送/调用事务。</p><p id="30a3" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">2.第二，EVM将Solidity(一种高级的人类可读语言)中的合同代码编译成字节码(一种低级的机器可读语言)。这个字节码直接翻译成操作码，操作码在单个调用栈中执行。</p><blockquote class="md me mf"><p id="2414" class="jj jk mg jl b jm jn iu jo jp jq ix jr mh jt ju jv mi jx jy jz mj kb kc kd ke hm dt translated">重要的是要注意:<code class="eh lz ma mb mc b">contract creation</code>字节码包含1) <code class="eh lz ma mb mc b">initialization code</code>和2)契约的实际<code class="eh lz ma mb mc b">runtime code</code>，按顺序连接。</p></blockquote><p id="b3f5" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">3.<strong class="jl hu">在合同创建过程中，EVM只执行</strong> <code class="eh lz ma mb mc b"><strong class="jl hu">initialization code</strong></code> <strong class="jl hu"> </strong>，直到到达堆栈中的第一条停止或返回指令。在这个阶段，契约的constructor()函数运行，契约有一个地址。</p><p id="a766" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">3.1.<strong class="jl hu">该初始化代码运行后，只有</strong> <code class="eh lz ma mb mc b"><strong class="jl hu">runtime code</strong></code> <strong class="jl hu">保留在堆栈</strong>中。然后，这些操作码被复制到内存中，并返回到EVM。</p><p id="7bfa" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">5.<strong class="jl hu">最后，EVM将该返回的剩余代码存储在州存储器中，</strong>与新合同地址相关联。这是<code class="eh lz ma mb mc b">runtime code</code>,将由堆栈在将来所有对新契约的调用中执行。</p><h2 id="9847" class="mk ld ht bd le ml mm mn li mo mp mq lm js mr ms lo jw mt mu lq ka mv mw ls mx dt translated">简而言之</h2><p id="cdee" class="pw-post-body-paragraph jj jk ht jl b jm lu iu jo jp lv ix jr js lw ju jv jw lx jy jz ka ly kc kd ke hm dt translated">要解决这个问题，您需要两组操作码:</p><ul class=""><li id="1a8f" class="my mz ht jl b jm jn jp jq js na jw nb ka nc ke nd ne nf ng dt translated"><code class="eh lz ma mb mc b">Initialization opcodes</code>:由EVM立即运行，以创建您的合同并存储您未来的运行时操作码，以及</li><li id="86e2" class="my mz ht jl b jm nh jp ni js nj jw nk ka nl ke nd ne nf ng dt translated"><code class="eh lz ma mb mc b">Runtime opcodes</code>:包含你想要的实际执行逻辑。这是您的代码的主要部分，应该<strong class="jl hu">返回0x </strong> <code class="eh lz ma mb mc b"><strong class="jl hu">0x42</strong></code> <strong class="jl hu">并且在10个操作码之下。</strong></li></ul><p id="e659" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><em class="mg">至此，要独立解决这个层次，可以深入阅读关于</em> <a class="ae ji" rel="noopener" href="/@blockchain101/solidity-bytecode-and-opcode-basics-672e9b1a88c2"> <em class="mg">操作码</em> </a> <em class="mg">和</em> <a class="ae ji" href="https://blog.zeppelin.solutions/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737" rel="noopener ugc nofollow" target="_blank"> <em class="mg">智能契约解构</em> </a> <em class="mg">(出自本Ethernaut层次的作者)。</em></p><p id="cf88" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><em class="mg">要获得更多指导，让我们继续……</em></p></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="d9bd" class="lc ld ht bd le lf nm lh li lj nn ll lm iz no ja lo jc np jd lq jf nq jg ls lt dt translated">详细演练</h1><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff nr"><img src="../Images/dc1106226fab0691b347c79f5a509e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3oSxbDxt1O5IYzW1vX7MmQ.png"/></div></div></figure><p id="95ad" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">0.用Ropsten (或您的首选设置)启动<a class="ae ji" rel="noopener" href="/coinmonks/5-minute-guide-to-deploying-smart-contracts-with-truffle-and-ropsten-b3e30d5ee1e"> truffle控制台，以便能够直接将字节码部署到EVM。并打开这张</a><a class="ae ji" href="https://github.com/ethereum/pyethereum/blob/develop/ethereum/opcodes.py" rel="noopener ugc nofollow" target="_blank">字节码&lt; &gt;操作码转换</a>图方便参考。</p><h1 id="711e" class="lc ld ht bd le lf lg lh li lj lk ll lm iz ln ja lo jc lp jd lq jf lr jg ls lt dt translated">运行时操作码—第1部分</h1><p id="cd9d" class="pw-post-body-paragraph jj jk ht jl b jm lu iu jo jp lv ix jr js lw ju jv jw lx jy jz ka ly kc kd ke hm dt translated">首先，让我们弄清楚<code class="eh lz ma mb mc b">runtime code</code>的逻辑。该级别限制您只能使用10个操作码。幸运的是，返回一个简单的<code class="eh lz ma mb mc b">0x42</code>并不需要更多的时间。</p><p id="4f83" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jl hu">返回值</strong>由<code class="eh lz ma mb mc b">RETURN</code>操作码处理，它接受两个参数:</p><ul class=""><li id="260d" class="my mz ht jl b jm jn jp jq js na jw nb ka nc ke nd ne nf ng dt translated"><code class="eh lz ma mb mc b">p</code>:您的值在内存中存储的位置，即0x0、0x40、0x50(见图)。<em class="mg">我们来任意挑一下0x80槽。</em></li><li id="076b" class="my mz ht jl b jm nh jp ni js nj jw nk ka nl ke nd ne nf ng dt translated"><code class="eh lz ma mb mc b">s</code>:你存储数据的大小。<em class="mg">回想一下你的值是32字节长(或者十六进制的0x20)。</em></li></ul><p id="e86c" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><em class="mg">回想一下以太坊内存是这样的，0x0，0x10，0x20…作为官位参考:</em></p><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div class="fe ff ns"><img src="../Images/def0a9901d7aa50230f997d2eface8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*gkbvs_Csc4SusEMNegXcNQ.png"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Every Ethereum transaction has 2²⁵⁶ bytes of (temporary) memory space to work with</figcaption></figure><p id="029d" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">但是…这意味着在你可以返回一个值之前，首先你必须把它存储在内存中。</p><ol class=""><li id="d0dd" class="my mz ht jl b jm jn jp jq js na jw nb ka nc ke nt ne nf ng dt translated">首先，用<code class="eh lz ma mb mc b">mstore(p, v)</code>将您的<code class="eh lz ma mb mc b">0x42</code>值存储在内存中，其中p是位置，v是十六进制值:</li></ol><pre class="kn ko kp kq fq nu mc nv nw aw nx dt"><span id="529d" class="mk ld ht mc b fv ny nz l oa ob">6042    // v: push1 0x42 (value is 0x42)<br/>6080    // p: push1 0x80 (memory slot is 0x80)<br/>52      // mstore</span></pre><p id="fddd" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">2.然后，你可以<code class="eh lz ma mb mc b">return</code>这个<code class="eh lz ma mb mc b">0x42</code>值:</p><pre class="kn ko kp kq fq nu mc nv nw aw nx dt"><span id="29ec" class="mk ld ht mc b fv ny nz l oa ob">6020    // s: push1 0x20 (value is 32 bytes in size)<br/>6080    // p: push1 0x80 (value was stored in slot 0x80)<br/>f3      // return</span></pre><p id="6781" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">这个结果操作码序列应该是<code class="eh lz ma mb mc b">604260805260206080f3</code>。您的运行时操作码正好是10个操作码和10个字节长。</p></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="6238" class="lc ld ht bd le lf nm lh li lj nn ll lm iz no ja lo jc np jd lq jf nq jg ls lt dt translated">初始化操作码—第2部分</h1><p id="5084" class="pw-post-body-paragraph jj jk ht jl b jm lu iu jo jp lv ix jr js lw ju jv jw lx jy jz ka ly kc kd ke hm dt translated">现在让我们创建合同<code class="eh lz ma mb mc b">initialization opcodes</code>。这些操作码需要将你的<code class="eh lz ma mb mc b">runtime opcodes</code>复制到内存中，然后再返回给EVM。<em class="mg">回想一下，EVM会自动将运行时序列</em> <code class="eh lz ma mb mc b"><em class="mg">604260805260206080f3</em></code> <em class="mg">保存到区块链——您不必处理最后这一部分。</em></p><p id="e503" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">将代码从一个地方复制到另一个地方由操作码<code class="eh lz ma mb mc b">codecopy</code>处理，它接受3个参数:</p><ul class=""><li id="cb5c" class="my mz ht jl b jm jn jp jq js na jw nb ka nc ke nd ne nf ng dt translated"><code class="eh lz ma mb mc b">t</code>:代码在内存中的目的位置。<em class="mg">我们把代码任意保存到0x00位置。</em></li><li id="d70a" class="my mz ht jl b jm nh jp ni js nj jw nk ka nl ke nd ne nf ng dt translated"><code class="eh lz ma mb mc b">f</code>:参考整个字节码，<code class="eh lz ma mb mc b">runtime opcodes</code>的当前位置。记住<code class="eh lz ma mb mc b">f</code>在<code class="eh lz ma mb mc b">initialization opcodes</code>结束后开始。<em class="mg">真是鸡和蛋的问题！您目前不知道该值。</em></li><li id="472d" class="my mz ht jl b jm nh jp ni js nj jw nk ka nl ke nd ne nf ng dt translated"><code class="eh lz ma mb mc b">s</code>:代码的大小，以字节为单位。<em class="mg">回想一下</em> <code class="eh lz ma mb mc b"><em class="mg">604260805260206080f3</em></code> <em class="mg">的长度是10个字节(或者十六进制的0x0a)。</em></li></ul><p id="326e" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">3.首先将你的<code class="eh lz ma mb mc b">runtime opcodes</code>复制到内存中。为<code class="eh lz ma mb mc b">f</code>添加一个占位符，因为它目前未知:</p><pre class="kn ko kp kq fq nu mc nv nw aw nx dt"><span id="9361" class="mk ld ht mc b fv ny nz l oa ob">600a    // s: push1 0x0a (10 bytes)<br/>60??    // f: push1 0x?? (current position of runtime opcodes)<br/>6000    // t: push1 0x00 (destination memory index 0)<br/>39      // CODECOPY</span></pre><p id="c4b8" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">4.然后，<code class="eh lz ma mb mc b">return</code>你的内存中<code class="eh lz ma mb mc b">runtime opcodes</code>到了EVM:</p><pre class="kn ko kp kq fq nu mc nv nw aw nx dt"><span id="d0c3" class="mk ld ht mc b fv ny nz l oa ob">600a    // s: push1 0x0a (runtime opcode length)<br/>6000    // p: push1 0x00 (access memory index 0)<br/>f3      // return to EVM</span></pre><p id="1c00" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">5.注意，总的来说，<code class="eh lz ma mb mc b">initialization opcodes</code>占用了12个字节，或者说<code class="eh lz ma mb mc b">0x0c</code>个空格。这意味着您的<code class="eh lz ma mb mc b">runtime opcodes</code>将从索引<code class="eh lz ma mb mc b">0x0c</code>开始，其中<code class="eh lz ma mb mc b">f</code>现在已知为<code class="eh lz ma mb mc b">0x0c</code>:</p><pre class="kn ko kp kq fq nu mc nv nw aw nx dt"><span id="7841" class="mk ld ht mc b fv ny nz l oa ob">600a    // s: push1 0x0a (10 bytes)<br/>60<strong class="mc hu">0c</strong>    // f: push1 0x?? (current position of runtime opcodes)<br/>6000    // t: push1 0x00 (destination memory index 0)<br/>39      // CODECOPY</span></pre><p id="58f4" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">6.因此，最后的顺序是:</p><pre class="kn ko kp kq fq nu mc nv nw aw nx dt"><span id="fc08" class="mk ld ht mc b fv ny nz l oa ob">0x600a600c600039600a6000f3604260805260206080f3</span></pre><p id="d60e" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">其中前12个字节是<code class="eh lz ma mb mc b">initialization opcodes</code>，后面的10个字节是你的<code class="eh lz ma mb mc b">runtime opcodes</code>。</p><p id="b2d8" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">7.在Truffle控制台中，使用以下命令创建您的合同:</p><pre class="kn ko kp kq fq nu mc nv nw aw nx dt"><span id="bf22" class="mk ld ht mc b fv ny nz l oa ob">&gt; var account = "your address here";<br/>&gt; var bytecode = "0x600a600c600039600a6000f3604260805260206080f3";<br/>&gt; web3.eth.sendTransaction({ from: account, data: bytecode }, function(err,res){console.log(res)});</span></pre><p id="842e" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">8.从返回的事务哈希中查找新创建的<strong class="jl hu">合同地址</strong>。您可以通过Etherscan或getTransactionReceipt(hash)<strong class="jl hu">来完成此操作。</strong></p><p id="ffb7" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">9.在Ethernaut web控制台中，只需输入以下内容即可通过该级别:</p><pre class="kn ko kp kq fq nu mc nv nw aw nx dt"><span id="c522" class="mk ld ht mc b fv ny nz l oa ob">await contract.setSolver("contract address");</span></pre></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="db8b" class="lc ld ht bd le lf nm lh li lj nn ll lm iz no ja lo jc np jd lq jf nq jg ls lt dt translated">学习更多的可靠性</h1><p id="8b1f" class="pw-post-body-paragraph jj jk ht jl b jm lu iu jo jp lv ix jr js lw ju jv jw lx jy jz ka ly kc kd ke hm dt translated">查看<a class="ae ji" href="https://github.com/nczhu/soliditykoans" rel="noopener ugc nofollow" target="_blank"> Solidity Koans </a>，通过测试驱动开发学习更多的Solidity。我们计划很快对此进行开源，所以欢迎所有用户的反馈！</p><h1 id="165f" class="lc ld ht bd le lf lg lh li lj lk ll lm iz ln ja lo jc lp jd lq jf lr jg ls lt dt translated">推荐读物</h1><ul class=""><li id="3d54" class="my mz ht jl b jm lu jp lv js oc jw od ka oe ke nd ne nf ng dt translated">对于所有以前的级别，<a class="ae ji" rel="noopener" href="/@nicolezhu">从这里开始。</a></li><li id="10bd" class="my mz ht jl b jm nh jp ni js nj jw nk ka nl ke nd ne nf ng dt translated">为了更深入地了解Solidity装配的奇妙世界，我推荐以下文章:</li></ul><div class="of og fm fo oh oi"><a href="https://blog.zeppelin.solutions/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab ej"><div class="ok ab ol cl cj om"><h2 class="bd hu fv z el on eo ep oo er et hs dt translated">解构契约——第一部分:引言</h2><div class="op l"><h3 class="bd b fv z el on eo ep oo er et ek translated">亚历杭德罗·桑坦德与利奥·阿里亚斯合作。</h3></div><div class="oq l"><p class="bd b gc z el on eo ep oo er et ek translated">博客.齐柏林.解决方案</p></div></div><div class="or l"><div class="os l ot ou ov or ow kw oi"/></div></div></a></div><div class="of og fm fo oh oi"><a rel="noopener follow" target="_blank" href="/@blockchain101/solidity-bytecode-and-opcode-basics-672e9b1a88c2"><div class="oj ab ej"><div class="ok ab ol cl cj om"><h2 class="bd hu fv z el on eo ep oo er et hs dt translated">可靠性字节码和操作码基础</h2><div class="op l"><h3 class="bd b fv z el on eo ep oo er et ek translated">随着我们更深入地编写智能合同，我们会遇到诸如“PUSH1”、“SSTORE”、“CALLVALUE”等术语…</h3></div><div class="oq l"><p class="bd b gc z el on eo ep oo er et ek translated">medium.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow kw oi"/></div></div></a></div><blockquote class="oy"><p id="05f0" class="oz pa ht bd pb pc pd pe pf pg ph ke ek translated"><a class="ae ji" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="pj pk pl pm pn kr fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff pi"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>