<html>
<head>
<title>Do you even unit test Solidity code bro/sis?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你甚至单元测试可靠性代码bro/sis？</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/do-you-even-unit-test-solidity-code-bro-sis-3ae0599873c0?source=collection_archive---------6-----------------------#2018-05-30">https://medium.com/coinmonks/do-you-even-unit-test-solidity-code-bro-sis-3ae0599873c0?source=collection_archive---------6-----------------------#2018-05-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/19828a16c658817f415e2d0c1d469a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/0*-YSr2xmdJ0Wk0hYl.jpg"/></div><figcaption class="ix iy fg fe ff iz ja bd b be z ek"><a class="ae jb" href="https://memegenerator.net/instance/55088928/office-space-that-would-be-great-if-you-could-test-your-code-that-would-be-great" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="4fa0" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">在过去的几周里，我有机会在一些黑客马拉松上编写solidity代码。本着黑客马拉松的精神，我们没有编写任何单元测试。在我看来，这些黑客马拉松的目的是在有限的时间内制造出可行的产品。但是现在想想，写任何solidity代码都是相当危险的。如果以太坊主网出现问题，你就可以玩真钱了！</p><p id="c508" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">编写单元测试通常有助于确保一段代码满足其预期的功能。单元测试还可以确保这段代码不会做它不想做的事情。这两个原因在编写可靠的智能合同时非常重要。你必须确认你的代码做了你认为它做的事情，并且确认它没有做其他危险的事情。🙃</p><p id="e324" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">注意:solidity测试不同于assert()、revert()、require()，后者是solidity提供的错误处理API。这里<em class="ka"/><a class="ae jb" href="https://media.consensys.net/when-to-use-revert-assert-and-require-in-solidity-61fb2c0e5a57" rel="noopener ugc nofollow" target="_blank"><em class="ka">可以很好的解释这些是做什么用的。</em></a></p><p id="aa04" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">对我们来说幸运的是，Truffle framework的优秀人员提供了一些非常好的助手类，如果你是一个以前了解过其他语言和框架的开发人员，这些类会让solidity单元测试感觉像是应该的。两个主要类别是:</p><ol class=""><li id="0fc8" class="kb kc ht je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">truffle/Assert.sol ( <a class="ae jb" href="https://github.com/trufflesuite/truffle/blob/beta/lib/testing/Assert.sol" rel="noopener ugc nofollow" target="_blank">链接</a></li><li id="109d" class="kb kc ht je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">块菌/部署地址. sol</li></ol><p id="7369" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">Assert.sol包含您将用于单元测试的所有助手方法。例如equal()即如果两个值相等，notEqual()即如果两个值不相等，isEmpty()、isNotEmpty()、isZero()、isNotZero()、isTrue()、isFalse()、isAbove()、isAtLeast()、isBelow()、isAtMost()等。所有助手方法的完整列表可以在<a class="ae jb" href="https://github.com/trufflesuite/truffle/blob/beta/lib/testing/Assert.sol" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="11a2" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">假设我们有一个这样的合同…</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="bbc8" class="ky kz ht ku b fv la lb l lc ld">pragma solidity ^0.4.2;</span><span id="2119" class="ky kz ht ku b fv le lb l lc ld">contract SimpleStorage {</span><span id="bc85" class="ky kz ht ku b fv le lb l lc ld">uint storedData;</span><span id="9b97" class="ky kz ht ku b fv le lb l lc ld">function set(uint x) public {</span><span id="c4ba" class="ky kz ht ku b fv le lb l lc ld">  storedData = x;</span><span id="a552" class="ky kz ht ku b fv le lb l lc ld">}</span><span id="f0a3" class="ky kz ht ku b fv le lb l lc ld">function get() public view returns (uint) {</span><span id="0302" class="ky kz ht ku b fv le lb l lc ld">  return storedData;</span><span id="0bba" class="ky kz ht ku b fv le lb l lc ld">}</span><span id="ea89" class="ky kz ht ku b fv le lb l lc ld">}</span></pre><p id="5b9b" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">上面的契约有两个公共函数。我们可能会决定将这两个代码块视为两个独立的功能或彼此的补充。所以我们可能会决定对它们都使用一个单元测试。</p><p id="3832" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">有两种方法可以测试这个智能合约。使用truffle framework，你必须在solidity中编写solidity测试或者Javascript mocha测试。</p><p id="481b" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">在solidity中编写测试看起来会像这样。</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="ef13" class="ky kz ht ku b fv la lb l lc ld">pragma solidity ^0.4.2;</span><span id="e467" class="ky kz ht ku b fv le lb l lc ld">import "truffle/Assert.sol";</span><span id="0e31" class="ky kz ht ku b fv le lb l lc ld">import "truffle/DeployedAddresses.sol";</span><span id="2a3c" class="ky kz ht ku b fv le lb l lc ld">import "../contracts/SimpleStorage.sol";</span><span id="38cb" class="ky kz ht ku b fv le lb l lc ld">contract TestSimpleStorage {</span><span id="63ff" class="ky kz ht ku b fv le lb l lc ld">function testItStoresAValue() public {<br/>SimpleStorage simpleStorage = SimpleStorage(DeployedAddresses.SimpleStorage());<br/>simpleStorage.set(89);<br/>uint expected = 89;<br/>Assert.equal(simpleStorage.get(), expected, "It should store the value 89.");<br/>}</span><span id="81e6" class="ky kz ht ku b fv le lb l lc ld">}</span></pre><p id="61c2" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">这里，我们首先将两个助手类<em class="ka"> Assert.sol </em>和<em class="ka"> DeployedAddresses.sol </em>导入到这个测试契约中。然后，我们创建我们的契约，并将其命名为<em class="ka"> TestSimpleStorage </em>。请注意，我们遵循了块菌文档中描述的命名约定。所有测试合同都必须以大写的<code class="eh lf lg lh ku b">T</code>开头<code class="eh lf lg lh ku b">Test</code>。</p><p id="81fb" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">然后我们定义一个测试方法<em class="ka"> testItStoresAValue() </em>，这里我们也遵循一个命名约定，从<code class="eh lf lg lh ku b">Test</code>开始，使用小写的<code class="eh lf lg lh ku b">t</code>。在此方法中，我们使用DeployedAddresses引用来获取SimpleStorage契约的对象。然后，我们只需调用SimpleStorage契约的set方法，为契约中的变量storedData设置一个值(89)。</p><p id="285d" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">这个单元测试的目的是检查如果我们在SimpleStorage契约中用set()方法设置一个值，在我们调用get()方法时，我们应该得到相同的值。</p><p id="ab26" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated"><em class="ka"> testItStoresAValue() </em>方法的最后一行使用Assert helper类来完成这项工作。使用<em class="ka"> Assert.equal() </em>我们检查当我们调用<em class="ka"> get() </em>时得到的值是否等于我们设置的初始值89。我们测试的可靠性部分到此结束。现在让我们写一些Javascript。</p><p id="f5a7" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">另一个选择是用javascript编写智能合约测试，即使用javascript中的Mocha编写测试。</p><pre class="kp kq kr ks fq kt ku kv kw aw kx dt"><span id="2cff" class="ky kz ht ku b fv la lb l lc ld">var SimpleStorage = artifacts.require("SimpleStorage");</span><span id="783c" class="ky kz ht ku b fv le lb l lc ld">contract('SimpleStorage', function(accounts) {</span><span id="a84d" class="ky kz ht ku b fv le lb l lc ld">it("...should store the value 89.", function() {<br/>  return SimpleStorage.deployed().then(function(instance) { </span><span id="7abf" class="ky kz ht ku b fv le lb l lc ld">    simpleStorageInstance = instance;<br/>    return simpleStorageInstance.set(89, {from: accounts[0]});<br/>  }).then(function() {<br/>    return simpleStorageInstance.get.call();<br/>  }).then(function(storedData) {<br/>    assert.equal(storedData, 89, "The value 89 was not stored.");<br/>  });<br/>});</span><span id="a555" class="ky kz ht ku b fv le lb l lc ld">});</span></pre><p id="438b" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">上面很简单，我们用契约对象用89调用<em class="ka"> set() </em>方法并通过调用get方法确认89被存储。这里我们断言使用mocha的助手类。</p><p id="7331" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">这个教程的代码是<a class="ae jb" href="https://github.com/akinmail/solidity-unit-test-tutorial" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p></div></div>    
</body>
</html>