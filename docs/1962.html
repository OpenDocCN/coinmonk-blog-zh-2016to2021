<html>
<head>
<title>Advanced EOS Series — Part 5 — One-to-many Relationships</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级EOS系列—第5部分—一对多关系</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/advanced-eos-series-part-5-one-to-many-relationships-42d2e075e05d?source=collection_archive---------1-----------------------#2019-01-11">https://medium.com/coinmonks/advanced-eos-series-part-5-one-to-many-relationships-42d2e075e05d?source=collection_archive---------1-----------------------#2019-01-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/04daff84a451d3e9c9f6d2ff451fdb97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qFR_SZnTB-EEPtUP5NSnFg@2x.jpeg"/></div></div></figure><p id="021c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎回到高级EOS开发系列，在这里我将涉及到教程或课程很少涉及的高级技术和功能。本系列的目的是将您作为EOS网络上的分布式应用程序开发人员所需的技能整合在一起。每篇文章都是按照难度排序的，所以如果你想要一个总体的概述，我建议你从第一部分开始，一步步往上。这些例子的完整代码可以在GitHub 上找到<a class="ae jz" href="https://github.com/MitchPierias/Advanced-EOS-Examples/tree/master/05_Table-One-To-Many-Relationships" rel="noopener ugc nofollow" target="_blank">。</a></p><div class="ka kb fm fo kc kd"><a href="https://github.com/MitchPierias/Advanced-EOS-Examples/tree/master/05_Table-One-To-Many-Relationships" rel="noopener  ugc nofollow" target="_blank"><div class="ke ab ej"><div class="kf ab kg cl cj kh"><h2 class="bd hu fv z el ki eo ep kj er et hs dt translated">MitchPierias/高级-EOS-示例</h2><div class="kk l"><h3 class="bd b fv z el ki eo ep kj er et ek translated">一系列EOS合同开发实例。通过创建…为MitchPierias/Advanced-EOS-Examples开发做出贡献</h3></div><div class="kl l"><p class="bd b gc z el ki eo ep kj er et ek translated">github.com</p></div></div><div class="km l"><div class="kn l ko kp kq km kr iz kd"/></div></div></a></div><blockquote class="ks kt ku"><p id="9677" class="jb jc kv jd b je jf jg jh ji jj jk jl kw jn jo jp kx jr js jt ky jv jw jx jy hm dt translated">由于这些是高级或扩展的主题，我很危险地假设你已经知道了基础知识，并且正在寻求进一步的知识。出于这个原因，这些文章中共享的代码将简明扼要地达到所讨论的目的。</p></blockquote><p id="58dd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这篇文章相对来说比较短，但是涵盖了一个基本的，看起来没有涉及到的方法，多索引表，唯一的主索引。</p><h1 id="6a10" class="kz la ht bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">一对多关系</h1><p id="be31" class="pw-post-body-paragraph jb jc ht jd b je lx jg jh ji ly jk jl jm lz jo jp jq ma js jt ju mb jw jx jy hm dt translated">我来自一个有图形数据库背景的人，这是一个奇妙的地方，数据也是直接链接的，就像MySQL joins一样，但是是类固醇。因此，如果你像我一样，已经掌握了EOS表的基本知识，那么你可能会问这样一个问题，但是我如何在多个表和行之间创建关系呢？在这个例子中，我们将研究使用EOS <code class="eh mc md me mf b">multi_index</code>表创建一对多关系的多种方法，而不是一种。</p><p id="c8d2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这些例子中，我们将看看三种不同的方法来创建我们的EOS表行之间的关系；向量、索引和范围。</p><blockquote class="ks kt ku"><p id="1243" class="jb jc kv jd b je jf jg jh ji jj jk jl kw jn jo jp kx jr js jt ky jv jw jx jy hm dt translated">为了简单起见，下面的例子将不验证调用者帐户。</p></blockquote></div><div class="ab cl mg mh hb mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hm hn ho hp hq"><h1 id="3b65" class="kz la ht bd lb lc mn le lf lg mo li lj lk mp lm ln lo mq lq lr ls mr lu lv lw dt translated">向量</h1><p id="4405" class="pw-post-body-paragraph jb jc ht jd b je lx jg jh ji ly jk jl jm lz jo jp jq ma js jt ju mb jw jx jy hm dt translated"><a class="ae jz" href="http://www.cplusplus.com/reference/vector/vector/" rel="noopener ugc nofollow" target="_blank">c++中的Vectors</a>表示动态数组的结构，允许我们存储任意大小的值集合。让我们通过存储玩家<code class="eh mc md me mf b">Profile</code>的唯一<code class="eh mc md me mf b">Item</code>标识符数组来探索向量。这里，存储在<code class="eh mc md me mf b">Profile</code>表中的标识符将对应于<code class="eh mc md me mf b">Item</code>表中行的<code class="eh mc md me mf b">id</code>。</p><pre class="ms mt mu mv fq mw mf mx my aw mz dt"><span id="955f" class="na la ht mf b fv nb nc l nd ne">struct Profile {<br/>  name              account;<br/>  vector&lt;uint64_t&gt;  items;<br/>}<br/><br/>struct Item {<br/>  uint64_t          id;<br/>  string	            name;<br/>}</span></pre><p id="87ef" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，在我们的<code class="eh mc md me mf b">create()</code>方法中，我们可以简单地使用之前存储的<code class="eh mc md me mf b">Item.id</code>和vector类的<code class="eh mc md me mf b">push_back()</code>方法来推送对<code class="eh mc md me mf b">Item</code>的引用。</p><pre class="ms mt mu mv fq mw mf mx my aw mz dt"><span id="97e7" class="na la ht mf b fv nb nc l nd ne">owners.modify(currentPlayer, 0, [&amp;](auto&amp; owner) {<br/>  owner.items.push_back(itemID);<br/>});</span></pre><p id="2dd9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们甚至可以更进一步，在我们的项目向量<code class="eh mc md me mf b">vector&lt;uint64_t, uint32_t&gt; items;</code>中定义一个子集合，其中<code class="eh mc md me mf b">uint64_t</code>是我们的项目标识符，<code class="eh mc md me mf b">uint32_t</code>是项目的年龄。或者，一个二级结构(集合)可以存储在vector中，如<code class="eh mc md me mf b">vector&lt;Item&gt; items;</code>。</p><p id="299f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">向量是在我们的表中直接存储相关数据和引用的一种很好的方式，但是由于过多的用户输入或不正确的数据管理，表行可能会很快变大。让我们转而研究二级索引来创建表之间的关系。</p></div><div class="ab cl mg mh hb mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hm hn ho hp hq"><h1 id="27b0" class="kz la ht bd lb lc mn le lf lg mo li lj lk mp lm ln lo mq lq lr ls mr lu lv lw dt translated">次要索引</h1><p id="5f96" class="pw-post-body-paragraph jb jc ht jd b je lx jg jh ji ly jk jl jm lz jo jp jq ma js jt ju mb jw jx jy hm dt translated">使用二级索引提供了另一种方法，我们可以缩放引用，同时避免表行中过大的数组<em class="kv">(向量)</em>。它还允许我们通过使用从子到父的向后引用，在表中的父子行之间无缝移动。让我们从以前的Vector部分扩展我们的项目，来实际地看看这个。首先我们要修改我们的结构，从<code class="eh mc md me mf b">Profile</code>结构中移除<code class="eh mc md me mf b">items</code>向量，并在<code class="eh mc md me mf b">Item</code>结构中添加对我们所有者的引用。</p><pre class="ms mt mu mv fq mw mf mx my aw mz dt"><span id="22c4" class="na la ht mf b fv nb nc l nd ne">struct Profile {<br/>    name 	account;<br/>}<br/><br/>struct Item {<br/>    uint64_t	uid;<br/>    string	name;<br/>    name		owner;<br/>}</span></pre><p id="4cf8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们需要添加搜索功能，这样我们就可以通过<code class="eh mc md me mf b">owner</code>找到我们的<code class="eh mc md me mf b">Item</code>。让我们创建一个二级索引，并将其添加到我们的<code class="eh mc md me mf b">multi_index</code>定义中。</p><pre class="ms mt mu mv fq mw mf mx my aw mz dt"><span id="dd5f" class="na la ht mf b fv nb nc l nd ne">struct Item {<br/>    ...<br/>    uint64_t get_owner() const { return owner; }<br/>}<br/><br/>typedef multi_index&lt;N(items), Item, indexed_by&lt;N(byowner), const_mem_fun&lt;Item, uint64_t, &amp;Item::get_owner&gt;&gt; item_table;</span></pre><p id="c4f9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">其中我们的索引名将是<code class="eh mc md me mf b">byowner</code>，它将使用<code class="eh mc md me mf b">get_owner</code>函数返回<code class="eh mc md me mf b">uint64_t owner</code>键。</p><blockquote class="nf"><p id="f634" class="ng nh ht bd ni nj nk nl nm nn no jy ek translated">multi_index方法允许我们为每个表定义多达16个附加索引。</p></blockquote><p id="85b2" class="pw-post-body-paragraph jb jc ht jd b je np jg jh ji nq jk jl jm nr jo jp jq ns js jt ju nt jw jx jy hm dt translated">我们将不再从添加项目功能中更新我们的<code class="eh mc md me mf b">Player</code>。相反，我们将在新创建的项目的<code class="eh mc md me mf b">owner</code>属性中存储对签名人<code class="eh mc md me mf b">account</code>的引用。让我们更新我们的<code class="eh mc md me mf b">additem</code>行动来实现这一点；</p><pre class="ms mt mu mv fq mw mf mx my aw mz dt"><span id="7b17" class="na la ht mf b fv nb nc l nd ne">items.emplace(account, [&amp;](auto&amp; item) {<br/>    ...<br/>    item.owner = account;<br/>});</span></pre><p id="4110" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们可以像这样得到一个玩家的所有物品；</p><pre class="ms mt mu mv fq mw mf mx my aw mz dt"><span id="0c4d" class="na la ht mf b fv nb nc l nd ne">void indexes::get(const name account) {<br/>  item_table items(_self, _self);<br/>  auto accounts_items = items.get_index&lt;N(byowner)&gt;();<br/>  auto iter = accounts_items.lower_bound(account);<br/>  while (iter != accounts_items.end(); iter++) { // Do stuff }<br/>}</span></pre></div><div class="ab cl mg mh hb mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hm hn ho hp hq"><h1 id="0fc7" class="kz la ht bd lb lc mn le lf lg mo li lj lk mp lm ln lo mq lq lr ls mr lu lv lw dt translated">范围</h1><p id="03a8" class="pw-post-body-paragraph jb jc ht jd b je lx jg jh ji ly jk jl jm lz jo jp jq ma js jt ju mb jw jx jy hm dt translated">对于最后一个方法，我们将使用表范围来表示表行之间的关系。使用作用域增加了一种受保护的安全性，即只有在作用域已知的情况下才能找到数据。</p><h2 id="6898" class="na la ht bd lb nu nv nw lf nx ny nz lj jm oa ob ln jq oc od lr ju oe of lv og dt translated">EOS数据结构</h2><pre class="ms mt mu mv fq mw mf mx my aw mz dt"><span id="2717" class="na la ht mf b fv nb nc l nd ne"><em class="kv">- code       * The account name assigned write permission (contract)<br/>-- scope     * The account where the data is stored<br/>--- table    * Name of the table being stored<br/>---- record  * A table row</em></span></pre><p id="96d5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们将修改我们的<code class="eh mc md me mf b">Item</code>来利用表的范围来查找所有玩家的物品。为了简化我们的项目，我们将从我们的<code class="eh mc md me mf b">Item</code> struct和multi_index表定义中移除<code class="eh mc md me mf b">owner</code>引用和<code class="eh mc md me mf b">get_owner()</code>索引。</p><pre class="ms mt mu mv fq mw mf mx my aw mz dt"><span id="c1be" class="na la ht mf b fv nb nc l nd ne">struct Item {<br/>    uint64_t    	id;<br/>    string	name;<br/>    auto primary_key() const { return id; };<br/>    EOSLIB_SERIALIZE(Item, (id)(name));<br/>};<br/><br/>typedef multi_index&lt;N(items), Item&gt; item_table;</span></pre><p id="2f34" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">真正的魔力发生在我们的setters和getters中，让我们看看它们是如何变化的。</p><pre class="ms mt mu mv fq mw mf mx my aw mz dt"><span id="580a" class="na la ht mf b fv nb nc l nd ne">item_table items(_self, account);<br/>auto item = items.emplace(account, [&amp;](auto&amp; item) {<br/>  ... configure item<br/>});</span></pre><p id="8639" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果您查看我们的实例化表，您会注意到我们现在使用的是我们的<code class="eh mc md me mf b">account</code>的范围，而不是契约的<code class="eh mc md me mf b">code</code>本身。我们的get操作也以同样的方式进行了修改。</p><pre class="ms mt mu mv fq mw mf mx my aw mz dt"><span id="6c55" class="na la ht mf b fv nb nc l nd ne">item_table items(_self, account);<br/>auto iter = playerItems.lower_bound();<br/>while (iter != playerItems.end()) { ... }</span></pre><p id="12eb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">就这么简单！使用范围隔离数据使得查找与用户相关的数据变得更加简单，然而，像计算所有用户的所有项目这样的事情变得更加困难。选择适用于您的应用目标的方法非常重要。</p><blockquote class="nf"><p id="cda0" class="ng nh ht bd ni nj nk nl nm nn no jy ek translated"><a class="ae jz" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="oi oj ok ol om iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff oh"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>