<html>
<head>
<title>Tutorial Chaincode Unit Testing on Hyperledger Fabric</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hyperledger Fabric上的链码单元测试教程</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/tutorial-on-hyperledger-fabrics-chaincode-testing-44c3f260cb2b?source=collection_archive---------1-----------------------#2019-01-14">https://medium.com/coinmonks/tutorial-on-hyperledger-fabrics-chaincode-testing-44c3f260cb2b?source=collection_archive---------1-----------------------#2019-01-14</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="e0cd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">大家好！你正在寻找如何在Hyperledger Fabric中整合一个单元测试套件来改进链码开发吗？我在这里向您解释我是如何用golang创建测试环境的，这使我能够真正加速链代码的开发，因为这样您甚至不再需要设置开发环境(当然，如果您设计了一个好的测试套件)。</p><p id="cb4f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我是这样组织教程的:</p><ol class=""><li id="90f2" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated"><strong class="is hu"> MockStub </strong> — Shim包，为链代码提供API以访问其状态变量、事务上下文并调用其他链代码(<a class="ae jx" href="https://github.com/hyperledger/fabric/blob/release-1.4/core/chaincode/shim/mockstub.go#L29" rel="noopener ugc nofollow" target="_blank"> wiew source </a>)。</li><li id="d4f3" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw dt translated"><strong class="is hu"> Go测试</strong> —包测试为Go包的自动化测试提供支持。它旨在与“go test”命令配合使用，该命令自动执行任何功能(<a class="ae jx" href="https://golang.org/pkg/testing/" rel="noopener ugc nofollow" target="_blank">官方go文档</a>)。</li><li id="b347" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw dt translated">测试套件 —本教程的核心，我将展示我是如何实现我的测试套件的。</li></ol><h1 id="6d29" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">模拟存根</h1><p id="b618" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">如前所述，MockStub是shim包，它允许创建测试函数来直接测试链代码函数。</p><h1 id="1b45" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">去测试</h1><p id="1098" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">谢天谢地，从我们的角度来看，围棋测试非常非常简单。要运行测试套件，您只需在测试套件所在的存储库中运行命令:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="7a4a" class="lp ke ht ll b fv lq lr l ls lt">go test</span></pre><h1 id="d362" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">测试套</h1><p id="5ebc" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">要编写一个新的测试套件，创建一个名为ends _test.go的文件，其中包含TestXxx函数，在我们的例子中是<chaincode_name> _test.go</chaincode_name></p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="e7f1" class="lp ke ht ll b fv lq lr l ls lt">&lt;chaincodeName&gt;_test.go</span></pre><p id="e860" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们深入了解我是如何使用MockStub功能开发一些专门针对链代码开发的测试函数的。</p><h2 id="e30c" class="lp ke ht bd kf lu lv lw kj lx ly lz kn jb ma mb kr jf mc md kv jj me mf kz mg dt translated">测试记录器</h2><p id="3958" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">首先，我将记录器设置为打印有用的信息:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="b4bf" class="lp ke ht ll b fv lq lr l ls lt"><strong class="ll hu">var </strong>testLog = shim.NewLogger("&lt;chaincodeName&gt;_test")</span></pre><h2 id="95a4" class="lp ke ht bd kf lu lv lw kj lx ly lz kn jb ma mb kr jf mc md kv jj me mf kz mg dt translated">测试比较</h2><p id="217b" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">之后，我开发了一个由一些嵌入了比较的函数组成的小“库”,以加速实际测试的开发:</p><ul class=""><li id="4381" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn mh ju jv jw dt translated">检查状态</li><li id="b24f" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn mh ju jv jw dt translated">检查状态</li><li id="3c5d" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn mh ju jv jw dt translated">检查查询</li><li id="31a8" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn mh ju jv jw dt translated">checkBadQuery</li><li id="c07e" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn mh ju jv jw dt translated">检查调用</li><li id="63ca" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn mh ju jv jw dt translated">checkBadInvoke</li></ul><p id="a446" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将详细研究所有这些函数。</p><ul class=""><li id="bfd0" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn mh ju jv jw dt translated">检查状态:</li></ul><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="8697" class="lp ke ht ll b fv lq lr l ls lt"><strong class="ll hu">func </strong>checkState(t *testing.T, stub *shim.MockStub, name string, value string) {<br/>   bytes := stub.State[name]<br/>   <strong class="ll hu">if </strong>bytes == nil {<br/>      testLog.Info("State", name, "failed to get value")<br/>      t.FailNow()<br/>   }<br/>   <strong class="ll hu">if </strong>string(bytes) != value {<br/>      testLog.Info("State value", name, "was", string(bytes), "and not", value, "as expected")<br/>      t.FailNow()<br/>   } <strong class="ll hu">else </strong>{<br/>      testLog.Info("State value", name, "is", string(bytes), "as expected")<br/>   }<br/>}</span></pre><ul class=""><li id="538a" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn mh ju jv jw dt translated">检查状态:</li></ul><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="df29" class="lp ke ht ll b fv lq lr l ls lt"><strong class="ll hu">func </strong>checkNoState(t *testing.T, stub *shim.MockStub, name string) {<br/>   bytes := stub.State[name]<br/>   <strong class="ll hu">if </strong>bytes != nil {<br/>      testLog.Info("State", name, "should be absent; found value")<br/>      t.FailNow()<br/>   } <strong class="ll hu">else </strong>{<br/>      testLog.Info("State", name, "is absent as it should be")<br/>   }<br/>}</span></pre><ul class=""><li id="8e1b" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn mh ju jv jw dt translated">检查查询(1，2，…，n个参数):</li></ul><p id="d352" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">—对于1个参数:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="9a90" class="lp ke ht ll b fv lq lr l ls lt"><strong class="ll hu">func </strong>checkQueryOneArg(t *testing.T, stub *shim.MockStub, function string, argument string, value string) {<br/>   res := stub.MockInvoke("1", [][]byte{[]byte(function), []byte(argument)})<br/>   <strong class="ll hu">if </strong>res.Status != shim.<em class="mi">OK </em>{<br/>      testLog.Info("Query", function, "failed", string(res.Message))<br/>      t.FailNow()<br/>   }<br/>   <strong class="ll hu">if </strong>res.Payload == nil {<br/>      testLog.Info("Query", function, "failed to get value")<br/>      t.FailNow()<br/>   }<br/>   payload := string(res.Payload)<br/>   <strong class="ll hu">if </strong>payload != value {<br/>      testLog.Info("Query value", function, "was", payload, "and not", value, "as expected")<br/>      t.FailNow()<br/>   } <strong class="ll hu">else </strong>{<br/>      testLog.Info("Query value", function, "is", payload, "as expected")<br/>   }<br/>}</span></pre><p id="53a7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">—对于两个参数:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="53c0" class="lp ke ht ll b fv lq lr l ls lt"><strong class="ll hu">func </strong>checkQueryTwoArgs(t *testing.T, stub *shim.MockStub, function string, argument1 string, argument2 string, value string) {<br/>   res := stub.MockInvoke("1", [][]byte{[]byte(function), []byte(argument1), []byte(argument2)})<br/>   <strong class="ll hu">if </strong>res.Status != shim.<em class="mi">OK </em>{<br/>      testLog.Info("Query", function, "failed", string(res.Message))<br/>      t.FailNow()<br/>   }<br/>   <strong class="ll hu">if </strong>res.Payload == nil {<br/>      testLog.Info("Query", function, "failed to get value")<br/>      t.FailNow()<br/>   }<br/>   payload := string(res.Payload)<br/>   <strong class="ll hu">if </strong>payload != value {<br/>      testLog.Info("Query value", function, "was", payload, "and not", value, "as expected")<br/>      t.FailNow()<br/>   } <strong class="ll hu">else </strong>{<br/>      testLog.Info("Query value", function, "is", payload, "as expected")<br/>   }<br/>}</span></pre><p id="f8c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们可以注意到，差别仅仅在于函数调用中参数的数量，所以我们可以很容易地推广到n…</p><ul class=""><li id="46e9" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn mh ju jv jw dt translated">checkBadQuery:</li></ul><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="6449" class="lp ke ht ll b fv lq lr l ls lt"><strong class="ll hu">func </strong>checkBadQuery(t *testing.T, stub *shim.MockStub, function string, name string) {<br/>   res := stub.MockInvoke("1", [][]byte{[]byte(function), []byte(name)})<br/>   <strong class="ll hu">if </strong>res.Status == shim.<em class="mi">OK </em>{<br/>      testLog.Info("Query", function, "unexpectedly succeeded")<br/>      t.FailNow()<br/>   } <strong class="ll hu">else </strong>{<br/>      testLog.Info("Query", function, "failed as espected, with message: ", res.Message)<br/><br/>   }<br/>}</span></pre><ul class=""><li id="658c" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn mh ju jv jw dt translated">checkInvoke:</li></ul><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="8aea" class="lp ke ht ll b fv lq lr l ls lt"><strong class="ll hu">func </strong>checkInvoke(t *testing.T, stub *shim.MockStub, functionAndArgs []string) {<br/>   functionAndArgsAsBytes := lib.ParseStringSliceToByteSlice(functionAndArgs)<br/>   res := stub.MockInvoke("1", functionAndArgsAsBytes)<br/>   <strong class="ll hu">if </strong>res.Status != shim.<em class="mi">OK </em>{<br/>      testLog.Info("Invoke", functionAndArgs, "failed", string(res.Message))<br/>      t.FailNow()<br/>   } <strong class="ll hu">else </strong>{<br/>      testLog.Info("Invoke", functionAndArgs, "successful", string(res.Message))<br/>   }<br/>}</span></pre><ul class=""><li id="86c4" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn mh ju jv jw dt translated">checkBadInvoke:</li></ul><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="4d43" class="lp ke ht ll b fv lq lr l ls lt"><strong class="ll hu">func </strong>checkBadInvoke(t *testing.T, stub *shim.MockStub, functionAndArgs []string) {<br/>   functionAndArgsAsBytes := lib.ParseStringSliceToByteSlice(functionAndArgs)<br/>   res := stub.MockInvoke("1", functionAndArgsAsBytes)<br/>   <strong class="ll hu">if </strong>res.Status == shim.<em class="mi">OK </em>{<br/>      testLog.Info("Invoke", functionAndArgs, "unexpectedly succeeded")<br/>      t.FailNow()<br/>   } <strong class="ll hu">else </strong>{<br/>      testLog.Info("Invoke", functionAndArgs, "failed as espected, with message: "+res.Message)<br/>   }<br/>}</span></pre><h2 id="7d64" class="lp ke ht bd kf lu lv lw kj lx ly lz kn jb ma mb kr jf mc md kv jj me mf kz mg dt translated">测试链码函数(示例)</h2><p id="17f9" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">现在，让我们继续对chaincode的功能进行真正的测试，例如，让我们以chaincode的一般“CreateFeature”功能为例:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="78b5" class="lp ke ht ll b fv lq lr l ls lt">//==================================================================<br/>// TestFeatureCreation - Test the 'CreateFeature' function<br/>// =================================================================<br/><strong class="ll hu">func </strong>TestFeatureCreation(t *testing.T) {<br/>   simpleChaincode := new(SimpleChaincode)<br/>   simpleChaincode.testMode = <em class="mi">true<br/>   </em>mockStub := shim.NewMockStub("Test Feature Creation", simpleChaincode)<br/><br/>   <strong class="ll hu">var </strong>functionAndArgs []string<br/>   functionName := <em class="mi">CreateFeature<br/><br/>   </em>// Invoke 'CreateFeature'<br/>   featureId := <em class="mi">NewFeatureId<br/>   </em>featureName := <em class="mi">NewFeatureName<br/><br/>   </em>args := []string{featureId, featureName}<br/>   functionAndArgs = append(functionAndArgs, functionName)<br/>   functionAndArgs = append(functionAndArgs, args...)<br/><br/>   checkInvoke(t, mockStub, functionAndArgs)<br/><br/>   feature := &amp;a.Feature{FeatureId: featureId, Name: featureName}<br/>   featureAsBytes, _ := json.Marshal(feature)<br/><br/>   checkState(t, mockStub, featureId, string(featureAsBytes))<br/><br/>   expectedResponse := "{\"FeatureId\":\"" + featureId + "\",\"Name\":\"" + featureName + "\",\"FeatureComposition\":null}"</span><span id="05fe" class="lp ke ht ll b fv mj lr l ls lt">   checkQueryOneArg(t, mockStub, "GetFeature", featureId, expectedResponse)<br/>}</span></pre><p id="84e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们在这个测试函数中检查两件事:</p><ul class=""><li id="33d5" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn mh ju jv jw dt translated">Invoke —直接调用checkInvoke，向其传递function和Args。</li><li id="8a2a" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn mh ju jv jw dt translated">查询—我们调用“GetFeature ”,并放置我们期望的响应JSON字符串。</li></ul><p id="a623" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果一切顺利，我们将看到嵌入日志的输出，并以:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="b112" class="lp ke ht ll b fv lq lr l ls lt">- - - PASS: TestFeatureCreation (0.00s)</span></pre><p id="faa2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果一切顺利的话。</p><p id="b24d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">或者是:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="e8a4" class="lp ke ht ll b fv lq lr l ls lt">- - - FAIL: TestFeatureCreation (0.00s)</span></pre><p id="3ebd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果有什么与我们的期望不同。在这种情况下，如果我们正确地设置日志，我们可以看到失败的来源，同样:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="4447" class="lp ke ht ll b fv lq lr l ls lt">2019–01–14 15:48:26.198 CET [innMind_test] Info -&gt; INFO 013 Query value GetFeatureNotFoundError was {“FeatureId”:”idfeature1",”Name”:”Color"} and not {“FeatureId”:”idfeature1",”Name”:”Shape"} as expected</span></pre><p id="f817" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们可以很容易地发现，预期的特征的名称是“形状”，但我们得到的是“颜色”。</p><p id="1f17" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，我展示了如何看一个测试套件:</p><figure class="lg lh li lj fq ml fe ff paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="fe ff mk"><img src="../Images/f87633cf42dd53bef627fcc3c9c9ae31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Fn8wbGpygQEvSUi6Fq00g.png"/></div></div></figure><p id="ab36" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您也认为可以利用Init函数用您需要的所有数据填充测试分类帐来模拟您脑海中的任何场景，那么您就可以很容易地理解这是如何加速开发的。我们将在另一篇文章中讨论如何初始化分类帐。</p><p id="ef58" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我希望这篇教程给了你一个开始测试你的链码的简单介绍！如果是，不要犹豫，给我一个响亮的掌声！；)</p><p id="db7d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">再见！</p><p id="cc22" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">— <em class="mi">瓦莱里奥</em></p><blockquote class="ms"><p id="4e3e" class="mt mu ht bd mv mw mx my mz na nb jn ek translated"><a class="ae jx" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="nd ne nf ng nh ml fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nc"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>