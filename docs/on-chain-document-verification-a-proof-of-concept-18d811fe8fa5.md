# 链上文件验证；概念证明。

> 原文：<https://medium.com/coinmonks/on-chain-document-verification-a-proof-of-concept-18d811fe8fa5?source=collection_archive---------4----------------------->

> 区块链不保证真理；它们保护真理和谎言不被日后篡改。—尼克·萨伯

因为区块链是一个分散的和不可变的分类账，它有可能提供文件欺诈预防。

例如，文凭和证书可能是一个很好的用例——潜在雇主只需查询区块链，然后在出示此类文件后验证其真实性。学生可以将这些文档放在一个所谓的数字文件夹中，终生携带，存储在一个不能关闭的数据库中，并且没有停机时间。

在区块链上，存储的不是文档本身，而是加密哈希。这不仅符合 GDPR 准则并保护文件持有者/所有者的隐私，而且还保证了防水验证；如果有人篡改文凭或证书，就会产生不同的加密哈希，与存储在区块链上的哈希不一致。

一旦文档被提交到区块链，它可能只是实现上述承诺。但是，我们如何防止一个坏演员提交一份欺诈性的文件呢？是的，我们可以让公证人来验证文件，但是……公证人是一个现实世界中的实体，可能是中央集权的，这样我们就摆脱了区块链的不信任本质。我们不能相信外链中介。

理想情况下，我们需要通过一种分散的、对不良行为者有弹性的一致算法来验证链上的文档。这种共识模式的参与者是所谓的先知，他们因说真话而获得经济上的奖励(因说谎而受到经济上的惩罚)。

智能合约的象征性经济学是对先知参与的激励，共识算法的[囚徒困境](https://en.wikipedia.org/wiki/Prisoner%27s_dilemma)是防止他们做出恶劣行为的原因(例如，在他们被要求验证的文件的真实性上撒谎)。验证链上文档的真实性是很重要的，因为一旦我们离开链并进入现实世界，我们就失去了区块链的不可信任的本质。

请注意，本文并没有为您提供可以插入到项目中的现成的智能合约。本文仅仅是链上文档验证背后的一个后勤练习，以伪代码的形式呈现给你。话虽如此，我们还是开始吧。

## 智能合同# 1；管理神谕

在其最基本的形式中，Oracle 只是一个(公钥)地址和一些关于 Oracle 的元数据，比如名称或头衔。契约#1 包含(公钥)地址到结构的映射，后者保存元数据(以及余额，稍后将详细介绍)。

```
**struct** Oracle {
  string  **public**  name;
  uint256 **private** balance;
}**mapping** (address => Oracle) **public** oracles;
```

合同#1 的管理员(可能是将合同部署到区块链的地址)能够向合同添加或删除 Oracles。如果其他任何人试图修改 Oracles，就会抛出一个异常，事务被恢复。

神谕本身需要向这个契约支付 X 量的 ETH，才能参与共识算法。这个重要的先决条件是，如果先知对文件的真实性撒谎，共识算法就可以惩罚他或她。

至于可见性，我们认为公众可见性没有任何问题。这允许第三方审计 Oracles。

## 智能合同# 2；上传文档

该合同允许文档的持有者/所有者将其上传到区块链。然后，文档存储在一个字节数组中。

```
**enum** Vote { None, Valid, Invalid }**struct** Document {
  bytes[] data;
  uint256 balance;
  uint256 timestamp;
  uint256 voteCount;
  **mapping** (address => Vote) votes
}**mapping** (address => Document) **private** documents
```

请注意，这些字节的可见性只对先知是禁止的。除了神谕之外，任何人都不允许查询这份合同中的文件。

契约#2 的构造者采用了契约#1 的地址，在此拒绝除神谕之外的任何人…

1.  查询已上传的文档，以及
2.  参与共识算法。

上传功能(允许持有者/所有者上传文件)是所谓的**应付款**。这允许共识算法在共识期结束时支付先知们的贡献。

```
**function** upload(bytes[] _bytes) **public** **payable** {
  ...
}
```

持有人/所有者需要为他/她的提交支付最低 ETH 金额(否则，将引发异常)。如果持有人/所有人决定支付高于最低金额的金额，那么他/她的文件很可能会更快获得批准。

文档上传后会发出一个事件，通知 Oracles。请注意，我们至少需要 3 个 Oracles，并且它们都需要为契约#1 贡献至少 X 个 ETH，否则将引发异常，事务将被恢复。

本质上，共识算法是这样工作的；我们至少需要 3 个神谕(越多越好)，在我们达成共识之前，我们需要至少 51%的神谕给合同#2 相同的答案。一旦达成共识，合同#2 将…

1.  计算文档字节的加密哈希，以及
2.  将加密散列存储在智能契约#3 中(稍后将详细介绍)

请注意，上面的场景假设 51%的先知认为文档是有效的。如果他们决定文档不是真实的，则没有加密散列被提交给契约#3。

我们将合同#2 中的字节保留 1 周。这应该给先知们足够的机会来参与共识算法。1 周后，合同#2 将…

1.  将文件持有人/所有人支付给合同#2 的 ETH 金额支付给按照一致结果回答的先知，除以先知的数量，以及
2.  惩罚那些确实参与了但其答案不符合共识结果的先知，以及
3.  将上传到合同#2 的字节清零

请注意，上传到合同#2 的字节在 1 周后总是被清零，不管是否达成共识。

我们如何跟踪文档 1 周的生命周期，以及我们何时确定文档是否过期？坚固性不包括计时器吧？这是一个好问题。虽然共识算法本身是由 Oracle 参与触发的(例如，回答关于上传真实性的合同#2)，但对合同#2 来说，最好的事情是持有人/所有者上传文档。换句话说:每次有人上传一个文档到契约#2，后者然后枚举所有其他文档，然后将过期的文档清零。

事件已发出…

1.  在文件已上传至合同#2 后，特此通知先知，以及
2.  一旦达成共识，特此通知文件持有人/所有人，以及
3.  一旦文件过期，特此通知先知。如果此时未达成共识，则该事件还会通知文档的持有者/所有者。

> 除了上面的字节数组，我们可以将文档上传到 [Swarm](https://swarm-guide.readthedocs.io) ，然后向 Oracles 提供 Swarm 中内容的十六进制地址字符串，供他们下载。但是为了这篇文章的缘故，我们暂时把事情放在智能合约中。

## 智能合同# 3；无限期存储指纹

一旦达成共识，就计算文档的加密散列，然后存储在契约#3 中

```
**mapping** (bytes32 => address) **public** hashes 
```

不言而喻，虽然散列对每个人都是公开的，但只有契约#2 被允许将新散列推送到契约#3。

智能合同#3 允许任何 dApp 验证…

1.  文档是否可信(否则，散列就不会存在于契约#3 中)，以及
2.  该文档是否属于提交该文档的人的(公钥)地址

*本文由*[*Ceciel van Helden*](https://www.linkedin.com/in/ceciel-van-helden-61b96619)*合著，V-ID* *首席程序员。*

> [直接在您的收件箱中获得最佳软件交易](https://coincodecap.com/?utm_source=coinmonks)

[![](img/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png)](https://coincodecap.com/?utm_source=coinmonks)