<html>
<head>
<title>End-to-End Formal Verification of Ethereum 2.0 Deposit Smart Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊2.0存款智能合约的端到端形式化验证</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/end-to-end-formal-verification-of-ethereum-2-0-deposit-smart-contract-7ebf13fa46ad?source=collection_archive---------1-----------------------#2020-01-20">https://medium.com/coinmonks/end-to-end-formal-verification-of-ethereum-2-0-deposit-smart-contract-7ebf13fa46ad?source=collection_archive---------1-----------------------#2020-01-20</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="a09f" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">在Daejun公园旁边</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/e45289d2a03a84626bff2cb8f3660e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_tddD_cVoqqWjqj8.png"/></div></div></figure><p id="9b14" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们在<a class="ae kq" href="https://runtimeverification.com/" rel="noopener ugc nofollow" target="_blank">运行时验证</a>，很高兴<a class="ae kq" href="https://github.com/runtimeverification/verified-smart-contracts/blob/master/deposit/deposit-formal-verification.pdf" rel="noopener ugc nofollow" target="_blank">向</a>报告我们成功完成了<a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/blob/v0.10.0/deposit_contract/contracts/validator_registration.vy" rel="noopener ugc nofollow" target="_blank">以太坊2.0存款合同</a>的正式验证，这可以说是以太坊社区今年部署的最重要的智能合同之一。</p><blockquote class="kr"><p id="8f3a" class="ks kt ht bd ku kv kw kx ky kz la kp ek translated"><a class="ae kq" href="https://coincodecap.com/category/smart-contract" rel="noopener ugc nofollow" target="_blank">发现并评估最佳智能合约安全软件</a></p></blockquote><h1 id="3019" class="lb lc ht bd ld le lf lg lh li lj lk ll iz lm ja ln jc lo jd lp jf lq jg lr ls dt translated">存款合同</h1><p id="aa5d" class="pw-post-body-paragraph ju jv ht jw b jx lt iu jz ka lu ix kc kd lv kf kg kh lw kj kk kl lx kn ko kp hm dt translated">押金合同是加入<a class="ae kq" href="https://github.com/ethereum/eth2.0-specs" rel="noopener ugc nofollow" target="_blank">以太坊2.0 </a>的入口。要成为驱动以太坊2.0的整个利益证明(PoS)链(称为<a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/blob/dev/specs/phase0/beacon-chain.md" rel="noopener ugc nofollow" target="_blank">信标链</a>)的验证者，您需要通过向存款合同发送交易(通过以太坊1.x网络)来存款一定量的以太作为“利益”。押金契约记录了押金的历史，锁定了以太坊1.x链的所有押金，以后可以在以太坊2.0的信标链认领。注意，在以太坊2.0的一个早期阶段，押金契约是单向函数；你可以把你的资金从以太坊1.x转移到以太坊2.0，但不能反过来。</p><p id="fffb" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">用<a class="ae kq" href="https://vyper.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> Vyper </a>编写的存款合同采用<a class="ae kq" href="https://en.wikipedia.org/wiki/Merkle_tree" rel="noopener ugc nofollow" target="_blank"> Merkle树</a>数据结构来有效地存储存款历史，其中每当接收到新的存款时，该树就被动态地<em class="ly">更新(即，从左到右递增地填充叶节点)。这里，契约中使用的Merkle树非常大——契约中实现了一个高度为32的Merkle树，它可以存储多达<code class="eh lz ma mb mc b">2^32</code>个存款。由于Merkle树的大小是巨大的，所以每次接收到新的存放时重建整个树是不实际的。</em></p><p id="5ba7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">为了降低时间和空间的复杂性，从而显著节省天然气成本，合同实施了<a class="ae kq" href="https://github.com/ethereum/research/blob/master/beacon_chain_impl/progressive_merkle_tree.py" rel="noopener ugc nofollow" target="_blank">增量Merkle树算法</a>。增量算法享受<code class="eh lz ma mb mc b">O(h)</code>时间和空间复杂性来重建(更准确地说，计算根)高度<code class="eh lz ma mb mc b">h</code>的Merkle树，而简单算法将需要<code class="eh lz ma mb mc b">O(2^h)</code>时间或空间复杂性。</p><p id="d49e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">然而，有效的增量算法导致存款合同实现不直观，并使得确保其正确性变得不容易。然而，存款合同的正确性对于以太坊2.0的安全性至关重要。考虑到存款合同的极端重要性，需要进行正式验证，这是最终保证其正确性的唯一已知方法。</p><h1 id="3950" class="lb lc ht bd ld le lf lg lh li lj lk ll iz md ja ln jc me jd lp jf mf jg lr ls dt translated">范围和方法</h1><p id="f50b" class="pw-post-body-paragraph ju jv ht jw b jx lt iu jz ka lu ix kc kd lv kf kg kh lw kj kk kl lx kn ko kp hm dt translated">我们正式验证约定的范围是确保单个事务中存款合同<em class="ly">字节码</em>的正确性，而不考虑事务级或链外行为。我们将编译后的字节码作为验证目标，以避免信任编译器。(的确，我们在形式验证的过程中发现了Vyper编译器的几个关键性bug。我们将在本帖后面解释更多关于我们发现的细节。)</p><p id="6b43" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在方法上，我们采用了著名的基于精化的验证方法。我们的验证工作包括以下两项任务:</p><p id="dca4" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">直观地说，第一个任务相当于确保契约源代码的正确性，而第二个任务相当于确保编译后的字节码是源代码的合理细化(即编译器的<a class="ae kq" href="https://link.springer.com/chapter/10.1007/BFb0054170" rel="noopener ugc nofollow" target="_blank">翻译验证</a>)。这种基于精化的方法允许我们避免对复杂的算法细节进行推理，尤其是直接在字节码级别指定和验证循环不变量。这种关注点的分离帮助我们节省了大量的验证工作。</p><p id="99ed" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在<a class="ae kq" href="https://runtimeverification.com/blog/formal-verification-of-ethereum-2-0-deposit-contract-part-1/" rel="noopener ugc nofollow" target="_blank">之前的博文</a>中，我们介绍了任务1，简单介绍了存款合同和增量Merkle树算法。在本帖中，我们将关注任务2。</p><p id="df2e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><em class="ly">查看我们的</em> <a class="ae kq" href="https://github.com/runtimeverification/verified-smart-contracts/blob/master/deposit/deposit-formal-verification.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="ly">最终报告</em> </a> <em class="ly">了解存款合同正式验证的全部细节。</em></p><h1 id="f471" class="lb lc ht bd ld le lf lg lh li lj lk ll iz md ja ln jc me jd lp jf mf jg lr ls dt translated">存款合同的字节码验证</h1><p id="a19c" class="pw-post-body-paragraph ju jv ht jw b jx lt iu jz ka lu ix kc kd lv kf kg kh lw kj kk kl lx kn ko kp hm dt translated">我们验证了存款合同的已编译字节码的功能正确性。对于每个公共函数，我们验证了它的返回值和存储状态更新(如果有的话)是正确的。</p><p id="d155" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">此外，我们仔细指定并验证了它的字节操作行为。它包括:</p><ul class=""><li id="df8a" class="mg mh ht jw b jx jy ka kb kd mi kh mj kl mk kp ml mm mn mo dt translated">根据<a class="ae kq" href="https://solidity.readthedocs.io/en/v0.6.1/abi-spec.html" rel="noopener ugc nofollow" target="_blank">协定ABI规范</a>，返回值被正确序列化为字节序列，</li><li id="64c8" class="mg mh ht jw b jx mp ka mq kd mr kh ms kl mt kp ml mm mn mo dt translated">为32字节对齐更正零填充，</li><li id="e19f" class="mg mh ht jw b jx mp ka mq kd mr kh ms kl mt kp ml mm mn mo dt translated">从大端到小端的正确转换，</li><li id="c049" class="mg mh ht jw b jx mp ka mq kd mr kh ms kl mt kp ml mm mn mo dt translated">根据<a class="ae kq" href="https://solidity.readthedocs.io/en/v0.6.1/abi-spec.html#events" rel="noopener ugc nofollow" target="_blank">合同事件ABI规范</a>对事件日志数据进行正确编码，</li><li id="0f73" class="mg mh ht jw b jx mp ka mq kd mr kh ms kl mt kp ml mm mn mo dt translated">正确构造SHA2–256哈希函数的输入字节，以及</li><li id="96c9" class="mg mh ht jw b jx mp ka mq kd mr kh ms kl mt kp ml mm mn mo dt translated">根据<a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/tree/dev/ssz" rel="noopener ugc nofollow" target="_blank"> SimpleSerialize (SSZ)规范</a>正确计算存款数据哈希(称为Merkleization)。</li></ul><p id="0339" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们还验证了活性性质，即只要提供足够量的气体，契约总是能够接受新的(有效的)存款。这种活跃度不是微不足道的，因为它需要保持，即使在任何未来的硬分叉，其中天然气费用计划被改变。事实上，我们发现了Vyper编译器的一个错误，它可能会使存款合同在未来的某个硬分叉中不起作用，在这种情况下，无论供应了多少气体，合同都会由于气体耗尽异常而失败。(我们将在这篇文章的后面回到这个问题。)</p><p id="e9fc" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们验证了积极和消极的行为。积极行为描述了合法输入状态下契约的期望行为。另一方面，负面行为描述了契约如何处理异常情况(例如，当良性用户错误地提供无效输入，或者恶意用户提供精心制作的输入以利用契约时)。负面行为大多与安全属性有关。</p><p id="8dfd" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">存款合同的已验证字节码行为的完整规范可以在<a class="ae kq" href="https://github.com/runtimeverification/verified-smart-contracts/blob/master/deposit/bytecode-verification/deposit-spec.ini.md" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="8e59" class="lb lc ht bd ld le lf lg lh li lj lk ll iz md ja ln jc me jd lp jf mf jg lr ls dt translated">调查的结果</h1><p id="4bd5" class="pw-post-body-paragraph ju jv ht jw b jx lt iu jz ka lu ix kc kd lv kf kg kh lw kj kk kl lx kn ko kp hm dt translated">在我们正式验证工作的过程中，我们发现了存款合同的细微bug(问题<a class="ae kq" href="https://github.com/ethereum/deposit_contract/issues/26" rel="noopener ugc nofollow" target="_blank"> 26 </a>、<a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/issues/1341" rel="noopener ugc nofollow" target="_blank"> 1341 </a>和<a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/issues/1357" rel="noopener ugc nofollow" target="_blank"> 1357 </a>),这些bug已经在<a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/blob/v0.10.0/deposit_contract/contracts/validator_registration.vy" rel="noopener ugc nofollow" target="_blank">最新版本</a>中修复，以及一些重构建议(问题<a class="ae kq" href="https://github.com/ethereum/deposit_contract/issues/27" rel="noopener ugc nofollow" target="_blank"> 27 </a>、<a class="ae kq" href="https://github.com/ethereum/deposit_contract/issues/28" rel="noopener ugc nofollow" target="_blank"> 28 </a>和<a class="ae kq" href="https://github.com/ethereum/deposit_contract/issues/38" rel="noopener ugc nofollow" target="_blank"> 38 </a>)可以提高代码可读性并降低gas成本。定金合同的细微漏洞部分是由于我们在验证过程中发现的Vyper编译器的另一个隐藏漏洞(Vyper Issues <a class="ae kq" href="https://github.com/vyperlang/vyper/issues/1563" rel="noopener ugc nofollow" target="_blank"> 1563 </a>、<a class="ae kq" href="https://github.com/vyperlang/vyper/issues/1599" rel="noopener ugc nofollow" target="_blank"> 1599 </a>、<a class="ae kq" href="https://github.com/vyperlang/vyper/issues/1610" rel="noopener ugc nofollow" target="_blank"> 1610 </a>和<a class="ae kq" href="https://github.com/vyperlang/vyper/issues/1761" rel="noopener ugc nofollow" target="_blank"> 1761 </a>)。</p><p id="f99c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">下面我们详细阐述一下我们发现的bug。我们注意到，在最新版本(<a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/blob/v0.10.0/deposit_contract/contracts/validator_registration.vy" rel="noopener ugc nofollow" target="_blank"> v0.10.0 </a>)中，定金合同的所有bug都已被报告、确认并得到妥善修复。</p><h2 id="6fed" class="mu lc ht bd ld mv mw mx lh my mz na ll kd nb nc ln kh nd ne lp kl nf ng lr nh dt translated"><code class="eh lz ma mb mc b">get_deposit_count()</code>功能的ABI标准符合性</h2><p id="a07d" class="pw-post-body-paragraph ju jv ht jw b jx lt iu jz ka lu ix kc kd lv kf kg kh lw kj kk kl lx kn ko kp hm dt translated">在之前版本的存款合同中，<code class="eh lz ma mb mc b">get_deposit_count()</code>函数不符合<a class="ae kq" href="https://solidity.readthedocs.io/en/v0.6.1/abi-spec.html" rel="noopener ugc nofollow" target="_blank"> ABI标准</a>，由于Vyper编译器<a class="ae kq" href="https://github.com/vyperlang/vyper/issues/1563" rel="noopener ugc nofollow" target="_blank">错误</a>，其返回值包含不正确的零填充。</p><p id="1afb" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">具体来说，在错误版本的编译字节码中，<code class="eh lz ma mb mc b">get_deposit_count()</code>函数(其返回类型为<code class="eh lz ma mb mc b">bytes[8]</code>)返回以下96个字节(以十六进制表示法):</p><pre class="jj jk jl jm fq ni mc nj nk aw nl dt"><span id="75fb" class="mu lc ht mc b fv nm nn l no np">0x0000000000000000000000000000000000000000000000000000000000000020 0000000000000000000000000000000000000000000000000000000000000008 deadbeefdeadbeef000000000000000000000000000000000000000000000020 ^^</span></pre><p id="e620" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">其中:</p><ul class=""><li id="50d4" class="mg mh ht jw b jx jy ka kb kd mi kh mj kl mk kp ml mm mn mo dt translated">前32个字节(第一行)表示字节数组的偏移量(32 = <code class="eh lz ma mb mc b">0x20</code>),</li><li id="eaf0" class="mg mh ht jw b jx mp ka mq kd mr kh ms kl mt kp ml mm mn mo dt translated">第二个32字节(在第二行)表示字节数组的大小(8 = <code class="eh lz ma mb mc b">0x8</code>)，以及</li><li id="13fa" class="mg mh ht jw b jx mp ka mq kd mr kh ms kl mt kp ml mm mn mo dt translated">接下来的8个字节“<code class="eh lz ma mb mc b">deadbeefdeadbeef</code>”(在第三行的开头)表示返回字节数组(类型<code class="eh lz ma mb mc b">bytes[8]</code>)的实际内容，即存放计数的(little-endian)字节表示。</li></ul><p id="2d1b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这里的问题是最后一个字节(用<code class="eh lz ma mb mc b">^^</code>标记)是<code class="eh lz ma mb mc b">0x20</code>，而它应该是<code class="eh lz ma mb mc b">0x00</code>。根据<a class="ae kq" href="https://solidity.readthedocs.io/en/v0.6.1/abi-spec.html" rel="noopener ugc nofollow" target="_blank"> ABI规范</a>，最后24个字节必须全为零，作为32字节对齐的零填充。因此，上面的返回值不符合ABI标准，这是有问题的，因为任何调用存款契约(的错误版本)并期望<code class="eh lz ma mb mc b">get_deposit_count()</code>函数符合ABI标准的契约(用Solidity或Vyper编写)都可能行为不检。</p><p id="f0aa" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这种错误行为主要是由于一个微妙的Vyper编译器<a class="ae kq" href="https://github.com/vyperlang/vyper/issues/1563" rel="noopener ugc nofollow" target="_blank">错误</a>未能正确编译其返回类型为<code class="eh lz ma mb mc b">bytes[n]</code>的函数，其中<code class="eh lz ma mb mc b">n</code>小于16，这导致编译后的函数返回不符合ABI标准的错误字节序列，如上图所示补零不足。</p><p id="14a3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们注意到，如果我们不把字节码作为验证目标，这个bug就不会被发现。这再次证实了字节码级验证对于确保最终的正确性是至关重要的(除非我们正式验证底层编译器)，因为我们不能(也不应该)信任编译器。</p><h2 id="a116" class="mu lc ht bd ld mv mw mx lh my mz na ll kd nb nc ln kh nd ne lp kl nf ng lr nh dt translated">检查呼叫数据的格式是否正确</h2><p id="fdcb" class="pw-post-body-paragraph ju jv ht jw b jx lt iu jz ka lu ix kc kd lv kf kg kh lw kj kk kl lx kn ko kp hm dt translated">先前版本的已编译字节码中的calldata解码过程没有对calldata的格式良好性进行足够的运行时检查。因此，它无法检测某些格式不正确的调用数据，导致无效的存款数据被放入Merkle树中。这是有问题的，尤其是当客户犯了错误，并且用不正确编码的呼叫数据发送存款交易时，这可能导致损失他们的存款资金。</p><p id="65fa" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">例如，考虑以下用于<code class="eh lz ma mb mc b">deposit()</code>函数的格式错误的calldata(十六进制表示法):</p><pre class="jj jk jl jm fq ni mc nj nk aw nl dt"><span id="4a42" class="mu lc ht mc b fv nm nn l no np">0xc47e300d 0000000000000000000000000000000000000000000000000000000000000060 0000000000000000000000000000000000000000000000000000000000000080 00000000000000000000000000000000000000000000000000000000000000a0 0000000000000000000000000000000000000000000000000000000000000030 0000000000000000000000000000000000000000000000000000000000000020 0000000000000000000000000000000000000000000000000000000000000060</span></pre><p id="8398" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">前四个字节(在第一行)表示<code class="eh lz ma mb mc b">deposit()</code>函数的签名散列，剩余的字节对应于三个参数的元组，<code class="eh lz ma mb mc b">pubkey</code>、<code class="eh lz ma mb mc b">withdrawal_credentials</code>和<code class="eh lz ma mb mc b">signature</code>。然而，这个呼叫数据显然是病态的，因此是无效的，原因很简单，因为其大小(196字节)比有效呼叫数据的大小(356字节)小得多。</p><p id="c99d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">但问题是，<code class="eh lz ma mb mc b">deposit()</code>函数并没有<em class="ly">而不是</em>拒绝上面的病态calldata，只是简单地在Merkle树中插入了某些无效(垃圾)存放数据。由于后来无效的存款数据无法通过签名验证，因此没有人可以主张与此相关联的存款资金，存款所有者失去了该资金。</p><p id="b2fc" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">注意，即使<code class="eh lz ma mb mc b">deposit()</code>函数在函数的开头包含以下长度检查断言，这种情况也会发生，这很不直观:</p><pre class="jj jk jl jm fq ni mc nj nk aw nl dt"><span id="2edb" class="mu lc ht mc b fv nm nn l no np">assert len(pubkey) == PUBKEY_LENGTH assert len(withdrawal_credentials) == WITHDRAWAL_CREDENTIALS_LENGTH assert len(signature) == SIGNATURE_LENGTH</span></pre><p id="2d09" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果Vyper编译器彻底生成运行时检查以确保calldata的格式良好，就不会存在这个问题。然而，由于修复编译器以生成这样的运行时检查并不容易，我们建议了几种方法来改进存放契约，以防止这种行为，而无需修复编译器。在与存款合同开发团队仔细讨论后，我们一起决定采用基于校验和的方法，其中<code class="eh lz ma mb mc b">deposit()</code>函数将存款数据的校验和作为附加输入，并使用校验和拒绝任何格式不正确的调用数据。在所有建议的修复方法中，基于校验和的方法是非侵入性最强的，也是最节能的。(其他建议修复的更多细节可以在<a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/issues/1357" rel="noopener ugc nofollow" target="_blank">这里</a>找到。)</p><p id="7d6f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们注意到这个问题是在我们核实存款合同的负面行为时发现的。这表明了正式规范不仅包括积极行为，还包括消极行为的重要性。</p><h2 id="ef9e" class="mu lc ht bd ld mv mw mx lh my mz na ll kd nb nc ln kh nd ne lp kl nf ng lr nh dt translated">活性</h2><p id="688d" class="pw-post-body-paragraph ju jv ht jw b jx lt iu jz ka lu ix kc kd lv kf kg kh lw kj kk kl lx kn ko kp hm dt translated">先前版本的存款合约未能满足liveness属性，因为其可能无法在更新汽油费时间表的某个未来硬叉中接受新存款(即使其有效)。这主要是由于另一个微妙的Vyper编译器<a class="ae kq" href="https://github.com/vyperlang/vyper/issues/1761" rel="noopener ugc nofollow" target="_blank"> bug </a>生成字节码，当调用某些预编译合约时，会提供一定量的硬编码气体。尽管这种硬编码的天然气量在当前的硬分叉(代号为<a class="ae kq" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1679.md" rel="noopener ugc nofollow" target="_blank">伊斯坦堡</a>)中是足够的，但在将来的某个硬分叉中，增加预编译合约的天然气费用计划可能是不够的。在这样一个未来的硬叉，漏洞版本的存款合同将始终失败，由于用完天然气的例外，无论有多少天然气是最初供应。此问题已在最新版本中修复。</p><p id="9ef6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们承认，直到存款合同开发团队仔细审阅并与我们讨论了字节码的<a class="ae kq" href="https://github.com/runtimeverification/verified-smart-contracts/blob/master/deposit/bytecode-verification/deposit-spec.ini.md" rel="noopener ugc nofollow" target="_blank">正式规范</a>之后，我们才发现此问题。最初，我们只考虑了当前硬分叉中字节码的行为，而没有确定契约字节码应该在任何未来的硬分叉中工作的要求。我们确定了缺失的需求，并在正式验证过程的非常晚的阶段发现了这个活跃度问题。正因为如此，我们没有足够的时间来遵循修复编译器引入的错误的标准过程，也就是说，等待下一个修复错误的编译器版本，使用新的编译器版本重新生成字节码，以及重新验证新生成的字节码。为了加快这个过程，我们要求Vyper编译器团队发布一个自定义修复程序版本(名称为<a class="ae kq" href="https://github.com/vyperlang/vyper/commits/1761-HOTFIX-v0.1.0-beta.13" rel="noopener ugc nofollow" target="_blank">1761-fix-v 0 . 1 . 0-beta . 13</a>，以最大限度地缩短等待bugfix发布的时间。使用自定义修复程序版本还可以最大限度地减少重新验证新生成的字节码的时间，因为以前的字节码和新生成的字节码之间的差异变得很小，只涉及用于修复错误的更改。</p><p id="1acc" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这个轶事般的经验本质上说明了开发人员的预期行为(通常只是非正式地存在)和验证工程师编写的正式规范之间的差距所导致的众所周知的问题。为了缩小这种差距，这两个组应该紧密合作，或者理想情况下，他们应该在同一个团队中。对于前者，正式的验证过程应该更频繁地涉及开发人员。对于后者，形式验证工具应该变得更容易使用，而不需要形式方法的高级知识。</p><h1 id="06d4" class="lb lc ht bd ld le lf lg lh li lj lk ll iz md ja ln jc me jd lp jf mf jg lr ls dt translated">结论</h1><p id="c729" class="pw-post-body-paragraph ju jv ht jw b jx lt iu jz ka lu ix kc kd lv kf kg kh lw kj kk kl lx kn ko kp hm dt translated">在完成以太坊2.0存款合同的端到端正式验证后，我们得出结论，最新的存款合同字节码是正确的，更准确地说，它将按照<a class="ae kq" href="https://github.com/runtimeverification/verified-smart-contracts/blob/master/deposit/bytecode-verification/deposit-spec.ini.md" rel="noopener ugc nofollow" target="_blank">正式规范</a>中指定的方式运行。</p><p id="bd87" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们采用基于精化的验证方法来确保契约的端到端正确性，同时最小化验证工作。具体来说，我们首先证明增量Merkle树算法在契约中是正确实现的，然后验证编译后的字节码是从源代码正确生成的。</p><p id="1212" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">虽然我们在正式验证过程中发现了存款合同的几个关键问题，其中一些是由于Vyper编译器隐藏的细微错误，但存款合同的所有问题都已在由Vyper编译器版本<a class="ae kq" href="https://github.com/vyperlang/vyper/commits/1761-HOTFIX-v0.1.0-beta.13" rel="noopener ugc nofollow" target="_blank">1761-hot fix-v 0 . 1 . 0-beta . 13</a>编译的存款合同最新版本(<a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/blob/v0.10.0/deposit_contract/contracts/validator_registration.vy" rel="noopener ugc nofollow" target="_blank"> v0.10.0 </a>)中得到妥善修复。</p><p id="4b65" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们注意到，这个正式验证结果是在不信任Vyper编译器的情况下建立的，这意味着即使Vyper编译器有<a class="ae kq" href="https://diligence.consensys.net/audits/2019/10/vyper/" rel="noopener ugc nofollow" target="_blank">错误</a>，正式验证的字节码也是正确的。事实上，Vyper编译器已经得到了足够的改进，可以从存款合同中生成正确的字节码。换句话说，当生成我们正式验证的特定字节码时，剩余的Vyper编译器错误(如果有的话)还没有被<em class="ly">触发。所以，你不需要担心<a class="ae kq" href="https://blog.ethereum.org/2020/01/08/update-on-the-vyper-compiler/" rel="noopener ugc nofollow" target="_blank">所有的</a><a class="ae kq" href="https://twitter.com/vyperlang/status/1215299130081402880" rel="noopener ugc nofollow" target="_blank"/><a class="ae kq" href="https://cointelegraph.com/news/bugs-found-in-compiler-for-readable-ethereum-smart-contracts-team-downplays-concerns" rel="noopener ugc nofollow" target="_blank"/><a class="ae kq" href="https://twitter.com/MartinLundfall/status/1215344893616381953" rel="noopener ugc nofollow" target="_blank">关于Vyper编译器的担忧</a>，关于存款合同的安全性。</em></p><h1 id="f513" class="lb lc ht bd ld le lf lg lh li lj lk ll iz md ja ln jc me jd lp jf mf jg lr ls dt translated">感谢</h1><p id="10a4" class="pw-post-body-paragraph ju jv ht jw b jx lt iu jz ka lu ix kc kd lv kf kg kh lw kj kk kl lx kn ko kp hm dt translated">我们要衷心感谢以太坊基金会<a class="ae kq" href="https://blog.ethereum.org/2019/05/21/ethereum-foundation-spring-2019-update/" rel="noopener ugc nofollow" target="_blank">资助</a>这一努力，以及<a class="ae kq" href="https://github.com/djrtwo" rel="noopener ugc nofollow" target="_blank">丹尼·瑞安</a>、<a class="ae kq" href="https://github.com/CarlBeek" rel="noopener ugc nofollow" target="_blank">卡尔·比肯</a>、<a class="ae kq" href="https://github.com/JustinDrake" rel="noopener ugc nofollow" target="_blank">贾斯汀·德雷克</a>、<a class="ae kq" href="https://github.com/MrChico" rel="noopener ugc nofollow" target="_blank">马丁·伦德福</a>、<a class="ae kq" href="https://github.com/NIC619" rel="noopener ugc nofollow" target="_blank">林暐</a>、<a class="ae kq" href="https://github.com/hwwhww" rel="noopener ugc nofollow" target="_blank">肖-王巍</a>、<a class="ae kq" href="https://github.com/fubuloubu" rel="noopener ugc nofollow" target="_blank">布莱恩特·艾森巴赫</a>、<a class="ae kq" href="https://github.com/jacqueswww" rel="noopener ugc nofollow" target="_blank">雅克·瓦格纳</a>、<a class="ae kq" href="https://github.com/charles-cooper" rel="noopener ugc nofollow" target="_blank">查尔斯·库珀</a></p><blockquote class="kr"><p id="e772" class="ks kt ht bd ku kv kw kx ky kz la kp ek translated"><a class="ae kq" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nr ns nt nu nv jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nq"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div><div class="ab cl nw nx hb ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="hm hn ho hp hq"><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff od"><img src="../Images/a06b758bdcc47dca7c2504f298674d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_s6JsD3P0hVj32E7t9EtGg.jpeg"/></div></a><figcaption class="oe of fg fe ff og oh bd b be z ek">Coinmonks</figcaption></figure></div></div>    
</body>
</html>