<html>
<head>
<title>Express uPort as javascript — Set IPFS hash to Registry Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将uPort表示为javascript —将IPFS哈希设置为注册管理机构合同</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/express-uport-as-javascript-set-ipfs-hash-to-registry-contract-600c2dbf8404?source=collection_archive---------1-----------------------#2018-10-12">https://medium.com/coinmonks/express-uport-as-javascript-set-ipfs-hash-to-registry-contract-600c2dbf8404?source=collection_archive---------1-----------------------#2018-10-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="5cff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">uPort是著名的以太坊项目。在我看来，uPort是区块链最成功的自我主权身份平台。所以我觉得了解它的策略对我们的事业是有帮助的。</p><p id="07ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我将uPort契约和IPFS或其他对象表示为javascript。然后我模拟如何工作。老实说，我不确定我的理解是否正确，尽管我尽可能地注意到了准确性，参考了<a class="ae jo" href="http://blockchainlab.com/pdf/uPort_whitepaper_DRAFT20161020.pdf" rel="noopener ugc nofollow" target="_blank">白皮书</a>和<a class="ae jo" href="https://github.com/uport-project/uport-identity" rel="noopener ugc nofollow" target="_blank"> Github </a>和<a class="ae jo" href="https://developer.uport.me/gettingstarted" rel="noopener ugc nofollow" target="_blank">官方文件</a>。请检查文件以获得准确的信息。</p><p id="c559" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这一次，我将重点介绍如何创建代理契约或IPFS哈希，并将哈希设置为注册中心契约。</p><p id="34dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Github上的代码:<a class="ae jo" href="https://github.com/tak1827/uport-contract-js/tree/set-ipfs-hash-to-registry" rel="noopener ugc nofollow" target="_blank"> uport-contract-js </a></p><p id="ea2e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下一篇文章:<a class="ae jo" rel="noopener" href="/@t.tak/express-uport-as-javascript-relay-transaction-to-3rd-party-dapp-12fd226acc2f">将uPort表示为JavaScript——将事务转发给第三方Dapp </a></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/b16b0ab3471b386ab92ded4c2164a0ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8uhvUxWZA70_ABs8VT9uQ.png"/></div></div></figure></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h2 id="a32b" class="ki kj ht bd kk kl km kn ko kp kq kr ks jb kt ku kv jf kw kx ky jj kz la lb lc dt translated">分成6个步骤</h2><p id="0694" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hm dt translated">我把整个过程分成6个步骤。</p><ol class=""><li id="b2e4" class="li lj ht is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq dt translated"><em class="lr">创建用户对象。</em></li><li id="9400" class="li lj ht is b it ls ix lt jb lu jf lv jj lw jn ln lo lp lq dt translated"><em class="lr">创建代理作为身份</em></li><li id="b720" class="li lj ht is b it ls ix lt jb lu jf lv jj lw jn ln lo lp lq dt translated"><em class="lr">生成JWT </em></li><li id="28b6" class="li lj ht is b it ls ix lt jb lu jf lv jj lw jn ln lo lp lq dt translated"><em class="lr">增加IPFS认证</em></li><li id="5d7e" class="li lj ht is b it ls ix lt jb lu jf lv jj lw jn ln lo lp lq dt translated"><em class="lr">注册IPFS哈希到UportRegistry合同</em></li><li id="dfb9" class="li lj ht is b it ls ix lt jb lu jf lv jj lw jn ln lo lp lq dt translated">由第三方验证JWT</li></ol></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h2 id="a8d4" class="ki kj ht bd kk kl km kn ko kp kq kr ks jb kt ku kv jf kw kx ky jj kz la lb lc dt translated"><em class="lx"> 1。创建用户对象。</em></h2><p id="2360" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hm dt translated">首先，我创建由我定义的用户对象(不是uPort)。用户对象持有代理对象和JWT私钥和主题(JWT的标识)。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="c373" class="ki kj ht lz b fv md me l mf mg">// User object hold proxy object and jwt private key<br/>let user = new User("Christian Lundkvist");</span></pre></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h2 id="ac83" class="ki kj ht bd kk kl km kn ko kp kq kr ks jb kt ku kv jf kw kx ky jj kz la lb lc dt translated"><em class="lx"> 2。创建代理身份</em></h2><p id="d778" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hm dt translated">代理是uPort上的身份契约。每个人都有一份代理合同。代理由名为IdentityManager的控制器合同创建。用户向此合同发送交易。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="0d75" class="ki kj ht lz b fv md me l mf mg">user.run(function() {</span><span id="7984" class="ki kj ht lz b fv mh me l mf mg">  // Proxy contract is deployed by IdentityManager<br/>  this.proxy = IM.createIdentity(this.address);<br/>});</span></pre><p id="f589" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在IdentityManager内部，生成了代理协定。请注意，代理生成的事务发送方(msg.sender)是IdentityManager，因此代理的所有者是IdentityManager。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="9490" class="ki kj ht lz b fv md me l mf mg">createIdentity(owner) {<br/>  setSender(this.address);// Set sender as IdentityManager</span><span id="0baf" class="ki kj ht lz b fv mh me l mf mg">  // Generate Proxy contract<br/>  const identity = new Proxy();</span><span id="e0f8" class="ki kj ht lz b fv mh me l mf mg">  this.owners[identity.address] = {<br/>    [owner]: (new Date()).getTime() - this.timeLock<br/>  }</span><span id="c142" class="ki kj ht lz b fv mh me l mf mg">  return identity;<br/>}</span></pre></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h2 id="8246" class="ki kj ht bd kk kl km kn ko kp kq kr ks jb kt ku kv jf kw kx ky jj kz la lb lc dt translated">3.生成JWT</h2><p id="6c89" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hm dt translated">JWT(Json Web Token)通常像OpenID一样用作身份认证。uPort使用JWT实现离线验证。</p><p id="c482" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从一开始，我定义JWT格式如下。这种格式与白皮书略有不同。首先，我将属性名如“Subject”改为“sub ”,因为<a class="ae jo" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> JWT RFC </a>定义为so以减少令牌大小。第二，为了简化，我更改了有效载荷中的内容。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="853d" class="ki kj ht lz b fv md me l mf mg">{<br/>  header: {<br/>    "alg": "ES256",<br/>    "typ": "JWT"<br/>  },<br/>  payload: {<br/>    attribute: {<br/>      name: user name,<br/>      identifier: IdenttityManager address<br/>    },<br/>    sub: Unique subject of this token,<br/>    iss: Proxy address,<br/>    exp: Expire datetime,<br/>    iat: Issued datetime<br/>  }<br/>  signature: Signature<br/>}</span></pre><p id="c822" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">转到生成过程。首先，用户定义唯一主题来区分创建的令牌。然后，使用上述格式创建有效载荷。接下来，用户生成私钥来签名JWT。请注意，我们需要使用ECDSA的‘secp 256 r 1’曲线，而不是‘secp 256k 1’。我已经在<a class="ae jo" rel="noopener" href="/coinmonks/can-not-use-secp256k1-which-is-common-on-crypto-currency-to-create-jwt-d6685be35a66">的另一篇博文</a>中提到过。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="ece3" class="ki kj ht lz b fv md me l mf mg">// Define unique subject<br/>user.subjects.push('First-JWT');</span><span id="ff45" class="ki kj ht lz b fv mh me l mf mg">const payload = buildPayload(<br/>  { name: user.name, identifier: IM.address }, <br/>  user.subjects[0], <br/>  user.proxy.address,<br/>);</span><span id="eb33" class="ki kj ht lz b fv mh me l mf mg">// Generate private key to sign JWT<br/>user.jwtKey = generatePrivateKey();</span><span id="c3e0" class="ki kj ht lz b fv mh me l mf mg">const token = sign(payload, user.jwtKey);</span></pre></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h2 id="7702" class="ki kj ht bd kk kl km kn ko kp kq kr ks jb kt ku kv jf kw kx ky jj kz la lb lc dt translated">4.向IPFS添加证明</h2><p id="72fc" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hm dt translated">认证包含JWT和公钥，重要的是，认证托管在IPFS上，任何人都可以通过互联网访问。第三方验证JWT从证明中检索公钥。</p><p id="428f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">证明的格式如下。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="ff61" class="ki kj ht lz b fv md me l mf mg">{<br/>  token: JWT,<br/>  data: {<br/>    header: Header<br/>    payload: Payload<br/>    signature: Signature<br/>  },<br/>  encrypted: false,<br/>  publicKey: Public key corresponding to signature<br/>}</span></pre><p id="d614" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">继续添加流程。首先，创建压缩的公钥，并按照上述格式构建证明。然后，将它添加到IPFS对象中。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="3e1c" class="ki kj ht lz b fv md me l mf mg">// Include pubkey to assertion for signature verification<br/>const pubkey = getCompressedPubkey(user.jwtKey);</span><span id="5434" class="ki kj ht lz b fv mh me l mf mg">// Build attestation. <br/>const attestation = buildAttestation(token, pubkey);</span><span id="8ce9" class="ki kj ht lz b fv mh me l mf mg">// Add to IPFS<br/>const hash = IS.add( JSON.stringify(attestation) );</span></pre></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h2 id="654f" class="ki kj ht bd kk kl km kn ko kp kq kr ks jb kt ku kv jf kw kx ky jj kz la lb lc dt translated">5.将IPFS哈希注册到UportRegistry合同</h2><p id="e966" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hm dt translated">UportRegistry是一个契约，它被用作存储IPFS哈希的注册表。第三方访问该合同并获得与JWT有效载荷对应的散列。请注意，用户不直接注册，而是通过IdentityManager注册。此外，IdentityManger将事务转发给用户的代理，以便最终的msg.sender是代理。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="ac9e" class="ki kj ht lz b fv md me l mf mg">user.run(function() {</span><span id="4d9f" class="ki kj ht lz b fv mh me l mf mg">  // IdentityManager delegate registration to Proxy<br/>  // Proxy register hash to UportRegistry<br/>  IM.forwardTo(<br/>    this.proxy, <br/>    'UportRegistry',<br/>    'set',<br/>    { <br/>      identifier: IM.address,<br/>      subject: user.subjects[0],<br/>      value: hash<br/>    }<br/>  );<br/>});</span><span id="8392" class="ki kj ht lz b fv mh me l mf mg">forwardTo(identity, className, methodName, data) {<br/>  this.onlyOwner(identity);</span><span id="4cda" class="ki kj ht lz b fv mh me l mf mg">  setSender(this.address);// Set sender as IdentityManager</span><span id="cc71" class="ki kj ht lz b fv mh me l mf mg">  // Forward to proxy<br/>  identity.forward(className, methodName, data);<br/>}</span></pre><p id="7135" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在代理契约内部的forward函数中，我将类名和函数名定义为参数，以区分应该运行哪个函数。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="2965" class="ki kj ht lz b fv md me l mf mg">forward(className, methodName, data) {<br/>  this.onlyOwner();</span><span id="f5d2" class="ki kj ht lz b fv mh me l mf mg">  setSender(this.address);// Set sender as Proxy</span><span id="f99a" class="ki kj ht lz b fv mh me l mf mg">  Assert(this.executeCall(className, functionName, data));<br/>}</span><span id="4160" class="ki kj ht lz b fv mh me l mf mg">executeCall(className, functionName, data) {</span><span id="a5d7" class="ki kj ht lz b fv mh me l mf mg">  if (className =='UportRegistry' &amp;&amp; functionName =='set') {<br/>    const { identifier, subject, value } = data;</span><span id="287d" class="ki kj ht lz b fv mh me l mf mg">    // Set IPFS hash to UportRegistry    <br/>    UR.set(identifier, subject, value);</span><span id="5b2d" class="ki kj ht lz b fv mh me l mf mg">  } else if (className =='UportRegistry' &amp;&amp; functionName =='get') {<br/>    const { identifier, issur, subject } = data;</span><span id="1afc" class="ki kj ht lz b fv mh me l mf mg">    // Get IPFS hash from UportRegistry    <br/>    UR.get(identifier, issur, subject);<br/>  }</span><span id="6e25" class="ki kj ht lz b fv mh me l mf mg">  return true;<br/>}</span></pre><p id="cb35" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，调用UportRegistry契约的Set函数。请注意，IPFS散列像这样存储在注册表中。</p><p id="0ed7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh mi mj mk lz b">registry[IdentigyManager.address][Proxy.address][Subject]</code></p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="84f0" class="ki kj ht lz b fv md me l mf mg">set(identifier, subject, value){</span><span id="4c0d" class="ki kj ht lz b fv mh me l mf mg">  if (typeof this.registry[identifier] =="undefined" ) {<br/>    this.registry[identifier] = {};<br/>  }<br/>  <br/>  if (typeof this.registry[identifier][msg.sender] =="undefined" ) {<br/>    this.registry[identifier][msg.sender] = {}<br/>  }</span><span id="5db8" class="ki kj ht lz b fv mh me l mf mg">  this.registry[identifier][msg.sender][subject] = value;<br/>}</span></pre></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h2 id="ae08" class="ki kj ht bd kk kl km kn ko kp kq kr ks jb kt ku kv jf kw kx ky jj kz la lb lc dt translated">6.由第三方验证JWT</h2><p id="c97f" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hm dt translated">让我解释一下如何验证第三方使用JWT。首先，第三方解码JWT并检索有效载荷。然后，获取相应的哈希。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="36cb" class="ki kj ht lz b fv md me l mf mg">// Decode token, then retrieve payload<br/>const decodedPayload = JSON.parse( decodeBase64(token.split(".")[1]) );</span><span id="fd69" class="ki kj ht lz b fv mh me l mf mg">// Get IPFS hash from UportRegistry<br/>const ipfsHash = UR.get(<br/>  decodedPayload.attribute.identifier,<br/>  decodedPayload.iss,<br/>  decodedPayload.sub<br/>);</span></pre><p id="c88f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，从IPFS获得公钥。现在第三方可以证实JWT。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="9d3e" class="ki kj ht lz b fv md me l mf mg">// Get attestation from IPFS<br/>const ipfsAtt = IS.cat(ipfsHash);</span><span id="3918" class="ki kj ht lz b fv mh me l mf mg">// Retrieve compressed public key form attestation<br/>const compressedPubkey = JSON.parse(ipfsAtt).publicKey;</span><span id="1d14" class="ki kj ht lz b fv mh me l mf mg">// Retrieve public key<br/>const ipfsPubkey = getPubkeyFromCompressedPubkey(compressedPubkey);</span><span id="09ea" class="ki kj ht lz b fv mh me l mf mg">// Verify token using public key which is hosted by IPFS<br/>verify(token, ipfsPubkey);</span></pre><blockquote class="ml"><p id="7a48" class="mm mn ht bd mo mp mq mr ms mt mu jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="mw mx my mz na ju fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mv"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>