<html>
<head>
<title>Web3.py: From Ganache to Infura</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web3.py:从加纳切到因弗拉</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/web3-py-from-ganache-to-infura-3c16aadb0a0?source=collection_archive---------1-----------------------#2021-04-03">https://medium.com/coinmonks/web3-py-from-ganache-to-infura-3c16aadb0a0?source=collection_archive---------1-----------------------#2021-04-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/6acabc86994dceac54db5d346bb8001a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EUjcggDt2unms_p6"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Photo by <a class="ae ig" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shahadat Rahman</a> on <a class="ae ig" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="f029" class="pw-subtitle-paragraph jg ii ij bd b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ek translated">你可以在这里找到这个教程的完整代码</h2></div><p id="7e0a" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">Ganache非常适合开发和测试目的，但是任何严肃的项目最终都需要转移到testnet中进行进一步的测试。在本文中，我将介绍我需要对代码进行的更改，以便使用像Infura这样的托管节点在Ropsten testnet上部署我的智能契约并与之交互。</p><p id="e682" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">您不一定需要使用Infura在testnet上部署智能契约。有些人选择运行他们自己的节点，我想象从Ganache到本地节点的过渡会非常顺利，唯一的代码变化是web3提供者。不幸的是，运行本地节点需要大量的存储、计算和带宽，因此不是每个人都愿意这样做。所以对大多数人来说，唯一的选择是使用像Infura这样的托管节点。然而，使用Infura需要对我们的代码进行一些修改。</p><p id="f538" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">为了说明这些变化，让我们从一个非常简单的智能契约开始，它只存储一个数字，并允许任何人更改它。契约还将发出一个事件，通知侦听器数字已经更改。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="181b" class="ld le ij kz b fv lf lg l lh li">contract darkPool {<br/>  uint public num;</span><span id="ec5c" class="ld le ij kz b fv lj lg l lh li">  event chage(uint number);</span><span id="28df" class="ld le ij kz b fv lj lg l lh li">  function set(uint _num) external {<br/>    num = _num;<br/>    emit change(num);<br/>  }<br/>}</span></pre><p id="e98c" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">接下来，我们将看到在使用托管节点时部署契约、发送事务和监听事件所需的更改。</p><p id="3346" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">我们代码中的第一个变化应该是web3提供者。使用Ganache时，我们通常会看到这样的内容:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="a1a8" class="ld le ij kz b fv lf lg l lh li">w3 = Web3(HTTPProvider("<a class="ae ig" href="http://127.0.0.1:8545" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8545</a>"))</span></pre><p id="c505" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">使用Infura并没有太大的不同，我们只需要为我们的项目提供Infura端点，它可以在Infura的项目设置下找到，对于Ropsten testnet应该是这样的:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="ba81" class="ld le ij kz b fv lf lg l lh li">w3 = Web3(HTTPProvider("https://ropsten.infura.io/v3/&lt;PROJECT ID&gt;"</span></pre><p id="187b" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">我们需要做出的下一个改变是我们部署合同的方式。使用Ganache，我们只需调用构造函数:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="d8ed" class="ld le ij kz b fv lf lg l lh li">tx_hash = contract.constructor().transact()</span></pre><p id="5769" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">使用托管节点，我们不能这样做，因为节点不为我们管理密钥，所以我们需要做更多的工作。我们首先需要构建提供如下参数的事务，然后使用我们的私钥对其进行签名，最后将其发送到节点:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="d5b4" class="ld le ij kz b fv lf lg l lh li"># build transaction<br/>build_tx = contract.constructor().buildTransaction({<br/>    'from': ...,<br/>    'nonce': ...,<br/>    'gas': ...,<br/>    'gasPrice': ...<br/>})<br/>private_key = ...<br/># sign transaction<br/>sign_tx = w3.eth.account.signTransaction(build_tx, private_key)<br/># send the transaction<br/>tx_hash = w3.eth.sendRawTransaction(sign_tx.rawTransaction)</span></pre><p id="fa06" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">在本地执行函数(即调用)保持不变，因此对于Ganache和Infura来说，获取存储在我们的契约中的当前数字是相同的:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="4b95" class="ld le ij kz b fv lf lg l lh li">num = contract.functions.num().call()</span></pre><p id="02fc" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">另一方面，通过发送事务来执行函数又是不同的(正如我们在契约构造函数中看到的)。使用Ganache，我们简单地写:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="1bac" class="ld le ij kz b fv lf lg l lh li">tx_hash = contract.functions.set(num).transact()</span></pre><p id="7190" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">要使用Infura在testnet上运行同样的事情，我们可以执行以下操作:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="492a" class="ld le ij kz b fv lf lg l lh li">num = ...<br/># build transaction<br/>build_tx = contract.functions.set(num).buildTransaction({<br/>    'from': ...,<br/>    'nonce': ...,<br/>    'gas': ...,<br/>    'gasPrice': ...<br/>})<br/># sign transaction<br/>sign_tx = w3.eth.account.signTransaction(build_tx, private_key)<br/># send the transaction<br/>tx_hash = w3.eth.sendRawTransaction(sign_tx.rawTransaction)</span></pre><p id="0bf2" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">最后，当使用本地节点时，我们可以创建事件过滤器，然后获取所有发布的事件。使用Ganache，我们可以执行以下操作:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="ff26" class="ld le ij kz b fv lf lg l lh li">filter = contract.events.change.createFilter(fromBlock="latest")</span><span id="28a1" class="ld le ij kz b fv lj lg l lh li">...</span><span id="67f3" class="ld le ij kz b fv lj lg l lh li">changes = filter.get_new_entries()</span></pre><p id="ac50" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">另一方面，我们与Infura的连接是无状态的，所以我们不能这样做。另一个可行的方法是:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="febd" class="ld le ij kz b fv lf lg l lh li">start = ... # the block from which to start getting logs<br/>changes = contract.events.change.getLogs(fromBlock=start)</span></pre><p id="336f" class="pw-post-body-paragraph jy jz ij ka b kb kc jk kd ke kf jn kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">第一次尝试在testnet上测试智能合约时，我花了一些时间试图弄清楚如何让我的代码工作。希望这篇文章(以及附带的代码)能帮您省去这个麻烦！</p></div></div>    
</body>
</html>