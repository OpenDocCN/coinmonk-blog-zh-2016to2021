<html>
<head>
<title>How Robots Follow Routes? — — PID Control</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器人是如何遵循路线的？— — PID控制</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-robots-follow-routes-pid-control-2a74226c5c99?source=collection_archive---------3-----------------------#2018-07-04">https://medium.com/coinmonks/how-robots-follow-routes-pid-control-2a74226c5c99?source=collection_archive---------3-----------------------#2018-07-04</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="c74c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">PID控制器代表<strong class="is hu">比例-积分-微分</strong>控制器，看起来很可怜，但如果你深入了解，实际上很容易理解。三个字母的PID实际上是三个独立的技术，而不是一个复杂的想法。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/aa2db117132c12a05146f35faec353b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PVQp4NT3HMz58WZX.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Graph of PID controller from Wikipedia</figcaption></figure><p id="44ac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">想象一下，我们有一辆自动驾驶汽车在路上行驶，我们肯定不希望我们的汽车在预定义的路径上漂移。这就是PID控制器的由来，用于自动转向。</p><h2 id="3293" class="ke kf ht bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky dt translated">交叉跟踪误差</h2><p id="3ce1" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">第一个问题是我们如何测量当前位置和我们预先定义的路线之间的差异。跨轨道误差(CTE或XTE)是一个简单的误差函数做这个把戏。它只是测量从一个位置到路径的距离。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff le"><img src="../Images/fb85387f6cce2da79edc0bd57c47766a.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/0*Yb7FI4eFQMqWm8V4"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Cross track error from <a class="ae lf" href="https://github.com/UWARG/PICpilot/wiki/Path-Management" rel="noopener ugc nofollow" target="_blank">PICpilot</a>.</figcaption></figure><p id="c3db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，我们将通过使用PID控制来尽量减小误差。</p><h2 id="18aa" class="ke kf ht bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky dt translated">p比例的</h2><p id="8a96" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">比例控制是一种简单的技术，根据CTE按比例操纵机器人。如果我们远离基线，我们的车辆会转向那里。与此同时，如果我们离我们的底线不远，情况会发生微妙的变化。有道理，对吧？</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff lg"><img src="../Images/f1d76555a69692f96045868439d49d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*nHfjyuhxWxqHA5br5KUXQQ.png"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Image from Udacity <a class="ae lf" href="https://classroom.udacity.com/courses/cs373/" rel="noopener ugc nofollow" target="_blank">Robotics</a>.</figcaption></figure><p id="d1e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是可行的，但是如果我们仔细考虑这个问题，我们的赛车基本上是在我们的基线附近摆动。看起来我们的司机喝醉了。这绝对是一种危险的行为。还有，在那辆车上你可能会有点晕船:)</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff lh"><img src="../Images/1a71ed0ca486418458cb82136a4a3a53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s3aHcJw58pojjrcXFv7jyw.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Image from Udacity <a class="ae lf" href="https://classroom.udacity.com/courses/cs373/" rel="noopener ugc nofollow" target="_blank">Robotics</a>.</figcaption></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff li"><img src="../Images/2cc344c7dc21189f3ad1850957f18aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*-Xi_orEAH3XCYpeApPj0FQ.png"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Equation for P. Kp is a parameter that decides how much degree of the proportion we gonna take. e(t) is the CTE.</figcaption></figure><h2 id="5b2a" class="ke kf ht bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky dt translated">d-导数</h2><p id="f6df" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">因此，我们希望减少振荡的影响。这就是为什么我们引入第二个控制器，导数控制。在这里，我们将考虑我们是如何转向的，来缓和这个斜坡。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff lj"><img src="../Images/cf7df86271c5cf7bae6dc4d3987fad04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kp0FJxj0TgSYq_uGiX2bKg.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Image from Udacity <a class="ae lf" href="https://classroom.udacity.com/courses/cs373/" rel="noopener ugc nofollow" target="_blank">Robotics</a>.</figcaption></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff lk"><img src="../Images/f7fa50ffc4d2536a932fff260eb58fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*LLRGDjDSUP7F3tKLFwX4aQ.png"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Equation for D. Kd is the parameter to decide how much derivative will be taken. That derivative is the CTE change along time. Say we measure it every 1s, we can take the derivative as (CTEt — CTEt-1)/1</figcaption></figure><p id="40f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">等等，看起来PD控制足够转向了。但是，是吗？让我们看看下面的场景。我们的自动驾驶汽车有一些机械问题，当它启动时，前轮有点像下面这样漂移。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff ll"><img src="../Images/43222dceaa5f563a569db381e0723fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6LSlTGcdPMAfuEUR7WI8g.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Image from Udacity <a class="ae lf" href="https://classroom.udacity.com/courses/cs373/" rel="noopener ugc nofollow" target="_blank">Robotics</a>.</figcaption></figure><p id="e61d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，当它运行时，我们的软件不知道这个问题，因为在这个时候，我们应该更多地转向以纠正车轮。因此，我们将看到以下结果。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff lm"><img src="../Images/71fbbdb81ef4324b51d811a9ffd0b58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AWY_JKL5mm63fKembd_qCA.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Image from Udacity <a class="ae lf" href="https://classroom.udacity.com/courses/cs373/" rel="noopener ugc nofollow" target="_blank">Robotics</a>.</figcaption></figure><h2 id="18a5" class="ke kf ht bd kg kh ki kj kk kl km kn ko jb kp kq kr jf ks kt ku jj kv kw kx ky dt translated">I积分</h2><p id="7a99" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">为了解决这个问题，我们将加入积分，让机器人思考整个过程。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/c401cf69563ee380ecd34edf71f388d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*dHry65AGt7jZ_ech17tpfg.png"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Ki is the parameter to decide the how much integral will be taken.</figcaption></figure><p id="b94a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果CTE误差不降低，机器人将考虑整个情况，因为积分将变大以进行更多的转向。</p><h1 id="489e" class="lo kf ht bd kg lp lq lr kk ls lt lu ko lv lw lx kr ly lz ma ku mb mc md kx me dt translated">最佳化</h1><p id="6897" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">如果你注意到了，所有这些PID方程都有自己的参数K，它决定了要取多少比例。PID优化有很多算法。接下来，让我们看看如何使用名为“旋转”的优化算法来更新参数。它有一个简单的逻辑。</p><p id="196c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在做任何事情之前，我们应该知道要优化什么。这显然是关于CTE的。此外，CTE可以是正的也可以是负的。因此，我们可以使用平方误差函数:</p><pre class="jp jq jr js fq mf mg mh mi aw mj dt"><span id="7d08" class="ke kf ht mg b fv mk ml l mm mn">def err(p):<br/>    # to calculate all the CTEs accordingly<br/>    cte, diff_cte, int_cte = calculate_cte(CURRENT_STATUS)<br/>    <!-- -->steer = -params[0]*cte - params[1]*diff_cte - params[2]*int_cte</span></pre><p id="1a77" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，我们将做一些初始化。</p><pre class="jp jq jr js fq mf mg mh mi aw mj dt"><span id="ef0f" class="ke kf ht mg b fv mk ml l mm mn"># Choose an initialization parameter vector<br/>p = [0, 0, 0]<br/># Define potential changes<br/>dp = [1, 1, 1]<br/># We can give a very large error in the begining<br/>best_err = 9999999999<br/># To stop optimizing<br/>threshold = 0.001</span></pre><p id="9d36" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">那么主要的算法是:</p><pre class="jp jq jr js fq mf mg mh mi aw mj dt"><span id="c2e7" class="ke kf ht mg b fv mk ml l mm mn">while sum(dp) &gt; threshold:<br/>    for i in range(len(p)):<br/>        p[i] += dp[i]<br/>        err = error(p)<br/><br/>        if err &lt; best_err:   # There was some improvement<br/>            best_err = err<br/>            dp[i] *= 1.1<br/>        else:                # There was no improvement<br/>            p[i] -= 2*dp[i]  # Go into the other direction<br/>            err = error(p)<br/>            # To see the outcome on this direction.<br/>            if err &lt; best_err:  # There was an improvement<br/>                best_err = err<br/>                dp[i] *= 1.05<br/>            else:               # There was no improvement<br/>                p[i] += dp[i]<br/>                # As there was no improvement, the step size in either<br/>                # direction, the step size might simply be too big.<br/>                dp[i] *= 0.95</span></pre><p id="6210" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">实际上，这个算法做简单的行为。去搜索正确的部分，不起作用？它会尝试另一边，最后工作？然后我们会有一个新的基准点，它会在新的基准点周围搜索。</p><p id="5bb1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">到目前为止，这是关于PID控制器和旋转优化器的一切。</p></div></div>    
</body>
</html>