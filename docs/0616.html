<html>
<head>
<title>Pure Attributes or Implementing Functional Smart Contracts From The Scratch at Home</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纯属性或在家从头开始实现功能性智能合约</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/pure-attributes-or-implementing-functional-smart-contracts-from-the-scratch-at-home-82202fb976fe?source=collection_archive---------1-----------------------#2018-05-25">https://medium.com/coinmonks/pure-attributes-or-implementing-functional-smart-contracts-from-the-scratch-at-home-82202fb976fe?source=collection_archive---------1-----------------------#2018-05-25</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="aaf1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">TLDR:一个简单的数据模型，如果你想在家里从头开始实现一个新的智能合同机制，它会很有帮助。用JavaScript和函数式编程。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/2b587f16235062cfe1290bc6cae6b150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wIl3mOkm6fhe1o5P."/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Photo by <a class="ae kf" href="https://unsplash.com/@igorovsyannykov?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Igor Ovsyannykov</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl kg kh hb ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hm hn ho hp hq"><h2 id="6e43" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jb ky kz la jf lb lc ld jj le lf lg lh dt translated">避免副作用</h2><p id="5e09" class="pw-post-body-paragraph iq ir ht is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hm dt translated">智能契约是关键的代码片段，应该易于编写和测试。</p><p id="b0ef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">虽然目前在形式代码验证领域正在进行认真的开发，但是纯属性思想是关于使用现有的并且在行业中被广泛接受的函数式编程方法。</p><p id="a538" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果一个智能契约能够表现为一个没有副作用的函数，从而易于测试和推理，那会怎么样？它是如何工作的？</p><p id="fab4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们做一些原型设计并创建一个函数，它可以作为一些虚拟加密货币令牌的非常简化的智能合约代码。</p><p id="279f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的函数将接收3个参数:</p><p id="7ebb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">- <strong class="is hu"> orig </strong>始发地账户地址<br/> - <strong class="is hu"> dest </strong>目的地账户地址<br/> - <strong class="is hu"> value </strong>从始发地向目的地转移的代币数量</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">source: <a class="ae kf" href="https://gist.github.com/slavasn/3ddacb1f522e76cadb8ee4f77ebd6f24" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/slavasn/3ddacb1f522e76cadb8ee4f77ebd6f24</a></figcaption></figure><p id="86e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jo"> getAttribute </em>和<em class="jo"> updateAttribute </em>是系统内置函数，负责检索和更新与此智能合约相关的用户信息。我们对<em class="jo"> updateAttribute </em>特别感兴趣，它表示在我们的传递函数中发生的副作用。</p><p id="3f12" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">怎样才能去掉它，让函数体内部的系统状态没有变化？让我们试着写一个新版本的代码。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">source: <a class="ae kf" href="https://gist.github.com/slavasn/10f36672bda08b7542a871bbe67d7a27" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/slavasn/10f36672bda08b7542a871bbe67d7a27</a></figcaption></figure><p id="988b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们在这里做了什么，这意味着什么:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="c276" class="kn ko ht lq b fv lu lv l lw lx">{<br/>    target: dest,<br/>    name: 'balance',<br/>    value: destBalance + value<br/>}</span></pre><p id="5d00" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们已经执行了我们的函数，并返回了计算结果，它说:<em class="jo">将目标地址</em><strong class="is hu"><em class="jo">dest</em></strong><em class="jo">的名为</em><strong class="is hu"><em class="jo">balance</em></strong><em class="jo">的属性设置为新值</em> <strong class="is hu"> <em class="jo"> destBalance +值</em> </strong> <em class="jo">。</em> <br/>底层代码会取它，检查返回值并保存计算结果。</p><h2 id="cd94" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jb ky kz la jf lb lc ld jj le lf lg lh dt translated">代码合同</h2><p id="73f5" class="pw-post-body-paragraph iq ir ht is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hm dt translated">注意，在第二个例子中，没有对返回的余额进行边界检查。现在，我们可以从主代码逻辑中省略这些检查，以使其更加清晰，并将所有验证委托给特殊函数。</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="09bc" class="kn ko ht lq b fv lu lv l lw lx">function validateBalance(balance) {<br/>    return balance &gt;= 0 &amp;&amp; balance &lt;= MAX_BALANCE;<br/>}</span></pre><p id="6540" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">将使用这些预定义的函数自动验证返回的属性列表，如果有效，帐户的属性<em class="jo">余额</em>将相应地更新为返回值。</p><h2 id="9bb4" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jb ky kz la jf lb lc ld jj le lf lg lh dt translated">使用函数式语言</h2><p id="dea3" class="pw-post-body-paragraph iq ir ht is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hm dt translated">这有什么意义？对于第一个代码示例，它也可以很好地工作，对吗？</p><p id="f667" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用无副作用的函数为使用真正的函数式语言打开了大门，这给我们的代码带来了额外的好处——没有了<em class="jo"> null </em>和数据结构的不变性。</p><p id="a46e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们用Elm重写这个小例子。</p><blockquote class="ly lz ma"><p id="0cfc" class="iq ir jo is b it iu iv iw ix iy iz ja mb jc jd je mc jg jh ji md jk jl jm jn hm dt translated">与手写的JavaScript不同，Elm代码实际上不会产生运行时异常。相反，Elm使用类型推断来检测编译过程中的问题。<br/><a class="ae kf" href="http://elm-lang.org/" rel="noopener ugc nofollow" target="_blank">http://elm-lang.org/</a></p></blockquote><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">source: <a class="ae kf" href="https://gist.github.com/slavasn/ff7d531e6279199468ebd4347e6e02cd" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/slavasn/ff7d531e6279199468ebd4347e6e02cd</a></figcaption></figure><p id="c520" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这可以极大地提高代码的可测试性和验证。这里以Elm为例。也有可能使用其他编译JavaScript语言，如PureScript、TypeScript、Clojure。</p><h2 id="0237" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jb ky kz la jf lb lc ld jj le lf lg lh dt translated">属性坐标</h2><p id="386a" class="pw-post-body-paragraph iq ir ht is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hm dt translated">我们现在有了两个坐标，可以让我们识别地址的属性——帐户<strong class="is hu">地址</strong>，属性<strong class="is hu">名称</strong>。</p><p id="ca71" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">到目前为止一切顺利。但是，如果我们想创建几个智能合同呢？我们怎么知道调用什么函数呢？</p><p id="3ea1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">看起来我们需要另一个坐标，一个智能合约的标识符。姑且称之为<strong class="is hu">自我</strong>。</p><p id="3415" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果有可能不仅调用我们的智能契约的默认函数<em class="jo"> transfer </em>而且还引入其他函数，会不会很方便？我们将如何解决这些问题？使用另一个属性坐标— <strong class="is hu">键</strong>，它代表函数名。</p><p id="536d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，让我们在新的区块链上创建一个事务，它将一些令牌从地址<strong class="is hu"> orig </strong>传输到<strong class="is hu"> dest </strong>。</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="438e" class="kn ko ht lq b fv lu lv l lw lx">{<br/> "orig": "origin address",<br/> "dest": "destination address",<br/> "value": 100,<br/> "self": "smart contract address",<br/> "key": "transfer"<br/>}</span></pre><p id="599a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">或者，创建新智能合约的交易:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="648a" class="kn ko ht lq b fv lu lv l lw lx">{<br/> "orig": "origin address",<br/> "dest": "self — destination address",<br/> "value": "smart contract code"<br/>}</span></pre><p id="77c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们有了一个简单的心智模型，允许我们使用无副作用的函数式编程方法轻松实现智能合同引擎。</p></div><div class="ab cl kg kh hb ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hm hn ho hp hq"><p id="755a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">更多代码示例和工作原型可以在<a class="ae kf" href="https://github.com/slavasn/bloqly" rel="noopener ugc nofollow" target="_blank">https://github.com/slavasn/bloqly</a>上找到</p></div></div>    
</body>
</html>