<html>
<head>
<title>Blockchain CTF write-up: Ethernaut GatekeeperTwo level</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">区块链CTF报道:Ethernaut GatekeeperTwo级别</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/blockchain-ctf-write-up-ethernaut-gatekeepertwo-level-bbde5c860a9d?source=collection_archive---------5-----------------------#2018-06-12">https://medium.com/coinmonks/blockchain-ctf-write-up-ethernaut-gatekeepertwo-level-bbde5c860a9d?source=collection_archive---------5-----------------------#2018-06-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="9fc2" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">第二部分</h2></div><p id="c98d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">是的，第二关比以太人CTF的第一关更复杂更有挑战性。</p><p id="a021" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我建议你在继续阅读这篇文章之前，先看看<a class="ae ke" rel="noopener" href="/coinmonks/blockchain-ctf-write-up-ethernaut-gatekeeperone-level-49f8d0a0528b"> GatekeeperOne level的文章</a>。</p><p id="30f3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这一次，我将描述“<strong class="jk hu"> GatekeeperTwo </strong>的水平。</p><p id="03a3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在这个关卡中，你会得到一个区块链智能合同<em class="kf">实例</em>以及用solidity编写的代码。</p><p id="7cbc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">目标是“进入”GatekeeperTwo，这意味着正确并完全执行“输入功能”:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff kg"><img src="../Images/4037d67d45a2e75f73c610387b35c775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PW76Iaoe98xde9tttB7xEQ.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">GatekeeperTwo source code of delivered instance to hack</figcaption></figure><p id="4545" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">同样，正如GatekeeperOne所发生的那样，如果您看一下代码，我们将不得不再次猜测一个新的“_gateKey”作为参数传递给“enter”函数，同时破解新的(和不同的)3修饰符(gateOne、gateTwo和gateThree安全检查)。</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff kw"><img src="../Images/fa49ca6d4ebda167eb74a03a7d3ea412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*bl3uBFOhtnqI4GHrSCQNeg.png"/></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">“enter” function that we have to exploit with its 3 gateX (X=One,Two,Three) modifiers</figcaption></figure><p id="a8c2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一旦我们得到它，就像GatekeeperOne smartcontract发生的那样，enter函数将简单地将tx.origin(我们的钱包)指定为进入者，但只有在同一个调用中满足所有条件时才会发生。</p><p id="39eb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">与GatekeeperTwo中的GatekeeperOne有什么区别？</strong></p><p id="e3c2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">主要的区别来自于gateTwo和gateTwo修饰符。</p><p id="37bf" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">gateOne与<a class="ae ke" rel="noopener" href="/coinmonks/blockchain-ctf-write-up-ethernaut-gatekeeperone-level-49f8d0a0528b"> GatekeeperOne的</a>如你所见完全相同:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff kx"><img src="../Images/27bf700200fa4d3dd54b98b3f7c39d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*H-zsJnDzBma06diNVnlX-Q.png"/></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">gateOne modifier code</figcaption></figure><p id="5ff1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果你记得的话，这个障碍很容易克服。我们只需要创建一个恶意的smartcontract，它将代表我的钱包远程调用enter函数。</p><p id="584c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">为什么GatekeeperTwo比GatekeeperOne级别复杂？</strong></p><p id="e067" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">它确实比以前的GatekeeperOne更复杂。让我们详细地看一下<strong class="jk hu">门二</strong>和<strong class="jk hu">门三</strong>以便你能理解这个陈述。</p><p id="8107" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果你看到<strong class="jk hu"> gateTwo </strong>:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff ky"><img src="../Images/6ff45743022bdd65908e09683fece3f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*6XsVqxLrsQmv6b5SpHzgLg.png"/></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">gateTwo modifier code</figcaption></figure><p id="2d45" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你有没有注意到一些奇怪的事情？</p><p id="09ff" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">是的，<a class="ae ke" href="http://solidity.readthedocs.io/en/v0.4.24/assembly.html" rel="noopener ugc nofollow" target="_blank">内联汇编调用</a>在solidity源代码中与其余代码混合是可能的。在这种类型的调用中要小心，因为所有相关的验证(数组长度检查，以避免越界检查等等..)将不会被考虑。</p><p id="4978" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">但是，真正奇怪的是，如果我们检查“<strong class="jk hu"> extcodesize </strong>条件的含义，那就意味着调用者(恶意)smartcontract <strong class="jk hu">的<strong class="jk hu">代码大小</strong>需要为零作为条件</strong>！！！！</p><p id="2e66" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们如何才能让它成为可能？</p><p id="bba6" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们的<strong class="jk hu">恶意Smartcontract大小</strong>会一直在0以上不是吗？</p><p id="00ff" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">有例外吗？</strong>:是的。</p><p id="288e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">如何？</strong>代码大小会在0以上，除非我们让所有发生(远程“回车”调用利用)<strong class="jk hu"> <em class="kf">在我们恶意smartcontract的构造函数里面！这意味着，恶意的smartcontract将在部署时自动利用漏洞。之后，它将具有extcodesize =真实代码大小。</em>T9】</strong></p><p id="188e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">那好吧。<strong class="jk hu">我们必须在构造函数代码逻辑</strong>中插入我们的远程函数调用(恶意的smartcontract调用要被黑客攻击的实例smartcontract的enter函数)<strong class="jk hu">。</strong></p><p id="f8d0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">但是，【gateThree安检呢？</p><p id="af32" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">像gateOne和gateTwo一样，gateThree只有一次被黑客攻击的机会，而且是在恶意的smartcontract被部署时。</p><p id="d5f2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们看看<strong class="jk hu"> gateThree修改器的代码</strong>:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/6bd50cf805dbe46a2f75426670c36eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*zsJpqX4JZxi9Wyr8ZVdOUQ.png"/></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">gateThree modifier code</figcaption></figure><p id="e5f2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu"> _gateKey又是“回车”功能的一个参数。</strong></p><p id="7416" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你注意到要满足的条件中的某些东西了吗？</p><p id="77c7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">没错，就是一个<strong class="jk hu">下溢情况！</strong></p><pre class="kh ki kj kk fq la lb lc ld aw le dt"><span id="c520" class="lf lg ht lb b fv lh li l lj lk">uint64(0) — 1</span></pre><p id="8261" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">将导致FFFFFFFFFFFFFF </strong></p><p id="a393" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因此，我们将不得不强制一个<strong class="jk hu">下溢条件</strong>:</p><pre class="kh ki kj kk fq la lb lc ld aw le dt"><span id="a68f" class="lf lg ht lb b fv lh li l lj lk">uint64(keccak256(msg.sender)) ^uint64(_gateKey)</span></pre><p id="396c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">但是现在开始了…</p><p id="4b08" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">msg.sender 将是我们的<strong class="jk hu">恶意smartcontract地址，但它将在部署时被动态分配。</strong></p><p id="d976" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果变量是在部署时赋值的，而同时我们只有一次机会(一次尝试)在构造函数中破解它，我们怎么能满足这样的条件呢？:)</p><p id="569f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这是棘手的部分，它也可以是可能的！！</p><p id="5d96" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了更好地理解它，让我向您展示我为这个一次性利用编写的<a class="ae ke" href="https://github.com/rriescog/Ethernaut-CTF/blob/master/Gatekeepertwosol.sol" rel="noopener ugc nofollow" target="_blank"> <strong class="jk hu">恶意smartcontract代码</strong> </a> <strong class="jk hu">，它与GatekeeperOne稍有不同并且更复杂，但是如果您已经阅读过以前的案例，您将会对这个新代码有更好的理解:</strong></p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff ll"><img src="../Images/78df65a850f85a906c8e368955e02dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFwT_RGh8mat2AA18_VRNg.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">Malicious Smartcontract to exploit / hack GatekeeperTwo level</figcaption></figure><p id="18a1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">首先，我们将通过使用<strong class="jk hu">“this”变量</strong>来控制动态smartcontract分配地址。</p><p id="5266" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">正如你所看到的，所有的逻辑都在“<strong class="jk hu">构造函数</strong>的内部:</p><p id="7103" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">函数Gatekeeperhack() </strong> { …}</p><p id="5de2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们需要产生一个下溢条件，然后，我们将计算<strong class="jk hu"> "_gateKeyMasked" </strong>过滤big endian MSB (8字节— 64位)<strong class="jk hu">。</strong></p><p id="6448" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">“<strong class="jk hu"> _gateKeyMasked_chunk </strong>”表示有趣的片段——就这8个字节(bytes8类型)。</p><p id="519a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">又来了<strong class="jk hu">【魔】</strong> : ('^'的意思是异或运算)</p><p id="c5f8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果你想有一些像</p><p id="db9d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">‘a’异或‘b’= FFFFF…(下溢)</strong>(见gateThree修改码)，</p><p id="aaed" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">存在</p><p id="52fd" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">‘a’= keccak 256(此)</strong>；</p><p id="7627" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然后</p><p id="3fa5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">‘b’必须是=‘a _ negation’</strong>，</p><p id="7859" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在哪里</p><p id="53ff" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">' a _ negation ' = ' a ' XOR ' FFFF…'</strong></p><p id="7e5d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我将变量<strong class="jk hu"> '_gateKey_hashed_negation '，</strong>命名为<strong class="jk hu">将基于“a”的取反进行动态计算，这依赖于msg.sender，即依赖于恶意smartcontract在部署过程中“动态”分配的地址…:)</strong></p><p id="ed6b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我们将这个<strong class="jk hu">字节8 </strong>变量作为一个<strong class="jk hu">参数传递给“enter”函数的远程调用，我们将进行异或运算</strong></p><p id="b408" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu"> 'a '异或' a _求反'</strong></p><p id="1d6b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这将导致“FFF……”等于uint64(0)-1，也是“FFF…”</p><p id="335c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">是的，<strong class="jk hu"> <em class="kf">一切都需要在部署恶意smartcontract时发生，一切都要同时动态计算和分配&amp;调用！！！</em>T25】</strong></p><p id="475e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu"> <em class="kf">它有点像“一次性破解”:)</em> </strong></p><p id="4b90" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">同样，我使用了REMIX IDE调试，这里我向您展示了该过程不同部分的一些截图(请记住，调试已在Javascript VM环境下完成，但利用将在区块链ropsten testnet网络中完成):</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff lm"><img src="../Images/e9e9b89fa68ebcabb73324c713ed03ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WL-wRm2gEKmSKSz3bLyaew.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">gateTwo-&gt; extcodesize == 0 ! (debug: JUMPDEST)</figcaption></figure><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff ln"><img src="../Images/8d687c44519ade80eec5f6e76b870e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1TMACr3-VqvApLyeIhdopQ.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">successful gateThree hack (debug: JUMPDEST instruction)</figcaption></figure><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff lo"><img src="../Images/1261971542bc87c58147a6fe88877b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZ1L6x2hYquHnaHlEyYcSA.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">“entrant” variable re-assigned to our wallet (debug: SSTORE instruction)</figcaption></figure><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff lp"><img src="../Images/2b14879602384628e99eecfb1e364a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*py8l-EH_B-FjIKLigBssXQ.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">“True” returned after successful execution of enter function!</figcaption></figure><p id="529f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">综上所述，y <strong class="jk hu">你将不得不在Ropsten测试区块链网络内部部署恶意的smartcontract，其中被黑客攻击的Smartcontract实例是</strong>；然后，当ropsten tesnet network部署它时，您将动态地自动利用/入侵它:)</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff lq"><img src="../Images/a3c056252376ce7be24787242f2c0a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A86QlVfJHwI0ULGTOVYQWQ.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">Deploying Malicious Smartcontract while automatic exploitation is taking place</figcaption></figure><p id="a823" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">和往常一样，当关卡完成时，Open Zeppelin总会给你一些建议:</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff lr"><img src="../Images/c60eacd4c56f32560dc177eeeda9ae81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qSToCGbN7l26Sq6vIs8_NA.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">GatekeeperTwo Level complete</figcaption></figure><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/afae5a8e0d79b92ce475a61e386966e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*UddAZndQxFO_3PdYMRAx2g.png"/></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">GatekeeperTwo Level complete</figcaption></figure><p id="e89c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通过使用web控制台(开发工具)，您还可以在实例仍在区块链中运行时检查变量状态。在此，我们检查利用前后“<strong class="jk hu">入口变量</strong>”是否已成功更新为元掩码钱包地址(tx.origin):</p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/c984290fc82cf3df3503cc7a72e5b3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*BBHszjuWPry6gG3xwhCMWg.png"/></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">entrant variable in ropsten blockchain network before and after the exploitation!</figcaption></figure><p id="e01b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我希望您已经喜欢并理解了GatekeeperOne和GatekeeperTwo级别之间的差异。</p><p id="db31" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">最后但同样重要的是，<a class="ae ke" href="https://github.com/rriescog/Ethernaut-CTF/blob/master/Gatekeepertwosol.sol" rel="noopener ugc nofollow" target="_blank">这个漏洞利用smartcontract的代码可以在Github </a>中找到。</p><p id="f791" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">祝好运，黑客快乐！</strong></p></div></div>    
</body>
</html>