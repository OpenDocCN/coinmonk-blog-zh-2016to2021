<html>
<head>
<title>Implement a Pseudo-Random Number Generator in 26 bytes smart contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在26字节智能合约中实现伪随机数生成器</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/sinh-s%E1%BB%91-pseudo-random-v%E1%BB%9Bi-26-bytes-smart-contract-4fee0d8da249?source=collection_archive---------2-----------------------#2021-05-24">https://medium.com/coinmonks/sinh-s%E1%BB%91-pseudo-random-v%E1%BB%9Bi-26-bytes-smart-contract-4fee0d8da249?source=collection_archive---------2-----------------------#2021-05-24</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/65e094f88750bc6633aadfed4715e64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8ehgIE00oIGSp0wI"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Photo by <a class="ae ig" href="https://unsplash.com/@florianolv?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Florian Olivo</a> on <a class="ae ig" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="798e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">自2015年以来，我一直关注分散式随机数生成器(DRNG)主题。这是一个漫长而愉快的旅程，因为我有时间在R&amp;D部门进行研究并参与开发。现在，阅读新的报纸，看看人们如何证明他们的方法，已经成为一种习惯力量。</p><p id="c776" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我最近用以太坊虚拟机操作码做了一些实验，并产生了一个想法，如何编写一个执行伪随机数生成器(PRNG)的最小智能契约。这个想法很简单，如果你在一个静态值上使用散列函数<code class="eh ke kf kg kh b">n</code>次，你会收到不同的结果，因为它的抗碰撞特性。这里你可能会有更多的细节，【http://www.ijcee.org/papers/439-JE503.pdf】T4。他们证明并通过了NIST给定的静态测试。</p><p id="0110" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我提出了一个非常简单的想法，我们通过对先前的<code class="eh ke kf kg kh b">immortal</code>和第32个旧块散列的组合执行散列来维护一个<code class="eh ke kf kg kh b">immortal</code>值。</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="6927" class="kq kr ij kh b fv ks kt l ku kv">Immortal := keccak256(Immortal XOR blockhash(block.number - 32))</span></pre><figure class="ki kj kk kl fq hv fe ff paragraph-image"><div class="fe ff kw"><img src="../Images/825ed6dd0cfcd0415ade193c8751993c.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*Ew2KnMmf2vDE1WrJ91VNzA.png"/></div></figure><h1 id="10dd" class="kx kr ij bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">这里的重点是什么？</h1><p id="76a3" class="pw-post-body-paragraph jg jh ij ji b jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd hm dt translated">显然，在上面的想法中，结果是可预测的，因为算法和输入是在区块链上发布的。任何人都可以进行链外计算。问题是他们无法预测另一个智能合约会触发这个合约多少次。预估压倒性交易的价值是有成本的。</p><p id="3e56" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了实际操作结果，miner将能够按照给定的顺序执行mine选择的交易，但是在交换中，他们需要冒他们的coinbase奖励的风险。</p><p id="1798" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果对手不是矿商，他们将能够通过创建一系列具有最高<code class="eh ke kf kg kh b">gasPrice</code>的序列事务来确保他们能够占据一系列值，从而获得优势。</p><h1 id="4e8a" class="kx kr ij bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">这个提议有什么帮助？</h1><p id="1fee" class="pw-post-body-paragraph jg jh ij ji b jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd hm dt translated">该算法对于大范围的PRNG应用和操纵成本超过交易价值的情况是安全和可接受的。</p><p id="089c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们可以使用PRNG作为额外的盐来改善由oracle或commit方案提供的结果。Oracle和commit方案在区块链上作为一个黑盒来维护随机性的不可预测性，而PRNG则提高了可信度。</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="4d87" class="kq kr ij kh b fv ks kt l ku kv">Randomness := RPNGResult XOR OracleResult</span></pre><h1 id="5aa9" class="kx kr ij bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">履行</h1><p id="6ac2" class="pw-post-body-paragraph jg jh ij ji b jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd hm dt translated">EVM是一个非常简单的虚拟机，它有一个深度为1024的堆栈。当然，它有记忆和存储。操作码的数量不算太多。</p><p id="5fff" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在尝试编写纯操作码智能契约时，我编写了自己的汇编程序来从汇编编译成EVM操作码。</p><p id="7650" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">下面是一个包含操作码列表的文件:</p><div class="hs ht fm fo hu lz"><a href="https://github.com/chiro-hiro/thedivine/blob/master/assembler/opcode.js" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab ej"><div class="mb ab mc cl cj md"><h2 class="bd ik fv z el me eo ep mf er et ii dt translated">千寻/thedivine</h2><div class="mg l"><h3 class="bd b fv z el me eo ep mf er et ek translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mh l"><p class="bd b gc z el me eo ep mf er et ek translated">github.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ia lz"/></div></div></a></div><p id="1219" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们遵循以下准则定义:</p><div class="hs ht fm fo hu lz"><a href="https://ethervm.io/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab ej"><div class="mb ab mc cl cj md"><h2 class="bd ik fv z el me eo ep mf er et ii dt translated">以太坊虚拟机操作码</h2><div class="mg l"><h3 class="bd b fv z el me eo ep mf er et ek translated">更新于2019年9月28日(添加了SHL、SHR和SAR操作码)。这是以太坊的一个低级参考…</h3></div><div class="mh l"><p class="bd b gc z el me eo ep mf er et ek translated">ethervm.io</p></div></div><div class="mi l"><div class="mo l mk ml mm mi mn ia lz"/></div></div></a></div><p id="32c2" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我的汇编程序:</p><figure class="ki kj kk kl fq hv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="009a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">实施:</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="dc0d" class="kq kr ij kh b fv ks kt l ku kv">; EVM Assembly The Divine by Chiro Hiro &lt;<a class="ae ig" href="mailto:chiro8x@gmail.com" rel="noopener ugc nofollow" target="_blank">chiro8x@gmail.com</a>&gt;</span><span id="f2e0" class="kq kr ij kh b fv mr kt l ku kv">PUSH1 0x20<br/>RETURNDATASIZE<br/>CALLER<br/>ORIGIN<br/>XOR<br/>PUSH1 0x0a<br/>JUMPI<br/>REVERT<br/>JUMPDEST<br/>DUP2<br/>DUP2<br/>DUP1<br/>SLOAD<br/>DUP3<br/>NUMBER<br/>SUB<br/>BLOCKHASH<br/>XOR<br/>DUP2<br/>MSTORE<br/>SHA3<br/>DUP2<br/>SSTORE<br/>RETURN</span></pre><ul class=""><li id="0153" class="ms mt ij ji b jj jk jn jo jr mu jv mv jz mw kd mx my mz na dt translated"><code class="eh ke kf kg kh b">PUSH1 0x20</code>将<code class="eh ke kf kg kh b">0x20</code>推到堆栈顶部</li><li id="b9b0" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">RETURNDATASIZE</code>将<code class="eh ke kf kg kh b">0x00</code>推入堆栈，因为我们没有执行任何调用，所以它的结果是<code class="eh ke kf kg kh b">0x00</code>。比<code class="eh ke kf kg kh b">PUSH1 0x00</code>便宜</li><li id="ad38" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">CALLER</code>将<code class="eh ke kf kg kh b">msg.sender</code>推到袋子上</li><li id="4e51" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">ORIGIN</code>将<code class="eh ke kf kg kh b">tx.origin</code>推到堆栈</li><li id="46ad" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">XOR</code>消耗堆栈顶部的两个项目，并将结果<code class="eh ke kf kg kh b">msg.sender xor tx.origin</code>压入堆栈</li><li id="2e98" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">PUSH1 0x0a</code>将<code class="eh ke kf kg kh b">JUMPDEST</code>推至堆栈</li><li id="7d36" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">JUMPI</code>消耗栈顶的两个物品，如果<code class="eh ke kf kg kh b">msg.sender == tx.origin</code>做<code class="eh ke kf kg kh b">REVERT</code>否则跳转到<code class="eh ke kf kg kh b">JUMPDEST</code></li><li id="51d1" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">DUP2</code>复制堆栈中的第二个项目</li><li id="ef63" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">DUP2</code>复制堆栈中的第二个项目</li><li id="5c0c" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">DUP1</code>复制栈顶的项目，我们的栈看起来会像这样<code class="eh ke kf kg kh b">[0x00,0x00,0x20,0x00,0x20]</code>，我们假设栈顶在左边。</li><li id="af97" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">SLOAD</code>在栈顶索引<code class="eh ke kf kg kh b">0x00</code>返回<code class="eh ke kf kg kh b">immortal</code>处装载存储</li><li id="007d" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">DUP3</code>我们用<code class="eh ke kf kg kh b">DUP3</code>复制<code class="eh ke kf kg kh b">0x20</code>，因为<code class="eh ke kf kg kh b">BLOCKHASH</code>不能在当前程序块上执行，我们的想法是在第32个旧程序块上执行。</li><li id="262d" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">NUMBER</code>将当前块高度<code class="eh ke kf kg kh b">block.number</code>返回堆栈</li><li id="816c" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">SUB</code>消耗堆栈顶部的两个值，然后将<code class="eh ke kf kg kh b">block.number - 32</code>压入堆栈</li><li id="4057" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">BLOCKHASH</code>获取<code class="eh ke kf kg kh b">block.number - 32</code>的块哈希，推入堆栈，<code class="eh ke kf kg kh b">blockhash</code>和<code class="eh ke kf kg kh b">immortal</code>位于堆栈顶部</li><li id="1b59" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">XOR</code> EVM的字长是256位，所以我们最好使用XOR来合并两个256位的值，而不是在内存中执行con cat。这一步之后<code class="eh ke kf kg kh b">blockhash xor imomrtal</code>将会在堆栈的顶部。</li><li id="f035" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">DUP2</code>将复制<code class="eh ke kf kg kh b">0x00</code>，现在<code class="eh ke kf kg kh b">0x00</code>在栈顶</li><li id="ebf2" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">MSTORE</code>分配内存<code class="eh ke kf kg kh b">memory[0, 32] = blockhash xor imomrtal</code>，现在堆栈<code class="eh ke kf kg kh b">[0x00,0x20,0x00,0x20]</code></li><li id="cc38" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">SHA3</code>在<code class="eh ke kf kg kh b">[0x00:0x20]</code>计算内存中值的摘要，然后将结果压入堆栈</li><li id="d1e3" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">DUP2</code>堆栈中有重复的<code class="eh ke kf kg kh b">0x00</code>值，堆栈为<code class="eh ke kf kg kh b">[0x00,keccak256(blockhash xor immortal),0x00,0x20]</code></li><li id="39a3" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">SSTORE</code>消耗堆栈顶部的两个项目，并在<code class="eh ke kf kg kh b">0x00</code>处覆盖<code class="eh ke kf kg kh b">immortal</code></li><li id="f348" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated"><code class="eh ke kf kg kh b">RETURN</code>消耗堆叠中的最后两件物品，然后离开。</li></ul><p id="b9db" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当我们运行汇编程序时，编译汇编程序的结果如下所示:</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="4003" class="kq kr ij kh b fv ks kt l ku kv">Output:<br/>60203d333218600a57fd5b8181805482430340188152208155f3</span><span id="e3b3" class="kq kr ij kh b fv mr kt l ku kv">Tx deploy data:<br/>601a803d90600a8239f360203d333218600a57fd5b8181805482430340188152208155f3</span></pre><h1 id="9d34" class="kx kr ij bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">结论</h1><ul class=""><li id="dd93" class="ms mt ij ji b jj lu jn lv jr ng jv nh jz ni kd mx my mz na dt translated">我们阻止正常地址触发PRNG</li><li id="da03" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated">代码被优化以最小化气体消耗</li><li id="a3b0" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated">每次通话费用大约在<code class="eh ke kf kg kh b">5190</code>气左右，大部分来自<code class="eh ke kf kg kh b">SLOAD</code>和<code class="eh ke kf kg kh b">SSTORE</code></li><li id="9cc8" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated">这段代码适用于任何EVM</li><li id="f252" class="ms mt ij ji b jj nb jn nc jr nd jv ne jz nf kd mx my mz na dt translated">其他合同越多地使用这种PRNG，对手预测或操纵结果的机会就越少</li></ul><p id="c024" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">此处提供源代码:</p><div class="hs ht fm fo hu lz"><a href="https://github.com/chiro-hiro/thedivine" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab ej"><div class="mb ab mc cl cj md"><h2 class="bd ik fv z el me eo ep mf er et ii dt translated">千寻/thedivine</h2><div class="mg l"><h3 class="bd b fv z el me eo ep mf er et ek translated">这是一份智能合同，允许我们以最低的成本生成并保护伪随机数。所有流程和…</h3></div><div class="mh l"><p class="bd b gc z el me eo ep mf er et ek translated">github.com</p></div></div><div class="mi l"><div class="nj l mk ml mm mi mn ia lz"/></div></div></a></div></div></div>    
</body>
</html>