<html>
<head>
<title>Validation in Hyperledger Sawtooth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hyperledger锯齿中的验证</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/validation-in-hyperledger-sawtooth-f29b2d9a6b23?source=collection_archive---------1-----------------------#2018-05-04">https://medium.com/coinmonks/validation-in-hyperledger-sawtooth-f29b2d9a6b23?source=collection_archive---------1-----------------------#2018-05-04</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/2f61a2a502539e529413e99dda70c5aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PkjpMsM_TpCmx61EW0MEzA.png"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek"><strong class="bd ig">from the homepage of sawtooth</strong></figcaption></figure><div class=""/><p id="6f61" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">作为我对锯齿文档概述的一部分，在此向您展示本系列的第二部分。</p><p id="fc29" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我创建了重要术语的文章内链接，以防你想跳过或回到你不理解的术语。唯一的例外是在下面的第一段和明确提到的外部链接。</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><p id="d25d" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在<a class="ae kl" href="https://www.hyperledger.org/projects/sawtooth" rel="noopener ugc nofollow" target="_blank">总账锯齿</a>，<a class="ae kl" rel="noopener" href="/@BlockchainDeal/hyperledger-sawtooth-for-a-beginner-transactions-and-batches-7c9cf444ecb5">块和批次</a>都是由授权节点以类似的方式进行验证。例如，这两个由日志处理——一个通过内部管道路由任务的接口。</p><p id="4f50" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在这里你可以找到日志中组件的完整分类。每个组件都可以看作是网络中的一个节点。</p><p id="f258" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">来自接收单位的日志通过<strong class="ji ik">完成符</strong>第一次接触。该组件确保“块和批次的所有相关性都已得到满足并向下游交付”。</p><p id="dff1" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然后，完成的块被发送到<a class="ae kl" href="#5eb8" rel="noopener ugc nofollow">链控制器</a>用于分支解析，而完成的批次被发送到块<a class="ae kl" href="#dd1d" rel="noopener ugc nofollow">发布器</a>用于包含在块中。</p><p id="d9f8" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">控制器和发布器协同工作，分别允许处理传入的块和新块的声明；这些都可以并行完成，并在高传入数据块率的时刻进行扩展。</p><h2 id="d212" class="km kn ij bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">商店</h2><blockquote class="lh li lj"><p id="78eb" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hm dt translated">块存储包含当前区块链中的所有块</p></blockquote><p id="71f0" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">可以通过批次ID、交易ID或块号来访问块。</p><p id="755c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">店里不包括叉子。为了将链头从一个分支更改为另一个分支，提交和取消提交到公共根的块的列表都被提供给原子方法。</p><p id="53c8" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">链头是标识当前分支的块，并且随着每个传入的块或合并而变化。</p><h2 id="d23b" class="km kn ij bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">隐藏物</h2><blockquote class="lh li lj"><p id="31d5" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hm dt translated">BlockCache保存验证器的工作块集，并跟踪处理状态</p></blockquote><p id="5122" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">它是块存储的实时内存构造版本，在系统启动时重新构建。</p><p id="3983" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">缓存中的块可以是:</p><ul class=""><li id="0784" class="lo lp ij ji b jj jk jn jo jr lq jv lr jz ls kd lt lu lv lw dt translated"><strong class="ji ik">有效</strong>，由<a class="ae kl" href="#5eb8" rel="noopener ugc nofollow">链控制器</a>验证</li><li id="6a3f" class="lo lp ij ji b jj lx jn ly jr lz jv ma jz mb kd lt lu lv lw dt translated"><strong class="ji ik">无效</strong>，前任或自身验证失败</li><li id="c465" class="lo lp ij ji b jj lx jn ly jr lz jv ma jz mb kd lt lu lv lw dt translated"><strong class="ji ik">未知</strong>，一般只是来自<a class="ae kl" href="#f258" rel="noopener ugc nofollow">完成者</a></li></ul><p id="20e4" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">流入和流出存储的数据块已经过验证，而缓存还会与潜在的新数据块或无效数据块进行交互。</p><p id="59fa" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在查找时，如果在缓存中找不到该块，则向存储进行查询，如果它仍然丢失，则该块被认为是系统未知的。</p><p id="c9a9" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">只要最近没有访问过的块没有被其他缓存的块作为前置块引用，它们就会被定期清除。</p><h2 id="f834" class="km kn ij bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">共识；一致</h2><p id="340f" class="pw-post-body-paragraph jg jh ij ji b jj mc jl jm jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd hm dt translated">该杂志支持可插拔的共识算法，如工作证明、耗时证明和其他实用的拜占庭容错算法。对网络协议的改变是通过认证的提议来完成的，认证的提议是设置族的事务。网络的这一部分运行着三个进程。</p><p id="ea91" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji ik"> <em class="lk">一致同意。BlockPublisher </em> </strong>用于创建候选区块来扩展链。它配备了对全局状态和<a class="ae kl" href="#d212" rel="noopener ugc nofollow">块存储</a>的只读访问，以及发布批处理的接口。这个过程的实例采取三个动作:初始化、检查和完成。</p><p id="637b" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji ik"> <em class="lk">意见一致。BlockVerifier </em> </strong>简单地向<a class="ae kl" href="#cd64" rel="noopener ugc nofollow">块验证器</a>提供块验证功能。这提供了一个机会来验证候选区块是否是按照适当的共识规则发布的。</p><p id="8b78" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji ik"> <em class="lk">意见一致。ForkResolver </em> </strong>使一致性算法能够选择下一个块作为链头。在像PBFT这样的最终算法中，永远不会有分叉来解析，解析器将总是选择扩展当前头的新块。</p><p id="bdeb" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这三个实现共同管理验证器的一致性活动。它们被编程为基于链宽参数执行，链宽参数在设置事务的帮助下被实例化，最初在<a class="ae kl" href="#7784" rel="noopener ugc nofollow">起源块</a>中。</p><h2 id="5eb8" class="km kn ij bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">控制器</h2><blockquote class="lh li lj"><p id="4b22" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hm dt translated">ChainController负责确定验证器当前在哪个链上，并协调任何需要发生的链变化活动。</p></blockquote><p id="3532" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">它被设计成一次处理多个块验证活动。这在出现多个分支时很有用，控制器可以同时处理来自所有竞争分支的块。这是在一组验证者失去连接并在稍后重新加入网络的情况下实现的。</p><figure class="mi mj mk ml fq hv fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/a02acf5e40c7d7b076ea0892bb9c686d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*OfqhXOmsACD54Xe7PDU_rg.png"/></div><figcaption class="ic id fg fe ff ie if bd b be z ek">this practical limitation is subject to change with the integration of Single Instruction Multiple Data (SIMD) and other parallel computation functions</figcaption></figure><p id="cd64" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当一个块从<a class="ae kl" href="#f258" rel="noopener ugc nofollow">完成器</a>到达时，<em class="lk">验证器</em>子组件被实例化，块被分派到一个线程池执行。</p><p id="1f18" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在处理过程中，验证器可以返回以下三种指示之一:</p><ol class=""><li id="4370" class="lo lp ij ji b jj jk jn jo jr lq jv lr jz ls kd mm lu lv lw dt translated">链头不再与实例化时相同，创建了一个新的验证器来重新进行fork解析</li><li id="f33e" class="lo lp ij ji b jj lx jn ly jr lz jv ma jz mb kd mm lu lv lw dt translated">该块应该成为链头，新的块作为头被添加到链中</li><li id="d440" class="lo lp ij ji b jj lx jn ly jr lz jv ma jz mb kd mm lu lv lw dt translated">该块不应成为链头，这可能是因为新块是无效链的一部分，或者是不需要的分支的成员</li></ol><p id="f6bf" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当向存储器提交列表时，由控制器启动链头更新过程，该列表具有来自新分叉的要提交的块和来自存储器的要取消提交的块。然后，<a class="ae kl" href="#dd1d" rel="noopener ugc nofollow">发布者</a>被通知新的链头。</p><h2 id="cf9b" class="km kn ij bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">验证器</h2><blockquote class="lh li lj"><p id="deaa" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hm dt translated">当BlockValidator被实例化时，它被赋予要验证的候选块和当前链头。</p></blockquote><p id="e1a7" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">该子部分有三个评估阶段。</p><p id="f142" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">首先，验证器确定fork的公共根，它可能是链头或公共前身。</p><p id="5545" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然后，逐块验证从公共根到块的链。任何无效块都会导致候选链无效。</p><p id="5262" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">最后，选择一个合格的候选人，并将其发送回<a class="ae kl" href="#5eb8" rel="noopener ugc nofollow">控制器</a>，作为新的链头添加到商店中，除非共识实施另有决定。</p><p id="8a9e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">实际的块验证过程最初检查链上事务权限，以验证谁被允许发出<a class="ae kl" rel="noopener" href="/@BlockchainDeal/hyperledger-sawtooth-for-a-beginner-transactions-and-batches-7c9cf444ecb5">事务和批次</a> —中等发布。之后，通过设置建议添加的链上块验证规则将应用于该块。然后，所有批处理都按顺序发送到事务调度程序。如果任何批次不符合以下标准，则该块无效:</p><blockquote class="mn"><p id="773c" class="mo mp ij bd mq mr ms mt mu mv mw kd ek translated">没有重复的批次</p><p id="1247" class="mo mp ij bd mq mr ms mt mu mv mw kd ek translated">无重复交易</p><p id="794e" class="mo mp ij bd mq mr ms mt mu mv mw kd ek translated">有效的事务相关性</p><p id="5589" class="mo mp ij bd mq mr ms mt mu mv mw kd ek translated">成功的批处理执行</p></blockquote><p id="5b5a" class="pw-post-body-paragraph jg jh ij ji b jj mx jl jm jn my jp jq jr mz jt ju jv na jx jy jz nb kb kc kd hm dt translated">完成后，共识验证会根据自己的规则进行。最后，通过验证块生成的状态根哈希必须与块头中的相关字段匹配。如果通过计算验证了该块，则将状态根哈希提交给存储。</p><h2 id="dd1d" class="km kn ij bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">出版者</h2><figure class="mi mj mk ml fq hv fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/fb90037d6ba821e598701944b8c4aaf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*uTuYPKqaqlwF_M1_7LIRHg.png"/></div><figcaption class="ic id fg fe ff ie if bd b be z ek">image from <a class="ae kl" href="https://sawtooth.hyperledger.org/docs/core/releases/1.0/architecture/journal.html" rel="noopener ugc nofollow" target="_blank">sawtooth documentation</a> — start reading from bottom left</figcaption></figure><p id="31ff" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">基本上，发布者只负责创建候选块并发布它们，同时响应一致性算法的命令。</p><h2 id="7784" class="km kn ij bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf lg dt translated">起源</h2><blockquote class="lh li lj"><p id="40c0" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hm dt translated">这是当块存储为空时创建链的根(起源块)的动作。</p></blockquote><p id="413d" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">该操作使用所需的共识模型、特定于部署的配置设置和创建时事务来引导验证器网络，以包括在分类帐的初始状态中。</p><p id="dba0" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">命令行界面工具用于生成批处理列表，当在空链上操作时，验证器在启动时加载这些列表。</p><p id="c541" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">建议在开发的所有阶段都遵循严格的批量订购结构；这在genesis的情况下是强制的，其中每一批都隐含依赖于前一批。</p><p id="2161" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在genesis中实现事务系列的作者必须提供工具来生成Genesis数据，这些数据带有流程所需的批处理。</p><blockquote class="lh li lj"><p id="79cc" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hm dt translated">以下示例将验证程序配置为使用PoET共识并指定适当的设置:</p></blockquote><figure class="mi mj mk ml fq hv fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/a91ac22a1060eb4c385f390aef18505a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*zE46ymOX1oB2gJcgd585iw.png"/></div></figure><p id="252d" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一个genesis.batch文件被写到验证器的数据目录中。</p><p id="38fb" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在启动时，只要batch.file存在并且没有块被指定为链头，验证器就使用该文件来产生一个起源块。</p><p id="df69" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然后正常处理该块，事务有效性的任何失败都将导致起源操作的失败。在批次被验证并且没有任何冲突的情况下，验证器使用genesis consensus生成一个具有空consensus字段的唯一块。</p><p id="6cf5" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">区块链ID或起源区块签名随后被添加到验证器的数据目录中。</p><p id="5de8" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">创世区块的部分生产需要共识机制的配置，这是第二个区块使用的。第二个模块必须知道如何从一个空字段初始化一个共识字段。</p><blockquote class="lh li lj"><p id="6a97" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hm dt translated">在未来的情况下，共识模型之间的转换可能是可能的，只要它们知道如何读取前一个块的共识字段。</p></blockquote><p id="5ff3" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要完成这个过程，所有必需的事务处理器(如锯齿设置事务处理器)都必须运行</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><p id="17bc" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果您对类似这样的锯齿文档的简单分解感兴趣，可以随时返回。现在，我每天都在阅读和撰写相关文章，我将能够为您提供关于如何使用该框架的稳定信息。</p><p id="b48a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">谢谢你的来访，希望能很快见到你。</p><figure class="mi mj mk ml fq hv fe ff paragraph-image"><a href="https://medium.com/coinmonks/hyperledger/home"><div class="fe ff ne"><img src="../Images/52effad9360d66adebc122ebba726352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EA8xflS01kmGsjhlK1Co3Q.png"/></div></a><figcaption class="ic id fg fe ff ie if bd b be z ek"><strong class="bd ig">Click to learn more HyperLedger Stories</strong></figcaption></figure></div></div>    
</body>
</html>