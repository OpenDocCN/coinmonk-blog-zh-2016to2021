<html>
<head>
<title>C++ Guide for EOS Development — Multi-Index Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">EOS开发的C++指南——多索引容器</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/c-guide-for-eos-development-multi-index-container-82ccfc21bad6?source=collection_archive---------1-----------------------#2018-10-09">https://medium.com/coinmonks/c-guide-for-eos-development-multi-index-container-82ccfc21bad6?source=collection_archive---------1-----------------------#2018-10-09</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/c536b181fe49be8a5373373aa81dcbb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p8Bh5Bjj4t-tvS12.png"/></div></div></figure><div class=""/><blockquote class="jb jc jd"><p id="8e50" class="je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这篇文章是我的<a class="ae kd" href="https://cmichel.io/categories/learneos" rel="noopener ugc nofollow" target="_blank">EOS开发人员C++指南</a>的一部分</p></blockquote><ol class=""><li id="751d" class="ke kf ie jh b ji jj jm jn kg kh ki kj kk kl kc km kn ko kp dt translated"><a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-basics/" rel="noopener ugc nofollow" target="_blank">基础知识</a></li><li id="c467" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated"><a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-call-by-value-reference/" rel="noopener ugc nofollow" target="_blank">通过值/引用调用&amp;指针</a></li><li id="5b7a" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated"><a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-classes-and-structs/" rel="noopener ugc nofollow" target="_blank">类和结构</a></li><li id="55bb" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated"><a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-templates" rel="noopener ugc nofollow" target="_blank">模板</a></li><li id="7648" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated"><a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-iterators-lambda-expressions" rel="noopener ugc nofollow" target="_blank">迭代器&amp;λ表达式</a></li><li id="b0d5" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated"><a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-multi-index" rel="noopener ugc nofollow" target="_blank">多指标</a></li><li id="87d4" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated">头文件</li></ol><h2 id="b28a" class="kv kw ie bd kx ky kz la lb lc ld le lf kg lg lh li ki lj lk ll kk lm ln lo lp dt translated">多指数</h2><p id="d124" class="pw-post-body-paragraph je jf ie jh b ji lq jk jl jm lr jo jp kg ls js jt ki lt jw jx kk lu ka kb kc hm dt translated">我们将讨论的最后一个重要话题是<em class="jg">多索引</em>。标准库附带了许多<em class="jg">容器</em>，如<code class="eh lv lw lx ly b">vector</code> s(动态数组)<code class="eh lv lw lx ly b">list</code> s(双向链表)<code class="eh lv lw lx ly b">set</code> s或<code class="eh lv lw lx ly b">map</code> s。虽然它们都服务于存储和访问元素的相同目的，但它们中的每一个都以不同的方式实现这一目的，从而导致基本操作的不同<em class="jg">运行时</em>——例如，<code class="eh lv lw lx ly b">set</code>以排序的方式维护其元素，而<code class="eh lv lw lx ly b">list</code>不产生随机访问，而是允许您在恒定时间内在任何位置插入元素，而无需重新分配。它们都提供了一个<em class="jg">单一的</em>特定的方式来访问你的元素，但是有时我们希望有多个接口来访问相同的数据。</p><p id="0d15" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">我们来看一个<code class="eh lv lw lx ly b">CryptoCurrency</code>类:</p><pre class="lz ma mb mc fq md ly me mf aw mg dt"><span id="dc68" class="kv kw ie ly b fv mh mi l mj mk">#include &lt;iostream&gt;<br/>#include &lt;set&gt;<br/>#include &lt;string&gt;<br/>#include &lt;algorithm&gt;<br/><br/>using namespace std;<br/><br/>class CryptoCurrency {<br/>    public:<br/>    string name;<br/>    uint64_t market_cap;<br/>    double priceInUSD;<br/>    CryptoCurrency(const string &amp;name, uint64_t market_cap, double priceInUSD) : name(name), market_cap(market_cap), priceInUSD(priceInUSD) {}<br/>    <br/>    // define comparison &lt; operator to compare cryptos by market_cap <br/>    bool operator&lt;(const CryptoCurrency&amp; c) const {<br/>        return market_cap &lt; c.market_cap;<br/>    }<br/>};<br/><br/>int main()<br/>{<br/>    // store some crypto currencies in a set<br/>    set&lt;CryptoCurrency&gt; cryptos;<br/>    cryptos.insert(CryptoCurrency("EOS", 1000, 1.0));<br/>    cryptos.insert(CryptoCurrency("Bitcoin", 2000, 10.0));<br/>    cryptos.insert(CryptoCurrency("Ethereum", 500, 2.0));<br/>    <br/>    // sets order their elements, in our case according to market_cap<br/>    // iterating the currencies in ascending order<br/>    for_each(cryptos.begin(), cryptos.end(), [](const CryptoCurrency&amp; c) {<br/>        cout &lt;&lt; c.name &lt;&lt; " " &lt;&lt; c.market_cap &lt;&lt; "\n";<br/>    });<br/>}</span></pre><p id="f143" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">集合是一种很好的方式来保持加密货币按单个<em class="jg">索引</em>排序，在我们的例子中就是<code class="eh lv lw lx ly b">market_cap</code>。但是，如果您需要一个按字母顺序排列的货币列表，会发生什么呢？</p><p id="e9c6" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">一种方法是保存一组指向由<code class="eh lv lw lx ly b">name</code>字段排序的<code class="eh lv lw lx ly b">set</code>元素的指针。然而，有一种更简单的方法:我们需要的是一种为相同的数据元素定义多个索引的方法。</p><p id="d030" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">这正是来自<em class="jg"> boost </em>库的<code class="eh lv lw lx ly b">multi_index_container</code> s的概念。</p><blockquote class="jb jc jd"><p id="f3e9" class="je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">Boost库是一个在实践中被高度使用的外部库，因为它解决了C++标准库中没有的广泛的常见任务，附带了很好的文档和教程，并且是开源的和经过同行评审的。(您也可以在编写智能合同时使用它！)</p></blockquote><pre class="lz ma mb mc fq md ly me mf aw mg dt"><span id="dd9f" class="kv kw ie ly b fv mh mi l mj mk">"The obvious solution for most programmers is to use a library that provides an elegant and efficient platform independent to needed services. Examples are BOOST..." — Bjarne Stroustrup</span></pre><p id="686a" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">让我们来看看如何让我们的类与<code class="eh lv lw lx ly b">multi_index_container</code> s:</p><pre class="lz ma mb mc fq md ly me mf aw mg dt"><span id="b77f" class="kv kw ie ly b fv mh mi l mj mk">#include &lt;iostream&gt;<br/>#include &lt;set&gt;<br/>#include &lt;string&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;boost/multi_index_container.hpp&gt;<br/>#include &lt;boost/multi_index/ordered_index.hpp&gt;<br/>#include &lt;boost/multi_index/identity.hpp&gt;<br/>#include &lt;boost/multi_index/member.hpp&gt;<br/><br/>using namespace std;<br/>using namespace boost; // for multi_index_container<br/>// for indexed_by, ordered_unique, member, identity<br/>using namespace boost::multi_index;<br/><br/>class CryptoCurrency<br/>{<br/>  public:<br/>    string name;<br/>    uint64_t market_cap;<br/>    double priceInUSD;<br/>    CryptoCurrency(const string &amp;name, uint64_t market_cap, double priceInUSD) : name(name), market_cap(market_cap), priceInUSD(priceInUSD) {}<br/><br/>    // define comparison &lt; operator to compare cryptos by market_cap<br/>    bool operator&lt;(const CryptoCurrency &amp;c) const<br/>    {<br/>        return market_cap &lt; c.market_cap;<br/>    }<br/>};<br/><br/>// typedef is a way to alias types<br/>// multi_index_container&lt;...&gt; will be aliased as crypto_set<br/>typedef multi_index_container<br/>&lt;<br/>    CryptoCurrency,<br/>    indexed_by<br/>    &lt;<br/>        // sort by CryptoCurrency::operator&lt;<br/>        ordered_unique&lt;identity&lt;CryptoCurrency&gt;&gt;,<br/>        // sort by string's &lt; on CryptoCurrency::name member<br/>        ordered_unique&lt;member&lt;CryptoCurrency, std::string, &amp;CryptoCurrency::name&gt;&gt;<br/>    &gt;<br/>&gt; crypto_set;<br/><br/>int main()<br/>{<br/>    // use the typedef'd multi_index_container<br/>    crypto_set cryptos;<br/>    cryptos.insert(CryptoCurrency("Eos", 1000, 1.0));<br/>    cryptos.insert(CryptoCurrency("Bitcoin", 2000, 10.0));<br/>    cryptos.insert(CryptoCurrency("Ethereum", 500, 2.0));<br/><br/>    // interface through the first index by market_cap<br/>    // market_cap_index is now an iterator having .begin() and .end()<br/>    // make sure to not forget the '&amp;' after ::type or use auto<br/>    const crypto_set::nth_index&lt;0&gt;::type &amp;market_cap_index = cryptos.get&lt;0&gt;();<br/>    for_each(market_cap_index.begin(), market_cap_index.end(), [](const CryptoCurrency &amp;c) {<br/>        cout &lt;&lt; c.name &lt;&lt; " " &lt;&lt; c.market_cap &lt;&lt; "\n";<br/>    });<br/><br/>    // alternatively you can omit the .get&lt;0&gt;().begin() and call .begin() directly<br/>    // not providing .get&lt;index&gt; always returns the first index<br/>    // so we don't even need to change the old code for sorting by market_cap!<br/>    for_each(cryptos.begin(), cryptos.end(), [](const CryptoCurrency &amp;c) {<br/>        cout &lt;&lt; c.name &lt;&lt; " " &lt;&lt; c.market_cap &lt;&lt; "\n";<br/>    });<br/><br/>    // now interface through the _second_ index by name<br/>    // const crypto_set::nth_index&lt;1&gt;::type&amp; name_index = cryptos.get&lt;1&gt;();<br/>    const auto &amp;name_index = cryptos.get&lt;1&gt;();<br/>    for_each(name_index.begin(), name_index.end(), [](const CryptoCurrency &amp;c) {<br/>        cout &lt;&lt; c.name &lt;&lt; " " &lt;&lt; c.market_cap &lt;&lt; "\n";<br/>    });<br/>}</span></pre><p id="281f" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">有比<code class="eh lv lw lx ly b">ordered_unique</code>或<code class="eh lv lw lx ly b">ordered_non_unique</code>更多的索引类型(对于非唯一类成员)。虽然这两个提供了类似于将<code class="eh lv lw lx ly b">CryptoCurrency</code>存储为<code class="eh lv lw lx ly b">std::set</code>的接口，但是<code class="eh lv lw lx ly b">sequenced&lt;&gt;</code>索引提供了类似于<code class="eh lv lw lx ly b">std::list</code>的双向接口。当您希望保持插入元素时的原始顺序时，顺序索引非常有用。如果你需要进入一个特定的位置，比如一个<code class="eh lv lw lx ly b">std::vector</code>，有一个<code class="eh lv lw lx ly b">random_access&lt;&gt;</code>索引。</p><p id="0f4a" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">当我们通过智能合约在EOS区块链中存储和检索数据表时，我们将重新访问。可以想象，拥有多个接口来排序和搜索数据库表中的元素是非常有用的。</p><p id="c321" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">如果你想了解更多，boost.org有一个详尽的教程。</p><figure class="lz ma mb mc fq hv fe ff paragraph-image"><a href="https://learneos.one#modal"><div class="fe ff ml"><img src="../Images/5d386a189e02fe717ed1bf3e9a240b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9BLV2ZakVpQHw4S4.png"/></div></a></figure></div><div class="ab cl mm mn hb mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hm hn ho hp hq"><p id="055e" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">最初发布于<a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-multi-index/" rel="noopener ugc nofollow" target="_blank"> cmichel.io </a></p><blockquote class="mt"><p id="2a4b" class="mu mv ie bd mw mx my mz na nb nc kc ek translated"><a class="ae kd" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ne nf ng nh ni hv fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nd"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>