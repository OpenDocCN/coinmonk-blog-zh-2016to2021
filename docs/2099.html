<html>
<head>
<title>Zero knowledge proofs using Bulletproofs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用bullet证明的零知识证明</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/zero-knowledge-proofs-using-bulletproofs-4a8e2579fc82?source=collection_archive---------0-----------------------#2019-02-23">https://medium.com/coinmonks/zero-knowledge-proofs-using-bulletproofs-4a8e2579fc82?source=collection_archive---------0-----------------------#2019-02-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/ad4df10f6cad8c88d6c26098469992b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ajez2ry0uorPlDFAwKnkAg.jpeg"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Photo by <a class="ae ig" href="https://unsplash.com/photos/1XgFFEG_RGA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jeremy Perkins</a> on <a class="ae ig" href="https://unsplash.com/search/photos/zero-knowledge?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="22ef" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这里我将展示如何使用<a class="ae ig" href="https://github.com/dalek-cryptography/bulletproofs" rel="noopener ugc nofollow" target="_blank"><em class="ke">bullet proof实现</em></a><em class="ke"/><a class="ae ig" href="https://github.com/dalek-cryptography" rel="noopener ugc nofollow" target="_blank"><em class="ke">dalek-cryptography</em></a><em class="ke">创建各种零知识证明。这些例子将是:I)证明已知给定数目的因子，而不暴露这些因子，ii)范围证明，即证明你知道值x，使得a ≤ x ≤ b，而不暴露x，iii)证明你拥有的值非零，而不暴露它(不使用上述范围证明)，iv)证明该值不等于给定值，而不暴露你自己的值，v)集合成员，即给定集合S， 证明你知道集合中包含的一个元素而不暴露该元素，vi)类似地，设置非成员资格而不暴露缺失元素的值。 这些例子只需很少的努力就可以修改，这样它们就可以用在libsnark或bellman这样的ZK-SNARK实现中。要直接浏览代码，请点击</em>  <em class="ke">进入</em> <a class="ae ig" href="https://github.com/lovesh/bulletproofs/blob/range-proof/tests" rel="noopener ugc nofollow" target="_blank"> <em class="ke">。</em></a></p><h2 id="d3a0" class="kf kg ij bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">这篇文章中的代码已经被重构，更新了更多的例子，并转移到了一个新的<a class="ae ig" href="https://github.com/lovesh/bulletproofs-r1cs-gadgets" rel="noopener ugc nofollow" target="_blank">repo</a>。</h2><h1 id="f82f" class="la kg ij bd kh lb lc ld kl le lf lg kp lh li lj ks lk ll lm kv ln lo lp ky lq dt translated">概观</h1><p id="6bcb" class="pw-post-body-paragraph jg jh ij ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hm dt translated">我假设你已经熟悉利用算术电路来证明任意陈述。它已经在几篇论文中被描述过，但是本帖所讨论的库是建立在论文“<a class="ae ig" href="https://eprint.iacr.org/2016/263" rel="noopener ugc nofollow" target="_blank">离散对数设置中算术电路的有效零知识论证</a>”之上的。通过<a class="ae ig" href="https://eprint.iacr.org/2017/1066.pdf" rel="noopener ugc nofollow" target="_blank">的Bulletproofs论文</a>和dalek-cryptography出版了他们的<a class="ae ig" href="https://github.com/dalek-cryptography/bulletproofs" rel="noopener ugc nofollow" target="_blank">实现</a>，该技术变得更加有效。其思想是将语句表示为算术电路，即一组方程，其中允许的运算符是加法、减法和乘法，并将这些方程转换为秩1约束系统(R1CS)。约束系统是一组变量的算术约束的集合。要了解更多关于这个过程和R1CS的信息，请看这篇<a class="ae ig" rel="noopener" href="/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">文章</a>。最近，利用r1c的验证系统越来越受欢迎，ZK-斯纳克是最受欢迎的一种。ZK-斯纳克法的缺点是存在可信设置，即协议参数的一次性生成，这涉及到可以用来破坏协议保证的一些秘密的知识或学习。这是一个挑战，因为现在的设置必须以这样的方式完成，这样的秘密不能被(完全)学习，Zcash使用多方计算来完成它。另一个挑战是必须对每条电路进行可信设置，例如，如果你想证明对2个因素的了解，那么你要进行可信设置。现在，如果您必须证明了解3个因素，您必须再次进行可信设置，因为约束条件已经改变。用Bulletproofs构建的R1CS系统没有可信的设置，因此避免了上述两个问题。</p><p id="d539" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">该验证系统的最高理念是<br/> 1。证明者承诺一个(多个)值，他想要证明对<br/> 2的了解。证明者通过对承诺值和任何附加的公共值施加约束来生成证明。这些约束可能需要证明者提交一些额外的变量。<br/> 3。证明者向验证者发送他在步骤1和步骤2中做出的所有承诺，以及来自步骤2的证明。<br/> 4。验证者现在通过对承诺加上任何公共值实施相同的约束来验证证明。</p><h1 id="3ceb" class="la kg ij bd kh lb lc ld kl le lf lg kp lh li lj ks lk ll lm kv ln lo lp ky lq dt translated">Bulletproofs API</h1><p id="911b" class="pw-post-body-paragraph jg jh ij ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hm dt translated">让我们在一个示例的上下文中探索Bulletproofs API。假设证明者想要证明一个公众号<code class="eh lw lx ly lz b">r</code>的因子的知识，证明者知道因子<code class="eh lw lx ly lz b">p</code>和<code class="eh lw lx ly lz b">q</code>，但是验证者不知道。因此，证明者将为陈述<code class="eh lw lx ly lz b">p * q = r</code>创建证明，其中<code class="eh lw lx ly lz b">r</code>被证明者和验证者都知道，但是<code class="eh lw lx ly lz b">p</code>和<code class="eh lw lx ly lz b">q</code>仅被证明者知道。</p><p id="cb70" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">1.创建一些将被证明者和验证者使用的生成器</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="34c6" class="kf kg ij lz b fv mi mj l mk ml">let pc_gens = PedersenGens::<em class="ke">default</em>();<br/>let bp_gens = BulletproofGens::<em class="ke">new</em>(128, 1);</span></pre><p id="96b7" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">上面的代码创建了2组生成器，<code class="eh lw lx ly lz b">pc_gens</code>是一对2生成器，<code class="eh lw lx ly lz b">bp_gens</code>是一对2向量(列表)生成器。自变量128表示每个向量将有128个生成器。所以在<code class="eh lw lx ly lz b">bp_gens</code>中总共创建了2*128=256个生成器。<code class="eh lw lx ly lz b">pc</code>和<code class="eh lw lx ly lz b">bp</code>分别代表Pedersen和Bulletproofs。</p><p id="0bb7" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">2.实例化一个证明者</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="3b8b" class="kf kg ij lz b fv mi mj l mk ml">let mut prover_transcript = Transcript::<em class="ke">new</em>(b"Factors");<br/>let mut prover = Prover::<em class="ke">new</em>(&amp;bp_gens, &amp;pc_gens, &amp;mut prover_transcript);</span></pre><p id="a5d9" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh lw lx ly lz b">prover_transcript</code>是证明者的抄本。副本是证明者和验证者之间交换的消息的记录，如证明者发送给验证者的承诺或验证者发送给证明者的挑战。由于这种Bulletproofs实现是非交互式的，挑战是由Fiat-Shamir启发式算法产生的，即散列抄本的当前状态。<code class="eh lw lx ly lz b">Factors</code>是转录本的标签，当方案由子方案组成时，用于区分不同的转录本或子转录本。</p><p id="6b0f" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">3.证明者提交变量</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="a4e1" class="kf kg ij lz b fv mi mj l mk ml">let x1 = Scalar::<em class="ke">random</em>(&amp;mut rng);<br/>let (com_p, var_p) = prover.commit(p.into(), x1);<br/>let x2 = Scalar::<em class="ke">random</em>(&amp;mut rng);<br/>let (com_q, var_q) = prover.commit(q.into(), x2);</span></pre><p id="4720" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在上面的例子中，证明者使用随机性<code class="eh lw lx ly lz b">x1</code>和<code class="eh lw lx ly lz b">pc_gens</code>的2个生成器<code class="eh lw lx ly lz b">g</code>和<code class="eh lw lx ly lz b">h</code>来提交因子<code class="eh lw lx ly lz b">p</code>。这是彼得森的承诺，因此称为<code class="eh lw lx ly lz b">com_p = gᵖhˣ¹</code>。同样<code class="eh lw lx ly lz b">com_q</code>是对<code class="eh lw lx ly lz b">q</code>与<code class="eh lw lx ly lz b">x2</code>的承诺。除了创建承诺，<code class="eh lw lx ly lz b">commit</code>方法还为约束系统创建相应的变量，<code class="eh lw lx ly lz b">var_p</code>和<code class="eh lw lx ly lz b">var_q</code>分别是<code class="eh lw lx ly lz b">p</code>和<code class="eh lw lx ly lz b">q</code>的变量。此外，在<code class="eh lw lx ly lz b">commit</code>期间，2项承诺被添加到记录中。</p><p id="1f68" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">4.证明者约束变量</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="89bd" class="kf kg ij lz b fv mi mj l mk ml">let (_, _, o) =  prover.multiply(var_p.into(), var_q.into());</span></pre><p id="e63c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通过<code class="eh lw lx ly lz b">multiply</code>函数，证明者指定变量<code class="eh lw lx ly lz b">var_p</code>和<code class="eh lw lx ly lz b">var_q</code>要相乘，结果被捕获到变量<code class="eh lw lx ly lz b">o</code>中。此外，该功能将导致分配对应于<code class="eh lw lx ly lz b">var_p</code>、<code class="eh lw lx ly lz b">var_q</code>和<code class="eh lw lx ly lz b">o</code>的变量。另外<code class="eh lw lx ly lz b">multiply</code>评估输入变量，并约束它们等于相应的分配变量。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="e27e" class="kf kg ij lz b fv mi mj l mk ml">let r_lc: LinearCombination = vec![(Variable::<em class="ke">One</em>(),      r.into())].iter().collect();<br/>prover.constrain(o -  r_lc);</span></pre><p id="4356" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在证明者想要强制执行<code class="eh lw lx ly lz b">p</code>和<code class="eh lw lx ly lz b">q</code>的乘积等于<code class="eh lw lx ly lz b">r</code>。由于<code class="eh lw lx ly lz b">p</code>和<code class="eh lw lx ly lz b">q</code>的变量乘积，即<code class="eh lw lx ly lz b">var_p</code>和<code class="eh lw lx ly lz b">var_q</code>在变量<code class="eh lw lx ly lz b">o</code>中被捕获，所以证明者可以为<code class="eh lw lx ly lz b">r</code>分配一个变量，然后确保<em class="ke"> r变量</em>和<code class="eh lw lx ly lz b">o</code>的减法为0。证明者通过创建线性约束来创建这个<em class="ke"> r变量</em>，即一个变量乘以一个标量。元组<code class="eh lw lx ly lz b">(Variable::<em class="ke">One</em>(), r.into())</code>表示值等于<code class="eh lw lx ly lz b">r</code>的线性约束，即将值为1的变量(<code class="eh lw lx ly lz b">Variable::<em class="ke">One</em>()</code>)乘以标量<code class="eh lw lx ly lz b">r</code>。如果证明者想要创建一个值为p+q+r的变量，他可以通过<code class="eh lw lx ly lz b">vec![(Variable::<em class="ke">One</em>(), (p+q+r).into())]</code>或<code class="eh lw lx ly lz b">vec![(Variable::<em class="ke">One</em>(), p.into()), (Variable::<em class="ke">One</em>(), q.into()), (Variable::<em class="ke">One</em>(), r.into())]</code>创建向量的相加项。<br/>由于线性组合可以彼此相加或相减以给出另一个线性组合，所以证明者确保线性组合<code class="eh lw lx ly lz b">o — lc</code>为0，这通过调用<code class="eh lw lx ly lz b">constrain</code>来完成。方法<code class="eh lw lx ly lz b">constrain</code>确保传递给它的线性组合等于0。</p><p id="1aed" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">5.证明者创造证据</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="a45a" class="kf kg ij lz b fv mi mj l mk ml">let proof = prover.prove().unwrap();</span></pre><p id="0ea2" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">6.实例化验证器</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="b8fb" class="kf kg ij lz b fv mi mj l mk ml">let mut verifier_transcript = Transcript::<em class="ke">new</em>(b"Factors");<br/>let mut verifier = Verifier::<em class="ke">new</em>(&amp;bp_gens, &amp;pc_gens, &amp;mut verifier_transcript);</span></pre><p id="3a10" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在这里，验证器被实例化，并创建自己的副本。请注意，抄本的名称与证明者的名称相同。这很重要，因为名字是抄本内容的一部分，而证明者和验证者之间的挑战是抄本内容的散列。不同的名称将导致不同的抄本内容，因此对证明者和验证者的挑战也不同，这将导致证明验证失败。</p><p id="eb42" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">7.使用承诺的验证者。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="7af6" class="kf kg ij lz b fv mi mj l mk ml">let var_p = verifier.commit(commitments.0);<br/>let var_q = verifier.commit(commitments.1);</span></pre><p id="2297" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">验证者在抄本中记录由证明者发送的对p和q的承诺，并为这些承诺创建类似于证明者的变量。区别在于证明者可以访问被提交的值和随机性，而验证者则不能。</p><p id="f7cc" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">8.验证器约束变量</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="e231" class="kf kg ij lz b fv mi mj l mk ml">let (_, _, o) =  verifier.multiply(var_p.into(), var_q.into());<br/>let r_lc: LinearCombination = vec![(Variable::<em class="ke">One</em>(), r.into())].iter().collect();<br/>verifier.constrain(o -  r_lc);</span></pre><p id="6a77" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">类似于证明者，验证者也约束对应于承诺的变量。请注意，约束与证明者的约束完全相同。</p><p id="947e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">9.最后，验证者验证证明。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="19e7" class="kf kg ij lz b fv mi mj l mk ml">verifier.verify(&amp;proof)</span></pre><p id="2be4" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这个例子缺少一个约束来确保<code class="eh lw lx ly lz b">p</code>和<code class="eh lw lx ly lz b">q</code>都不能为1(除非<code class="eh lw lx ly lz b">r</code>为1)，这可以通过使用范围证明(expenve)或证明不等于1来实现，如下例所示。完整的例子是<a class="ae ig" href="https://github.com/lovesh/bulletproofs/blob/e477511a20bdb8de8f4fa82cb789ba71cc66afd8/tests/basic_r1cs.rs#L17" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h1 id="fee3" class="la kg ij bd kh lb lc ld kl le lf lg kp lh li lj ks lk ll lm kv ln lo lp ky lq dt translated">更多示例</h1><p id="ac6a" class="pw-post-body-paragraph jg jh ij ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hm dt translated"><strong class="ji ik">量程证明<br/> </strong>为了证明一个承诺值<code class="eh lw lx ly lz b">x</code>满足<em class="ke"> min ≤ x ≤ max </em>对于某些公共<code class="eh lw lx ly lz b">min</code>和<code class="eh lw lx ly lz b">max</code>，证明者需要满足两个陈述，<em class="ke"> x ≥ min </em>和<em class="ke"> x ≤ max </em>。<em class="ke"> x ≥ min </em>相当于证明<em class="ke"> x - min ≥ 0 </em>和<em class="ke"> x ≤ max </em>相当于证明<em class="ke"> max - x ≥ 0 </em>。现在，如果证明者对于某些提交的<code class="eh lw lx ly lz b">v</code>、<code class="eh lw lx ly lz b">v</code> ≥ 0，他可以证明<em class="ke"> x - min ≥ 0 </em>和<em class="ke"> max - x ≥ 0 </em>，并对<em class="ke"> x - min </em>和<em class="ke"> max - x. </em>进行提交，那么让我们重点证明<code class="eh lw lx ly lz b">v</code> ≥ 0且小于最大允许值，以避免某些提交的<code class="eh lw lx ly lz b">v</code>，即<code class="eh lw lx ly lz b">v</code>在<em class="ke"> [0，MAX_VALUE如果证明者创建了一个<code class="eh lw lx ly lz b">v</code>的位表示，并且该位表示包含了<code class="eh lw lx ly lz b">n</code>位，那么很明显<code class="eh lw lx ly lz b">v</code>位于2ⁿ).的[0一旦证明者创建了这个<code class="eh lw lx ly lz b">n</code>位向量，它仍然不能向验证者透露这个位向量，因为这将<code class="eh lw lx ly lz b">v</code>给验证者。但是如果证明者可以向验证者证明这个向量的每个元素确实是一个比特，并且这些比特被设置在“正确的索引”处，那么它就可以说服验证者<code class="eh lw lx ly lz b">v</code>在范围内。<br/>说n位向量是【bₙ₋₁，bₙ₋₂，…b₁，b₀].要证明每个bᵢ都有一点，证明bᵢ*(1-bᵢ)=0.就足够了下面的片段展示了这个想法</em></p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="cbfc" class="kf kg ij lz b fv mi mj l mk ml">for i in 0..n {<br/>    // Create low-level variables and add them to constraints<br/>    let (a, b, o) = cs.allocate(|| {<br/>        let q: u64 = v.assignment.ok_or(R1CSError::<em class="ke">MissingAssignment</em>)?;<br/>        let bit: u64 = (q &gt;&gt; i) &amp; 1;<br/>        <em class="ke">Ok</em>(((1 - bit).into(), bit.into(), Scalar::<em class="ke">zero</em>()))<br/>    })?;<br/><br/>    // Enforce a * b = 0, so one of (a,b) is zero<br/>    cs.constrain(o.into());<br/><br/>    // Enforce that a = 1 - b, so they both are 1 or 0.<br/>    cs.constrain(a + (b - 1u64));<br/>}</span></pre><p id="7ccc" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">上面的例子迭代了<code class="eh lw lx ly lz b">v</code>的n位。<code class="eh lw lx ly lz b">cs</code>是约束系统。前面例子中的证明者和验证者都是约束系统，都将运行上面的代码块。<code class="eh lw lx ly lz b">allocate</code>将分配3个变量，<code class="eh lw lx ly lz b">a</code>，<code class="eh lw lx ly lz b">b</code>和<code class="eh lw lx ly lz b">o</code>，约束条件为<code class="eh lw lx ly lz b">a * b = o</code>。变量<code class="eh lw lx ly lz b">a</code>和<code class="eh lw lx ly lz b">b</code>也被分别赋值<code class="eh lw lx ly lz b">1-bit</code>和<code class="eh lw lx ly lz b">bit</code>。因此，对于<code class="eh lw lx ly lz b">v</code>的每个位<code class="eh lw lx ly lz b">bit</code>(<code class="eh lw lx ly lz b">(q &gt;&gt; i) &amp; 1</code>返回第<code class="eh lw lx ly lz b">i</code>个最低有效位)，证明者将满足约束<code class="eh lw lx ly lz b">(1-bit)*bit=o</code>并将约束<code class="eh lw lx ly lz b">o</code>为<code class="eh lw lx ly lz b">cs.constrain(o.into())</code>中的0。但是如果你注意到传递给<code class="eh lw lx ly lz b">allocate</code>的闭包可以访问<code class="eh lw lx ly lz b">v</code>的值，这对于验证器来说是不可能的，事实上也不是。闭包只为证明者执行，不为验证者执行。但是这意味着可以将任意值赋给<code class="eh lw lx ly lz b">a</code>和<code class="eh lw lx ly lz b">b</code>，因为只有<code class="eh lw lx ly lz b">o</code>被约束为0，例如a=3和b=0仍然导致a*b=0。这样就需要一个额外的约束，即<code class="eh lw lx ly lz b">a = 1 - b</code> = &gt; <code class="eh lw lx ly lz b"> cs.constrain(a + (b — 1u64))</code> <br/>上面的例子证明了向量的那个元素是位，但仍然不能证明位向量是针对<code class="eh lw lx ly lz b">v</code>的。例如，上述约束系统将满足全0或全1，但这可能不是<code class="eh lw lx ly lz b">v</code>的正确表示。我们需要更多的约束来证明这个位向量是用于<code class="eh lw lx ly lz b">v</code>的。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="b49d" class="kf kg ij lz b fv mi mj l mk ml">pub fn positive_no_gadget&lt;CS: ConstraintSystem&gt;(<br/>    cs: &amp;mut CS,<br/>    v: AllocatedQuantity,<br/>    n: usize<br/>    ,) -&gt; Result&lt;(), R1CSError&gt; {<br/>    let mut constraint_v = vec![(v.variable, -Scalar::<em class="ke">one</em>())];<br/>    let mut exp_2 = Scalar::<em class="ke">one</em>();<br/>    for i in 0..n {<br/>        // Create low-level variables and add them to constraints<br/>        let (a, b, o) = cs.allocate(|| {<br/>            ....<br/>        })?;<br/>        // Enforce a * b = 0, so one of (a,b) is zero<br/>        // Enforce that a = 1 - b, so they both are 1 or 0.<br/>        ....<br/>        constraint_v.push((b, exp_2)  );<br/>        exp_2 = exp_2 + exp_2;<br/>    }<br/><br/>    // Enforce that -v + Sum(b_i * 2^i, i = 0..n-1) = 0 =&gt; Sum(b_i * 2^i, i = 0..n-1) = v<br/>    cs.constrain(constraint_v.iter().collect());<br/><br/>    <em class="ke">Ok</em>(())<br/>}</span></pre><p id="3131" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们从线性组合的向量<code class="eh lw lx ly lz b">constraint_v</code>开始，负的<code class="eh lw lx ly lz b">v</code>是它的第一项。然后对于<code class="eh lw lx ly lz b">v</code>的每一位，我们将该位乘以适当的2的幂，并将结果加到<code class="eh lw lx ly lz b">constraint_v.push((b, exp_2))</code>中的上述线性组合中。最后，对线性组合的所有项求和，结果为0。<code class="eh lw lx ly lz b">cs.constrain(constraint_v.iter().collect())</code>表示将<code class="eh lw lx ly lz b">constraint_v</code>的所有项相加，并确保总和为0。类型<code class="eh lw lx ly lz b">AllocatedQuantity</code>是提交变量的包装器。完整的代码是<a class="ae ig" href="https://github.com/lovesh/bulletproofs/blob/aa2b0a5e7815080c0125d321903ad160a6409689/tests/utils.rs#L85" rel="noopener ugc nofollow" target="_blank">这里是</a>。<br/>现在我们可以用上面的<code class="eh lw lx ly lz b">positive_no_gadget</code>来证明<code class="eh lw lx ly lz b">x-min</code>和<code class="eh lw lx ly lz b">max — x</code>都在[0，2ⁿ).这看起来很好，但证明者仍然可以欺骗。由于证明者只对<code class="eh lw lx ly lz b">x-min</code>和<code class="eh lw lx ly lz b">max-x</code>给出承诺，他可以通过在承诺中使用不同的<code class="eh lw lx ly lz b">x</code>来欺骗，因此一个承诺在<code class="eh lw lx ly lz b">x-min</code>之上，另一个在<code class="eh lw lx ly lz b">max-y</code>之上。这可以通过确保将两个提交值相加得到结果<code class="eh lw lx ly lz b">max-min</code>来解决。设a = x-min，b=max-x，证明者承诺<code class="eh lw lx ly lz b">v</code>、<code class="eh lw lx ly lz b">a</code>和<code class="eh lw lx ly lz b">b</code>。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="bacb" class="kf kg ij lz b fv mi mj l mk ml">let (com_v, var_v) = prover.commit(v.into(), Scalar::<em class="ke">random</em>(&amp;mut rng));<br/>let quantity_v = AllocatedQuantity {<br/>    variable: var_v,<br/>    assignment: <em class="ke">Some</em>(v),<br/>};</span><span id="118a" class="kf kg ij lz b fv mm mj l mk ml">let (com_a, var_a) = prover.commit(a.into(), Scalar::<em class="ke">random</em>(&amp;mut rng));<br/>let quantity_a = AllocatedQuantity {<br/>    variable: var_a,<br/>    assignment: <em class="ke">Some</em>(a),<br/>};</span><span id="de6f" class="kf kg ij lz b fv mm mj l mk ml">let (com_b, var_b) = prover.commit(b.into(), Scalar::<em class="ke">random</em>(&amp;mut rng));<br/>let quantity_b = AllocatedQuantity {<br/>    variable: var_b,<br/>    assignment: <em class="ke">Some</em>(b),<br/>};</span></pre><p id="62cd" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">校准者将<code class="eh lw lx ly lz b">v</code>、<code class="eh lw lx ly lz b">a</code>和<code class="eh lw lx ly lz b">b</code>的变量传递给<code class="eh lw lx ly lz b">bound_check_gadget</code>，确保<code class="eh lw lx ly lz b">v</code>在<code class="eh lw lx ly lz b">min</code>、<code class="eh lw lx ly lz b">max</code>中。然后他创造证据。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="753d" class="kf kg ij lz b fv mi mj l mk ml">assert!(bound_check_gadget(&amp;mut prover, quantity_v, quantity_a, quantity_b, max, min, n).is_ok());<br/><br/>let proof = prover.prove()?;</span></pre><p id="efb5" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh lw lx ly lz b">bound_check_gadget</code>确保a+b = max-min且a和b都在[0，2ⁿ).完整的代码是<a class="ae ig" href="https://github.com/lovesh/bulletproofs/blob/0b1a76c28641d79765c937df60b776c8ce48cb77/tests/gadget_bound_check.rs" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="34ee" class="kf kg ij lz b fv mi mj l mk ml">pub fn bound_check_gadget&lt;CS: ConstraintSystem&gt;(<br/>    cs: &amp;mut CS,<br/>    v: AllocatedQuantity,<br/>    a: AllocatedQuantity,<br/>    b: AllocatedQuantity,<br/>    max: u64,<br/>    min: u64,<br/>    n: usize<br/>) -&gt; Result&lt;(), R1CSError&gt; {<br/>    // a + b = max - min<br/>    let lc_max_minus_min: LinearCombination = vec![(Variable::<em class="ke">One</em>(), Scalar::<em class="ke">from</em>(max-min))].iter().collect();<br/><br/>    // Constrain a + b to be same as max - min.<br/>    cs.constrain(a.variable + b.variable - lc_max_minus_min);<br/><br/>    // Constrain a in [0, 2^n)<br/>    assert!(positive_no_gadget(cs, a, n).is_ok());<br/>    // Constrain b in [0, 2^n)<br/>    assert!(positive_no_gadget(cs, b, n).is_ok());<br/><br/>    <em class="ke">Ok</em>(())<br/>}</span></pre><h2 id="7f8b" class="kf kg ij bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">承诺值非零的证明</h2><p id="9c85" class="pw-post-body-paragraph jg jh ij ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hm dt translated">经常需要证明某个值是非零的，而不需要揭示它，只需要提交它，我们将在下面的集合非成员证明中看到它的用法。另一种用法是证明某个值不等于某个值，因为证明<code class="eh lw lx ly lz b">x</code>不等于<code class="eh lw lx ly lz b">c</code>，证明<code class="eh lw lx ly lz b">x-c</code>不等于0就足够了。这个证明是基于下面的观察(不是我的)。说你要证明<code class="eh lw lx ly lz b">x</code>不等于0。计算<code class="eh lw lx ly lz b">x</code>的逆，称之为<code class="eh lw lx ly lz b">inv</code>。让<code class="eh lw lx ly lz b">y = if x!=0 then 1 else 0</code>。<code class="eh lw lx ly lz b">inv</code> = 0当<code class="eh lw lx ly lz b">x</code> =0否则<code class="eh lw lx ly lz b">inv</code> = <code class="eh lw lx ly lz b">x</code> ⁻。现在以下两个等式成立:I)x *(1-y)= 0(T27)ii)x * inv = y(T28)证明者首先提交<code class="eh lw lx ly lz b">x</code>及其逆<code class="eh lw lx ly lz b">inv</code>，然后满足以上两个约束。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="67f0" class="kf kg ij lz b fv mi mj l mk ml">let (com_val, var_val) = prover.commit(value.clone(), Scalar::<em class="ke">random</em>(&amp;mut rng));<br/>let alloc_scal = AllocatedScalar {<br/>    variable: var_val,<br/>    assignment: <em class="ke">Some</em>(value),<br/>};</span><span id="975a" class="kf kg ij lz b fv mm mj l mk ml">let inv = value.invert();<br/>let (com_val_inv, var_val_inv) = prover.commit(inv.clone(), Scalar::<em class="ke">random</em>(&amp;mut rng));<br/>let alloc_scal_inv = AllocatedScalar {<br/>    variable: var_val_inv,<br/>    assignment: <em class="ke">Some</em>(inv),<br/>};<br/>assert!(is_nonzero_gadget(&amp;mut prover, alloc_scal, alloc_scal_inv).is_ok());</span></pre><p id="72eb" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">以下是一些限制因素</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="c5df" class="kf kg ij lz b fv mi mj l mk ml">pub fn is_nonzero_gadget&lt;CS: ConstraintSystem&gt;(<br/>    cs: &amp;mut CS,<br/>    x: AllocatedScalar,<br/>    x_inv: AllocatedScalar,<br/>) -&gt; Result&lt;(), R1CSError&gt; {<br/>    let y: u32 = 1;<br/><br/>    let x_lc: LinearCombination = vec![(x.variable, Scalar::<em class="ke">one</em>())].iter().collect();<br/>    let one_minus_y_lc: LinearCombination = vec![(Variable::<em class="ke">One</em>(), Scalar::<em class="ke">from</em>(1-y))].iter().collect();<br/>    let y_lc: LinearCombination = vec![(Variable::<em class="ke">One</em>(), Scalar::<em class="ke">from</em>(y))].iter().collect();<br/><br/>    // x * (1-y) = 0<br/>    let (_, _, o1) = cs.multiply(x_lc.clone(), one_minus_y_lc);<br/>    cs.constrain(o1.into());<br/><br/>    // x * x_inv = y<br/>    let inv_lc: LinearCombination = vec![(x_inv.variable, Scalar::<em class="ke">one</em>())].iter().collect();<br/>    let (_, _, o2) = cs.multiply(x_lc.clone(), inv_lc.clone());<br/>    // Output wire should have value `y`<br/>    cs.constrain(o2 - y_lc);<br/><br/>    // Ensure x_inv is the really the inverse of x by ensuring x*x_inv = 1<br/>    let (_, x_inv_var, o3) = cs.multiply(x_lc, inv_lc);<br/>    // Output wire should be 1<br/>    let one_lc: LinearCombination = vec![(Variable::<em class="ke">One</em>(), Scalar::<em class="ke">one</em>())].iter().collect();<br/>    cs.constrain(o3 - one_lc);<br/>    <em class="ke">Ok</em>(())<br/>}</span></pre><p id="b0f8" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">注意，前两个约束<code class="eh lw lx ly lz b">cs.constrain(o1.into())</code>和<code class="eh lw lx ly lz b">cs.constrain(o2 — y_lc)</code>对应于上面的两个等式，但还有第三个约束检查<code class="eh lw lx ly lz b">inv</code>是否实际上是<code class="eh lw lx ly lz b">x</code>的逆。这是必要的，因为证明者只将<code class="eh lw lx ly lz b">x</code>和<code class="eh lw lx ly lz b">inv</code> ( <code class="eh lw lx ly lz b">x</code> ⁻)的承诺给验证者，并且证明者可能通过不给出相反的值而给出其他值来欺骗。所以验证者确保<code class="eh lw lx ly lz b">inv</code>实际上是逆的。完整的代码是<a class="ae ig" href="https://github.com/lovesh/bulletproofs/blob/01f36edcc09a553762bcb519d41bc92bb0727498/tests/gadget_zero_nonzero.rs#L65" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><h2 id="61d4" class="kf kg ij bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">证明承诺值不等于给定值</h2><p id="237e" class="pw-post-body-paragraph jg jh ij ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hm dt translated">证明你的值<code class="eh lw lx ly lz b">v</code>不等于给定的<code class="eh lw lx ly lz b">c</code>和证明<br/> <code class="eh lw lx ly lz b">v — c != 0</code>是一样的。所以我们利用上面的<code class="eh lw lx ly lz b">is_nonzero_gadget</code>。完整的代码是<a class="ae ig" href="https://github.com/lovesh/bulletproofs/blob/range-proof/tests/gadget_not_equals.rs" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><h2 id="6b62" class="kf kg ij bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">设置非成员</h2><p id="8ed3" class="pw-post-body-paragraph jg jh ij ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hm dt translated">证明者可能需要证明他的承诺值不在集合中，例如，假设有一个公共集合<code class="eh lw lx ly lz b">S</code> as [2，9，78，44，55]并且证明者的承诺值<code class="eh lw lx ly lz b">v</code>是12，他不希望验证者知道他的值是12，而只是知道他的值不在集合中。其思想是证明者可以从每个集合元素中减去他的值，并证明每个结果都是非零的，即对于每个集合索引<code class="eh lw lx ly lz b">i</code>。所以证明者首先提交他的值，然后提交每个集合元素和他的值的差，以及每个差的倒数，<code class="eh lw lx ly lz b">2*n+1</code>总共提交，其中<code class="eh lw lx ly lz b">n</code>是集合中元素的数量。需要对差值的倒数进行承诺，以证明差值<em class="ke">非零</em>，如前一示例所示。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="2486" class="kf kg ij lz b fv mi mj l mk ml">let mut comms: Vec&lt;CompressedRistretto&gt; = vec![];<br/>let mut diff_vars: Vec&lt;AllocatedScalar&gt; = vec![];<br/>let mut diff_inv_vars: Vec&lt;AllocatedScalar&gt; = vec![];</span><span id="35ea" class="kf kg ij lz b fv mm mj l mk ml">let (com_value, var_value) = prover.commit(value.clone(), Scalar::<em class="ke">random</em>(&amp;mut rng));<br/>let alloc_scal = AllocatedScalar {<br/>    variable: var_value,<br/>    assignment: <em class="ke">Some</em>(value),<br/>};</span><span id="3937" class="kf kg ij lz b fv mm mj l mk ml">for i in 0..set_length {<br/>    let elem = Scalar::<em class="ke">from</em>(set[i]);<br/>    let diff = elem - value;<br/>    let diff_inv = diff.invert();<br/><br/>    // Take difference of set element and value, `set[i] - value`<br/>    let (com_diff, var_diff) = prover.commit(diff.clone(), Scalar::<em class="ke">random</em>(&amp;mut rng));<br/>    let alloc_scal_diff = AllocatedScalar {<br/>        variable: var_diff,<br/>        assignment: <em class="ke">Some</em>(diff),<br/>    };<br/>    diff_vars.push(alloc_scal_diff);<br/>    comms.push(com_diff);<br/><br/>    // Inverse needed to prove that difference `set[i] - value` is non-zero<br/>    let (com_diff_inv, var_diff_inv) = prover.commit(diff_inv.clone(), Scalar::<em class="ke">random</em>(&amp;mut rng));<br/>    let alloc_scal_diff_inv = AllocatedScalar {<br/>        variable: var_diff_inv,<br/>        assignment: <em class="ke">Some</em>(diff_inv),<br/>    };<br/>    diff_inv_vars.push(alloc_scal_diff_inv);<br/>    comms.push(com_diff_inv);<br/>}</span><span id="1ad6" class="kf kg ij lz b fv mm mj l mk ml">assert!(set_non_membership_gadget(&amp;mut prover, alloc_scal, diff_vars, diff_inv_vars, &amp;set).is_ok());</span></pre><p id="56b1" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">与上述承诺相对应的变量用于以下约束条件中</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="8b61" class="kf kg ij lz b fv mi mj l mk ml">pub fn set_non_membership_gadget&lt;CS: ConstraintSystem&gt;(<br/>    cs: &amp;mut CS,<br/>    v: AllocatedScalar,<br/>    diff_vars: Vec&lt;AllocatedScalar&gt;,<br/>    diff_inv_vars: Vec&lt;AllocatedScalar&gt;,<br/>    set: &amp;[u64]<br/>) -&gt; Result&lt;(), R1CSError&gt; {<br/>    let set_length = set.len();<br/><br/>    for i in 0..set_length {<br/>        // Take difference of value and each set element, `v - set[i]`<br/>        let elem_lc: LinearCombination = vec![(Variable::<em class="ke">One</em>(), Scalar::<em class="ke">from</em>(set[i]))].iter().collect();<br/>        let v_minus_elem = v.variable - elem_lc;<br/><br/>        // Since `diff_vars[i]` is `set[i] - v`, `v - set[i]` + `diff_vars[i]` should be 0<br/>        cs.constrain(diff_vars[i].variable + v_minus_elem);<br/><br/>        // Ensure `set[i] - v` is non-zero<br/>        is_nonzero_gadget(cs, diff_vars[i], diff_inv_vars[i])?;<br/>    }<br/><br/>    <em class="ke">Ok</em>(())<br/>}</span></pre><p id="b6dc" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">注意，在上述约束中，除了非零约束之外，每个集合元素还有附加约束。需要这个约束来确保校准者对每个设置的索引<code class="eh lw lx ly lz b">i</code>使用<code class="eh lw lx ly lz b">S[i] — v != 0</code>中相同的<code class="eh lw lx ly lz b">v</code>。这是通过为<code class="eh lw lx ly lz b">v-S[i]</code>创建一个变量，并将其添加到上述差值中，并将结果约束为0来实现的。完整的代码是<a class="ae ig" href="https://github.com/lovesh/bulletproofs/blob/01f36edcc09a553762bcb519d41bc92bb0727498/tests/gadget_set_non_membership.rs" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><h2 id="5f5b" class="kf kg ij bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">设置成员证明</h2><p id="f404" class="pw-post-body-paragraph jg jh ij ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hm dt translated">证明者可能需要证明他的承诺值在集合<code class="eh lw lx ly lz b">S</code>中，但不需要透露他的值<code class="eh lw lx ly lz b">v</code>。这是这个想法(摘自<a class="ae ig" href="https://github.com/HarryR/ethsnarks/blob/master/src/gadgets/one_of_n.hpp" rel="noopener ugc nofollow" target="_blank"> ethsnarks </a> repo) <br/> 1。证明者创建对应于集合的位向量，其中集合的每个元素1位。所有位都是0。<br/> 2。证明者将位向量中的位设置在其值<code class="eh lw lx ly lz b">v</code>的索引处。例如，如果set <code class="eh lw lx ly lz b">S</code>是[5，9，1，100，200]并且证明者的值是100，则位向量将是[0，0，0，1，0]。<br/> 3。证明者然后证明<br/> i)比特向量的每个元素实际上是一个比特，<br/> ii)通过将所有比特相加并且证明总和为1，比特向量中只有1个比特集合。<br/> iii)对于每个设定指标<code class="eh lw lx ly lz b">i</code>，该关系成立<code class="eh lw lx ly lz b">set[i] * bitvec[i] = bitvec[i] * v</code>。这应该成立，因为除了索引<code class="eh lw lx ly lz b">v</code>之外，所有<code class="eh lw lx ly lz b">i</code>的<code class="eh lw lx ly lz b">bitvec[i]</code>都是0。</p><p id="e556" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">证明者首先创建位向量并提交给每一位。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="e8e1" class="kf kg ij lz b fv mi mj l mk ml">let bit_map: Vec&lt;u64&gt; = set.iter().map( | elem | {<br/>    if *elem == value { 1 } else { 0 }<br/>}).collect();</span><span id="c129" class="kf kg ij lz b fv mm mj l mk ml">let mut comms = vec![];<br/>let mut bit_vars = vec![];<br/>for b in bit_map {<br/>    let (com, var) = prover.commit(b.into(), Scalar::<em class="ke">random</em>(&amp;mut rng));<br/>    let quantity = AllocatedQuantity {<br/>        variable: var,<br/>        assignment: <em class="ke">Some</em>(b),<br/>    };<br/>    assert!(bit_gadget(&amp;mut prover, quantity).is_ok());<br/>    comms.push(com);<br/>    bit_vars.push(quantity);<br/>}</span></pre><p id="7a95" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了证明某个值是位，使用了基于关系式<code class="eh lw lx ly lz b">bit*(1-bit)=0</code>的<code class="eh lw lx ly lz b">bit_gadget</code>。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="1610" class="kf kg ij lz b fv mi mj l mk ml">pub fn bit_gadget&lt;CS: ConstraintSystem&gt;(<br/>    cs: &amp;mut CS,<br/>    v: AllocatedQuantity<br/>) -&gt; Result&lt;(), R1CSError&gt; {<br/>    let (a, b, o) = cs.allocate(|| {<br/>        let bit: u64 = v.assignment.ok_or(R1CSError::<em class="ke">MissingAssignment</em>)?;<br/>        <em class="ke">Ok</em>(((1 - bit).into(), bit.into(), Scalar::<em class="ke">zero</em>()))<br/>    })?;<br/><br/>    // Variable b is same as v so b + (-v) = 0<br/>    let neg_v: LinearCombination = vec![(v.variable, -Scalar::<em class="ke">one</em>())].iter().collect();<br/>    cs.constrain(b + neg_v);<br/><br/>    // Enforce a * b = 0, so one of (a,b) is zero<br/>    cs.constrain(o.into());<br/><br/>    // Enforce that a = 1 - b, so they both are 1 or 0.<br/>    cs.constrain(a + (b - 1u64));<br/><br/>    <em class="ke">Ok</em>(())<br/>}</span></pre><p id="3e7c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">请注意，需要<code class="eh lw lx ly lz b">cs.constrain(b + neg_v)</code>来确保证明者为变量<code class="eh lw lx ly lz b">b</code>分配与<code class="eh lw lx ly lz b">v</code>中提交的值相同的值。</p><p id="01e9" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在，证明者通过对向量求和并将结果与1进行比较，来确保向量中只有1位设置。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="70d9" class="kf kg ij lz b fv mi mj l mk ml">assert!(vector_sum_gadget(&amp;mut prover, &amp;bit_vars, 1).is_ok());</span></pre><p id="ad0d" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">下面是一个矢量和小工具，可以用来比较给定矢量和给定值。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="95a3" class="kf kg ij lz b fv mi mj l mk ml">// Ensure sum of items of `vector` is `sum`<br/>pub fn vector_sum_gadget&lt;CS: ConstraintSystem&gt;(<br/>    cs: &amp;mut CS,<br/>    vector: &amp;[AllocatedQuantity],<br/>    sum: u64<br/>) -&gt; Result&lt;(), R1CSError&gt; {<br/>    let mut constraints: Vec&lt;(Variable, Scalar)&gt; = vec![(Variable::<em class="ke">One</em>(), -Scalar::<em class="ke">from</em>(sum))];<br/>    for i in vector {<br/>        constraints.push((i.variable, Scalar::<em class="ke">one</em>()));<br/>    }<br/><br/>    cs.constrain(constraints.iter().collect());<br/><br/>    <em class="ke">Ok</em>(())<br/>}</span></pre><p id="cc16" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">注意，线性组合<code class="eh lw lx ly lz b">constraints</code>的第一项是负的<code class="eh lw lx ly lz b">sum</code>，并且该线性组合的所有项的总和被约束为0。</p><p id="b99f" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在，证明者通过提交值并使用已经为提交的位向量分配的变量来满足最终乘积关系<code class="eh lw lx ly lz b">set[i] * bitvec[i] = bitvec[i] * v</code>。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="9213" class="kf kg ij lz b fv mi mj l mk ml">let (com_value, var_value) = prover.commit(value.into(), Scalar::<em class="ke">random</em>(&amp;mut rng));<br/>let quantity_value = AllocatedQuantity {<br/>    variable: var_value,<br/>    assignment: <em class="ke">Some</em>(value),<br/>};<br/>assert!(vector_product_gadget(&amp;mut prover, &amp;set, &amp;bit_vars, &amp;quantity_value).is_ok());</span></pre><p id="dbfd" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh lw lx ly lz b">vector_product_gadget</code></p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="aca8" class="kf kg ij lz b fv mi mj l mk ml">// Ensure items[i] * vector[i] = vector[i] * value<br/>pub fn vector_product_gadget&lt;CS: ConstraintSystem&gt;(<br/>    cs: &amp;mut CS,<br/>    items: &amp;[u64],<br/>    vector: &amp;[AllocatedQuantity],<br/>    value: &amp;AllocatedQuantity<br/>) -&gt; Result&lt;(), R1CSError&gt; {<br/>    let mut constraints = vec![(value.variable, -Scalar::<em class="ke">one</em>())];<br/><br/>    for i in 0..items.len() {<em class="ke"><br/>        </em>let (a, b, o) = cs.allocate(|| {<br/>            let bit: u64 = vector[i].assignment.ok_or(R1CSError::<em class="ke">MissingAssignment</em>)?;<br/>            let val = value.assignment.ok_or(R1CSError::<em class="ke">MissingAssignment</em>)?;<br/>            <em class="ke">Ok</em>((items[i].into(), bit.into(), (bit*val).into()))<br/>        })?;<br/><br/>        constraints.push((o, Scalar::<em class="ke">one</em>()));<br/><br/>        let item_var: LinearCombination = vec![(Variable::<em class="ke">One</em>(), items[i].into())].iter().collect();<br/>        cs.constrain(a - item_var);<br/><br/>        // Each `b` is already constrained to be 0 or 1<br/>    }<br/><br/>    // Constrain the sum of output variables to be equal to the value of committed variable<br/>    cs.constrain(constraints.iter().collect());<br/><br/>    <em class="ke">Ok</em>(())<br/>}</span></pre><p id="1c29" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">注意约束<code class="eh lw lx ly lz b">cs.constrain(a — item_var)</code>。验证者确保由证明者分配给变量<code class="eh lw lx ly lz b">a</code>的值等于该索引处的集合项的值。完整的代码是<a class="ae ig" href="https://github.com/lovesh/bulletproofs/blob/548f71b31abf4079e1a68ae8322233b540f0ab5e/tests/gadget_set_membership.rs" rel="noopener ugc nofollow" target="_blank">这里是</a>。<br/>还有另外一种证明集合成员关系的方法<em class="ke">。它依赖于这样的思想:如果一个元素存在于集合中，那么通过取每个集合项和这个元素的差而构造的向量将包含1个零值。所以如果我们把这个新向量的所有元素相乘，乘积将是0。证明者承诺每个集合项的值及其差值，并调用新的集合成员小工具<code class="eh lw lx ly lz b">set_membership_1_gadget</code></em></p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="a654" class="kf kg ij lz b fv mi mj l mk ml">let (com_value, var_value) = prover.commit(value.clone(), Scalar::<em class="ke">random</em>(&amp;mut rng));<br/>let alloc_scal = AllocatedScalar {<br/>    variable: var_value,<br/>    assignment: <em class="ke">Some</em>(value),<br/>};<br/>comms.push(com_value);<br/><br/>for i in 0..set_length {<br/>    let elem = Scalar::<em class="ke">from</em>(set[i]);<br/>    let diff = elem - value;<br/><br/>    // Take difference of set element and value, `set[i] - value`<br/>    let (com_diff, var_diff) = prover.commit(diff.clone(), Scalar::<em class="ke">random</em>(&amp;mut rng));<br/>    let alloc_scal_diff = AllocatedScalar {<br/>        variable: var_diff,<br/>        assignment: <em class="ke">Some</em>(diff),<br/>    };<br/>    diff_vars.push(alloc_scal_diff);<br/>    comms.push(com_diff);<br/>}<br/><br/>assert!(set_membership_1_gadget(&amp;mut prover, alloc_scal, diff_vars, &amp;set).is_ok());</span></pre><p id="a370" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在<code class="eh lw lx ly lz b">set_membership_1_gadget</code>中，<code class="eh lw lx ly lz b">diff_vars</code>元素的乘积被约束为0。完整的代码是<a class="ae ig" href="https://github.com/lovesh/bulletproofs/blob/range-proof/tests/gadget_set_membership_1.rs" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><pre class="ma mb mc md fq me lz mf mg aw mh dt"><span id="aa8a" class="kf kg ij lz b fv mi mj l mk ml">pub fn set_membership_1_gadget&lt;CS: ConstraintSystem&gt;(<br/>    cs: &amp;mut CS,<br/>    v: AllocatedScalar,<br/>    diff_vars: Vec&lt;AllocatedScalar&gt;,<br/>    set: &amp;[u64]<br/>) -&gt; Result&lt;(), R1CSError&gt; {<br/>    let set_length = set.len();<br/>    // Accumulates product of elements in `diff_vars`<br/>    let mut product: LinearCombination = Variable::<em class="ke">One</em>().into();<br/><br/>    for i in 0..set_length {<br/>        // Take difference of value and each set element, `v - set[i]`<br/>        let elem_lc: LinearCombination = vec![(Variable::<em class="ke">One</em>(), Scalar::<em class="ke">from</em>(set[i]))].iter().collect();<br/>        let v_minus_elem = v.variable - elem_lc;<br/><br/>        // Since `diff_vars[i]` is `set[i] - v`, `v - set[i]` + `diff_vars[i]` should be 0<br/>        cs.constrain(diff_vars[i].variable + v_minus_elem);<br/><br/>        let (_, _, o) = cs.multiply(product.clone(), diff_vars[i].variable.into());<br/>        product = o.into();<br/>    }<br/><br/>    // Ensure product of elements if `diff_vars` is 0<br/>    cs.constrain(product);<br/><br/>    <em class="ke">Ok</em>(())<br/>}</span></pre><blockquote class="mn"><p id="1ee7" class="mo mp ij bd mq mr ms mt mu mv mw kd ek translated"><a class="ae ig" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="my mz na nb nc hv fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mx"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>