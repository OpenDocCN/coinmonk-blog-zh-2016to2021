<html>
<head>
<title>Getting started with Ligo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ligo入门</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/getting-started-with-ligo-13ea2c4e844e?source=collection_archive---------2-----------------------#2020-02-21">https://medium.com/coinmonks/getting-started-with-ligo-13ea2c4e844e?source=collection_archive---------2-----------------------#2020-02-21</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="5357" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">使用Ligo为Tezos区块链创建智能合约(第1部分)</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/45153c0b22e7b7fc458ef439f778767e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nJEh-A46g9mz0rrUnAQICQ.jpeg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">LigoLang</figcaption></figure><p id="dc23" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">在我写完第一篇关于流动性的文章后，我在Twitter上进行了一次非常有趣的交流。其中，据我所知，Liquidity正在远离Tezos，转而致力于Dune network，Tezos平台上语言的未来可能不确定。</p><p id="4faf" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">由于我想为我的编程(和我的一般知识)保留一种函数式语言，我看了一下Tezos的另一种流行的函数式语言，LigoLang(或Ligo)。这不是我的第一选择，因为在线编辑器中没有契约的例子，除了我们将在本教程中讨论的“简单存储”的例子。网站上还有一个教程，对于精通OCaml的人来说可能不错，但对我来说太模糊了。</p><p id="750a" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">于是我决定在探索Tezos开发生态系统的过程中采用Ligo，并写一篇关于它的基础教程，这将帮助我更好地理解这种语言，并且(我希望)帮助其他可能遇到同样障碍的人。和Liquidity一样，我会选择ReasonML语法，我相信对于像我这样来自JavaScript或Solidity的开发者来说，它看起来更容易。</p><p id="0e63" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">我们将在Ligo网站的编辑器中写下<a class="ae ku" href="https://ide.ligolang.org/p/QlLBsoG1-gF-zQYiKeVNlQ" rel="noopener ugc nofollow" target="_blank">这个合同</a>。契约增加和减少存储中的变量。这是一个很好的例子，因为它将介绍用Ligo编写智能合同的细节。</p><h1 id="27da" class="kv kw ht bd kx ky kz la lb lc ld le lf iz lg ja lh jc li jd lj jf lk jg ll lm dt translated">合同的结构</h1><h2 id="6a64" class="ln kw ht bd kx lo lp lq lb lr ls lt lf kh lu lv lh kl lw lx lj kp ly lz ll ma dt translated">仓库</h2><p id="cc30" class="pw-post-body-paragraph jy jz ht ka b kb mb iu kd ke mc ix kg kh md kj kk kl me kn ko kp mf kr ks kt hm dt translated">区块链上的每个<a class="ae ku" href="https://blog.coincodecap.com/tag/smart-contact/" rel="noopener ugc nofollow" target="_blank">智能契约</a>都包含一个存储器，它是保存契约状态的内存的一部分。Ligo也不例外。存储被声明为与您选择的类型(整数、字符串、记录等)相等的单一类型。)<br/>在这种情况下，我们将创建类型<strong class="ka hu">存储</strong>，它将接收类型<strong class="ka hu"> int </strong>的值:</p><pre class="jj jk jl jm fq mg mh mi mj aw mk dt"><span id="e897" class="ln kw ht mh b fv ml mm l mn mo"><strong class="mh hu">type storage = int;</strong></span></pre><h2 id="a985" class="ln kw ht bd kx lo lp lq lb lr ls lt lf kh lu lv lh kl lw lx lj kp ly lz ll ma dt translated">伪入口点</h2><p id="4254" class="pw-post-body-paragraph jy jz ht ka b kb mb iu kd ke mc ix kg kh md kj kk kl me kn ko kp mf kr ks kt hm dt translated">Ligo中的契约有一个特殊性，即只有一个入口点，即主函数。每个传入的事务都将与一个模式进行匹配，并被重定向到匹配函数。<br/>为了让它工作，我们必须创建一个定义伪多入口点操作的变体。<em class="mp">变量</em>是包含不同案例的类型，其值将根据案例而变化。这是语言的一个非常强大的方面。这是我们合同的例子:</p><pre class="jj jk jl jm fq mg mh mi mj aw mk dt"><span id="8ccc" class="ln kw ht mh b fv ml mm l mn mo">type storage = int;</span><span id="7c32" class="ln kw ht mh b fv mq mm l mn mo"><strong class="mh hu">type action =<br/>| Increment(int)<br/>| Decrement(int);</strong></span></pre><p id="6e5b" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">正如你所看到的，我们声明了一个新的类型叫做“动作”。它可以有两个值:可以递增并接收一个整数，也可以递减并接收一个整数。</p><h2 id="6a87" class="ln kw ht bd kx lo lp lq lb lr ls lt lf kh lu lv lh kl lw lx lj kp ly lz ll ma dt translated">这些功能</h2><p id="ec1a" class="pw-post-body-paragraph jy jz ht ka b kb mb iu kd ke mc ix kg kh md kj kk kl me kn ko kp mf kr ks kt hm dt translated">现在让我们为伪入口点编写函数。我们需要两个函数:一个增加状态，一个减少状态。它们必须接收两个参数:第一个是当前存储，第二个是要加到或减去存储的值。请注意，这是Ligo中的一般模式:您将存储传递给函数，更新它并返回它，没有从函数内部访问<a class="ae ku" href="https://blog.coincodecap.com/tag/smart-contact/" rel="noopener ugc nofollow" target="_blank">智能契约</a>存储。Ligo文档称它们为<em class="mp">【a】</em>和<em class="mp">【b】</em>，但是为了更清楚起见，我们称它们为<em class="mp">【存储】</em>和<em class="mp">【计数】</em>:</p><pre class="jj jk jl jm fq mg mh mi mj aw mk dt"><span id="75b6" class="ln kw ht mh b fv ml mm l mn mo">type storage = int;</span><span id="25b7" class="ln kw ht mh b fv mq mm l mn mo">type action =<br/>| Increment(int)<br/>| Decrement(int);</span><span id="1ce5" class="ln kw ht mh b fv mq mm l mn mo"><strong class="mh hu">let add = ((storage, count): (int, int)): int =&gt; storage + count;<br/>let sub = ((storage, count): (int, int)): int =&gt; storage - count;</strong></span></pre><p id="a6d7" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">如果您不熟悉这个语法，让我们来看看函数:</p><ol class=""><li id="ec37" class="mr ms ht ka b kb kc ke kf kh mt kl mu kp mv kt mw mx my mz dt translated"><strong class="ka hu"> let add </strong>:使用“let”关键字声明函数，后跟函数名(add)。</li><li id="d9fd" class="mr ms ht ka b kb na ke nb kh nc kl nd kp ne kt mw mx my mz dt translated"><strong class="ka hu"> ((storage，count): (int，int)) </strong>:这个块表示我们需要两个参数(实际上是一个<a class="ae ku" href="https://ligolang.org/docs/next/language-basics/sets-lists-tuples/#tuples" rel="noopener ugc nofollow" target="_blank">元组</a>，稍后会详细介绍)，存储空间和要对其加减的数字，两个参数都是整数。</li><li id="a3cc" class="mr ms ht ka b kb na ke nb kh nc kl nd kp ne kt mw mx my mz dt translated"><strong class="ka hu"> : int </strong>:这部分函数表示我们将返回一个整数，这将是我们新的存储。</li><li id="a4c7" class="mr ms ht ka b kb na ke nb kh nc kl nd kp ne kt mw mx my mz dt translated"><strong class="ka hu">存储+计数/存储—计数</strong>:将“计数”变量加或减到存储中并返回。请注意，不需要显式返回。</li></ol><h2 id="1447" class="ln kw ht bd kx lo lp lq lb lr ls lt lf kh lu lv lh kl lw lx lj kp ly lz ll ma dt translated">真正的入口点(主函数)</h2><p id="0778" class="pw-post-body-paragraph jy jz ht ka b kb mb iu kd ke mc ix kg kh md kj kk kl me kn ko kp mf kr ks kt hm dt translated">现在是我们写合同的真正切入点的时候了:</p><pre class="jj jk jl jm fq mg mh mi mj aw mk dt"><span id="0c2f" class="ln kw ht mh b fv ml mm l mn mo">type storage = int;</span><span id="a8f7" class="ln kw ht mh b fv mq mm l mn mo">type action =<br/>| Increment(int)<br/>| Decrement(int);</span><span id="6351" class="ln kw ht mh b fv mq mm l mn mo">let add = ((storage, count): (int, int)): int =&gt; storage + count;<br/>let sub = ((storage, count): (int, int)): int =&gt; storage - count;</span><span id="c713" class="ln kw ht mh b fv mq mm l mn mo"><strong class="mh hu">let main = ((p,s): (action, storage)) =&gt; {<br/>    let storage = <br/>        switch (p) {<br/>            | Increment(n) =&gt; add((s, n))<br/>            | Decrement(n) =&gt; sub((s, n))<br/>        };<br/>    ([]: list(operation), storage);<br/>};</strong></span></pre><p id="f515" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">这实际上比看起来容易！</p><p id="b959" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">Ligo中的一个<a class="ae ku" href="https://blog.coincodecap.com/tag/smart-contact/" rel="noopener ugc nofollow" target="_blank">智能契约</a>必须包含一个<strong class="ka hu"> main </strong>函数，这将是“真正的”入口点。这个函数有两个参数:随事务发送的参数和存储。在本例中，我们将当前存储称为“s ”,新存储称为“storage ”,以避免混淆。(action，storage)部分表示第一个参数的类型是action(我们前面声明的变体)，第二个参数的类型是“storage”(智能协定存储)。</p><p id="bd56" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">接下来，我们将使用新值更新存储。然后，我们将在名为“storage”(我们的新存储)的变量中获得新值。下一行是奇迹发生的地方！</p><h2 id="6c5e" class="ln kw ht bd kx lo lp lq lb lr ls lt lf kh lu lv lh kl lw lx lj kp ly lz ll ma dt translated">开关</h2><p id="f06e" class="pw-post-body-paragraph jy jz ht ka b kb mb iu kd ke mc ix kg kh md kj kk kl me kn ko kp mf kr ks kt hm dt translated">描述Ligo(以及一般的ML语言)中所有复杂的模式匹配有点太长了，超出了本文的范围。如果您不熟悉这个语法，这里有一个简单的方法来理解它:您发送的参数与不同的选项匹配，并且必须是可用选项之一。这使得JavaScript中不可能有未定义的值。<br/>在本例中，“p”被传递给开关，并与两个选项“增量”和“减量”匹配。这是唯一的选择。除此之外，契约将确保传递的值是之前在“action”变量中声明的类型(在本例中是一个整数)。如果参数与其中一个选项匹配，将使用适当的参数调用箭头右侧的关联函数。<br/>比如调用“Increment”并传递“2”，就会调用“add”函数，将“2”添加到存储中。</p><h2 id="99df" class="ln kw ht bd kx lo lp lq lb lr ls lt lf kh lu lv lh kl lw lx lj kp ly lz ll ma dt translated">退回的存储</h2><p id="dc57" class="pw-post-body-paragraph jy jz ht ka b kb mb iu kd ke mc ix kg kh md kj kk kl me kn ko kp mf kr ks kt hm dt translated">main函数返回两个值:操作列表(在本例中是两个空方括号，类型为“list(operation)”)和新存储(由开关的一个选项返回的值)。在事务结束时，新的存储被保存，假设一切都按计划进行。</p><h2 id="a18d" class="ln kw ht bd kx lo lp lq lb lr ls lt lf kh lu lv lh kl lw lx lj kp ly lz ll ma dt translated">编译成迈克尔逊</h2><p id="3118" class="pw-post-body-paragraph jy jz ht ka b kb mb iu kd ke mc ix kg kh md kj kk kl me kn ko kp mf kr ks kt hm dt translated">现在，我们必须确保契约能够正常工作和编译。使用提供的接口很容易做到这一点。在右侧，您会看到一个包含多个选项的栏:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff nf"><img src="../Images/25b37dbbb3cc33c81265f0063164de33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jwKOZXM6ODMZxgakFKtfaQ.png"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Compiler step</figcaption></figure><p id="c902" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">默认情况下，应该已经选择了“编译”选项，您只需单击“运行”按钮。您将获得以下代码:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ng"><img src="../Images/db7dc52e068571bc1cf5c09cb7bb595a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kI0JHqd4YtyoPfaDQ_Xgcg.png"/></div></div></figure><p id="755b" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">如果是这样的话，恭喜你！你编写并编译了你的第一个Ligo代码🥳</p><h1 id="5469" class="kv kw ht bd kx ky kz la lb lc ld le lf iz lg ja lh jc li jd lj jf lk jg ll lm dt translated">丰富</h1><p id="9b9d" class="pw-post-body-paragraph jy jz ht ka b kb mb iu kd ke mc ix kg kh md kj kk kl me kn ko kp mf kr ks kt hm dt translated">现在让我们改进合同！</p><p id="ad5c" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">假设我们希望保存一个作为参数传递的名称。让我们列一个清单，列出我们必须做出的改变:</p><ul class=""><li id="3159" class="mr ms ht ka b kb kc ke kf kh mt kl mu kp mv kt nh mx my mz dt translated">我们必须更改存储类型，因为我们现在必须保存两种不同类型(整数和字符串)的两个不同值。</li><li id="5edc" class="mr ms ht ka b kb na ke nb kh nc kl nd kp ne kt nh mx my mz dt translated">我们必须在我们的<em class="mp">动作</em>变体中添加一个新选项来分派正确的函数并保存名称。</li><li id="b80f" class="mr ms ht ka b kb na ke nb kh nc kl nd kp ne kt nh mx my mz dt translated">我们必须编写函数来将名称保存在存储器中。</li><li id="5bb3" class="mr ms ht ka b kb na ke nb kh nc kl nd kp ne kt nh mx my mz dt translated">我们必须把我们的选项加到主开关上。</li></ul><p id="33d9" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">让我们一步一步来:</p><p id="5332" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">对于存储，我们现在使用一个名为“<a class="ae ku" href="https://ligolang.org/docs/next/language-basics/maps-records/" rel="noopener ugc nofollow" target="_blank">记录</a>的类型，它允许我们存储不同类型的数据:“计数”字段将保存我们递增和递减的整数，而“名称”字段将保存我们发送的字符串:</p><pre class="jj jk jl jm fq mg mh mi mj aw mk dt"><span id="5f39" class="ln kw ht mh b fv ml mm l mn mo"><strong class="mh hu">type storage = {<br/>  count: int,<br/>  name: string<br/>};</strong></span></pre><p id="e3e5" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">我们现在添加一个“SaveName”选项，该选项接受一个指向契约的伪入口点的字符串:</p><pre class="jj jk jl jm fq mg mh mi mj aw mk dt"><span id="034f" class="ln kw ht mh b fv ml mm l mn mo">type storage = {<br/>  count: int,<br/>  name: string<br/>};</span><span id="2b4f" class="ln kw ht mh b fv mq mm l mn mo"><strong class="mh hu">type action =<br/>  | Increment(int)<br/>  | Decrement(int)<br/>  | SaveName(string);</strong></span></pre><p id="e1df" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">现在，让我们(重新)编写更新状态的函数。这里有两件事需要考虑:首先，我们必须从头开始编写一个新函数来存储名称，其次，我们必须更新前面的函数，这些函数当前为存储返回一个整数，而不是一条记录。</p><p id="1093" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">新函数的语法非常相似:我们传递两个参数，当前存储和名称，并返回新的存储:</p><pre class="jj jk jl jm fq mg mh mi mj aw mk dt"><span id="6514" class="ln kw ht mh b fv ml mm l mn mo">let saveName = <br/>  ((s, name): (storage, string)): storage =&gt; {...s, name: name};</span></pre><p id="ac56" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">如果你懂JavaScript，语法看起来一定很熟悉！(这也是我认为ReasonLigo是一个很棒的选择的原因之一。)该函数期望元组具有两个<em class="mp">组件</em>(或值)，一个是“存储”类型，一个是“字符串”类型。为了清楚起见，我将实际的存储称为“s ”,以免与它的类型(也是存储)混淆。<br/>该函数返回存储类型的值。Reason语法允许非常方便的快捷方式来更新和返回记录:首先，<a class="ae ku" href="https://reasonml.github.io/docs/en/record#immutable-update" rel="noopener ugc nofollow" target="_blank">扩展操作符</a>将记录的所有字段复制到一个新记录中，然后，<a class="ae ku" href="https://reasonml.github.io/docs/en/record#syntax-shorthand" rel="noopener ugc nofollow" target="_blank">双关</a>技术允许我们只写与字段名称匹配的值的名称(即"<em class="mp"> name </em>"而不是"<em class="mp"> name: name </em>")。</p><p id="aa14" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">接下来，我们可以更新前面的两个函数:</p><pre class="jj jk jl jm fq mg mh mi mj aw mk dt"><span id="26a5" class="ln kw ht mh b fv ml mm l mn mo">type storage = {<br/>  count: int,<br/>  name: string<br/>};</span><span id="d0c3" class="ln kw ht mh b fv mq mm l mn mo">type action =<br/>| Increment(int)<br/>| Decrement(int)<br/>| SaveName(string);</span><span id="a24f" class="ln kw ht mh b fv mq mm l mn mo"><strong class="mh hu">let add = <br/>  ((s, count): (storage, int)): storage =&gt; <br/>    {...s, count: s.count + count};<br/>let sub = <br/>  ((s, count): (storage, int)): storage =&gt; <br/>    {...s, count: s.count - count};<br/>let saveName = <br/>((s, name): (storage, string)): storage =&gt; {...s, name: name};</strong></span></pre><p id="9c60" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">快到了！现在唯一缺少的是更新主函数的开关，契约的实际入口点:</p><pre class="jj jk jl jm fq mg mh mi mj aw mk dt"><span id="2510" class="ln kw ht mh b fv ml mm l mn mo">type storage = {<br/>  count: int,<br/>  name: string<br/>};</span><span id="7305" class="ln kw ht mh b fv mq mm l mn mo">type action =<br/>| Increment(int)<br/>| Decrement(int)<br/>| SaveName(string);</span><span id="eab6" class="ln kw ht mh b fv mq mm l mn mo">let add = <br/>  ((s, count): (storage, int)): storage =&gt; <br/>    {...s, count: s.count + count};<br/>let sub = <br/>  ((s, count): (storage, int)): storage =&gt; <br/>    {...s, count: s.count - count};<br/>let saveName = <br/>((s, name): (storage, string)): storage =&gt; {...s, name: name};</span><span id="94e0" class="ln kw ht mh b fv mq mm l mn mo"><strong class="mh hu">let main = ((p,s): (action, storage)) =&gt; {<br/>  let storage =<br/>    switch (p) {<br/>    | Increment(n) =&gt; add((s, n))<br/>    | Decrement(n) =&gt; sub((s, n))<br/>    | SaveName(n) =&gt; saveName((s, n))<br/>  };<br/>  ([]: list(operation), storage);<br/>};</strong></span></pre><p id="5b1f" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">在这里！现在让我们确保它能正确编译。选择右栏中的“编译”选项并点击“运行”，如果你得到以下代码，你做到了！</p><pre class="jj jk jl jm fq mg mh mi mj aw mk dt"><span id="f83a" class="ln kw ht mh b fv ml mm l mn mo">{ parameter (or (or (int %decrement) (int %increment)) (string %saveName)) ;<br/>  storage (pair (int %count) (string %name)) ;<br/>  code { DUP ;<br/>         DUP ;<br/>         CDR ;<br/>         DIP { DUP } ;<br/>         SWAP ;<br/>         CAR ;<br/>         IF_LEFT<br/>           { DUP ;<br/>             IF_LEFT<br/>               { DIP 2 { DUP } ;<br/>                 DIG 2 ;<br/>                 DIP { DUP } ;<br/>                 PAIR ;<br/>                 DUP ;<br/>                 CAR ;<br/>                 DUP ;<br/>                 DIP { DUP } ;<br/>                 SWAP ;<br/>                 CAR ;<br/>                 DIP { DIP 2 { DUP } ; DIG 2 ; CDR } ;<br/>                 SUB ;<br/>                 SWAP ;<br/>                 CDR ;<br/>                 SWAP ;<br/>                 PAIR ;<br/>                 DIP { DROP 3 } }<br/>               { DIP 2 { DUP } ;<br/>                 DIG 2 ;<br/>                 DIP { DUP } ;<br/>                 PAIR ;<br/>                 DUP ;<br/>                 CAR ;<br/>                 DUP ;<br/>                 DIP { DUP } ;<br/>                 SWAP ;<br/>                 CAR ;<br/>                 DIP { DIP 2 { DUP } ; DIG 2 ; CDR } ;<br/>                 ADD ;<br/>                 SWAP ;<br/>                 CDR ;<br/>                 SWAP ;<br/>                 PAIR ;<br/>                 DIP { DROP 3 } } ;<br/>             DIP { DROP } }<br/>           { DIP { DUP } ;<br/>             SWAP ;<br/>             DIP { DUP } ;<br/>             PAIR ;<br/>             DUP ;<br/>             CAR ;<br/>             DIP { DUP } ;<br/>             SWAP ;<br/>             CDR ;<br/>             SWAP ;<br/>             CAR ;<br/>             PAIR ;<br/>             DIP { DROP 2 } } ;<br/>         DUP ;<br/>         NIL operation ;<br/>         PAIR ;<br/>         DIP { DROP 4 } } }</span></pre><p id="5f0f" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">如果你对代码有任何问题，或者它不适合你，不要犹豫，在评论中提出问题，我很乐意帮助你😊<br/>你也可以通过点击链接直接在Ligo在线编辑器中查看完整的代码<a class="ae ku" href="https://ide.ligolang.org/p/O6URqlH2e7JmawDRaBfDxA" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="97df" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">这篇文章可以在我的博客<a class="ae ku" href="https://decentradev.netlify.com/#/post/ligo-lesson-1" rel="noopener ugc nofollow" target="_blank">分散发展</a>上找到(文章被托管在IPFS上)。</p><p id="c190" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">在下一篇文章中，我们将使用在线编辑器，并测试我们刚刚编写的代码。<br/>在以后的文章中，我们将开始深入Ligo，学习高级概念来编写更复杂的智能合约。</p><p id="643c" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">回头见！！</p><blockquote class="ni"><p id="11a6" class="nj nk ht bd nl nm nn no np nq nr kt ek translated"><a class="ae ku" rel="noopener" href="/coinmonks/getting-started-with-ligo-part-2-fb0c000e40c6">在此阅读第二部分</a></p><p id="1018" class="nj nk ht bd nl nm nn no np nq nr kt ek translated"><a class="ae ku" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nt nu nv nw nx jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ns"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ny"><img src="../Images/e9dbce386c4f90837b5db529a4c87766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fZu_SfnNF6m_BGbXlsl-A@2x.png"/></div></div></figure></div></div>    
</body>
</html>