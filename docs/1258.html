<html>
<head>
<title>Multi Label Intent Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多标签意图分类</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/multi-label-intent-classification-d4979e261a21?source=collection_archive---------3-----------------------#2018-08-07">https://medium.com/coinmonks/multi-label-intent-classification-d4979e261a21?source=collection_archive---------3-----------------------#2018-08-07</a></blockquote><div><div class="eg hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fj fl is it iu iv ff fg paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="ff fg ir"><img src="../Images/3606b9cc1a00dec8a6bb8b7ddc2487cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KLNwW9qScLRz9x0iBlWZrw.jpeg"/></div></div></figure><p id="44b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有很多应用需要文本分类，或者我们可以说意图分类。现在，所有的东西都需要分类，就像内容一样，产品也经常被分类。</p><p id="21f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是网上绝大多数的文本分类文章和教程都是邮件垃圾过滤(spam vs. ham)、情感分析(正面vs .负面)等二元文本分类。我们现实世界的问题要比这复杂得多。因此，这就是我要在这篇博客中解释的。将文本分类成多个类别。</p><p id="ac42" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">问题陈述:</strong></p><p id="5963" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我为我的GSoC项目(Owasp SKF聊天机器人)开发了这个分类器。问题陈述是针对不同漏洞的安全知识框架知识库。它提供了针对不同漏洞的描述、解决方案和代码示例。所以，我需要对用户的查询进行分类，无论他是要求描述、解决方案还是代码示例。</p><p id="b2c1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我使用了<a class="ae ka" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae ka" href="http://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter Notebook </a>来开发我们的系统，依靠<a class="ae ka" href="http://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn </a>作为机器学习组件。</p><p id="4541" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">数据集的准备:</p><p id="d086" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于任何与分类或机器学习相关的问题，我们首先需要的是格式过于正确的数据。因此，首先我将解释我如何准备意图分类的数据集。</p><pre class="kb kc kd ke fr kf kg kh ki aw kj dt"><span id="afa9" class="kk kl hu kg b fw km kn l ko kp">import json<br/>import csv<br/>with open("data.json",encoding='utf-8') as read_file:<br/> data = json.load(read_file)</span></pre><p id="53d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可以在这里查看data.json <a class="ae ka" href="https://github.com/Priya997/SKF-Chatbot/blob/master/Basic_Approach/Scripts_to_prepare_dataset/data.json" rel="noopener ugc nofollow" target="_blank">。我将准备CSV格式的数据集，因为它很容易训练模型。</a></p><pre class="kb kc kd ke fr kf kg kh ki aw kj dt"><span id="2491" class="kk kl hu kg b fw km kn l ko kp">#For parsing the Json<br/>a=data['items']<br/>#Declaration of lists</span><span id="38c4" class="kk kl hu kg b fw kq kn l ko kp">title=[]<br/>ques=[]<br/>sol=[]<br/>code=[]</span><span id="8b00" class="kk kl hu kg b fw kq kn l ko kp">#For accessing the title from Json and storing it in the list.<br/>for d in a: <br/> title.append((d['title']))</span></pre><p id="3c9e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的文本分类是针对问答类系统的。因此，我需要生成问题，因为我提取了列表中的所有标题。</p><pre class="kb kc kd ke fr kf kg kh ki aw kj dt"><span id="2d04" class="kk kl hu kg b fw km kn l ko kp">for t in title:<br/>	ques.append("What is "+ t + " ?")<br/>	ques.append("What does "+ t + " mean ?")<br/>	ques.append("Tell me something about "+ t + " ?")<br/>	ques.append(t)<br/>	ques.append("Explain " + t +" ?")<br/>	ques.append("Elaborate " + t +" ?")<br/>	ques.append("Can you tell me about " + t + " ?")<br/>	ques.append("What do you know about " + t + " ?")<br/>	ques.append("What can you tell me about " + t + " ?")<br/>	ques.append("I want to know about XSS " + t )<br/>	ques.append("Do you have information about " + t + " ?")</span><span id="232c" class="kk kl hu kg b fw kq kn l ko kp">for t in title:<br/> sol.append("How to solve "+ t + " ?")<br/> sol.append("How to resolve "+ t + " ?")<br/> sol.append("How to mitigate "+ t + " ?")<br/> sol.append("Solution for "+ t)<br/> sol.append("Provide me some Solution for "+ t)<br/> sol.append("mitigation for "+ t)<br/> sol.append("How to stop "+ t + " ?")<br/> sol.append("How to defend "+ t + " ?")<br/> sol.append("How to get secured against "+ t + " ?")<br/> sol.append("Solution, "+t)</span><span id="9130" class="kk kl hu kg b fw kq kn l ko kp">for t in title:<br/> code.append("Give me some sample code of "+ t )<br/> code.append("Code example of "+ t + " ?")<br/> code.append("Code of "+ t )</span></pre><p id="4c90" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，问题需要根据描述、解决方案和代码进行分类。所以，我做了三个列表，每个列表存储一个问题。</p><pre class="kb kc kd ke fr kf kg kh ki aw kj dt"><span id="f30e" class="kk kl hu kg b fw km kn l ko kp">file=open("intent_data.csv","x")<br/>file.write('class,question\n')<br/>for x in ques:<br/> x=x.replace(",","")<br/> file.write('Description, '+x+"\n") <br/>for y in sol:<br/> y=y.replace(",","")<br/> file.write('Solution, '+y+"\n")</span><span id="6483" class="kk kl hu kg b fw kq kn l ko kp">for z in code:<br/> z=z.replace(",","")<br/> file.write('Code, '+z+"\n")</span><span id="a695" class="kk kl hu kg b fw kq kn l ko kp">file.close()</span></pre><figure class="kb kc kd ke fr iv ff fg paragraph-image"><div class="ab fs cl kr"><img src="../Images/337360c4ab8cd4c1f489c7028d5a3933.png" data-original-src="https://miro.medium.com/v2/format:webp/1*D0Q5JS51XLW4SpdAl1uU8g.png"/></div></figure><p id="3fd0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，现在数据准备好了。你可以在这里查看完整数据<a class="ae ka" href="https://github.com/Priya997/SKF-Chatbot/blob/master/Basic_Approach/Scripts_to_prepare_dataset/intent_data.csv" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="33b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了更好地理解如何准备数据集，您也可以查看这个<a class="ae ka" href="https://github.com/Priya997/SKF-Chatbot/blob/master/Basic_Approach/notebook/intent_data_prepare.ipynb" rel="noopener ugc nofollow" target="_blank"> jupyter笔记本</a>示例。</p><p id="6573" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们已经准备好数据😄…是时候用它变变魔术了。让我们看看如何对意图进行分类。</p><p id="6ba0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">让我们导入一些库:</strong></p><pre class="kb kc kd ke fr kf kg kh ki aw kj dt"><span id="1b97" class="kk kl hu kg b fw km kn l ko kp">import pandas as pd<br/>from io import StringIO<br/>from sklearn.feature_extraction.text import TfidfVectorizer<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.feature_extraction.text import CountVectorizer<br/>from sklearn.feature_extraction.text import TfidfTransformer<br/>from sklearn.naive_bayes import MultinomialNB</span></pre><p id="cb95" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们将从CSV文件中提取数据，并将其存储在数据帧中。</p><pre class="kb kc kd ke fr kf kg kh ki aw kj dt"><span id="b084" class="kk kl hu kg b fw km kn l ko kp">def get_data():<br/> df = pd.read_csv('datasets/intent_data.csv')<br/> return df</span></pre><p id="95fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这一步中，我们将准备好数据以将其输入算法。首先，我们在<strong class="je hv">‘y’</strong>中获得完整的数据，并使用</p><pre class="kb kc kd ke fr kf kg kh ki aw kj dt"><span id="6912" class="kk kl hu kg b fw km kn l ko kp"><strong class="kg hv">y=[col]</strong></span></pre><p id="f1fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">之后，使用'<strong class="je hv"> pd.notnull' </strong>来检查问题列中的数据是否为空，如果为空，则将删除整行。</p><blockquote class="ks kt ku"><p id="b5b3" class="jc jd kv je b jf jg jh ji jj jk jl jm kw jo jp jq kx js jt ju ky jw jx jy jz hn dt translated">这一步对于获得高质量的干净数据非常重要。因为，如果我们有好的数据，我们就会有好的结果。😃</p></blockquote><p id="3931" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将创建一个新的列<strong class="je hv">‘category _ id’</strong>，它将给出一个班级编号。类似于描述，它将是0，解决方案1和代码2。</p><p id="6e8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">删除重复后，我们将得到类似这样的东西</p><pre class="kb kc kd ke fr kf kg kh ki aw kj dt"><span id="50f6" class="kk kl hu kg b fw km kn l ko kp">category_id_df = y[['classs', 'category_id']].<strong class="kg hv">drop_duplicates()</strong>.sort_values('category_id')<br/><strong class="kg hv">print(category_id_df)</strong></span><span id="fac4" class="kk kl hu kg b fw kq kn l ko kp"><strong class="kg hv">classs category_id</strong><br/>0 Description 0<br/>2 Solution 1<br/>5081 Code 2</span></pre><p id="83f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可以查看下面data_prepare的代码片段。</p><pre class="kb kc kd ke fr kf kg kh ki aw kj dt"><span id="6aee" class="kk kl hu kg b fw km kn l ko kp">def data_prepare():<br/> col = ['classs', 'question']<br/> y=get_data()<br/> y = y[col]<br/> y = y[pd.notnull(y['question'])]<br/> y.columns = ['classs', 'question']<br/> y['category_id'] = y['classs'].factorize()[0]<br/> category_id_df = y[['classs', 'category_id']].drop_duplicates().sort_values('category_id')<br/> category_to_id = dict(category_id_df.values)<br/> id_to_category = dict(category_id_df[['category_id', 'classs']].values) <strong class="kg hv">#This will add the column in our dataframe</strong><br/> return y</span></pre><p id="4795" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我使用了多项式朴素贝叶斯算法进行预测，因为我发现它易于实现并且具有很高的准确性。</p><p id="c5ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">OneVsRest策略可用于多标签学习，例如，使用分类器来预测多个标签。朴素贝叶斯支持多类，但我们处于多标签场景中，因此，我们将朴素贝叶斯包装在OneVsRestClassifier中。</p><blockquote class="ks kt ku"><p id="64fc" class="jc jd kv je b jf jg jh ji jj jk jl jm kw jo jp jq kx js jt ju ky jw jx jy jz hn dt translated"><strong class="je hv"> OneVsRest多标签策略</strong></p><p id="9d70" class="jc jd kv je b jf jg jh ji jj jk jl jm kw jo jp jq kx js jt ju ky jw jx jy jz hn dt translated">多标签算法接受多个标签上的二进制掩码。每个预测的结果将是一个由0和1组成的数组，用于标记哪些类标签适用于每个行输入样本。</p></blockquote><p id="29c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了更好地理解下面的代码片段和多项式Naive_bayes，请尝试<a class="ae ka" href="http://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.MultinomialNB.html" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="a3d9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个简短的概述是:在这里，我将我的数据分为测试数据和训练数据，然后将这些数据输入到模型中。</p><pre class="kb kc kd ke fr kf kg kh ki aw kj dt"><span id="d16d" class="kk kl hu kg b fw km kn l ko kp">def naive_algo():<br/> tfidf = TfidfVectorizer(sublinear_tf=True, min_df=5, norm='l2', encoding='latin-1', ngram_range=(1, 2), stop_words='english')<br/> df=data_prepare()<br/> features = tfidf.fit_transform(df.question).toarray()<br/> labels = df.category_id<br/> features.shape<br/> X_train, X_test, y_train, y_test = train_test_split(df['question'], df['classs'], random_state = 0)<br/> count_vect = CountVectorizer()<br/> X_train_counts = count_vect.fit_transform(X_train)<br/> tfidf_transformer = TfidfTransformer()<br/> X_train_tfidf = tfidf_transformer.fit_transform(X_train_counts)<br/> clf = MultinomialNB().fit(X_train_tfidf, y_train)<br/> return clf,count_vect</span></pre><p id="5348" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我还尝试了其他算法或模型，如线性SVC、逻辑回归和随机森林。你可以看看这里的那个<a class="ae ka" href="https://github.com/Priya997/SKF-Chatbot/blob/master/Notebooks/implementing%20multiclass.ipynb" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="96f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将给我们最终的预测。</p><pre class="kb kc kd ke fr kf kg kh ki aw kj dt"><span id="7b87" class="kk kl hu kg b fw km kn l ko kp">def predict(question):<br/> clf,count_vect=naive_algo()<br/> intent=clf.predict(count_vect.transform([question]))<br/> intent=str(intent).strip("['']")<br/> return intent</span></pre><p id="b36c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们输入问题，并将其传递给predict函数，然后等待变魔术。😝</p><pre class="kb kc kd ke fr kf kg kh ki aw kj dt"><span id="3782" class="kk kl hu kg b fw km kn l ko kp">ques=input("Enter your question ")<br/>x=predict(ques)</span></pre><figure class="kb kc kd ke fr iv ff fg paragraph-image"><div class="ab fs cl kr"><img src="../Images/5a4818ad48d30e50b6fd2983a67dd1dc.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ZCo-a_2n2xrlqOI-4wi__g.png"/></div></figure><p id="e9ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">漂亮，准确，不是吗？</p><p id="afdd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以查看本<a class="ae ka" href="https://github.com/Priya997/SKF-Chatbot/blob/master/Basic_Approach/notebook/Intent_classifier.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>以更好地了解意图分类。</p><blockquote class="ks kt ku"><p id="555d" class="jc jd kv je b jf jg jh ji jj jk jl jm kw jo jp jq kx js jt ju ky jw jx jy jz hn dt translated">感谢阅读！如果你喜欢它，请鼓掌，评论(评论或质疑)并分享它😄</p><p id="85de" class="jc jd kv je b jf jg jh ji jj jk jl jm kw jo jp jq kx js jt ju ky jw jx jy jz hn dt translated">你可以在<a class="ae ka" href="https://github.com/Priya997" rel="noopener ugc nofollow" target="_blank"> Github </a>、<a class="ae ka" href="https://www.linkedin.com/in/priyanka997/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>、<a class="ae ka" href="https://twitter.com/priyankajain997" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上和我联系😄</p></blockquote></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><p id="a363" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kv">原载于2018年8月7日</em><a class="ae ka" href="https://towardsdatascience.com/multi-label-intent-classification-1cdd4859b93" rel="noopener" target="_blank"><em class="kv">towardsdatascience.com</em></a><em class="kv">。</em></p><p id="1424" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更多内容，请点击下面的“给我买杯咖啡”图标支持我。</p><figure class="kb kc kd ke fr iv ff fg paragraph-image"><a href="https://www.buymeacoffee.com/priyankajain97"><div class="ff fg lg"><img src="../Images/7a5c035cd21f7fa41bd8ae7cbadf7d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*1LFaaJOnWU9L0G6_c_wRWQ.png"/></div></a></figure></div></div>    
</body>
</html>