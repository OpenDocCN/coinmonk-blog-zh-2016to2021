# 天然气优化的周末体验

> 原文：<https://medium.com/coinmonks/a-weekends-take-on-gas-optimization-74b4c6961ff1?source=collection_archive---------9----------------------->

在过去的两天里，我一直在优化一个智能契约库，它为[高级提交-揭示方案](https://github.com/lorenzb/libsubmarine/)执行 merkle-patricia 证明验证。

![](img/4e2da8bc0d9871676a59d69956b7e0d6.png)

By Freepik

在这个项目之前，我经常满足于诸如“将存储数据放在结构中”和“永远不要使用 for 循环”这样的启发式方法，以避免惊人的汽油费用。虽然这些启发法可以走很长一段路，我想看看我是否能发现一些其他可能更微妙的启发法，可以为我节省一两个气体。

# 向内存声明变量。

当在函数中编写复杂的逻辑时，我经常发现自己在重复读取同一个存储变量。事实证明，这不是最好的主意。

> 如果一个变量在一个函数中不止一次被使用，那么这个变量应该被声明到内存中。

从存储器中读取一个数据字的 SLOAD 操作码花费 200 gas，而从存储器中写入和读取的 MSTORE 和 MLOAD 操作码每个仅花费 3 gas。

以下代码演示了启发式方法:

# 使用正确的类型。

我的直觉告诉我，我应该总是使用尽可能小的数据类型，以防止保留我知道我永远不会使用的空间。我的直觉又一次误导了我。

> 除非可以进行结构打包，否则最佳存储类型总是 32 字节/ 256 位长。

任何存储都被编译成一个字节数组，该数组存储在协定的存储 merkle-patricia 树中。这个字节数组中的每一项都需要由 32 个字节(256 位)组成。这意味着任何较小的数据都用零填充，以填充 32 个字节，这需要来自 EVM 的额外操作，并且花费更多的汽油！

下面的代码显示了在存储中声明 uint256 和 uint128 之间的区别。

# 结构包装的微妙之处。

我已经提到过几次，结构打包是一个很好的启发。当我学会这种启发式方法时，我开始把我所有的存储数据放在结构体中。事实证明，有一些微妙之处需要解决。

> 仅当组合数据是 32 字节的倍数时，结构打包才有效。

在前面的试探法中，我们提到数据被填充到 32 字节。在一个结构中，可以放置多种数据类型，这些数据类型加起来有 32 个字节，但在存储时表现得像一个 32 字节的对象。然而，以下微妙之处适用:

1.  将一个 32 字节的类型放在一个结构中比把它放在外面代价更高。
2.  打包以 32 字节的倍数进行，因此将小于 32 字节的类型单独放在结构中不会节省任何空间。
3.  可以将数字和字符串打包在一起。

# 现在就这样吧！

如果你有任何启发/字幕要分享，给我喊一声@thegostep

我的朋友[赫尔南多·卡斯塔诺](https://medium.com/u/f63ea2773bc3?source=post_page-----74b4c6961ff1--------------------------------)分享了一篇很棒的文章，其中涵盖了[在 solidity】中实现快速排序的细节。值得一读！](https://blog.cotten.io/thinking-in-solidity-6670c06390a9)

快乐优化！😄