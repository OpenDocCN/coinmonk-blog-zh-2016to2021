<html>
<head>
<title>7 Key Insights for Smart Contract Developers: What We’ve Learned Building Splice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合同开发人员的7个关键见解:我们从构建拼接中学到了什么</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/7-key-insights-for-smart-contract-developers-what-weve-learned-building-splice-995dbb7bc2d6?source=collection_archive---------4-----------------------#2021-12-14">https://medium.com/coinmonks/7-key-insights-for-smart-contract-developers-what-weve-learned-building-splice-995dbb7bc2d6?source=collection_archive---------4-----------------------#2021-12-14</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="8d1e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们即将推出一款新的web3产品，并希望分享我们在这一过程中学到的一些最重要的东西:</p><ul class=""><li id="44bf" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated">如何将关注点分离到不同的契约中？</li><li id="47cd" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">验证所有权并允许初步铸造</li><li id="fd19" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">如何保证没有人能在元数据上作弊？</li><li id="72b9" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">组合令牌id</li><li id="7088" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">我们是否应该转用L2的网络来降低汽油费？</li><li id="e474" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">如何降低仓储成本？</li><li id="71b3" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">如何保证支付安全？</li></ul><p id="e087" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先快速概述一下我们已经构建了什么:Splice允许您使用您已经拥有的NFT来播种新生成的NFT。请访问我们的Dapp，网址为<a class="ae kc" href="https://getsplice.io" rel="noopener ugc nofollow" target="_blank"> https://getsplice.io </a>，并选择您的一个NFT。Splice将提取其元数据和颜色，并将其注入到您选择的生成艺术风格的代码中。结果是一个独特的艺术品，你可以作为NFT铸币。我们推出了艺术风格来生成横幅图像，您可以将其植入您的PFP，并在Twitter或Discord上使用，如下所示:</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="fe ff kd"><img src="../Images/05a7439c8bc361858128f82d94e34418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ywzGoxUp-K6VTrZn.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">A Splice background image minted of <a class="ae kc" href="https://opensea.io/assets/0x9d418c2cae665d877f909a725402ebd3a0742844/5409" rel="noopener ugc nofollow" target="_blank">Fangster #5409</a> and the Style “A Beginning is A Very Delicate Time”</figcaption></figure><p id="4eab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">拼接的规模超越了横幅图像，并将以各种方式发展。我们的合同准备将不止一个NFT作为原产地，<a class="ae kc" href="https://github.com/SpliceNFT/splicenft/issues/86" rel="noopener ugc nofollow" target="_blank">我们最终将把更多的输入参数</a>交给风格代码，包括原产地NFT的特征、额外的图像分析数据或稀有度得分。这将使艺术家能够为更高级的用例构建风格。拼接将能够选择<a class="ae kc" href="https://opensea.io/collection/lootproject" rel="noopener ugc nofollow" target="_blank"> Loots </a>或<a class="ae kc" href="https://opensea.io/collection/the-colors-dot-art" rel="noopener ugc nofollow" target="_blank">颜色</a>或<a class="ae kc" href="https://opensea.io/collection/devs-for-revolution" rel="noopener ugc nofollow" target="_blank"> DevDAO的NFTs </a>作为输入，并创建新的元宇宙项目。</p><p id="b1bf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个想法把我们带入了《EthOnline21》的大结局。你可以从10月21日(7:16)在黑客马拉松的Splice版本上观看我们的最终项目推介:</p><figure class="ke kf kg kh fq ki"><div class="bz el l di"><div class="kt ku l"/></div></figure><p id="8450" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是我们的Dapp经过大约2个月的微调和功能添加后的样子。<a class="ae kc" href="https://getsplice.io" rel="noopener ugc nofollow" target="_blank">请随意尝试一下</a> —在撰写本文时，我们支持在您的mainnet资产上预览样式，您将能够在Rinkeby测试网络上对选定的集合进行拼接。</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="fe ff kv"><img src="../Images/edac4acdcaee4df5ca01054e33c6510d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T0H7Lh2b0_-FBBDgw5iHsA.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek"><a class="ae kc" href="https://getsplice.io" rel="noopener ugc nofollow" target="_blank">https://getsplice.io</a></figcaption></figure><h1 id="a52d" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">如何将关注点分离到不同的契约中？</h1><p id="c8d4" class="pw-post-body-paragraph iq ir ht is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hm dt translated">我们的<a class="ae kc" href="https://github.com/SpliceNFT/splicenft/tree/main/packages/contracts/contracts" rel="noopener ugc nofollow" target="_blank">拼接契约</a>涵盖了两个主要用例。首先，拼接合同本身是一个ERC721兼容的NFT，用于跟踪预制拼接的所有权。其次，Splice的<strong class="is hu">样式</strong>由另一个契约(Splice Style NFT)管理，该契约控制样式的所有权并存储样式代码及其元数据的固定位置。每种风格的NFT都会强制执行一些规则，比如一种风格可以铸造多少个拼接，铸造是否仅限于某些原产地系列，铸造者是否拥有独家铸造权，以及最重要的是，一个铸币厂有多贵。</p><p id="e6c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了分离关注点，我们决定将拼接架构分为三个合同:拼接、风格和价格策略(静态)。我们在部署/样式创建过程中通过将成员属性类型化为组合契约来连接所有这些契约。</p><pre class="ke kf kg kh fq lz ma mb mc aw md dt"><span id="c143" class="me kx ht ma b fv mf mg l mh mi">contract <strong class="ma hu">Splice</strong> {</span><span id="5e4c" class="me kx ht ma b fv mj mg l mh mi">  <strong class="ma hu">SpliceStyleNFT</strong> public styleNFT;</span><span id="72a9" class="me kx ht ma b fv mj mg l mh mi">  function <strong class="ma hu">setStyleNFT</strong>(SpliceStyleNFT _styleNFT) public onlyOwner {<br/>    styleNFT = _styleNFT;<br/>  }</span><span id="0894" class="me kx ht ma b fv mj mg l mh mi">  function quote(IERC721 nft, uint32 style_token_id) <br/>    public view <br/>    returns (uint256 fee) { <br/>      return <strong class="ma hu">styleNFT</strong>.quoteFee(nft, style_token_id);<br/>  }<br/>}</span><span id="2107" class="me kx ht ma b fv mj mg l mh mi">contract <strong class="ma hu">SpliceStyleNFT</strong> {</span><span id="d31b" class="me kx ht ma b fv mj mg l mh mi">  address public <strong class="ma hu">spliceNFT</strong>;</span><span id="3de3" class="me kx ht ma b fv mj mg l mh mi">  function <strong class="ma hu">setSplice</strong>(address _spliceNFT) external onlyOwner {<br/>    spliceNFT = _spliceNFT;<br/>  }</span><span id="5567" class="me kx ht ma b fv mj mg l mh mi">  function quoteFee(IERC721 nft, uint32 style_token_id)<br/>    external <br/>    view <br/>    returns (uint256 fee) {<br/>      fee = styleSettings[style_token_id].<strong class="ma hu">priceStrategy</strong>.quote(<br/>        this,<br/>        nft,<br/>        style_token_id,<br/>        styleSettings[style_token_id]<br/>      );<br/>    }<br/>  function mint(<br/>    ...<br/>    <strong class="ma hu">ISplicePriceStrategy</strong> _priceStrategy,<br/>    bytes32 _priceStrategyParameters<br/>  ) {<br/>    styleSettings[style_token_id] = StyleSettings({<br/>      <strong class="ma hu">priceStrategy</strong>: _priceStrategy,<br/>      <strong class="ma hu">priceParameters</strong>: _priceStrategyParameters<br/>    })<br/> }</span><span id="7552" class="me kx ht ma b fv mj mg l mh mi">}</span><span id="e27b" class="me kx ht ma b fv mj mg l mh mi">struct <strong class="ma hu">StyleSettings</strong> {<br/>  uint32 mintedOfStyle;<br/>  uint32 cap;<br/>  ISplicePriceStrategy <strong class="ma hu">priceStrategy</strong>;<br/>  bytes32 <strong class="ma hu">priceParameters</strong>;<br/>  bool salesIsActive; <br/>  bool collectionConstrained;<br/>  bool isFrozen;<br/>  string styleCID;<br/>}</span><span id="224a" class="me kx ht ma b fv mj mg l mh mi">contract <strong class="ma hu">SplicePriceStrategyStatic</strong> {</span><span id="c54b" class="me kx ht ma b fv mj mg l mh mi">  function quote(<br/>    SpliceStyleNFT <strong class="ma hu">styleNFT</strong>, <br/>    IERC721 collection, <br/>    uint256 token_id,<br/>    StyleSettings memory styleSettings<br/>  ) external pure override returns (uint256) {<br/>    return uint256(styleSettings.<strong class="ma hu">priceParameters</strong>);<br/>  }</span><span id="eae2" class="me kx ht ma b fv mj mg l mh mi">}</span></pre><p id="77d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在可靠性中分离关注点可能是一个架构上的挑战，因为一旦契约被部署，它们通常不能被改变。我们的<code class="eh mk ml mm ma b">priceStrategy</code>乍一看似乎是不必要的，因为它只是返回一个样式制作者在制作过程中提供的静态费用。我们这样做的原因是基于前瞻性的假设。智能合约的设计必须足够开放，以便从第一天起就可以扩展，因为一旦它们进入状态并被广泛使用，改变它们将是一场噩梦。</p><p id="9e9b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的<em class="mn"> PriceStrategy </em>抽象允许在未来添加更复杂的价格计算，而不需要我们对现有合同做任何修改。它的实现接收足够的信息，以支持任意复杂的定价策略。一个简单的扩展可以是线性结合的铸造费用算法，它随着每个拼接铸造而略微增加费用，或者是荷兰式拍卖，它根据自上次铸造以来经过的时间而改变费用。</p><h1 id="9646" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">谁去造币厂？验证所有权并允许初步铸造</h1><p id="5cf7" class="pw-post-body-paragraph iq ir ht is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hm dt translated">确保某人拥有一个原点是相当简单的，您只需将原点集合的地址转换为IERC721，并检查它的<code class="eh mk ml mm ma b">ownerOf</code>方法是否为传入的令牌ID产生了<code class="eh mk ml mm ma b">msg.sender</code>:</p><pre class="ke kf kg kh fq lz ma mb mc aw md dt"><span id="fcf5" class="me kx ht ma b fv mf mg l mh mi">function mint(<br/>    <strong class="ma hu">IERC721</strong>[] memory origin_collections,<br/>    uint256[] memory origin_token_ids,<br/>    uint32 style_token_id,<br/>    bytes32[] memory allowlistProof,<br/>    bytes calldata input_params<br/>) {<br/>for (uint256 i = 0; i &lt; origin_collections.length; i++) {<br/>      if (origin_collections[i].<strong class="ma hu">ownerOf</strong>(origin_token_ids[i]) != msg.sender) {<br/>        revert NotOwningOrigin();<br/>      }<br/>}</span></pre><p id="2c98" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是还有更多。一个艺术家可能会决定建立一种只适用于三个专门的原创系列的风格。如果是这样的话，这些收藏的地址可以在我们的风格NFT的<code class="eh mk ml mm ma b">collectionAllowed</code>成员中提供。当原始集合未列在约束列表中时，具有集合约束的样式将恢复拼接薄荷。默认情况下，风格并不局限于特定的集合，所以拼接可以铸造任何原产地NFT。</p><p id="9da5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，我们决定添加一个对每种风格的NFT都独一无二的特征。如果您想简单地构建allowlists，您可以只添加一些类型为<code class="eh mk ml mm ma b">mapping(uint32 =&gt; mapping(address =&gt; bool))</code>的成员，但是在部署新样式时必须初始化映射。如果一个样式创建者想要在一个allowlist上有200个地址，那就需要在创建事务中发送大量的gas。因为我们想让这个功能更节能，所以我们必须想出一个更好的解决方案。</p><p id="cf78" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们决定使用<a class="ae kc" href="https://media.consensys.net/ever-wonder-how-merkle-trees-work-c2f8b7100ed3" rel="noopener ugc nofollow" target="_blank"> Merkle树证明</a>来确定mint请求是否是由一个被允许的用户发出的。幸运的是，OpenZeppelin为我们介绍了他们的Merkle proofs的<a class="ae kc" href="https://docs.openzeppelin.com/contracts/4.x/utilities#verifying_merkle_proofs" rel="noopener ugc nofollow" target="_blank">参考实现</a>，所以实现这个特性只需要一行实际代码:</p><pre class="ke kf kg kh fq lz ma mb mc aw md dt"><span id="3ef0" class="me kx ht ma b fv mf mg l mh mi">///SpliceStyleNFT.sol</span><span id="4a83" class="me kx ht ma b fv mj mg l mh mi">function <strong class="ma hu">verifyAllowlistEntryProof</strong>(<br/>  uint32 style_token_id, <br/>  bytes32[] memory allowlistProof,<br/>  address requestor<br/>) public view returns (bool) {<br/>  return <strong class="ma hu">MerkleProof.verify</strong>(<br/>    allowlistProof,<br/>    allowlists[style_token_id].merkleRoot,<br/>    keccak256(abi.encodePacked(requestor))<br/>  );<br/>}</span><span id="4286" class="me kx ht ma b fv mj mg l mh mi">///Splice.sol:mint</span><span id="bad1" class="me kx ht ma b fv mj mg l mh mi">if (<br/>  allowlistProof.length == 0 || <br/>  !styleNFT.<strong class="ma hu">verifyAllowlistEntryProof</strong>(<br/>    style_token_id,<br/>    allowlistProof,<br/>    msg.sender<br/>  ) {<br/>    revert NotAllowedToMint('no reservations left or proof failed');<br/>  }<br/>)</span></pre><p id="9720" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这种方法的缺点是allowlist成员必须保存在一个安全的地方，并且必须为每个用户单独生成证明，但是因为这个特性无论如何都处理许可的数据，所以没有必要以100%分散的方式解决它。创建相应证明数组的客户端代码如下所示:</p><pre class="ke kf kg kh fq lz ma mb mc aw md dt"><span id="cd98" class="me kx ht ma b fv mf mg l mh mi">import { MerkleTree } from 'merkletreejs';<br/>import keccak256 from 'keccak256';</span><span id="c4bd" class="me kx ht ma b fv mj mg l mh mi">function createMerkleProof(allowedAddresses: string[]): MerkleTree {<br/>  const leaves = allowedAddresses.map((x) =&gt; keccak256(x));<br/>  return new MerkleTree(leaves, keccak256, {<br/>    sort: true<br/>  });<br/>}</span><span id="9ab7" class="me kx ht ma b fv mj mg l mh mi">const allowedAddresses: string[] = [/* many 0xaddresses */]</span><span id="1a63" class="me kx ht ma b fv mj mg l mh mi">const merkleTree = createMerkleProof(allowedAddresses);<br/>const leaf = utils.keccak256(_allowedAddresses[0]);</span><span id="9812" class="me kx ht ma b fv mj mg l mh mi">// this grows linearly with the overall amount of allowed addresses<br/>const proof = merkleTree.getHexProof(leaf);</span><span id="7cd4" class="me kx ht ma b fv mj mg l mh mi">const verified = await styleNft.<strong class="ma hu">verifyAllowlistEntryProof</strong>(<br/>  1,<br/>  proof,<br/>  allowedAddresses[0] <br/>);</span><span id="4b27" class="me kx ht ma b fv mj mg l mh mi">expect(verified).to.be.true;</span></pre><h1 id="a8ee" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">热保证没人能在元数据上作弊？</h1><p id="1eff" class="pw-post-body-paragraph iq ir ht is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hm dt translated">我们最初实现Splice的<a class="ae kc" href="https://showcase.ethglobal.com/ethonline2021/splice" rel="noopener ugc nofollow" target="_blank">是基于这样一个假设，即用户完全控制他们的拼接结果:代码在用户的机器上呈现拼接结果，将其编码为PNG，在IPFS上发布(使用</a><a class="ae kc" href="https://nft.storage/" rel="noopener ugc nofollow" target="_blank"> nft.storage </a>)，然后使用其IPFS内容散列调用契约的mint方法。</p><p id="a0c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后我们意识到，这个实现很容易被用户欺骗:他们实际上可以将任何他们喜欢的IPFS散列输入到mint函数中，实际上能够铸造任何东西。这肯定不是我们想要允许的，所以我们想到了使用oracle来请求专用的验证后端，以验证我们用户的新“请求”实际上包含与用户在他们的机器上使用的输入参数相匹配的有效拼接图像(您可以在我们的回购历史中找到该<a class="ae kc" href="https://github.com/SpliceNFT/splicenft/blob/77ce12f9843ef53b310fec6454994f965ce288b5/packages/backend/lib/validate.js" rel="noopener ugc nofollow" target="_blank">的实现)。</a></p><p id="7aae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">随着专用风格NFT的引入，我们不赞成这个验证步骤。到目前为止，Splice本身根本不存储任何IPFS元数据。我们为链上的每个拼接保留的唯一信息是在拼接过程中计算的其“<strong class="is hu">出处</strong>:</p><pre class="ke kf kg kh fq lz ma mb mc aw md dt"><span id="b9af" class="me kx ht ma b fv mf mg l mh mi">/// Splice.sol:mint</span><span id="2510" class="me kx ht ma b fv mj mg l mh mi">bytes32 provenanceHash = keccak256(<br/>  abi.encodePacked(<br/>    origin_collections, origin_token_ids, style_token_id<br/>  )<br/>);</span></pre><p id="a663" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于每个拼接输入来说，出处(或者我们历史上称之为遗产)是唯一的。用户本身不提供任何其他信息，除了他们期望的原始输入和样式令牌id，该id确定在输入上执行哪个样式代码，以及哪个本身锚定在IPFS上。因此，任何知道导致出处的输入的人都可以确定性地再现渲染图像。</p><h1 id="f1e7" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">组合令牌id</h1><p id="cea5" class="pw-post-body-paragraph iq ir ht is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hm dt translated">如果你看一下<a class="ae kc" href="https://testnets.opensea.io/assets/0xea934c468e6c8c0c60e6e62797ae57dbd601970f/12884901892" rel="noopener ugc nofollow" target="_blank"> Splice的令牌id</a>，例如“<em class="mn"> 12884901894 </em>”，你会注意到它们似乎不是递增生成的。基本上是，但是很难看到。Splice将每个令牌的两个增量ID组合成一个唯一的ID值。它将选定的样式id和增量(每种样式)拼接标记ID组合成一个唯一的标记id (uint64，按照ERC721的要求存储为uint256):</p><pre class="ke kf kg kh fq lz ma mb mc aw md dt"><span id="adaf" class="me kx ht ma b fv mf mg l mh mi">/// SpliceStyleNFT</span><span id="0088" class="me kx ht ma b fv mj mg l mh mi">function incrementMintedPerStyle(uint32 style_token_id)<br/>    external<br/>    onlySplice<br/>    returns (uint32)<br/>{<br/>      if (mintsLeft(style_token_id) == 0) {<br/>        revert StyleIsFullyMinted();<br/>      }<br/>    <br/>      styleSettings[style_token_id].mintedOfStyle += 1;<br/>      return styleSettings[style_token_id].mintedOfStyle;<br/>}</span><span id="3794" class="me kx ht ma b fv mj mg l mh mi">/// Splice.sol<br/>uint32 nextStyleMintId = styleNFT.incrementMintedPerStyle(style_token_id);</span><span id="09d2" class="me kx ht ma b fv mj mg l mh mi">token_id = BytesLib.toUint64(<br/>  <strong class="ma hu">abi.encodePacked(style_token_id, nextStyleMintId),</strong> <br/>  0<br/>);</span></pre><p id="db2e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这种方法允许您计算每个拼接NFT的风格遗产。取其最低有效的64位，分成两个uint32值。第一个表示样式ID，第二个表示该样式的增量接头ID:</p><pre class="ke kf kg kh fq lz ma mb mc aw md dt"><span id="87e5" class="me kx ht ma b fv mf mg l mh mi">/// Splice.ts</span><span id="17fd" class="me kx ht ma b fv mj mg l mh mi">public static tokenIdToStyleAndToken(<strong class="ma hu">tokenId</strong>: BigNumber) {<br/>    const hxToken = ethers.utils.arrayify(<br/>      utils.zeroPad(tokenId.toHexString(), 8)<br/>    );<br/>    return {<br/>      <strong class="ma hu">style_token_id</strong>: BigNumber.from(hxToken.slice(0, 4),<br/>      <strong class="ma hu">token_id</strong>: BigNumber.from(hxToken.slice(4))<br/>    };<br/>  }</span></pre><p id="2c2a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">十进制读为<code class="eh mk ml mm ma b">12884901894</code>的令牌ID转换为十六进制字符串<code class="eh mk ml mm ma b">0x0300000006</code>(或填充为8字节/ uint64: <code class="eh mk ml mm ma b">0x0000000300000006</code>)，因此它实际上转换为“style #3的splice #6”。</p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="fe ff mo"><img src="../Images/954a4137077fd067ab6751be86c5c39f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxOkoiWl8KaLOX4vMetBAA.png"/></div></div></figure><h1 id="6a5a" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">我们是否应该转用L2的网络来降低汽油费？</h1><p id="980d" class="pw-post-body-paragraph iq ir ht is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hm dt translated">最小化L1造币厂的额外网络成本应该是每个web3项目的主要关注点。乍一看，拼接实际上是L2明廷的一个很好的候选，但这样做会引入一个额外的架构复杂性层。记住，拼接依赖于关于某些资产所有权的知识(原始NFT)。为了铸造一个拼接，合同必须确保铸造者实际上拥有他们的原产地NFT。如果你想在L2网络上对L1现有的资产进行拼接，你需要创建一个所有权关系的密码确定性证明，并使用在各层之间传递知识的消息桥进行通信<a class="ae kc" href="https://developer.offchainlabs.com/docs/l1_l2_messages" rel="noopener ugc nofollow" target="_blank">。更糟糕的是，该证明在创建后可以通过将原始资产转移到另一个账户而立即被否定，只有通过将原始资产锁定在第三方托管中才能进行补救，以确保其安全，直到L2的造币厂最终确定。最终，你要么决定使拼接成为L2优先协议，这意味着用户不能在mainnet上伪造拼接，要么你必须想出一个非常聪明的ID缺口，以便用户可以将拼接从L2迁移到L1，而不会与现有的ID冲突。</a></p><p id="ff04" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">鉴于大多数有价值的资产仍然锚定在mainnet上，而Splice的主要目标是为这些资产增值，我们认为将它部署为纯L1协议是目前最好的方式(这并不意味着不会很快出现Polygon、zkSync或Arbitrum版本的Splice)。</p><h1 id="0b91" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">如何降低仓储成本？</h1><p id="1893" class="pw-post-body-paragraph iq ir ht is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hm dt translated">以太坊高油价的主要驱动力是数据存储。状态树上的每个存储槽必须被所有参与节点复制，并且它们中最昂贵的操作是<a class="ae kc" rel="noopener" href="/coinmonks/storing-on-ethereum-analyzing-the-costs-922d41d6b316">分配新的存储槽</a>，这发生在创建新的映射元素或追加数组元素时。事实证明，有史以来最方便的NFT加法之一充分利用了这些操作:<a class="ae kc" href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721Enumerable" rel="noopener ugc nofollow" target="_blank">可枚举集合</a>。它们允许客户端迭代一个用户的所有条目，这个问题通过添加另一个映射和一个索引表在内部得到解决。</p><p id="c7f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">删除此功能会减少三分之一(！)和<a class="ae kc" href="https://shiny.mirror.xyz/OUampBbIz9ebEicfGnQf5At_ReMHlZy0tB4glb9xQ0E" rel="noopener ugc nofollow" target="_blank">其他人报告见证了</a>可比较的结果。</p><div class="mp mq fm fo mr ms"><a href="https://github.com/SpliceNFT/splicenft/blob/38bf9fad2e4889f33e912106501418f3d7570e3b/packages/contracts/test/gas-comparison.txt" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">splice NFT/gas-comparison . txt at 38 BF 9 fad 2e 4889 f33e 912106501418 f3d 7570 e3b splice NFT/splice NFT</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">可升级| Solc版本:0.8.10启用优化器:真实运行次数:200块限制:30000000 gas……</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kn ms"/></div></div></a></div><p id="da0b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们可以从拼接契约的初稿中删除的另一个存储槽是拼接令牌的“遗产”。事实证明，需要直接存储在链上的唯一信息是拼接遗产的出处散列(32字节),以确定某个项目是否已经被铸造。这种优化将薄荷的用气量又减少了30%。</p><h2 id="9041" class="me kx ht bd ky nh ni nj lc nk nl nm lg jb nn no lk jf np nq lo jj nr ns ls nt dt translated">那么在哪里存储原始信息呢？拯救之图！</h2><p id="e7ed" class="pw-post-body-paragraph iq ir ht is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hm dt translated">您在chain上节省的每个存储插槽都会损失一些功能。当应用上述优化时，我们丢失了两个重要的视图函数，这两个函数以前可以直接在chain上请求:1。<em class="mn">拼接标记</em>和2的确切来源是什么。<em class="mn">账户拥有哪些拼接令牌</em>。</p><p id="c35c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">事实证明，这两个特征都是由<a class="ae kc" href="https://thegraph.com/en/" rel="noopener ugc nofollow" target="_blank">子图</a>索引和查询的完美候选。子图由基于WASM (AssemblyScript)的索引脚本组成，这些脚本在索引器节点上执行，以构建onchain信息的二级数据库，并使用GraphQL API公开查询它。尽管该图提供了一种完全去中心化的方式来在激励的索引和监管层上部署子图，但是我们选择了使用它们非常方便(并且免费)的<a class="ae kc" href="https://thegraph.com/hosted-service/" rel="noopener ugc nofollow" target="_blank">托管服务</a>。</p><p id="256c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">子图映射监听由契约发出的事件，并相应地对它们做出反应。在Splice中，一个minting事务发出两个事件:一个自定义事件<code class="eh mk ml mm ma b">Minted(bytes32 origin, uint64 token_id, uint32 style_token_id)</code>和<code class="eh mk ml mm ma b">Transfer</code>(由基本ERC721契约发出)。注意，仅仅通过跟踪<code class="eh mk ml mm ma b">Minted</code>事件，您仍然不能找出原始集合或令牌id:我们实际上必须分析的是发出事件的<code class="eh mk ml mm ma b">mint</code>调用的<strong class="is hu">事务输入</strong>。我们的子图的<code class="eh mk ml mm ma b">handleMinted</code>处理程序展示了如何实现这一点:</p><figure class="ke kf kg kh fq ki"><div class="bz el l di"><div class="nu ku l"/></div></figure><p id="1983" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在从我们的<code class="eh mk ml mm ma b">Mint</code>事件中提取一些未编码的值之后，我们正在获取发起<code class="eh mk ml mm ma b">mint</code>方法调用的输入数据(第18行),并去掉方法签名的前4个字节。现在，我们遇到了底层<a class="ae kc" href="https://github.com/graphprotocol/ethabi" rel="noopener ugc nofollow" target="_blank"> ABI解码器的Rust实现</a>的一个缺点:它只能解码单个值，例如元组、单位或数组，但<strong class="is hu">不能像<code class="eh mk ml mm ma b">event.transaction.input</code>中存储的那样直接解码普通函数调用。我们用来欺骗解码器正确解码我们的函数调用的方法是在参数前加上<a class="ae kc" href="https://docs.soliditylang.org/en/latest/abi-spec.html#handling-tuple-types" rel="noopener ugc nofollow" target="_blank"> ABI编码器对元组类型</a> (0x20)的签名，并让解码器对该值进行操作(第21–32行):</strong></p><pre class="ke kf kg kh fq lz ma mb mc aw md dt"><span id="e1a8" class="me kx ht ma b fv mf mg l mh mi">const decoded = ethereum.decode(<br/>    '<strong class="ma hu">(address[],uint[],uint,bytes32[],bytes)</strong>',<br/>    tupleInputBytes<br/>);</span></pre><p id="d4b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还制作了一个Rust样本来证明这种方法是可行的:</p><div class="mp mq fm fo mr ms"><a href="https://github.com/SpliceNFT/splicenft/blob/main/packages/subgraph/testdecode/src/main.rs" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">主拼接处的拼接/主rs</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">此文件包含双向Unicode文本，其解释或编译可能与下面显示的不同…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">github.com</p></div></div><div class="nb l"><div class="nv l nd ne nf nb ng kn ms"/></div></div></a></div><p id="6881" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">拼接子图可在图的托管服务上公开查询:<a class="ae kc" href="https://thegraph.com/hosted-service/subgraph/elmariachi111/splicemultirinkeby" rel="noopener ugc nofollow" target="_blank">https://The Graph . com/hosted-service/subgraph/elmariachi 111/splicemulturinkeby</a>并且它为拼接Dapp 的<a class="ae kc" href="https://getsplice.io/#/my-splices" rel="noopener ugc nofollow" target="_blank">“我的拼接”页面提供动力。(注意，由于尚未发现的原因，GraphQL模式的复数版本<code class="eh mk ml mm ma b">splice</code>是<code class="eh mk ml mm ma b">spliceice</code>)</a></p><figure class="ke kf kg kh fq ki fe ff paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="fe ff nw"><img src="../Images/8fe81cade5dbd570083c9cf9900f371f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MMUehXOUyUkiBXFngWKpZg.png"/></div></div><figcaption class="kp kq fg fe ff kr ks bd b be z ek">a query to retrieve all splice tokens owned by an user</figcaption></figure><h1 id="4add" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">如何保证支付安全？</h1><p id="eb8f" class="pw-post-body-paragraph iq ir ht is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hm dt translated">最后，根据<a class="ae kc" href="https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls" rel="noopener ugc nofollow" target="_blank"> Consensys的智能合同安全最佳实践</a>，我们非常小心地确保所有涉及我们合同的付款尽可能安全。我们并没有将铸造费推给收款人，而是要求他们通过自己发布拉交易来撤回铸造费。为了确保所有参与者的资金安全，我们集成了一个<a class="ae kc" rel="noopener" href="/@ethdapp/using-the-openzeppelin-escrow-library-6384f22caa99">内部令牌</a> <code class="eh mk ml mm ma b"><a class="ae kc" rel="noopener" href="/@ethdapp/using-the-openzeppelin-escrow-library-6384f22caa99">escrow</a></code>，它只将资金转移给有资格的参与者，并且由主合同拥有，因此没有人可以劫持托管本身。铸造时，所有费用根据当前有效的协议设置进行分割(艺术家85%，拼接15%)，并托管，直到其受益人撤回:</p><pre class="ke kf kg kh fq lz ma mb mc aw md dt"><span id="d839" class="me kx ht ma b fv mf mg l mh mi">import '@openzeppelin/contracts-upgradeable/utils/escrow/EscrowUpgradeable.sol';</span><span id="8f41" class="me kx ht ma b fv mj mg l mh mi">EscrowUpgradeable private <strong class="ma hu">feesEscrow</strong>;</span><span id="71da" class="me kx ht ma b fv mj mg l mh mi">function initialize(...) public initializer {<br/>  /// ...<br/>  feesEscrow = new <strong class="ma hu">EscrowUpgradeable</strong>();<br/>  feesEscrow.initialize();<br/>}</span><span id="bf77" class="me kx ht ma b fv mj mg l mh mi">function withdrawShares() external nonReentrant whenNotPaused {<br/>    uint256 balance = shareBalanceOf(msg.sender);<br/>    feesEscrow.<strong class="ma hu">withdraw</strong>(payable(msg.sender));<br/>    emit Withdrawn(msg.sender, balance);<br/>}</span><span id="35fe" class="me kx ht ma b fv mj mg l mh mi">function shareBalanceOf(address payee) public view returns (uint256) {<br/>  return feesEscrow.<strong class="ma hu">depositsOf</strong>(payee);<br/>}</span><span id="bcb3" class="me kx ht ma b fv mj mg l mh mi">//called inside the mint method<br/>function splitMintFee(uint256 amount, uint32 style_token_id) internal {<br/>  uint256 feeForArtist = ARTIST_SHARE * (amount / 100);<br/>  uint256 feeForPlatform = amount - feeForArtist;<br/>  address beneficiaryArtist = styleNFT.ownerOf(style_token_id);<br/>  feesEscrow.<strong class="ma hu">deposit</strong>{ value: feeForArtist }(beneficiaryArtist);<br/>  feesEscrow.<strong class="ma hu">deposit</strong>{ value: feeForPlatform }(platformBeneficiary);                                 }</span></pre><h1 id="98ff" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">卷曲</h1><p id="72bf" class="pw-post-body-paragraph iq ir ht is b it lu iv iw ix lv iz ja jb lw jd je jf lx jh ji jj ly jl jm jn hm dt translated">我们当然可以谈论我们在拼接协议实施过程中发现的许多其他知识。首先，我们可以推荐一件事:自己阅读公共契约准则！你会偶然发现很多别人在你之前已经发现的东西。在我们的案例中，我们通过分析<a class="ae kc" href="https://etherscan.io/address/0xa7d8d9ef8d8ce8992df33d8b8cf4aebabd5bd270#code" rel="noopener ugc nofollow" target="_blank"> ArtBlocks </a>、<a class="ae kc" href="https://etherscan.io/address/0xd31fc221d2b0e0321c43e9f6824b26ebfff01d7d#code" rel="noopener ugc nofollow" target="_blank"> Brotchain </a>和<a class="ae kc" href="https://etherscan.io/address/0xc631164b6cb1340b5123c9162f8558c866de1926#code" rel="noopener ugc nofollow" target="_blank"> Divine Anarchy </a>的合同学到了很多东西。</p><p id="96f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你喜欢你读过的东西，并且你想成为拼接之旅的一部分，不要犹豫，直接在Discord或Twitter上联系我们。你可能还会发现阅读我们的<a class="ae kc" href="https://splicenft.github.io/splicenft/developers/" rel="noopener ugc nofollow" target="_blank">开发人员文档</a>有助于更深入地了解拼接协议的内部工作原理。我们很乐意接受任何问题和建议。</p><blockquote class="nx"><p id="979f" class="ny nz ht bd oa ob oc od oe of og jn ek translated">加入Coinmonks <a class="ae kc" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae kc" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h2 id="6048" class="me kx ht bd ky nh oh nj lc nk oi nm lg jb oj no lk jf ok nq lo jj ol ns ls nt dt translated">也阅读</h2><div class="mp mq fm fo mr ms"><a rel="noopener follow" target="_blank" href="/coinmonks/leveraged-token-3f5257808b22"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">杠杆代币[多头代币]终极指南</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">杠杆化令牌是具有杠杆化风险敞口的ERC20令牌，不考虑保证金、要求、管理…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">medium.com</p></div></div><div class="nb l"><div class="om l nd ne nf nb ng kn ms"/></div></div></a></div><div class="mp mq fm fo mr ms"><a href="https://blog.coincodecap.com/crypto-exchange" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">最佳加密交易所| 2021年十大加密货币交易所</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">加密货币交易所的加密交易需要了解市场，这可以帮助你获得利润。之前…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">blog.coincodecap.com</p></div></div><div class="nb l"><div class="on l nd ne nf nb ng kn ms"/></div></div></a></div><div class="mp mq fm fo mr ms"><a href="https://blog.coincodecap.com/best-swap-platforms" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">2021年最佳加密交换平台| CoinCodeCap</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">编辑描述</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">blog.coincodecap.com</p></div></div><div class="nb l"><div class="oo l nd ne nf nb ng kn ms"/></div></div></a></div><div class="mp mq fm fo mr ms"><a rel="noopener follow" target="_blank" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">2021年最佳加密借贷平台| 6大比特币借贷平台</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">获得比特币和其他加密货币的最佳贷款利率</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">medium.com</p></div></div><div class="nb l"><div class="op l nd ne nf nb ng kn ms"/></div></div></a></div><div class="mp mq fm fo mr ms"><a rel="noopener follow" target="_blank" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">2021年6大最佳硬件钱包|顶级加密硬件钱包[更新]</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">最好的加密货币硬件钱包是绝对必要的。我们将在NGRAVE、Ledger Nano X和…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">medium.com</p></div></div><div class="nb l"><div class="oq l nd ne nf nb ng kn ms"/></div></div></a></div><div class="mp mq fm fo mr ms"><a rel="noopener follow" target="_blank" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">2021年最佳免费加密交易机器人</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">2021年币安、比特币基地、库币和其他密码交易所的最佳密码交易机器人。四进制，位间隙…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">medium.com</p></div></div><div class="nb l"><div class="or l nd ne nf nb ng kn ms"/></div></div></a></div><div class="mp mq fm fo mr ms"><a rel="noopener follow" target="_blank" href="/coinmonks/best-crypto-signals-telegram-5785cdbc4b2b"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">最佳4个加密交易信号电报通道</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">这是乏味的找到正确的加密交易信号提供商。因此，在本文中，我们将讨论最好的…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">medium.com</p></div></div><div class="nb l"><div class="os l nd ne nf nb ng kn ms"/></div></div></a></div><div class="mp mq fm fo mr ms"><a href="https://blog.coincodecap.com/bitsgap-review" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">获取信号、交易机器人和套利</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">编辑描述</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">blog.coincodecap.com</p></div></div><div class="nb l"><div class="ot l nd ne nf nb ng kn ms"/></div></div></a></div></div></div>    
</body>
</html>