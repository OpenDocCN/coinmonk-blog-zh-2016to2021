<html>
<head>
<title>Introduction to Decentralized Random Number Generation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分散随机数生成简介</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-crash-course-on-proof-of-stake-part-iii-67aa720ea08f?source=collection_archive---------1-----------------------#2018-11-25">https://medium.com/coinmonks/a-crash-course-on-proof-of-stake-part-iii-67aa720ea08f?source=collection_archive---------1-----------------------#2018-11-25</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="d127" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">利害关系证明速成班(第三部分)</h2></div><h2 id="8201" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">目录</h2><ul class=""><li id="b07e" class="kg kh ht ki b kj kk kl km jt kn jx ko kb kp kq kr ks kt ku dt translated"><a class="ae kv" rel="noopener" href="/coinmonks/a-crash-course-on-proof-of-stake-part-i-843e7a44c682">先决条件和动机</a></li><li id="c142" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq kr ks kt ku dt translated"><a class="ae kv" rel="noopener" href="/coinmonks/a-crash-course-on-proof-of-stake-part-ii-96aeea8a0f58">利益证明的概念证明</a></li><li id="089d" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq kr ks kt ku dt translated">分散随机数生成简介<strong class="ki hu"> <em class="lb">(本帖)</em> </strong></li><li id="71ed" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq kr ks kt ku dt translated">可验证延迟函数和可验证秘密共享<em class="lb">(即将推出)</em></li><li id="7a77" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq kr ks kt ku dt translated">没什么利害关系和远程攻击<em class="lb">(即将推出)</em></li></ul><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff lc"><img src="../Images/903b0cbd7ccb6aa45e38161430cb9121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dOGYrKUD1KS1JaGSXy44jg.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Adopted from an original by <a class="ae kv" href="https://pixabay.com/en/users/analogicus-8164369/" rel="noopener ugc nofollow" target="_blank">analogicus</a> on pixabay.com</figcaption></figure><p id="27a3" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">在最后一部分中，我介绍了一个简单实用的利害关系证明方案，它在安全性方面有严重的缺陷。其中一个缺点是我们的随机性来源的偏差能力，即最后一个块的散列；在每一轮中，被选中的矿工被允许并被激励去偏向随机数的结果，以增加他再次被选中成为下一个区块的矿工的概率。</p><p id="1d6b" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">为了解决这个问题，我们深入研究了分散随机数生成(DRNG)机制。首先，我们看到一个评估不同drng的框架，然后我们回顾drng的主要类型。开始吧！</p><p id="b1d3" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated"><em class="lb">这部分会有点技术性，如果你觉得有些东西不清楚或难以理解，请告诉我。</em></p></div><div class="ab cl mh mi hb mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hm hn ho hp hq"><h1 id="50be" class="mo jj ht bd jk mp mq mr jo ms mt mu js iz mv ja jw jc mw jd ka jf mx jg ke my dt translated">分散随机数生成</h1><p id="1d93" class="pw-post-body-paragraph ls lt ht ki b kj kk iu lv kl km ix lx jt mz lz ma jx na mc md kb nb mf mg kq hm dt translated">DRNG机制是一组人在不依赖任何第三方的情况下协作生成一个随机数的过程。在我们继续讨论细节之前，让我先介绍一个简单的DRNG。</p><h2 id="31ea" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">朴素异或(上)</h2><p id="0d3b" class="pw-post-body-paragraph ls lt ht ki b kj kk iu lv kl km ix lx jt mz lz ma jx na mc md kb nb mf mg kq hm dt translated">假设我们已经部署了一个智能契约来执行我们的方案。首先，它允许任何人注册成为DRNG机制的参与者；假设到目前为止已经有N名参与者注册。在每一轮中，该机制执行以下步骤来生成随机数:</p><ol class=""><li id="ef32" class="kg kh ht ki b kj lu kl lw jt nc jx nd kb ne kq nf ks kt ku dt translated">每个参与者必须在本地抽取一个随机数。我们把第<em class="lb"> i </em>个参与者的本地随机数称为<em class="lb"> R_i </em>。</li><li id="aeef" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq nf ks kt ku dt translated">所有参与者必须向智能合同提交他们的本地随机数。</li><li id="fa39" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq nf ks kt ku dt translated">输出是我们协作生成的随机数，计算如下:</li></ol><figure class="ld le lf lg fq lh fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/f3f3411e3c56b2b8d9829a980e9387da.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/format:webp/1*nmOocPwzRQK9SsXky3l07w.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Equation #1</figcaption></figure><p id="77ef" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">如果参与者没有发送他的份额，我们简单地忽略该份额。此外，我们可以要求人们在注册时在智能合同中投入一些硬币，这样如果他们碰巧没有反应，我们就可以烧掉这些股份。</p><p id="b111" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">细心的读者可能会想，我们将如何使用<em class="lb"> R </em>作为下一个块挖掘器的决定者，而<em class="lb"> R </em>在生成之前需要许多新块(因为我们正在使用智能合同生成<em class="lb"> R </em>)。嗯，我们可以生成我们想要的那么大的<em class="lb"> R </em>并将其分成块，比如说<em class="lb"> m </em>块，然后我们可以使用这些块来选择所有后续<em class="lb"> m </em>块的挖掘器。</p><h2 id="6255" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">DRNG对利益相关证明的期望特征</h2><p id="2544" class="pw-post-body-paragraph ls lt ht ki b kj kk iu lv kl km ix lx jt mz lz ma jx na mc md kb nb mf mg kq hm dt translated">到目前为止，我们已经了解了两种不同的DRNG机制，<em class="lb">最后一个块哈希</em>和<em class="lb">朴素异或</em>，但是我们仍然没有一个框架来相互比较drng。以下是<a class="ae kv" href="https://eprint.iacr.org/2016/1067.pdf" rel="noopener ugc nofollow" target="_blank">【1】</a>中DRNG在利益相关证明协议中所需的特性列表。</p><ul class=""><li id="8036" class="kg kh ht ki b kj lu kl lw jt nc jx nd kb ne kq kr ks kt ku dt translated"><strong class="ki hu">可用性(活跃度)</strong>:尽管有恶意节点参与，但成功完成。</li><li id="ffb7" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq kr ks kt ku dt translated"><strong class="ki hu">不可预测性</strong>:在完成之前，没有人知道关于输出的任何事情。</li><li id="62b5" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq kr ks kt ku dt translated"><strong class="ki hu">无偏</strong>:输出随机均匀分布，尽管有恶意节点参与。</li><li id="f9fa" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq kr ks kt ku dt translated"><strong class="ki hu">可验证</strong>:输出正确性可由第三方检查。这意味着，必须存在一个不可伪造的见证(或证明)来验证该输出是流程的唯一有效输出。</li><li id="d20b" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq kr ks kt ku dt translated">可扩展的:可由许多参与者执行；足够低的计算和通信复杂度。</li></ul><p id="69b1" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">一个好的DRNG必须大概率满足上述性质。</p><h2 id="cd41" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">最后一块散列</h2><p id="ff0b" class="pw-post-body-paragraph ls lt ht ki b kj kk iu lv kl km ix lx jt mz lz ma jx na mc md kb nb mf mg kq hm dt translated">现在我们有了合适的方法，让我们来权衡一下最后一个块哈希机制的优缺点。</p><ul class=""><li id="8350" class="kg kh ht ki b kj lu kl lw jt nc jx nd kb ne kq kr ks kt ku dt translated"><strong class="ki hu">可用\\<br/>T30】只要区块链保持可用，最后一个块哈希机制保持可用。</strong></li><li id="75c3" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq kr ks kt ku dt translated">不可预测性 ✘ <br/>最后一个方块矿工实际上比任何人都更早知道结果。</li><li id="c434" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq kr ks kt ku dt translated">不偏不倚的✘最后一个块生产者能够测试多个有效块，并且只广播对她有利的一个。</li><li id="cb08" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq kr ks kt ku dt translated"><strong class="ki hu">可证实的</strong> ✘ <br/>没有证人或证明证明最终的区块是唯一可生产的区块。(事实上，在可能的情况下使用多个块。)</li><li id="4879" class="kg kh ht ki b kj kw kl kx jt ky jx kz kb la kq kr ks kt ku dt translated"><strong class="ki hu">可扩展的</strong>:DRNG只受限于区块链的可扩展性。它不需要额外的链上或链外消息。</li></ul><h2 id="0a7a" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">朴素异或(第二部分)</h2><p id="51b6" class="pw-post-body-paragraph ls lt ht ki b kj kk iu lv kl km ix lx jt mz lz ma jx na mc md kb nb mf mg kq hm dt translated">我们来分析一下朴素的异或方案。首先，请注意，每个人都能够在流程完成之前观察事务并了解<em class="lb"> R_i </em> s。因此，<strong class="ki hu">最后一个向智能合约提交其份额的参与者</strong>可以提交<em class="lb"> R_N </em>，使得<em class="lb"> R </em>等于他想要的任意数字！<em class="lb">这叫最后一个演员问题。</em>所以，这个方案的输出不是<em class="lb">无偏的</em>，<em class="lb">不可预测的</em>也不是<em class="lb">可验证的</em>。</p><p id="c54b" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">只要至少有一个参与者提交了她的份额，这个方案就会不断产生新的随机数；此外，不响应的参与者会受到惩罚。因此，将简单的Xor视为可用的方案是公平的。</p><p id="eeb3" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">每个块所需的链上事务的数量是<em class="lb"> N/m </em>，如果我们假设<em class="lb"> m </em>为常数，我们就不能在参与者数量巨大的情况下执行这个方案。因此，我认为朴素Xor是<em class="lb">不可销售的</em>。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/036b098d66f18230078bd07649467116.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*M1SubLQB0rrSANwphY0h3g.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Naive Xor</figcaption></figure><h2 id="8b6a" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">提交-显示异或</h2><p id="e094" class="pw-post-body-paragraph ls lt ht ki b kj kk iu lv kl km ix lx jt mz lz ma jx na mc md kb nb mf mg kq hm dt translated">朴素Xor的主要缺点是最后一个参与者能够在提交它之前自适应地改变他的份额。很自然的想法是<strong class="ki hu">限制参与者，使他们在看到其他参与者的份额后不能更改自己的份额</strong>。为了实现这一想法，我们将一个<em class="lb">步骤0 </em>添加到朴素Xor，如下所示:</p><p id="1903" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">0.每个参与者必须首先提交其随机数的散列。因此，第<em class="lb"> i </em>个参与者提交散列<em class="lb"> (R_i) </em>。</p><p id="d161" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">然后我们按照朴素异或的步骤。显然要求<em class="lb"> R_i </em>和<em class="lb"> Hash(R_i) </em>一致，否则第<em class="lb"> i </em>个参与者将受到惩罚。</p><p id="ead1" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">这样，最后一个行动者不能自适应地改变他的份额以使<em class="lb"> R </em>等于任意值。然而，他仍然可以决定发表或不发表他的份额。因此，他能够在某种程度上使结果有偏差。</p><p id="a01f" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">为了使该方案可验证，我们必须在每次甚至一个人没有提交他的份额时终止过程，并再次重复整个过程。这样，每个人都可以观察区块链，并验证产生的随机数<em class="lb"> R </em>是唯一可产生的随机数。(<em class="lb">)这会引起一些其他问题，但我不会详细说明。</em>)</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/eaae24edfd834f1207c1d704a0d059e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*-4WZ2x4RIY6BW5uuvsHiow.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Commit-Reveal Xor</figcaption></figure><h2 id="267a" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">哈希洋葱异或</h2><figure class="ld le lf lg fq lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff ni"><img src="../Images/9ea794bc81b8afa35ec1b2696325229a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VqF6v46OZj9kTQEa1zG6Nw.jpeg"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Hash Onion is <em class="nj">multi layered</em> commit. Copyright reserved for <a class="ae kv" href="http://www.onionsnz.com" rel="noopener ugc nofollow" target="_blank">onionsnz.com</a>.</figcaption></figure><p id="c8f0" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">最后两个方案，朴素Xor和提交-揭示Xor，是不可扩展的，因为随着参与者数量的增加，它们需要大量的链上事务。想法是以减少所需消息数量的方式改变提交-揭示步骤。换句话说，这个想法是<strong class="ki hu">让参与者能够用每条消息</strong>承诺一个以上的价值。</p><p id="5c2a" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated"><em class="lb"> Hash onion </em>是一个只使用一条小消息提交一系列值的工具。对于任意值<em class="lb"> x </em>，我们定义<em class="lb"> C(x，i) </em>如下:</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/c26cf3d9f935c7909433ea3bcb9e8a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*ta2Ev-exL3ousGT1B6pp3w.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Equation #2</figcaption></figure><p id="4bfd" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">比如<em class="lb"> C(x，2) </em>是<em class="lb"> C(x，1) </em>的hash，<em class="lb"> C(x，1) </em>是<em class="lb"> C(x，2) </em>的<a class="ae kv" href="https://en.wiktionary.org/wiki/preimage" rel="noopener ugc nofollow" target="_blank">前像</a>。如果一个人向C(x，2)提交，他向一系列值提交:<em class="lb"> x，hash(x)，hash(hash(x)) </em>。</p><p id="103e" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated"><em class="lb">下面是哈希洋葱Xor方案:</em>每个块必须包含一个名为<em class="lb"> R </em>的字段和一个名为<em class="lb">前像</em>的字段。我们将<em class="lb">场R </em>和<em class="lb">场预图像</em>设置为等于genesis块中的任意值。任何人都可以通过下注一些硬币并提交随机值<em class="lb"> R_i </em>的<em class="lb"> C(R_i，m) </em>来注册为准矿工。注意<em class="lb"> m </em>是协议中预定义的常数。在每一轮中，协议根据<em class="lb"> R </em>从一组注册挖掘器中选择下一个块挖掘器。被选中的矿工必须剥掉一层他承诺的洋葱！为此，矿工将<em class="lb">场预映像</em>设置为等于他已提交的最后<em class="lb"> C(x，i) </em>的预映像(通过注册为矿工或通过产生块)。那么他必须如下设置字段R:</p><p id="445f" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated"><em class="lb">(新块的R) =(最后块的R) xor(新块的前图像)</em></p><p id="07d8" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated"><strong class="ki hu">例如</strong>，如果<em class="lb"> V </em>被选为下一个块的挖掘者，并且如果他挖掘的最后一个块的预图像等于<em class="lb"> C(R_V，5) </em>，他必须用<em class="lb"> C(R_V，4)填充新块的预图像字段。</em></p><p id="c26c" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">在一个矿工开采完m+1个区块后，她的洋葱被完全剥掉，他不得不再次注册并提交一个新的洋葱。注意，在这个方案中，我们每个块只传送2个额外的消息。因此，即使有大量参与者，它也是可执行的。</p><p id="28cf" class="pw-post-body-paragraph ls lt ht ki b kj lu iu lv kl lw ix lx jt ly lz ma jx mb mc md kb me mf mg kq hm dt translated">现在我们有了<em class="lb">可用性</em>、<em class="lb">可验证性</em>和<em class="lb">可扩展性</em>。但是我们的方案<em class="lb">仍然缺少</em> <em class="lb">不可预测性</em>和<em class="lb">无偏性</em>。被选中的下一个矿工可以决定是取消提交还是不广播新的块。所以他比其他人更早知道最终结果，他可以偏向于对自己有利的方面。</p><figure class="ld le lf lg fq lh fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/13b4f30fe21c27f0e0d0c4134e83642c.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*EuB6mJ0f5F6EXS3gq6NQsQ.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Hash Onion Xor</figcaption></figure></div><div class="ab cl mh mi hb mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hm hn ho hp hq"><h1 id="004a" class="mo jj ht bd jk mp mq mr jo ms mt mu js iz mv ja jw jc mw jd ka jf mx jg ke my dt translated">下一步是什么？</h1><p id="cfad" class="pw-post-body-paragraph ls lt ht ki b kj kk iu lv kl km ix lx jt mz lz ma jx na mc md kb nb mf mg kq hm dt translated">有没有任何已知的DRNG机制可以满足所有这些期望的性质？！幸好是的！我们将研究<strong class="ki hu"> <em class="lb">可验证延迟函数</em> </strong> <em class="lb"> </em>和<strong class="ki hu"> <em class="lb">可验证秘密共享</em> </strong> <em class="lb"> </em>作为使我们能够建立这样的DRNG机制的关键工具。下一部分再见！:)</p><h1 id="9876" class="mo jj ht bd jk mp nl mr jo ms nm mu js iz nn ja jw jc no jd ka jf np jg ke my dt translated">参考</h1><p id="4457" class="pw-post-body-paragraph ls lt ht ki b kj kk iu lv kl km ix lx jt mz lz ma jx na mc md kb nb mf mg kq hm dt translated">[1]<a class="ae kv" href="https://eprint.iacr.org/2016/1067.pdf" rel="noopener ugc nofollow" target="_blank">https://eprint.iacr.org/2016/1067.pdf</a></p><blockquote class="nq"><p id="ae36" class="nr ns ht bd nt nu nv nw nx ny nz kq ek translated"><a class="ae kv" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ob oc od oe of lh fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff oa"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>