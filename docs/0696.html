<html>
<head>
<title>Distributed Environments and Data Storages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式环境和数据存储</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/distributed-environments-and-data-storages-7926773941bf?source=collection_archive---------3-----------------------#2018-06-04">https://medium.com/coinmonks/distributed-environments-and-data-storages-7926773941bf?source=collection_archive---------3-----------------------#2018-06-04</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="4213" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">如何避免竞态条件(以及最终的并发性)噩梦的微妙指南</h2></div><h2 id="aebb" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">在深入探讨这个话题之前</h2><p id="235a" class="pw-post-body-paragraph kg kh ht ki b kj kk iu kl km kn ix ko jt kp kq kr jx ks kt ku kb kv kw kx ky hm dt translated">在分布式环境中，在开始任何企业之前，有相当多的考虑事项需要明确。这些考虑必须在开始之前从基础开始，因为否则，像许多其他努力一样，当产品或功能发布时，臭名昭著的技术债务将对您团队的性能和永无止境的bug列表产生重大影响，影响您产品的健康。</p><p id="aa03" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">当事情变得如此混乱时，最容易被忽视的组件之一是数据存储和竞争条件(大多数情况下，与并发性问题相结合，这是一种组合)。这通常不会出现在单片应用程序中，因为它们的关注点是集中的，但是它们提供了另一组我们今天不会讨论的问题。</p><p id="3a6a" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">分布式环境的自然设计为这类问题的滋生提供了一个真正健康的土壤，事实是，没有什么圣杯可以拯救你，你需要设计并预期失败是你架构的一部分。当组件构建在继承了潜在问题的其他架构和解决方案之上时，一些团队会很挣扎，因此遭受了容易与其他情况混淆的症状。</p><p id="a7ec" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">同样重要的是要记住，分布式环境不仅适用于B2B应用程序中相互交流的系统，也适用于面向客户的应用程序，如JS web应用程序、IOT和移动应用程序。它们都处理依赖于底层存储的状态(或反应性)对象。</p><h2 id="488e" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">问题是</h2><p id="5c92" class="pw-post-body-paragraph kg kh ht ki b kj kk iu kl km kn ix ko jt kp kq kr jx ks kt ku kb kv kw kx ky hm dt translated">请考虑下图:</p><figure class="lf lg lh li fq lj fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff le"><img src="../Images/62c45a698ff7346719d51357355cb13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wAPgMOZfi8gkFzq93Fmhfw.jpeg"/></div></div></figure><p id="cf87" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">发生了以下事件:</p><ol class=""><li id="f61f" class="lq lr ht ki b kj kz km la jt ls jx lt kb lu ky lv lw lx ly dt translated">对象存储在数据库中，然后由服务(A)请求</li><li id="2661" class="lq lr ht ki b kj lz km ma jt mb jx mc kb md ky lv lw lx ly dt translated">微秒(或任何相关的时间单位)之后，另一个服务(B)请求该对象的另一个副本</li><li id="9f9d" class="lq lr ht ki b kj lz km ma jt mb jx mc kb md ky lv lw lx ly dt translated">服务A在对象中进行更改，并将其保存在数据存储中</li><li id="3eca" class="lq lr ht ki b kj lz km ma jt mb jx mc kb md ky lv lw lx ly dt translated">服务B在对象中进行更改，并在几微秒后将其保存在数据存储中。</li><li id="f543" class="lq lr ht ki b kj lz km ma jt mb jx mc kb md ky lv lw lx ly dt translated">此时，服务A所做的更改将会丢失</li></ol><blockquote class="me mf mg"><p id="f9a8" class="kg kh mh ki b kj kz iu kl km la ix ko mi lb kq kr mj lc kt ku mk ld kw kx ky hm dt translated">因此..发生了什么事？数据已被覆盖</p></blockquote><p id="d85d" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">在分布式系统中，一个对象属于一个组件/系统(所有者),其他组件要访问它，需要向所有者请求该对象的副本。例如，有一个管理用户配置文件微服务，所以每当一个组件想要与用户配置文件交互时，它都会请求这个微服务进行访问。通过将对象发送回微服务所有者，对此副本的任何修改都可以保存到存储中。现在，如果将此乘以数据上的操作和组件交换和交互的数量，图中的前一个示例很可能会发生，虽然很难发现，但还是发生了。</p><p id="3855" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">这种情况与传输协议无关，可以是简单的HTTP表单、JSON-REST、WSDL web服务、web-socket、grpc……总之，问题属于数据层和业务逻辑，而不是传输层。</p><p id="92d9" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">这是让每个组件或微服务通过SQL(或任何其他语言)直接访问底层数据库的一种折衷，只要考虑向表中添加一个属性，您就必须修改所有组件，并且业务规则也必须更新。看待这一点的最佳方式就像一个单片应用程序是如何构建的，你可能在一个库中共享了一个完全相同的组件，所以最终，这也适用于某种形式的单片应用程序。</p><h2 id="8d12" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">解决方案</h2><p id="a7f7" class="pw-post-body-paragraph kg kh ht ki b kj kk iu kl km kn ix ko jt kp kq kr jx ks kt ku kb kv kw kx ky hm dt translated">首先，我们需要简化问题，或者像一些人实际上认为的那样:找到真正的问题，问问你自己你实际上需要什么，以及你是否需要。让我们先回顾一些常见的方法，并谈谈潜在的问题:</p><p id="a9ff" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">A.)Paxos和任何其他共识算法都不在讨论之列，因为它们更有可能帮助数据存储副本(想想数据中心)之间的数据同步。这不是我们正在讨论的问题。</p><p id="2146" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">B.)你可能会尝试谷歌的概率故障感知分布式系统，但你真的需要它吗？如果你的SaaS主要存在是基于解决这个问题，当然，否则这可能是一种矫枉过正的方法。</p><p id="70f5" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">C.)保留一个“last updated”字段(或者更昂贵的、对象的计算散列属性表示)，您可以在对象的所有者处检查该字段，以便在进行任何其他修改之前查看对象是否已经更改？这很可能会奏效，确保所有其他组件都可以处理错误(如开头所说:设计和预期失败)。这是在反应式数据存储上完成的，这仅涉及WEBAPP或移动设备中的单个用户，但对于B2B或系统到系统的通信来说，这并不简单，还可能是过度杀戮和性能下降的解决方案。</p><p id="f47f" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">D.)底层存储和所有者组件是否支持仅更新已更改的属性？是的，如果消费者(或更新副本对象的服务)只发送已更改的字段(信任)，这将是可行的。使用这种方法和我们的第一个图表示例，这就像一个“合并”操作。但是如果两者都在改变同一个属性呢？或者他们依靠一个随时间变化的属性来做决定？</p><p id="66fa" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">E.)数据库已经通过事务、行级锁定、ACID组件和许多其他特性解决了这个问题，此时您可能会问自己，但是……您是否打算让所有分布式系统直接与数据库对话来访问对象/模型？这当然是可行的，但是你为维护解决方案所创造的复杂程度是最糟糕的。</p><p id="a5b0" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">F.)有一个反应层，会通知大家存储发生了变化？当然，这是可行的，而且可能是最好的技术和更好的解决方案。但是你的产品能估算出它有多贵，有多复杂吗？想象一个google文档，想象它背后的所有基础设施支持那些套接字和它背后的pub/sub组件，以确保事情顺利和实时地进行，在没有应用业务规则的情况下，基本上是相同的。</p><p id="395e" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">在他这一点上我们已经没有主意了，也许解决方案在解决方案c .)和d .)和f .)之间，但是，我们100%确定问题会消失吗？而答案是<strong class="ki hu"> <em class="mh">没有</em> </strong>这是为什么:</p><blockquote class="me mf mg"><p id="0109" class="kg kh mh ki b kj kz iu kl km la ix ko mi lb kq kr mj lc kt ku mk ld kw kx ky hm dt translated">问题不在于对数据的串行或并发访问，而在于谁(以及如何)对数据做出决策并决定最终状态。</p></blockquote><h2 id="eabe" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">如何克服这个问题(微妙指南)</h2><p id="28fd" class="pw-post-body-paragraph kg kh ht ki b kj kk iu kl km kn ix ko jt kp kq kr jx ks kt ku kb kv kw kx ky hm dt translated">确保每个组件、系统或服务不仅拥有对象，还拥有附属于它的逻辑和业务逻辑。如果你在不同的组件中修改一个对象的属性，你会产生一个群体性的交流问题。使用相同的图表:</p><ul class=""><li id="4423" class="lq lr ht ki b kj kz km la jt ls jx lt kb lu ky ml lw lx ly dt translated">如果服务A不是将对象克隆的整个表示发送给所有者服务，而是发送要修改的值，则所有者服务可以做出更好的决定。</li><li id="4580" class="lq lr ht ki b kj lz km ma jt mb jx mc kb md ky ml lw lx ly dt translated">如果所有服务都向所有者服务报告更改，那么所有者服务可以以类似无状态的方式处理这种情况。</li><li id="1b94" class="lq lr ht ki b kj lz km ma jt mb jx mc kb md ky ml lw lx ly dt translated">这将为API和其他类型的交互扩展CRUD的错误使用性质，因为操作变得不仅仅是“更新”，相反，它将是需要在底层中触发的对另一个规则或信号作出反应的通知。</li></ul><p id="ec15" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">不要把事情搞得太复杂，如果逻辑封装得很好，过程很简单，你就可以通过设计创建一个廉价的快速处理组件，这当然会减少类似问题发生的几率。</p><ul class=""><li id="fc28" class="lq lr ht ki b kj kz km la jt ls jx lt kb lu ky ml lw lx ly dt translated">所有的数据操作都需要发生在最低层，这意味着如果你能把一个过程封装在一个存储过程中，将会比试图在其他层解决它更好，更能解决其他类型的问题。</li><li id="4dde" class="lq lr ht ki b kj lz km ma jt mb jx mc kb md ky ml lw lx ly dt translated">如果您不喜欢存储过程或者存储过程对您不可用，那么定义对象的下一层就是拥有它的层，它可以做出比任何其他组件更好的决策。</li><li id="ef5f" class="lq lr ht ki b kj lz km ma jt mb jx mc kb md ky ml lw lx ly dt translated">并发和竞争条件与时间有着内在的联系，所以在一个操作中花费的时间越少越好。如果你有一个很长的IO或外部API调用过程，并且这个过程在最后修改了一个对象，你很可能会遇到这个问题。</li><li id="599e" class="lq lr ht ki b kj lz km ma jt mb jx mc kb md ky ml lw lx ly dt translated">如果您正在创建的流程(或方法)正在更改数据，并且没有事务支持，那么您可能需要重新考虑您的设计和方法，因为创建损坏数据的可能性很高……非常高。</li></ul><p id="9a56" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">最后，将真正的关注点转移给服务的所有者将会提供更好、更清晰的交流，所有的组件都可以理解，并且遵循关注点分离的实践。在一个“面向对象编程2.0”的世界中，解决方案架构开始出现一些问题，这些问题在过去已经通过试图使代码更容易理解和更优雅(这很好)而得到了解决，但最终会矫枉过正。</p></div></div>    
</body>
</html>