<html>
<head>
<title>The Contract Prelude: A Case Study</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合同前奏:一个案例研究</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/the-contract-prelude-a-case-study-b82352dec8b9?source=collection_archive---------0-----------------------#2019-04-08">https://medium.com/coinmonks/the-contract-prelude-a-case-study-b82352dec8b9?source=collection_archive---------0-----------------------#2019-04-08</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/cdfa8fda2dd5a1050a2a27afb6e9afaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbM0GFWQ1xSkXtPQcYssjw.png"/></div></div></figure><blockquote class="jb jc jd"><p id="6ded" class="je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">嗯——合同前奏？我以前从未听说过这个术语…</p></blockquote><p id="702e" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">我们会谈到这一点，但在进入合同前奏之前，为什么它有用，以及如何正确使用它，请允许我分享一个关于我最初如何对它们产生兴趣的小故事。</p><p id="436a" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">当君士坦丁堡/圣彼得堡上线时，我着手在Mainnet上执行第一个合同<a class="ae kg" rel="noopener" href="/@0age/the-promise-and-the-peril-of-metamorphic-contracts-9eb8b8413c5e">变形记</a>。现在，变形契约的目标是能够部署一个<strong class="jh hu">防白痴契约</strong>，一个总是可以用新代码“重置”的契约，不管你犯了多么糟糕的错误<em class="jg">(因为，让我们面对它:每个人都会犯错误)。</em>带着这个目标，我建立了一个<a class="ae kg" href="https://etherscan.io/address/0x00000000c9329eab0ede00c18accad77db00aa73" rel="noopener ugc nofollow" target="_blank">变形合同工厂</a>并且<a class="ae kg" href="https://etherscan.io/address/0x714352eb3b0198e9c830a8c4bf16705db89a078f#code" rel="noopener ugc nofollow" target="_blank">用一个小消息在块<code class="eh kh ki kj kk b">7280025</code>中部署了一个合同</a>，意图通过一个简单的<code class="eh kh ki kj kk b">CALL</code>来<code class="eh kh ki kj kk b">SELFDESTRUCT</code>它并且部署一个新的。</p><p id="f2ab" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">然而，我很快意识到我犯了一个错误——<code class="eh kh ki kj kk b">SELFDESTRUCT</code>是第一个操作码，但我没有先在堆栈上放置一个转发地址，这意味着调用<strong class="jh hu">会导致堆栈下溢，因此契约无法重置！</strong>(别慌:我在<code class="eh kh ki kj kk b">7280046</code>区块部署了一个新的变形契约，在<code class="eh kh ki kj kk b">7280070</code>区块<a class="ae kg" href="https://etherscan.io/address/0x000000009042b40070c8f83bff1293005dc25257#code" rel="noopener ugc nofollow" target="_blank">成功重新绑定</a>。)</p><p id="28ca" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">这凸显了变形合同的一个奇怪的怪癖——它们遭遇了与大多数合同完全相反的问题。而<em class="jg">通常</em>的第一法则是<strong class="jh hu">不惜一切代价避免</strong>达成<code class="eh kh ki kj kk b">SELFDESTRUCT</code>，第一法则为<em class="jg">变质</em>契约<em class="jg">(假设你想让</em> <strong class="jh hu"> <em class="jg">待</em> </strong> <em class="jg">变质)</em>是为了<strong class="jh hu">保证</strong>契约无论如何都能达成<code class="eh kh ki kj kk b">SELFDESTRUCT</code>、<strong class="jh hu">！</strong></p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff kl"><img src="../Images/e534a9dc3fc3cf809c121610a04dabef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GlVwCE5c0lzKz64D_BdPkQ.jpeg"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Metamorphic contracts do not fear destruction—they yearn for it!</figcaption></figure><p id="ffc3" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">此后不久，我无意中发现了另一个大脚炮<em class="jg">(也许脚炮-</em><strong class="jh hu"><em class="jg">nuke</em></strong><em class="jg">更恰当)</em>在处理变形契约时，<a class="ae kg" href="https://etherscan.io/address/0x000000000073b6eeb97a1b007fa833561b10be1e" rel="noopener ugc nofollow" target="_blank">在这里演示了</a>并如此概括:向一个契约发送一个魏，<code class="eh kh ki kj kk b">SELFDESTRUCT</code>它，并将魏转发回它自己——然后<strong class="jh hu">噗！那个魏不见了</strong>。不仅仅是某处无法挽回，而是<strong class="jh hu"> <em class="jg">全军覆没！</em> </strong>把“燃烧的乙醚”这个概念放在了一个全新的角度。</p><p id="6615" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">这不仅仅是一个让it部门对<code class="eh kh ki kj kk b">selfdestruct(address(this))</code>负责的问题——假设您创建了与魏的合同<code class="eh kh ki kj kk b">A</code>和与魏的合同<code class="eh kh ki kj kk b">B</code>，其中<code class="eh kh ki kj kk b">A</code>在销毁时将资金转发给<code class="eh kh ki kj kk b">B</code>，而<code class="eh kh ki kj kk b">B</code>将资金转发给<code class="eh kh ki kj kk b">A</code>。您可能已经知道，当调用<code class="eh kh ki kj kk b">SELFDESTRUCT</code>时，契约只被<strong class="jh hu"> <em class="jg">调度</em> </strong>销毁，但实际上在事务结束时被<em class="jg">删除</em>。然后，您可能会假设账户余额也在交易结束时被<strong class="jh hu"> <em class="jg">转发</em> </strong>给收款人——在这种情况下，您的假设是错误的！</p><p id="2817" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">资金实际上是由<code class="eh kh ki kj kk b">SELFDESTRUCT</code><strong class="jh hu"/>、<strong class="jh hu"> </strong> <em class="jg">(甚至不能被收款人拒绝，也不能像在</em> <code class="eh kh ki kj kk b">CALL</code> <em class="jg">、</em>中那样作出反应)但是一旦交易结束，如果已经安排在<code class="eh kh ki kj kk b">SELFDESTRUCT</code>中，它们将被永久销毁。因此，如果您销毁同一个事务中的<code class="eh kh ki kj kk b">A</code>，那么<code class="eh kh ki kj kk b">B</code>，您将获得以下余额序列:</p><p id="d8a5" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated"><code class="eh kh ki kj kk b">{a: 1, b: 1} =&gt; {a: 0, b: 2} =&gt; {a: 2, b: 0} =&gt; {a: 0, b: 0}</code></p><p id="5595" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">我还会提到，在合同被销毁之前，资金可以从已经计划删除的合同中解救出来— <a class="ae kg" href="https://ropsten.etherscan.io/address/0x644a703af3cacd9954dcc758ea004f449a666a94#code" rel="noopener ugc nofollow" target="_blank">这里有一个例子</a>。此外，请记住，契约并不持有代币余额。相反，它们驻留在令牌契约的存储中，因此即使在<code class="eh kh ki kj kk b">SELFDESTRUCT</code>之后它们也将持续存在，这很好——只要您可以重新部署！</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ku"><img src="../Images/1991db60361e2f04d217d66de8e6f20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jEdhBQoiU-_L5NFL544DJw.jpeg"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Real heroes don’t run from the fire: they quench the flames!</figcaption></figure><blockquote class="jb jc jd"><p id="1194" class="je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">好了，轶事已经够多了— <strong class="jh hu">什么是合同前奏？！</strong></p></blockquote><p id="4e84" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">很公平，我就结束了，直奔主题。</p><h2 id="72a1" class="kv kw ht bd kx ky kz la lb lc ld le lf kd lg lh li ke lj lk ll kf lm ln lo lp dt translated">实现</h2><p id="7c47" class="pw-post-body-paragraph je jf ht jh b ji lq jk jl jm lr jo jp kd ls js jt ke lt jw jx kf lu ka kb kc hm dt translated">很明显，我们已经获得了用任意运行时代码重新部署契约所需的工具，但显然<strong class="jh hu"> <em class="jg">不是</em> </strong>傻瓜才知道。</p><p id="069e" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">我们需要一种方法来确保:</p><ul class=""><li id="9a7d" class="lv lw ht jh b ji jj jm jn kd lx ke ly kf lz kc ma mb mc md dt translated">契约总是可以被销毁，所以它总是可以被升级</li><li id="8be0" class="lv lw ht jh b ji me jm mf kd mg ke mh kf mi kc ma mb mc md dt translated"><strong class="jh hu">资金在<em class="jg">被</em>销毁时将被运送到安全的目的地</strong>，并在重新调配时返回合同。</li></ul><p id="8820" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">因此，我们需要确保我们的变形契约能够拿起武器对抗重重困难，并摆脱这种致命的束缚。但是，问题就在这里:合同需要自我毁灭。毕竟没有<code class="eh kh ki kj kk b">OTHER-DESTRUCT</code>操作码。我们如何确保契约总是可以被销毁，而不限制我们可以部署的契约类型或者期望它们每次都正确地实现适当的析构函数？<strong class="jh hu">通过使用合同前奏</strong>。</p><h2 id="8e8a" class="kv kw ht bd kx ky kz la lb lc ld le lf kd lg lh li ke lj lk ll kf lm ln lo lp dt translated">合同前奏</h2><p id="c8a6" class="pw-post-body-paragraph je jf ht jh b ji lq jk jl jm lr jo jp kd ls js jt ke lt jw jx kf lu ka kb kc hm dt translated">契约前奏是<strong class="jh hu">放置在契约运行时代码最开始的一段代码。</strong>正常情况下，Solidity契约将通过分配空闲内存指针、从调用数据中读取函数签名，并将签名传递给函数调度程序来启动执行，函数调度程序使用该签名跳转到所需的函数。相比之下，契约prelude被设计为在所有这些之前插入，并在调用契约时在函数调度器<em class="jg">(或任何其他东西)</em>之前执行。</p><p id="95a8" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">prelude可以用来在某些情况下转移契约行为，而不改变它们之前的契约的核心功能——以前有一个例子是关于透明代理的，代理的管理员可以管理契约升级，但是任何其他调用者都会触发一个<code class="eh kh ki kj kk b">DELEGATECALL</code>到实现契约。</p><p id="efb1" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">契约前奏也可以用于各种其他的好东西，比如存储元数据或者创建全局<strong class="jh hu"/><strong class="jh hu"/><strong class="jh hu">可拥有</strong><strong class="jh hu"/><strong class="jh hu"><em class="jg">仅</em></strong>可支付的契约，应有尽有。另一个用例是利用调用契约时提供的gas(或gas模某数)作为额外的、廉价的输入源——例如超高效的函数调度程序，它根据调用时使用的gas来选择跳转目的地！一个额外的、更好的应用程序是用于确定契约的运行时是在一个<code class="eh kh ki kj kk b">CALL</code>还是一个<code class="eh kh ki kj kk b">DELEGATECALL</code> <em class="jg">的上下文中执行(通过将</em> <code class="eh kh ki kj kk b">ADDRESS</code> <em class="jg">与一个硬编码的契约地址进行比较)</em>，并根据给定的上下文修改它的行为——例如，如果您知道调用是一个<code class="eh kh ki kj kk b">DELEGATECALL</code>，那么您可以在它上面运行一个套娃，并执行<strong class="jh hu"> <em class="jg">另一个</em> </strong> <code class="eh kh ki kj kk b">DELEGATECALL</code>，而不会有对契约进行不必要的修改的风险。最后，现在你可能已经自己解决了，这对于确保合同是可破坏的也非常有用。</p><p id="3593" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">假设我们在它部署的每个变形合同的合同序言中指定我们的合同工厂地址，使得从工厂合同到变形合同的<code class="eh kh ki kj kk b">CALL</code>将导致变形合同到<code class="eh kh ki kj kk b">SELFDESTRUCT</code>。对于任何其他<em class="jg">来电者，前奏将被安全跳过。然后，我们还指定一个<strong class="jh hu"> <em class="jg">不会</em> </strong> <code class="eh kh ki kj kk b">SELFDESTRUCT</code>的转发地址，将资金退回给合同。瞧，我们现在有了一个“硬化的”变形契约。现在，当工厂部署新合同时，它可以立即使用<code class="eh kh ki kj kk b">EXTCODECOPY</code>检查结果运行时代码的开始，如果没有正确的prelude，它将返回，取消整个操作！</em></p><p id="c79d" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">因此，Metapod的想法诞生了。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/1f101e5166d823dda069d60f55bd3667.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*t7xOAezRBkThc2n0JkdRLA.jpeg"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Nintendo, please don’t sue!</figcaption></figure><h2 id="0d4c" class="kv kw ht bd kx ky kz la lb lc ld le lf kd lg lh li ke lj lk ll kf lm ln lo lp dt translated">Metapod —硬化变质合同</h2><p id="5860" class="pw-post-body-paragraph je jf ht jh b ji lq jk jl jm lr jo jp kd ls js jt ke lt jw jx kf lu ka kb kc hm dt translated">Metapod是一个变形合同工厂，它可以防止非变形合同的部署和升级<em class="jg">时的资金损失(尽管只有当Metapod是通过prelude摧毁它的那个人时——如果你足够坚定，任何</em>  <em class="jg">合同都只能做这么多来保护你免于烧光你的筹码)</em>。代码可以在<a class="ae kg" href="https://github.com/0age/metamorphic/blob/master/contracts/Metapod.sol" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到，部署的契约实例可以在<a class="ae kg" href="https://etherscan.io/address/0x00000000002b13cccec913420a21e4d11b2dcd3c#code" rel="noopener ugc nofollow" target="_blank"> Mainnet </a>和<a class="ae kg" href="https://ropsten.etherscan.io/address/0x0000000000f647ba29e4dd009d2b7cada21c1c68#code" rel="noopener ugc nofollow" target="_blank"> Ropsten </a>上找到。</p><p id="a4e4" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">它要求以下44字节的序言出现在它部署的所有契约上:</p><pre class="km kn ko kp fq mk kk ml mm aw mn dt"><span id="96bb" class="kv kw ht kk b fv mo mp l mq mr">Metapod (Mainnet) - required prelude (44 bytes):<br/> 0x6e<!-- -->2b13cccec913420a21e4d11b2dcd3c3318602b5773<!-- --> ++<br/> dedicated_vault_address ++<br/> 0xff5b</span><span id="8ba1" class="kv kw ht kk b fv ms mp l mq mr">Metapod (Ropsten) - required prelude (44 bytes):<br/> 0x6e<!-- -->f647ba29e4dd009d2b7cada21c1c68<!-- -->3318602b5773 ++<br/> dedicated_vault_address ++<br/> 0xff5b</span></pre><p id="b318" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">下面是Ropsten实例<em class="jg">所需prelude的分解(注意，Metapod使用紧凑的</em> <a class="ae kg" rel="noopener" href="/@0age/on-efficient-ethereum-addresses-3fef0596e263"> <em class="jg">高效地址</em> </a> <em class="jg">和5个前导零字节)</em>:</p><pre class="km kn ko kp fq mk kk ml mm aw mn dt"><span id="1879" class="kv kw ht kk b fv mo mp l mq mr">Metapod (Ropsten) - prelude description<br/>pc op opcode                                   [stack]<br/>-- -- ---------------------------------------  -------------------<br/>// Push Metapod’s address to the stack (compact so PUSH15 works).<br/>00 6E PUSH15 0xf647ba29e4dd009d2b7cada21c1c68  [metapod_address]<br/> <br/>// Push the caller’s address to the stack.<br/>16 33 CALLER                                   [metapod, caller]<br/> <br/>// XOR the two — equals zero if they are equal, non-zero otherwise.<br/>16 18 XOR                                      [0 iff metapod]<br/> <br/>// Push program counter for the jumpdest at end of prelude to stack.<br/>18 60 PUSH1 0x2b                  [0 iff metapod, end_prelude_label]<br/> <br/>// Jump to end of prelude (pc 43) unless Metapod is the caller.<br/>20 57 JUMPI                                    []<br/> <br/>// If Metapod *is* caller, push vault contract’s address to stack.<br/>21 73 PUSH20 <!-- -->dedicated_vault_address<!-- -->           [vault_address]<br/> <br/>// Schedule account for deletion &amp; forward funds to vault contract.<br/>42 FF SELFDESTRUCT                             []<br/> <br/>// Otherwise we end up here with an empty stack and unused memory.<br/>43 5B JUMPDEST                                 []</span></pre><p id="d834" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">使用专用保险库合同的决定源于我们会计工作的简化。我们不是存储资金并跟踪工厂合同<em class="jg">中每个账户各自的余额(当资金通过</em> <code class="eh kh ki kj kk b">SELFDESTRUCT</code> <em class="jg">)转发时，我们无法处理资金的接收，这使任务变得非常复杂)，而是将每个账户的余额隔离在一个唯一的合同中，然后该合同可以在重新部署时将资金发送回相关的变形合同。</em></p><p id="2e42" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">保险库契约地址的推导稍微复杂一点，每个salt ( <code class="eh kh ki kj kk b">20_byte_caller_address ++ 12_byte_identifier =&gt; 32_byte_salt</code>)都有一个唯一的保险库，但是您可以通过调用Metapod上的<code class="eh kh ki kj kk b">findVaultContractAddress(bytes32 salt)</code>视图函数来确定给定salt的保险库，或者您可以只调用<code class="eh kh ki kj kk b">getPrelude(bytes32 salt)</code>来一次性获得给定salt的整个前奏。</p><p id="47d2" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">Metapod有三种状态更改方法:</p><ul class=""><li id="6f99" class="lv lw ht jh b ji jj jm jn kd lx ke ly kf lz kc ma mb mc md dt translated"><code class="eh kh ki kj kk b">deploy(uint96 identifier, bytes initializationCode)</code>取提供的合同初始化代码<em class="jg">(是的，</em> <strong class="jh hu"> <em class="jg">可以使用构造函数！</em> </strong> <em class="jg"> ) </em>并在通过<code class="eh kh ki kj kk b">CREATE2</code>部署临时契约时使用调用者的地址和提供的标识符作为salt。这个契约然后拉入初始化代码，并使用<code class="eh kh ki kj kk b">CREATE</code>部署变形契约，然后被销毁。当然，它会检查所需的前奏，如果有，就只允许部署。在实际需要之前，不会部署任何保险存储合同。</li><li id="1fd5" class="lv lw ht jh b ji me jm mf kd mg ke mh kf mi kc ma mb mc md dt translated"><code class="eh kh ki kj kk b">destroy(uint96 identifier)</code>将与给定标识符相关联的变形合同触发到<code class="eh kh ki kj kk b">SELFDESTRUCT</code>，将任何资金转发到专用金库合同。</li><li id="4e01" class="lv lw ht jh b ji me jm mf kd mg ke mh kf mi kc ma mb mc md dt translated"><code class="eh kh ki kj kk b">recover(uint96 identifier)</code>是一种专用的便捷方法，可以一次性清除具有给定标识符的金库、临时合同和变形合同，并将资金发送回调用者。不过，变形契约必须首先销毁。</li></ul><p id="5bda" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">太好了！所以我们拿起我们的契约，把必要的前奏贴在我们代码的前面，并把它提供给<code class="eh kh ki kj kk b">deploy</code> … <strong class="jh hu">，它回复</strong>。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mt"><img src="../Images/07fdfc904ca741654aafceadd9425723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0CV57dgE8fCiQwvcQLRVig.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">I was told there would be idiot-proofing…</figcaption></figure><p id="e28d" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">第一个问题是，我们将prelude放在契约的<strong class="jh hu"> <em class="jg">初始化代码</em> </strong>的开头，而不是契约的<strong class="jh hu"> <em class="jg">运行时代码</em> </strong>的开头。但是这是一个相对容易的解决方法:Solidity处理初始化的方式是运行所有的构造器逻辑，然后执行一个<code class="eh kh ki kj kk b">CODECOPY</code>将所有的运行时代码放入内存并返回它。然后，我们需要做的就是找到指定我们正在复制的代码长度的<code class="eh kh ki kj kk b">PUSH</code>，并将其增加prelude的大小，然后在运行时代码的开头插入prelude，而不是在初始化代码的开头。听起来不太难，对吧？</p><p id="f85e" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">你在寻找这样的序列:</p><pre class="km kn ko kp fq mk kk ml mm aw mn dt"><span id="c2ac" class="kv kw ht kk b fv mo mp l mq mr">...60xx8060yy6000396000f3fe6080604052...</span></pre><p id="b5f5" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">还要注意的是，<code class="eh kh ki kj kk b">60</code>的(<code class="eh kh ki kj kk b">PUSH1</code>)可能是<code class="eh kh ki kj kk b">61</code>的(<code class="eh kh ki kj kk b">PUSH2</code>)。这是细目分类:</p><pre class="km kn ko kp fq mk kk ml mm aw mn dt"><span id="2dab" class="kv kw ht kk b fv mo mp l mq mr">op opcode     [stack] &amp; &lt;memory&gt; &amp; *deployed_code*<br/>-- ---------- -----------------------------------------<br/>// push the length of the runtime code onto the stack.<br/>60 PUSH1 xx   [..., runtime_length]</span><span id="27c4" class="kv kw ht kk b fv ms mp l mq mr">// duplicate that value, used later for returning the runtime code.<br/>80 DUP1       [..., runtime_length, runtime_length]</span><span id="090e" class="kv kw ht kk b fv ms mp l mq mr">// push the offset of the runtime code (i.e. location in the code).<br/>60 PUSH1 yy   [..., runtime_length, runtime_length, code_offset]</span><span id="68b5" class="kv kw ht kk b fv ms mp l mq mr">// memory offset is zero — put runtime code at start of memory.<br/>60 PUSH1 0x00 [..., runtime_length, runtime_length, code_offset, 0]<br/> <br/>// place the runtime code into memory, consuming three stack items.<br/>39 CODECOPY   [..., runtime_length] &lt;runtime_code&gt;<br/> <br/>// push the return offset (zero) for code to return from memory.<br/>60 PUSH1 0x00 [..., runtime_length, 0] &lt;runtime_code&gt;<br/> <br/>// deploy runtime code, using same length as we did in codecopy.<br/>F3 RETURN     [...] *runtime_code*</span><span id="4806" class="kv kw ht kk b fv ms mp l mq mr">// the subsequent invalid opcode is there for safety, I guess.<br/>FE INVALID</span><span id="3bc9" class="kv kw ht kk b fv ms mp l mq mr">// runtime code begins here - not executed during initialization.<br/>60 PUSH1 0x80 <br/>60 PUSH1 0x40<br/>52 MSTORE<br/>...</span></pre><p id="96fa" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">所以我们只是通过增加前奏的大小来改变长度(<code class="eh kh ki kj kk b">xx</code>)。我们不需要改变偏移量(<code class="eh kh ki kj kk b">yy</code>)，除非<code class="eh kh ki kj kk b">PUSH1</code>需要改为<code class="eh kh ki kj kk b">PUSH2</code>，在这种情况下，我们还会将它增加<code class="eh kh ki kj kk b">1</code>。最后，我们移动prelude，使其位于<code class="eh kh ki kj kk b">INVALID</code>操作码和当前运行时代码之间。太好了，我们再试一次。</p><p id="20ec" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">这一次，<strong class="jh hu">合同成功部署！</strong>太好了，现在我们来试着用一下。</p><p id="fdee" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">还有…</p><p id="3eb7" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated"><strong class="jh hu"> <em class="jg">当</em> <em class="jg">吧！</em> </strong>我们称之为合同的抛出错误，到处都是<code class="eh kh ki kj kk b">Invalid JUMPDEST</code> s！</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mu"><img src="../Images/10d1f4da6a9a935658a91bf12b6766d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9TRhUYn_POxPyKw5VBofLw.jpeg"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Who would’ve thought that poking compiled EVM code would end up stirring up trouble like this?</figcaption></figure><p id="df30" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">怎么会这样嗯，<strong class="jh hu">运行时代码中所有的</strong> <code class="eh kh ki kj kk b"><strong class="jh hu">JUMP</strong></code> <strong class="jh hu">指令都被破坏</strong>。它们没有指向正确的<code class="eh kh ki kj kk b">JUMPDEST</code>——相反，它们指向比预期的<code class="eh kh ki kj kk b">JUMPDEST</code>早44个字节<em class="jg">的操作码，这很可能根本不是一个<code class="eh kh ki kj kk b">JUMPDEST</code>，或者充其量是一个错误的操作码。此外，如果你有静态常量，比如十六进制字符串之类的，这些都是关闭的，因为它们使用<code class="eh kh ki kj kk b">CODECOPY</code>来获取值，而不再指向正确的位置。</em></p><p id="4acc" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">好消息是我们的前奏还是不错的——谢谢，Metapod。我们可以销毁合同，再试一次。</p><p id="19ab" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">为了解决这个问题，我们有一个更困难的任务——我们必须弄清楚每个<code class="eh kh ki kj kk b">JUMP</code>(和<code class="eh kh ki kj kk b">JUMPI</code>)指向哪个<code class="eh kh ki kj kk b">JUMPDEST</code>，以及向每个<code class="eh kh ki kj kk b">CODECOPY</code>提供什么代码偏移量。然后，我们需要找到这些值的来源并修正它们。<em class="jg">(取决于如何使用，</em> <code class="eh kh ki kj kk b">PC</code> <em class="jg">操作码可能也需要修改——幸运的是，Solidity不会生成任何操作码，并且专门依赖静态</em> <code class="eh kh ki kj kk b">PUSH</code> <em class="jg"> es来设置跳转目的地。)</em></p><p id="3208" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">现在，这显然会在语言级别得到理想的处理，所以Solidity或Vyper只是根据提供的前奏正确地生成它们。但是有一种更简单的事后分析方法——我们可以尝试对编译后的运行时代码进行jumpdest分析，并在编译后对其进行修改。这就是我要做的，所以我做了一个名为<a class="ae kg" href="https://github.com/0age/metamorphic/blob/master/scripts/kakuna/kakuna.js" rel="noopener ugc nofollow" target="_blank">铁壳昆</a>T13】的概念验证(我知道，我就是忍不住)。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/18ca48f8bc5020b49a7655f1af44db84.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*AaYoGFMZjkW48URF7qdr9g.png"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Well, now I’m definitely getting sued… hopefully my pseudonym holds up!</figcaption></figure><h2 id="31e7" class="kv kw ht bd kx ky kz la lb lc ld le lf kd lg lh li ke lj lk ll kf lm ln lo lp dt translated">铁壳昆——翻转一些位并重新包装你的运行时</h2><p id="337b" class="pw-post-body-paragraph je jf ht jh b ji lq jk jl jm lr jo jp kd ls js jt ke lt jw jx kf lu ka kb kc hm dt translated">基本策略是遍历代码，将每个<code class="eh kh ki kj kk b">PUSH</code>值放入堆栈，并跟踪它在哪里被使用。如果它从未得到<code class="eh kh ki kj kk b">DUP</code>d，并最终作为<code class="eh kh ki kj kk b">JUMP</code>或<code class="eh kh ki kj kk b">JUMPI</code>目的地或<code class="eh kh ki kj kk b">CODECOPY</code>偏移量被使用，那么它可以安全地递增前导码的长度，就像我们之前对初始化代码所做的那样。当我们点击<code class="eh kh ki kj kk b">JUMPI</code>时，假设条件未知，我们<strong class="jh hu">分叉并尝试两个选项</strong>。</p><p id="3d9a" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">可悲的是，这个游戏计划很快土崩瓦解。简而言之，代码中潜在路径的数量很快就失控了。此外，您可能会遇到循环引用和其他愚蠢的情况，这会使代码不受静态分析的影响。从这里开始，通过操作代码的中间表示<em class="jg">(而不是字节码本身)</em>，可以改进铁壳昆。另一种使它更健壮的方法是使用一个“蹦床”，它存储从旧的<code class="eh kh ki kj kk b">JUMPDEST</code>到新的<em class="jg">(理想情况下通过非结构化存储)</em>的映射，然后在指向蹦床的所有现有的<code class="eh kh ki kj kk b">JUMP</code>和<code class="eh kh ki kj kk b">JUMPI</code>操作码前面插入一个跳转目的地，然后生成正确的<code class="eh kh ki kj kk b">JUMP</code>。此外，<a class="ae kg" href="https://github.com/ethereum/EIPs/issues/615" rel="noopener ugc nofollow" target="_blank"> EIP 615 </a>提议修改<code class="eh kh ki kj kk b">JUMP</code>语义，使之更符合eWASM的工作方式，这很好，但它也提议对现有的EVM进行相当重大的改革，这意味着我们将不得不用现有的东西来凑合。</p><p id="1f6c" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">这不是什么灵丹妙药，就像目前写的那样，对于复杂的合同几乎肯定会失败，但对于相对简单的东西，铁壳昆实际上可以完成这该死的事情。它还将执行我们上面使用的相同的初始化代码转换。因此，我们向它提供我们的初始化代码和我们想要插入的前奏，然后获取输出并将其交给Metapod。而且—瞧吧— <strong class="jh hu">它真的有效！</strong></p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mw"><img src="../Images/147881a522d7b9046ea8729c2b63f854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n03VC043ta1GLOCYarfFUA.jpeg"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">We did it — with only a few contract fatalities!</figcaption></figure><p id="c874" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">现在，这是不是比我们以前的更安全，更白痴？当然不是，但是如果你问我，它仍然是非常有趣的。代码验证被抛到了九霄云外，谁知道在转换后的代码中会隐藏着什么样的bug。如果编译器增加了对插入前奏的支持，这些问题将会得到缓解。与此同时，至少合同可以被固定和重新部署<em class="jg">(记住，合同状态被清除)</em>——我要冒险一试<strong class="jh hu">称之为胜利</strong>。</p><p id="9b9a" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">即使这个特殊的案例研究不是你所喜欢的，我也希望它能帮助你演示如何使用合同前奏来为你带来好处，假设你能避开潜在的陷阱。我的前辈们，让我们一起努力改进他们周围的工具！<em class="jg">(为此，使用现有的</em> <code class="eh kh ki kj kk b">solc</code> <em class="jg">功能来更可靠地插入前奏和修改输出的工作已经在进行中——敬请期待！)</em></p><p id="299a" class="pw-post-body-paragraph je jf ht jh b ji jj jk jl jm jn jo jp kd jr js jt ke jv jw jx kf jz ka kb kc hm dt translated">我要感谢我的许多同谋者和密友在这一努力中提供的帮助和反馈，包括<a class="ae kg" href="https://github.com/charles-cooper" rel="noopener ugc nofollow" target="_blank">查尔斯·库珀</a>、<a class="ae kg" href="https://telegram.me/raymondpulver" rel="noopener ugc nofollow" target="_blank">雷蒙德·普尔弗</a>、<a class="ae kg" href="https://twitter.com/ethlorenz" rel="noopener ugc nofollow" target="_blank">洛伦茨·布赖登巴赫</a>、<a class="mx my gr" href="https://medium.com/u/1aa2e52b3196?source=post_page-----b82352dec8b9--------------------------------" rel="noopener" target="_blank">夏羽·戈塞林</a>、<a class="ae kg" href="https://twitter.com/smpalladino" rel="noopener ugc nofollow" target="_blank">圣地亚哥·帕拉迪诺</a>、<a class="mx my gr" href="https://medium.com/u/2b893c124663?source=post_page-----b82352dec8b9--------------------------------" rel="noopener" target="_blank">马特·彻尼克</a>和<a class="ae kg" href="https://twitter.com/michaeldunwort1" rel="noopener ugc nofollow" target="_blank">迈克尔·邓沃斯</a>。</p><blockquote class="mz"><p id="7d6b" class="na nb ht bd nc nd ne nf ng nh ni kc ek translated"><a class="ae kg" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nk nl nm nn no iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nj"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>