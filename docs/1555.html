<html>
<head>
<title>C++ Guide for EOS Development — Iterators &amp; Lambda Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">EOS开发的C++指南—迭代器和Lambda表达式</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/c-guide-for-eos-development-iterators-lambda-expressions-c677d0a99278?source=collection_archive---------5-----------------------#2018-09-25">https://medium.com/coinmonks/c-guide-for-eos-development-iterators-lambda-expressions-c677d0a99278?source=collection_archive---------5-----------------------#2018-09-25</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/7d4420f404ca3d1bb1e93313989c87a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_JVasbPOrKnDnr3c.png"/></div></div></figure><div class=""/><blockquote class="jb jc jd"><p id="faf6" class="je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这篇文章是我的<a class="ae kd" href="https://cmichel.io/categories/learneos" rel="noopener ugc nofollow" target="_blank">EOS开发人员C++指南</a>的一部分</p></blockquote><ol class=""><li id="a1c8" class="ke kf ie jh b ji jj jm jn kg kh ki kj kk kl kc km kn ko kp dt translated"><a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-basics/" rel="noopener ugc nofollow" target="_blank">基础知识</a></li><li id="6783" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated"><a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-call-by-value-reference/" rel="noopener ugc nofollow" target="_blank">通过值/引用调用&amp;指针</a></li><li id="f0a4" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated"><a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-classes-and-structs/" rel="noopener ugc nofollow" target="_blank">类和结构</a></li><li id="2429" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated"><a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-templates" rel="noopener ugc nofollow" target="_blank">模板</a></li><li id="7393" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated"><a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-iterators-lambda-expressions" rel="noopener ugc nofollow" target="_blank">迭代器&amp;λ表达式</a></li><li id="7d68" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated">多指数</li><li id="db67" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated">头文件</li></ol><h2 id="c346" class="kv kw ie bd kx ky kz la lb lc ld le lf kg lg lh li ki lj lk ll kk lm ln lo lp dt translated">迭代器</h2><p id="8807" class="pw-post-body-paragraph je jf ie jh b ji lq jk jl jm lr jo jp kg ls js jt ki lt jw jx kk lu ka kb kc hm dt translated">让我们来谈谈迭代器，这是一个非常有用的工具，在EOS代码库中被大量使用。如果您来自JavaScript背景，您可能已经熟悉迭代器，就像它们用在<code class="eh lv lw lx ly b">for of</code>循环中一样。迭代器的关键概念是提供一种更好的方式来遍历一组条目。额外的好处是，您可以为任何自定义类实现<em class="jg">迭代器接口</em>，使迭代器成为遍历数据的通用方式。</p><pre class="lz ma mb mc fq md ly me mf aw mg dt"><span id="6db0" class="kv kw ie ly b fv mh mi l mj mk">// @url: https://repl.it/@MrToph/CPPBasics-Iterators<br/>#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/><br/>using namespace std;<br/><br/>int main()<br/>{<br/>  vector&lt;int&gt; v{2, 3, 5, 8};<br/>  // old way to iterate<br/>  for (int i = 0; i &lt; v.size(); i++)<br/>  {<br/>    cout &lt;&lt; v[i] &lt;&lt; "\n";<br/>  }<br/><br/>  // using Iterators<br/>  // begin() returns an iterator that points to the beginning of the vector<br/>  // end() points to the end, can be compared using != operator<br/>  // iterators are incremented by using the + operator thanks to operator-overloading<br/>  for (vector&lt;int&gt;::iterator i = v.begin(); i != v.end(); i++)<br/>  {<br/>    // iterators are dereferenced by * like pointers<br/>    // returns the element the iterator is currently pointing to<br/>    cout &lt;&lt; *i &lt;&lt; "\n";<br/>  }<br/><br/>  // auto keyword allows you to not write the type yourself<br/>  // instead C++ infers it from the return type of v.begin<br/>  for (auto i = v.begin(); i != v.end(); i++)<br/>  {<br/>    cout &lt;&lt; *i &lt;&lt; "\n";<br/>  }<br/><br/>  // can use arithmetic to "jump" to certain elements<br/>  int thirdElement = *(v.begin() + 2);<br/>  cout &lt;&lt; "Third: " &lt;&lt; thirdElement &lt;&lt; "\n";<br/>  // end is the iterator that points to the "past-the-end" element<br/>  // The past-the-end element is the theoretical element that would follow the last element in the vector.<br/>  // It does not point to any element, and thus shall not be dereferenced.<br/>  int lastElement = *(v.end() - 1);<br/>  cout &lt;&lt; "Last: " &lt;&lt; lastElement &lt;&lt; "\n";<br/><br/>  // do not go out of bounds by iterating past the end() iterator<br/>  // the behavior is undefined<br/>  // BAD: v.end() + 1, v.begin() + 10<br/>}</span></pre><p id="3013" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">在现代C++中，迭代器是迭代元素集合(<code class="eh lv lw lx ly b">vector</code> s，<code class="eh lv lw lx ly b">list</code> s，<code class="eh lv lw lx ly b">map</code> s)的首选方式。此外，<code class="eh lv lw lx ly b">auto</code>关键字让你不用输入冗长的类型，但是可能会导致代码表达能力下降。</p><h2 id="b824" class="kv kw ie bd kx ky kz la lb lc ld le lf kg lg lh li ki lj lk ll kk lm ln lo lp dt translated">λ表达式</h2><p id="c0ee" class="pw-post-body-paragraph je jf ie jh b ji lq jk jl jm lr jo jp kg ls js jt ki lt jw jx kk lu ka kb kc hm dt translated">有了迭代器，我们可以开始研究现代C++的函数式编程概念。标准库中的许多函数将由两个迭代器(开始和结束)和一个<strong class="jh if">匿名函数</strong> (lambda函数)表示的一系列元素作为参数。然后，这个匿名函数被应用于该范围内的每个元素。它们被称为匿名函数，因为它们没有绑定到变量，而是作为内联参数传递给高阶函数的短逻辑块。通常，它们对于它们被传递到的函数是唯一的，因此不需要有一个名字(匿名)的全部开销。</p><p id="5a8b" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">有了它，我们可以实现排序、映射、过滤等类似的结构。用JavaScript这样的语言很容易做到:</p><pre class="lz ma mb mc fq md ly me mf aw mg dt"><span id="2fa0" class="kv kw ie ly b fv mh mi l mj mk">[1,2,3,4].map(x =&gt; x*x).filter(x =&gt; x % 2 === 1).sort((a,b) =&gt; b - a)</span></pre><p id="f261" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">C++中的代码没有这么简洁，但结构是一样的。许多来自<code class="eh lv lw lx ly b">std</code>库的函数式编程助手在<em class="jg">半开</em>区间上操作，这意味着包括下限，排除上限。</p><pre class="lz ma mb mc fq md ly me mf aw mg dt"><span id="29f7" class="kv kw ie ly b fv mh mi l mj mk">// @url: https://repl.it/@MrToph/CPPBasics-Lambdas<br/>#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>// for sort, map, etc.<br/>#include &lt;algorithm&gt;<br/><br/>using namespace std;<br/><br/>int main()<br/>{<br/>  vector&lt;int&gt; v{2, 1, 4, 3, 6, 5};<br/>  // first two arguments are the range<br/>  // v.begin() is included up until v.end() (excluded)<br/>  // sorts ascending<br/>  sort(v.begin(), v.end());<br/><br/>  // in C++, functions like sort mutate the container (in contrast to immutability and returning new arrays in other languages)<br/>  for (auto i = v.begin(); i != v.end(); i++)<br/>  {<br/>    cout &lt;&lt; *i &lt;&lt; "\n";<br/>  }<br/><br/>  // sort it again in descending order<br/>  // third argument is a lambda function which is used as the comparison for the sort<br/>  sort(v.begin(), v.end(), [](int a, int b) { return a &gt; b; });<br/><br/>  // functional for_each, can also use auto for type<br/>  for_each(v.begin(), v.end(), [](int a) { cout &lt;&lt; a &lt;&lt; "\n"; });<br/><br/>  vector&lt;string&gt; names{"Alice", "Bob", "Eve"};<br/>  vector&lt;string&gt; greetings(names.size());<br/><br/>  // transform is like a map in JavaScript<br/>  // it applies a function to each element of a container<br/>  // and writes the result to (possibly the same) container<br/>  // first two arguments are range to iterate over<br/>  // third argument is the beginning of where to write to<br/>  transform(names.begin(), names.end(), greetings.begin(), [](const string &amp;name) {<br/>    return "Hello " + name + "\n";<br/>  });<br/>  // filter greetings by length of greeting<br/>  auto new_end = std::remove_if(greetings.begin(), greetings.end(), [](const string &amp;g) {<br/>    return g.size() &gt; 10;<br/>  });<br/>  // iterate up to the new filtered length<br/>  for_each(greetings.begin(), new_end, [](const string &amp;g) { cout &lt;&lt; g; });<br/>  // alternatively, really erase the filtered out elements from vector<br/>  // so greetings.end() is the same as new_end<br/>  // greetings.erase(new_end, greetings.end());<br/><br/>  // let's find Bob<br/>  string search_name = "Bob";<br/>  // we can use the search_name variable defined outside of the lambda scope<br/>  // notice the [&amp;] instead of [] which means that we want to do "variable capturing"<br/>  // i.e. make all local variables available to use in the lambda function<br/>  auto bob = find_if(names.begin(), names.end(), [&amp;](const string &amp;name) {<br/>    return name == search_name;<br/>  });<br/>  // find_if returns an iterator referncing the found object or the past-the-end iterator if nothing was found<br/>  if (bob != names.end())<br/>    cout &lt;&lt; "Found name " &lt;&lt; *bob &lt;&lt; "\n";<br/>}</span></pre><p id="b6af" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">在C++中，匿名函数的语法是需要习惯的。它们由括号指定，后跟一个参数列表，就像so <code class="eh lv lw lx ly b">[](int a, int b) -&gt; bool {return a &gt; b; }</code>。注意，<code class="eh lv lw lx ly b">-&gt; bool</code>指定了一个布尔返回值。通常，您可以避免表达返回类型，因为它可以从函数体中的返回类型推断出来。</p><p id="0dc9" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">如果你想使用定义在lambda函数范围之外的变量，你需要做<em class="jg">变量捕获</em>。也有可能通过<em class="jg">引用</em>或<em class="jg">值</em>将参数传递给你的函数。</p><ul class=""><li id="767e" class="ke kf ie jh b ji jj jm jn kg kh ki kj kk kl kc ml kn ko kp dt translated">要通过引用传递，您需要以<code class="eh lv lw lx ly b">&amp;</code>字符开始您的lambda(就像在函数中使用引用时一样):<code class="eh lv lw lx ly b">[&amp;]</code></li><li id="0cd8" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc ml kn ko kp dt translated">为了传递值，可以使用<code class="eh lv lw lx ly b">=</code>字符:<code class="eh lv lw lx ly b">[=]</code></li></ul><p id="16c3" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">也有可能<em class="jg">混搭</em>通过价值和引用捕获。<br/>例如，<code class="eh lv lw lx ly b">[=, &amp;foo]</code>将为除<code class="eh lv lw lx ly b">foo</code>之外的所有变量创建副本，而<code class="eh lv lw lx ly b">foo</code>是通过引用捕获的。</p><p id="9f74" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">这有助于理解使用lambdas时幕后发生的事情:</p><blockquote class="jb jc jd"><p id="002b" class="je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">原来lambdas的实现方式是通过创建一个小类；这个类重载了操作符()，因此它的行为就像一个函数。lambda函数是该类的一个实例；构造类时，周围环境中的任何变量都被传递到lambda函数类的构造函数中，并保存为成员变量。事实上，这有点像已经存在的函子的概念。C++11的好处是这样做变得非常简单——所以你可以一直使用它，而不是只在极少数情况下编写一个全新的类才有意义。<a class="ae kd" href="https://www.cprogramming.com/c++11/c++11-lambda-closures.html" rel="noopener ugc nofollow" target="_blank">编程Lambda函数</a></p></blockquote><p id="2725" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">Lambda函数在EOS智能合约中被大量使用，因为它们提供了一种用少量代码修改数据的非常方便的方法。标准库中有更多函数的工作方式与我们已经看到的<code class="eh lv lw lx ly b">sort, transform, remove_if</code>和<code class="eh lv lw lx ly b">find_if</code>类似。它们都是通过<code class="eh lv lw lx ly b">&lt;algorithm&gt;</code>头导出的。</p><figure class="lz ma mb mc fq hv fe ff paragraph-image"><a href="https://learneos.one#modal"><div class="fe ff mm"><img src="../Images/2d451a641e23abf5003c1c69fae9c5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rrhS8AjoGrxOHqMH.png"/></div></a></figure></div><div class="ab cl mn mo hb mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hm hn ho hp hq"><p id="0ced" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">最初发布于<a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-iterators-lambda-expressions/" rel="noopener ugc nofollow" target="_blank"> cmichel.io </a></p><figure class="lz ma mb mc fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mu"><img src="../Images/6e3d144816a09a7592e313b285360781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lb8GUeq2Dqt5YEd9.gif"/></div></div></figure><blockquote class="mv"><p id="cfbe" class="mw mx ie bd my mz na nb nc nd ne kc ek translated"><a class="ae kd" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="ng nh ni nj nk hv fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nf"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>