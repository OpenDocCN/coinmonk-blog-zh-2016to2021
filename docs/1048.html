<html>
<head>
<title>Bitcoin: Review of the original paper by Satoshi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比特币:对Satoshi原始论文的评论</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/bitcoin-a-fully-decentralized-electronic-cash-network-using-trustless-nodes-23ee9874f969?source=collection_archive---------6-----------------------#2018-07-15">https://medium.com/coinmonks/bitcoin-a-fully-decentralized-electronic-cash-network-using-trustless-nodes-23ee9874f969?source=collection_archive---------6-----------------------#2018-07-15</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="d7f8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我总是发现阅读和重述基础论文中的主要观点很有价值。本帖涵盖<a class="ae jo" href="https://bitcoin.org/bitcoin.pdf" rel="noopener ugc nofollow" target="_blank">原比特币论文</a>。(想要更深入了解的读者:我强烈推荐阅读<a class="ae jo" href="http://www.merkle.com/papers/Protocols.pdf" rel="noopener ugc nofollow" target="_blank">默克尔关于公钥加密系统协议的原始论文</a>，以及<a class="ae jo" href="http://www.hashcash.org/papers/hashcash.pdf" rel="noopener ugc nofollow" target="_blank">亚当·布莱克的hashcash </a>以获得工作细节的证明。)</p><h2 id="0937" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">介绍</h2><p id="2c56" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">在最近的过去，货币传统上是由一个中央机构发行的。这有助于确保钱是有效的，也是钱没有双重花费。当有人进行一些现金交易时，钱会转手，并且不能被分发现金的人重复花费。在网络世界中，这一负担由一个中央机构分担，比如银行，它确保用户只能消费一次给定的金额。如果我有10美元可以花，那么我只能花1美元。如果您在银行有一个中央数据库，这是一个很容易解决的问题。</p><p id="725a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但接下来就是一个中央集权的系统，掌握着太多的现金/权力，可以对每一笔交易收取交易费。中介还可以对国外交易收费，可以对交易规模进行限制等。由于某些交易可能需要撤销，因此需要在系统中引入更多的信任——这意味着客户需要向央行披露更多的个人信息。</p><p id="cdcd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这就是比特币网络的主要动机——能否存在一个由不可信节点组成的网络，可以帮助进行点对点电子现金交易，而不必依赖于中央权威机构。要解决的主要问题显然是如何避免同一笔钱/硬币的双重花费。在一个网络世界里，一个恶意代理人M可以花同样的钱给A和B，只要A和B彼此都不知道对方和与M的交易。</p><h2 id="1214" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">硬币</h2><p id="6f46" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">让我们来定义一下这种电子硬币可能是什么样子。假设所有所有者都有公钥和私钥。每枚硬币基本上都是一长串加密签名的散列——姑且称之为事务。每次硬币转移所有权时，前一个所有者(所有者1)获取列表中的最后一笔交易，下一个所有者(所有者2)的公钥并用其私钥对其签名，并将其附加到该硬币的交易列表中。</p><p id="bb9e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Transaction(new)=<strong class="is hu"><em class="kp">Hash</em></strong>(所有者1-私钥，最后一次交易-硬币，所有者2-公钥)</p><p id="7a0c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，系统中的其他节点可以通过使用所有者1的公钥验证数字签名，来验证硬币是否被转移给了新的所有者。</p><h2 id="db9a" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">重复花费的问题</h2><p id="a468" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">Owner2怎么会知道Owner1在这次交易之前没有和OwnerX进行同样的交易？在中央集权的系统中，这很容易。所有交易都被记录下来，因此系统可以验证这是否是一次重复消费的尝试。</p><p id="690c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在一个分散的系统中，了解这一点的唯一方法是了解在这枚硬币的交易之前发生的所有交易。因此，比特币网络中的节点需要宣布每一笔交易(即所有权转移)，并就这些交易发生的顺序达成一致。所以拥有者2可以确信它是第一个从拥有者1那里收到这枚硬币的人。</p><h1 id="5d27" class="kq jq ht bd jr kr ks kt jv ku kv kw jz kx ky kz kc la lb lc kf ld le lf ki lg dt translated">解决方案的构建模块</h1><p id="3f67" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">避免重复花费的有效方法是拥有一个时间戳服务器。时间戳服务器可以说硬币1在某个时间存在，并在另一个时间被转移给另一个所有者。如果每个接受硬币的人都可以获得该数据，那么他们可以返回并确认硬币的当前所有者之前没有在该硬币上花费过。首先，我们可以看看集中式时间戳服务器，然后再看看分散式时间戳服务器。</p><h2 id="37da" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">集中式时间戳服务器</h2><p id="2c88" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">让我们首先假设有一个中央服务器可以对某个数据块进行数字标记。这里时间戳的意思是:一个数据块将被分配一个数字时间戳，该时间戳在将来是不可修改和可验证的。一种方法是使用时间戳服务器的密钥创建(数据、时间戳)的散列。随后，任何人都可以验证数据和时间戳。显然，这依赖于集中式时间戳服务器及其完整性。</p><p id="61a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在集中式时间戳服务器上实施某种完整性的一种方法是让它经常在报纸或一些团体中发布这些散列。这将确保时间戳服务器不能与客户端勾结，在报纸用户没有注意到的情况下修改现有文档的数字时间戳。(显然，这在数字环境中不容易实现)</p><p id="bc74" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">另一种使修改散列更加困难的方法是创建一个数字时间戳链。因此，即使有人决定更改某个特定的时间戳，他们也需要从那里开始更改整个链。这是一个简单的图表:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/ac5f52c95aba5ad14f375cb76a60d8dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OOpALvt0IW0sWo2LT2YXxA.jpeg"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">A simple digital timestamps of transactions linked to reenforce previous timestamps</figcaption></figure><h2 id="894b" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">分散时间戳服务器</h2><p id="207f" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">最后两种方法使我们更接近一种分散的解决方案。</p><ol class=""><li id="9f59" class="lx ly ht is b it iu ix iy jb lz jf ma jj mb jn mc md me mf dt translated">在一个网络节点中，向整个网络宣布事务</li><li id="7f7a" class="lx ly ht is b it mg ix mh jb mi jf mj jj mk jn mc md me mf dt translated">每个新的交易都建立在前一个交易的基础上，使得有针对性的修改更加困难</li><li id="5d48" class="lx ly ht is b it mg ix mh jb mi jf mj jj mk jn mc md me mf dt translated">我们还可以通过引入工作证明来增加生成数字时间戳的难度，这种工作证明需要很长时间来生成，只需很少的时间来验证，从而使修改数据块变得更加困难。</li><li id="0d7c" class="lx ly ht is b it mg ix mh jb mi jf mj jj mk jn mc md me mf dt translated">功函的一个简单证明是产生一个散列值，其最高有效“w”位设置为零。随着“w”的增加，工作证明的复杂性也会增加。</li><li id="bba0" class="lx ly ht is b it mg ix mh jb mi jf mj jj mk jn mc md me mf dt translated">由于在没有强力的情况下很难反转给定的单向散列，所以生成这种工作证明的唯一方法是获取一个随机数并继续递增它，直到它的散列的最高有效“w”位被设置为零，例如，对于散列值，它将类似于:</li></ol><blockquote class="ml mm mn"><p id="dfa4" class="iq ir kp is b it iu iv iw ix iy iz ja mo jc jd je mp jg jh ji mq jk jl jm jn hm dt translated">递增随机数，</p><p id="ec8b" class="iq ir kp is b it iu iv iw ix iy iz ja mo jc jd je mp jg jh ji mq jk jl jm jn hm dt translated">散列它，</p><p id="81de" class="iq ir kp is b it iu iv iw ix iy iz ja mo jc jd je mp jg jh ji mq jk jl jm jn hm dt translated">检查最高有效w位是否为0。</p><p id="2ea9" class="iq ir kp is b it iu iv iw ix iy iz ja mo jc jd je mp jg jh ji mq jk jl jm jn hm dt translated">如果是，我们提供了有效的工作证明。否则回到第一步。</p></blockquote><p id="6e55" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">比特币区块链的形象大概是这样的:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/00f28879e1e56c89b519cad2a01fdfcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wS2YvTpwmdhGojvKXYKfYQ.jpeg"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Bitcoin blockchain with Merkle tree in each block</figcaption></figure><h2 id="58a6" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">把所有的放在一起</h2><p id="f4ed" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">所以我们目前所知道的是:</p><ol class=""><li id="9b46" class="lx ly ht is b it iu ix iy jb lz jf ma jj mb jn mc md me mf dt translated">与硬币转移有关的一系列交易。</li><li id="361f" class="lx ly ht is b it mg ix mh jb mi jf mj jj mk jn mc md me mf dt translated">然后，我们有一种机制将这些事务组合到一个块中——使用工作证明机制</li><li id="2954" class="lx ly ht is b it mg ix mh jb mi jf mj jj mk jn mc md me mf dt translated">然后，这些块被链接在一起，形成一个长长的列表——本质上是制作一个分类账。</li></ol><p id="ba82" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在让我们看看网络是如何运行的</p><ol class=""><li id="d06d" class="lx ly ht is b it iu ix iy jb lz jf ma jj mb jn mc md me mf dt translated">事务被公开宣布并被所有节点接收</li><li id="ae24" class="lx ly ht is b it mg ix mh jb mi jf mj jj mk jn mc md me mf dt translated">每个节点从这些事务中创建一个块，并且每个节点找到一个PoW。这是启动数字时间戳的过程。</li><li id="0584" class="lx ly ht is b it mg ix mh jb mi jf mj jj mk jn mc md me mf dt translated">然后一个随机节点向网络提出它的块和功率</li><li id="aef3" class="lx ly ht is b it mg ix mh jb mi jf mj jj mk jn mc md me mf dt translated">网络中的节点验证PoW，然后仅当块中的所有事务都是有效的并且还没有耗尽时才接受块。这就是在块/事务中执行订单的方式。</li><li id="fa83" class="lx ly ht is b it mg ix mh jb mi jf mj jj mk jn mc md me mf dt translated">然后，节点通过使用这个块的散列来创建下一个块。这实质上是宣布接受先前发出的块。</li></ol><h2 id="f758" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">解释了双重支出情况</h2><p id="cd42" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">另一个仍然需要解决的问题是，我们如何知道我们不是在使用一个已经用完的硬币。下图解释了这种情况。a创建了两个交易，然后将同一个硬币C转移给B和d。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/302832e596cbc8f29ad98c47cd12041d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Rgk6-PgYI_UmQMX8JlCLg.jpeg"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Double Spend of Coin C owned by A. First to B and then to C. This coins is getting used in blocks Bx and By again.</figcaption></figure><p id="b12a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">按照一般原则，节点将信任较长的链-假设大多数节点由诚实的工作人员控制，诚实的链将增长最长，攻击者将无法控制区块链的大部分。</p><p id="0c1c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这种情况下，没有明确的赢家。两条区块链一样长。因此，防止这种情况的一种方法是，所有者B和D等待链增长。在添加块后，两者都可以等待超过x次确认。假设x足够大，那么两条链保持相同的长度就变得非常困难。一个链将变得更长，第二个链(及其孤立块)可能会失效。这里的一个关键点是，从网络的角度来看，这里没有真正的对错交易。这实际上是一个在网络中保持一致的交易顺序的问题。</p><h2 id="2439" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">激励运行网络中的节点</h2><p id="9836" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">保持网络运行有两个主要动机。</p><ol class=""><li id="f109" class="lx ly ht is b it iu ix iy jb lz jf ma jj mb jn mc md me mf dt translated">每个挖掘者(节点所有者)在创建和建议一个块时，都会包含一个新的事务，该块会包含在最终的长链中。这是该区块的第一笔交易，本质上是启动硬币的创建。</li><li id="6ac6" class="lx ly ht is b it mg ix mh jb mi jf mj jj mk jn mc md me mf dt translated">一旦所有的硬币都被铸造出来，交易费将会发挥重要作用。运行网络的节点可以向发送者建议交易费用是多少。硬币的发送者必须同意向运行该节点的实体支付交易费用。因此，平衡ob块反映为:输入值=输出值+交易费用</li></ol><h2 id="4012" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">Merkle树用于高效的磁盘存储和成员资格</h2><p id="c6f7" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">由于比特币的分散性质，每个节点都需要保留所有交易和区块的分类账。如果所有事务都一直存在，那么日志将会非常大。因此，网络使用Merkle树结构来安排给定块中的事务。让我们看看Merkle树是什么样子，然后我们可以看到它是如何被利用的。这是来自原始论文的Merkle树:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/628ac6369ce2b8f980035f9a8891d838.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*J3ebapFfm2FR2uLAaWCiSQ.png"/></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Illustration of a Merkle Tree</figcaption></figure><p id="1aac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">可以看出，这里使用叶节点y1、y2等表示了8个事务1至8。所有中间节点都是其子节点的散列。如果有人决定检查y5的成员资格/有效性，那么他们需要的只是来自H(1，8，Y)-H(5，8，Y)-H(5，5，Y)的所有散列。他们不需要整个树，即从1到8的所有事务。</p><p id="47fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这棵树的另一个优点是，对任何节点的修改都需要传播到根节点，并重做所有的散列。所以修改H(6，6，Y)不是小事。然后，攻击者需要修改H(5，6，Y)，然后修改H(5，8，Y)，最后修改根节点。</p><p id="a95f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用Merkle树的这些属性，一旦事务在它之后的多个块中被重新执行，我们就可以删除树的一些分支。最终，大量的分支可以被移除，所有剩下的就是块中的根签名。这大大减少了磁盘的使用。</p><h2 id="7c46" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">如何确认交易是否有效</h2><p id="349b" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">比特币分类账被表示为状态机，而不是账户数据库。所以每一个新的事务都把前一个事务的输出作为输入。假设A正在使用交易y8中给它的硬币。假设A想在当前交易中把这个给B是y15。为了验证y8的输出在y15之前是否没有被花掉，我们需要回过头来遍历y15到y8并确认有效性。Merkle trees对会员来说也很方便，我们不必检查中间的每一笔交易。</p><h2 id="89bf" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">不诚实链存活的概率</h2><p id="78aa" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">在网络中，攻击者最有可能尝试做的是加倍消费，并使用第二次消费来收回之前消费的钱。(偷别人的钱意味着得到他们的私人钥匙。没有工作证明，凭空创造金钱是不可能的。)在这种情况下，攻击者只能通过控制网络的大部分(记住，网络中的随机节点可以添加下一个块)，使不诚实的链成为最长的链。如果多数由诚实节点控制，那么如果不诚实链比诚实链落后“z”个块，这显然转化为指数(z)概率。</p><h2 id="eb1c" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">结论</h2><p id="8ce7" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">天才真的在于简单——这篇论文只引用了其他8篇论文，考虑到其产生的影响，这令人震惊。我发现如果没有传统的所有者账户价值的观点，很难想象比特币分类账。但是在其他地方解释的状态转换观点使得阅读这篇论文更加容易。另一篇论文，分布式共识形成了一个更大的技术的基础(但在敌对的场景中)。这篇论文也参考了兰波特关于分布式共识的论文(这里也提到了T2的论文)。这个想法证明工作土地上的概率解决拜占庭一般的问题也是非常整洁！</p></div></div>    
</body>
</html>