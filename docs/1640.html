<html>
<head>
<title>Hyperledger Fabric Private Data Collections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hyperledger结构私有数据集合</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/hyperledger-fabric-not-so-private-data-collections-cb4dbff62c58?source=collection_archive---------0-----------------------#2018-10-12">https://medium.com/coinmonks/hyperledger-fabric-not-so-private-data-collections-cb4dbff62c58?source=collection_archive---------0-----------------------#2018-10-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/000572856679c1a32bf8de2639842207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCw1QTVIkVhYgchGznVZ5g.png"/></div></div></figure><div class=""/><p id="5cc6" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Hyperledger Fabric向前迈进了一大步，在Hyperledger Fabric的1.2版本中增加了<a class="ae jz" href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/private-data/private-data.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jd if">私有数据集合</strong> </a>。这个概念很有意义，因为当一些组织希望在一个更大的通道内交换私有数据时，创建一个新的通道就成了管理上的噩梦。</p><h1 id="2168" class="ka kb ie bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated"><strong class="ak">私人数据收集</strong></h1><p id="6293" class="pw-post-body-paragraph jb jc ie jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">私有数据收集使部分数据成为私有数据成为可能，从而允许组织的子集在同一渠道上查看数据的私有部分。</p><h1 id="5442" class="ka kb ie bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">2018年10月26日更新</h1><p id="1e41" class="pw-post-body-paragraph jb jc ie jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">IBM<strong class="jd if">的David Enyeart(Hyperledger Fabric项目的维护者)联系我，澄清了我在文章第一版中发现的问题:</strong></p><blockquote class="ld le lf"><p id="57c1" class="jb jc lg jd b je jf jg jh ji jj jk jl lh jn jo jp li jr js jt lj jv jw jx jy hm dt translated">不幸的是，最初的社区样本并没有展示使用瞬态字段来保持数据的私密性</p></blockquote><p id="84c0" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Dave说最新的<a class="ae jz" href="https://hyperledger-fabric.readthedocs.io/en/release-1.3/private-data-arch.html#how-to-pass-private-data-in-a-chaincode-proposal" rel="noopener ugc nofollow" target="_blank"> 1.3文档</a>在指定瞬态字段方面做得更好，如下所示:</p><blockquote class="ld le lf"><p id="7f93" class="jb jc lg jd b je jf jg jh ji jj jk jl lh jn jo jp li jr js jt lj jv jw jx jy hm dt translated">chaincode提议中的一个特殊字段称为<code class="eh lk ll lm ln b"><em class="ie">transient</em></code>字段，可以用来传递来自客户端的私有数据(或者chaincode将用来生成私有数据的数据)，以便在对等体上调用chaincode。</p></blockquote><p id="d7d5" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这篇文章是<strong class="jd if"> <em class="lg">现在</em> </strong>关于当你<strong class="jd if"> <em class="lg">不</em> </strong>使用<code class="eh lk ll lm ln b"><em class="lg">transient</em></code>字段时会发生什么。谢谢戴夫！</p><h1 id="c427" class="ka kb ie bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated"><strong class="ak">我是如何发现这个问题的</strong></h1><p id="0245" class="pw-post-body-paragraph jb jc ie jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">我一直在建立一个数据库适配器来存储任何标准数据库，如MySQL，MongoDB，Oracle或Postgres的Hyperledger私人数据。</p><p id="c1d2" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">确保我的数据库适配器安全的一部分是首先检查Hyperledger是如何存储和清除私有数据的。</p><h1 id="1e31" class="ka kb ie bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated"><strong class="ak"> BlockToLive </strong></h1><p id="9eab" class="pw-post-body-paragraph jb jc ie jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">Hyperledger在collections_config.json中有一个<a class="ae jz" href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/private-data-arch.html?highlight=blockToLive" rel="noopener ugc nofollow" target="_blank"><strong class="jd if">block to live</strong></a><strong class="jd if"/>属性，该属性指定在清除数据之前有多少个块。</p><figure class="lp lq lr ls fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lo"><img src="../Images/9125e6d982a3887ab2776800dd215823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qn2J5Af_WH2AGyiW57SWqg.png"/></div></div></figure><h1 id="f24f" class="ka kb ie bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated"><strong class="ak">吹扫</strong></h1><p id="cdd6" class="pw-post-body-paragraph jb jc ie jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">在添加了X个块(在本例中是3个块)之后，数据不再可用于查询，从这个意义上说，清除是有效的。</p><p id="4d25" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是一个在<strong class="jd if">预清除</strong>时完成的私有数据查询的示例。</p><figure class="lp lq lr ls fq hv fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/bc098d211b6c1ce873d1455678392741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*F_7h1t0ZYW3BsgJB_hwcPQ.png"/></div></figure><p id="a08b" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是在清除后完成的<strong class="jd if">相同的私有数据查询。</strong></p><figure class="lp lq lr ls fq hv fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/131ae352e86e3276dc9d8c59a17ca6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*XHZ3itpuDXXBHIAzGJKkjw.png"/></div></figure><h1 id="0122" class="ka kb ie bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated"><strong class="ak">问题</strong></h1><p id="bdd6" class="pw-post-body-paragraph jb jc ie jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">问题是私有数据被清除了，<strong class="jd if">但是</strong>如果你不调用带有transient字段的调用，当我们初始化私有数据(在本例中是一个弹球，价格为0.99美元)时，私有数据实际上被写入了<strong class="jd if">所有的</strong>块文件中，甚至是在组织对等体上，这些对等体本应<strong class="jd if">而不是</strong>对私有数据有任何<strong class="jd if">访问权。指定了<strong class="jd if"> blockToLive </strong>属性的collections_config.json还指定了指示哪些组织可以访问私有数据的策略。</strong></p><figure class="lp lq lr ls fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lo"><img src="../Images/e0729410a60aa2e0ca0ee5c25c0c4d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HdoAN0OclQtSL8NmumH_MQ.png"/></div></div></figure><p id="328e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">私有数据是由<a class="ae jz" href="https://github.com/golang" rel="noopener ugc nofollow" target="_blank"> Golang </a>文件marbles_chaincode_private.go中的initMarble函数创建的</p><p id="d837" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下面是marblePrivateDetails结构，来自marbles_chaincode_private.go，其中很明显<strong class="jd if"> <em class="lg"> Price </em> </strong>整数是<strong class="jd if"> private。</strong></p><figure class="lp lq lr ls fq hv fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/5354c156bdfe5850c30acc17a52b8c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*MFiP4EqZajYwVYoAzimsOQ.png"/></div></figure><p id="6146" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里是Org2上一个对等体的<strong class="jd if">清除后</strong>块文件，在这里您可以看到Org2不应该<strong class="jd if">获得的私有数据，即清除前和清除后。</strong></p><figure class="lp lq lr ls fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lv"><img src="../Images/91a4009e23415f07e85df291435b6cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6CKZO24elBPlfESvznopQ.png"/></div></div></figure><h1 id="0c90" class="ka kb ie bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated"><strong class="ak">结论</strong></h1><p id="db27" class="pw-post-body-paragraph jb jc ie jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">我相信Hyperledger将成为企业的主流区块链解决方案，这个问题不会让我对Hyperledger失去兴趣，但这项技术是新的，公司需要对开发和迭代测试保持警惕，以确保使用瞬态字段保持私人数据的私密性。</p><p id="4bcc" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你觉得这篇文章怎么样？如果你喜欢它或者学到了什么，请留下你的掌声！DarkBlock.io是一家区块链企业发展公司，我们一直在接纳新客户。请通过<a class="ae jz" href="mailto:sheffield@darkblock.io" rel="noopener ugc nofollow" target="_blank"> sheffield@darkblock.io </a>联系我或访问我们的网站<a class="ae jz" href="https://darkblock.io/" rel="noopener ugc nofollow" target="_blank"> DarkBlock.io </a>！</p></div></div>    
</body>
</html>