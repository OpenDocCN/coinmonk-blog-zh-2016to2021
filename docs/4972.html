<html>
<head>
<title>Unlocking the Secrets of an Ethereum Transaction (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解开以太坊交易的秘密(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/unlocking-the-secrets-of-an-ethereum-transaction-3a33991f696c?source=collection_archive---------0-----------------------#2021-07-13">https://medium.com/coinmonks/unlocking-the-secrets-of-an-ethereum-transaction-3a33991f696c?source=collection_archive---------0-----------------------#2021-07-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="e612" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">用Python解码事务日志</h2></div><p id="f41b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在本系列的第1部分<a class="ae ke" rel="noopener" href="/coinmonks/discovering-the-secrets-of-an-ethereum-transaction-64febb00935c">中，我们使用Python来解码事务<em class="kf">输入数据</em>。输入数据对于理解交易的广泛范围具有关键的洞察力。在本文中，我们主要关注事务日志。日志允许我们更深入地研究事务期间发生的单个运行时事件。我们将探讨什么是事务日志，为什么它们很重要，以及如何解码它们。</a></p><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff kg"><img src="../Images/e14eccd638bc90b478aa8c5873ed9754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WEYANbKZgcDZob7FmJGACw.png"/></div></div></figure><h2 id="3c57" class="ks kt ht bd ku kv kw kx ky kz la lb lc jr ld le lf jv lg lh li jz lj lk ll lm dt translated">什么是事务日志？</h2><p id="5d76" class="pw-post-body-paragraph ji jj ht jk b jl ln iu jn jo lo ix jq jr lp jt ju jv lq jx jy jz lr kb kc kd hm dt translated">以太坊交易日志可以比作传统app开发中的日志记录。传统应用程序的程序员使用日志来调试、检测特定事件，或者通知日志查看者发生了一些事情。以太坊虚拟机(EVM)上的日志服务于非常相似的目的，因为它们用于描述在智能合约的运行时执行中发生的事件。这些事件可以由dapps或任何连接到以太坊节点的想要监听这些事件的设备订阅。日志中的事件也可以编入索引，以便在区块链上搜索事件历史。</p><p id="f16b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">事务日志有两个主要组成部分— <em class="kf">主题</em>和<em class="kf">数据</em>。以这个<a class="ae ke" href="https://etherscan.io/tx/0xac80bab0940f061e184b0dda380d994e6fc14ab5d0c6f689035631c81bfe220b" rel="noopener ugc nofollow" target="_blank">事务日志</a>为例。此事件日志描述了两个地址之间的ETH传输，这是更广泛事务的一部分。</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Transaction log example</figcaption></figure><p id="2ff5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们细分<em class="kf">话题</em>。主题可以描述为<em class="kf">事件</em>的索引参数数组。<code class="eh ly lz ma mb b">topics[0]</code>总是指事件名称和输入参数类型的Keccak-256哈希的十六进制值。在我们的例子中，<code class="eh ly lz ma mb b">topics[0]</code>等于<code class="eh ly lz ma mb b">Transfer(address,address,unit256)</code>。<code class="eh ly lz ma mb b">topics[1:]</code>最多3个索引参数。在我们的例子中，<code class="eh ly lz ma mb b">topics[1]</code>和<code class="eh ly lz ma mb b">topics[2]</code>是用于执行事件的<code class="eh ly lz ma mb b">Transfer()</code>方法的地址。</p><p id="d4da" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="kf">数据</em>部分可以描述为事件所需的<em class="kf">附加数据。在我们的示例中，地址间传输的ETH量以十六进制格式包含在数据段中。智能合约的程序员可能以这种方式编程，因为写入日志的主题数组需要gas，而写入数据不需要。也可以查询主题，但不能查询数据。没有人会去搜索一个有特定数量的ETH转移的事件，所以把这个数量放在数据部分是有意义的，这样可以节省油费。</em></p><p id="3a56" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在我们对事务日志的结构有了更多的了解，让我们深入代码。</p><h2 id="81f5" class="ks kt ht bd ku kv kw kx ky kz la lb lc jr ld le lf jv lg lh li jz lj lk ll lm dt translated">解码交易</h2><p id="73c7" class="pw-post-body-paragraph ji jj ht jk b jl ln iu jn jo lo ix jq jr lp jt ju jv lq jx jy jz lr kb kc kd hm dt translated">我们将使用Web3库与以太坊节点进行交互。有关安装和入门要求，请参见<a class="ae ke" href="https://web3py.readthedocs.io/en/stable/quickstart.html" rel="noopener ugc nofollow" target="_blank"> Web3文档</a>。</p><p id="0ca9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们的第一步是拿到交易收据。我们可以通过向Web3的<code class="eh ly lz ma mb b">get_transaction_receipt()</code>方法传递一个事务散列来做到这一点。这将返回一个字典，其中包含有关事务的高级信息，包括日志。</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="3b71" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">该事务包含四个日志，但在本教程中，我们将重点关注第一个日志对象。我们分离出想要解码的日志以及事件发起地址的智能契约。</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="28af" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">接下来，我们需要获取启动事件的智能合约的ABI。我们可以用Etherscan的API做到这一点。你需要一个API密匙，可以从<a class="ae ke" href="https://etherscan.io/myapikey" rel="noopener ugc nofollow" target="_blank">开发者页面</a>免费获得。</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="e67a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">接下来，我们创建契约对象，它允许我们通过Python代码与智能契约进行交互。</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="6108" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这里我们分离出日志中的<code class="eh ly lz ma mb b">event signature</code>。它总是主题数组的第一项。我们将使用它来识别在此事件中调用了哪个智能合约函数。</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="75ef" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">接下来，我们可以使用契约的ABI来查找所有具有<code class="eh ly lz ma mb b">event</code>类型的元素。这有助于我们缩小在事件期间使用的函数的搜索范围，因为函数必须有事件类型。</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="9727" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">最后，我们可以遍历契约的事件，找出哪个事件与日志的事件签名相匹配。我们通过提取函数名和参数来组装事件对象的签名。我们使用<code class="eh ly lz ma mb b">join</code>函数和<code class="eh ly lz ma mb b">f-strings</code>来组装函数签名。然后，我们可以对集合的签名进行哈希运算，以将其与日志中的签名进行比较。当我们找到这两个签名之间的匹配时，我们知道我们找到了事件中使用的函数。最后，我们可以通过调用<code class="eh ly lz ma mb b">processReceipt</code>方法使用我们的契约对象来解码事务日志。</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="ls lt l"/></div></figure><h2 id="0109" class="ks kt ht bd ku kv kw kx ky kz la lb lc jr ld le lf jv lg lh li jz lj lk ll lm dt translated">结论</h2><p id="4cbe" class="pw-post-body-paragraph ji jj ht jk b jl ln iu jn jo lo ix jq jr lp jt ju jv lq jx jy jz lr kb kc kd hm dt translated">在我们的例子中，父事务是SushiSwap上的一个简单的令牌交换。解码事务日志使我们能够了解幕后发生了什么，以确保该事务成功完成。本教程只解码了1/4的事件，所以为了获得完整的图片，我们的应用程序需要解码所有四个事件。</p><p id="c360" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这项基本技能可应用于许多应用，包括区块链智能、区块链数据分析等。我的下一篇文章将是关于基质框架以及它是如何改变区块链的发展方式的。点击跟随按钮，这样你就不会错过它。</p><p id="9b6e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果你觉得这篇文章有帮助，如果你能留下评论并鼓掌，我们将不胜感激。谢谢大家！</p><h2 id="d8b6" class="ks kt ht bd ku kv kw kx ky kz la lb lc jr ld le lf jv lg lh li jz lj lk ll lm dt translated">另外，阅读</h2><div class="mc md fm fo me mf"><a href="https://blog.coincodecap.com/ewasm-ethereum-webassembly" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab ej"><div class="mh ab mi cl cj mj"><h2 class="bd hu fv z el mk eo ep ml er et hs dt translated">Ewasm -以太坊WebAssembly</h2><div class="mm l"><h3 class="bd b fv z el mk eo ep ml er et ek translated">在我们上一篇关于信标链和分片的文章中，我们探讨了以太坊将如何实现PoS以及交易如何…</h3></div><div class="mn l"><p class="bd b gc z el mk eo ep ml er et ek translated">blog.coincodecap.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt kq mf"/></div></div></a></div></div></div>    
</body>
</html>