<html>
<head>
<title>Building a FedCoin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建造一个联邦币</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/building-a-fedcoin-4577eccc9ff0?source=collection_archive---------6-----------------------#2018-11-19">https://medium.com/coinmonks/building-a-fedcoin-4577eccc9ff0?source=collection_archive---------6-----------------------#2018-11-19</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="220c" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated"><em class="ji">通过世界上首批区块链管理系统之一BlockCluster的创始人兼首席技术官Narayan Prusty的这篇文章，了解如何构建FedCoin。</em></h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/d91ed12b52b427f22e46294a67fe4da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vE2YOe9dhINsNpt5v1t7nw.jpeg"/></div></div></figure><p id="29fe" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">FedCoin是一种由中央银行发行的数字货币，与他们的法定货币一对一对冲。使用区块链将法定货币数字化有几个好处，比如方便跨境支付和节省对账工作。</p><p id="986d" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">本文将向您展示如何在两个不同的区块链网络上构建数字化的印度卢比和美元。然后，您将创建一些原子互换合约，以自动实现银行之间的货币交换。这个用例要求您使用IBFT共识创建两个不同的法定人数网络。</p><p id="9a90" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">在每一个网络中，都有一个权威，就是央行，<strong class="jx hu"> <em class="kr"> N </em> </strong>个同行，就是其他银行。所以，你可以假设在第一个网络中，<strong class="jx hu">美联储系统</strong> ( <strong class="jx hu"> FRS </strong>)是权威，而<strong class="jx hu">美银</strong> ( <strong class="jx hu"> BOA </strong>)和ICICI银行是对等。同样，在第二个网络中，印度储备银行是权威机构，印度银行和印度工业信贷银行是对等机构。</p><p id="81c1" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">您现在不必构建这个网络，因为在构建和测试智能合约时，您可以只使用一个具有四个以太坊帐户地址的节点。这将足以模拟整个场景。</p><h2 id="bb83" class="ks kt ht bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">智能合约将法定货币数字化</h2><p id="f5df" class="pw-post-body-paragraph jv jw ht jx b jy ln iu ka kb lo ix kd ke lp kg kh ki lq kk kl km lr ko kp kq hm dt translated">这是一个在区块链上创建数字化美元的基本智能合约。这种智能合约允许您发行和转移数字化货币:</p><pre class="jk jl jm jn fq ls lt lu lv aw lw dt"><span id="32f9" class="ks kt ht lt b fv lx ly l lz ma">pragma solidity ^0.4.19;</span><span id="051e" class="ks kt ht lt b fv mb ly l lz ma">contract USD {</span><span id="da9f" class="ks kt ht lt b fv mb ly l lz ma">mapping (address =&gt; uint) balances;<br/> mapping (address =&gt; mapping (address =&gt; uint)) allowed;<br/> address owner;</span><span id="9adf" class="ks kt ht lt b fv mb ly l lz ma">function USD() {<br/>  owner = msg.sender;<br/> }</span><span id="1424" class="ks kt ht lt b fv mb ly l lz ma">function issueUSD(address to, uint amount) {<br/> if(msg.sender == owner) {<br/>  balances[to] += amount;<br/>  }<br/> }</span><span id="8273" class="ks kt ht lt b fv mb ly l lz ma">function transferUSD(address to, uint amount) {<br/>  if(balances[msg.sender] &gt;= amount) {<br/>   balances[msg.sender] -= amount;<br/>   balances[to] += amount;<br/>  }<br/> }</span><span id="4140" class="ks kt ht lt b fv mb ly l lz ma">function getUSDBalance(address account) view returns (uint balance) {<br/>   return balances[account];<br/> }</span><span id="0d51" class="ks kt ht lt b fv mb ly l lz ma">function approve(address spender, uint amount) {<br/>   allowed[spender][msg.sender] = amount;<br/> }</span><span id="a4b8" class="ks kt ht lt b fv mb ly l lz ma">function transferUSDFrom(address from, address to, uint amount) {<br/>  <br/>  if(allowed[msg.sender][from] &gt;= amount &amp;&amp; balances[from] &gt;= amount) {<br/>    allowed[msg.sender][from] -= amount;<br/>    balances[from] -= amount;<br/>    balances[to] += amount;<br/>  }<br/> }<br/>}</span></pre><p id="9c00" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">以下是上述代码的工作原理:</p><p id="2481" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">首先，定义一个映射来存储每家银行持有的美元数量。每个银行可以有多个地址来实现隐私。这些地址不一定是银行。它们也可以是其他智能合约，因为每个智能合约也有<code class="eh mc md me lt b">address</code>。</p><p id="c505" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">接下来，你假设中央银行部署合约。因此，您通过将中央银行的<code class="eh mc md me lt b">address</code>分配给<code class="eh mc md me lt b">owner</code>来将中央银行定义为发行人。</p><p id="6f9a" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">然后，您定义函数<code class="eh mc md me lt b">issueUSD</code>，通过该函数，央行可以向其他银行发行美元。</p><p id="4a37" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">然后，您定义另一个名为<code class="eh mc md me lt b">transferUSD</code>的函数，银行可以通过它在彼此之间转移美元。</p><p id="c032" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">接下来，您有一个读取帐户余额的函数。</p><p id="6bc5" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">最后，你有两个重要的函数:<code class="eh mc md me lt b">approve</code>和<code class="eh mc md me lt b">transferUSDFrom</code>。<code class="eh mc md me lt b">transferUSDFrom</code>功能允许合约代表你发送美元。换句话说，您正在为同一区块链上的其他智能合约提供API来管理您的资金。<code class="eh mc md me lt b">approve</code>功能用于批准管理您资金的智能合同。在给<code class="eh mc md me lt b">approve</code>打电话时，你提到合同能管理你多少资金。</p><p id="6d86" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">现在，部署一个类似的合同，在第二个网络中数字化INR。将之前合同中的<code class="eh mc md me lt b">USD</code>替换为<code class="eh mc md me lt b">INR</code>并部署。它应该是这样的:</p><pre class="jk jl jm jn fq ls lt lu lv aw lw dt"><span id="a064" class="ks kt ht lt b fv lx ly l lz ma">pragma solidity ^0.4.19;</span><span id="31b0" class="ks kt ht lt b fv mb ly l lz ma">contract INR {<br/> mapping (address =&gt; uint) balances;<br/> mapping (address =&gt; mapping (address =&gt; uint)) allowed;<br/> address owner;<br/> <br/> function INR() {<br/>  owner = msg.sender;<br/> }</span><span id="ef52" class="ks kt ht lt b fv mb ly l lz ma">function issueINR(address to, uint amount) {<br/>  if(msg.sender == owner) {<br/>  balances[to] += amount;<br/>  }<br/> }</span><span id="05f1" class="ks kt ht lt b fv mb ly l lz ma">function transferINR(address to, uint amount) {<br/>  if(balances[msg.sender] &gt;= amount) {<br/>   balances[msg.sender] -= amount;<br/>   balances[to] += amount;<br/>  }<br/> }</span><span id="e724" class="ks kt ht lt b fv mb ly l lz ma">function getINRBalance(address account) view returns (uint balance) {<br/>  return balances[account];<br/> }</span><span id="851d" class="ks kt ht lt b fv mb ly l lz ma">function approve(address spender, uint amount) {<br/>  allowed[spender][msg.sender] = amount;<br/> }<br/> <br/> function transferINRFrom(address from, address to, uint amount) {<br/>  if(allowed[msg.sender][from] &gt;= amount &amp;&amp; balances[from]&gt;= amount) {<br/>   allowed[msg.sender][from] -= amount;<br/>   balances[from] -= amount;<br/>   balances[to] += amount;<br/>  }<br/> }<br/>}</span></pre><h2 id="04d0" class="ks kt ht bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">原子互换智能合约</h2><p id="dd83" class="pw-post-body-paragraph jv jw ht jx b jy ln iu ka kb lo ix kd ke lp kg kh ki lq kk kl km lr ko kp kq hm dt translated">你成功地数字化了法定货币。现在是时候实现原子交换智能契约了，它将提供哈希锁定机制。您在每个区块链都部署了原子互换智能合约，也就是说，第一个区块链上的原子互换智能合约将锁定美元一段时间，并期望一家印度银行(此处为ICICI银行)在定义的时间段内使用该秘密来认领它。</p><p id="6845" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">类似地，第二个区块链上的原子互换合同将锁定INR一段时间，并期望一家美国银行(这里是BOA)使用该秘密在规定的时间内认领它。</p><p id="08a8" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">以下是锁定美元的原子互换智能合约:</p><pre class="jk jl jm jn fq ls lt lu lv aw lw dt"><span id="49fd" class="ks kt ht lt b fv lx ly l lz ma">pragma solidity ^0.4.19;<br/><br/>import "./USD.sol";<br/><br/>contract AtomicSwap_USD {<br/><br/>    struct AtomicTxn {<br/>        address from;<br/>        address to;<br/>        uint lockPeriod;<br/>        uint amount;<br/>    }<br/><br/>    mapping (bytes32 =&gt; AtomicTxn) txns;<br/>    USD USDContract;<br/><br/>    event usdLocked(address to, bytes32 hash, uint expiryTime, <br/>      uint amount);<br/>    event usdUnlocked(bytes32 hash);<br/>    event usdClaimed(string secret, address from, bytes32 hash);<br/><br/>    function AtomicSwap_USD(address usdContractAddress) {<br/>        USDContract = USD(usdContractAddress); <br/>    }<br/><br/>    function lock(address to, bytes32 hash, uint lockExpiryMinutes,<br/>      uint amount) {<br/>        USDContract.transferUSDFrom(msg.sender, address(this), amount);<br/>        txns[hash] = AtomicTxn(msg.sender, to, block.timestamp + <br/>         (lockExpiryMinutes * 60), amount);<br/>        usdLocked(to, hash, block.timestamp + (lockExpiryMinutes * 60),<br/>          amount);<br/>    }<br/><br/>    function unlock(bytes32 hash) {<br/>        if(txns[hash].lockPeriod &lt; block.timestamp) {<br/>            USDContract.transferUSD(txns[hash].from, <br/>              txns[hash].amount);<br/>            usdUnlocked(hash);<br/>        }<br/>    }<br/><br/>    function claim(string secret) {<br/>        bytes32 hash = sha256(secret);<br/>        USDContract.transferUSD(txns[hash].to, txns[hash].amount);<br/>        usdClaimed(secret, txns[hash].from, hash);<br/>    }<br/><br/>    function calculateHash(string secret) returns (bytes32 result) {<br/>        return sha256(secret);<br/>    }<br/>}</span></pre><p id="9b4d" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">下面是前面的智能合约的工作原理:</p><p id="fdae" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">在部署智能契约时，您提供了<code class="eh mc md me lt b">USD</code>契约的契约地址，以便它可以调用其函数来转移资金。</p><p id="24a9" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated"><code class="eh mc md me lt b">lock</code>方法用于使用<code class="eh mc md me lt b">hash</code>锁定资金。显然，在调用<code class="eh mc md me lt b">lock</code>方法之前，BOA必须批准这个原子互换契约地址，以便能够访问其一定数量的资金。需要<code class="eh mc md me lt b">hash</code>，锁定一定时间的资金。<code class="eh mc md me lt b">amount</code>指定要锁定多少美元，该金额应小于或等于批准的金额。<code class="eh mc md me lt b">to</code>地址指定了印度银行的地址——即ICICI银行。所以，当ICICI银行来认领资金时，他们会去这个地址。这个函数实际上将资金转移到其合同地址(即<code class="eh mc md me lt b">address(this)</code>)并触发一个事件，以便ICICI银行可以看到资金已经被锁定。</p><p id="942e" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">在<code class="eh mc md me lt b">hash</code>到期后，如果资金无人认领，BOA可使用<code class="eh mc md me lt b">unlock</code>方法解锁资金。</p><p id="9fa2" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">ICICI银行使用<code class="eh mc md me lt b">claim</code>方法来要求使用秘密的资金。</p><p id="6186" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">最后，你用<code class="eh mc md me lt b">calculateHash</code>的方法来计算一个秘密的<code class="eh mc md me lt b">hash</code>。</p><p id="dc25" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">将前面合同中的<code class="eh mc md me lt b">USD</code>更改为<code class="eh mc md me lt b">INR</code>，为第二个区块链提供原子互换智能合同。下面是代码的样子:</p><pre class="jk jl jm jn fq ls lt lu lv aw lw dt"><span id="7ebe" class="ks kt ht lt b fv lx ly l lz ma">pragma solidity ^0.4.19;<br/><br/>import "./INR.sol";<br/><br/>contract AtomicSwap_INR {<br/><br/>    struct AtomicTxn {<br/>        address from;<br/>        address to;<br/>        uint lockPeriod;<br/>        uint amount;<br/>    }<br/><br/>    mapping (bytes32 =&gt; AtomicTxn) txns;<br/>    INR INRContract;<br/><br/>    event inrLocked(address to, bytes32 hash, uint expiryTime,<br/>      uint amount);<br/>    event inrUnlocked(bytes32 hash);<br/>    event inrClaimed(string secret, address from, bytes32 hash);<br/><br/>    function AtomicSwap_INR(address inrContractAddress) {<br/>        INRContract = INR(inrContractAddress); <br/>    }<br/><br/>    function lock(address to, bytes32 hash, uint lockExpiryMinutes, <br/>      uint amount) {<br/>        INRContract.transferINRFrom(msg.sender, address(this), amount);<br/>        txns[hash] = AtomicTxn(msg.sender, to, block.timestamp + <br/>         (lockExpiryMinutes * 60), amount);<br/>        inrLocked(to, hash, block.timestamp + (lockExpiryMinutes * 60), <br/>          amount);<br/>    }<br/><br/>    function unlock(bytes32 hash) {<br/>        if(txns[hash].lockPeriod &lt; block.timestamp) {<br/>            INRContract.transferINR(txns[hash].from, <br/>              txns[hash].amount);<br/>            inrUnlocked(hash);<br/>        }<br/>    }<br/><br/>    function claim(string secret) {<br/>        bytes32 hash = sha256(secret);<br/>        INRContract.transferINR(txns[hash].to, txns[hash].amount);<br/>        inrClaimed(secret, txns[hash].from, hash);<br/>    }<br/><br/>    function calculateHash(string secret) returns (bytes32 result) {<br/>        return sha256(secret);<br/>    }<br/>}</span></pre><h2 id="d5df" class="ks kt ht bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">测试</h2><p id="2e09" class="pw-post-body-paragraph jv jw ht jx b jy ln iu ka kb lo ix kd ke lp kg kh ki lq kk kl km lr ko kp kq hm dt translated">现在，您已经准备好在两个不同区块链的资产之间进行原子互换的智能合约。接下来，编写一些JavaScript代码来测试前面的契约并进行原子交换。下面的代码允许您这样做。出于测试和模拟目的，您可以在一个具有四个帐户的仲裁节点中运行以下代码:</p><pre class="jk jl jm jn fq ls lt lu lv aw lw dt"><span id="0c15" class="ks kt ht lt b fv lx ly l lz ma">var generateSecret = function () {<br/>    return Math.random().toString(36).substr(2, 9);<br/>};<br/><br/>var web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));<br/><br/>var RBI_Address = "0x92764a01c43ca175c0d2de145947d6387205c655";<br/>var FRS_Address = "0xbc37e7ba9f099ba8c61532c6fce157072798fe77";<br/>var BOA_Address = "0x104803ea6d8696afa6e7a284a46a1e71553fcf12";<br/>var ICICI_Address = "0x84d2dab0d783dd84c40d04692e303b19fa49bf47";<br/><br/>var usdContract_ABI = /* Put JSON here */;<br/>var usdContract_Bytecode = "0x606..."<br/>var atomicswapUSD_ABI = /* Put JSON here */;<br/>var atomicswapUSD_Bytecode = "0x606..."<br/>var inrContract_ABI = /* Put JSON here */;<br/>var inrContract_Bytecode = "0x606..."<br/>var atomicswapINR_ABI = /* Put JSON here */;<br/>var atomicswapINR_Bytecode = "0x606..."<br/><br/>var usdContract = web3.eth.contract(usdContract_ABI);<br/>var usd = usdContract.new({<br/>  from: FRS_Address, <br/>   data: usdContract_Bytecode, <br/>   gas: "4700000"<br/>}, function (e, contract){<br/>  if (typeof contract.address !== 'undefined') {<br/>    var usdContractAddress = contract.address;<br/>    var usdContractInstance = usdContract.at(usdContractAddress)<br/>    var atomicswap_usdContract = web3.eth.contract(atomicswapUSD_ABI);<br/>    var atomicswap_usd = atomicswap_usdContract.new(usdContractAddress, {<br/>        from: FRS_Address, <br/>        data: atomicswapUSD_Bytecode, <br/>        gas: "4700000"<br/>    }, function (e, contract){<br/>        if (typeof contract.address !== 'undefined') {<br/>            var atomicSwapUSDAddress = contract.address;<br/>            var atomicSwapUSDContractInstance =<br/>              atomicswap_usdContract.at(atomicSwapUSDAddress);<br/><br/>            var inrContract = web3.eth.contract(inrContract_ABI);<br/><br/>        var inr = inrContract.new({<br/>            from: RBI_Address, <br/>            data: inrContract_Bytecode, <br/>            gas: "4700000"<br/>        }, function (e, contract){<br/>            if(typeof contract.address !== 'undefined') {<br/>                var inrContractAddress = contract.address;<br/>                var inrContractInstance = <br/>                  inrContract.at(inrContractAddress)<br/>            var atomicswap_inrContract =<br/>              web3.eth.contract(atomicswapINR_ABI);<br/>            var atomicswap_inr = atomicswap_inrContract.new(<br/>                inrContractAddress, {<br/>                from: RBI_Address, <br/>                data: atomicswapINR_Bytecode, <br/>                gas: '4700000'<br/>            }, function (e, contract){<br/>                if (typeof contract.address !== 'undefined') {<br/>                    var atomicSwapINRAddress = contract.address;<br/>                    var atomicSwapINRContractInstance = <br/>                      atomicswap_inrContract.at(atomicSwapINRAddress);<br/><br/><br/>                }<br/>            })<br/>            }<br/>        })<br/>        }<br/>    })<br/>  }<br/>})</span></pre><p id="cdff" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">首先，您部署了<code class="eh mc md me lt b">USD</code>契约，然后通过将<code class="eh mc md me lt b">USD</code>契约的地址作为参数进行传递，部署了USD的原子互换契约。您将这些合同部署为FRS。然后，通过将<code class="eh mc md me lt b">INR</code>契约的地址作为参数进行传递，为INR部署<code class="eh mc md me lt b">INR</code>契约和原子交换契约。您将这些合同部署为RBI。</p><p id="4828" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">将以下代码放在提到延续的地方:</p><pre class="jk jl jm jn fq ls lt lu lv aw lw dt"><span id="19a7" class="ks kt ht lt b fv lx ly l lz ma">//Issue USD<br/>usdContractInstance.issueUSD.sendTransaction(BOA_Address, 1000,<br/>  {from: FRS_Address}, function(e, txnHash){<br/><br/>  //Fetch USD Balance<br/>  console.log("Bank of America's USD Balance is : " + <br/>    usdContractInstance.getUSDBalance.call(BOA_Address).toString())<br/><br/>  //Issue INR<br/>  inrContractInstance.issueINR.sendTransaction(ICICI_Address, 1000,<br/>   {from: RBI_Address}, function(e, txnHash){<br/><br/>    //Fetch INR Balance<br/>    console.log("ICICI Bank's INR Balance is : " + <br/>      inrContractInstance.getINRBalance.call(ICICI_Address).toString())<br/><br/>    //Generate Secret and Hash<br/>    var secret = generateSecret();<br/>    var hash = atomicSwapUSDContractInstance.calculateHash.call(secret,<br/>      {from: BOA_Address});<br/><br/>    //Give Access to Smart Contract<br/>    usdContractInstance.approve.sendTransaction(atomicSwapUSDAddress,<br/>      1000, {from: BOA_Address}, function(e, txnHash){<br/><br/>      //Give Access to Smart Contract<br/>      inrContractInstance.approve.sendTransaction(atomicSwapINRAddress,<br/>        1000, {from: ICICI_Address}, function(e, txnHash){<br/><br/>        //Lock 1000 USD for 30 min<br/>        atomicSwapUSDContractInstance.lock.sendTransaction(ICICI_Address, hash, <br/>  30, 1000, {from: BOA_Address, gas: 4712388}, function(e, txnHash){<br/><br/>          //Fetch USD Balance<br/>          console.log("USD Atomic Exchange Smart Contracts holds : " + <br/>            usdContractInstance.getUSDBalance.call<br/>            (atomicSwapUSDAddress).toString())<br/><br/>          //Lock 1000 INR for 15 min<br/>          atomicSwapINRContractInstance.lock.sendTransaction(BOA_Address,<br/>  hash, 15, 1000, {from: ICICI_Address, gas: 4712388},<br/>  function(e, txnHash){<br/><br/>            //Fetch INR Balance<br/>            console.log("INR Atomic Exchange Smart Contracts holds : "<br/>              + inrContractInstance.getINRBalance.call<br/>              (atomicSwapINRAddress).toString())<br/><br/>            atomicSwapINRContractInstance.claim(secret, {<br/>              from: BOA_Address, gas: 4712388<br/>            }, function(error, txnHash){<br/><br/>              //Fetch INR Balance<br/>              console.log("Bank of America's INR Balance is : " +<br/>                inrContractInstance.getINRBalance.call<br/>                (BOA_Address).toString())<br/><br/>              atomicSwapUSDContractInstance.claim(secret, {<br/>                from: ICICI_Address, gas: 4712388<br/>              }, function(error, txnHash){<br/><br/>                //Fetch USD Balance<br/>                console.log("ICICI Bank's USD Balance is : " +<br/>                  usdContractInstance.getUSDBalance.call<br/>                  (ICICI_Address).toString())<br/>              })<br/><br/>            })<br/><br/>          })<br/>        })<br/>      })<br/><br/>    })<br/>  })<br/><br/>})</span></pre><p id="71d3" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">以下是上述代码的工作原理:</p><p id="cbd9" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">1.这里，FRS向BOA发行美元，然后RBI向ICICI银行发行印度卢比。</p><p id="506e" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">2.然后，宝儿产生了一个秘密。您使用一个非常基本的函数来生成一个秘密。显然，在现实世界的场景中，您应该使用某种基于硬件的工具来生成这些安全的秘密。</p><p id="74db" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">3.接下来，计算秘密的散列。</p><p id="ad7f" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">4.美国银行和ICICI银行分别向美元原子掉期和印度卢比原子合约提供资金。</p><p id="cf2c" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">5.美国银行在美元原子掉期合约中锁定美元30分钟，并声明只有ICICI银行可以要求资金。</p><p id="7947" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">6.同样，ICICI银行在INR原子掉期合约中锁定INR 15分钟，并声明只有BOA可以申请资金。</p><p id="4da3" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">7.最后，BOA继续要求INR。ICICI一知道这个秘密，它就开始行动，要求赔偿美元。</p><p id="db48" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">为了测试前面的契约，首先，复制您的以太坊地址并替换在前面的例子中已经生成的地址。然后，确保您解锁了节点中的所有四个帐户。最后，编译契约并填充<code class="eh mc md me lt b">ABI</code>和<code class="eh mc md me lt b">Bytecode</code>变量。</p><p id="32f0" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated"><em class="kr">如果你觉得这篇文章有趣，你可以探索Narayan Prusty的</em> <a class="ae mf" href="https://www.amazon.com/Blockchain-Enterprise-applications-interoperability-permissioned/dp/1788479742" rel="noopener ugc nofollow" target="_blank">区块链for Enterprise </a> <em class="kr">在你选择的使用以太坊的领域中实现区块链原则。</em> <a class="ae mf" href="https://www.packtpub.com/big-data-and-business-intelligence/blockchain-enterprise" rel="noopener ugc nofollow" target="_blank">面向企业的区块链</a> <em class="kr">涵盖了面向企业和开发者的区块链的方方面面，通过真实世界的例子，可以帮助你理解DApps是什么以及区块链生态系统是如何运作的。</em></p><blockquote class="mg"><p id="ee78" class="mh mi ht bd mj mk ml mm mn mo mp kq ek translated"><a class="ae mf" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mr ms mt mu mv jo fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mq"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>