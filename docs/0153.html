<html>
<head>
<title>A Gentle Introduction to Building a Full Stack DApp on Ethereum — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊上构建全栈DApp的温和介绍—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-gentle-intro-to-building-a-full-stack-dapp-on-ethereum-part-1-c1aedb11fcd2?source=collection_archive---------0-----------------------#2018-03-10">https://medium.com/coinmonks/a-gentle-intro-to-building-a-full-stack-dapp-on-ethereum-part-1-c1aedb11fcd2?source=collection_archive---------0-----------------------#2018-03-10</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/815c30b4de4cbc45c74ecc92bfab3b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qI9z3JVl-qp6wuEVa3sVhQ.jpeg"/></div></div></figure><p id="7328" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在本教程中，我们将构建一个简单的dapp(分散式应用程序)。目标是介绍技术堆栈的所有部分，并展示它们是如何协同工作的。我们不会深入到任何单一的技术，而是覆盖刚刚够开始作为你自己的项目的基础。这个dapp将简单地存储和检索以太坊和IPFS上的用户输入文本，并使用uPort进行登录。</p><p id="7af7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">本教程分为两个部分:<br/> <strong class="jd hu">第一部分— </strong>编写智能契约，用于编译和迁移的Solidity，Truffle和一个用于我们前端的服务。<br/> <a class="ae jz" rel="noopener" href="/@mwallaceboulder/a-gentle-intro-to-building-a-full-stack-dapp-on-ethereum-part-3-c48e99b4d3e8"> <strong class="jd hu">第二部分</strong> </a> —使用React、uPort和IPFS与智能合约集成。</p><p id="eac0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们将使用以下技术栈:<br/><a class="ae jz" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">React</a>-前端库<br/><a class="ae jz" href="https://solidity.readthedocs.io/en/develop/" rel="noopener ugc nofollow" target="_blank">Solidity</a>-用于构建运行在以太坊<br/><a class="ae jz" href="http://truffleframework.com/" rel="noopener ugc nofollow" target="_blank">Truffle</a>上的智能合约的语言-用于编译、迁移和测试智能合约的框架。<br/><a class="ae jz" href="https://ipfs.io/" rel="noopener ugc nofollow" target="_blank">IPFS</a>-分散存储<br/><a class="ae jz" href="https://www.uport.me/" rel="noopener ugc nofollow" target="_blank">支持</a> -身份管理、数字签名交易和轻松登录dapps。</p><blockquote class="ka"><p id="5f99" class="kb kc ht bd kd ke kf kg kh ki kj jy ek translated"><a class="ae jz" href="https://coincodecap.com/category/blockchain-node-and-api" rel="noopener ugc nofollow" target="_blank">发现并回顾最佳区块链api和节点产品</a></p></blockquote><p id="61bf" class="pw-post-body-paragraph jb jc ht jd b je kk jg jh ji kl jk jl jm km jo jp jq kn js jt ju ko jw jx jy hm dt translated">React的知识不是必需的，但最好有。我们将构建一个可以在任何前端框架中轻松使用的服务。</p><figure class="kq kr ks kt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff kp"><img src="../Images/7f2e59ac4f4d77fc08c28dc309df917e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JzEsST1gV0Ooyp_-5e6dSg.jpeg"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">The dapp architecture</figcaption></figure><p id="26e8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要跟进，在这里下载dapp回购:<a class="ae jz" href="https://github.com/zerostatic/dapp-starter-kit" rel="noopener ugc nofollow" target="_blank">https://github.com/zerostatic/dapp-starter-kit</a></p><p id="bb29" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下载后，安装依赖项:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="71dd" class="ld le ht kz b fv lf lg l lh li">yarn install</span></pre><p id="6de6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要运行该应用程序:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="dce1" class="ld le ht kz b fv lf lg l lh li">yarn start</span></pre><h1 id="2a91" class="lj le ht bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">第一部分:</h1><p id="ef9c" class="pw-post-body-paragraph jb jc ht jd b je mg jg jh ji mh jk jl jm mi jo jp jq mj js jt ju mk jw jx jy hm dt translated">在第一部分中，我们将使用Remix在Solidity中编写一个智能契约。我们将使用Truffle进行编译和迁移，并创建一个前端服务，我们可以用它来与合同进行交互。</p><figure class="kq kr ks kt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/8042d283fcd892a3f6fb30e9d51e25a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7RegqS_uCZVeu_JGOm2Dxg.jpeg"/></div></div></figure><p id="5cea" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae jz" href="https://solidity.readthedocs.io/en/v0.4.20/" rel="noopener ugc nofollow" target="_blank">坚固性</a>是用于编写运行在以太网网络上的智能合同的语言。我们的坚实智能合同将是非常基本的，只包含两个功能。一个保存IPFS散列和时间戳的函数，存储在用户地址下。另一个函数将返回特定用户地址的IPFS散列和时间戳。更多关于<a class="ae jz" href="https://ipfs.io/" rel="noopener ugc nofollow" target="_blank"> IPFS </a>以后。</p><h2 id="1c31" class="ld le ht bd lk ml mm mn lo mo mp mq ls jm mr ms lw jq mt mu ma ju mv mw me mx dt translated">混音:</h2><p id="7380" class="pw-post-body-paragraph jb jc ht jd b je mg jg jh ji mh jk jl jm mi jo jp jq mj js jt ju mk jw jx jy hm dt translated">我们将使用在线工具<a class="ae jz" href="https://remix.ethereum.org" rel="noopener ugc nofollow" target="_blank"> Remix </a>编写Solidity代码。Remix是一个在线IDE，它使得编写和调试Solidity变得非常容易。您可以在这里找到Remix IDE:<a class="ae jz" href="https://remix.ethereum.org" rel="noopener ugc nofollow" target="_blank">https://remix.ethereum.org</a></p><p id="b819" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在Remix中，通过选择左上角的“加号”图标创建一个新文件。然后将文件命名为:MyDetails.sol。</p><figure class="kq kr ks kt fq iu fe ff paragraph-image"><div class="fe ff my"><img src="../Images/ca02e310bef0a785e847e2825e74e69b.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*gTdlA3xrQ_l0wiDg-IUu9w.png"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">Select for new file</figcaption></figure><p id="211e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，在屏幕右侧，选择“运行”。然后在“环境”旁边选择“JavaScript虚拟机”。这将允许您在浏览器中测试和运行智能合同。</p><figure class="kq kr ks kt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mz"><img src="../Images/5f14c7ec6f60974bdda372e28ed2bb89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UA1ZIPJbVXjYDngFYNRp4w.png"/></div></div></figure><p id="4e3f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，在代码中，我们需要告诉编译器使用哪个版本的Solidity。将此添加到文件顶部:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="d33e" class="ld le ht kz b fv lf lg l lh li">pragma solidity ^0.4.18;</span></pre><p id="d5a0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要创建合同类，请添加以下内容:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="0bb2" class="ld le ht kz b fv lf lg l lh li">MyDetails {</span><span id="b575" class="ld le ht kz b fv na lg l lh li">}</span></pre><p id="3b80" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在类中，我们将添加两个映射。一个用于存储IPF散列，一个用于存储时间戳。在类定义中，添加以下两行:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="9cea" class="ld le ht kz b fv lf lg l lh li">mapping (address =&gt; string) ipfsHashes;<br/>mapping (address =&gt; uint) timestamp;</span></pre><p id="9e89" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">什么是映射？映射可以被认为是哈希表。要定义映射，首先将类型设置为<code class="eh nb nc nd kz b">mapping</code>。接下来，我们设置键和值类型。在我们的第一个映射中，键是一个<strong class="jd hu">地址</strong>，类型是一个<strong class="jd hu">字符串:</strong> <code class="eh nb nc nd kz b">(address =&gt; string)</code> <strong class="jd hu"> </strong>换句话说:映射中的每个条目将在一个唯一的地址下存储一个字符串。最后，我们为映射设置了一个变量名:<code class="eh nb nc nd kz b">ipfsHashes</code></p><p id="cc33" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在第二个映射中，我们将把时间戳作为uint(无符号整数)存储在用户地址下。</p><p id="5bed" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来是设置数据的功能:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="c5c8" class="ld le ht kz b fv lf lg l lh li">function setHash(string ipfsHash) public {<br/>     ipfsHashes[msg.sender] = ipfsHash;<br/>     timestamp[msg.sender] = now;<br/>}</span></pre><p id="702a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该函数接收ipfs哈希字符串作为参数。然后，我们使用映射将ipfs哈希存储在用户地址下。此处显示:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="4218" class="ld le ht kz b fv lf lg l lh li">ipfsHashes[msg.sender] = ipfsHash;</span></pre><p id="3737" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在Solidity中，<code class="eh nb nc nd kz b">msg.sender</code>会自动设置为发送方的地址，因此我们可以将它用作映射的密钥，并将ipfs哈希存储为值。</p><p id="73de" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">函数中的第二行是:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="ca43" class="ld le ht kz b fv lf lg l lh li">timestamp[msg.sender] = now;</span></pre><p id="3b22" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里我们还使用用户地址作为密钥并设置值<code class="eh nb nc nd kz b">now</code>，这将保存时间戳。</p><p id="953d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来是检索数据的函数:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="cfd0" class="ld le ht kz b fv lf lg l lh li">function getHash(address account) public view returns(string, uint) {<br/>     return (ipfsHashes[account], timestamp[account]);<br/>}</span></pre><p id="cd9d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该函数接受一个地址作为参数，并返回存储在该用户地址下的ipfs哈希和时间戳。</p><p id="9e86" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在solidity中，我们需要设置几个可见性关键字:<code class="eh nb nc nd kz b">public</code>表示它可以从契约外部调用，<code class="eh nb nc nd kz b">view</code>表示这个函数是只读的。</p><p id="b5c7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可靠性还要求您在这里定义返回类型，我们指定:<code class="eh nb nc nd kz b">returns(string, uint)</code>，这意味着我们返回一个字符串和一个uint(一个ipfs散列和时间戳)</p><p id="4b81" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以下是我们智能合约的完整代码:</p><figure class="kq kr ks kt fq iu"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="4c03" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们现在可以通过选择“创建”来测试代码</p><figure class="kq kr ks kt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ng"><img src="../Images/06da32597226ba74cda419bb8800a75b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TkIN1SKTS_Pas7x16bCfCw.png"/></div></div></figure><p id="b59c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后在下面你会看到你的契约中的getters和setters列表:</p><figure class="kq kr ks kt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nh"><img src="../Images/8f5d9c6494388d5c235fa6eac2c7e8dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJi4vhFi_QnVjEw0ekbPFQ.png"/></div></div></figure><p id="ec81" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">继续在“setHash”旁边输入任意字符串，确保输入的值用引号括起来，以表示一个字符串。然后选择“setHash”。</p><p id="6346" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，在“gethash”旁边输入地址账号。<em class="ni">地址列在右上角“账户”旁边——选择复制图标获取地址。</em>点击“getHash ”,你应该会看到你设置Hash时输入的字符串。</p><p id="eb37" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">既然合同已经完成。让我们看看如何将它集成到我们的项目中。</p><figure class="kq kr ks kt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/616dab405ec423561969697360d51b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8dt8v_BOYfrP8fYN5BgsA.jpeg"/></div></div></figure><p id="e7f8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Truffle是一个编译、迁移和测试合同的框架。它还可以处理部署到不同私有和公共网络的网络管理。</p><p id="8648" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在项目文件中，打开<code class="eh nb nc nd kz b">src/ethereum</code>处的目录。这是我们将用来编译和迁移Solidity智能合同的目录。以太坊目录已经包含了编译和迁移所需的所有目录。让我们看看这是如何做到的。首先，您需要对Truffle进行全局安装:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="290a" class="ld le ht kz b fv lf lg l lh li">npm install -g truffle</span></pre><p id="ca69" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">目录:<code class="eh nb nc nd kz b">build, contracts, migrations and test</code>是通过运行以下命令自动创建的:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="6ad3" class="ld le ht kz b fv lf lg l lh li">truffle init</span></pre><p id="1fa6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下面两个文件也是在<code class="eh nb nc nd kz b">truffle init</code>运行时自动生成的:<code class="eh nb nc nd kz b">contracts/Migrations.sol</code>和<code class="eh nb nc nd kz b">migrations/1_initial_migration.js</code> Truffle要求您拥有这个初始迁移合同，以便使用迁移特性。对于大多数项目，该合同将在第一次迁移时部署，不会再次更新。</p><p id="105d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在来看看文件:<code class="eh nb nc nd kz b">contracts/MyDetails.sol</code>这是我们上面用Remix创建的Solidity文件。为了标记迁移，我在<code class="eh nb nc nd kz b">migrations/2_myDetails_migrations.js</code>添加了一个文件。这个文件的命名很重要。它以数字2开始，因为我们希望它在第一个契约之后编译。</p><p id="1533" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以下是该文件的内容:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="a2ac" class="ld le ht kz b fv lf lg l lh li">var Mydetails = artifacts.require("./MyDetails.sol");</span><span id="ff06" class="ld le ht kz b fv na lg l lh li">module.exports = function (deployer) {<br/>   deployer.deploy(Mydetails);<br/>};</span></pre><p id="1a91" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是一个标准的Truffle迁移样板文件，指向我们想要迁移的Solidity文件。</p><p id="4492" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们来编辑合同。在终端中确保您的当前目录是:<code class="eh nb nc nd kz b">src/ethereum</code>然后运行:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="876f" class="ld le ht kz b fv lf lg l lh li">truffle compile</span></pre><p id="f48f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">编译完成后，您将在目录:<code class="eh nb nc nd kz b">build/contracts</code>中看到编译后的json文件，稍后我们将使用这些文件与契约进行交互。</p><p id="f6fe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，我们将设置用于部署契约的配置文件。我们将部署到Rinkeby测试网络，因为这是uPort目前使用的网络。uPort将很快在其他测试网络上可用，稍后将在主以太网上可用。</p><p id="c678" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们将使用Infura连接到Rinkeby网络。首先，去Infura注册:<a class="ae jz" href="https://infura.io/signup" rel="noopener ugc nofollow" target="_blank">https://infura.io/signup</a>注册后，你会收到一封电子邮件，里面有一系列与你的账户相关的Infura网址。复制为Rinkeby提供的url。</p><p id="33b3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">打开文件<code class="eh nb nc nd kz b">truffle.js</code>，配置已经设置好，如下所示:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="9771" class="ld le ht kz b fv lf lg l lh li">var HDWalletProvider = require('truffle-hdwallet-provider');</span><span id="3a52" class="ld le ht kz b fv na lg l lh li">var mnemonic = 'candy maple cake sugar pudding cream honey rich smooth crumble sweet treat';</span><span id="329f" class="ld le ht kz b fv na lg l lh li">module.exports = {<br/>  rinkeby: {<br/>    provider: new HDWalletProvider(mnemonic,<br/>    'https://rinkeby.infura.io/XAmfM8SVSh5OkuiYMIBx',<br/>    1),<br/>    network_id: 5,<br/>    gas: 6712388,<br/>    gasPrice: 10000000<br/>  },<br/> },<br/>};</span></pre><p id="448c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">注意<code class="eh nb nc nd kz b">truffle-hdwallet-provider</code>的导入，这是使用Truffle配置部署所必需的。这是使用命令安装的:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="4f35" class="ld le ht kz b fv lf lg l lh li">npm install --save truffle-hdwallet-provider</span></pre><p id="3143" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">用注册Infura后收到的网址替换<code class="eh nb nc nd kz b">rinkeby.infura</code>网址。</p><p id="ef14" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在编写本文时，配置文件中设置的gas和gasPrice是有效的，但是您可能需要针对将来的情况进行调整。</p><p id="986d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们准备将智能合约迁移到Rinkeby。在终端中输入:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="e316" class="ld le ht kz b fv lf lg l lh li">truffle migrate --network rinkeby</span></pre><p id="bf68" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">迁移将需要15秒或更长时间。如果成功，我们就可以开始与合同互动了！</p><h1 id="632e" class="lj le ht bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">合同服务:</h1><p id="5e89" class="pw-post-body-paragraph jb jc ht jd b je mg jg jh ji mh jk jl jm mi jo jp jq mj js jt ju mk jw jx jy hm dt translated">接下来，在项目目录中查看<code class="eh nb nc nd kz b">/service</code>目录。里面是我已经创建的名为:<code class="eh nb nc nd kz b">DetailService.js</code>的服务，我们可以用它来与契约进行交互。打开这个文件，我们来浏览一下。</p><p id="40d5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，注意顶部的web导入</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="b61d" class="ld le ht kz b fv lf lg l lh li">import { web3 } from "../util/Uport";</span></pre><p id="6f04" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">web3.js是一个库的集合，它允许你与本地或远程以太坊节点交互。因为我们使用uPort，所以我们将使用web3的uPort实现来进行契约交互。如果您想使用不同的提供者，如<a class="ae jz" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> MetaMask </a>而不是uPort，您可以在这里使用标准版本的<a class="ae jz" href="https://github.com/ethereum/web3.js/" rel="noopener ugc nofollow" target="_blank">web 3</a>。</p><p id="d0f3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下一次导入显示我们将使用<code class="eh nb nc nd kz b">truffle-contract</code>,它是使用</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="3456" class="ld le ht kz b fv lf lg l lh li">npm install truffle-contract --save</span></pre><p id="a298" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Truffle contract通过提供更好的控制流和使用承诺(即，在你保证交易已经被挖掘之前，交易不会完成)使与合同的交互变得容易。以及此处所列<a class="ae jz" href="https://github.com/trufflesuite/truffle-contract" rel="noopener ugc nofollow" target="_blank">的其他功能。</a></p><p id="57fe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，我们将导入之前用Truffle创建的已编译的契约:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="eb9a" class="ld le ht kz b fv lf lg l lh li">import MyDetails from '../ethereum/build/contracts/MyDetails.json';</span></pre><p id="ea61" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后我们配置truffle-contract并设置web3提供者:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="5c5b" class="ld le ht kz b fv lf lg l lh li">const DetailsContract = contract(MyDetails);<br/>DetailsContract.setProvider(web3.currentProvider);</span></pre><p id="d2d9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第一个函数只是返回契约的一个实例:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="2b6c" class="ld le ht kz b fv lf lg l lh li">const getInstance = async () =&gt; {<br/>   const instance = await DetailsContract.deployed();<br/>   return instance;<br/>}</span></pre><p id="c41e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下一个函数将调用合同上的事务。这里我们传递一个地址和一个IPFS散列。散列作为一个参数被传递，地址被设置为<code class="eh nb nc nd kz b">from</code>字段，我们的契约将它作为<code class="eh nb nc nd kz b">msg.sender</code>接收。注意，函数名<code class="eh nb nc nd kz b">setHash</code>与我们在Solidity契约中使用的名称相同。</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="e40e" class="ld le ht kz b fv lf lg l lh li">export const setContractHash = async (account, hash) =&gt; {<br/>   const instance = await getInstance();<br/>   const items = await instance.setHash(hash, { from: account });<br/>   return items;<br/>}</span></pre><p id="e379" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第二个函数用于获取IPFS散列。在这里，我们传递将用于查找存储散列的地址:</p><pre class="kq kr ks kt fq ky kz la lb aw lc dt"><span id="a6a1" class="ld le ht kz b fv lf lg l lh li">export const getContractHash = async (account) =&gt; {<br/>   const instance = await getInstance();<br/>   const items = await instance.getHash(account);<br/>   return items;<br/>}</span></pre><p id="f7e7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这就是我们服务所需要的。您可以在任何前端应用程序中使用该服务，但是对于本教程，我将向您展示如何使用React。</p><p id="d11e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae jz" rel="noopener" href="/@mwallaceboulder/a-gentle-intro-to-building-a-full-stack-dapp-on-ethereum-part-3-c48e99b4d3e8">进入第二部分！</a></p><p id="56cd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="ni">此处表达的所有代码和观点</em><em class="ni">都是我自己的，而不是我雇主的观点。</em></p><blockquote class="ka"><p id="93d1" class="kb kc ht bd kd ke kf kg kh ki kj jy ek translated">加入Coinmonks <a class="ae jz" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jz" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae jz" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="ld le ht bd lk ml nj mn lo mo nk mq ls jm nl ms lw jq nm mu ma ju nn mw me mx dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="no np ht jd b je mg ji mh jm nq jq nr ju ns jy nt nu nv nw dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae jz" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="no np ht jd b je nx ji ny jm nz jq oa ju ob jy nt nu nv nw dt translated"><a class="ae jz" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae jz" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="no np ht jd b je nx ji ny jm nz jq oa ju ob jy nt nu nv nw dt translated"><a class="ae jz" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae jz" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="no np ht jd b je nx ji ny jm nz jq oa ju ob jy nt nu nv nw dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae jz" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="6065" class="no np ht jd b je nx ji ny jm nz jq oa ju ob jy nt nu nv nw dt translated"><a class="ae jz" href="https://coincodecap.com/binance-vs-bitstamp" rel="noopener ugc nofollow" target="_blank">币安vs比特邮票</a> | <a class="ae jz" href="https://coincodecap.com/bitpanda-coinbase-coinsbit" rel="noopener ugc nofollow" target="_blank">比特熊猫vs比特币基地vs Coinsbit </a></li><li id="5711" class="no np ht jd b je nx ji ny jm nz jq oa ju ob jy nt nu nv nw dt translated"><a class="ae jz" href="https://coincodecap.com/buy-ripple-india" rel="noopener ugc nofollow" target="_blank">如何购买Ripple (XRP) </a> | <a class="ae jz" href="https://coincodecap.com/crypto-exchange-africa" rel="noopener ugc nofollow" target="_blank">非洲最好的加密交易所</a></li><li id="861b" class="no np ht jd b je nx ji ny jm nz jq oa ju ob jy nt nu nv nw dt translated"><a class="ae jz" href="https://coincodecap.com/crypto-exchange-africa" rel="noopener ugc nofollow" target="_blank">非洲最佳加密交易所</a> | <a class="ae jz" href="https://coincodecap.com/hoo-exchange-review" rel="noopener ugc nofollow" target="_blank">胡交易所评论</a></li><li id="452c" class="no np ht jd b je nx ji ny jm nz jq oa ju ob jy nt nu nv nw dt translated"><a class="ae jz" href="https://coincodecap.com/etoro-robinhood" rel="noopener ugc nofollow" target="_blank"> eToro vs罗宾汉</a>|<a class="ae jz" href="https://coincodecap.com/bybit-bityard-moonxbt" rel="noopener ugc nofollow" target="_blank">MoonXBT vs Bybit vs Bityard</a></li><li id="47a8" class="no np ht jd b je nx ji ny jm nz jq oa ju ob jy nt nu nv nw dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">面向开发人员的最佳加密API</a></li><li id="b359" class="no np ht jd b je nx ji ny jm nz jq oa ju ob jy nt nu nv nw dt translated">最佳<a class="ae jz" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="no np ht jd b je nx ji ny jm nz jq oa ju ob jy nt nu nv nw dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae jz" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="no np ht jd b je nx ji ny jm nz jq oa ju ob jy nt nu nv nw dt translated">杠杆代币的终极指南</li></ul></div></div>    
</body>
</html>