<html>
<head>
<title>Solidity Fundamentals: Error Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚固性基础:错误处理</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-fundamentals-a95bb6c8ba2a?source=collection_archive---------0-----------------------#2021-01-13">https://medium.com/coinmonks/solidity-fundamentals-a95bb6c8ba2a?source=collection_archive---------0-----------------------#2021-01-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><h2 id="cb43" class="hr hs ht bd b gc hu hv hw hx hy hz ek ia translated" aria-label="kicker paragraph">以太坊智能合约开发</h2><div class=""/><div class=""><h2 id="fe92" class="pw-subtitle-paragraph iz ic ht bd b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ek translated">断言、要求、恢复和异常</h2></div><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/5c1b75d05d5da21124925c2a19bd9eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWjRa349zScDdF6FRZnMCw.jpeg"/></div></div></figure></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="ae9f" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">在编写<em class="lg"> Solidity </em>时，恢复状态变化以防止可能出现的问题是必要的。在这一部分中，我们将学习如何使用<code class="eh lh li lj lk b">revert</code>、<code class="eh lh li lj lk b">require</code>、<code class="eh lh li lj lk b">assert</code>和<code class="eh lh li lj lk b">try/catch</code>来处理错误，以撤销当前调用中对状态所做的所有更改。</p><p id="2ef2" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">目前，Solidity支持两种错误签名:<code class="eh lh li lj lk b">Error(string)</code>和<code class="eh lh li lj lk b">Panic(uint256)</code>。<code class="eh lh li lj lk b">Error(string)</code>用于<em class="lg">常规的</em>错误条件，而<code class="eh lh li lj lk b">Panic(uint256)</code>用于无bug代码中不应该出现的错误。</p></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="606a" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><strong class="km id">慌经</strong> <code class="eh lh li lj lk b"><strong class="km id">assert</strong></code></p><p id="deb2" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><code class="eh lh li lj lk b">assert</code>应仅用于测试内部错误，以及检查不变量。它还应该返回true，因为断言失败意味着代码中存在bug。以下是<em class="lg">实性</em>创建<strong class="km id">断言类型— </strong> <code class="eh lh li lj lk b">Panic(uint256)</code> <strong class="km id"> </strong>异常的情况；</p><ul class=""><li id="fd1b" class="ll lm ht km b kn ko kq kr kt ln kx lo lb lp lf lq lr ls lt dt translated">使用显示<code class="eh lh li lj lk b">false</code>的参数调用<code class="eh lh li lj lk b">assert</code></li><li id="933c" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated">提供的算术运算导致<em class="lg">下溢</em>或<em class="lg">上溢</em>(参见:<a class="ae lz" rel="noopener" href="/coinmonks/solidity-fundamentals-ca824a3ac023">值类型:第一部分</a>)</li><li id="3c73" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated">除以零或以零为模</li><li id="7528" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated">将太大或负值转换为枚举</li><li id="9700" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated">在空数组上调用<code class="eh lh li lj lk b">pop()</code></li><li id="2cf0" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated">访问越界或负数的数组元素</li><li id="c05e" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated">分配太多内存或创建太大的数组</li><li id="0011" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated">调用内部函数类型的零初始化变量</li></ul><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="ma mb l"/></div></figure></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="ac92" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><strong class="km id">错误通过</strong> <code class="eh lh li lj lk b"><strong class="km id">require</strong></code></p><p id="23f5" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><code class="eh lh li lj lk b">require</code>函数用于保证在执行前无法检测到的有效条件。它检查输入、<em class="lg">合同状态变量</em>的<em class="lg">条件或来自外部合同调用的<em class="lg">返回值</em>。它要么创建一个错误类型<code class="eh lh li lj lk b">Error(string)</code>，要么创建一个没有任何错误数据的错误。以下是Solidity创建<strong class="km id">需求类型</strong> — <code class="eh lh li lj lk b">Error(string)</code>异常的情况；</em></p><ul class=""><li id="fb59" class="ll lm ht km b kn ko kq kr kt ln kx lo lb lp lf lq lr ls lt dt translated">使用显示false的参数调用require</li><li id="6113" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated">对不包含代码的协定执行外部函数调用</li><li id="3109" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated">当契约通过不带payable修饰符的公共函数接收Ether时——包括构造函数和回退函数(稍后将详细介绍这些主题)</li><li id="d9e0" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated">当你的契约通过一个<strong class="km id">公共getter </strong>函数获得以太时。</li></ul><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="ma mb l"/></div></figure><blockquote class="mc md me"><p id="1070" class="kk kl lg km b kn ko jd kp kq kr jg ks mf ku kv kw mg ky kz la mh lc ld le lf hm dt translated"><strong class="km id"> <em class="ht">记住:</em> </strong>你可以有选择地为<code class="eh lh li lj lk b"><strong class="km id"><em class="ht">require</em></strong></code>提供一个消息字符串，但不能为<code class="eh lh li lj lk b"><strong class="km id"><em class="ht">assert</em></strong></code>提供。</p></blockquote></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="1bd0" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">对于以下情况，将转发来自外部调用(如果提供)的错误数据。这意味着它可能会导致错误或混乱(或任何其他情况):</p><ul class=""><li id="0b39" class="ll lm ht km b kn ko kq kr kt ln kx lo lb lp lf lq lr ls lt dt translated">当<code class="eh lh li lj lk b">transfer()</code>失败时</li><li id="31a4" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated">当通过消息调用一个函数，但它没有正确完成时(即，它运行<strong class="km id"> </strong> <em class="lg">耗尽</em>，没有<em class="lg">匹配的函数</em>，或<em class="lg">自身抛出异常</em>)，使用低级操作<code class="eh lh li lj lk b">call</code>、<code class="eh lh li lj lk b">send</code>、<code class="eh lh li lj lk b">delegatecall</code>、<code class="eh lh li lj lk b">callcode</code>或<code class="eh lh li lj lk b">staticcall</code>时除外。低级操作从不抛出异常，而是通过返回<code class="eh lh li lj lk b">false</code>来指示失败(稍后将详细介绍低级函数调用)。</li><li id="3eec" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated">当使用<code class="eh lh li lj lk b">new</code>关键字创建合同，但合同创建<a class="ae lz" href="https://docs.soliditylang.org/en/v0.8.0/control-structures.html?highlight=require#creating-contracts" rel="noopener ugc nofollow" target="_blank">未正确完成</a>时。</li></ul><blockquote class="mc md me"><p id="87e7" class="kk kl lg km b kn ko jd kp kq kr jg ks mf ku kv kw mg ky kz la mh lc ld le lf hm dt translated"><strong class="km id"> <em class="ht">注意:</em> </strong> Panic异常在Solidity 0.8.0之前曾经使用过<code class="eh lh li lj lk b">invalid</code>操作码，消耗了所有可供调用的gas。使用<code class="eh lh li lj lk b">require</code>的例外用于消耗所有气体，直到Metropolis发布之前。</p></blockquote></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="78ff" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><code class="eh lh li lj lk b"><strong class="km id">revert</strong></code></p><p id="4e68" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">为了恢复当前调用，我们可以使用<em class="lg">Solidity</em>T13】函数来生成显示错误的异常。该函数将创建一个<code class="eh lh li lj lk b">Error(String) </code>异常，该异常可选地接收包含错误详细信息的字符串消息。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="78e8" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">如果我们直接提供错误字符串，那么以上两个语法选项是等价的，我们可以选择任何一个。</p><p id="6da2" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">上例中，<code class="eh lh li lj lk b">revert(“Only exact payments!”)</code>返回以下十六进制作为错误返回数据:</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="ma mb l"/></div></figure></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="3241" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><code class="eh lh li lj lk b"><strong class="km id">try/catch</strong></code></p><p id="25ab" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">合同创建和外部调用期间的异常可以用<code class="eh lh li lj lk b">try</code> / <code class="eh lh li lj lk b">catch</code>语句捕获。<code class="eh lh li lj lk b">try</code>关键字后面必须跟一个外部函数调用或合同创建的表达式(<code class="eh lh li lj lk b">new ContractName()</code>)。</p><p id="b527" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">由<code class="eh lh li lj lk b">revert("reasonString")</code>或<code class="eh lh li lj lk b"><strong class="km id">require</strong>(false, "reasonString")</code>发生的错误是由类型<code class="eh lh li lj lk b">catch Error(string memory reason)</code>调用的catch子句导致的。</p><p id="712d" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">如果错误签名与任何其他子句都不匹配，如果解码错误消息时出现错误，或者如果异常没有提供错误数据，则执行<code class="eh lh li lj lk b">catch (bytes memory lowLevelData)</code>。</p><p id="cdf2" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">如果我们对错误数据不感兴趣，我们可以使用<code class="eh lh li lj lk b">catch { … }</code>。</p><p id="d2ab" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">为了捕捉所有的错误情况，我们至少要有子句<code class="eh lh li lj lk b">catch { ...}</code>或子句<code class="eh lh li lj lk b">catch (bytes memory lowLevelData) { ... }</code>。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="ma mb l"/></div></figure></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="63dd" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">接下来，我们将研究<em class="lg">实度函数类型</em> — <code class="eh lh li lj lk b">internal</code>、<code class="eh lh li lj lk b">external</code>、<code class="eh lh li lj lk b">public</code>和<code class="eh lh li lj lk b">private</code>。感谢阅读。</p></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="57bf" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><strong class="km id">参考文献</strong></p><div class="mi mj fm fo mk ml"><a href="https://docs.soliditylang.org/en/v0.8.0/control-structures.html?highlight=require#error-handling-assert-require-revert-and-exceptions" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab ej"><div class="mn ab mo cl cj mp"><h2 class="bd id fv z el mq eo ep mr er et ic dt translated">错误处理:断言、要求、恢复和异常-可靠性0.8.0</h2><div class="ms l"><h3 class="bd b fv z el mq eo ep mr er et ek translated">编辑描述</h3></div><div class="mt l"><p class="bd b gc z el mq eo ep mr er et ek translated">docs.soliditylang.org</p></div></div></div></a></div><div class="mi mj fm fo mk ml"><a rel="noopener follow" target="_blank" href="/coinmonks/solidity-fundamentals-ca824a3ac023"><div class="mm ab ej"><div class="mn ab mo cl cj mp"><h2 class="bd id fv z el mq eo ep mr er et ic dt translated">坚固性基础</h2><div class="ms l"><h3 class="bd b fv z el mq eo ep mr er et ek translated">值类型:第一部分</h3></div><div class="mt l"><p class="bd b gc z el mq eo ep mr er et ek translated">medium.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz kb ml"/></div></div></a></div><div class="mi mj fm fo mk ml"><a href="https://solidity-by-example.org" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab ej"><div class="mn ab mo cl cj mp"><h2 class="bd id fv z el mq eo ep mr er et ic dt translated">以身作则</h2><div class="ms l"><h3 class="bd b fv z el mq eo ep mr er et ek translated">使用Solidity学习智能合约编程</h3></div><div class="mt l"><p class="bd b gc z el mq eo ep mr er et ek translated">solidity-by-example.org</p></div></div></div></a></div></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><h1 id="8d23" class="na nb ht bd nc nd ne nf ng nh ni nj nk ji nl jj nm jl nn jm no jo np jp nq nr dt translated">所有部件正常</h1><ul class=""><li id="633f" class="ll lm ht km b kn ns kq nt kt nu kx nv lb nw lf lq lr ls lt dt translated"><a class="ae lz" href="https://ferdikurt.medium.com/solidity-fundamentals-88ceb4873064" rel="noopener">合同的版式</a></li><li id="6bb5" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated"><a class="ae lz" href="https://ferdikurt.medium.com/solidity-fundamentals-ca824a3ac023" rel="noopener">值类型:第一部分</a></li><li id="d6f5" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated"><a class="ae lz" href="https://ferdikurt.medium.com/solidity-fundamentals-c94460e3be3d" rel="noopener">值类型:第二部分</a></li><li id="505a" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated"><a class="ae lz" rel="noopener" href="/coinmonks/solidity-fundamentals-1fb0e6b3b607">操作员</a></li><li id="623d" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated"><a class="ae lz" rel="noopener" href="/coinmonks/solidity-fundamentals-e4e4660e16c8">参考类型</a></li><li id="fc35" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated"><a class="ae lz" rel="noopener" href="/coinmonks/solidity-fundamentals-a71bf54c0b98">数据位置和赋值行为</a></li><li id="9410" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated"><a class="ae lz" rel="noopener" href="/coinmonks/solidity-fundamentals-1dc2af4b453b">控制结构</a></li><li id="a3fd" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated"><a class="ae lz" rel="noopener" href="/coinmonks/solidity-fundamentals-a95bb6c8ba2a">错误处理:断言、要求、恢复和异常</a></li><li id="7468" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated"><a class="ae lz" rel="noopener" href="/coinmonks/solidity-fundamentals-d2216be1c2c3">功能:第一部分</a></li><li id="783d" class="ll lm ht km b kn lu kq lv kt lw kx lx lb ly lf lq lr ls lt dt translated"><a class="ae lz" href="https://ferdikurt.medium.com/solidity-fundamentals-functions-a7e3d38c1fe5" rel="noopener">功能:第二部分</a></li></ul></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="7494" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">随意问任何问题。</p><p id="0f95" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><strong class="km id">注意安全，做好工作，保持联系！</strong></p><p id="26a3" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><a class="ae lz" href="https://www.linkedin.com/in/ferdi-kurt-8b910b164/" rel="noopener ugc nofollow" target="_blank">费尔迪科特</a></p></div></div>    
</body>
</html>