<html>
<head>
<title>ERC20 token as Hyperledger Fabric Golang chaincode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ERC20令牌作为Hyperledger结构Golang链代码</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/erc20-token-as-hyperledger-fabric-golang-chaincode-d09dfd16a339?source=collection_archive---------0-----------------------#2018-11-11">https://medium.com/coinmonks/erc20-token-as-hyperledger-fabric-golang-chaincode-d09dfd16a339?source=collection_archive---------0-----------------------#2018-11-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/f0e1237809517fceca5f9b6fc80268d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nCteC9185FxNCqGRR1KWXg.png"/></div></div></figure><p id="ffb9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">与以太坊区块链一样，Hyperledger Fabric platform (HLF)可用于令牌创建，实现为智能合约(HLF术语中的链码),保存用户余额。与以太坊不同，HLF链码不能使用用户地址作为持有者密钥，因此我们将使用成员服务提供商(MSP)标识符和用户证书标识符的组合。下面是如何在Hyperledger Fabric平台上使用<a class="ae jz" href="https://github.com/s7techlab/cckit" rel="noopener ugc nofollow" target="_blank"> CCKit </a> chaincode库创建Golang chaincode令牌的简单示例。</p><h1 id="44a3" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">什么是ERC20令牌标准</h1><p id="c405" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">令牌标准是以太坊中令牌智能合约标准化的一种尝试，它描述了以太坊令牌合约必须实现的功能和事件。以太坊区块链上的大多数主要代币都符合ERC20标准。ERC-20有很多好处，包括统一代币钱包，以及交易所只需提供代币合同地址就能列出更多代币的能力。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="lh li l"/></div></figure><h1 id="fbb6" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">ERC20实施基础</h1><p id="9910" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">本质上，以太币合同是一个智能合同，它持有帐户地址及其余额的映射。余额是由合同创建者定义的一个值，它可以是可替换的物理对象，也可以是另一个货币值。这种余额的单位通常称为代币。</p><p id="9c2f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">ERC20功能有:</p><ul class=""><li id="2036" class="lj lk ht jd b je jf ji jj jm ll jq lm ju ln jy lo lp lq lr dt translated"><code class="eh ls lt lu lv b">balanceOf</code>:返回所有者标识符的令牌余额(以太坊的情况下为账户地址)</li><li id="3615" class="lj lk ht jd b je lw ji lx jm ly jq lz ju ma jy lo lp lq lr dt translated"><code class="eh ls lt lu lv b">transfer</code>:向我们选择的所有者标识符转移一笔金额</li><li id="f057" class="lj lk ht jd b je lw ji lx jm ly jq lz ju ma jy lo lp lq lr dt translated"><code class="eh ls lt lu lv b">approve</code>:设置一个指定的所有者标识符可以代表我们消费的代币数量</li><li id="e03d" class="lj lk ht jd b je lw ji lx jm ly jq lz ju ma jy lo lp lq lr dt translated"><code class="eh ls lt lu lv b">allowance</code>:检查一个所有者标识符可以代表我们花费多少钱</li><li id="556e" class="lj lk ht jd b je lw ji lx jm ly jq lz ju ma jy lo lp lq lr dt translated"><code class="eh ls lt lu lv b">transferFrom</code>:指定一个所有者标识符，如果那个所有者标识符允许我们花费一些代币，我们就从那个所有者标识符转账。</li></ul><h1 id="e045" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">Hyperledger结构中的所有者标识符</h1><p id="17e1" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">在Hyperledger结构网络中，所有参与者都有一个为其他参与者所知的身份。默认的<a class="ae jz" href="https://hyperledger-fabric.readthedocs.io/en/release-1.3/msp.html" rel="noopener ugc nofollow" target="_blank">成员服务提供者</a>实现使用X.509证书作为身份，采用传统的公钥基础设施(PKI)分层模型。</p><p id="2abf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用关于提议的创建者和资产所有权的信息，链代码应该能够实现链代码级的访问控制机制，检查参与者是否可以启动更新资产的事务。相应的链码逻辑必须能够存储与资产相关的“所有权”信息，并根据提议对其进行评估。</p><p id="dda3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">作为HLF网络中的唯一所有者标识符(令牌余额持有者),我们可以使用MSP标识符和用户身份标识符的组合。身份标识符—是X.509证书的<code class="eh ls lt lu lv b">Subject</code>和<code class="eh ls lt lu lv b">Issuer</code>部分的串联。这个ID保证在MSP中是唯一的。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="c9b8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">C <a class="ae jz" href="https://github.com/hyperledger/fabric/tree/master/core/chaincode/lib/cid" rel="noopener ugc nofollow" target="_blank">客户端身份链代码库</a>允许编写基于客户端身份(即链代码的调用方)做出访问控制决定的链代码。</p><p id="4770" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">特别是，您可以根据与客户端相关的以下一项或两项做出访问控制决策:</p><ul class=""><li id="cf1c" class="lj lk ht jd b je jf ji jj jm ll jq lm ju ln jy lo lp lq lr dt translated">客户端身份的MSP(成员资格服务提供商)ID</li><li id="3587" class="lj lk ht jd b je lw ji lx jm ly jq lz ju ma jy lo lp lq lr dt translated">与客户端身份相关联的属性</li></ul><p id="b3ed" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">CCkit包含<a class="ae jz" href="https://github.com/s7techlab/cckit/tree/master/identity" rel="noopener ugc nofollow" target="_blank"> identity </a>包，其结构和功能可用于在链码中实现访问控制。</p><h1 id="218f" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">示例入门</h1><p id="3fba" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">在我们的示例中，我们使用CCKit路由器来管理智能合同功能。在你开始之前，一定要拿到<code class="eh ls lt lu lv b">CCkit</code>:</p><p id="7d43" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh ls lt lu lv b">git clone git@github.com:s7techlab/cckit.git</code></p><p id="d3b0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">并使用<code class="eh ls lt lu lv b">dep</code>命令获得依赖关系:</p><p id="cd18" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh ls lt lu lv b">dep ensure -vendor-only</code></p><p id="8faa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">ERC20示例位于<a class="ae jz" href="https://github.com/s7techlab/cckit/tree/master/examples/erc20" rel="noopener ugc nofollow" target="_blank"> examples/erc20 </a>目录下。</p><h1 id="544b" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">定义令牌智能合约功能</h1><p id="72df" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">首先，我们需要定义链码函数。在我们的例子中，我们使用来自<a class="ae jz" href="https://github.com/s7techlab/cckit/" rel="noopener ugc nofollow" target="_blank"> CCKit </a>的<a class="ae jz" href="https://github.com/s7techlab/cckit/tree/master/router" rel="noopener ugc nofollow" target="_blank"> router </a>包，它允许我们以一致的方式定义链码方法及其参数。关于链码方法路由、中间件、链码调用上下文的细节在之前的文章中有所描述。</p><p id="93be" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，我们用参数<code class="eh ls lt lu lv b">symbol</code>、<code class="eh ls lt lu lv b">name</code>和<code class="eh ls lt lu lv b">totalSupply</code>定义<code class="eh ls lt lu lv b">init</code>函数(智能契约构造函数)。之后，我们定义了链码方法，实现了ERC20接口，用于HLF所有者标识符(MSP Id和证书Id对)。从链码状态查询的方法以<code class="eh ls lt lu lv b">query</code>为前缀，写入链码状态的方法以<code class="eh ls lt lu lv b">invoke</code>为前缀。</p><p id="55a8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，我们使用<a class="ae jz" href="https://github.com/s7techlab/cckit/blob/master/router/chaincode.go" rel="noopener ugc nofollow" target="_blank">默认链码</a>结构，将<code class="eh ls lt lu lv b">Init</code>和<code class="eh ls lt lu lv b">Invoke</code>处理委托给路由器。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="lh li l"/></div></figure><h1 id="4681" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">链码初始化(构造函数)</h1><p id="145c" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">Chaincode <code class="eh ls lt lu lv b">init</code>函数(令牌构造函数)执行以下操作:</p><ul class=""><li id="8009" class="lj lk ht jd b je jf ji jj jm ll jq lm ju ln jy lo lp lq lr dt translated">使用来自<a class="ae jz" href="https://github.com/s7techlab/cckit/" rel="noopener ugc nofollow" target="_blank"> CCKit </a>的<a class="ae jz" href="https://github.com/s7techlab/cckit/tree/master/extensions/owner" rel="noopener ugc nofollow" target="_blank">所有者</a>扩展，将关于链码所有者的状态信息放入链码</li><li id="9a6f" class="lj lk ht jd b je lw ji lx jm ly jq lz ju ma jy lo lp lq lr dt translated">将链码状态令牌配置-令牌符号、名称和总供应量</li><li id="9752" class="lj lk ht jd b je lw ji lx jm ly jq lz ju ma jy lo lp lq lr dt translated">设置总供应的链码所有者余额</li></ul><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="lh li l"/></div></figure><h1 id="91ef" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">定义事件结构类型</h1><p id="1317" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">我们使用<a class="ae jz" href="https://github.com/s7techlab/cckit/tree/master/identity" rel="noopener ugc nofollow" target="_blank">标识</a>包中的<a class="ae jz" href="https://github.com/s7techlab/cckit/blob/master/identity/entry.go" rel="noopener ugc nofollow" target="_blank"> Id </a>结构，为<code class="eh ls lt lu lv b">Transfer</code>和<code class="eh ls lt lu lv b">Approve</code>事件定义结构:</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="lh li l"/></div></figure><h1 id="3c21" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">实现令牌智能合约功能</h1><p id="c654" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">查询函数非常简单——它只是从链码状态中读取值:</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="9702" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一些变化的状态函数更复杂。例如，在函数<code class="eh ls lt lu lv b">invokeTransfer</code>中，我们:</p><ul class=""><li id="09f2" class="lj lk ht jd b je jf ji jj jm ll jq lm ju ln jy lo lp lq lr dt translated">接收函数调用方证书(通过tx <code class="eh ls lt lu lv b">GetCreator()</code>函数)</li><li id="a1c9" class="lj lk ht jd b je lw ji lx jm ly jq lz ju ma jy lo lp lq lr dt translated">检查转移目的地</li><li id="0625" class="lj lk ht jd b je lw ji lx jm ly jq lz ju ma jy lo lp lq lr dt translated">获取当前发票人(付款人)余额</li><li id="9e99" class="lj lk ht jd b je lw ji lx jm ly jq lz ju ma jy lo lp lq lr dt translated">检查余额以转移代币<code class="eh ls lt lu lv b">amount</code></li><li id="276b" class="lj lk ht jd b je lw ji lx jm ly jq lz ju ma jy lo lp lq lr dt translated">获取收款人余额</li><li id="7834" class="lj lk ht jd b je lw ji lx jm ly jq lz ju ma jy lo lp lq lr dt translated">在链码状态下更新付款人和收款人余额</li></ul><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="lh li l"/></div></figure><h1 id="1455" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">测试</h1><p id="ef3e" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">此外，我们可以通过<a class="ae jz" href="https://github.com/s7techlab/cckit/tree/master/testing" rel="noopener ugc nofollow" target="_blank"> CCKit MockStub快速测试我们的链代码。</a></p><p id="f66d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了开始测试，我们通过带有测试参数的MockStub初始化链代码:</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="15e7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我们可以检查所有令牌操作之后:</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="lh li l"/></div></figure><p id="dbd0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">完整示例可在此处找到<a class="ae jz" href="https://github.com/s7techlab/cckit/tree/master/examples/erc20" rel="noopener ugc nofollow" target="_blank">https://github . com/s7techlab/cc kit/tree/master/examples/ERC 20</a></p><p id="f735" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关于链码单元测试和测试驱动开发的更多信息，你可以在这里阅读:</p><blockquote class="mb mc md"><p id="17cc" class="jb jc me jd b je jf jg jh ji jj jk jl mf jn jo jp mg jr js jt mh jv jw jx jy hm dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/test-driven-hyperledger-fabric-golang-chaincode-development-dbec4cb78049">https://medium . com/coin monks/test-driven-hyperledger-fabric-golang-chain code-development-dbec 4c b 78049</a></p></blockquote><p id="d08d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Chaincode状态模式可以通过protobuf代码生成来实现，它允许定义一次数据模型，然后轻松地从各种数据源写入和读取结构化数据。</p><blockquote class="mb mc md"><p id="70c2" class="jb jc me jd b je jf jg jh ji jj jk jl mf jn jo jp mg jr js jt mh jv jw jx jy hm dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/hyperledger-fabric-smart-contract-data-model-protobuf-to-chaincode-state-mapping-191cdcfa0b78">https://medium . com/coin monks/hyperledger-fabric-smart-contract-data-model-proto buf-to-chain code-state-mapping-191 CDC fa 0 b 78</a></p></blockquote></div></div>    
</body>
</html>