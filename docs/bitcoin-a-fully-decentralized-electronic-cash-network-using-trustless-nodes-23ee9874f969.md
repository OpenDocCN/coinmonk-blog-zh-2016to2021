# 比特币:对 Satoshi 原始论文的评论

> 原文：<https://medium.com/coinmonks/bitcoin-a-fully-decentralized-electronic-cash-network-using-trustless-nodes-23ee9874f969?source=collection_archive---------6----------------------->

我总是发现阅读和重述基础论文中的主要观点很有价值。本帖涵盖[原比特币论文](https://bitcoin.org/bitcoin.pdf)。(想要更深入了解的读者:我强烈推荐阅读[默克尔关于公钥加密系统协议的原始论文](http://www.merkle.com/papers/Protocols.pdf)，以及[亚当·布莱克的 hashcash](http://www.hashcash.org/papers/hashcash.pdf) 以获得工作细节的证明。)

## 介绍

在最近的过去，货币传统上是由一个中央机构发行的。这有助于确保钱是有效的，也是钱没有双重花费。当有人进行一些现金交易时，钱会转手，并且不能被分发现金的人重复花费。在网络世界中，这一负担由一个中央机构分担，比如银行，它确保用户只能消费一次给定的金额。如果我有 10 美元可以花，那么我只能花 1 美元。如果您在银行有一个中央数据库，这是一个很容易解决的问题。

但接下来就是一个中央集权的系统，掌握着太多的现金/权力，可以对每一笔交易收取交易费。中介还可以对国外交易收费，可以对交易规模进行限制等。由于某些交易可能需要撤销，因此需要在系统中引入更多的信任——这意味着客户需要向央行披露更多的个人信息。

这就是比特币网络的主要动机——能否存在一个由不可信节点组成的网络，可以帮助进行点对点电子现金交易，而不必依赖于中央权威机构。要解决的主要问题显然是如何避免同一笔钱/硬币的双重花费。在一个网络世界里，一个恶意代理人 M 可以花同样的钱给 A 和 B，只要 A 和 B 彼此都不知道对方和与 M 的交易。

## 硬币

让我们来定义一下这种电子硬币可能是什么样子。假设所有所有者都有公钥和私钥。每枚硬币基本上都是一长串加密签名的散列——姑且称之为事务。每次硬币转移所有权时，前一个所有者(所有者 1)获取列表中的最后一笔交易，下一个所有者(所有者 2)的公钥并用其私钥对其签名，并将其附加到该硬币的交易列表中。

Transaction(new)=***Hash***(所有者 1-私钥，最后一次交易-硬币，所有者 2-公钥)

然后，系统中的其他节点可以通过使用所有者 1 的公钥验证数字签名，来验证硬币是否被转移给了新的所有者。

## 重复花费的问题

Owner2 怎么会知道 Owner1 在这次交易之前没有和 OwnerX 进行同样的交易？在中央集权的系统中，这很容易。所有交易都被记录下来，因此系统可以验证这是否是一次重复消费的尝试。

在一个分散的系统中，了解这一点的唯一方法是了解在这枚硬币的交易之前发生的所有交易。因此，比特币网络中的节点需要宣布每一笔交易(即所有权转移)，并就这些交易发生的顺序达成一致。所以拥有者 2 可以确信它是第一个从拥有者 1 那里收到这枚硬币的人。

# 解决方案的构建模块

避免重复花费的有效方法是拥有一个时间戳服务器。时间戳服务器可以说硬币 1 在某个时间存在，并在另一个时间被转移给另一个所有者。如果每个接受硬币的人都可以获得该数据，那么他们可以返回并确认硬币的当前所有者之前没有在该硬币上花费过。首先，我们可以看看集中式时间戳服务器，然后再看看分散式时间戳服务器。

## 集中式时间戳服务器

让我们首先假设有一个中央服务器可以对某个数据块进行数字标记。这里时间戳的意思是:一个数据块将被分配一个数字时间戳，该时间戳在将来是不可修改和可验证的。一种方法是使用时间戳服务器的密钥创建(数据、时间戳)的散列。随后，任何人都可以验证数据和时间戳。显然，这依赖于集中式时间戳服务器及其完整性。

在集中式时间戳服务器上实施某种完整性的一种方法是让它经常在报纸或一些团体中发布这些散列。这将确保时间戳服务器不能与客户端勾结，在报纸用户没有注意到的情况下修改现有文档的数字时间戳。(显然，这在数字环境中不容易实现)

另一种使修改散列更加困难的方法是创建一个数字时间戳链。因此，即使有人决定更改某个特定的时间戳，他们也需要从那里开始更改整个链。这是一个简单的图表:

![](img/ac5f52c95aba5ad14f375cb76a60d8dd.png)

A simple digital timestamps of transactions linked to reenforce previous timestamps

## 分散时间戳服务器

最后两种方法使我们更接近一种分散的解决方案。

1.  在一个网络节点中，向整个网络宣布事务
2.  每个新的交易都建立在前一个交易的基础上，使得有针对性的修改更加困难
3.  我们还可以通过引入工作证明来增加生成数字时间戳的难度，这种工作证明需要很长时间来生成，只需很少的时间来验证，从而使修改数据块变得更加困难。
4.  功函的一个简单证明是产生一个散列值，其最高有效“w”位设置为零。随着“w”的增加，工作证明的复杂性也会增加。
5.  由于在没有强力的情况下很难反转给定的单向散列，所以生成这种工作证明的唯一方法是获取一个随机数并继续递增它，直到它的散列的最高有效“w”位被设置为零，例如，对于散列值，它将类似于:

> 递增随机数，
> 
> 散列它，
> 
> 检查最高有效 w 位是否为 0。
> 
> 如果是，我们提供了有效的工作证明。否则回到第一步。

比特币区块链的形象大概是这样的:

![](img/00f28879e1e56c89b519cad2a01fdfcb.png)

Bitcoin blockchain with Merkle tree in each block

## 把所有的放在一起

所以我们目前所知道的是:

1.  与硬币转移有关的一系列交易。
2.  然后，我们有一种机制将这些事务组合到一个块中——使用工作证明机制
3.  然后，这些块被链接在一起，形成一个长长的列表——本质上是制作一个分类账。

现在让我们看看网络是如何运行的

1.  事务被公开宣布并被所有节点接收
2.  每个节点从这些事务中创建一个块，并且每个节点找到一个 PoW。这是启动数字时间戳的过程。
3.  然后一个随机节点向网络提出它的块和功率
4.  网络中的节点验证 PoW，然后仅当块中的所有事务都是有效的并且还没有耗尽时才接受块。这就是在块/事务中执行订单的方式。
5.  然后，节点通过使用这个块的散列来创建下一个块。这实质上是宣布接受先前发出的块。

## 解释了双重支出情况

另一个仍然需要解决的问题是，我们如何知道我们不是在使用一个已经用完的硬币。下图解释了这种情况。a 创建了两个交易，然后将同一个硬币 C 转移给 B 和 d。

![](img/302832e596cbc8f29ad98c47cd12041d.png)

Double Spend of Coin C owned by A. First to B and then to C. This coins is getting used in blocks Bx and By again.

按照一般原则，节点将信任较长的链-假设大多数节点由诚实的工作人员控制，诚实的链将增长最长，攻击者将无法控制区块链的大部分。

在这种情况下，没有明确的赢家。两条区块链一样长。因此，防止这种情况的一种方法是，所有者 B 和 D 等待链增长。在添加块后，两者都可以等待超过 x 次确认。假设 x 足够大，那么两条链保持相同的长度就变得非常困难。一个链将变得更长，第二个链(及其孤立块)可能会失效。这里的一个关键点是，从网络的角度来看，这里没有真正的对错交易。这实际上是一个在网络中保持一致的交易顺序的问题。

## 激励运行网络中的节点

保持网络运行有两个主要动机。

1.  每个挖掘者(节点所有者)在创建和建议一个块时，都会包含一个新的事务，该块会包含在最终的长链中。这是该区块的第一笔交易，本质上是启动硬币的创建。
2.  一旦所有的硬币都被铸造出来，交易费将会发挥重要作用。运行网络的节点可以向发送者建议交易费用是多少。硬币的发送者必须同意向运行该节点的实体支付交易费用。因此，平衡 ob 块反映为:输入值=输出值+交易费用

## Merkle 树用于高效的磁盘存储和成员资格

由于比特币的分散性质，每个节点都需要保留所有交易和区块的分类账。如果所有事务都一直存在，那么日志将会非常大。因此，网络使用 Merkle 树结构来安排给定块中的事务。让我们看看 Merkle 树是什么样子，然后我们可以看到它是如何被利用的。这是来自原始论文的 Merkle 树:

![](img/628ac6369ce2b8f980035f9a8891d838.png)

Illustration of a Merkle Tree

可以看出，这里使用叶节点 y1、y2 等表示了 8 个事务 1 至 8。所有中间节点都是其子节点的散列。如果有人决定检查 y5 的成员资格/有效性，那么他们需要的只是来自 H(1，8，Y)-H(5，8，Y)-H(5，5，Y)的所有散列。他们不需要整个树，即从 1 到 8 的所有事务。

这棵树的另一个优点是，对任何节点的修改都需要传播到根节点，并重做所有的散列。所以修改 H(6，6，Y)不是小事。然后，攻击者需要修改 H(5，6，Y)，然后修改 H(5，8，Y)，最后修改根节点。

使用 Merkle 树的这些属性，一旦事务在它之后的多个块中被重新执行，我们就可以删除树的一些分支。最终，大量的分支可以被移除，所有剩下的就是块中的根签名。这大大减少了磁盘的使用。

## 如何确认交易是否有效

比特币分类账被表示为状态机，而不是账户数据库。所以每一个新的事务都把前一个事务的输出作为输入。假设 A 正在使用交易 y8 中给它的硬币。假设 A 想在当前交易中把这个给 B 是 y15。为了验证 y8 的输出在 y15 之前是否没有被花掉，我们需要回过头来遍历 y15 到 y8 并确认有效性。Merkle trees 对会员来说也很方便，我们不必检查中间的每一笔交易。

## 不诚实链存活的概率

在网络中，攻击者最有可能尝试做的是加倍消费，并使用第二次消费来收回之前消费的钱。(偷别人的钱意味着得到他们的私人钥匙。没有工作证明，凭空创造金钱是不可能的。)在这种情况下，攻击者只能通过控制网络的大部分(记住，网络中的随机节点可以添加下一个块)，使不诚实的链成为最长的链。如果多数由诚实节点控制，那么如果不诚实链比诚实链落后“z”个块，这显然转化为指数(z)概率。

## 结论

天才真的在于简单——这篇论文只引用了其他 8 篇论文，考虑到其产生的影响，这令人震惊。我发现如果没有传统的所有者账户价值的观点，很难想象比特币分类账。但是在其他地方解释的状态转换观点使得阅读这篇论文更加容易。另一篇论文，分布式共识形成了一个更大的技术的基础(但在敌对的场景中)。这篇论文也参考了兰波特关于分布式共识的论文(这里也提到了 T2 的论文)。这个想法证明工作土地上的概率解决拜占庭一般的问题也是非常整洁！