<html>
<head>
<title>Simple Directed Acyclic Graph (IOTA-like) implementation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中简单的有向无环图(IOTA-like)实现</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/simple-directed-acyclic-graph-iota-like-implementation-in-python-8e07677c55b5?source=collection_archive---------1-----------------------#2018-11-12">https://medium.com/coinmonks/simple-directed-acyclic-graph-iota-like-implementation-in-python-8e07677c55b5?source=collection_archive---------1-----------------------#2018-11-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="3962" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">对于那些仅仅区块链是不够的。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/e335140c82f4e0bbce8ace9b7c8a41b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSuN1iAS8dKdHftIoq_yoQ.png"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Picture taken from <a class="ae jy" href="https://ukcryptocurrency.com/iota/introduction-what-is-iota/" rel="noopener ugc nofollow" target="_blank">https://ukcryptocurrency.com/iota/introduction-what-is-iota/</a></figcaption></figure><p id="2140" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">大约在一年前的同一时间，我在《密码世界》中有了“信仰的飞跃”。我阅读了数十份白皮书，数千篇Reddit帖子，访问了无数次聚会，直到我发现了IOTA并加入了crypto-rage。作为一个干渣现在有一个知识想和观众分享。受到像<a class="ae jy" href="https://hackernoon.com/learn-blockchains-by-building-one-117428612f46" rel="noopener ugc nofollow" target="_blank"> this </a>或<a class="ae jy" rel="noopener" href="/crypto-currently/lets-build-the-tiniest-blockchain-e70965a248b"> this </a>这样的区块链教程的可访问性和易用性的启发，以及缺乏类似的有向无环图(DAG)教程的情况，我想也做点贡献。这里有一个类似IOTA的分布式账本技术的简单实现Tangle！要点页与完整的代码可以找到<a class="ae jy" href="https://gist.github.com/stkubr/0469ab30b1f992e2817f6060e4bf576f" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="b31f" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">让我们从添加我们将需要的库开始:</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="81ff" class="la lb ht kw b fv lc ld l le lf">import hashlib<br/>import random<br/>import string<br/>import time<br/>from collections import OrderedDict</span></pre><p id="03bd" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">然后我们将Tangle表示为三个独立的字典:</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="d088" class="la lb ht kw b fv lc ld l le lf">tangle_graph = {'genesis_branch': [],<br/>                'genesis_trunk': []}<br/><br/>tangle_data = {}<br/><br/>tangle_ledger = {'iota_satoshi': 100}</span></pre><p id="9bbb" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><code class="eh lg lh li kw b">tangle_graph</code>将表示图形数据结构——每个字典键是一个事务，每个值是键引用的另外两个事务的列表，即所谓的:分支和主干。我们开始与一些创世纪的树枝和树干纠缠在一起。<code class="eh lg lh li kw b">tangle_data</code>包含事务到数据有效负载的映射，而<code class="eh lg lh li kw b">tangle_ledger</code>是公钥到值的映射。在实际的IOTA实现中，这些数据结构不是分离的，而是混乱的，但是为了教程的可见性，我们让它保持原样。</p><p id="00e5" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这里为了简单起见，我们将不使用任何非对称加密，如RSA或量子抗Winternitz签名，只需记住<code class="eh lg lh li kw b">'iota_satoshi'</code>是一个公钥或一个<strong class="kb hu">地址</strong>，任何拥有相应私钥的人都可以从这个地址使用。</p><p id="8b4f" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">然后我们需要一个散列函数，让我们以简单的SHA1为例:</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="17c1" class="la lb ht kw b fv lc ld l le lf">def calc_hash(msg):<br/>    hasher = hashlib.sha1(msg.encode())<br/>    return hasher.hexdigest()</span></pre><p id="94d4" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">现在我们引入一个基本块——Block类(双关语):</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="52fd" class="la lb ht kw b fv lc ld l le lf">class Block:<br/>    def __init__(self, branch, trunk):<br/>        self.branch = branch<br/>        self.trunk = trunk<br/>        self.timestamp = time.time()<br/>        self.data_payload = get_random_string()<br/>        self.value_tx = None<br/><br/>    def get_hash(self):<br/>        return calc_hash(str(OrderedDict(self.__dict__)))</span></pre><p id="1e66" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">块包含分支和主干分支、时间戳和一些数据。这里<code class="eh lg lh li kw b">get_random_string()</code>只是为block的<code class="eh lg lh li kw b">data_payload</code>提供随机字符串。</p><p id="6046" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">此外，我们定义了向Tangle添加块的函数:</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="9d28" class="la lb ht kw b fv lc ld l le lf">def add_tx(block: Block):<br/>  if block.branch in tangle_graph and block.trunk in tangle_graph:<br/>      tangle_graph[block.get_hash()]=[block.branch,block.trunk]<br/>      tangle_data[block.get_hash()] = block.data_payload</span></pre><p id="7cb2" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">基本上，该函数检查分类帐中是否存在block的分支和主干分支，如果存在，则向Tangle添加新交易。</p><p id="8b9d" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">现在，我们需要某种算法来从现有的混乱事务中选择事务，作为新事务的分支和主干:</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="8a5d" class="la lb ht kw b fv lc ld l le lf">def find_tips():<br/>    return tuple(random.sample(set(tangle_graph.keys()), 2))</span></pre><p id="c8f5" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这是最简单的均匀随机tips选择算法——它只是从所有事务中选择两个不同的随机事务。事实上，事情要复杂得多。</p><p id="4e84" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这就是了！有了一个类和三个函数，我们就可以运行Tangle了—让我们运行<code class="eh lg lh li kw b">add_tx(Block(*find_tips()))</code>:</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="7ea3" class="la lb ht kw b fv lc ld l le lf">tangle_graph<br/>Out[24]: <br/>{'e0d5787db72c7a0bea6d9621f73bd4b21f47546f': <br/>['genesis_trunk','genesis_branch'],<br/> 'genesis_branch': [],<br/> 'genesis_trunk': []}</span></pre><p id="5369" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">我们刚刚添加了引用‘genesis _ trunk’和‘genesis _ branch’的事务<code class="eh lg lh li kw b">‘e0d5787db72c7a0bea6d9621f73bd4b21f47546f’</code>。让我们通过多跑几次<code class="eh lg lh li kw b">add_tx(Block(*find_tips()))</code>来增加更多！</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="2ae7" class="la lb ht kw b fv lc ld l le lf">{'2b503d9c90eec329b96b89cde4dc54efa826b0df': <br/>['genesis_trunk','580e464bd9cef52e4af07508171ce84369b258d5'],</span><span id="5444" class="la lb ht kw b fv lj ld l le lf"> '37379d02f49e9dc57a6e08ff33e218a12c39f9de': <br/>['genesis_branch','e0d5787db72c7a0bea6d9621f73bd4b21f47546f'],</span><span id="0df8" class="la lb ht kw b fv lj ld l le lf"> '580e464bd9cef52e4af07508171ce84369b258d5':['37379d02f49e9dc57a6e08ff33e218a12c39f9de','genesis_trunk'],</span><span id="2250" class="la lb ht kw b fv lj ld l le lf"> 'e0d5787db72c7a0bea6d9621f73bd4b21f47546f':<br/> ['genesis_trunk','genesis_branch'],</span><span id="aba6" class="la lb ht kw b fv lj ld l le lf"> 'genesis_branch': [],<br/> 'genesis_trunk': []}</span></pre><p id="fdac" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">如您所见，Tangle在增长，新事务开始随机引用旧事务。至于<code class="eh lg lh li kw b">tangle_data</code>看起来是这样的:</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="3d5c" class="la lb ht kw b fv lc ld l le lf">{'2b503d9c90eec329b96b89cde4dc54efa826b0df': 'yxgcs',<br/> '37379d02f49e9dc57a6e08ff33e218a12c39f9de': '1lyf8',<br/> '580e464bd9cef52e4af07508171ce84369b258d5': '1y4vu',<br/> 'e0d5787db72c7a0bea6d9621f73bd4b21f47546f': 'nct8w'}</span></pre><p id="10e4" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">只是一些随机数据。</p><p id="e7c2" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">现在我们要转移一些资金，但是为了这样做，我们需要给我们的<code class="eh lg lh li kw b">Block</code>类添加额外的函数:</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="0930" class="la lb ht kw b fv lc ld l le lf">def add_value_tx(self, sender, receiver, amount, signature):<br/>        self.value_tx = {'sender': sender,<br/>                         'receiver': receiver,<br/>                         'amount': amount,<br/>                         'signature': signature<br/>                         }</span></pre><p id="cba5" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这将为块对象添加<strong class="kb hu">非零事务</strong>状态:</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="3791" class="la lb ht kw b fv lc ld l le lf"># prepare block usual way<br/>value_block = Block(*find_tips())</span><span id="c6ae" class="la lb ht kw b fv lj ld l le lf"># add value transition in block<br/>value_block.add_value_tx('iota_satoshi', 'iota_foundation_address', 50, 'calligraphic_signature_of_satoshi_himself')</span></pre><p id="e900" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">显然<code class="eh lg lh li kw b">calligraphic_signature_of_satoshi_himself</code>是公钥/地址<code class="eh lg lh li kw b">iota_satoshi</code>的加密签名。现在我们需要为值事务处理一个逻辑，它将修改<code class="eh lg lh li kw b">tangle_ledger</code>:</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="01f5" class="la lb ht kw b fv lc ld l le lf">def check_value_tx(value_tx):<br/>    if value_tx['sender'] in tangle_ledger:<br/>      if value_tx['amount'] &lt;=  tangle_ledger[value_tx['sender']]:<br/>            # if signature is valid too<br/>            res = True<br/>    return res</span><span id="c48d" class="la lb ht kw b fv lj ld l le lf">def move_money(sender, receiver, amount):<br/>    tangle_ledger[sender] -= amount<br/>    if receiver in tangle_ledger:<br/>        tangle_ledger[receiver] += amount<br/>    else:<br/>        tangle_ledger[receiver] = amount</span></pre><p id="a688" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">首先检查<code class="eh lg lh li kw b">sender</code>地址是否存在，是否有足够的钱花。第二个将资金从<code class="eh lg lh li kw b">sender</code>移动到<code class="eh lg lh li kw b">receiver</code>，如果分类帐上不存在，则添加后者。(人们仍然可以发送负金额并把某人扔进dept😱)</p><p id="db9a" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">有待修改的所有内容<code class="eh lg lh li kw b">add_tx()</code>:</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="749d" class="la lb ht kw b fv lc ld l le lf">def add_tx(block: Block):<br/>    if block.branch in tangle_graph <br/>       and block.trunk in tangle_graph:<br/>        if block.value_tx:<br/>            if check_value_tx(block.value_tx):<br/>                move_money(block.value_tx['sender'],<br/>                           block.value_tx['receiver'],<br/>                           block.value_tx['amount'])<br/>                tangle_graph[block.get_hash()] = [block.branch,   <br/>                                                  block.trunk]<br/>                tangle_data[block.get_hash()] = block.data_payload<br/>        else:<br/>            tangle_graph[block.get_hash()] = [block.branch, <br/>                                              block.trunk]<br/>            tangle_data[block.get_hash()] = block.data_payload</span></pre><p id="9ca2" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">现在，我们可以添加一个带有值事务的块<code class="eh lg lh li kw b">add_tx(value_block)</code>,这种纠结将看起来像:</p><pre class="jj jk jl jm fq kv kw kx ky aw kz dt"><span id="5c40" class="la lb ht kw b fv lc ld l le lf">tangle_graph<br/>{'2b503d9c90eec329b96b89cde4dc54efa826b0df': <br/>['genesis_trunk','580e464bd9cef52e4af07508171ce84369b258d5'],</span><span id="97ee" class="la lb ht kw b fv lj ld l le lf">'37379d02f49e9dc57a6e08ff33e218a12c39f9de': <br/>['genesis_branch','e0d5787db72c7a0bea6d9621f73bd4b21f47546f'],</span><span id="2701" class="la lb ht kw b fv lj ld l le lf">'580e464bd9cef52e4af07508171ce84369b258d5':['37379d02f49e9dc57a6e08ff33e218a12c39f9de','genesis_trunk'],</span><span id="f8ab" class="la lb ht kw b fv lj ld l le lf">'c33f585243abac2f59494eb092a600d3fe97423a': ['genesis_branch',<br/>  '580e464bd9cef52e4af07508171ce84369b258d5'],</span><span id="dbba" class="la lb ht kw b fv lj ld l le lf">'e0d5787db72c7a0bea6d9621f73bd4b21f47546f':<br/> ['genesis_trunk','genesis_branch'],</span><span id="082b" class="la lb ht kw b fv lj ld l le lf">'genesis_branch': [],<br/> 'genesis_trunk': []}<br/></span><span id="2d5b" class="la lb ht kw b fv lj ld l le lf">tangle_ledger<br/>{'iota_foundation_address': 50, 'iota_satoshi': 50}<br/></span><span id="926a" class="la lb ht kw b fv lj ld l le lf">tangle_data<br/>{'2b503d9c90eec329b96b89cde4dc54efa826b0df': 'yxgcs',<br/> '37379d02f49e9dc57a6e08ff33e218a12c39f9de': '1lyf8',<br/> '580e464bd9cef52e4af07508171ce84369b258d5': '1y4vu',<br/> 'e0d5787db72c7a0bea6d9621f73bd4b21f47546f': 'nct8w',<br/> 'c33f585243abac2f59494eb092a600d3fe97423a': <br/>  {'data_payload': 'ps697',<br/>   'value_payload': <br/>    {('sender', 'iota_satoshi'),<br/>     ('receiver', 'iota_foundation_address'),<br/>     ('amount', 50),<br/>     ('signature', 'calligraphic_signature_of_satoshi_himself')}<br/>}</span></pre><p id="4fe7" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这是最简单的DAG实现，当然它缺乏一致性、密钥加密、验证和网络拓扑，但是它应该给读者一个IOTA如何工作的直观理解。</p><p id="aaea" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">完整代码的要点页面可以在<a class="ae jy" href="https://gist.github.com/stkubr/0469ab30b1f992e2817f6060e4bf576f" rel="noopener ugc nofollow" target="_blank">这里</a>找到。你可以通过IOTA Discord的stkubr#1936 或Twitter <a class="ae jy" href="https://twitter.com/KubrakStan" rel="noopener ugc nofollow" target="_blank"> @KubrakStan </a>联系我。如果你喜欢我的工作，并希望我继续将本教程扩展到第二部分，添加节点共识，Flask网络服务器等。请随意捐赠一些Iotas，地址:</p><p id="d6a3" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">ehnqjbgfaiutjkpmsucsdmih 9 xthanmjbvezlfyuruxjuartgkg 9 kdbhtczhdkzzogt 9 engemhposlhpwxaelupsdx</p><p id="5942" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">感谢您的关注:)</p><blockquote class="lk"><p id="c877" class="ll lm ht bd ln lo lp lq lr ls lt ku ek translated"><a class="ae jy" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="lv lw lx ly lz jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lu"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>