<html>
<head>
<title>A Brief Overview of Kademlia, and its use in various decentralized platforms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kademlia的简要概述，及其在各种分散平台中的使用</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-brief-overview-of-kademlia-and-its-use-in-various-decentralized-platforms-da08a7f72b8f?source=collection_archive---------0-----------------------#2019-02-15">https://medium.com/coinmonks/a-brief-overview-of-kademlia-and-its-use-in-various-decentralized-platforms-da08a7f72b8f?source=collection_archive---------0-----------------------#2019-02-15</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="3cc8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Kademlia是一个分布式哈希表，在许多现代分散协议中实现，包括Storj V3网络、以太坊、BitTorrent、Swarm和IPFS。</p><p id="0de4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Kademlia为数百万台计算机提供了一种自组织成网络、与网络上的其他计算机通信以及在计算机之间共享资源(例如文件、blobs、对象)的方式，所有这些都不需要由个人或公司运行的中央注册表或查找。</p><p id="249f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Kademlia由Petar Maymounkov和David Mazières于2002年构思，通常被认为是推动了第三代扁平层次计算协议的采用，因为它比集中式和基于泛洪的节点发现和路由方法更加可靠和高效。</p><p id="a7b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Kademlia的分布式特性意味着不存在NodeIDs映射到其地址的绝对事实(即，路由表是<em class="jp">分布式的</em>，因此每个节点必须在自己的路由表中为网络上的节点子集保留这种映射。</p><p id="d3e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">基于Kademlia的网络对拒绝服务攻击和一组节点的丢失具有很强的抵抗力，因为协议只是简单地绕过不可用的节点。</p><p id="9583" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这使得分布式系统能够抵御攻击、停机和<a class="ae jo" href="https://storj.io/blog/2018/11/the-benefits-of-decentralization-go-far-beyond-ideology/" rel="noopener ugc nofollow" target="_blank">中心故障点</a>。</p><p id="0d90" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Kademlia的重大突破是通过使用XOR度量(将在下一节中描述)来定义密钥空间中各点之间的距离，从而最大限度地减少节点间的消息传递。</p><p id="cc2a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，如果距离被表示为log2(n)个节点，这意味着对于具有10，000，000个Kademlia节点的网络，对于与任何节点子集的通信，最多只需要大约20跳。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/93fa8f85c649bfda2b40c7c11a6b23f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VjRS6-nCY-QyCi5HmLfFaw.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">“<a class="ae jo" href="https://metaquestions.me/2014/08/01/shortest-distance-between-two-points-is-not-always-a-straight-line/" rel="noopener ugc nofollow" target="_blank"><em class="kg">The shortest distance between two points is not always a straight line.</em></a>“ Image Source: (<a class="ae jo" href="https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf" rel="noopener ugc nofollow" target="_blank"><em class="kg">Maymounkov, </em>et al.</a>)</figcaption></figure><p id="bf55" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Kademlia的另一个优势是，该协议自然更喜欢长寿命的节点，而不是新加入的节点。下图(摘自Kademlia的论文)说明了一个事实，即一个节点存在的时间越长，它在未来保持在线的可能性就越大。</p><p id="38fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这种对节点“活跃性”的偏好很自然地融入到我们的分布式存储系统中，在这种系统中，节点流失会导致一种情况，即<a class="ae jo" href="https://storj.io/blog/2019/01/why-proof-of--replication-is-bad-for-decentralized-storage-part-2-churn-and-burn/" rel="noopener ugc nofollow" target="_blank">修复成本必须最小化</a>。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff kh"><img src="../Images/8ba67e701fef1e1084fac8301f39bde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7teP36eX0zguNt8cdxahfQ.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Source: (<a class="ae jo" href="https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf" rel="noopener ugc nofollow" target="_blank"><em class="kg">Maymounkov, </em>et al.</a>)</figcaption></figure><p id="34c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">加入Kademlia网络的过程只需要发现一个对等点，然后节点广播它的出现。然后，发起者从每个响应中收集NodeID，并将其添加到自己的对等表中。(这就是术语“分布式哈希表”的来源。)</p><p id="7d21" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这导致了第三个优点，Kademlia使用并行和异步查询防止了超时延迟或从已经脱离或离开网络的故障节点的“恢复阻塞”。</p></div><div class="ab cl ki kj hb kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hm hn ho hp hq"><p id="2e51" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，我将快速浏览一下Kademlia网络的基本组件:</p><h2 id="b6bb" class="kp kq ht bd kr ks kt ku kv kw kx ky kz jb la lb lc jf ld le lf jj lg lh li lj dt translated">卡德姆利亚NodeIDs</h2><p id="6ac3" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">Kademlia将网络上的每个节点视为二叉树上的一片叶子。通常，每个Kademlia节点都有一个160位的NodeID (SHA-1 ),其位置由其ID的最短唯一前缀决定。</p><p id="519f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了将键值对分配给特定的节点，Kademlia依赖于两个标识符之间的距离概念。给定两个160位标识符x和y，Kademlia将它们之间的距离定义为XOR。</p><p id="a045" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从节点的角度来看，树被分成一系列连续的子树，其中第160个子树包含单个节点。Kademlia协议确保每个节点至少知道其每个子树上的一个节点。有了这种保证，一个节点可以通过它的ID定位任何其他节点。</p><h2 id="0ba6" class="kp kq ht bd kr ks kt ku kv kw kx ky kz jb la lb lc jf ld le lf jj lg lh li lj dt translated">路由表和K桶</h2><p id="e4f0" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">路由表是一棵二叉树，它的叶子是k桶。Kademlia路由表的结构是这样的，即节点维护离它们最近的地址空间的详细信息，并以指数方式减少对更远的地址空间的了解。</p><p id="9734" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对称性是有用的，因为这意味着这些最接近的联系人中的每一个都将维护地址空间的相似部分的详细信息，而不是远程部分。</p><p id="49da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> K桶</strong>是网络中其他节点的路由地址列表，由每个节点维护，包含系统中对等参与者的IP地址、端口和NodeID。他们更喜欢寿命最长的节点，这意味着人们不能通过用新节点淹没系统来超越节点的路由状态(从而防止某些类型的DDOS攻击)。</p><p id="5451" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">路由表大小由<code class="eh lp lq lr ls b">O(log₂(n/k))</code>渐近限定，其中<em class="jp"> n </em>是网络中节点的实际数量，而<em class="jp"> k </em>是存储桶大小，因此较大的存储桶实现稍微减少了路由表中存储桶的总数。</p><h2 id="8922" class="kp kq ht bd kr ks kt ku kv kw kx ky kz jb la lb lc jf ld le lf jj lg lh li lj dt translated">对等消息传递</h2><p id="1698" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">像Kademlia这样的分散式协议要求对等体使用相同的语言，这样它们就可以找到彼此，识别彼此的位置，并交换消息。</p><p id="c084" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Kademlia协议由四个远程过程调用(RPC)组成:</p><ol class=""><li id="4958" class="lt lu ht is b it iu ix iy jb lv jf lw jj lx jn ly lz ma mb dt translated"><strong class="is hu"> PING: </strong>探测一个节点，看它是否在线</li><li id="ef63" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn ly lz ma mb dt translated"><strong class="is hu">存储:</strong>指示节点存储一个键值对</li><li id="c2ec" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn ly lz ma mb dt translated"><strong class="is hu"> FIND_NODE: </strong>返回与目标id最近的k个<em class="jp">节点的信息</em></li><li id="d659" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn ly lz ma mb dt translated"><strong class="is hu"> FIND_VALUE: </strong>类似于FIND_NODE RPC，但是如果接收方已经接收到给定键的存储，它就返回存储的值</li></ol><h1 id="f0a1" class="mh kq ht bd kr mi mj mk kv ml mm mn kz mo mp mq lc mr ms mt lf mu mv mw li mx dt translated"><strong class="ak">Storj的Kademlia(</strong>白皮书章节<strong class="ak"> 3.3和4.6) </strong></h1><p id="1ba6" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">Storj V3网络是备受期待的Storj分布式和分散式对象存储平台的下一个版本。</p><p id="1dda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">新的网络使用Kademlia的修改版本作为类似DNS的功能的主要来源，用于<em class="jp">节点查找</em>，即使网络不需要Kademlia的键/值存储方面。</p><p id="de9a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在构建之前的Storj网络时，我们非常关注Kademlia的实现，甚至围绕协议构建了一个<a class="ae jo" href="https://storj.io/blog/2016/09/introducing-kfs-a-local-file-store-inspired-by-kademlia/" rel="noopener ugc nofollow" target="_blank">文件系统概念。我们很快意识到在分布式存储网络中使用修改的k-bucket的一些性能限制，并在Storj V3中解决了这些问题。</a></p><p id="becf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">将Kademlia单独用于节点查找，可以消除Kademlia原本需要的一些其他功能，例如基于所有者的密钥重新发布、基于邻居的密钥重新发布、值的存储和检索等等。</p><p id="8140" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">此外，为了保证节点通信的安全性并提供完全的隐私性，每个对等体必须以只有目标参与者才能理解的加密语言相互通信(以避免窃听者和中间人攻击)。</p><p id="3cad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">出于这个原因，我们已经实现了大量的<a class="ae jo" href="https://ieeexplore.ieee.org/document/4447808" rel="noopener ugc nofollow" target="_blank"> S/Kademlia扩展</a>，以在适当的时候启用安全的基于密钥的路由协议。</p><p id="2b42" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">S/Kademlia还提供了针对分布式系统的某些攻击的基本防护层，特别是:</p><ol class=""><li id="2691" class="lt lu ht is b it iu ix iy jb lv jf lw jj lx jn ly lz ma mb dt translated"><strong class="is hu"> Sybil攻击</strong> —用户生成大量任意身份(NodeIDs)来淹没网络。</li><li id="f163" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn ly lz ma mb dt translated"><strong class="is hu"> Eclipse攻击</strong> <em class="jp"> — </em>攻击者试图通过确保所有出站连接都到达恶意节点来隔离网络图中的一个节点或一组节点。</li></ol><p id="f80b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">S/Kademlia扩展通过为节点生成创建最小工作阈值来防止地址空间上的sybil攻击。存储NodeID的生成不需要在比特币(以及类似的共识协议)中实现工作证明，而是需要在0的<em class="jp">位之后添加</em>位。这允许我们继续使用Kademlia XOR路由。</p><p id="5b97" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这减慢了添加新节点的过程，并且需要计算生成NodeID的开销，但是该工作的结果被合并到NodeID中。这允许我们继续使用XOR路由，而不需要增加额外的步骤来验证NodeID已经完成了工作。</p><p id="dff6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在定义V3网络规范的过程中，我们与Kademlia作者<strong class="is hu"> Petar Maymounkov </strong>进行了密切的磋商，他也被列为<a class="ae jo" href="https://storj.io/white-paper" rel="noopener ugc nofollow" target="_blank"> V3白皮书</a>的撰稿人(特别是他围绕<a class="ae jo" href="https://storj.io/storjv3.pdf#page=35" rel="noopener ugc nofollow" target="_blank">第4.6.1节</a>所做的工作)</p><p id="8f69" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Storj通过使用公钥散列作为NodeIDs、基于这些公钥的签名、节点审查过程以及S/Kademlia和Maymounkov的贡献所规定的多重分离网络查找来保护自己免受eclipse攻击。</p><h2 id="3c0d" class="kp kq ht bd kr ks kt ku kv kw kx ky kz jb la lb lc jf ld le lf jj lg lh li lj dt translated">在Storj V3中克服Kademlia的限制</h2><p id="f79d" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">为了设计一个全局可伸缩、高性能的分布式对象存储层，我们必须考虑一些限制。</p><p id="52dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，像Kademlia这样的DHT需要多次网络往返才能完成许多操作，这使得它很难实现毫秒级的响应时间。</p><p id="4cd6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Storj卫星上的覆盖缓存会跟踪最新的在线节点。如果在<strong class="is hu">覆盖缓存</strong>中没有找到它们，那么我们标记节点必须离线，因此擦除份额消失，从而进入<a class="ae jo" href="https://storj.io/blog/2018/12/decentralized-auditing-and-repair-the-low-key-life-of-data-resurrection/" rel="noopener ugc nofollow" target="_blank">数据修复过程</a>。</p><p id="efb7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有趣的是，存储节点本身与DHT缓存层是分离的，也就是说，它们可以在不与卫星联系的情况下进行通信和组织。然而，为了使客户端上传/下载发生，它们需要协调代理(卫星)介入并与它们通信。</p><p id="5629" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当每个Kademlia FIND_NODE RPC在覆盖层上共享时，消息包括存储节点的可用磁盘空间、每个卫星的可用带宽以及网络需要的任何其他元数据。节点发现缓存将收集这些由节点提供的信息，从而优化查找速度。</p><p id="b914" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，参与的存储节点对卫星执行广泛的审查过程，以确保它所通告的资源的可用性。该过程为存储节点设置<a class="ae jo" href="https://storj.io/blog/2019/01/reputation-matters-when-it-comes-to-storage-nodes/" rel="noopener ugc nofollow" target="_blank">基准信誉，并将</a><a class="ae jo" href="https://storj.io/blog/2019/01/sharing-storage-space-for-fun-and-profit/" rel="noopener ugc nofollow" target="_blank">收益潜力</a>考虑在内。</p><p id="d9ef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，进入路由表的节点被认为被网络“审查”,并且查找仅通过审查的节点进行。</p><p id="4a14" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这确保了只有具有经验证的磁盘空间的节点才能够进入和参与路由层，同时还增加了对网络容量的了解，并且还防止了攻击。</p><h1 id="74b1" class="mh kq ht bd kr mi mj mk kv ml mm mn kz mo mp mq lc mr ms mt lf mu mv mw li mx dt translated">以太坊协议中的Kademlia用法</h1><p id="4250" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">以太坊的区块链网络堆栈中的节点发现协议是基于Kademlia的一个略微修改的实现。</p><p id="09d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以太坊利用Kademlia的XOR度量和k-bucket结构，与Storj类似，lookup主要用于发现新的对等体。</p><p id="b5cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在以太坊中，客户端将其他节点的信息存储在两种数据结构中。第一个是名为db的长期数据库，它存储在磁盘上，在客户端重新启动后仍然存在。第二个是短期数据库，称为table，它包含类似Kademlia的bucketss，每当客户端重新启动时，这些bucket总是为空。</p><p id="9ace" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">值得注意的是，以太坊最初的Kademlia实现容易受到<strong class="is hu"> eclipse攻击</strong> 的攻击，攻击者生成一组以太坊NodeIDs，然后使用协调的策略从两台主机(每台只有一个IP地址)发起eclipse攻击。</p><p id="da57" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Storj能够避免这种情况，因为前面提到的<a class="ae jo" href="https://storj.io/storjv3.pdf#page=35" rel="noopener ugc nofollow" target="_blank"> 4.6.1 </a>和S/Kademlia扩展，其中卫星审查过程和工作证明证书生成使得NodeID生成的成本对于潜在的攻击者来说不是微不足道的。</p><h2 id="0413" class="kp kq ht bd kr ks kt ku kv kw kx ky kz jb la lb lc jf ld le lf jj lg lh li lj dt translated">星际文件系统协议中的Kademlia用法</h2><p id="be06" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">行星间文件系统(IPFS)也使用Kademlia，带有Coral DSHT和S/Kademlia扩展。在IPFS的实现中，NodeID包含一个到IPFS文件散列的直接映射。每个节点还存储从哪里获取文件或资源的信息。</p><p id="095a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">许多项目都希望利用Storj网络作为IPFS的对象商店。其中最引人注目的是RTrade，它正在构建一个由Storj支持的IPFS节点，以确保其IPFS文件的可用性和持久性。</p><h2 id="f952" class="kp kq ht bd kr ks kt ku kv kw kx ky kz jb la lb lc jf ld le lf jj lg lh li lj dt translated">群协议中的Kademlia用法</h2><p id="ce0d" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">Swarm的主要目标是为以太坊的公共记录提供足够分散和冗余的存储，特别是存储和分发dApp代码和数据，以及区块链数据。</p><p id="42c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">群网络中的参与者在Kademlia DHT中通过群基本帐户的以太坊地址的散列来识别。这用作它们的覆盖地址，基于这些地址计算邻近顺序箱。</p><p id="de8b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">与大型对象存储相比，Swarm最适合与以太坊智能合约相关的较小数据位。</p><p id="0b1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Swarm使用最大4k的碎片大小，TB大约是1000000000kb。因此，对于一个更大的对象，比如1tb，要上传到Swarm，将需要250，000，000个节点(仅略少于美国的人口)。</p><p id="8bed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">相比之下，Storj更适合存储大型对象，因为我们只需要找到足够的节点来覆盖擦除份额。</p><p id="845b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Swarm还实现了一个被称为<em class="jp">责任邻域</em>的概念，它采用了一种新颖的<a class="ae jo" href="https://swarm-guide.readthedocs.io/en/latest/architecture.html#redundancy" rel="noopener ugc nofollow" target="_blank">冗余策略</a>来确保节点流失时的可用性。根据我们操作之前Storj网络的经验，我们了解到碎片复制可能是一种确保文件持久性的<a class="ae jo" href="https://storj.io/blog/2019/01/why-proof-of--replication-is-bad-for-decentralized-storage-part-2-churn-and-burn/" rel="noopener ugc nofollow" target="_blank">低效方式</a>，尤其是在节点变动和上游带宽受限的环境中。</p><h1 id="e592" class="mh kq ht bd kr mi mj mk kv ml mm mn kz mo mp mq lc mr ms mt lf mu mv mw li mx dt translated">结论</h1><p id="219a" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">了解Kademlia的最好方法之一就是看它的实际应用。您可以<a class="ae jo" href="https://storj.io/sign-up-farmer" rel="noopener ugc nofollow" target="_blank">加入Storj网络</a>来共享未使用的存储和带宽，并操作我们网络上的一个节点。</p><p id="bf40" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">希望这篇文章能很好地概述Kademlia及其在现代分布式平台中的应用。Kademlia和XOR metric是一个强大而有效的工具，在现代网络Storj V3、以太坊、IPFS和Swarm中用于查找、路由和节点发现。</p></div><div class="ab cl ki kj hb kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hm hn ho hp hq"><p id="d762" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">您有什么意见或代码更改可以让Storj变得更好吗？请发送一个拉取请求。Storj V3网络的所有代码都是开源的，您可以通过我们的repo、</em> <a class="ae jo" href="https://github.com/storj/storj" rel="noopener ugc nofollow" target="_blank"> <em class="jp">这里的</em> </a> <em class="jp">查看我们当前的Kademlia实现。</em></p><p id="0220" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">你可以通过查看我们的</em> <a class="ae jo" href="https://storj.io/white-paper" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> V3网络白皮书</em> </a> <em class="jp">来了解更多关于Storj中Kademlia的用法。</em></p><blockquote class="my"><p id="82f8" class="mz na ht bd nb nc nd ne nf ng nh jn ek translated">加入Coinmonks <a class="ae jo" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jo" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae jo" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="kp kq ht bd kr ks ni ku kv kw nj ky kz jb nk lb lc jf nl le lf jj nm lh li lj dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="lt lu ht is b it lk ix ll jb nn jf no jj np jn nq lz ma mb dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae jo" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn nq lz ma mb dt translated"><a class="ae jo" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae jo" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn nq lz ma mb dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/top-3-telegram-channels-for-crypto-traders-in-2021-8385f4411ff4">密码电报信号</a> | <a class="ae jo" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn nq lz ma mb dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae jo" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn nq lz ma mb dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">开发人员的最佳加密API</a></li><li id="b359" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn nq lz ma mb dt translated">最佳<a class="ae jo" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn nq lz ma mb dt translated">杠杆代币的终极指南</li></ul></div></div>    
</body>
</html>