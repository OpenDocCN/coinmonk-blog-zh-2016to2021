<html>
<head>
<title>Tensors in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的张量</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-deep-dive-into-tensors-in-javascript-4e73d7f10142?source=collection_archive---------6-----------------------#2018-08-07">https://medium.com/coinmonks/a-deep-dive-into-tensors-in-javascript-4e73d7f10142?source=collection_archive---------6-----------------------#2018-08-07</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/db0d4601e2fc8e99eee34ecbce471ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9yrdB_7qhi-_ju-7ph_KhQ.png"/></div></div></figure><p id="1bac" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">大多数机器学习模型的核心是数字。支撑你执行的所有数学变换的特殊数据类型被称为张量。</p><p id="b8ff" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">张量是从数学和物理中引入的一个概念，它们在理论上<a class="ae jz" href="https://www.quora.com/What-is-a-tensor" rel="noopener ugc nofollow" target="_blank">要比这篇文章所涉及的</a>复杂得多。如果你是一个黑客，想在网上用Javascript开始一个机器学习项目，你可以假设:</p><ol class=""><li id="ba88" class="ka kb ht jd b je jf ji jj jm kc jq kd ju ke jy kf kg kh ki dt translated">张量有数据</li><li id="adf9" class="ka kb ht jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">张量有一个维度</li><li id="46b3" class="ka kb ht jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">张量有形状</li><li id="34c3" class="ka kb ht jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">张量有一种类型</li><li id="94e9" class="ka kb ht jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">张量描述了有效的变换</li></ol><p id="af4f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们一个一个地过一遍。</p><figure class="ko kp kq kr fq iu"><div class="bz el l di"><div class="ks kt l"/></div></figure><h1 id="bebf" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">1.张量有数据</h1><p id="dcaf" class="pw-post-body-paragraph jb jc ht jd b je ls jg jh ji lt jk jl jm lu jo jp jq lv js jt ju lw jw jx jy hm dt translated">张量是一组数据的储存库，通常是数字。这样，它类似于用Javascript编写的平面或多维数组。</p><p id="70a1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以使用Tensorflow.js构建一个张量，并通过调用<code class="eh lx ly lz ma b">.print()</code>获得其数据的表示:</p><pre class="ko kp kq kr fq mb ma mc md aw me dt"><span id="67e1" class="mf kv ht ma b fv mg mh l mi mj">&gt; tf.tensor([1, 2, 3, 4]).print();<br/>Tensor<br/>    [1, 2, 3, 4]</span></pre><h1 id="7d91" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">2.张量有一个维度</h1><p id="01f9" class="pw-post-body-paragraph jb jc ht jd b je ls jg jh ji lt jk jl jm lu jo jp jq lv js jt ju lw jw jx jy hm dt translated">上例中的数组是一个简单的数字序列。考虑这个数组的另一种方式是它的维度为1 。</p><p id="165c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">更复杂的东西，比如包含行和列的Excel电子表格，<strong class="jd hu">的维度是2 </strong>。</p><p id="0846" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">张量定义了一种将维度编码到数据结构中的简单方法。(维度通常被称为“秩”，如“这个张量的秩为2”。)</p><p id="b3e7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看一个二维张量的例子:</p><pre class="ko kp kq kr fq mb ma mc md aw me dt"><span id="c3e6" class="mf kv ht ma b fv mg mh l mi mj">&gt; tf.tensor([[1, 2], [3, 4]]).print();<br/>Tensor<br/>    [[1, 2],<br/>     [3, 4]]</span></pre><p id="ed11" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如<a class="ae jz" href="https://hackernoon.com/learning-ai-if-you-suck-at-math-p4-tensors-illustrated-with-cats-27f0002c9b32" rel="noopener ugc nofollow" target="_blank">丹尼尔·杰弗里斯在他的教程</a>中所列出的，高阶张量被用于各种各样的机器学习问题:</p><blockquote class="mk ml mm"><p id="cd90" class="jb jc mn jd b je jf jg jh ji jj jk jl mo jn jo jp mp jr js jt mq jv jw jx jy hm dt translated">3D =时间序列</p><p id="ddc5" class="jb jc mn jd b je jf jg jh ji jj jk jl mo jn jo jp mp jr js jt mq jv jw jx jy hm dt translated">4D =图像</p><p id="b92f" class="jb jc mn jd b je jf jg jh ji jj jk jl mo jn jo jp mp jr js jt mq jv jw jx jy hm dt translated">5D =视频</p></blockquote><h1 id="b3da" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">3.张量有形状</h1><p id="ff3e" class="pw-post-body-paragraph jb jc ht jd b je ls jg jh ji lt jk jl jm lu jo jp jq lv js jt ju lw jw jx jy hm dt translated">与张量的维数(或秩)密切相关的是形状。</p><p id="f350" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">张量的形状描述了张量维度的潜在长度。这里有一个例子:</p><pre class="ko kp kq kr fq mb ma mc md aw me dt"><span id="f012" class="mf kv ht ma b fv mg mh l mi mj">&gt; tf.tensor([[1, 2, 3], [3, 4, 5]]).shape<br/>(2) [2, 3]</span></pre><h1 id="0d81" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">4.张量有一种类型</h1><p id="dba3" class="pw-post-body-paragraph jb jc ht jd b je ls jg jh ji lt jk jl jm lu jo jp jq lv js jt ju lw jw jx jy hm dt translated">张量的数据有一个固定的类型来描述数据是什么。Tensorflow.js中的有效类型可以是浮点数(小数)、整数或布尔值。</p><p id="f801" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以在创建张量时设置数据类型:</p><pre class="ko kp kq kr fq mb ma mc md aw me dt"><span id="7dc7" class="mf kv ht ma b fv mg mh l mi mj">&gt; tf.tensor1d([1, 2], null, 'float32').dtype<br/>"float32"</span></pre><h1 id="a0d5" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">5.张量描述了有效的变换</h1><p id="cef0" class="pw-post-body-paragraph jb jc ht jd b je ls jg jh ji lt jk jl jm lu jo jp jq lv js jt ju lw jw jx jy hm dt translated">张量编码了与其他张量相关的有效数学运算的知识。由于这个原因，不把张量看作数据结构，而是看作对象或类是有用的。这正是<a class="ae jz" href="https://js.tensorflow.org/api/0.12.0/#class:Tensor" rel="noopener ugc nofollow" target="_blank"> Tensorflow.js表示张量</a>的方式。</p><p id="fb5b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">假设我们想要计算<a class="ae jz" href="https://en.wikipedia.org/wiki/Dot_product" rel="noopener ugc nofollow" target="_blank">点积</a>:</p><pre class="ko kp kq kr fq mb ma mc md aw me dt"><span id="e8b4" class="mf kv ht ma b fv mg mh l mi mj">&gt; tf.tensor1d([1, 2]).dot(tf.tensor2d([[1,2], [2, 3]])).print()<br/>Tensor<br/>    [5, 8]</span></pre><p id="3816" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">但是，如果我们尝试执行无效的计算:</p><pre class="ko kp kq kr fq mb ma mc md aw me dt"><span id="bd86" class="mf kv ht ma b fv mg mh l mi mj">&gt; tf.tensor2d([[1, 2, 3], [4, 5, 6]]).dot(tf.tensor2d([[1,2], [2, 3]])).print()<br/>Uncaught Error: Error in dot: inner dimensions of inputs must match, but got 3 and 2.</span></pre><p id="50cb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">张量防止我们执行无效的计算。如果你来自非数学背景(像我一样)，你会非常感激这些错误信息。</p></div><div class="ab cl mr ms hb mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hm hn ho hp hq"><figure class="ko kp kq kr fq iu fe ff paragraph-image"><div class="fe ff my"><img src="../Images/12d5a11c9396114fe4f34100bc1e0b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*CeGLv33I5N-OjlHFgKa-qA.gif"/></div></figure><p id="bec0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">到目前为止，我们已经看到了用Tensorflow.js使用普通数组作为输入来构建张量的例子。另一种构造张量的方法是用一个<code class="eh lx ly lz ma b">TypedArray</code>。</p><h1 id="402f" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">类型化数组</h1><p id="83ce" class="pw-post-body-paragraph jb jc ht jd b je ls jg jh ji lt jk jl jm lu jo jp jq lv js jt ju lw jw jx jy hm dt translated">类型化数组由底层数据缓冲区<code class="eh lx ly lz ma b">ArrayBuffer</code>和处理缓冲区数据的对象<code class="eh lx ly lz ma b">DataView</code>定义。</p><blockquote class="mz"><p id="e6f6" class="na nb ht bd nc nd ne nf ng nh ni jy ek translated">类型化数组是浏览器的一个相对较新的功能，它产生于在WebGL中有效处理二进制数据的需求。类型化数组是一块带有类型化视图的内存，很像c语言中数组的工作方式。——<a class="ae jz" href="https://www.html5rocks.com/en/tutorials/webgl/typed_arrays" rel="noopener ugc nofollow" target="_blank">伊尔马里·海基宁</a></p></blockquote><p id="cc03" class="pw-post-body-paragraph jb jc ht jd b je nj jg jh ji nk jk jl jm nl jo jp jq nm js jt ju nn jw jx jy hm dt translated">您可以直接创建视图，通过以下方式在幕后创建缓冲区:</p><pre class="ko kp kq kr fq mb ma mc md aw me dt"><span id="656e" class="mf kv ht ma b fv mg mh l mi mj">const typedArray = new Int8Array(5);<br/>f64a[0] = 1;<br/>f64a[1] = 2;<br/><br/>// Int8Array(5) [1, 2, 0, 0, 0]</span></pre><p id="f5b1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">或者，您可以从视图中单独显式声明缓冲区:</p><pre class="ko kp kq kr fq mb ma mc md aw me dt"><span id="b45e" class="mf kv ht ma b fv mg mh l mi mj">const buffer = new ArrayBuffer(8); // 8-byte ArrayBuffer.<br/>const typedArray = new Int8Array(buffer);<br/>typedArray[0] = 1<br/><br/>// Int8Array(8) [1, 0, 0, 0, 0, 0, 0, 0]</span></pre><p id="1e62" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果您确实显式创建了缓冲区，您必须了解字节的底层表示:</p><pre class="ko kp kq kr fq mb ma mc md aw me dt"><span id="49b2" class="mf kv ht ma b fv mg mh l mi mj">const buffer = new ArrayBuffer(8); // 8-byte ArrayBuffer.<br/>const typedArray = new Int16Array(buffer);<br/>typedArray[0] = 1<br/><br/>// Int16Array(4) [1, 0, 0, 0]</span></pre><p id="5a17" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可以有多个视图指向同一个底层缓冲区。例如，这种方法用于<a class="ae jz" href="https://thekevinscott.com/dealing-with-mnist-image-data-in-tensorflowjs/" rel="noopener ugc nofollow" target="_blank">将MNIST图像示例迭代地构建到底层数据缓冲器</a>中。这里有一个简单的例子:</p><pre class="ko kp kq kr fq mb ma mc md aw me dt"><span id="3290" class="mf kv ht ma b fv mg mh l mi mj">const buffer = new ArrayBuffer(8); // 8-byte ArrayBuffer.<br/>const firstHalfView = new Int8Array(buffer, 0, 4);<br/>const secondHalfView = new Int8Array(buffer, 4, 4);<br/>firstHalfView[0] = 1<br/>secondHalfView[0] = 2<br/>console.log(buffer);<br/>// [[Int8Array]]: Int8Array(8) [1, 0, 0, 0, 2, 0, 0, 0]</span></pre><p id="f649" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您可以使用许多同名的类型化数组；<a class="ae jz" href="https://blog.codingbox.io/exploring-javascript-typed-arrays-c8fd4f8bd24f" rel="noopener ugc nofollow" target="_blank">这里是它们的字节大小的概要</a>。</p><h1 id="3ceb" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">为什么要使用类型化数组？</h1><p id="d3c0" class="pw-post-body-paragraph jb jc ht jd b je ls jg jh ji lt jk jl jm lu jo jp jq lv js jt ju lw jw jx jy hm dt translated">答案:<strong class="jd hu">性能</strong>。</p><p id="50d3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最初引入类型化数组是为了处理WebGL和其他需要超快的性能的图形层。机器学习受益于类似的性能水平，这就是为什么许多大型机器学习模型在服务器上训练，跨强大的GPU并行化。</p><blockquote class="mz"><p id="982e" class="na nb ht bd nc nd ne nf ng nh ni jy ek translated">因为类型化数组由原始内存支持，所以JavaScript引擎可以将内存直接传递给本地库，而不必费力地将数据转换为本机表示。因此，在向WebGL和其他处理二进制数据的API传递数据时，类型化数组的性能要比JavaScript数组好得多。— <a class="ae jz" href="https://www.html5rocks.com/en/tutorials/webgl/typed_arrays" rel="noopener ugc nofollow" target="_blank">伊尔马里·海基宁</a></p></blockquote><p id="4361" class="pw-post-body-paragraph jb jc ht jd b je nj jg jh ji nk jk jl jm nl jo jp jq nm js jt ju nn jw jx jy hm dt translated">习惯使用类型化数组来确保编写高性能代码是一个好习惯。</p><h1 id="0b21" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">结论</h1><p id="24d7" class="pw-post-body-paragraph jb jc ht jd b je ls jg jh ji lt jk jl jm lu jo jp jq lv js jt ju lw jw jx jy hm dt translated">在实践中，你可以用张量，记住张量有:</p><ol class=""><li id="b6ae" class="ka kb ht jd b je jf ji jj jm kc jq kd ju ke jy kf kg kh ki dt translated">数据</li><li id="653c" class="ka kb ht jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">尺寸</li><li id="db6e" class="ka kb ht jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">形状</li><li id="30b5" class="ka kb ht jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">类型</li><li id="60bf" class="ka kb ht jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">有效转换的描述</li></ol><figure class="ko kp kq kr fq iu"><div class="bz el l di"><div class="ks kt l"/></div></figure><p id="5b5e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最初发表于<a class="ae jz" href="https://thekevinscott.com/tensors-in-javascript" rel="noopener ugc nofollow" target="_blank">https://thekevinscott.com</a></p></div></div>    
</body>
</html>