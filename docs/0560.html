<html>
<head>
<title>Avocado Network Token Faucet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">鳄梨网络令牌水龙头</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/avocado-network-token-faucet-94973204d288?source=collection_archive---------5-----------------------#2018-05-17">https://medium.com/coinmonks/avocado-network-token-faucet-94973204d288?source=collection_archive---------5-----------------------#2018-05-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/af652cd4cc8162b9e5d9091eb542c3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*SjMEtNWlFZ6bnKBi59MmAA.jpeg"/></div><figcaption class="ix iy fg fe ff iz ja bd b be z ek">Avocado Network</figcaption></figure><p id="2cc8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我最近为<a class="ae jz" href="https://github.com/AvocadoNetwork/governance" rel="noopener ugc nofollow" target="_blank">鳄梨网</a>和他们的<a class="ae jz" href="https://etherscan.io/address/0xfa6f7881e52fdf912c4a285d78a3141b089ce859#code" rel="noopener ugc nofollow" target="_blank"> AVO </a>令牌做了一个<a class="ae jz" href="https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC20" rel="noopener ugc nofollow" target="_blank"> erc20 </a>令牌水龙头。这个想法是有一个令牌水龙头，允许用户请求AVO令牌，并在请求成功后设置一个时间锁。要求如下:</p><ul class=""><li id="472f" class="ka kb ht jd b je jf ji jj jm kc jq kd ju ke jy kf kg kh ki dt translated">捐赠者可以向智能合同发送AVO</li><li id="ef30" class="ka kb ht jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">用户可以调用这些方法中的任何一种:<br/> get1000Avo() —要成功，该用户的最后一次调用必须至少在1小时之前<br/> get2000Avo() —要成功，该用户的最后一次调用必须至少在2小时之前<br/> get5000Avo() —要成功，该用户的最后一次调用必须至少在5小时之前</li></ul><p id="e9fe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看看我们是如何将这些需求实现到一个全功能的智能契约中的。</p><p id="07a5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于不耐烦的人来说，这里是包含所有代码的回购协议。</p><h1 id="620c" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">水龙头合同</h1><p id="1284" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">这些要求意味着两件事:</p><ul class=""><li id="51cb" class="ka kb ht jd b je jf ji jj jm kc jq kd ju ke jy kf kg kh ki dt translated">水龙头应该有一个主人，能够打开/关闭水龙头</li><li id="5b6a" class="ka kb ht jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">水龙头应该接受ERC20基本令牌</li></ul><p id="72df" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，该合同从<a class="ae jz" href="https://github.com/OpenZeppelin/openzeppelin-solidity." rel="noopener ugc nofollow" target="_blank"> Open Zeppelin </a>继承了这两个合同:<a class="ae jz" href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol" rel="noopener ugc nofollow" target="_blank"> Ownable.sol、</a>和<a class="ae jz" href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/ERC20Basic.sol" rel="noopener ugc nofollow" target="_blank"> ERC20Basic.sol </a>。</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="a2f4" class="ma kp ht lw b fv mb mc l md me">import “./token/ERC20Basic.sol”;<br/>import “./ownership/Ownable.sol”;</span></pre><p id="2657" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">很好，现在我们可以很容易地使用这两个合同中的方法来构建我们的水龙头，但首先让我们设置一些存储以供以后使用:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="ade9" class="ma kp ht lw b fv mb mc l md me"> string public faucetName;<br/> ERC20Basic public tokenInstance;<br/> bool public faucetStatus;<br/> mapping(address =&gt; uint256) status;</span></pre><p id="2aa7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">非常简单，我们有一个水龙头实例的名称、一个ERC20基本令牌的实例、水龙头的状态，以及一个请求地址及其时间锁状态的映射。</p><p id="eaa8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">很好，让我们看看构造函数:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="265c" class="ma kp ht lw b fv mb mc l md me">constructor(address _tokenInstance, string _faucetName)<br/> public<br/> {<br/>    tokenInstance = ERC20Basic(_tokenInstance);<br/>    faucetName = _faucetName;<br/>    faucetStatus = true;</span><span id="0da6" class="ma kp ht lw b fv mf mc l md me">    emit FaucetOn(faucetStatus);<br/> }</span></pre><p id="f7f1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">构造函数接受两个参数:已经部署的令牌实例的地址和水龙头的名称。然后，它使用该地址设置一个ERC20Basic令牌的实例，设置水龙头名称，打开水龙头并发出一个nice事件。</p><p id="b9f6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们需要设置一些常量:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="1b4d" class="ma kp ht lw b fv mb mc l md me"> uint256 constant oneKToken = 1000000000000000000000;<br/> uint256 constant twoKToken = 2000000000000000000000;<br/> uint256 constant fiveKToken = 5000000000000000000000;<br/> uint256 constant oneHours = 1 hours;<br/> uint256 constant twoHours = 2 hours;<br/> uint256 constant fiveHours = 5 hours;</span></pre><p id="4f6c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity提供了<a class="ae jz" href="http://solidity.readthedocs.io/en/v0.4.24/units-and-global-variables.html?highlight=time" rel="noopener ugc nofollow" target="_blank">时间</a>的单位，我们可以很容易地使用它来设置每种方法的时间锁定周期。我们还设置了每个函数要分配的令牌数量。</p><p id="60dc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看看水龙头的功能实际上是如何工作的；每个功能将遵循相同的逻辑:</p><ul class=""><li id="6786" class="ka kb ht jd b je jf ji jj jm kc jq kd ju ke jy kf kg kh ki dt translated">通过访问状态图检查发送者的时间锁定状态</li><li id="1f1e" class="ka kb ht jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">如果状态为锁定，则恢复</li><li id="6266" class="ka kb ht jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">如果状态未锁定，则向发送者发送其令牌并更新其状态</li><li id="efd7" class="ka kb ht jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">最后发射一个事件让世界知道刚刚发生了什么</li></ul><p id="2e5d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一般流程如下:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="7aae" class="ma kp ht lw b fv mb mc l md me">function drip1000Token()<br/> public<br/> faucetOn()<br/> {<br/>     if(checkStatus(msg.sender)) {<br/>         revert();<br/>     }<br/>     tokenInstance.transfer(msg.sender, oneKToken);<br/>     updateStatus(msg.sender, oneHours);</span><span id="ee69" class="ma kp ht lw b fv mf mc l md me">     emit OneKTokenSent(msg.sender);<br/> }</span></pre><p id="3078" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该函数首先检查水龙头是否打开，然后我们检查发送者的时间锁定状态:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="3ada" class="ma kp ht lw b fv mb mc l md me">function checkStatus(address _address)<br/> internal<br/> view<br/> returns (bool)<br/> {<br/>     //check if first time address is requesting<br/>     if(status[_address] == 0) {<br/>         return false;<br/>     }<br/>     //if not first time check the timeLock<br/>     else {<br/>          // solium-disable-next-line security/no-block-members<br/>          if(block.timestamp &gt;= status[_address]) {<br/>              return false;<br/>          }<br/>          else {<br/>              return true;<br/>          }<br/>     }<br/> }</span></pre><p id="7e63" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">注意这个函数有内部修饰符。首先，我们检查发送者是否是第一次请求，如果是，酷，让他们有他们的令牌。否则，我们通过将其与当前块时间戳进行比较来检查其时间锁的状态。如果数据块时间戳小于其当前锁定时间，这意味着该时间段尚未过去，您不能拥有令牌，否则您可以开始使用，我们会向您发送令牌，然后更新您的状态:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="fc7f" class="ma kp ht lw b fv mb mc l md me">function updateStatus(address _address, uint256 _timelock)<br/> internal<br/> { // solium-disable-next-line security/no-block-members<br/>     status[_address] = block.timestamp + _timelock;<br/> }</span></pre><p id="436d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这仅仅意味着将您的时间锁设置为当前块时间戳加上所需的等待时间，在本例中为1小时。</p><p id="b025" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以下是完整的合同代码:</p><figure class="lr ls lt lu fq iu"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="ix iy fg fe ff iz ja bd b be z ek">Faucet.sol</figcaption></figure><p id="9c49" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">很好，是时候写一些测试了。</p><h1 id="28f7" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">测试水龙头</h1><p id="15b9" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">当然，我们使用<a class="ae jz" href="http://truffleframework.com/" rel="noopener ugc nofollow" target="_blank">松露</a>进行开发，所以我们有一个很好的测试套件。让我们来看一个检查<code class="eh mi mj mk lw b"> drip1000Token() </code>函数的测试:</p><figure class="lr ls lt lu fq iu"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="ix iy fg fe ff iz ja bd b be z ek">Faucet_1000Token.test.js</figcaption></figure><p id="3582" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先我们得到需要测试的工件，然后我们从<a class="ae jz" href="https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/test/helpers" rel="noopener ugc nofollow" target="_blank"> Open Zeppelin </a>中挑选一些好帮手。我们确保在测试之前在<code class="eh mi mj mk lw b">beforeEach</code>块中部署契约。</p><p id="8110" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于实际测试，首先我们向合同发送一些AVO令牌:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="8a08" class="ma kp ht lw b fv mb mc l md me">//Donor sends AVO to faucet await AVO.transfer(faucet.address, amount, { from: accounts[1] }) faucet_balance = await AVO.balanceOf.call(faucet.address, { from: accounts[0] }) assert.equal(faucet_balance.toNumber(), amount)</span></pre><p id="90cd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后我们有一个地址要求1000个AVO令牌:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="b125" class="ma kp ht lw b fv mb mc l md me">//Sends 1000 AVO to requesting address<br/> confirm = await faucet.drip1000Token({from: accounts[0]})<br/> faucet_balance = await AVO.balanceOf.call(faucet.address, { from: accounts[0] })<br/> assert.equal(faucet_balance.toNumber(), amount — drip)<br/> sender_balance = await AVO.balanceOf.call(accounts[0], { from: accounts[0] })<br/> assert.equal(sender_balance.toNumber(), drip)</span></pre><p id="7e95" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该发件人可以再次请求吗？不是:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="b49c" class="ma kp ht lw b fv mb mc l md me">//check previous sender is now locked from requesting again<br/> await assertRevert(faucet.drip1000Token({from: accounts[0]}))</span></pre><p id="96b3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们向前移动1小时，看看发送者是否可以获得更多令牌:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="531d" class="ma kp ht lw b fv mb mc l md me">//advancing 1 hour in time<br/> const unlockTime = latestTime() + duration.hours(1)<br/> await increaseTimeTo(unlockTime)</span></pre><p id="db48" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">给我更多的AVO！</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="93fd" class="ma kp ht lw b fv mb mc l md me">//previous sender can now request again<br/> confirm = await faucet.drip1000Token({from: accounts[0]})<br/> faucet_balance = await AVO.balanceOf.call(faucet.address, { from: accounts[0] })<br/> assert.equal(faucet_balance.toNumber(), 0)<br/> sender_balance = await AVO.balanceOf.call(accounts[0], { from: accounts[0] })<br/> assert.equal(sender_balance.toNumber(), 2*drip)</span></pre><p id="f7c9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以走了！</p><p id="0506" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">前往水龙头回购获得<a class="ae jz" href="https://github.com/AvocadoNetwork/smart-contract-faucet/tree/master/test" rel="noopener ugc nofollow" target="_blank">完整的测试套件</a>。</p><h1 id="ea62" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">释放；排放；发布</h1><p id="c100" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">水龙头发布为<a class="ae jz" href="https://github.com/NFhbar/smart-contract-faucet/releases" rel="noopener ugc nofollow" target="_blank"> v2.0.0 </a>，你可以在<a class="ae jz" href="https://www.ethpm.com/registry/packages/48" rel="noopener ugc nofollow" target="_blank"> ethpm </a>上获得，或者简单地分叉/克隆<a class="ae jz" href="https://github.com/AvocadoNetwork/smart-contract-faucet" rel="noopener ugc nofollow" target="_blank">回购</a>。</p></div><div class="ab cl ml mm hb mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hm hn ho hp hq"><p id="5347" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">就是这样！如果你更愿意在<a class="ae jz" href="http://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a>中处理这个合同，我设置了一个<a class="ae jz" href="https://gist.github.com/NFhbar/e2112d0d909881e5c82b2c3d6a1c5e75" rel="noopener ugc nofollow" target="_blank">要点</a>供你使用。</p><p id="1400" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">向<a class="ae jz" href="https://github.com/AvocadoNetwork" rel="noopener ugc nofollow" target="_blank"> Avocado Network </a>、<a class="ae jz" href="https://github.com/peter-evans" rel="noopener ugc nofollow" target="_blank"> Peter Evans </a>和<a class="ae jz" href="https://github.com/agro1986" rel="noopener ugc nofollow" target="_blank"> agro1986 </a>大声呼喊，感谢他们的重要贡献和评论。</p><p id="6a51" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">非常感谢你阅读这篇文章！如果你觉得这篇文章很有用<strong class="jd hu">，请点击这篇文章，并确保关注我的更多常规内容</strong>，也请查看我的<a class="ae jz" href="https://github.com/NFhbar" rel="noopener ugc nofollow" target="_blank"> Github </a>，因为我定期发布示例代码和项目。如果你有任何问题，欢迎在下面回复或者给我发邮件。</p><p id="4dc8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">玩得开心！</p></div></div>    
</body>
</html>