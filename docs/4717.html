<html>
<head>
<title>Yield Farming Tutorial — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高产农业教程—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/yield-farming-tutorial-part-1-3fd5972ce717?source=collection_archive---------0-----------------------#2021-06-06">https://medium.com/coinmonks/yield-farming-tutorial-part-1-3fd5972ce717?source=collection_archive---------0-----------------------#2021-06-06</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="e582" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">使用可靠性和安全帽的智能合同</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/e694fccf98e1fb7ad32be590b6b3d177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8tUir_0B9SUzZwTGCKtBEA.jpeg"/></div></div></figure><h1 id="d084" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">介绍</h1><p id="879f" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">在本教程的第一部分中，我们将使用Hardhat开发环境和Solidity构建一个产量农业分散应用程序。如果你搜索DuckDuckGo，你会发现相当多的产量养殖教程；然而，我既没有发现利用安全帽和乙醚的产量农业教程，也没有发现任何解释如何创建自动化产量计算器的教程。通常，这些产量农场需要所有者运行脚本来向dApp的用户交付产量。本文旨在纠正这种情况，并为您提供工具来创造一些惊人的东西。为了从本教程中获得最大收益，我建议你有一些关于可靠性的经验。</p><p id="075e" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">一、什么是产量农场？产量农业的整体理念包括用被动收入激励用户，以换取流动性。在我看来，要真正耕种，需要用户将他们赚取的收益投入另一个流动性池；因此，他们在被动收入的基础上获得被动收入。当然，这个过程会一直持续到用户收到令人讨厌的被动收入。</p><p id="0fde" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">考虑到上面的定义，我们在技术上不会构建一个“耕作”协议；相反，我们正在建立农业协议的第一个必要组成部分。一旦我们理解了基本原理，我们就可以真正开始玩DeFi钱乐高了。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/812eb27c8dfe47d8a3ecfc1665a515a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*97LQHpTiUE-H-1ZsVKYHNw.jpeg"/></div></figure><p id="a5a5" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">让我们开始吧。</p></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><h1 id="d3ad" class="ju jv ht bd jw jx lv jz ka kb lw kd ke iz lx ja kg jc ly jd ki jf lz jg kk kl dt translated">环境设置/依赖关系</h1><p id="6b6c" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">让我们从打开代码编辑器并创建一个新目录开始。对于这个项目，我将我的矿命名为pmkn-farm(没错，我就是养殖pmkn)。确保您已经安装了Node(或者Yarn，如果您愿意)。</p><p id="7b86" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">在代码编辑器终端(我用的是Mac)，cd进入你的farm目录。然后，安装以下依赖项(遵循<a class="ae ma" href="https://hardhat.org/guides/typescript.html" rel="noopener ugc nofollow" target="_blank"> Hardhat的TypeScript </a>配置，并添加一些内容):</p><p id="3fdc" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><code class="eh mb mc md me b">npm i --save-dev hardhat</code></p><p id="1cb7" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">用<code class="eh mb mc md me b">npx hardhat</code>打开安全帽</p><p id="e769" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">向下滚动一项到<em class="mf">创建一个空的hardhat.config.js </em></p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mg"><img src="../Images/62908733c4fd06ec1d9906e236fda177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QrvBB_uNOstHlDVCKggx2A.png"/></div></div></figure><p id="d32b" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">接下来，我们需要为TypeScript安装依赖项。运行以下命令:</p><p id="cd47" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><code class="eh mb mc md me b">npm i --save-dev ts-node typescript</code></p><p id="e8ac" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">对于测试:</p><p id="d1f2" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><code class="eh mb mc md me b">npm i --save-dev chai @types/node @types/mocha @types/chai</code></p><p id="e0eb" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">接下来，我们将使用ERC20代币作为赌注代币和奖励给用户的收益。为了方便开发者，OpenZeppelin 托管了大量的库。他们还提供了优秀的测试工具。在测试过程中，我们需要模拟时间的流逝。让我们抓住这里的一切:</p><p id="7b0e" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><code class="eh mb mc md me b">npm i --save-dev @openzeppelin/contracts @openzeppelin/test-helpers</code></p><p id="d2c2" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">OpenZeppelin的time.increase()函数也需要这个:</p><p id="2db4" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><code class="eh mb mc md me b">npm i --save-dev @nomiclabs/hardhat-web3 @nomiclabs/hardhat-waffle</code></p><p id="2140" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">接下来，如果你打算在GitHub或本地环境之外的任何地方发布你的作品，你需要dotenv:</p><p id="0d80" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><code class="eh mb mc md me b">npm i --save-dev dotenv</code></p><p id="4cd6" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">将<em class="mf"> hardhat.config </em>更改为TypeScript:</p><p id="bddd" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><code class="eh mb mc md me b">mv hardhat.config.js hardhat.config.ts</code></p><p id="b627" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">最后，我们将更改Solidity版本并重新格式化hardhat-waffle导入，并将hardhat-web3导入包含在<em class="mf"> hardhat.config.ts </em>中:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mh mi l"/></div></figure></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><h1 id="7b4d" class="ju jv ht bd jw jx lv jz ka kb lw kd ke iz lx ja kg jc ly jd ki jf lz jg kk kl dt translated">契约</h1><h1 id="e14d" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">1.ERC20 PmknToken合同</h1><p id="f046" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">因为喜欢南瓜，所以这个教程会奖励用户PmknTokens。您可以随意更改名称。</p><p id="5958" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">您应该仍然在目录的根目录中，并且在您的终端中:</p><p id="0bf3" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><code class="eh mb mc md me b">mkdir contracts</code></p><p id="535a" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><code class="eh mb mc md me b">touch contracts/PmknToken.sol</code></p><p id="56a7" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">我们将首先制定我们的ERC20令牌合同。让我们从OpenZeppelin导入ERC20契约，同时也导入OpenZeppelin的<em class="mf"> Ownable.sol </em>契约。您可以在<em class="mf"> node_modules </em>中亲自查看这些合同。在声明导入之后，我们将为函数<strong class="ko hu"> mint() </strong>和<strong class="ko hu"> transferOwnership() </strong>构建两个包装器。这些包装器的目的包括控制谁可以调用这些函数(因此，只有<em class="mf">owner</em>修饰符)。mint函数向指定的用户地址分配指定数量的令牌。因为我们希望自动化这个过程，所以我们还包含了transferOwnership()函数来将所有权转移到farm契约；因此，只有契约本身才能发行代币。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mh mi l"/></div></figure></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><h1 id="a083" class="ju jv ht bd jw jx lv jz ka kb lw kd ke iz lx ja kg jc ly jd ki jf lz jg kk kl dt translated">2.PmknFarm合同</h1><p id="2591" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated"><code class="eh mb mc md me b">touch contracts/PmknFarm.sol</code></p><p id="b054" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">在您的PmknFarm合同中，让我们构建项目的框架。我们正在建立一个高产农业dApp因此，我们将需要一个功能，允许用户赌注他们的资金。我们还需要一个功能来拆分他们的资金。此外，用户会想要撤回他们的收益。三个核心功能。导入PmknToken契约和OpenZeppelin的IERC20契约。我们还需要为前端声明一些状态变量映射和事件。我们将检查合同的每个方面。首先，让我们回顾一下构造函数、状态变量和事件。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="eaf7" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">startTime和pmknBalance映射可能需要一点解释，以便更好地理解它们将如何在我们的函数中使用。startTime将跟踪用户地址的时间戳，以便跟踪用户的<em class="mf">未实现的</em>收益。pmknBalance将指向已实现的<em class="mf"/>，或者与用户地址相关联的等待生成的存储数量、PmknToken yield(不要与实际生成的PmknToken混淆)。如果您不熟悉映射，它们只是键/值对。要获得更深入的解释，我鼓励你阅读<a class="ae ma" href="https://docs.soliditylang.org/en/v0.8.0/types.html?highlight=mapping#mapping-types" rel="noopener ugc nofollow" target="_blank">的《坚实度文档</a>。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="84b2" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">我总是声明一个名称变量用于测试；然而，这不是必需的。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="dce4" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">这些状态变量声明以类型(即IERC20，PmknToken)和可见性(public)开头。</p><p id="6a04" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">为了避免混淆，我鼓励遵循以下约定:</p><ul class=""><li id="c909" class="mj mk ht ko b kp li ks lj kv ml kz mm ld mn lh mo mp mq mr dt translated">type =&gt; PascalCasing</li><li id="a03b" class="mj mk ht ko b kp ms ks mt kv mu kz mv ld mw lh mo mp mq mr dt translated">状态声明= &gt;骆驼套</li><li id="6100" class="mj mk ht ko b kp ms ks mt kv mu kz mv ld mw lh mo mp mq mr dt translated">构造函数参数= &gt; _ underscoreCamelCasing</li></ul><p id="805e" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">当我第一次开始使用Solidity时，我花了一些时间来理解使用ERC20令牌到底是怎么回事。我希望这个概念是这样向我解释的:IERC20和PmknToken由类型组成；如中所示，导入的令牌类型。状态变量声明由令牌类型的协定实例组成。最后，构造函数的参数指向完全创建导入令牌的协定实例的地址。</p><p id="0a07" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">对于那些不熟悉的人来说，构造函数是一个在契约部署期间只使用一次的函数。构造函数的一个常见用例包括设置常量地址(就像我们在这里做的一样)。为了部署此契约，用户必须输入_daiToken和_pmknToken的地址。</p><p id="e70c" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">前进到这篇文章的核心。</p></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><h1 id="eea1" class="ju jv ht bd jw jx lv jz ka kb lw kd ke iz lx ja kg jc ly jd ki jf lz jg kk kl dt translated">核心功能</h1><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="ff08" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><strong class="ko hu"> stake() </strong>函数首先要求amount参数大于0，并且用户持有足够的DAI来支付交易。条件if语句检查用户是否已经下注DAI。如果是这样，合约将未实现的收益加到pmknBalance上。这确保了累积收益不会消失。之后，协定调用IERC20 transferFrom函数。用户首先必须批准合同转移资金的请求。此后，用户必须签署实际交易。该函数更新stakingBalance、startTime和isStaking映射。最后，它发出Stake事件，让我们的前端可以轻松地监听所述事件。</p></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="a44e" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><strong class="ko hu"> unstake() </strong>函数要求isStaking映射等于true(仅在调用stake函数时发生),并要求请求的unstake金额不大于用户的staked余额。我声明了一个局部toTransfer变量等于calculateYieldTotal函数(稍后将详细介绍这个函数)，以便于我的测试(延迟给我带来了检查余额的问题)。此后，我们遵循checks-effects-transactions模式，将balanceTransfer设置为等于金额，然后将金额设置为0。这可以防止用户滥用<a class="ae ma" href="https://docs.soliditylang.org/en/v0.8.3/security-considerations.html" rel="noopener ugc nofollow" target="_blank">重入</a>功能。</p><p id="fdcd" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">此外，该逻辑更新stakingBalance映射并将DAI传送回用户。接下来，该逻辑更新pmknBalance映射。这种映射构成了用户的未实现收益；因此，如果用户已经持有未实现的收益余额，则新的余额包括当前余额和以前的余额(同样，在calculateYieldTotal一节中对此有更多介绍)。最后，我们包括一个条件语句，检查用户是否仍然持有赌注资金。如果用户没有，isStaking映射指向false。</p><p id="f835" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><em class="mf">*我还应该注意到，Solidity版本&gt; = 0.8.0包括已经集成的SafeMath。如果你正在使用Solidity &lt; 0.8.0，我强烈建议你使用SafeMath库来防止溢出。</em></p><p id="fa26" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><em class="mf">* *原始的unstake()函数无法重置startTime映射。上面的代码反映了错误修复。</em></p></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="40df" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><strong class="ko hu"> withdrawYield() </strong>函数要求calculateYieldTotal函数或pmknBalance为用户保存余额。if条件语句专门检查pmknBalance。如果这个映射指向一个余额，这意味着用户不止一次下注DAI。契约逻辑将旧的pmknBalance添加到我们从calculateYieldTotal接收的运行产出总量中。注意，逻辑遵循检查-效果-事务模式；其中，oldBalance获取pmknBalance单元。紧接着，pmknBalance被赋值为零(同样是为了防止重入)。之后，startTime被分配给当前时间戳，以便重置应计收益。最后，契约调用pmknToken.mint函数，该函数将PMKN直接传递给用户。</p></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><h1 id="a990" class="ju jv ht bd jw jx lv jz ka kb lw kd ke iz lx ja kg jc ly jd ki jf lz jg kk kl dt translated">助手功能</h1><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="e8c0" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><strong class="ko hu">calculateieldtime()</strong>函数只是用当前时间戳从指定用户的地址中减去startTime时间戳。这个函数更像是一个帮助函数的助手。此功能的可见性应该是内部的；然而，我选择让公众了解测试。</p></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="ce55" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><strong class="ko hu"> calculateYieldTotal() </strong>函数允许进行自动锁定过程。首先，该逻辑从calculateyieldtime函数中获取返回值，并将其乘以10 ⁸.这被证明是必要的，因为Solidity不处理浮点数或分数。通过将返回的时间戳差值转换成一个<a class="ae ma" href="https://docs.ethers.io/v5/api/utils/bignumber/" rel="noopener ugc nofollow" target="_blank">大数字</a>，Solidity可以提供更高的精度。rate变量等于86，400，即一天中的秒数。这个想法是:用户每24小时收到100%的DAI。</p><p id="b4aa" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><em class="mf">*在更传统的yield farm中，费率是由用户占池的百分比而不是时间决定的。</em></p><p id="f2a8" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">此外，BigNumber时间变量除以硬编码率(86400)。该函数取商并将其乘以用户的DAI赌注余额，然后除以10 ⁸.当前端获取原始产量时，它必须再次除以10 ⁸以显示实际产量。</p></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><h1 id="6e03" class="ju jv ht bd jw jx lv jz ka kb lw kd ke iz lx ja kg jc ly jd ki jf lz jg kk kl dt translated">结论</h1><p id="c23b" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">这是最终的合同:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="75df" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">这就结束了产量农业dApp的合同部分。如果您有任何问题，请随时联系我们。我希望这能帮助你踏上坚实的旅程。非常感谢您的阅读！</p><p id="1936" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><a class="ae ma" href="https://fleming-andrew.medium.com/yield-farming-tutorial-part-2-ea5b5254805d" rel="noopener">第2部分:使用Hardhat和Chai测试智能合约</a></p><p id="c2ee" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated"><em class="mf">*要查看包含测试、脚本和前端的完整回购，这里是回购:</em><a class="ae ma" href="https://github.com/andrew-fleming/pmkn-farm" rel="noopener ugc nofollow" target="_blank"><em class="mf">https://github.com/andrew-fleming/pmkn-farm</em></a></p><blockquote class="mx my mz"><p id="9440" class="km kn mf ko b kp li iu kr ks lj ix ku na lk kx ky nb ll lb lc nc lm lf lg lh hm dt translated"><em class="ht">*小费不胜感激！<br/> ETH地址:0xd 300 faed 55 AE 89229 f7d 725 e0d 710551927 b5 b 15</em></p></blockquote><blockquote class="nd"><p id="b083" class="ne nf ht bd ng nh ni nj nk nl nm lh ek translated">加入<a class="ae ma" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank"> Coinmonks电报频道</a>，了解加密交易和投资</p></blockquote><h2 id="7402" class="nn jv ht bd jw no np nq ka nr ns nt ke kv nu nv kg kz nw nx ki ld ny nz kk oa dt translated">另外，阅读</h2><ul class=""><li id="2b9c" class="mj mk ht ko b kp kq ks kt kv ob kz oc ld od lh mo mp mq mr dt translated"><a class="ae ma" href="https://blog.coincodecap.com/defi-yield-farming-and-liquidity-mining" rel="noopener ugc nofollow" target="_blank">低产农业和流动性采矿</a></li></ul></div></div>    
</body>
</html>