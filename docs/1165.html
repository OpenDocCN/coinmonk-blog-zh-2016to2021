<html>
<head>
<title>How to develop Ethereum contract using Python Flask?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python Flask开发以太坊契约？</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-develop-ethereum-contract-using-python-flask-9758fe65976e?source=collection_archive---------0-----------------------#2018-07-30">https://medium.com/coinmonks/how-to-develop-ethereum-contract-using-python-flask-9758fe65976e?source=collection_archive---------0-----------------------#2018-07-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="2e28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在数据库中存储数据是任何软件应用程序不可或缺的一部分。谁控制了那个数据库，谁就是那个数据的主人。区块链技术将数据存储到区块链网络内部的区块中。因此，每当某个节点同步到网络时，它们将获得块中数据的副本。所以在这项技术中没有特定的数据主人。</p><p id="41fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本教程中，我们将编写一个智能契约(我将进一步解释这一点)，用于在区块链上持久化用户数据。我们将使用python web 3(python library for web 3)来制作和部署智能合约。一旦我们在区块链部署了智能合同。我们将使用flask API与智能合同进行交互，以存储一些数据/信息。我们将它存储在区块链上，这样它将是不可改变的。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/2fba73908e1bc63e1c283d3297a81942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4x8YPKyFwC38se4nzlXZg.jpeg"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">“Ethereum smart contract deployment flow” by Neha <a class="ae ke" href="https://github.com/NehaGhogale" rel="noopener ugc nofollow" target="_blank">Ghogale</a></figcaption></figure><h2 id="7ad4" class="kf kg ht bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz dt translated">要求:</h2><p id="3360" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">Python 3.6</p><h2 id="d049" class="kf kg ht bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz dt translated"><span class="l lf lg lh bm li lj lk ll lm di">I</span>T9】安装:</h2><ol class=""><li id="3e65" class="ln lo ht is b it la ix lb jb lp jf lq jj lr jn ls lt lu lv dt translated">创建一个python虚拟环境。</li></ol><p id="2260" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae ke" href="http://virtualenv.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Virtualenv </a>将您的Python包保存在一个针对您的项目的虚拟环境中，而不是强迫您在系统范围内安装您的包。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="28c1" class="kf kg ht lx b fv mb mc l md me"><em class="mf">$ virtualenv -p /usr/bin/python3.6 venv<br/>$ source venv/bin/activate</em></span></pre><p id="a4ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2.现在我们需要像ganache这样的以太坊测试链。</p><p id="ff79" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae ke" href="https://github.com/trufflesuite/ganache-cli/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> Ganache </a>是一个用于以太坊开发的个人区块链，您可以使用它来部署契约、开发应用程序和运行测试。</p><p id="f9f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh mg mh mi lx b">$ npm install -g ganache-cli</code></p><p id="9d01" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3.安装python web3。</p><p id="46ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae ke" href="https://web3py.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Web3.py </a>是一个用于与以太坊交互的python库。它的API源自<a class="ae ke" href="https://github.com/ethereum/wiki/wiki/JavaScript-API" rel="noopener ugc nofollow" target="_blank"> Web3.js </a> Javascript API，使用过Web3.js的人应该都很熟悉。</p><p id="9b54" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh mg mh mi lx b">$ pip3 install web3</code></p><p id="26ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">4.烧瓶:</p><p id="d07c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae ke" href="http://flask.pocoo.org/" rel="noopener ugc nofollow" target="_blank"> Flask </a> <em class="mf">是Python </em>的微框架</p><p id="ef62" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh mg mh mi lx b">$ pip3 install flask</code></p><p id="6bf9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">5.烧瓶宁静</p><p id="7b17" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Flask-RESTful 是Flask的扩展，增加了对快速构建REST APIs的支持。</p><p id="ee27" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh mg mh mi lx b">$ pip3 install flask-restful</code></p><p id="62ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">6.烧瓶棉花糖</p><p id="f160" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">烧瓶棉花糖是一个对象序列化/反序列化库</p><p id="76f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh mg mh mi lx b">$ pip3 install flask-marshmallow</code></p><h2 id="0179" class="kf kg ht bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz dt translated">启动以太坊测试区块链服务器。</h2><p id="6d49" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">要部署智能合约，我们应该开始测试以太坊服务器。我们正在使用<a class="ae ke" href="https://github.com/trufflesuite/ganache-cli/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> ganache </a>进行测试。在终端中键入以下命令。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="3366" class="kf kg ht lx b fv mb mc l md me">$ ganache-cli</span></pre><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/f53083afcd4075b9ed43044747e11a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*byLtgRTVNhwbxynlB4HIaw.png"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Ganache Account Address</figcaption></figure><p id="47f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Ganache给了我们10个默认的测试账户，每个账户有100个假乙醚用于交易。我们将使用这些帐户在合同中部署和设置价值。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/13baf13ee7b9d27aca13dcf58fe46fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*hleX_pkMM8if3NqGudVSXg.png"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Ganache port</figcaption></figure><p id="d6b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们可以看到gas奖励和限制以及部署ganache的host:port。在部署合同时，我们将需要它。</p><h2 id="35a0" class="kf kg ht bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz dt translated">创建user.sol文件</h2><p id="28dd" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">现在我们将在<a class="ae ke" href="http://solidity.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> solidity </a>中编写智能合约。Solidity是以太坊上写智能合约的语言。智能合同由我们将存储在区块链上的数据组成，数据上有可选的验证函数和用于访问数据的getter、setter方法。</p><p id="5229" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">例如，要在区块链上创建一个考勤登记簿，您将拥有一个用户对象数组。它将有getter，setter方法来访问用户。因为每个用户每天只能标记一次她的出勤，所以需要一个验证函数来检查。智能合约非常类似于我们通常用其他语言开发的应用程序。</p><p id="9ca2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在下面的文件中，我们正在用getter、setter函数构建简单的用户契约。</p><ol class=""><li id="c917" class="ln lo ht is b it iu ix iy jb ml jf mm jj mn jn ls lt lu lv dt translated">在中声明<a class="ae ke" href="https://solidity.readthedocs.io/en/v0.4.24/layout-of-source-files.html#version-pragma" rel="noopener ugc nofollow" target="_blank"> solidity编译器</a>版本。sol文件。</li></ol><p id="7e1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh mg mh mi lx b">pragma solidity ^0.4.21;</code></p><p id="0e52" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要知道使用了哪个编译器版本<br/> <code class="eh mg mh mi lx b">$ solidity — version</code></p><p id="3cd5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2.<a class="ae ke" href="https://solidity.readthedocs.io/en/v0.4.24/layout-of-source-files.html#importing-other-source-files/" rel="noopener ugc nofollow" target="_blank">导入库</a>文件。我们应该将库用于常见的实用功能。库只编译一次，然后反复使用(<a class="ae ke" href="http://source https://github.com/ethereum/dapp-bin/tree/master/library/" rel="noopener ugc nofollow" target="_blank">点击这里</a>获得一些好的库资源)。</p><p id="b33c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh mg mh mi lx b">import “stringUtils.sol”;</code></p><p id="0691" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3.为用户<br/>申报合同<code class="eh mg mh mi lx b">contract userRecords {}</code></p><p id="d183" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">4.现在对于基本的演示，我们将存储用户的姓名和性别信息。所以使用struct和enum数据类型初始化这两个变量。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="d5f6" class="kf kg ht lx b fv mb mc l md me">// enum type variable to store user gender <br/>enum genderType { male, female } <br/>// Actual user object which we will store in ethereum contract <br/>struct user{ <br/>    string name; genderType gender; <br/>}</span></pre><p id="29d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">5.现在我们将声明user(struct)类型的用户对象。您还可以将它声明为public以从契约外部访问它(对于可见性范围<a class="ae ke" href="https://solidity.readthedocs.io/en/v0.4.24/contracts.html#visibility-and-getters" rel="noopener ugc nofollow" target="_blank">单击此处</a>)。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="5a36" class="kf kg ht lx b fv mb mc l md me">user user_obj;</span></pre><p id="a59b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">6.现在为用户对象添加getter、setter方法。我们将在区块链上保存每个用户的信息。我们应该总是公开这个方法，因为我们将从契约之外访问它们。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="4358" class="kf kg ht lx b fv mb mc l md me">// set user public function<br/>// This is similar to persisting object in db.<br/>function setUser(string name, string gender) public {<br/>    genderType gender_type = getGenderFromString(gender);<br/>    user_obj = user({name:name, gender: gender_type});<br/>}</span><span id="f6c3" class="kf kg ht lx b fv mo mc l md me">// get user public function<br/>// This is similar to getting object from db.<br/>function getUser() public returns (string, string) { <br/>    return (user_obj.name, getGenderToString(user_obj.gender));<br/>}</span></pre><p id="2278" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">7.注意，我们使用了两个内部辅助函数getGenderFromString()和getGenderToString()。让我们添加这个内部函数。将它们声明为内部的，因为我们不会在外部使用它们。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="1168" class="kf kg ht lx b fv mb mc l md me">// Internal function to convert genderType enum from string<br/>function getGenderFromString(string gender) internal returns(genderType) {<br/>    if(StringUtils.equal(gender, "male")) {<br/>        return genderType.male;<br/>    } else {<br/>        return genderType.female;<br/>    }<br/>}</span><span id="8e2d" class="kf kg ht lx b fv mo mc l md me">// Internal function to convert genderType enum to string<br/>function getGenderToString(genderType gender) internal returns (string) {<br/>    if(gender == genderType.male) {<br/>        return "male";<br/>    } else {<br/>        return "female";<br/>    }<br/>}</span></pre><p id="acc6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们使用的是stringUtils.equal()库函数。因为这个版本的solidity不支持使用(==)进行字符串比较。</p><p id="ad5b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">8.现在，我们的合同user.sol文件将如下所示:</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="1a9a" class="kf kg ht lx b fv mb mc l md me">pragma solidity ^0.4.21;<br/>// import library file<br/>import "stringUtils.sol";</span><span id="3d01" class="kf kg ht lx b fv mo mc l md me">contract userRecords {<br/>  // enum type variable to store user gender<br/>  enum genderType { male, female };<br/>  // Actual user object which we will store<br/>  struct user{<br/>    string name;<br/>    genderType gender;<br/>  }<br/>  // user object<br/>  user user_obj;<br/>  //Internal function to conver genderType enum from string<br/>  function getGenderFromString(string gender) internal returns   (genderType) {<br/>    if(StringUtils.equal(gender, "male")) {<br/>      return genderType.male;<br/>    } else {<br/>      return genderType.female;<br/>    }<br/>  }</span><span id="a78d" class="kf kg ht lx b fv mo mc l md me">  //Internal function to convert genderType enum to string<br/>  function getGenderToString(genderType gender) internal returns (string) {<br/>    if(gender == genderType.male) {<br/>      return "male";<br/>    } else {<br/>      return "female";<br/>    }<br/>  }</span><span id="e8e7" class="kf kg ht lx b fv mo mc l md me">  // set user public function<br/>  // This is similar to persisting object in db.<br/>  function setUser(string name, string gender) public {<br/>    genderType gender_type = getGenderFromString(gender);<br/>    user_obj = user({name:name, gender: gender_type});<br/>  }<br/>  <br/>  // get user public function<br/>  // This is similar to getting object from db.<br/>  function getUser() public returns (string, string) {<br/>    return (user_obj.name, getGenderToString(user_obj.gender));<br/>  }<br/>}</span></pre><h2 id="c5bf" class="kf kg ht bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz dt translated">使用python脚本编译和部署上述solidity文件。</h2><ol class=""><li id="5c5d" class="ln lo ht is b it la ix lb jb lp jf lq jj lr jn ls lt lu lv dt translated">在下面的python脚本中，我们需要使用python-web3实例化测试以太坊节点。我们正在将ganche url设置为一个测试以太坊节点。我们将使用以下w3对象来部署合同。</li></ol><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="0600" class="kf kg ht lx b fv mb mc l md me">from web3 import Web3<br/># web3.py instance<br/>w3 = Web3(Web3.HTTPProvider("http://127.0.0.1:8545"))</span></pre><p id="05f3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2.现在我们将编译solidity代码。为了编译solidity代码，我们使用了python对solidity编译器的扩展<a class="ae ke" href="https://github.com/ethereum/py-solc" rel="noopener ugc nofollow" target="_blank"> py-solc </a>。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="347f" class="kf kg ht lx b fv mb mc l md me">from solc import compile_files</span><span id="e452" class="kf kg ht lx b fv mo mc l md me"># compile all contract files<br/>contracts = compile_files(['user.sol', 'stringUtils.sol'])</span><span id="56af" class="kf kg ht lx b fv mo mc l md me"># separate main file and link file<br/>main_contract = contracts.pop("user.sol:userRecords")<br/>library_link = contracts.pop("stringUtils.sol:StringUtils")</span></pre><p id="50d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3.每当用import语句编译. sol文件时。我们还需要将导入文件的部署地址与主合同链接起来。因此，首先通过编译部署所有链接(如果已经部署，然后保存地址),见下图主合同绑定。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mp"><img src="../Images/b0316319d34cd5072fd817654d0545d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AqzKXtjOiSuMpN5QPjAmNQ.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">compile contract bin</figcaption></figure><p id="442b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当你编译你的主合同时，如果你看到它的bin部分，你会发现<em class="mf">" _ string utils . sol:string utils _ _ _ _ _ _ _ _ _ "用于我们正在导入的库(它也可以用于合同)。这部分我们应该通过在契约前部署库地址来替换。</em></p><p id="2c54" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">4.然后我们会把库地址和主合同链接起来。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="0592" class="kf kg ht lx b fv mb mc l md me">from solc import link_code</span><span id="0af8" class="kf kg ht lx b fv mo mc l md me">def deploy_contract(contract_interface):<br/>    # Instantiate and deploy contract<br/>    contract = w3.eth.contract(<br/>        abi=contract_interface['abi'],<br/>        bytecode=contract_interface['bin']<br/>    )<br/>    # Get transaction hash from deployed contract<br/>    tx_hash = contract.deploy(<br/>        transaction={'from': w3.eth.accounts[1]}<br/>    )<br/>    # Get tx receipt to get contract address<br/>    tx_receipt = w3.eth.getTransactionReceipt(tx_hash)<br/>    return tx_receipt['contractAddress']</span><span id="c92d" class="kf kg ht lx b fv mo mc l md me">library_address = {<br/>    "stringUtils.sol:StringUtils": deploy_contract(library_link)<br/>}<br/>main_contract['bin'] = link_code(<br/>    main_contract['bin'], library_address<br/>)</span></pre><p id="7ac3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">链接后，请参见主合同箱的下图</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mq"><img src="../Images/a5140f719bf980ebfa6b18afd4524204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bUVfKnZHtlXEgPz6hmDwuw.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">main contract bin 2</figcaption></figure><p id="56e4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您将看到导入库bin已被添加。</p><p id="9fcc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">5.现在使用w3对象部署主合同。使用以太坊账号<em class="mf">{ ' from ':w3 . eth . accounts[1]}</em>的默认地址进行部署。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="20ef" class="kf kg ht lx b fv mb mc l md me">def deploy_contract(contract_interface):<br/>    # Instantiate and deploy contract<br/>    contract = w3.eth.contract(<br/>        abi=contract_interface['abi'],<br/>        bytecode=contract_interface['bin']<br/>    )<br/>    # Get transaction hash from deployed contract<br/>    tx_hash = contract.deploy(<br/>        transaction={'from': w3.eth.accounts[1]}<br/>    )<br/>    # Get tx receipt to get contract address<br/>    tx_receipt = w3.eth.getTransactionReceipt(tx_hash)<br/>    return tx_receipt['contractAddress']</span><span id="05a4" class="kf kg ht lx b fv mo mc l md me">contract_address = deploy_contract(main_contract)</span></pre><p id="7056" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您将在运行ganache测试服务器的选项卡中看到下面几行。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mr"><img src="../Images/a75f0685ddf879a13246dd62cf250843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KWSyFE2bXGQxdUhUlYXmwQ.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">ganache receipt</figcaption></figure><p id="f414" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这与合同部署后您将在tx_receipt中获得的信息相同。</p><p id="3087" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">6.现在将abi和contract_address存储在json文件中。以便我们以后可以在flask api中使用它来存储契约中的用户对象。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="4c0a" class="kf kg ht lx b fv mb mc l md me"># add abi(application binary interface) and transaction reciept in json file<br/>with open('data.json', 'w') as outfile:<br/>    data = {<br/>       "abi": main_contract['abi'],<br/>       "contract_address": deploy_contract(main_contract)<br/>    }<br/>    json.dump(data, outfile, indent=4, sort_keys=True)</span></pre><p id="4343" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">7.现在，我们完整的脚本将如下所示</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="27bc" class="kf kg ht lx b fv mb mc l md me">import json<br/>from web3 import Web3<br/>from solc import compile_files, link_code, compile_source</span><span id="739b" class="kf kg ht lx b fv mo mc l md me"># web3.py instance<br/>w3 = Web3(Web3.HTTPProvider("http://127.0.0.1:8545"))</span><span id="4a7e" class="kf kg ht lx b fv mo mc l md me">def deploy_contract(contract_interface):<br/>    # Instantiate and deploy contract<br/>    contract = w3.eth.contract(<br/>        abi=contract_interface['abi'],<br/>        bytecode=contract_interface['bin']<br/>    )<br/>    # Get transaction hash from deployed contract<br/>    tx_hash =contract.deploy(transaction{'from':w3.eth.accounts[1]})<br/>    # Get tx receipt to get contract address<br/>    tx_receipt = w3.eth.getTransactionReceipt(tx_hash)<br/>    return tx_receipt['contractAddress']</span><span id="6ac3" class="kf kg ht lx b fv mo mc l md me"># compile all contract files<br/>contracts = compile_files(['user.sol', 'stringUtils.sol'])</span><span id="957b" class="kf kg ht lx b fv mo mc l md me"># separate main file and link file<br/>main_contract = contracts.pop("user.sol:userRecords")<br/>library_link = contracts.pop("stringUtils.sol:StringUtils")</span><span id="3c71" class="kf kg ht lx b fv mo mc l md me"># print bin part in  console you will see 'stringUtils' in that we need to link library address in that bin code.<br/># to that we have to deploy library code first then link it<br/>library_address = {<br/>    "stringUtils.sol:StringUtils": deploy_contract(library_link)<br/>}<br/>main_contract['bin'] = link_code(<br/>    main_contract['bin'], library_address)</span><span id="7791" class="kf kg ht lx b fv mo mc l md me"># add abi(application binary interface) and transaction reciept in json file<br/>with open('data.json', 'w') as outfile:<br/>    data = {<br/>        "abi": main_contract['abi'],<br/>        "contract_address": deploy_contract(main_contract)<br/>    }<br/>    json.dump(data, outfile, indent=4, sort_keys=True)</span></pre><h2 id="9406" class="kf kg ht bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz dt translated">创建flask api为用户存储不同的值。</h2><p id="1ca6" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">您将只部署一次合同。但是使用它的地址，你将一次又一次地存储数据。类似地，在db中，您将只定义一次模型/模式，但是您将在DB中添加不同的行/文档。</p><ol class=""><li id="2531" class="ln lo ht is b it iu ix iy jb ml jf mm jj mn jn ls lt lu lv dt translated">我们将使flask post api从用户处获取用户信息并返回成功。</li></ol><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="d549" class="kf kg ht lx b fv mb mc l md me">from flask import Flask, Response, request, jsonify<br/>from marshmallow import Schema, fields, ValidationError</span><span id="312b" class="kf kg ht lx b fv mo mc l md me">def check_gender(data):<br/>    valid_list = ["male", "female"]<br/>    if data not in valid_list:<br/>        raise ValidationError(<br/>            'Invalid gender. Valid choices are'+ valid_list<br/>        )</span><span id="b60f" class="kf kg ht lx b fv mo mc l md me">#For api validations<br/>class UserSchema(Schema):<br/>    name = fields.String(required=True)<br/>    gender = fields.String(required=True, validate=check_gender)</span><span id="0da7" class="kf kg ht lx b fv mo mc l md me"># Initializing flask app<br/>app = Flask(__name__)</span><span id="1db5" class="kf kg ht lx b fv mo mc l md me"># api to set new user every api call</span><span id="07b4" class="kf kg ht lx b fv mo mc l md me">@app.route("/blockchain/user", methods=['POST'])<br/>def user():<br/>    body = request.get_json()<br/>    result, error = UserSchema().load(body)<br/>    if error:<br/>        return jsonify(error), 422<br/>    return jsonify({"data": result}), 200</span></pre><p id="5bf7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于这不是烧瓶教程，我不会详细阐述这一点。我们的API用户将从客户端获取数据(curl请求)并对其进行验证，然后将其返回给客户端(curl请求)</p><p id="ff00" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2.现在，我们将初始化web3对象，以便与部署的用户契约进行通信。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="815d" class="kf kg ht lx b fv mb mc l md me">from web3 import Web3</span><span id="57e3" class="kf kg ht lx b fv mo mc l md me"># web3.py instance<br/>w3 = Web3(Web3.HTTPProvider("http://127.0.0.1:8545"))</span></pre><p id="f9f3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3.现在，我们将获得abi和合同地址，我们之前已经将它们存储在“data.json”文件中。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="cdf6" class="kf kg ht lx b fv mb mc l md me">with open("data.json", 'r') as f:<br/>     datastore = json.load(f)<br/>     abi = datastore["abi"]<br/>     contract_address = datastore["contract_address"]</span></pre><p id="855b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">4.选择交易记录的默认帐户地址。每次在合同中为用户设置新值时。你会从钱包里拿出一些汽油。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="fb7a" class="kf kg ht lx b fv mb mc l md me">w3.eth.defaultAccount = w3.eth.accounts[1]</span></pre><p id="99d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">5.最后，您将设置您在以太坊契约中对用户对象的api调用中获得的值。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="662b" class="kf kg ht lx b fv mb mc l md me">@app.route("/blockchain/user", methods=['POST'])<br/>def user():<br/>    # Create the contract instance with the newly-deployed address<br/>    user = w3.eth.contract(address=contract_address, abi=abi)</span><span id="640b" class="kf kg ht lx b fv mo mc l md me">    body = request.get_json()<br/>    result, error = UserSchema().load(body)<br/>    if error:<br/>        return jsonify(error), 422</span><span id="a464" class="kf kg ht lx b fv mo mc l md me">    tx_hash = user.functions.setUser(<br/>        result['name'],result['gender']<br/>    )<br/>    tx_hash = tx_hash.transact()<br/>    # Wait for transaction to be mined...<br/>    w3.eth.waitForTransactionReceipt(tx_hash)<br/>    user_data = user.functions.getUser().call()<br/>    return jsonify({"data": user_data}), 200</span></pre><p id="ce2e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们首先使用abi和contract_address获得部署的合同。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="3dfa" class="kf kg ht lx b fv mb mc l md me">user = w3.eth.contract(address=contract_address, abi=abi)</span></pre><p id="8abe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，我们可以使用契约实例调用任何契约公共函数。在为用户设置值之后，我们将通过使用<a class="ae ke" href="http://web3py.readthedocs.io/en/stable/contracts.html#web3.contract.ContractFunction.transact" rel="noopener ugc nofollow" target="_blank"> transact() </a>方法将其公开。这将使新用户在以太坊中增值。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="9af9" class="kf kg ht lx b fv mb mc l md me">tx_hash = user.functions.setUser(<br/>    result['name'],result['gender']<br/>).transact()</span></pre><p id="d83f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们可以使用<a class="ae ke" href="http://web3py.readthedocs.io/en/stable/contracts.html#web3.contract.ContractFunction.call" rel="noopener ugc nofollow" target="_blank"> call() </a>方法在契约中获取已经设置的值，这将调用契约函数，而无需在区块链中添加任何块。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="ea6e" class="kf kg ht lx b fv mb mc l md me">user_data = user.functions.getUser().call()</span></pre><p id="7eb3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的api文件的最终代码如下所示。将此另存为“app.py”</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="9458" class="kf kg ht lx b fv mb mc l md me">import json<br/>from flask import Flask, Response, request, jsonify<br/>from marshmallow import Schema, fields, ValidationError<br/>from web3 import Web3</span><span id="4f0b" class="kf kg ht lx b fv mo mc l md me"># web3.py instance<br/>w3 = Web3(Web3.HTTPProvider("http://127.0.0.1:8545"))<br/>w3.eth.defaultAccount = w3.eth.accounts[1]</span><span id="2005" class="kf kg ht lx b fv mo mc l md me"># Get stored abi and contract_address<br/>with open("data.json", 'r') as f:<br/>    datastore = json.load(f)<br/>    abi = datastore["abi"]<br/>    contract_address = datastore["contract_address"]</span><span id="f7c6" class="kf kg ht lx b fv mo mc l md me">def check_gender(data):<br/>    valid_list = ["male", "female"]<br/>    if data not in valid_list:<br/>        raise ValidationError(<br/>            'Invalid gender. Valid choices are'+ valid_list<br/>        )</span><span id="5e5b" class="kf kg ht lx b fv mo mc l md me">#For api validations<br/>class UserSchema(Schema):<br/>    name = fields.String(required=True)<br/>    gender = fields.String(required=True, validate=check_gender)</span><span id="72b0" class="kf kg ht lx b fv mo mc l md me"># Initializing flask app<br/>app = Flask(__name__)</span><span id="d11a" class="kf kg ht lx b fv mo mc l md me"># api to set new user every api call</span><span id="a537" class="kf kg ht lx b fv mo mc l md me">@app.route("/blockchain/user", methods=['POST'])<br/>def user():<br/>    # Create the contract instance with the newly-deployed address<br/>    user = w3.eth.contract(address=contract_address, abi=abi)<br/>    body = request.get_json()<br/>    result, error = UserSchema().load(body)<br/>    if error:<br/>        return jsonify(error), 422<br/>    tx_hash = user.functions.setUser(<br/>        result['name'],result['gender']<br/>    ).transact()<br/>    # Wait for transaction to be mined...<br/>    receipt = w3.eth.waitForTransactionReceipt(tx_hash)<br/>    user_data = user.functions.getUser().call()<br/>    return jsonify({"data": user_data}), 200</span></pre><p id="b0d7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行以下命令启动您的服务器。</p><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="95d2" class="kf kg ht lx b fv mb mc l md me">$ FLASK_APP=app.py flask run</span></pre><h2 id="0553" class="kf kg ht bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz dt translated">使用curl调用api。</h2><pre class="jp jq jr js fq lw lx ly lz aw ma dt"><span id="97d1" class="kf kg ht lx b fv mb mc l md me">$ curl -H "Content-Type: application/json" --request POST -d '{"name":"John Doe","gender":"male"}' <a class="ae ke" href="http://localhost:5000/blockchain/user" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/blockchain/user</a></span></pre><p id="c654" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你可以在这里找到完整的代码<a class="ae ke" href="https://github.com/NehaGhogale/basic_user_contract" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1b41" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">资源:</strong></p><ol class=""><li id="09d8" class="ln lo ht is b it iu ix iy jb ml jf mm jj mn jn ls lt lu lv dt translated"><a class="ae ke" href="http://web3py.readthedocs.io/en/stable/quickstart.html" rel="noopener ugc nofollow" target="_blank">http://web3py.readthedocs.io/en/stable/quickstart.html</a></li><li id="ff6d" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn ls lt lu lv dt translated"><a class="ae ke" href="https://www.ethereum.org/greeter" rel="noopener ugc nofollow" target="_blank">https://www.ethereum.org/greeter</a></li><li id="c8a8" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn ls lt lu lv dt translated"><a class="ae ke" href="http://solidity.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">http://solidity.readthedocs.io/en/latest/</a></li></ol><blockquote class="mx"><p id="d990" class="my mz ht bd na nb nc nd ne nf ng jn ek translated">加入Coinmonks <a class="ae ke" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ke" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae ke" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="kf kg ht bd kh ki nh kk kl km ni ko kp jb nj kr ks jf nk ku kv jj nl kx ky kz dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="ln lo ht is b it la ix lb jb lp jf lq jj lr jn nm lt lu lv dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated"><a class="ae ke" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae ke" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="f33b" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae ke" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated">面向开发者的最佳加密API</li><li id="f1dd" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated"><a class="ae ke" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="b359" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated">最佳<a class="ae ke" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li><li id="95d1" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated"><a class="ae ke" href="https://coincodecap.com/best-vpns-for-crypto-trading" rel="noopener ugc nofollow" target="_blank">加密交易的最佳VPN</a></li><li id="918f" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated"><a class="ae ke" href="https://coincodecap.com/huobi-crypto-trading-signals" rel="noopener ugc nofollow" target="_blank">火币加密交易信号</a> | <a class="ae ke" rel="noopener" href="/coinmonks/hitbtc-review-c5143c5d53c2"> HitBTC审核</a></li><li id="58f1" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated"><a class="ae ke" href="https://coincodecap.com/traderwagon-review" rel="noopener ugc nofollow" target="_blank"> TraderWagon回顾</a> | <a class="ae ke" href="https://coincodecap.com/kraken-vs-gemini-vs-bityard" rel="noopener ugc nofollow" target="_blank">北海巨妖vs双子vs比特亚德</a></li><li id="ad10" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated">如何在FTX交易所交易期货</li><li id="71f4" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated"><a class="ae ke" href="https://coincodecap.com/okex-kucoin" rel="noopener ugc nofollow" target="_blank"> OKEx vs KuCoin </a> | <a class="ae ke" href="https://coincodecap.com/celsius-alternatives" rel="noopener ugc nofollow" target="_blank">摄氏替代品</a> | <a class="ae ke" href="https://coincodecap.com/buy-vechain" rel="noopener ugc nofollow" target="_blank">如何购买VeChain </a></li><li id="e6a8" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated"><a class="ae ke" href="https://coincodecap.com/3commas-vs-pionex-vs-cryptohopper" rel="noopener ugc nofollow" target="_blank">3 commas vs . Pionex vs . crypto hopper</a></li><li id="0539" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated"><a class="ae ke" href="https://coincodecap.com/cornix-trading-bot" rel="noopener ugc nofollow" target="_blank">如何使用Cornix交易机器人</a></li><li id="7ed0" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated"><a class="ae ke" href="https://coincodecap.com/bitget-review" rel="noopener ugc nofollow" target="_blank"> Bitget回顾</a>|<a class="ae ke" href="https://coincodecap.com/gemini-vs-blockfi" rel="noopener ugc nofollow" target="_blank">Gemini vs block fi</a>cmd |<a class="ae ke" href="https://coincodecap.com/okex-futures-trading" rel="noopener ugc nofollow" target="_blank">OKEx期货交易</a></li><li id="60b3" class="ln lo ht is b it ms ix mt jb mu jf mv jj mw jn nm lt lu lv dt translated"><a class="ae ke" href="https://coincodecap.com/buy-crypto-with-credit-card" rel="noopener ugc nofollow" target="_blank">用信用卡购买密码的10个最佳地点</a></li></ul></div></div>    
</body>
</html>