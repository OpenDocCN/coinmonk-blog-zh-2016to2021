<html>
<head>
<title>Testing Solidity with Truffle and Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Truffle和Async/Await测试可靠性</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/testing-solidity-with-truffle-and-async-await-396e81c54f93?source=collection_archive---------2-----------------------#2017-08-10">https://medium.com/coinmonks/testing-solidity-with-truffle-and-async-await-396e81c54f93?source=collection_archive---------2-----------------------#2017-08-10</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/4981b61bfe1bcc3db2b3b473cd499eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZAGvxMAcqAPNhiohTAyR3w.png"/></div></div></figure><p id="e842" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果你问一个程序员/开发者工作中最糟糕的部分是什么，我想大多数人会说写测试。您必须创建模拟数据并进行编码反转，以使特定的东西正常工作。除此之外，你必须为一个特性/功能编写许多不同的案例。编写好的测试需要很多时间。但是随着node 8中async/await的引入，编写测试变得更好了！这就是我们用来为<a class="ae jz" href="https://www.hellosugoi.com/" rel="noopener ugc nofollow" target="_blank"> HelloSugoi </a>创建超过100个测试的<a class="ae jz" rel="noopener" href="/hello-sugoi/building-100-tests-for-hellosugoi-ebde9a6c62d">。</a></p><blockquote class="ka"><p id="1e68" class="kb kc ht bd kd ke kf kg kh ki kj jy ek translated"><a class="ae jz" href="https://coincodecap.com" rel="noopener ugc nofollow" target="_blank">发现并回顾最佳区块链软件</a></p></blockquote></div><div class="ab cl kk kl hb km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hm hn ho hp hq"><h2 id="ea74" class="kr ks ht bd kt ku kv kw kx ky kz la lb jm lc ld le jq lf lg lh ju li lj lk ll dt translated">观众:</h2><p id="efc4" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">主要面向用Solidity编写以太坊应用程序和用Javascript编写代码测试的开发人员。对于任何对async/await及其如何帮助编写更好的测试感兴趣的人来说。</p><h2 id="f2ad" class="kr ks ht bd kt ku kv kw kx ky kz la lb jm lc ld le jq lf lg lh ju li lj lk ll dt translated">要求/安装:</h2><p id="be4e" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">对于节点8，async/await默认启用。在7.6版本之前，只要添加了<code class="eh lr ls lt lu b">--harmony-async-await</code>标志，就可以使用async/await。对于之前的版本，你也可以使用<a class="ae jz" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>向下转换到ES5兼容的javascript。我建议安装Node 8或以上，这个项目才能正常工作。您可以使用<a class="ae jz" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">自制软件</a>或<a class="ae jz" href="https://github.com/creationix/nvm" rel="noopener ugc nofollow" target="_blank"> nvm </a>来管理您正在使用的版本。</p><p id="8447" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">除了安装node之外，您还需要在全球范围内安装<a class="ae jz" href="https://github.com/trufflesuite/truffle" rel="noopener ugc nofollow" target="_blank"> Truffle </a>和<a class="ae jz" href="https://github.com/trufflesuite/ganache-cli" rel="noopener ugc nofollow" target="_blank"> Ganache-cli </a>。</p><ol class=""><li id="08c1" class="lv lw ht jd b je jf ji jj jm lx jq ly ju lz jy ma mb mc md dt translated"><code class="eh lr ls lt lu b">npm install -g truffle</code></li><li id="0e8c" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy ma mb mc md dt translated"><code class="eh lr ls lt lu b">npm install -g </code>加纳切-cli</li></ol><p id="ab4b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae jz" href="https://github.com/trufflesuite/truffle" rel="noopener ugc nofollow" target="_blank"> Truffle </a>用于编译和迁移实体契约到以太网上。<a class="ae jz" href="https://github.com/trufflesuite/ganache-cli" rel="noopener ugc nofollow" target="_blank"> Ganache-cli </a>作为伪以太坊节点，立即返回，而不是15秒。要确认您已经安装了所有组件，请尝试以下操作:</p><ol class=""><li id="62bc" class="lv lw ht jd b je jf ji jj jm lx jq ly ju lz jy ma mb mc md dt translated">Node ≥ 7.6在命令行输入<code class="eh lr ls lt lu b">node -v</code>确认</li><li id="c60c" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy ma mb mc md dt translated">通过在命令行中输入<code class="eh lr ls lt lu b">npm -v</code>来确认npm ≥ 4</li><li id="074b" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy ma mb mc md dt translated"><a class="ae jz" href="https://github.com/trufflesuite/truffle" rel="noopener ugc nofollow" target="_blank">松露</a> ≥ 3.3在命令行输入<code class="eh lr ls lt lu b">truffle -v</code>确认</li><li id="2116" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy ma mb mc md dt translated"><a class="ae jz" href="https://github.com/trufflesuite/ganache-cli" rel="noopener ugc nofollow" target="_blank"> Ganache-cli </a> ≥ 5.0.0在命令行输入<code class="eh lr ls lt lu b">ganache-cli -v</code>确认</li></ol><h2 id="f3f8" class="kr ks ht bd kt ku kv kw kx ky kz la lb jm lc ld le jq lf lg lh ju li lj lk ll dt translated">项目设置示例:</h2><p id="8ad4" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">我有一个例子项目回购与我们所有的代码。如果您想使用它，请克隆并安装它的依赖项。</p><ol class=""><li id="6a2e" class="lv lw ht jd b je jf ji jj jm lx jq ly ju lz jy ma mb mc md dt translated">git克隆<a class="ae jz" href="https://github.com/sogoiii/truffle-async-await-tests" rel="noopener ugc nofollow" target="_blank">https://github.com/sogoiii/truffle-async-await-tests</a></li><li id="ad31" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy ma mb mc md dt translated"><code class="eh lr ls lt lu b">cd truffle-async-await-tests</code></li><li id="aedf" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy ma mb mc md dt translated"><code class="eh lr ls lt lu b">npm install</code>或<code class="eh lr ls lt lu b">yarn install</code></li><li id="cffa" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy ma mb mc md dt translated"><code class="eh lr ls lt lu b">truffle compile</code></li><li id="7496" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy ma mb mc md dt translated"><code class="eh lr ls lt lu b">truffle test</code></li></ol><p id="2d98" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第四个命令运行所有测试，它们应该成功完成。</p><h2 id="75bb" class="kr ks ht bd kt ku kv kw kx ky kz la lb jm lc ld le jq lf lg lh ju li lj lk ll dt translated">异步/等待的工作原理:</h2><p id="6cb3" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">从概念上讲，async/await使异步JavaScript代码看起来像同步代码。让我们比较一下这两者:</p><figure class="mj mk ml mm fq iu"><div class="bz el l di"><div class="mn mo l"/></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">Comparing simple truffle test as promise chain or async/await</figcaption></figure><p id="5961" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">从上面的例子中，我认为<code class="eh lr ls lt lu b">status2</code>方法看起来比<code class="eh lr ls lt lu b">status</code>方法更干净。它实际上有4行样板文件，比<code class="eh lr ls lt lu b">status2</code>中的3行逻辑还要多。我觉得选择很容易！</p><p id="4110" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要使用async/await，您需要将<code class="eh lr ls lt lu b">async</code>名字添加到函数声明中。这告诉v8解释器寻找<code class="eh lr ls lt lu b">await</code>键，否则node抛出一个错误，询问<code class="eh lr ls lt lu b">await</code>是什么。你把<code class="eh lr ls lt lu b">await</code>放在任何promise函数/方法前面，不是回调！如果你的函数是回调函数，我建议使用像<a class="ae jz" href="http://bluebirdjs.com/docs/api-reference.html" rel="noopener ugc nofollow" target="_blank">蓝鸟</a>或者Node 8中引入的原生<a class="ae jz" href="http://2ality.com/2017/05/util-promisify.html" rel="noopener ugc nofollow" target="_blank"> promisify方法</a>这样的包。幸运的是，<a class="ae jz" href="https://github.com/trufflesuite/truffle" rel="noopener ugc nofollow" target="_blank">松露</a>回报的是承诺而不是回调。</p><p id="dc49" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一个异步函数(<code class="eh lr ls lt lu b">async function(){}</code>)也返回一个承诺！这很好，因为如果需要的话，您可以链接承诺或异步函数。如下例所示:</p><figure class="mj mk ml mm fq iu"><div class="bz el l di"><div class="mn mo l"/></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">Async returns a promise</figcaption></figure><p id="b2f1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">不久前，async/await遇到了相当大的性能冲击。它足够大，不使用async/await是合理的。自从<a class="ae jz" href="https://v8project.blogspot.com/2016/10/v8-release-55.html" rel="noopener ugc nofollow" target="_blank"> v8 5.5发布以来，性能</a>变得越来越好。除非您正在做计算量很大的事情，否则使用async/await可能是一个不错的选择。</p><h2 id="d560" class="kr ks ht bd kt ku kv kw kx ky kz la lb jm lc ld le jq lf lg lh ju li lj lk ll dt translated">示例(简单情况):</h2><p id="38e3" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated"><a class="ae jz" href="https://github.com/trufflesuite/truffle" rel="noopener ugc nofollow" target="_blank">松露</a>好吃是因为<code class="eh lr ls lt lu b">.deployed</code>还一个承诺。记住，承诺面前只有等待的地方！</p><p id="b4ae" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">打开<code class="eh lr ls lt lu b">test/metacoin.js</code>文件，查看第一个测试。</p><figure class="mj mk ml mm fq iu"><div class="bz el l di"><div class="mn mo l"/></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">Truffle easy test example</figcaption></figure><p id="5c3d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第一次测试只做了3个操作。第一个是获取已部署的契约JavaScript对象，并将其设置为变量<code class="eh lr ls lt lu b">meta</code>。然后调用<code class="eh lr ls lt lu b">await</code>关键字后面的函数<code class="eh lr ls lt lu b">getBalance.call()</code>函数。同样，这是因为<code class="eh lr ls lt lu b">.call</code>返回一个承诺。最后，我们简单地检查函数是否在断言中返回了预期的值。很简单！它的所有检查是根据测试标题检查<code class="eh lr ls lt lu b">meta</code>的余额是否为<code class="eh lr ls lt lu b">1000</code>。</p><p id="54a2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当您在命令行中运行<code class="eh lr ls lt lu b">truffle test test/metacoin.js</code>时，您将看到所有测试是如何成功运行的。</p><h2 id="a0d9" class="kr ks ht bd kt ku kv kw kx ky kz la lb jm lc ld le jq lf lg lh ju li lj lk ll dt translated">示例(错误情况):</h2><p id="1a75" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">要用async/await捕获错误，您需要将调用包装在try/catch中。</p><figure class="mj mk ml mm fq iu"><div class="bz el l di"><div class="mn mo l"/></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">Truffle fail test example</figcaption></figure><p id="7141" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上面的测试中，我调用了一个我知道在Solidity契约中不存在的函数。<code class="eh lr ls lt lu b">Await</code>将抛出一个在try/catch中被捕获的错误。因为我想验证调用<code class="eh lr ls lt lu b">someNonExistentFn</code>是否抛出错误，所以我在catch中返回true以退出测试。如果<code class="eh lr ls lt lu b">await meta.someNonExistentFn()</code>成功，catch块将不会被调用，下一行<code class="eh lr ls lt lu b">throw new Error(...)</code>将被命中。从而告诉我函数没有抛出。</p><h2 id="f9f1" class="kr ks ht bd kt ku kv kw kx ky kz la lb jm lc ld le jq lf lg lh ju li lj lk ll dt translated">示例(时间旅行):</h2><p id="8a32" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">有时，一个可靠契约可能有一个只有在将来被调用时才起作用的功能。在<code class="eh lr ls lt lu b">MetaCoin.sol</code>中，我给<code class="eh lr ls lt lu b">specialFn</code>添加了<code class="eh lr ls lt lu b">onlyAfterDate</code>函数修饰符，在这里我定义了将来什么时候可以调用一个函数。</p><figure class="mj mk ml mm fq iu"><div class="bz el l di"><div class="mn mo l"/></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">MetaCoin.sol with time info only</figcaption></figure><p id="b5f0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在元币构造函数内部，我手动将<code class="eh lr ls lt lu b">endTime</code>设置为<code class="eh lr ls lt lu b">1 days</code>。固体中的时间变量是纪元秒的<code class="eh lr ls lt lu b">uint</code>。<code class="eh lr ls lt lu b">onlyAfterDate</code>函数修饰符使用<code class="eh lr ls lt lu b">endTime</code>，这意味着任何带有<code class="eh lr ls lt lu b">onlyAfterDate</code>的函数都只能在<code class="eh lr ls lt lu b">1 days</code>中被调用。</p><p id="0a83" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了测试这项功能，我们不会等一整天！当时间更加动态而不是硬编码时会发生什么？Ganache-cli 增加了一个名为<code class="eh lr ls lt lu b">evm_increaseTime</code>的RPC方法，它将穿越区块链。</p><figure class="mj mk ml mm fq iu"><div class="bz el l di"><div class="mn mo l"/></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">Ganache-cli evm_increaseTime as a promise</figcaption></figure><p id="71fa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们所要做的就是用<code class="eh lr ls lt lu b">evn_increaseTime</code>和params对web3进行RPC调用。我将基于回调的web3封装到一个promise中，这样我们可以将它与async/await一起使用。</p><p id="34d9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有了这个新功能，我们只需简单地用一个时间和嘣！都过了几天了！如果您使用的是<a class="ae jz" href="https://github.com/ethereumjs/testrpc" rel="noopener ugc nofollow" target="_blank"> Testrpc </a> 4.0.0(以及旧版本的ganache-cli)，那么会有一个bug，必须挖掘一个块才能使<code class="eh lr ls lt lu b">evm_timeTravel</code>生效。你可以在这里查看bug<a class="ae jz" href="https://github.com/ethereumjs/testrpc/issues/336" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="mj mk ml mm fq iu"><div class="bz el l di"><div class="mn mo l"/></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">Successful time travel with Truffle and Ganache-cli</figcaption></figure><h2 id="5181" class="kr ks ht bd kt ku kv kw kx ky kz la lb jm lc ld le jq lf lg lh ju li lj lk ll dt translated">大对比:</h2><p id="5e15" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">下面的两个片段测试了完全相同的东西。唯一的区别是一个写为承诺链，另一个写为async/await。只是把重点讲清楚！</p><figure class="mj mk ml mm fq iu"><div class="bz el l di"><div class="mn mo l"/></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">Large Promise Chain Truffle Test</figcaption></figure><figure class="mj mk ml mm fq iu"><div class="bz el l di"><div class="mn mo l"/></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">Large Async/Await Truffle Test</figcaption></figure><h2 id="d324" class="kr ks ht bd kt ku kv kw kx ky kz la lb jm lc ld le jq lf lg lh ju li lj lk ll dt translated">结论:</h2><p id="5545" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">我希望您能看到async/await的测试有多好。许多样板文件消失了，这增加了可读性。捕捉错误可能更繁琐，但它们是可以管理的。另外，如果您需要为您的测试进行时间旅行，<a class="ae jz" href="https://github.com/trufflesuite/ganache-cli" rel="noopener ugc nofollow" target="_blank"> Ganache-cli </a>提供了一种更新时间的方法。如果您已经在使用promises，那么与async/await集成是非常容易的。如果你有很多回调，那么使用<code class="eh lr ls lt lu b">require('utils').promisify</code>让你的生活变得简单。看到趋势了吗？</p><blockquote class="ka"><p id="2526" class="kb kc ht bd kd ke kf kg kh ki kj jy ek translated">加入Coinmonks <a class="ae jz" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jz" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae jz" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="kr ks ht bd kt ku mt kw kx ky mu la lb jm mv ld le jq mw lg lh ju mx lj lk ll dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="lv lw ht jd b je lm ji ln jm my jq mz ju na jy nb mb mc md dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae jz" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy nb mb mc md dt translated"><a class="ae jz" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae jz" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy nb mb mc md dt translated"><a class="ae jz" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae jz" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy nb mb mc md dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae jz" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="6474" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy nb mb mc md dt translated"><a class="ae jz" href="https://coincodecap.com/bitget-review" rel="noopener ugc nofollow" target="_blank"> Bitget回顾</a> | <a class="ae jz" href="https://coincodecap.com/gemini-vs-blockfi" rel="noopener ugc nofollow" target="_blank">双子星vs BlockFi </a> | <a class="ae jz" href="https://coincodecap.com/okex-futures-trading" rel="noopener ugc nofollow" target="_blank"> OKEx期货交易</a></li><li id="c009" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy nb mb mc md dt translated"><a class="ae jz" href="https://coincodecap.com/crypto-trading-bots-in-the-us" rel="noopener ugc nofollow" target="_blank">美国最佳加密交易机器人</a> | <a class="ae jz" href="https://coincodecap.com/changelly-review" rel="noopener ugc nofollow" target="_blank">经常性回顾</a></li><li id="7716" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy nb mb mc md dt translated"><a class="ae jz" href="https://coincodecap.com/crypto-arbitrage-in-india" rel="noopener ugc nofollow" target="_blank">在印度利用加密套利赚取被动收入</a></li><li id="92d8" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy nb mb mc md dt translated"><a class="ae jz" href="https://coincodecap.com/huobi-review" rel="noopener ugc nofollow" target="_blank">霍比评论</a> | <a class="ae jz" href="https://coincodecap.com/okex-margin-trading" rel="noopener ugc nofollow" target="_blank"> OKEx保证金交易</a> | <a class="ae jz" href="https://coincodecap.com/futures-trading" rel="noopener ugc nofollow" target="_blank">期货交易</a></li><li id="47a8" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy nb mb mc md dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">面向开发人员的最佳加密API</a></li><li id="b359" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy nb mb mc md dt translated">最佳<a class="ae jz" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="lv lw ht jd b je me ji mf jm mg jq mh ju mi jy nb mb mc md dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币的终极指南</a></li></ul></div></div>    
</body>
</html>