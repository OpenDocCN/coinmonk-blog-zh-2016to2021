# 散列法简介

> 原文：<https://medium.com/coinmonks/gentle-introduction-to-hashing-61295dbcc0c5?source=collection_archive---------1----------------------->

![](img/1f157388436bfccad777aa97bcb6303c.png)

**简介**

假设我们有一个雇员记录列表，我们需要搜索一个雇员。你想到的数据结构是什么？链表，树，数组？

让我们看看每一个的时间复杂度。

1.  链表:查找一个元素的时间是 O(n)。

2.二分搜索法树:O(log n)假设我们有一棵平衡的树。

3.Arrays: O(1)假设我们知道每个记录的索引。

哈希利用了数组的这一特性。主要是在 O(1)时间内获取元素。

**那么我们如何实现这一目标呢？**

对于每个记录，我们在数组中计算一个相应的索引。为此，我们可以使用哈希函数。一个非常基本的哈希函数可以是 H(k) = k mod 11，其中 k 是输入值。

示例—假设我们有以下要插入的员工 Id 列表{101，220，452，321，600}数组的大小为 5，要使用的哈希函数为 H(k) = k mod 5。让我们计算每个输入的哈希值。

H(101)= 101 mod 5 = 1
H(220)= 220 mod 5 = 0
H(304)= 304 mod 5 = 4
H(303)= 303 mod 5 = 3
H(202)= 202 mod 5 = 2

如你所见，我们得到了以下映射(101，1)，(220，0)，(304，4)，(303，3)，(202，2)。元素存储在数组中这些各自的索引处。

在检索时，我们再次使用散列函数。因此，如果我们想要 id 为 304 的用户，我们执行 H(304) = 4，后跟雇员[4]。简单不是吗。

哈希表往往是**最好的数据结构**来维护**字典**。还有其他的应用。

**哈希问题**

你可能已经注意到，如果我们有多个元素得到相同的哈希值，那么我们该怎么办？比如，如果我们有一个数字 600，那么它就是 H(600) = 0，但是我们在索引 0 处已经有 220 了。现在怎么办？这个问题被称为碰撞。不管哈希函数有多好，冲突总是会发生的。

> [直接在您的收件箱中获得最佳软件交易](https://coincodecap.com/?utm_source=coinmonks)

[![](img/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png)](https://coincodecap.com/?utm_source=coinmonks)

为了**解决**这个我们有几种方法:

1.**链接**是一个简单的解决方案。我们可以通过使用链表方法将元素存储在同一个桶中。于是哈希表就变成了链表的数组(让我想起了用来存储图的邻接表)。问题是空间被指针消耗了。
2。**开放式寻址**是另一种使用探测的流行方法。我们继续重新计算哈希值，直到找到一个空桶。也可以用类似的方式搜索元素。但是删除会有一些问题。就像当我们删除一个元素时，槽是空的。考虑尝试查找一个元素，该元素的位置应该在被删除元素的旁边。一个解决方案可以是用某个东西标记被删除的槽，并在下一次插入时使用它。

探测可以分为线性探测、二次探测和双重散列。

在本文中，我不会深入讨论这些方法的细节。

**总结**

总之，我们看到了一种在检索元素时非常有效的数据结构。我们也看到了与散列相关的问题。