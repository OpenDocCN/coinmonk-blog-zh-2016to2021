<html>
<head>
<title>SMTChecker: (almost) practical superpower</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(几乎)实用的超级大国</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/smtchecker-almost-practical-superpower-5a3efdb3cf19?source=collection_archive---------1-----------------------#2021-08-31">https://medium.com/coinmonks/smtchecker-almost-practical-superpower-5a3efdb3cf19?source=collection_archive---------1-----------------------#2021-08-31</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><h1 id="bf80" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">理论:什么是SMTChecker？</h1><p id="9eab" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">你会拿你的第一个孩子打赌你刚刚部署的契约没有严重的漏洞吗？如果你和我一样，答案是响亮的“不”。</p><p id="f703" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我在传统软件工程中见过足够多的黑客，知道你永远不可能100%确定。这很可怕，但是不同技术的结合可以让我们非常接近期望的信心水平。<a class="ae kr" href="https://docs.soliditylang.org/en/v0.8.7/smtchecker.html" rel="noopener ugc nofollow" target="_blank"> SMTChecker </a>就是其中之一。</p><p id="3001" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">它是一个对你的契约进行正式验证的工具:你定义一个规范(你认为你的契约应该做什么)，SMTChecker正式证明契约符合规范。如果没有，SMTChecker通常会给出一个具体的反例:一系列违反规范的事务。</p><p id="1c30" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">最棒的是。如果你使用Solidity，你已经有了SMT checker——它是Solidity编译器的一部分。</p><p id="19e4" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">无论如何，这都不是一个万无一失的解决方案——存在缺陷，验证缓慢。最重要的是，很难定义一个完整的规范。但即使知道这一点，还是值得一试。</p><h2 id="15fa" class="ks ir ht bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf dt translated">示例:跳棋</h2><p id="1c4b" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">契约实现了一个计数器——在一个8x8的棋盘上玩的跳棋游戏中的一个棋子。</p><p id="a25c" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们将实现一个(虚构的)“懒惰计数器”:它不能移动，但可以通过“跳过”它们来捕获对角相邻单元格上的块:如果我在(0，0)处，想在(1，1)处捕获一块，我将在(2，2)处结束。简单。</p><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="28b4" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">代码很简单:我们在给定的位置创建一个计数器。然后它可以捕捉其他部分。</p><p id="61cc" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">有趣的是最后一个函数——它定义了一个在任何时候都必须成立的不变量。不变量很简单——计数器不能离开棋盘。让我们编译契约，看看我们的不变量是否被打破(注意额外的<code class="eh ln lo lp lq b">solc</code>参数——它们在<a class="ae kr" href="https://docs.soliditylang.org/en/v0.8.7/smtchecker.html#timeout" rel="noopener ugc nofollow" target="_blank">激进</a>但<a class="ae kr" href="https://docs.soliditylang.org/en/v0.8.7/smtchecker.html#constrained-horn-clauses-chc" rel="noopener ugc nofollow" target="_blank">精确</a>模式下打开SMTChecker):</p><pre class="lg lh li lj fq lr lq ls lt aw lu dt"><span id="609b" class="ks ir ht lq b fv lv lw l lx ly">~/src/smtchecker_demo ❯❯❯ solc 1.sol --model-checker-engine chc --model-checker-show-unproved --model-checker-timeout 0<br/>Warning: CHC: Assertion violation happens here.<br/>Counterexample:<br/>x = 0, y = 8</span><span id="280e" class="ks ir ht lq b fv lz lw l lx ly">Transaction trace:<br/>LazyCounter.constructor(2, 6)<br/>State: x = 2, y = 6<br/>LazyCounter.capture(1, 7)<br/>State: x = 0, y = 8<br/>LazyCounter.invariant()<br/>  --&gt; 1.sol:32:9:<br/>   |<br/>32 |         assert(x &gt;= 0 &amp;&amp; x &lt; 8 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 8);<br/>   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></pre><p id="9894" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">哎呀，我们的不变量坏了。SMTChecker甚至给了我们一个反例！如果我们的棋子在(2，6)处，并且它在(1，7)处捕获了该棋子，那么它在棋盘之外的(0，8)处结束。我们忘记在捕获后检查计数器位置的有效性。</p><p id="6f40" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们给了它一个契约，其中包含一组操作边界(定义一组有效输入的<code class="eh ln lo lp lq b">require</code>语句)和一个不变量。SMTChecker进行了<strong class="jq hu">详尽的分析</strong>:将<strong class="jq hu">所有公共函数</strong>与<strong class="jq hu">所有可能的输入</strong>以<strong class="jq hu">所有可能的组合</strong>循环调用。实际上，它并没有采用暴力的方式(那太昂贵了)，而是依靠<em class="ma">数学</em>来实现(我不会假装完全理解这一点，这里<a class="ae kr" href="https://docs.soliditylang.org/en/v0.8.7/smtchecker.html#smt-and-horn-solvers" rel="noopener ugc nofollow" target="_blank">有一些细节</a>)。</p><p id="f1f3" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">下面是另一个例子，说明了SMTChecker尝试用长序列的事务来测试不变量:一个实现了象棋骑士的契约。我们将添加一个我们知道无效的不变量，只是为了给SMTChecker一些线索:骑士无法到达(7，7)位置。SMTChecker还会给我们一个反例。</p><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="ll lm l"/></div></figure><pre class="lg lh li lj fq lr lq ls lt aw lu dt"><span id="57c3" class="ks ir ht lq b fv lv lw l lx ly">~/src/smtchecker_demo ❯❯❯ solc 2.sol --model-checker-engine chc --model-checker-show-unproved --model-checker-timeout 0<br/>Warning: CHC: Assertion violation happens here.<br/>Counterexample:<br/>x = 7, y = 7</span><span id="e353" class="ks ir ht lq b fv lz lw l lx ly">Transaction trace:<br/>Knight.constructor()<br/>State: x = 0, y = 0<br/>Knight.move2()<br/>    Knight.isValidPosition() -- internal call<br/>State: x = 2, y = 1<br/>Knight.move2()<br/>    Knight.isValidPosition() -- internal call<br/>State: x = 4, y = 2<br/>Knight.move5()<br/>    Knight.isValidPosition() -- internal call<br/>State: x = 3, y = 4<br/>Knight.move1()<br/>    Knight.isValidPosition() -- internal call<br/>State: x = 4, y = 6<br/>Knight.move3()<br/>    Knight.isValidPosition() -- internal call<br/>State: x = 6, y = 5<br/>Knight.move1()<br/>    Knight.isValidPosition() -- internal call<br/>State: x = 7, y = 7<br/>Knight.get_to_7_7()<br/>  --&gt; 2.sol:61:9:<br/>   |<br/>61 |         assert(!(x == 7 &amp;&amp; y == 7));<br/>   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></pre><p id="484b" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">真棒。它给出了将骑士从(0，0)移动到(7，7)的步骤序列。</p><h1 id="f28d" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">实践</h1><p id="37f2" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><em class="ma">免责声明:其他一切都是一个大实验，看看如何让它在‘生产环境’中有用。可能还有其他的方法，我并不自称已经找到了。</em></p><p id="230b" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">让我们做一些更实际的事情:AMM的一部分:流动性提供者给交易对增加流动性，但实际上没有人可以交易。</p><ul class=""><li id="b2e7" class="mb mc ht jq b jr km jv kn jz md kd me kh mf kl mg mh mi mj dt translated">建设完成后，业主交存若干(<code class="eh ln lo lp lq b">x</code> ) X代币和若干(<code class="eh ln lo lp lq b">y</code> ) Y代币。AMM生成<code class="eh ln lo lp lq b">x * y</code> LP代币</li><li id="3e59" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated">任何人都可以存入<code class="eh ln lo lp lq b">x1</code> X和<code class="eh ln lo lp lq b">y1</code> Y代币，只要不改变X/Y余额比例(<code class="eh ln lo lp lq b">x1/y1 == xReserves / yReserves</code>)。AMM生成<code class="eh ln lo lp lq b">totalSupply(LP) * (x1 / xReserves)</code> LP代币</li><li id="a3c0" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated">我们仅支持小数位数为()的定点ERC20代币== 18</li></ul><p id="0bb3" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">就是这样。我们甚至没有分发LP代币，只是生成代币。</p><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="07ec" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们可以加上哪些不变量？没多少——或许外汇储备并不是空的，但仅此而已。</p><p id="d9c1" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">让我们将不变量的定义转向另一面，称之为“动态不变量”:了解执行<code class="eh ln lo lp lq b">addLiquidity</code>前后的状态，我们能断言什么？</p><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="5f3c" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">请注意末尾的<code class="eh ln lo lp lq b">revert()</code>，它确保不变函数没有副作用(可以将其视为<code class="eh ln lo lp lq b">view</code>函数)。让我们来试试吧！</p><pre class="lg lh li lj fq lr lq ls lt aw lu dt"><span id="7b99" class="ks ir ht lq b fv lv lw l lx ly">~/src/smtchecker_demo ❯❯❯ solc --model-checker-engine chc --model-checker-show-unproved --model-checker-timeout 0 --model-checker-contracts 3.sol<br/>...</span></pre><p id="f461" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">这需要一段时间(最多几个小时)。对于1个简单不变量来说不够实用。</p><p id="a295" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">什么会让它变慢？我猜是地址和外部调用(<code class="eh ln lo lp lq b">transferFrom</code> ) — SMTChecker将它们建模为可以做任何事情的未知函数，包括回调你的合同。这很好也很有用(它们<a class="ae kr" href="https://docs.soliditylang.org/en/v0.8.7/smtchecker.html#external-calls-and-reentrancy" rel="noopener ugc nofollow" target="_blank">可以发现可重入性问题</a>)，但是对于我们的场景来说不实用。</p><p id="c6e8" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们将重新构建合同:将所有外部通信分离到一个单独的合同中。我们的“核心”合同将保持最小状态，只是一个数字处理器。额外的好处是——它使得跟随CEI(检查-效果-互动)几乎是自动的。</p><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="8fac" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated"><code class="eh ln lo lp lq b">AMMPairEngine</code>有<code class="eh ln lo lp lq b">addLiquidityStateChange</code>作为内部函数。本来打算叫<code class="eh ln lo lp lq b">AMMPair</code>(继承自<code class="eh ln lo lp lq b">AMMPairEngine</code>)。<code class="eh ln lo lp lq b">AMMPairEngine</code>仅有的公共函数是不变量。如果我们不希望它们出现在已部署的代码中，可以将它们移到<code class="eh ln lo lp lq b">AMMPairEngineTest is AMMPairEngine</code>契约中。</p><pre class="lg lh li lj fq lr lq ls lt aw lu dt"><span id="140e" class="ks ir ht lq b fv lv lw l lx ly">~/src/smtchecker_demo ❯❯❯ time solc --model-checker-engine chc --model-checker-show-unproved --model-checker-timeout 0 --model-checker-contracts 3.sol:AMMPairEngine 3.sol<br/>Warning: CHC: Division by zero happens here.<br/>Counterexample:<br/>xReserves = 2, yReserves = 2, totalSupply = 0<br/>depositX = 1<br/>depositY = 1<br/>oldSupply = 0<br/>oldXReserves = 1<br/>supplyAdded = 0</span><span id="7cad" class="ks ir ht lq b fv lz lw l lx ly">Transaction trace:<br/>AMMPairEngine.constructor(1, 1)<br/>State: xReserves = 1, yReserves = 1, totalSupply = 0<br/>AMMPairEngine.invariantAddLiquidity(1, 1)<br/>    AMMPairEngine.addLiquidityStateChange(1, 1) -- internal call<br/>   --&gt; 3.sol:117:43:<br/>    |<br/>117 |         assert(depositX / oldXReserves == supplyAdded / oldSupply);<br/>    |                                           ^^^^^^^^^^^^^^^^^^^^^^^</span><span id="5777" class="ks ir ht lq b fv lz lw l lx ly">Warning: CHC: Assertion violation happens here.<br/>   --&gt; 3.sol:117:9:<br/>    |<br/>117 |         assert(depositX / oldXReserves == supplyAdded / oldSupply);<br/>    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span id="7ab9" class="ks ir ht lq b fv lz lw l lx ly">solc --model-checker-engine chc --model-checker-show-unproved  0   3.sol  7.11s user 0.17s system 98% cpu 7.357 total</span></pre><p id="bfa2" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">被零除会导致断言冲突。反例(<code class="eh ln lo lp lq b">depositX = 1; depositY = 1; oldSupply = 0</code>)让问题显而易见:契约创建者存放了X的1e-18和Y令牌的1e-18。这使得合约发行了0个LP令牌(1e-36太小，无法用18进制定点数学表示)。我们将切换到36位十进制数学，这应该可以解决这个问题:</p><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="ll lm l"/></div></figure><pre class="lg lh li lj fq lr lq ls lt aw lu dt"><span id="6d76" class="ks ir ht lq b fv lv lw l lx ly">~/src/smtchecker_demo ❯❯❯ time solc --model-checker-engine chc --model-checker-show-unproved --model-checker-timeout 0 --model-checker-contracts 3.sol:AMMPairEngine 3.sol<br/>Warning: CHC: Assertion violation might happen here.<br/>   --&gt; 3.sol:117:9:<br/>    |<br/>117 |         assert(depositX / oldXReserves == supplyAdded / oldSupply);<br/>    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span id="1175" class="ks ir ht lq b fv lz lw l lx ly">solc --model-checker-engine chc --model-checker-show-unproved  0   3.sol  75.19s user 0.50s system 99% cpu 1:16.27 total</span></pre><p id="a527" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">注意变化:没有被零除，并且“断言违反<strong class="jq hu">发生在</strong>这里”现在是“断言违反<strong class="jq hu">可能发生在</strong>这里”。我认为将不确定性解释为“这里肯定没有断言违反”是不安全的，但这是部分成功。我需要做更多的调查来更好地了解这里发生了什么。</p><p id="dbf4" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated"><strong class="jq hu">更新09/05/2021</strong>:<a class="ae kr" href="https://twitter.com/leonardoalt" rel="noopener ugc nofollow" target="_blank">Leo Alt</a>指出‘可能发生’还不足以称之为‘部分成功’——SMT checker真的很难证明这个断言，所以我们真的不能依赖它:</p><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="mp lm l"/></div></figure><figure class="lg lh li lj fq lk"><div class="bz el l di"><div class="mp lm l"/></div></figure><p id="f9bf" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">FWIW，<a class="ae kr" href="https://github.com/sblOWPCKCR/smtchecker_demo/blob/main/z3.ipynb" rel="noopener ugc nofollow" target="_blank">您可以手动证明上一个示例中的数学公式</a>，但是这显然不可扩展。带有反例的原始代码中的断言冲突:</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff mq"><img src="../Images/46261f8ea7bca9e2102e678153113f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H28r2hdKhCL9JAgarE53iA.png"/></div></div></figure><p id="7c12" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">证明新代码中没有断言冲突:</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff mx"><img src="../Images/0527400dea4697b3140df4f5a9dca3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9k9Dwa8_Lba-4zTG68q9w.png"/></div></div></figure><h1 id="dfca" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">结论</h1><p id="8c93" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">SMTChecker可以成为你的个人超能力——它可能需要一些工作，你的合同需要牢记这一点。但是如果情况一致，每个人都可以享受自动正式验证的好处。</p><p id="97e3" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我希望花些时间深入了解SMTChecker，敬请关注。</p><h1 id="9762" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">可供选择的事物</h1><ol class=""><li id="3581" class="mb mc ht jq b jr js jv jw jz my kd mz kh na kl nb mh mi mj dt translated"><a class="ae kr" href="https://github.com/trailofbits/manticore" rel="noopener ugc nofollow" target="_blank">蝎狮</a>是一个符号执行引擎，可以做类似SMTChecker的事情。它是高度可编程的——一方面，它可以做更少的开箱即用的事情(<code class="eh ln lo lp lq b">invariantAddLiquidity</code>有两个参数，SMTChecker为它们探索了所有可能的输入；蝎狮做不到)。另一方面，这些东西是可实现的，加上我们对验证过程有更多的控制(也许我们可以对外部合同做一些假设？)</li><li id="6c6d" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl nb mh mi mj dt translated"><a class="ae kr" href="https://github.com/crytic/echidna" rel="noopener ugc nofollow" target="_blank">鼹鼠</a>是一个模糊化工具——使用类似的不变量概念，随机尝试寻找破坏它们的输入。它没有<strong class="jq hu">证明</strong>不变量成立(也许它只是没有发现一个边缘情况)，但可以很快发现许多非边缘情况的缺陷。鼹鼠使用相同的语法和蝎狮，所以它们可以并行使用(至少在理论上)。</li><li id="8781" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl nb mh mi mj dt translated"><a class="ae kr" href="https://consensys.net/diligence/scribble/" rel="noopener ugc nofollow" target="_blank"> Scribble </a>采取了不同的方法——你<strong class="jq hu">用动态不变量注释</strong>每个函数。对于不变量，它使用自己的语言，并且可以用物化的不变量来检测您的代码。</li><li id="8ce9" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl nb mh mi mj dt translated">无数的静态分析/其他模糊工具——它们非常有用，但是超出了本文的范围</li></ol><h1 id="c125" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">感谢</h1><p id="3749" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><a class="nc nd gr" href="https://medium.com/u/8206cbb70805?source=post_page-----5a3efdb3cf19--------------------------------" rel="noopener" target="_blank">阿尔贝托·单面山·卡尼亚达</a>对于上述大部分参考资料和小AMM的想法</p><blockquote class="ne"><p id="bab0" class="nf ng ht bd nh ni nj nk nl nm nn kl ek translated">加入Coinmonks <a class="ae kr" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae kr" href="https://www.youtube.com/channel/UCbyDhTbOiKh2iUMKBi4-4Zg" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h2 id="7402" class="ks ir ht bd is kt no kv iw kw np ky ja jz nq la je kd nr lc ji kh ns le jm lf dt translated">另外，阅读</h2><ul class=""><li id="a5d4" class="mb mc ht jq b jr js jv jw jz my kd mz kh na kl mg mh mi mj dt translated"><a class="ae kr" href="https://blog.coincodecap.com/bitget-review" rel="noopener ugc nofollow" target="_blank"> Bitget评论</a> | <a class="ae kr" href="https://blog.coincodecap.com/gemini-vs-blockfi" rel="noopener ugc nofollow" target="_blank">双子星vs BlockFi </a> | <a class="ae kr" href="https://blog.coincodecap.com/okex-futures-trading" rel="noopener ugc nofollow" target="_blank"> OKEx期货交易</a></li><li id="ff60" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated"><a class="ae kr" href="https://blog.coincodecap.com/okex-kucoin" rel="noopener ugc nofollow" target="_blank"> OKEx vs KuCoin </a> | <a class="ae kr" href="https://blog.coincodecap.com/celsius-alternatives" rel="noopener ugc nofollow" target="_blank">摄氏替代度</a> | <a class="ae kr" href="https://blog.coincodecap.com/buy-vechain" rel="noopener ugc nofollow" target="_blank">如何购买VeChain </a></li><li id="a961" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated"><a class="ae kr" href="https://blog.coincodecap.com/stormgain-review" rel="noopener ugc nofollow" target="_blank"> Stormgain回顾</a> | <a class="ae kr" href="https://blog.coincodecap.com/bexplus-review" rel="noopener ugc nofollow" target="_blank"> Bexplus回顾</a> | <a class="ae kr" href="https://blog.coincodecap.com/binance-vs-bittrex" rel="noopener ugc nofollow" target="_blank">币安vs Bittrex </a></li><li id="20b6" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated"><a class="ae kr" href="https://blog.coincodecap.com/bookmap-review-2021-best-trading-software" rel="noopener ugc nofollow" target="_blank"> Bookmap评论</a> | <a class="ae kr" href="https://blog.coincodecap.com/crypto-exchange-usa" rel="noopener ugc nofollow" target="_blank">美国5大最佳加密交易所</a></li><li id="dda8" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated"><a class="ae kr" href="https://blog.coincodecap.com/ftx-futures-trading" rel="noopener ugc nofollow" target="_blank">如何在FTX交易所交易期货</a> | <a class="ae kr" href="https://blog.coincodecap.com/okex-vs-binance" rel="noopener ugc nofollow" target="_blank"> OKEx vs币安</a></li><li id="ecf7" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated"><a class="ae kr" href="https://blog.coincodecap.com/buy-domain-on-unstoppable-domains" rel="noopener ugc nofollow" target="_blank">如何在势不可挡的域名上购买域名？</a></li><li id="adb1" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated"><a class="ae kr" href="https://blog.coincodecap.com/crypto-tax-india" rel="noopener ugc nofollow" target="_blank">印度的秘密税</a> | <a class="ae kr" href="https://blog.coincodecap.com/altfins-review" rel="noopener ugc nofollow" target="_blank"> altFINS审查</a> | <a class="ae kr" rel="noopener" href="/coinmonks/prokey-review-26611173c13c"> Prokey审查</a></li><li id="05eb" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated"><a class="ae kr" href="https://blog.coincodecap.com/blockfi-vs-coinbase" rel="noopener ugc nofollow" target="_blank">布洛克菲vs比特币基地</a> | <a class="ae kr" href="https://blog.coincodecap.com/bitkan-review" rel="noopener ugc nofollow" target="_blank">比特坎评论</a> | <a class="ae kr" rel="noopener" href="/coinmonks/binance-review-ee10d3bf3b6e">币安评论</a></li><li id="b5f9" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated"><a class="ae kr" href="https://blog.coincodecap.com/coldcard-review" rel="noopener ugc nofollow" target="_blank"> Coldcard评论</a> | <a class="ae kr" href="https://blog.coincodecap.com/boxtradex-review" rel="noopener ugc nofollow" target="_blank"> BOXtradEX评论</a>|<a class="ae kr" href="https://blog.coincodecap.com/uniswap" rel="noopener ugc nofollow" target="_blank">unis WAP指南</a></li><li id="80c5" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated"><a class="ae kr" href="https://blog.coincodecap.com/best-crypto-exchanges-in-uae" rel="noopener ugc nofollow" target="_blank">阿联酋5大最佳加密交易所</a> | <a class="ae kr" href="https://blog.coincodecap.com/simpleswap-review" rel="noopener ugc nofollow" target="_blank"> SimpleSwap评论</a></li><li id="706c" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated"><a class="ae kr" href="https://blog.coincodecap.com/ways-to-buy-dogecoin" rel="noopener ugc nofollow" target="_blank">购买Dogecoin的7种最佳方式</a> | <a class="ae kr" href="https://blog.coincodecap.com/zebpay-review" rel="noopener ugc nofollow" target="_blank"> ZebPay评论</a></li><li id="ae25" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated"><a class="ae kr" href="https://blog.coincodecap.com/crypto-trading-bots-in-the-us" rel="noopener ugc nofollow" target="_blank">美国最佳加密交易机器人</a> | <a class="ae kr" href="https://blog.coincodecap.com/changelly-review" rel="noopener ugc nofollow" target="_blank">不断回顾</a></li><li id="664e" class="mb mc ht jq b jr mk jv ml jz mm kd mn kh mo kl mg mh mi mj dt translated"><a class="ae kr" href="https://blog.coincodecap.com/huobi-crypto-trading-signals" rel="noopener ugc nofollow" target="_blank">huo bi的加密交易信号</a> | <a class="ae kr" href="https://blog.coincodecap.com/bitmex-review" rel="noopener ugc nofollow" target="_blank"> BitMEX评论</a></li></ul></div></div>    
</body>
</html>