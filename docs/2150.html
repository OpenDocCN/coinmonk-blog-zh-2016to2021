<html>
<head>
<title>A .NET Developer’s Workflow for Creating and Calling Ethereum Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">答。NET开发人员创建和调用以太坊智能合约的工作流</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-net-developers-workflow-for-creating-and-calling-ethereum-smart-contracts-44714f191db2?source=collection_archive---------0-----------------------#2019-04-03">https://medium.com/coinmonks/a-net-developers-workflow-for-creating-and-calling-ethereum-smart-contracts-44714f191db2?source=collection_archive---------0-----------------------#2019-04-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="9147" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有<a class="ae jo" href="https://github.com/ConsenSys/ethereum-developer-tools-list#developer-tools" rel="noopener ugc nofollow" target="_blank">许多伟大的工具</a>可以用来创建以太坊智能合约。很难在它们之间做出选择。在本文中，您将学习一个简单的工作流，用于开发Solidity smart contracts并从C#中调用它们的函数。这个工作流程非常适合。NET开发人员，因为它将您需要了解的新工具的数量减到最少。通过使用优秀的<a class="ae jo" href="https://nethereum.com" rel="noopener ugc nofollow" target="_blank">尼瑟姆。NET </a>库您可以继续使用您已经熟悉的Visual Studio工具集。</p><p id="3b7b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">假设您的目标是从Solidity文档中获取名为<a class="ae jo" href="https://solidity.readthedocs.io/en/v0.5.7/introduction-to-smart-contracts.html#storage-example" rel="noopener ugc nofollow" target="_blank"> SimpleStorage.sol </a>的契约，并从C#项目中调用它的函数。您的首选是尽可能使用Visual Studio。这篇文章是基于我自己在Nethereum项目中的工作经验，该项目将以太坊与SAP销售和分销业务流程集成在一起。</p><p id="f5ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">【2019年11月更新:这个工作流非常适合智能合约经常变化的情况(可能因为你正在开发它们)。当智能合约不经常更改时(可能因为智能合约是由另一个团队开发的)，我发现我更喜欢本文结尾的第<strong class="is hu">节中详细介绍的工作流。这是因为like能够明确控制再生何时发生。两个工作流使用相同的Nethereum代码生成。</strong></p><h1 id="d8df" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">工作流程概述</h1><p id="2ef9" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">有许多可能的工作流程来实现你的目标，随着新版本的工具和插件的发布，其他选项将会出现。在撰写本文时，我们发现该工作流程简单快捷:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="ab fr cl kx"><img src="../Images/782da8778f666a81997dd24e7c6ce399.png" data-original-src="https://miro.medium.com/v2/format:webp/1*yVBYD0RtP27-f8KCAZQcNg.png"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">A .NET Developer’s Workflow: Write Solidity and Consume in C#</figcaption></figure><p id="87da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">上图显示了这些步骤:</p><ol class=""><li id="856b" class="le lf ht is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm dt translated">编写Solidity智能合约，并用Visual Studio代码进行编译。编译过程的输出是一些代表合同的ABI和字节码的文件。</li><li id="b802" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated">使用Nethereum Autogen代码生成器自动构建C# API类，以提供对智能合约的访问。</li><li id="53e8" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated">使用Visual Studio编写C#来调用生成的C# API类中的方法。</li></ol><p id="4b17" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本文中，术语<code class="eh ls lt lu lv b">function</code>指的是可靠性函数，而<code class="eh ls lt lu lv b">method</code>指的是C#方法。</p><h1 id="5b5f" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">初始设置</h1><h2 id="fe84" class="lw jq ht bd jr lx ly lz jv ma mb mc jz jb md me kd jf mf mg kh jj mh mi kl mj dt translated">创建项目</h2><p id="37be" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">在命令提示符下，您将创建一个新的。您将用来保存所有文件的. NET core控制台项目:</p><pre class="ks kt ku kv fq mk lv ml mm aw mn dt"><span id="4d86" class="lw jq ht lv b fv mo mp l mq mr">dotnet new sln --name DevWorkflowExample<br/>dotnet new console --name SimpleStorage<br/>dotnet sln add .\SimpleStorage\SimpleStorage.csproj<br/>cd SimpleStorage<br/>dotnet add package Nethereum.Web3<br/>dotnet add package Nethereum.Autogen.ContractApi</span></pre><h2 id="d86d" class="lw jq ht bd jr lx ly lz jv ma mb mc jz jb md me kd jf mf mg kh jj mh mi kl mj dt translated">准备Visual Studio代码</h2><ol class=""><li id="3e6d" class="le lf ht is b it kn ix ko jb ms jf mt jj mu jn lj lk ll lm dt translated">打开Visual Studio代码。</li><li id="6fb5" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated">打开延伸件并在此处安装<a class="ae jo" href="https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity" rel="noopener ugc nofollow" target="_blank">坚固延伸件</a>。</li><li id="484c" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated">打开我们刚刚创建的SimpleStorage文件夹。您应该会看到类似这样的内容:</li></ol><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="ab fr cl kx"><img src="../Images/852f66adaa56855737f9dc94dfc00c42.png" data-original-src="https://miro.medium.com/v2/format:webp/1*UnbYsbAryoGAhj3UW3OjlQ.png"/></div></figure><p id="7a1b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">4.如果在任何时候，VS代码询问“构建和调试所需的资产在‘简单存储’中缺失。加他们？”答应吧。</p><p id="8b5a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">5.创建一个新文件(ctrl+N)。</p><p id="0b10" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">6.将以下实体代码粘贴到文件中:</p><pre class="ks kt ku kv fq mk lv ml mm aw mn dt"><span id="f7ce" class="lw jq ht lv b fv mo mp l mq mr">pragma solidity &gt;=0.4.0 &lt;0.7.0;<br/><br/>contract SimpleStorage {<br/>    uint storedData;<br/><br/>    function set(uint x) public {<br/>        storedData = x;<br/>    }<br/><br/>    function get() public view returns (uint) {<br/>        return storedData;<br/>    }<br/>}</span></pre><p id="88b4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">7.将文件另存为SimpleStorage文件夹根目录下的<code class="eh ls lt lu lv b">SimpleStorage.sol</code>。</p><p id="a267" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">合同来自<a class="ae jo" href="https://solidity.readthedocs.io/en/v0.5.7/introduction-to-smart-contracts.html#storage-example" rel="noopener ugc nofollow" target="_blank">可靠性文档</a>，你可以看到这是一个非常简单的合同，只有<code class="eh ls lt lu lv b">set()</code>和<code class="eh ls lt lu lv b">get()</code>功能。现在，您已经准备好开始主要的开发人员工作流了。以下步骤与上图中的数字相对应。</p><h1 id="c911" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">主开发人员工作流程</h1><h2 id="ca4f" class="lw jq ht bd jr lx ly lz jv ma mb mc jz jb md me kd jf mf mg kh jj mh mi kl mj dt translated">步骤1 —在Visual Studio代码中编译智能协定</h2><p id="6be3" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">在Visual Studio代码中，按Shift-Ctrl-P并选择“实体:编译当前实体契约”或按F5。你应该会看到一些新文件出现在<code class="eh ls lt lu lv b">SimpleStorage\bin</code>文件夹中，最重要的是<code class="eh ls lt lu lv b">SimpleStorage.abi</code>和<code class="eh ls lt lu lv b">SimpleStorage.bin</code>。</p><h2 id="2bb5" class="lw jq ht bd jr lx ly lz jv ma mb mc jz jb md me kd jf mf mg kh jj mh mi kl mj dt translated">步骤2 —在Visual Studio中重新构建C#项目</h2><p id="a2b8" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">在Visual Studio中打开解决方案<code class="eh ls lt lu lv b">DevWorkflowExample.sln</code>(非Visual Studio代码)。</p><p id="16a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">右键单击SimpleStorage项目，然后选择“Rebuild”。重建项目的行为触发了<code class="eh ls lt lu lv b">Nethereum.Autogen.ContractApi</code>包来构建C# API类，让您与<code class="eh ls lt lu lv b">SimpleStorage.sol</code>契约进行交互。您应该会看到一个名为<code class="eh ls lt lu lv b">SimpleStorage</code>的文件夹中添加到项目中的新文件集合，如下所示:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="ab fr cl kx"><img src="../Images/20c17738895f268d55da561b1e5a2d86.png" data-original-src="https://miro.medium.com/v2/format:webp/1*6xEbdsbo0Boo5CFtwaP9dg.png"/></div></figure><p id="a15a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">生成的<code class="eh ls lt lu lv b">SimpleStorageService</code>类包含一些有用的方法:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="fe ff mv"><img src="../Images/91f59b976c8bbc503024b41a6eeb27df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHXcY1Po86BwLAQvgV34ug.png"/></div></div></figure><p id="229c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">注意C#方法命名对于<code class="eh ls lt lu lv b">set()</code>和<code class="eh ls lt lu lv b">get()</code>函数调用是不同的。这是因为<code class="eh ls lt lu lv b">set()</code>改变了区块链上的一个值，所以它消耗以太，所以它被使用以太坊交易调用，并将返回一个收据。<code class="eh ls lt lu lv b">get()</code>函数不改变区块链上的任何值，所以它是一个简单的调用，并且是免费的(没有交易也没有收据)。</p><h2 id="46a4" class="lw jq ht bd jr lx ly lz jv ma mb mc jz jb md me kd jf mf mg kh jj mh mi kl mj dt translated">步骤3 —在Visual Studio中从C#调用智能合约函数</h2><p id="46ff" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">现在，您可以在。NET核心控制台程序，方法是调用前面提到的生成的C#类。例如，将下面的代码粘贴到<code class="eh ls lt lu lv b">Program.cs</code>中，替换当前存在的所有内容。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="816d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">构建项目。</p><p id="567a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">工作流程完成了！现在，您可以在Visual Studio代码中进一步编辑智能协定，在那里编译它，并在Visual Studio中简单地重新构建项目，以便能够对修改后的Solidity函数进行C#调用。</p><h1 id="68c8" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">程序执行</h1><p id="66dc" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">当然，您希望检查程序是否成功运行。为了项目的运行，它需要与区块链对话，这里你需要一个新的工具。开发期间的一个好选择是运行本地区块链，如下所述:<a class="ae jo" href="https://github.com/Nethereum/TestChains#geth" rel="noopener ugc nofollow" target="_blank">https://github.com/Nethereum/TestChains#geth</a>。</p><p id="b85b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行本地区块链，从Visual Studio运行<code class="eh ls lt lu lv b">SimpleStorage</code>控制台项目。您应该得到如下输出:</p><pre class="ks kt ku kv fq mk lv ml mm aw mn dt"><span id="5e3e" class="lw jq ht lv b fv mo mp l mq mr">Contract Deployment Tx Status: 1<br/>Contract Address: 0x243e72b69141f6af525a9a5fd939668ee9f2b354<br/><br/>Sending a transaction to the function set()...<br/>Finished storing an int: Tx Hash: 0xe4c8e72bf18c391c3dd0d18aa4c2ec4672591b974383f7d02120657d766d1bf3<br/>Finished storing an int: Tx Status: 1<br/><br/>Calling the function get()...<br/>Int value: 42 (expecting value 42)<br/><br/>Finished</span></pre><h1 id="a2aa" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">从这里去哪里</h1><p id="9a33" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">您开发过程的下一步可能是为您的Solidity契约添加一些测试。这是否意味着你一定要去学习松露或其他工具？答案是不，你没有。这里有一个<a class="ae jo" href="https://github.com/Nethereum/Nethereum/tree/master/src/Nethereum.Contracts.IntegrationTests" rel="noopener ugc nofollow" target="_blank">例子</a>在运行测试部署契约和调用函数之前，使用XUnit测试夹具启动一个本地链。</p><p id="6b57" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">注意，你不必使用生成的<code class="eh ls lt lu lv b">SimpleStorageService</code>类来调用你的智能合约的函数。不过，至少，看看这些调用在生成的代码中是如何工作的是有启发性的。</p><h1 id="6150" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">使用VSCode的替代工作流</h1><p id="21b2" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">【2019年11月更新:如上所述，当智能合约经常发生变化，并且您希望C#类经常反映这些变化时，我发现上面详述的工作流非常有用。这适合我同时开发智能合约和C#的情况。</p><p id="bce8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在智能契约稳定的情况下(例如，你已经被另一个开发团队发送了ABI和字节码)，我发现我更喜欢明确地控制重新生成发生的时间。这可以通过使用VSCode来实现，不仅可以编写智能合约，还可以生成必要的C#代码。工作流程在尼瑟姆文档网站上有很好的解释<a class="ae jo" href="https://docs.nethereum.com/en/latest/nethereum-codegen-vscodesolidity/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="0bdc" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">信用</h1><p id="bc62" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">感谢来自<a class="ae jo" href="https://gitter.im/Nethereum/Nethereum" rel="noopener ugc nofollow" target="_blank">尼瑟姆Gitter </a>的<a class="ae jo" href="https://github.com/vijay055" rel="noopener ugc nofollow" target="_blank"> Vijay055 </a>发布了一些类似的项目代码作为演示。感谢<a class="ae jo" href="https://github.com/juanfranblanco" rel="noopener ugc nofollow" target="_blank"> Juan Blanco </a>创建了尼瑟姆项目，<a class="ae jo" href="https://github.com/Dave-Whiffin" rel="noopener ugc nofollow" target="_blank"> Dave Whiffin </a>提供了Autogen代码生成器包，<a class="ae jo" href="https://github.com/anegg0" rel="noopener ugc nofollow" target="_blank"> Gael Blanchemain </a>审阅并改进了文章内容。</p><blockquote class="nc"><p id="1a7b" class="nd ne ht bd nf ng nh ni nj nk nl jn ek translated">加入Coinmonks <a class="ae jo" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jo" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae jo" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="lw jq ht bd jr lx nm lz jv ma nn mc jz jb no me kd jf np mg kh jj nq mi kl mj dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="le lf ht is b it kn ix ko jb ms jf mt jj mu jn nr lk ll lm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae jo" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn nr lk ll lm dt translated"><a class="ae jo" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">电网交易</a> | <a class="ae jo" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn nr lk ll lm dt translated"><a class="ae jo" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae jo" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn nr lk ll lm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae jo" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="6065" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn nr lk ll lm dt translated"><a class="ae jo" href="https://coincodecap.com/binance-vs-bitstamp" rel="noopener ugc nofollow" target="_blank">币安vs比特邮票</a> | <a class="ae jo" href="https://coincodecap.com/bitpanda-coinbase-coinsbit" rel="noopener ugc nofollow" target="_blank">比特熊猫vs比特币基地vs Coinsbit </a></li><li id="5711" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn nr lk ll lm dt translated"><a class="ae jo" href="https://coincodecap.com/buy-ripple-india" rel="noopener ugc nofollow" target="_blank">如何购买Ripple (XRP) </a> | <a class="ae jo" href="https://coincodecap.com/crypto-exchange-africa" rel="noopener ugc nofollow" target="_blank">非洲最好的加密交易所</a></li><li id="861b" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn nr lk ll lm dt translated"><a class="ae jo" href="https://coincodecap.com/crypto-exchange-africa" rel="noopener ugc nofollow" target="_blank">非洲最佳加密交易所</a> | <a class="ae jo" href="https://coincodecap.com/hoo-exchange-review" rel="noopener ugc nofollow" target="_blank">胡交易所评论</a></li><li id="452c" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn nr lk ll lm dt translated"><a class="ae jo" href="https://coincodecap.com/etoro-robinhood" rel="noopener ugc nofollow" target="_blank"> eToro vs罗宾汉</a>|<a class="ae jo" href="https://coincodecap.com/bybit-bityard-moonxbt" rel="noopener ugc nofollow" target="_blank">MoonXBT vs Bybit vs Bityard</a></li><li id="47a8" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn nr lk ll lm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">面向开发人员的最佳加密API</a></li><li id="b359" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn nr lk ll lm dt translated">最佳<a class="ae jo" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn nr lk ll lm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae jo" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="le lf ht is b it ln ix lo jb lp jf lq jj lr jn nr lk ll lm dt translated">杠杆代币的终极指南</li></ul></div></div>    
</body>
</html>