<html>
<head>
<title>Secure Asp.Net Core 2 API with Ethereum Blockchain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用以太坊区块链保护Asp.Net核心2 API</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/secure-asp-net-core-2-api-with-ethereum-blockchain-88001d5ddb6?source=collection_archive---------2-----------------------#2018-07-18">https://medium.com/coinmonks/secure-asp-net-core-2-api-with-ethereum-blockchain-88001d5ddb6?source=collection_archive---------2-----------------------#2018-07-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><h1 id="e539" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">问题是</h1><p id="68c8" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">分散式应用程序(DApp)的一个常见设计不仅依赖于以太坊区块链，还依赖于API层。在这种情况下，DApp通过用户的以太坊帐户与智能合约交互，并通过交换用户凭证而颁发的JWT令牌与API层交互。</p><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff km"><img src="../Images/a7db428c8e9393a340f39c1382a410c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*myVxQt4aTKJzFYnFj4mypQ.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">A typical DApp architecture</figcaption></figure><p id="ff77" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">目标是<strong class="jq hu">使用以太坊账户作为用户凭证</strong>来请求JWT令牌。</p><p id="0d05" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">一种可能的最简单的方法是请求用户在以太坊上用额外的随机生成的数据进行交易，然后在发布JWT之前检查交易和随机数据。这种方法有几个副作用:</p><ol class=""><li id="3e04" class="lh li ht jq b jr lc jv ld jz lj kd lk kh ll kl lm ln lo lp dt translated">用户必须进行交易并支付<strong class="jq hu"> <em class="lq">气体</em> </strong>进行简单的认证。</li><li id="512e" class="lh li ht jq b jr lr jv ls jz lt kd lu kh lv kl lm ln lo lp dt translated">用户必须等待12-120秒(基于消耗的气体)才能完成认证过程。</li><li id="e1b0" class="lh li ht jq b jr lr jv ls jz lt kd lu kh lv kl lm ln lo lp dt translated">在以太坊区块链，每个用户的所有登录操作都变成了不变的公开。</li></ol><p id="c886" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">这种方式是不实际的，并且具有几个用户体验限制，我们需要一种方式来让用户证明她/他拥有与她/他想要用来登录的帐户相关的私钥，而(当然)不要求私钥并且不要求她/他进行交易。</p><h1 id="853f" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">解决方案</h1><p id="bccd" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">这篇教程的灵感来自Metamask团队成员<a class="ae lw" rel="noopener" href="/@danfinlay"> Dan Finlay </a>的<a class="ae lw" rel="noopener" href="/metamask/the-new-secure-way-to-sign-data-in-your-browser-6af9dd2a1527">帖子</a>。基本上，您的DApp可以提示用户使用他的私钥签署文本消息。这个签名操作不会生成事务，它由Metamask插件透明地处理(顺便说一句，您的帐户需要解锁)。签名后，帐户、消息和签名将被发送到API令牌端点。身份验证方法首先通过一个接受签名和普通消息作为输入的函数，从签名中推断出帐户(即公钥)。如果计算出的以太坊地址等于用户提供的账户，则为该账户发放一个JWT令牌。</p><p id="ef39" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">值得注意的是，整个身份验证流程不需要询问用户名/密码或OAuth外部服务。用来验证用户身份的机制与以太坊用来保证区块链以太坊安全性的机制相同。这要归功于Go Ethereum (Geth)通过Metamask插件提供的<strong class="jq hu">web 3 . personal . sign</strong>JSON RPC。</p><p id="bdf3" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">服务器端调用对应的JSON RPC从签名中检索帐户:<strong class="jq hu">web 3 . personal . ecrecover</strong>。在本教程中，我们将构建一个Asp.Net Core 2项目作为API层，并构建一个简单的HTML/javascript客户端作为DApp来实际演示这个认证过程。</p><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff lx"><img src="../Images/74668561611dfa73c8258697bd27aff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UknISGD_zTEXJBKIe3v0JA.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Authentication flow</figcaption></figure><ol class=""><li id="c2b7" class="lh li ht jq b jr lc jv ld jz lj kd lk kh ll kl lm ln lo lp dt translated">从DApp用户点击登录按钮。这需要Metamask提供的web3对象。</li><li id="ac1c" class="lh li ht jq b jr lr jv ls jz lt kd lu kh lv kl lm ln lo lp dt translated">Metamask要求用户通过<strong class="jq hu">web 3 . personal . sign</strong>JSON RPC对消息进行签名。</li><li id="6302" class="lh li ht jq b jr lr jv ls jz lt kd lu kh lv kl lm ln lo lp dt translated">签名被发送到API层，API层通过<strong class="jq hu">web 3 . personal . ecrecover</strong>JSON RPC验证账户。</li><li id="7718" class="lh li ht jq b jr lr jv ls jz lt kd lu kh lv kl lm ln lo lp dt translated">一旦通过验证，API层就发布JWT。</li></ol><h1 id="3579" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">先决条件</h1><ol class=""><li id="1754" class="lh li ht jq b jr js jv jw jz ly kd lz kh ma kl lm ln lo lp dt translated">为Chrome或Firefox安装<a class="ae lw" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> Metamask插件</a>。这个插件“<em class="lq">为你的浏览器带来以太坊</em>。实际上，Metamask提供了一个<a class="ae lw" href="https://github.com/ethereum/web3.js/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hu"> web3 </strong> </a> <strong class="jq hu"> </strong>对象，用于从您的DApp与以太坊区块链进行交互，保管您的私钥并管理浏览器内的事务。</li><li id="fc88" class="lh li ht jq b jr lr jv ls jz lt kd lu kh lv kl lm ln lo lp dt translated">可选。运行一个<a class="ae lw" href="https://github.com/ethereum/go-ethereum" rel="noopener ugc nofollow" target="_blank"> Geth </a>节点。我将向您展示两种从签名中恢复以太坊帐户的方法，其中一种方法要求您的API层针对Geth节点调用JSON RPC。<br/>注意:<strong class="jq hu"> Infura </strong>目前还不够，因为他们不允许大部分web3.personal.* JSON RPC。出于开发目的，运行Geth节点非常简单。在生产环境中，由于安全问题，运行Geth节点不是一项简单的任务。最好的办法是依靠由<a class="ae lw" href="https://aws.amazon.com/it/blockchain/templates/" rel="noopener ugc nofollow" target="_blank"> AWS </a>或<a class="ae lw" href="https://azure.microsoft.com/en-us/solutions/blockchain/" rel="noopener ugc nofollow" target="_blank"> Azure </a>提供的区块链即服务(BaaS)栈。</li><li id="4dcb" class="lh li ht jq b jr lr jv ls jz lt kd lu kh lv kl lm ln lo lp dt translated">开发栈:<strong class="jq hu"> Visual studio 2017 </strong>和节点包管理器(<strong class="jq hu"> NPM </strong>)。</li><li id="5ec7" class="lh li ht jq b jr lr jv ls jz lt kd lu kh lv kl lm ln lo lp dt translated">以太坊/Asp基础知识。Net核心/前端开发，JWT认证流程基础知识。</li></ol><h1 id="6bfe" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">我们开始吧！</h1><p id="32c4" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">打开Visual Studio 2017，创建EthereumJwtSolution并添加两个<strong class="jq hu">Asp.Net Core 2 Web应用</strong>项目:<strong class="jq hu"> EthereumJwtApi </strong>和<strong class="jq hu"> EthereumJwtClient </strong>。为两个项目选择空的项目脚手架。</p><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff mb"><img src="../Images/2d36063c66ad36698ca1afd0cd2f7f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ixVNDbAcqejNXbkdJTj_JA.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Create two Asp.Net Core 2 Web Application</figcaption></figure><p id="6a5a" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated"><strong class="jq hu"> EthereumJwtClient </strong>只是一个HTML/Javascript客户端。我们将在Asp.Net核心之上构建客户端应用程序，以便在IIS Express上轻松运行。</p><p id="2ae2" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">为了保护某个安全端点，我们需要准备EthereumJwtApi来创建和处理JWT令牌。这项任务非常简单，因为Asp.Net Core 2有一个内置的JWT机制，可以随时插入我们的应用中。打开<em class="lq"> Startup.cs </em>，修改<em class="lq"> ConfigureServices </em>方法:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="e4ed" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">然后修改<em class="lq">配置</em>的方法:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="6ffe" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">我们告诉我们的API应用程序使用<strong class="jq hu"> JWT认证</strong>服务。为了与我们的客户合作，我们还需要配置一个<strong class="jq hu"> Cors </strong>策略。我们在<em class="lq"> appsetting.json </em>中定义JWT配置设置:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="06fe" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">为测试目的创建一个简单的可能的安全端点:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="9d56" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated"><em class="lq"> TokenController.cs </em>将处理JWT请求和相关的令牌问题:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="e8fa" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">这是一个典型的JWT控制器，其核心方法<em class="lq">认证</em>和<em class="lq">认证2 </em>尚未实现。一旦实现，他们将做同样的工作:从签名中恢复以太坊地址，并检查它是否等于客户端提供的以太坊地址。</p><p id="f1ae" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated"><em class="lq"> LoginVM </em>代表客户端提供的用户凭证，<em class="lq"> UserVM </em>代表“<em class="lq">服务器端</em>”登录用户:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="9a31" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated"><em class="lq"> Authenticate </em>方法将把<strong class="jq hu">签名</strong>和<strong class="jq hu">消息</strong>属性作为<strong class="jq hu"> ecRecover </strong>函数的输入，而<em class="lq"> Authenticate2 </em>方法将把<strong class="jq hu">签名</strong>和<strong class="jq hu"> Hash </strong>属性作为替代。我稍后会解释不同之处。</p><h1 id="246c" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">客户</h1><p id="3f9b" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">正如我们所说，我们的DApp是一个简单的HTML/ES6客户端。我们将在Asp.Net Core 2之上构建客户端，以便利用<strong class="jq hu"> IIS Express </strong>和<strong class="jq hu"> Visual Studio IDE </strong>。因此，<em class="lq"> Startup.cs </em>类中的<em class="lq"> Configure </em>方法将是:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="18c7" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">使DApp成为一个<strong class="jq hu"> NPM </strong>项目，并安装使用ES6 Javascript标准的先决条件。这不是强制性的，请随意使用您自己的堆栈来构建您的DApp。</p><p id="e2b9" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">从项目文件夹运行Powershell，并运行以下NPM命令:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="f6f8" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">为了配置webpack/babel，使用以下配置创建<em class="lq"> webpack.config.js </em>文件:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="9fdc" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">我们已经指示webpack将<em class="lq"> src/main.js </em>文件构建到<em class="lq"> /www/js/main.build.js </em>。</p><p id="e9ba" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">安装以太坊特定包:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="e112" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">Web3是一个javascript包装器，它简化了针对以太坊区块链的JSON RPC调用。<strong class="jq hu">以太坊js-util </strong>提供了一些以太坊特有的实用工具。</p><p id="1992" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">让我们构建一个非常简单的HTML页面。我们需要一个登录按钮和另一个按钮来从我们的API层加载一些安全数据:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="95cd" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">正如我们在<em class="lq"> webpack.config.js </em>文件中指定的那样，DApp逻辑将驻留在src/main.js文件中。<em class="lq"> src/main.js </em>文件将是:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><ol class=""><li id="81a9" class="lh li ht jq b jr lc jv ld jz lj kd lk kh ll kl lm ln lo lp dt translated"><strong class="jq hu"> coinbase </strong>和<strong class="jq hu"> accessToken </strong>是分别存储用户以太坊账号和JWT令牌的全局变量。</li><li id="f55f" class="lh li ht jq b jr lr jv ls jz lt kd lu kh lv kl lm ln lo lp dt translated"><strong class="jq hu"> init </strong>函数从Metamask提供的提供者中初始化web3对象，然后它尝试检索用户的帐户(coinbase)。这需要您在Metamask中解锁您的帐户签名。</li><li id="4a6b" class="lh li ht jq b jr lr jv ls jz lt kd lu kh lv kl lm ln lo lp dt translated"><strong class="jq hu"> require </strong>函数只是一个包装<em class="lq"> hxr </em>对象的包装器，使ajax能够轻松调用API层。</li><li id="5ed0" class="lh li ht jq b jr lr jv ls jz lt kd lu kh lv kl lm ln lo lp dt translated"><strong class="jq hu"> load_data_btn </strong> click处理程序对API层安全端点进行ajax调用。这需要有效的accessToken才能工作，否则，API层将使用401 HTTP响应进行响应。</li><li id="647e" class="lh li ht jq b jr lr jv ls jz lt kd lu kh lv kl lm ln lo lp dt translated"><strong class="jq hu"> login_btn </strong>点击是一个两步功能。首先，它要求用户签署任意消息。签名后，它将帐户、签名、普通消息和带前缀的哈希发送到令牌端点。</li></ol><p id="2114" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">注意<strong class="jq hu"> web3.personal.sign </strong>将十六进制格式(0x…)的普通字符串的字节数组作为输入。</p><p id="7dd3" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">正如我们所说的，在服务器端，我们将使用两种不同的方法从签名中恢复公钥:一种方法是使用<strong class="jq hu">web 3 . personal . ecrecover</strong>JSON RPC(对应的<strong class="jq hu">web 3 . personal . sign</strong>)；在另一个例子中，我们将使用一个底层的<strong class="jq hu"> ecrecover </strong>离线函数。根据文档，<strong class="jq hu"> web3.personal.sign </strong>使用底层的<strong class="jq hu"> sign </strong>函数来签署一个散列的带前缀的消息，因此，为了使用底层的<strong class="jq hu"> ecrecover </strong>对应函数，我们也需要计算这个散列并将其发送到令牌端点。</p><p id="2d43" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">运行这两个应用程序，并使用安装了Metamask附加组件的浏览器导航到客户端。请记住，为了将<em class="lq"> src/main.js </em>文件构建到<em class="lq"> js/main.build.js </em>中，您需要从Powershell运行<strong class="jq hu"> webpack </strong>命令。如果一切正常，客户端将检索coinbase，您将看到您的帐户显示在页面上:</p><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff me"><img src="../Images/7298adabd7a389e02673c1d5ea710ce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0a0O68ivo7T-UZS176jQhA.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">The working DApp index page</figcaption></figure><p id="5093" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">如果您现在点击请求数据按钮，您将得到一个401 HTTP响应。如果您单击登录按钮，Metamask将提示您一个签名请求:</p><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/7b09b9b6d06deee378a5b82d9dc3eb3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*Vuufof7dR1hb-gXtkSudTA.png"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Metamask sign prompt</figcaption></figure><p id="8d5a" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">签名后，处理程序将对令牌端点进行ajax调用。在这一阶段，身份验证方法不会检查任何签名，因此端点将始终颁发JWT令牌。一旦收到JWT令牌，客户机就能够通过ajax调用安全端点。如果您现在单击请求数据按钮，您将收到200 HTTP响应和您的数据有效负载:</p><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff me"><img src="../Images/49cbdff23a10c978568fa8f5e850bd98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HpWWCE7U8XaNrT61_tGnuA.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">We got a JWT token so we are able to make authorized api call</figcaption></figure><h1 id="a3cc" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">从签名中检索以太坊帐户</h1><p id="781f" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">到目前为止，<strong class="jq hu"> EthereumJwtApi </strong>是一个简单的Asp.Net JWT核心样本，因为它没有提供任何有效的认证方法。</p><p id="9593" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">令牌控制器的关键部分是两种身份验证方法及其从签名中检索以太坊帐户的能力。为了做到这一点，你需要安装<strong class="jq hu">尼瑟姆。Web3 </strong> NuGet包。尼日坊是以太坊的. Net实现。</p><p id="eaf0" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated"><em class="lq">认证</em>方法简单地对<strong class="jq hu"> web3.personal.ecrecover </strong>函数进行JSON RPC调用:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="15cf" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated"><strong class="jq hu">亲:</strong></p><ol class=""><li id="0d9a" class="lh li ht jq b jr lc jv ld jz lj kd lk kh ll kl lm ln lo lp dt translated"><strong class="jq hu"> web3.personal.sign </strong>是<strong class="jq hu"> web3.personal.sign </strong>的对应物，所以你不需要担心它的底层实现。</li></ol><p id="93fe" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated"><strong class="jq hu"> CONS: </strong></p><ol class=""><li id="096e" class="lh li ht jq b jr lc jv ld jz lj kd lk kh ll kl lm ln lo lp dt translated">需要自己的Geth节点。不支持奇偶校验，Infura不允许web3.personal.* JSON RPC。</li></ol><p id="81c9" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated"><em class="lq"> Authenticate2 </em>方法展示了一种替代方式，它使用底层<strong class="jq hu"> ecrecover </strong>函数的离线实现:</p><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="dfca" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated"><strong class="jq hu">亲:</strong></p><ol class=""><li id="bcf3" class="lh li ht jq b jr lc jv ld jz lj kd lk kh ll kl lm ln lo lp dt translated">不需要JSON RPC调用就能工作。消息签名者。EcRecover 是<strong class="jq hu">尼瑟姆</strong>提供的离线功能。</li></ol><p id="9b2e" class="pw-post-body-paragraph jo jp ht jq b jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh lg kj kk kl hm dt translated">CONS: </p><ol class=""><li id="636f" class="lh li ht jq b jr lc jv ld jz lj kd lk kh ll kl lm ln lo lp dt translated">你需要注意web3.personal.sign的实现，以便正确地恢复帐户。因此，在客户端，我们相应地计算了带前缀的消息哈希。</li></ol><h1 id="00e2" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">结论</h1><p id="4b74" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在你有了知识和一个主干项目来用以太坊保护你的Asp.Net核心2 API。只有几个注意事项:</p><ol class=""><li id="6b02" class="lh li ht jq b jr lc jv ld jz lj kd lk kh ll kl lm ln lo lp dt translated"><strong class="jq hu"> web3 1.0.0 </strong>处于测试阶段，<strong class="jq hu"> web3.personal.sign </strong>的实现可能会随着时间的推移而变化。请确保在您可以维护的代码库上使用这种身份验证方法。</li><li id="e3c3" class="lh li ht jq b jr lr jv ls jz lt kd lu kh lv kl lm ln lo lp dt translated">也许Infura可以在这几天决定允许<strong class="jq hu">web 3 . personal . ecrecover</strong>；-)</li></ol></div></div>    
</body>
</html>