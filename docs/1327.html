<html>
<head>
<title>Develop W3C Web Components with WebAssembly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用WebAssembly开发W3C Web组件</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/develop-w3c-web-components-with-webassembly-d65938284255?source=collection_archive---------1-----------------------#2018-08-16">https://medium.com/coinmonks/develop-w3c-web-components-with-webassembly-d65938284255?source=collection_archive---------1-----------------------#2018-08-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="4108" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">WebAssembly和Web Components是两个新兴的标准，它们很有可能对Web平台的未来产生重大影响。有趣的问题是，我们能把这两种技术结合起来吗？我们可以使用WebAssembly创建Web组件吗？在这里找到答案。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/ae9dc7af10e94d10284137c6e2b52b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BjqwO5-P-9ET8KqEhPOeMw.jpeg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">WEB COMPONENTS with WEBASSEMBLY</figcaption></figure><h2 id="9416" class="jy jz ht bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">Web组件</h2><p id="3dab" class="pw-post-body-paragraph kw kx ht ky b kz la iu lb lc ld ix le kj lf lg lh kn li lj lk kr ll lm ln lo hm dt translated">web组件是由万维网联盟(W3C)引入的HTML和DOM规范中的一组功能，用于在Web文档和Web应用程序中创建可重用的小部件或组件。其目的是将基于组件的软件工程引入万维网。理解Web组件最简单的方法是通过一个例子。假设您的同事开发了一个在网页上显示条形码的Web组件。要使用该组件，您只需执行以下操作:</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="9e45" class="jy jz ht lq b fv lu lv l lw lx">&lt;html&gt; <br/>&lt;body&gt;  </span><span id="3346" class="jy jz ht lq b fv ly lv l lw lx">&lt;barcode input="12345678"&gt;&lt;/barcode&gt;    </span><span id="2634" class="jy jz ht lq b fv ly lv l lw lx">&lt;/body&gt; <br/>&lt;/html&gt;</span></pre><p id="dc99" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">您只需要声明一个HTML标记，就可以在您的网页或应用程序中使用该组件。不需要编写任何代码来调用组件，也不需要干预来理解组件的内部工作方式。这使您能够通过使用组件来简化web开发。</p><h2 id="02a3" class="jy jz ht bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">W3C的Web组件包括以下4个特性</h2><ul class=""><li id="b165" class="me mf ht ky b kz la lc ld kj mg kn mh kr mi lo mj mk ml mm dt translated">自定义元素—将新的HTML元素添加到DOM中</li><li id="0727" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated">影子DOM——创建由HTML标记封装的唯一DOM</li><li id="b8c6" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated">HTML导入—导入HTML代码并在其他页面中重用您的组件</li><li id="8a52" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated">HTML模板——编写可重用的代码并声明其外观</li></ul><p id="613a" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">上述内容可能仍会发生变化。</p><p id="7f8f" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">另外，Google提供并维护Polymer，这是一个开源的JavaScript库，用于使用web组件构建Web应用程序。</p><h2 id="db03" class="jy jz ht bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">web程序集</h2><p id="ea7f" class="pw-post-body-paragraph kw kx ht ky b kz la iu lb lc ld ix le kj lf lg lh kn li lj lk kr ll lm ln lo hm dt translated">WebAssembly是一个web标准，由W3C开发，它定义了一个类似汇编的二进制代码格式(wasm ),用于在网页中执行。执行代码的运行速度几乎与本机代码一样快，旨在显著提高web应用程序的性能。由于WebAssembly是一个低级二进制字节码，它支持从不同的编程语言编译。</p><p id="7877" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">除了作为不同编程语言的编译目标之外，WebAssembly还提供了用JavaScript之外的语言进行web开发的替代方案。从2017年开始，WebAssembly已经被包括Firefox、Chrome、Safari、Edge在内的所有主流浏览器原生支持。</p><p id="6cef" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">理解WebAssembly最简单的方法也是通过一个例子。下面的源代码显示了一个“hello_world.c”文件的内容。这是一个用C语言编写的程序。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="acb8" class="jy jz ht lq b fv lu lv l lw lx">#include   <br/>int main() <br/>{   </span><span id="e029" class="jy jz ht lq b fv ly lv l lw lx">printf("hello, world!\n");      <br/>return 0; </span><span id="8bd1" class="jy jz ht lq b fv ly lv l lw lx">}</span></pre><p id="c646" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">过去，您使用C/C++编译器将上述内容编译成二进制可执行文件，以便在命令行中运行。接下来，您可以将上面的程序编译成WebAssembly，并在浏览器中运行该程序。</p><p id="9e5c" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">允许您这样做的工具之一是Emscripten。这个工具基本上将C/C++代码编译成WebAssembly模块WASM。然后可以将WASM模块加载到网页(HTML)中，以显示“printf”功能的“hello，world”。</p><h2 id="08c9" class="jy jz ht bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">可以混合WebAssembly和Web组件吗？</h2><p id="a8a2" class="pw-post-body-paragraph kw kx ht ky b kz la iu lb lc ld ix le kj lf lg lh kn li lj lk kr ll lm ln lo hm dt translated">这两个新兴的标准很有可能对网络平台的未来产生重大影响。有趣的问题是我们能结合这两种技术吗？我们可以使用WebAssembly创建Web组件吗？有人试过这个吗？网上的简单搜索不会返回任何结果。</p><p id="8c71" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">经过一番研究，我得出结论，答案是肯定的！下一节说明了如何做到这一点。但是，请注意，由于规范的变化和标准的发展，一些代码、脚本或HTML可能会发生变化。</p><h2 id="7861" class="jy jz ht bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dt translated">使用WebAssembly创建Web组件</h2><p id="4bd6" class="pw-post-body-paragraph kw kx ht ky b kz la iu lb lc ld ix le kj lf lg lh kn li lj lk kr ll lm ln lo hm dt translated">为了使这个例子有用和有价值，我们将使用WebAssembly创建一个条形码Web组件。具体来说，我们将创建一个生成Code 39条形码的组件。我们将使用来自https://www.barcoderesource.com的免费Code 39条形码网络字体来显示我们的条形码。</p><p id="352b" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">对于那些不能等待的人，您可以滚动到本页底部下载包含示例代码工作副本的zip文件。对于那些想了解更多的人，请继续读下去。</p><p id="f024" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">1.从以下网址下载并安装Emscripten</p><p id="8428" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">http://kripken.github.io/emscripten-site/<a class="ae ms" href="http://kripken.github.io/emscripten-site/" rel="noopener ugc nofollow" target="_blank"/></p><p id="60b8" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">Emscripten是一个工具链，用于编译成asm.js和WebAssembly，使用LLVM构建，让您可以在没有插件的情况下在web上以接近本机的速度运行C和C++。</p><p id="bc4c" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">2.使用记事本创建一个包含以下内容的“code39.cpp”文件。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="a540" class="jy jz ht lq b fv lu lv l lw lx">#include &lt;iostream&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;emscripten/bind.h&gt;</span><span id="f39d" class="jy jz ht lq b fv ly lv l lw lx">using namespace emscripten;</span><span id="3d5f" class="jy jz ht lq b fv ly lv l lw lx">class Code39 {</span><span id="5cd5" class="jy jz ht lq b fv ly lv l lw lx">public:<br/>  Code39()<br/>  {<br/> inputData="12345678";<br/> checkDigit=1;<br/>  }</span><span id="85d5" class="jy jz ht lq b fv ly lv l lw lx">Code39(std::string inputData, int checkDigit)<br/>    : checkDigit(checkDigit)<br/>    , inputData(inputData)<br/>  {}</span><span id="1d42" class="jy jz ht lq b fv ly lv l lw lx">std::string encode() <br/>{</span><span id="f8d2" class="jy jz ht lq b fv ly lv l lw lx">std::string filteredData=filterInput(inputData);</span><span id="c2cb" class="jy jz ht lq b fv ly lv l lw lx">int filteredlength = filteredData.length();<br/>std::string result;<br/>if (checkDigit==1)<br/>  result="*"+filteredData+generateCheckDigit(filteredData)+"*";<br/>else<br/>  result="*"+filteredData+"*";</span><span id="8095" class="jy jz ht lq b fv ly lv l lw lx">std::string mappedResult;<br/>for (int x=0;x&lt;result.length();x++)<br/> {        <br/>         mappedResult=mappedResult+"&amp;#"+<br/>         std::to_string((unsigned char)result[x])+";";  <br/> }<br/>result=mappedResult;</span><span id="8f26" class="jy jz ht lq b fv ly lv l lw lx">human_readable_text=result;<br/>return result;</span><span id="4001" class="jy jz ht lq b fv ly lv l lw lx">}</span><span id="9cb5" class="jy jz ht lq b fv ly lv l lw lx">int getCheckDigit() const { return checkDigit; }<br/>void setCheckDigit(int checkDigit_) { checkDigit = checkDigit_; }</span><span id="f57f" class="jy jz ht lq b fv ly lv l lw lx">std::string getInputData() const { return inputData; }</span><span id="62f1" class="jy jz ht lq b fv ly lv l lw lx">void setInputData(std::string inputData_) <br/>{ <br/>inputData = inputData; <br/>}</span><span id="a1e9" class="jy jz ht lq b fv ly lv l lw lx">std::string getHumanReadableText() const <br/>{ <br/>return human_readable_text; <br/>}</span><span id="a4d6" class="jy jz ht lq b fv ly lv l lw lx">private:</span><span id="bcf0" class="jy jz ht lq b fv ly lv l lw lx">std::string inputData;<br/>std::string human_readable_text;<br/>int checkDigit;<br/>std::string result;<br/>std::string CODE39MAP[43]={"0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","-","."," ","$","/","+","%"};</span><span id="b168" class="jy jz ht lq b fv ly lv l lw lx">int getCode39Value(char inputchar) <br/>{<br/>int RVal=-1;<br/>int i=0;<br/>for (i=0;i&lt;43;i++)<br/>{<br/>  if (inputchar==CODE39MAP[i][0])<br/>  {<br/>   RVal=i;<br/>  }<br/>}<br/>return RVal;<br/>}</span><span id="952a" class="jy jz ht lq b fv ly lv l lw lx">std::string generateCheckDigit(std::string data)<br/>{<br/> std::string checkDigit;<br/> int datalength=data.length();<br/> int sumValue=0;<br/> int x=0;<br/> for (x=0;x&lt;datalength;x++)<br/> {<br/>  sumValue=sumValue+getCode39Value(data[x]);<br/> }<br/> sumValue=sumValue % 43;<br/> return CODE39MAP[sumValue];<br/>}</span><span id="0573" class="jy jz ht lq b fv ly lv l lw lx">std::string filterInput(std::string data)<br/>{<br/> std::string result;<br/> int x=0;<br/> int y=0;<br/> for (x=0; x &lt; data.length() &amp;&amp; y &lt; 255; x++)<br/> {<br/>  if (getCode39Value(data[x]) != -1)<br/>  {<br/>   result=result+data[x];<br/>   y++; <br/>  }<br/> }<br/>return result;<br/>}</span><span id="524b" class="jy jz ht lq b fv ly lv l lw lx">};</span><span id="1b79" class="jy jz ht lq b fv ly lv l lw lx">// Binding code<br/>EMSCRIPTEN_BINDINGS(connectcode_code39) {<br/>  class_&lt;Code39&gt;("Code39")<br/>    .constructor&lt;&gt;()<br/>    .constructor&lt;std::string, int&gt;()<br/>    .function("encode", &amp;Code39::encode)<br/>    .property("checkDigit", <br/>		&amp;Code39::getCheckDigit, <br/>		&amp;Code39::setCheckDigit)<br/>    .property("inputData", <br/>		&amp;Code39::getInputData, <br/>		&amp;Code39::setInputData)<br/>    .property("humanReadableText", &amp;Code39::getHumanReadableText)<br/>    ;<br/>}</span></pre><p id="5ec8" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">上述代码定义了一个C++类和生成Code 39条形码的必要函数，如下所述。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="a49b" class="jy jz ht lq b fv lu lv l lw lx">.constructor&lt;std::string, int&gt;()</span></pre><p id="d01e" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">上面一行定义了条形码的输入数据(第一个参数)的构造函数，以及是否需要校验位的指示符(第二个参数)。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="7f92" class="jy jz ht lq b fv lu lv l lw lx">.function("encode", &amp;Code39::encode)</span></pre><p id="4fdd" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">上面一行是我们执行来生成Code 39条形码的函数。或者更具体地说，它生成一些输出字符，当应用条形码字体时，显示Code 39条形码。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="7fb5" class="jy jz ht lq b fv lu lv l lw lx">.property("checkDigit", &amp;Code39::getCheckDigit, &amp;Code39::setCheckDigit)</span></pre><p id="ed23" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">上述属性用于指示在执行“编码”功能之前是否生成校验位。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="b0df" class="jy jz ht lq b fv lu lv l lw lx">.property("inputData", &amp;Code39::getInputData, &amp;Code39::setInputData)</span></pre><p id="15ca" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">上述属性用于获取或设置输入数据。您可以使用此属性更改输入数据，并执行“编码”功能以生成不同的Code 39条形码。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="c4cd" class="jy jz ht lq b fv lu lv l lw lx">.property("humanReadableText", &amp;Code39::getHumanReadableText)</span></pre><p id="76b5" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">上述属性用于获取通常出现在条形码下方的可读文本。人类可读文本与Code 39条形码的输入数据不同，可能需要添加开始/停止和检查字符。</p><p id="5658" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">3.在Emscripten中使用以下命令编译“code39.cpp”。这为我们提供了一个WASM模块，稍后我们可以在Web组件中使用它。启动命令提示符并执行以下命令。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="5f6b" class="jy jz ht lq b fv lu lv l lw lx">emcc --bind -o code39.js -s WASM=1 -O2 code39.cpp</span></pre><p id="ddf8" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">如果在命令提示符下找不到“emcc”命令，可以转到Emscripten文件夹并执行“emcmdprompt.bat”脚本文件来设置它。</p><p id="a091" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">有了以上内容，我们就有了一个可以在网页中使用的WebAssembly模块。但是，请记住，我们的目标是利用这个WebAssembly来创建一个符合W3C标准的Web组件。因此，我们的WebAssembly模块将从我们的Web组件中执行。</p><p id="fafd" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">4.接下来，我们将在没有任何框架帮助的情况下，从头开始创建一个Web组件。</p><p id="cfb3" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">使用记事本创建一个“code39-barcode.html”文件。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="e554" class="jy jz ht lq b fv lu lv l lw lx">&lt;!-- Defines element markup --&gt;</span><span id="e230" class="jy jz ht lq b fv ly lv l lw lx">&lt;template&gt;<br/>    &lt;style TYPE="text/css" media="screen,print"&gt;<br/>     <a class="ae ms" href="http://twitter.com/font" rel="noopener ugc nofollow" target="_blank">@font</a>-face {<br/>       font-family: CCode39_S3_Trial;<br/>       src: url("fonts/ConnectCode39_S3_Trial.woff") format("woff");<br/>     }<br/>     .barcode {font-weight: normal; font-style: normal; line-height:normal; <br/> font-family: 'CCode39_S3_Trial', sans-serif; font-size: 32px}<br/>&lt;/style&gt;</span><span id="5ab7" class="jy jz ht lq b fv ly lv l lw lx">&lt;div style="width:5in"&gt;<br/>&lt;center&gt;<br/>&lt;div class="barcode"&gt;12345678&lt;/div&gt;<br/>&lt;div class="barcode_text"&gt;&lt;/div&gt;<br/>&lt;/center&gt;<br/>&lt;/div&gt;<br/>&lt;br&gt;</span><span id="2e7c" class="jy jz ht lq b fv ly lv l lw lx">&lt;/template&gt;</span><span id="1fde" class="jy jz ht lq b fv ly lv l lw lx">&lt;script type="text/javascript" src="code39.js"&gt;&lt;/script&gt;</span><span id="6c28" class="jy jz ht lq b fv ly lv l lw lx">&lt;script&gt;</span><span id="b852" class="jy jz ht lq b fv ly lv l lw lx">(function(window, document, undefined) {</span><span id="6f2e" class="jy jz ht lq b fv ly lv l lw lx">	var thatDoc = document;<br/>        var thisDoc =  (thatDoc._currentScript || 					thatDoc.currentScript).ownerDocument;<br/>        var template = thisDoc.querySelector('template').content;<br/>        var MyElementProto = Object.create(HTMLElement.prototype);<br/>        MyElementProto.barcodeData = '';<br/>        MyElementProto.createdCallback = function() {<br/>        var shadowRoot = this.createShadowRoot();<br/>        var clone = thatDoc.importNode(template, true);<br/>        shadowRoot.appendChild(clone);<br/>        if (this.hasAttribute('inputData')) {<br/>            var data = this.getAttribute('inputData');<br/>            this.setData(data);<br/>        }<br/>        else {<br/>            this.setData(this.data);<br/>        }<br/>    };</span><span id="11fe" class="jy jz ht lq b fv ly lv l lw lx">MyElementProto.attributeChangedCallback = function(attr, oldVal, newVal) {<br/>        if (attr === 'inputData') {<br/>            this.setData(newVal);<br/>        }<br/>    };</span><span id="407c" class="jy jz ht lq b fv ly lv l lw lx">MyElementProto.setData = function(val) {<br/>        this.barcodeInputData = val;</span><span id="5489" class="jy jz ht lq b fv ly lv l lw lx">};</span><span id="521c" class="jy jz ht lq b fv ly lv l lw lx">window.MyElement = thatDoc.registerElement('code39-barcode', {<br/>        prototype: MyElementProto<br/>    });</span><span id="b9e2" class="jy jz ht lq b fv ly lv l lw lx">Module['onRuntimeInitialized'] = onRuntimeInitialized;</span><span id="7e2f" class="jy jz ht lq b fv ly lv l lw lx">function onRuntimeInitialized() {</span><span id="8590" class="jy jz ht lq b fv ly lv l lw lx">var thatDoc = document;<br/>    var list = document.getElementsByTagName("code39-barcode")[0];<br/>    var elements=list.shadowRoot.querySelector(".barcode");<br/>    var elementsHR=list.shadowRoot.querySelector(".barcode_text");</span><span id="4ff0" class="jy jz ht lq b fv ly lv l lw lx">var instance = new Module.Code39();<br/>    instance.inputData = list.barcodeInputData;<br/>    instance.checkDigit = 1;<br/>    elements.innerHTML=instance.encode();<br/>    elementsHR.innerHTML=instance.humanReadableText;<br/>    instance.delete();</span><span id="43d7" class="jy jz ht lq b fv ly lv l lw lx">};</span><span id="3235" class="jy jz ht lq b fv ly lv l lw lx">})(window, document);</span><span id="c6e4" class="jy jz ht lq b fv ly lv l lw lx">&lt;/script&gt;</span></pre><p id="5ac1" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">这个HTML文件包含三个部分。第一部分包含一个HTML“模板”，第二部分包含创建和注册Web组件的Javascript代码，第三部分执行我们的WebAssembly模块。</p><p id="9d43" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">下面的代码使用HTML“template”创建一个影子DOM。您可以将影子DOM视为元素中可以创建组件的限定了作用域的子树。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="1072" class="jy jz ht lq b fv lu lv l lw lx">var MyElementProto = Object.create(HTMLElement.prototype);		<br/>MyElementProto.barcodeData = '';<br/>MyElementProto.createdCallback = function() {<br/>var shadowRoot = this.createShadowRoot();<br/>var clone = thatDoc.importNode(template, true);<br/>shadowRoot.appendChild(clone);</span></pre><p id="aec1" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">下面的代码行在浏览器中注册了我们的定制元素“MYElementProto ”,这样我们就可以使用“code39-barcode”作为标签。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="d2b5" class="jy jz ht lq b fv lu lv l lw lx">window.MyElement = thatDoc.registerElement('code39-barcode', {<br/>        prototype: MyElementProto<br/>    });</span></pre><p id="4d5d" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">在执行WebAssembly模块之前，我们需要加载WASM文件。以下代码行加载由Emscripten工具生成的Javascript。生成这个Javascript是为了帮助我们加载WebAssembly模块。</p><p id="d03e" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">对于我们中的一些人来说，我们可能会发现这个计数器很直观，因为我们需要加载一个Javascript模块来加载一个WebAssembly模块。这是我相信以后会改进的地方。在某种程度上，我们将能够把WebAssembly模块视为HTML网页中的一等公民。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="0650" class="jy jz ht lq b fv lu lv l lw lx">&lt;script type="text/javascript" src="code39.js"&gt;&lt;/script&gt;</span></pre><p id="6314" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">“onRuntimeInitialized”函数是在WASM模块完全加载后执行的函数。在这个函数中，我们从Web组件中获取“barcode”和“barcode _ text”div元素。我们这样做是为了从Web组件标记中获取输入数据，然后将条形码返回给“barcode”div元素。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="1560" class="jy jz ht lq b fv lu lv l lw lx">var thatDoc = document;<br/>var list = document.getElementsByTagName("code39-barcode")[0];<br/>var elements=list.shadowRoot.querySelector(".barcode");<br/>var elementsHR=list.shadowRoot.querySelector(".barcode_text");</span></pre><p id="37b7" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">下面的代码行为我们的WebAssembly模块Code39类声明了一个实例。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="9e86" class="jy jz ht lq b fv lu lv l lw lx">var instance = new Module.Code39();</span></pre><p id="e4fb" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">接下来，我们使用“实例”根据输入数据生成条形码(条形码字符)。一旦用“encode”函数生成了条形码，我们还可以从“instance”中获得“humanReadableText”。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="7de8" class="jy jz ht lq b fv lu lv l lw lx">instance.inputData = list.barcodeInputData;<br/>instance.checkDigit = 1;<br/>elements.innerHTML=instance.encode();<br/>elementsHR.innerHTML=instance.humanReadableText;</span></pre><p id="4f4f" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">6.我们已经完成了Web组件的开发，并在组件中使用WebAssembly来生成条形码。我们可以创建一个简单的HTML文件来测试我们的Web组件。</p><p id="bd2d" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">使用记事本，创建一个包含以下内容的“index.html”文件。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="4e4d" class="jy jz ht lq b fv lu lv l lw lx">&lt;!doctype html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;</span><span id="58ab" class="jy jz ht lq b fv ly lv l lw lx">&lt;meta charset="utf-8"&gt;<br/>&lt;title&gt;&lt;hello-world&gt;&lt;/title&gt;</span><span id="66b9" class="jy jz ht lq b fv ly lv l lw lx">&lt;style TYPE="text/css" media="screen,print"&gt;<br/>     <a class="ae ms" href="http://twitter.com/font" rel="noopener ugc nofollow" target="_blank">@font</a>-face {<br/>       font-family: CCode39;<br/>       src: url("fonts/CCode39.woff") format("woff");<br/>     }<br/>     .barcode {font-weight: normal; font-style: normal; line-height:normal; font-family: 'CCode39', sans-serif; font-size: 32px}<br/>&lt;/style&gt;</span><span id="6e22" class="jy jz ht lq b fv ly lv l lw lx">&lt;link rel="import" href="code39-barcode.html"&gt;</span><span id="4f0a" class="jy jz ht lq b fv ly lv l lw lx">&lt;/head&gt;<br/>&lt;body&gt;</span><span id="7e6a" class="jy jz ht lq b fv ly lv l lw lx">Input : 12345678<br/>Barcode : Code39<br/>Check Digit : 1 (On)<br/>Font Name : ConnectCode39_S3</span><span id="8452" class="jy jz ht lq b fv ly lv l lw lx">Output : </span><span id="f811" class="jy jz ht lq b fv ly lv l lw lx">    &lt;code39-barcode input="12345678"&gt;</span><span id="da9a" class="jy jz ht lq b fv ly lv l lw lx">&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="d53a" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">如下所示的第一行包括Web组件，第二行使用我们之前声明的Web组件标记。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="560c" class="jy jz ht lq b fv lu lv l lw lx">&lt;link rel="import" href="code39-barcode.html"&gt; <br/>.<br/>.<br/>.	 <br/>&lt;code39-barcode input="12345678"&gt;</span></pre><p id="25a0" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">7.保存HTML文件，并在命令提示符下运行以下命令，启动Chrome浏览器来查看我们的Web组件。</p><pre class="jj jk jl jm fq lp lq lr ls aw lt dt"><span id="4fd9" class="jy jz ht lq b fv lu lv l lw lx">emrun --browser chrome index.html</span></pre><p id="3ba0" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">您应该看到以下内容:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mt"><img src="../Images/df3bf5a1cf5d5c33fe1a8f54988eece2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AM2LZSp7DBv9ragz.png"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">WebAssembly Web Components Barcode</figcaption></figure><p id="f0d4" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">本教程说明了未来将带来的许多可能性。</p><ul class=""><li id="03d9" class="me mf ht ky b kz lz lc ma kj mu kn mv kr mw lo mj mk ml mm dt translated">软件供应商可以运输和销售非常优化的(WebAssembly)和标准化的(Web Components)组件，而无需将源代码运输给其他用户。</li><li id="970a" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated">web开发人员可以很容易地以标准化的方式集成第三方组件。</li><li id="dd2b" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated">我们可以想象Java或者。NET可以移植到浏览器中作为WebAssembly运行。开发人员可以使用他们喜欢的工具和编程语言开发他们的Web组件。</li></ul><p id="561d" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">下载可运行的zip文件:</p><ul class=""><li id="7495" class="me mf ht ky b kz lz lc ma kj mu kn mv kr mw lo mj mk ml mm dt translated"><a class="ae ms" href="https://barcoderesource.com/pwa_webcomponents_webassembly.zip" rel="noopener ugc nofollow" target="_blank">pwa _ web components _ web assembly . zip</a></li></ul><p id="9307" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated"><strong class="ky hu">浏览器测试于</strong></p><ul class=""><li id="e520" class="me mf ht ky b kz lz lc ma kj mu kn mv kr mw lo mj mk ml mm dt translated">谷歌浏览器65.0.3325.181(或更高版本)</li></ul><p id="4d8f" class="pw-post-body-paragraph kw kx ht ky b kz lz iu lb lc ma ix le kj mb lg lh kn mc lj lk kr md lm ln lo hm dt translated">注意-通过使用来自框架(如Polymer)的polyfill，上述教程可以在更多浏览器上工作。</p><blockquote class="mx"><p id="869b" class="my mz ht bd na nb nc nd ne nf ng lo ek translated">加入Coinmonks <a class="ae ms" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ms" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae ms" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="jy jz ht bd ka kb nh kd ke kf ni kh ki kj nj kl km kn nk kp kq kr nl kt ku kv dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="me mf ht ky b kz la lc ld kj mg kn mh kr mi lo mj mk ml mm dt translated"><a class="ae ms" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae ms" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated"><a class="ae ms" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae ms" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated"><a class="ae ms" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae ms" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated"><a class="ae ms" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae ms" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="6065" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated"><a class="ae ms" href="https://coincodecap.com/binance-vs-bitstamp" rel="noopener ugc nofollow" target="_blank">币安vs比特邮票</a> | <a class="ae ms" href="https://coincodecap.com/bitpanda-coinbase-coinsbit" rel="noopener ugc nofollow" target="_blank">比特熊猫vs比特币基地vs Coinsbit </a></li><li id="5711" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated"><a class="ae ms" href="https://coincodecap.com/buy-ripple-india" rel="noopener ugc nofollow" target="_blank">如何购买Ripple (XRP) </a> | <a class="ae ms" href="https://coincodecap.com/crypto-exchange-africa" rel="noopener ugc nofollow" target="_blank">非洲最好的加密交易所</a></li><li id="861b" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated"><a class="ae ms" href="https://coincodecap.com/crypto-exchange-africa" rel="noopener ugc nofollow" target="_blank">非洲最佳加密交易所</a> | <a class="ae ms" href="https://coincodecap.com/hoo-exchange-review" rel="noopener ugc nofollow" target="_blank">胡交易所评论</a></li><li id="452c" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated"><a class="ae ms" href="https://coincodecap.com/etoro-robinhood" rel="noopener ugc nofollow" target="_blank"> eToro vs罗宾汉</a>|<a class="ae ms" href="https://coincodecap.com/bybit-bityard-moonxbt" rel="noopener ugc nofollow" target="_blank">MoonXBT vs Bybit vs Bityard</a></li><li id="47a8" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated"><a class="ae ms" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">面向开发人员的最佳加密API</a></li><li id="b359" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated">最佳<a class="ae ms" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated"><a class="ae ms" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae ms" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="me mf ht ky b kz mn lc mo kj mp kn mq kr mr lo mj mk ml mm dt translated">杠杆代币的终极指南</li></ul></div></div>    
</body>
</html>