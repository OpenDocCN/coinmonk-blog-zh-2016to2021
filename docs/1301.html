<html>
<head>
<title>A weekend’s take on gas optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">天然气优化的周末体验</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-weekends-take-on-gas-optimization-74b4c6961ff1?source=collection_archive---------9-----------------------#2018-08-12">https://medium.com/coinmonks/a-weekends-take-on-gas-optimization-74b4c6961ff1?source=collection_archive---------9-----------------------#2018-08-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="65ec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在过去的两天里，我一直在优化一个智能契约库，它为<a class="ae jo" href="https://github.com/lorenzb/libsubmarine/" rel="noopener ugc nofollow" target="_blank">高级提交-揭示方案</a>执行merkle-patricia证明验证。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/4e2da8bc0d9871676a59d69956b7e0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*AncVKZMSDnJZK3NGnutFlw.png"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">By Freepik</figcaption></figure><p id="287e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这个项目之前，我经常满足于诸如“将存储数据放在结构中”和“永远不要使用for循环”这样的启发式方法，以避免惊人的汽油费用。虽然这些启发法可以走很长一段路，我想看看我是否能发现一些其他可能更微妙的启发法，可以为我节省一两个气体。</p><h1 id="72e7" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">向内存声明变量。</h1><p id="b29e" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">当在函数中编写复杂的逻辑时，我经常发现自己在重复读取同一个存储变量。事实证明，这不是最好的主意。</p><blockquote class="le"><p id="0c28" class="lf lg ht bd lh li lj lk ll lm ln jn ek translated">如果一个变量在一个函数中不止一次被使用，那么这个变量应该被声明到内存中。</p></blockquote><p id="477e" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">从存储器中读取一个数据字的SLOAD操作码花费200 gas，而从存储器中写入和读取的MSTORE和MLOAD操作码每个仅花费3 gas。</p><p id="8c4e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以下代码演示了启发式方法:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lt lu l"/></div></figure><h1 id="1cab" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">使用正确的类型。</h1><p id="e31c" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">我的直觉告诉我，我应该总是使用尽可能小的数据类型，以防止保留我知道我永远不会使用的空间。我的直觉又一次误导了我。</p><blockquote class="le"><p id="a504" class="lf lg ht bd lh li lj lk ll lm ln jn ek translated">除非可以进行结构打包，否则最佳存储类型总是32字节/ 256位长。</p></blockquote><p id="2b5c" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">任何存储都被编译成一个字节数组，该数组存储在协定的存储merkle-patricia树中。这个字节数组中的每一项都需要由32个字节(256位)组成。这意味着任何较小的数据都用零填充，以填充32个字节，这需要来自EVM的额外操作，并且花费更多的汽油！</p><p id="77fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面的代码显示了在存储中声明uint256和uint128之间的区别。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lt lu l"/></div></figure><h1 id="9488" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结构包装的微妙之处。</h1><p id="10eb" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">我已经提到过几次，结构打包是一个很好的启发。当我学会这种启发式方法时，我开始把我所有的存储数据放在结构体中。事实证明，有一些微妙之处需要解决。</p><blockquote class="le"><p id="60f2" class="lf lg ht bd lh li lj lk ll lm ln jn ek translated">仅当组合数据是32字节的倍数时，结构打包才有效。</p></blockquote><p id="4093" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">在前面的试探法中，我们提到数据被填充到32字节。在一个结构中，可以放置多种数据类型，这些数据类型加起来有32个字节，但在存储时表现得像一个32字节的对象。然而，以下微妙之处适用:</p><ol class=""><li id="d5ce" class="lv lw ht is b it iu ix iy jb lx jf ly jj lz jn ma mb mc md dt translated">将一个32字节的类型放在一个结构中比把它放在外面代价更高。</li><li id="a6aa" class="lv lw ht is b it me ix mf jb mg jf mh jj mi jn ma mb mc md dt translated">打包以32字节的倍数进行，因此将小于32字节的类型单独放在结构中不会节省任何空间。</li><li id="dfb8" class="lv lw ht is b it me ix mf jb mg jf mh jj mi jn ma mb mc md dt translated">可以将数字和字符串打包在一起。</li></ol><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lt lu l"/></div></figure><h1 id="d4f2" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">现在就这样吧！</h1><p id="7d40" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">如果你有任何启发/字幕要分享，给我喊一声@thegostep</p><p id="322b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我的朋友<a class="mj mk gr" href="https://medium.com/u/f63ea2773bc3?source=post_page-----74b4c6961ff1--------------------------------" rel="noopener" target="_blank">赫尔南多·卡斯塔诺</a>分享了一篇很棒的文章，其中涵盖了<a class="ae jo" href="https://blog.cotten.io/thinking-in-solidity-6670c06390a9" rel="noopener ugc nofollow" target="_blank">在solidity】中实现快速排序的细节。值得一读！</a></p><p id="3a07" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">快乐优化！😄</p></div></div>    
</body>
</html>