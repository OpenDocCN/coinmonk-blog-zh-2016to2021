<html>
<head>
<title>Design patterns in Typescript made easy — part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让Typescript中的设计模式变得简单——第一部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/design-patterns-in-javascript-made-easy-part-i-10334decb204?source=collection_archive---------2-----------------------#2018-10-08">https://medium.com/coinmonks/design-patterns-in-javascript-made-easy-part-i-10334decb204?source=collection_archive---------2-----------------------#2018-10-08</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/3f9468f87902ddec5af11572cb7b8cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBE9U7G4gNybRXviqtY8Rg.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Moroccan pattern (Zellij)</figcaption></figure><p id="3d25" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt kd translated">如果你在这里，你很可能是Javascript开发人员或最佳实践代码爱好者，无论哪种情况都欢迎。</p><p id="e9b8" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">今天我将讲述设计模式，从最佳实践和架构的角度来看，它被认为是日常编程问题的最佳解决方案。</p><p id="72f4" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在这一系列文章中，我将尝试涵盖编程领域，尤其是Javascript中最常用的模式。</p><p id="7cff" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">为什么是Javascript？首先，根据<a class="ae km" href="https://insights.stackoverflow.com/survey/2017#technology-programming-languages" rel="noopener ugc nofollow" target="_blank"> StackOverflow的年度调查</a>，它成为今年世界上使用最多的编程语言。</p><p id="901c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">其次，学习Javascript设计模式的资源很少，这是因为Javascript的本质:根据<a class="ae km" href="https://en.wikipedia.org/wiki/JavaScript" rel="noopener ugc nofollow" target="_blank">维基百科的定义</a>，它是动态的、弱类型的、基于原型的和多范例的。</p><p id="58fb" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在本文中，我将介绍创造性设计模式，它们是处理对象创建机制的模式，试图在给定的情况下以合适的方式创建对象。</p></div><div class="ab cl kn ko hb kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hm hn ho hp hq"><h1 id="a908" class="ku kv ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">什么是模式？</h1><p id="6af9" class="pw-post-body-paragraph jf jg ht jh b ji ls jk jl jm lt jo jp jq lu js jt ju lv jw jx jy lw ka kb kc hm dt kd translated"><span class="l ke kf kg bm kh ki kj kk kl di"/>模式是一种可重用的解决方案，可以应用于软件设计中常见的问题——在我们的例子中——编写Javascript web应用程序。看待模式的另一种方式是作为我们如何解决问题的模板——可以在很多不同的情况下使用的模板。<em class="lx">(Adnan Osmani所著《学习JavaScript设计模式》一书)</em></p><p id="44df" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在我们开始之前，我必须配置Javascript项目以使用Typescript来受益于面向对象编程的强大功能，例如接口和类型:</p><p id="be3d" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">首先要做的是从github获取我的样板文件:</p><pre class="ly lz ma mb fq mc md me mf aw mg dt"><span id="5260" class="mh kv ht md b fv mi mj l mk ml">$ git clone <a class="ae km" href="https://github.com/AbderrahimSoubaiElidrissi/nodejs-typescript-boilerplate.git" rel="noopener ugc nofollow" target="_blank">https://github.com/AbderrahimSoubaiElidrissi/nodejs-typescript-boilerplate.git</a></span><span id="fdfe" class="mh kv ht md b fv mm mj l mk ml">$ cd nodejs-typescript-boilerplate</span><span id="617b" class="mh kv ht md b fv mm mj l mk ml">$ npm install</span></pre><p id="ac5c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">现在我们已经准备好了工作空间，我们可以从第一个设计模式开始</p><h1 id="2a65" class="ku kv ht bd kw kx mn kz la lb mo ld le lf mp lh li lj mq ll lm ln mr lp lq lr dt translated">1.构造函数模式:</h1><blockquote class="ms mt mu"><p id="af30" class="jf jg lx jh b ji jj jk jl jm jn jo jp mv jr js jt mw jv jw jx mx jz ka kb kc hm dt translated">在经典的面向对象编程语言中，构造函数是一种特殊的方法，用于在为新创建的对象分配内存后初始化该对象。在JavaScript中，几乎所有东西都是对象，所以我们最感兴趣的是<em class="ht">对象</em>构造函数。</p></blockquote><p id="3886" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">问题:</strong></p><p id="07c6" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们的应用程序使用一个对象来构造数据并调用服务的方法，所以我们需要初始化这些对象并填充它们的属性。</p><p id="024c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">解决方案:</strong></p><p id="0a85" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">构造函数是一种“神奇”的方法，用于初始化对象的属性，并在对象初始化时调用方法。</p><p id="0381" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">例如:</strong></p><p id="30a3" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">使用以下代码片段获取src/app.ts编辑文件:</p><figure class="ly lz ma mb fq iu"><div class="bz el l di"><div class="my mz l"/></div></figure><p id="48e3" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们可以在控制台中看到“Hello world”在“npm start”之后，这意味着我们的构造函数已经将参数中传递的值设置为属性greeting</p><h1 id="eae1" class="ku kv ht bd kw kx mn kz la lb mo ld le lf mp lh li lj mq ll lm ln mr lp lq lr dt translated">2.单一模式:</h1><figure class="ly lz ma mb fq iu fe ff paragraph-image"><div class="fe ff na"><img src="../Images/8da5a09f3216dc3de8f9745abf5a9acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*FFhIuK-Y9k1FrBXLWKtYyg.png"/></div></figure><p id="ae25" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">下一个模式是最著名的模式之一，因为它是四种设计模式中的一员。</p><p id="c6a3" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">问题:</strong></p><p id="51ca" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们的应用程序只需要一个具有全局公共访问的给定类的实例(示例会话实例)。</p><p id="19e9" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">解决方案:</strong></p><p id="6440" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">Singleton模式是一种限制类的实例化的解决方案，它确保类只存在一个实例。Singleton大多数提供了一个全局访问点来获取类的实例。通常我们使用singleton模式来实现日志、缓存、会话等功能</p><p id="1dc0" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">举例</strong>:</p><figure class="ly lz ma mb fq iu"><div class="bz el l di"><div class="my mz l"/></div></figure><p id="6b33" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">下面的代码将抛出错误，因为我们在属性实例中存储了早期的Singleton类实例。另一个不用测试构造函数中的实例就能强制执行单例模式的有趣想法是将单例类的构造函数设为私有，这将阻止人们实例化你的类</p><pre class="ly lz ma mb fq mc md me mf aw mg dt"><span id="a411" class="mh kv ht md b fv mi mj l mk ml">let mySuperInstance = new Singleton(); // Error</span></pre><p id="a352" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">要实例化单例，您必须调用静态方法getInstance()</p><pre class="ly lz ma mb fq mc md me mf aw mg dt"><span id="e0f4" class="mh kv ht md b fv mi mj l mk ml">let mySuperInstance = Singleton.getInstance(); // success</span></pre><h1 id="c091" class="ku kv ht bd kw kx mn kz la lb mo ld le lf mp lh li lj mq ll lm ln mr lp lq lr dt translated">3.原型模式:</h1><figure class="ly lz ma mb fq iu fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/ada9f0d991c7646070260d4b5558f81c.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*zZ5_U5KmjuSw5wsbp9GMGw.png"/></div></figure><p id="815c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们下一个设计模式是原型设计模式。当要创建的对象类型由原型确定时，使用原型，通常是为了通过降低创建对象的成本来提高体系结构的性能。</p><p id="c2fd" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">问题:</strong></p><p id="cec7" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们的应用程序需要对象来实现功能，但是从性能的角度来看，对象的创建(使用operator new)代价很高，例如，对象实例的创建涉及调用数据库或进行API调用。</p><p id="1ea9" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">解决方案:</strong></p><p id="eb7b" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">当对象创建是耗时且高成本的操作时，原型模式是必需的，因此我们用现有的对象本身创建一个对象。从现有对象创建对象的最佳可用方法之一是<strong class="jh hu"> clone()方法</strong>。克隆是实现原型模式的最简单的方法。但是，如何根据您的业务模型复制现有对象是您自己的事情。</p><p id="f49e" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">示例:</strong></p><figure class="ly lz ma mb fq iu"><div class="bz el l di"><div class="my mz l"/></div></figure><p id="c86a" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我创建了接口ICloneable来强制原型类实现方法clone()。clone方法返回prototype类实例的精确克隆结果，我们有一个类的两个实例，只使用了一次“new”操作符，这种做法降低了创建一个重对象(循环、数据库调用……)的成本</p><p id="c071" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">要测试设计模式:</p><pre class="ly lz ma mb fq mc md me mf aw mg dt"><span id="2961" class="mh kv ht md b fv mi mj l mk ml">//the instance<br/>let prototype = new Prototype(1);</span><span id="6d41" class="mh kv ht md b fv mm mj l mk ml">//the clone<br/>let pClone = prototype.clone();</span><span id="15a7" class="mh kv ht md b fv mm mj l mk ml">console.log(prototype.list[10] === pClone.list[10] ); //true<br/>console.log(prototype.identity === pClone.identity); //true</span></pre></div><div class="ab cl kn ko hb kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hm hn ho hp hq"><p id="4cb8" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在下一篇文章中，我将通过实例介绍更多的设计模式，并通过给定问题的真实用例进行解释</p><p id="5639" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">参考资料:</p><div class="nc nd fm fo ne nf"><a href="https://github.com/torokmark/design_patterns_in_typescript" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab ej"><div class="nh ab ni cl cj nj"><h2 class="bd hu fv z el nk eo ep nl er et hs dt translated">to romark/design _ patterns _ in _ typescript</h2><div class="nm l"><h3 class="bd b fv z el nk eo ep nl er et ek translated">triangular _ ruler:TypeScript中的设计模式实现—to romark/Design _ patterns _ in _ TypeScript</h3></div><div class="nn l"><p class="bd b gc z el nk eo ep nl er et ek translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt iz nf"/></div></div></a></div><div class="nc nd fm fo ne nf"><a href="https://www.oreilly.com/library/view/learning-javascript-design/9781449334840/ch09s01.html" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab ej"><div class="nh ab ni cl cj nj"><h2 class="bd hu fv z el nk eo ep nl er et hs dt translated">学习JavaScript设计模式</h2><div class="nm l"><h3 class="bd b fv z el nk eo ep nl er et ek translated">在经典的面向对象编程语言中，构造函数是一种特殊的方法，用于…</h3></div><div class="nn l"><p class="bd b gc z el nk eo ep nl er et ek translated">www.oreilly.com</p></div></div><div class="no l"><div class="nu l nq nr ns no nt iz nf"/></div></div></a></div><div class="nc nd fm fo ne nf"><a href="https://www.tutorialspoint.com/design_pattern/prototype_pattern.htm" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab ej"><div class="nh ab ni cl cj nj"><h2 class="bd hu fv z el nk eo ep nl er et hs dt translated">设计模式原型模式</h2><div class="nm l"><h3 class="bd b fv z el nk eo ep nl er et ek translated">设计模式原型模式——以简单易行的步骤学习java设计模式:初学者教程…</h3></div><div class="nn l"><p class="bd b gc z el nk eo ep nl er et ek translated">www.tutorialspoint.com</p></div></div><div class="no l"><div class="nv l nq nr ns no nt iz nf"/></div></div></a></div><blockquote class="nw"><p id="c6a0" class="nx ny ht bd nz oa ob oc od oe of kc ek translated"><a class="ae km" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="oh oi oj ok ol iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff og"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>