<html>
<head>
<title>Merkle root of a bitcoin block calculated in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C#计算的比特币块的Merkle根</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/merkle-root-of-a-bitcoin-block-calculated-in-c-8c659a3b3290?source=collection_archive---------1-----------------------#2019-01-23">https://medium.com/coinmonks/merkle-root-of-a-bitcoin-block-calculated-in-c-8c659a3b3290?source=collection_archive---------1-----------------------#2019-01-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><blockquote class="iq ir is"><p id="fe9d" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">(本文假设您对区块链的工作原理有基本的了解，目的是让您对块中包含的事务有一点了解)</p></blockquote><h2 id="4c17" class="js jt ht bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dt translated">什么是Merkle树？</h2><p id="ebcd" class="pw-post-body-paragraph it iu ht iw b ix kq iz ja jb kr jd je kd ks jh ji kh kt jl jm kl ku jp jq jr hm dt translated">Merkle树又名二进制哈希树，是一种用于有效总结和验证大型数据集完整性的数据结构<br/> Merkle树是一种倒置的树结构，其根(称为<strong class="iw hu"> Merkle根</strong>)在顶部，叶子在底部。请参见下面的示例。<br/>比特币和区块链技术中使用这种数据结构来总结一个区块中的所有交易，提供了一个非常有效的流程来验证一个交易是否包含在一个区块中。</p><figure class="kw kx ky kz fq la fe ff paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="fe ff kv"><img src="../Images/dd803212396ce9a7c63d1670cee6afda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prtcx2rVQZmX9oZcyrC_gQ.png"/></div></div></figure><h2 id="23dd" class="js jt ht bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dt translated">一点历史</h2><p id="c296" class="pw-post-body-paragraph it iu ht iw b ix kq iz ja jb kr jd je kd ks jh ji kh kt jl jm kl ku jp jq jr hm dt translated">Merkle也是公钥密码学的发明者之一，他似乎早就从密码学转移到解决更有趣的问题上了。你可以在这里查看他的网页。<br/>在学习Merkle tree的时候，我有一个想法，想快速编写一些代码，从比特币链下载一个区块，并计算交易的Merkle根，看看我是否会到达由区块挖掘器计算并由网络验证的相同的Merkle根，因为……为什么不呢？</p><p id="0268" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">维基百科对merkle树的定义是</p><p id="7dbf" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated"><em class="iv">Merkle树递归定义为</em> <a class="ae lh" href="https://en.wikipedia.org/wiki/Hash_list" rel="noopener ugc nofollow" target="_blank"> <em class="iv">哈希列表</em> </a> <em class="iv">的二叉树，其中父节点为其子节点的哈希，叶节点为原始数据块的</em> <strong class="iw hu"> <em class="iv">哈希。</em> </strong></p><p id="4c9c" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">这与比特币区块链中merkle树的实现方式一致。</p><p id="23d8" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated"><strong class="iw hu">算法大致如下</strong></p><ul class=""><li id="6838" class="li lj ht iw b ix iy jb jc kd lk kh ll kl lm jr ln lo lp lq dt translated">事务表示原始数据块，这些数据块被散列以产生形成叶节点的事务散列(事务id)。</li><li id="cd2c" class="li lj ht iw b ix lr jb ls kd lt kh lu kl lv jr ln lo lp lq dt translated">叶节点的数量必须是偶数，这样二进制散列树才能工作，因此如果叶节点的数量是奇数，则复制最后一个叶节点，使计数为偶数。</li><li id="794c" class="li lj ht iw b ix lr jb ls kd lt kh lu kl lv jr ln lo lp lq dt translated">每对叶节点被连接和散列以形成第二行散列。</li><li id="4d3a" class="li lj ht iw b ix lr jb ls kd lt kh lu kl lv jr ln lo lp lq dt translated">重复该过程，直到获得只有两个散列的行</li><li id="49cb" class="li lj ht iw b ix lr jb ls kd lt kh lu kl lv jr ln lo lp lq dt translated">这最后两个散列被连接起来形成Merkle根。</li></ul><p id="617c" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">从算法来看，它看起来非常简单，我非常有信心能够立即编写代码并验证比特币区块链<a class="ae lh" href="https://blockchain.info/r" rel="noopener ugc nofollow" target="_blank">https://block chain . info</a>中某个区块的Merkle根。</p><p id="a698" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">拿着我的(隐喻的)啤酒…</p><p id="2ce5" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated"><strong class="iw hu">递归……真的吗？</strong></p><p id="5448" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">嗯……你可以只使用while循环，但是这里的重点是<strong class="iw hu">区块链</strong>，而不是算法，递归总是很有趣。:)</p><figure class="kw kx ky kz fq la fe ff paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="fe ff lw"><img src="../Images/418f2106c6e64616e67fca5a5d8ccd65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDwylvLCpJMVoPMditnDTg.png"/></div></div></figure><p id="5fe5" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">几个小时后，我感到非常恼火；算法很简单，但是，我的Merkle根与块中的根不匹配，我真的不知道为什么。</p><p id="3692" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated"><strong class="iw hu">魔鬼总是在细节中</strong></p><p id="1d6d" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">在查看《比特币开发者参考》时，我发现了以下内容</p><p id="7ceb" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated"><em class="iv">如果一个块有三个或三个以上的事务，则形成中间merkle树行。TXID按顺序成对放置，从coinbase事务的TXID开始。每一对被连接在一起作为64个原始字节，并且</em><strong class="iw hu"><em class="iv">sha 256(sha 256())</em></strong><em class="iv">被散列以形成第二行散列。</em></p><figure class="kw kx ky kz fq la fe ff paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="fe ff lx"><img src="../Images/0ab55790be8a13be4f57b1d9bf072de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*70hDjugZbx_2faHI0Qv66A.png"/></div></div></figure><p id="f80f" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">看起来我需要对连接的对进行双重散列，而不是仅仅进行一次散列，所以我很高兴地进行了更改，编译并运行了代码。令人失望的是，仍然没有喜悦，我认真考虑只是把它留在那里，因为开始只是一个随机的想法，现在花费我的时间，而让我不满意。但是我被迷住了，我必须知道为什么我的代码不起作用。在谷歌上搜索了一段时间，并与一位区块链爱好者交谈后，我偶然发现了一个我并不太熟悉的概念…</p><p id="8c5d" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated"><strong class="iw hu">小端和大端</strong></p><p id="27bc" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">本质上，这指的是计算机如何存储多字节数。</p><p id="6de8" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated"><strong class="iw hu">“小端序</strong>”机器将数字的<strong class="iw hu">低位</strong>顺序字节存储在内存的<strong class="iw hu">最低</strong>地址，将<strong class="iw hu">高位</strong>顺序字节存储在<strong class="iw hu">最高</strong>地址。</p><p id="3449" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated"><strong class="iw hu">【大端】</strong>机器将数字的<strong class="iw hu">高位</strong>顺序字节存储在<strong class="iw hu">最低</strong>地址，将<strong class="iw hu">低位</strong>顺序字节存储在<strong class="iw hu">最高</strong>地址。</p><p id="8eb7" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">比方说，你有一个4字节的长度</p><p id="087b" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">字节3字节2字节1字节0</p><pre class="kw kx ky kz fq ly lz ma mb aw mc dt"><span id="132b" class="js jt ht lz b fv md me l mf mg"><strong class="lz hu">In little endian machines , it will be arranged in memory as </strong></span><span id="a632" class="js jt ht lz b fv mh me l mf mg">    Address0   Byte0<br/>    Address1   Byte1<br/>    Address2   Byte2<br/>    Address3   Byte3</span><span id="ddf3" class="js jt ht lz b fv mh me l mf mg"><strong class="lz hu">In big endian machines , it will be arranged in memory as </strong>     <br/>    <br/>    Address0   Byte3<br/>    Address1   Byte2<br/>    Address2   Byte1<br/>    Address3   Byte0</span></pre><p id="418a" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">在比特币中，交易数据中的大多数字段都是小端格式。<strong class="iw hu"> <em class="iv">从小端转换到大端</em> </strong> <em class="iv">时，先交换每对字符，然后反转字符串。</em></p><p id="297f" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated"><strong class="iw hu">所以修复只是简单的</strong></p><ul class=""><li id="c293" class="li lj ht iw b ix iy jb jc kd lk kh ll kl lm jr ln lo lp lq dt translated">之前将事务哈希从小端转换为大端。运行BuildMerkleRoot算法。</li><li id="debb" class="li lj ht iw b ix lr jb ls kd lt kh lu kl lv jr ln lo lp lq dt translated">将Merkle根转换回小端字节序</li></ul><figure class="kw kx ky kz fq la fe ff paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="fe ff mi"><img src="../Images/7bc2298ca7bd98c82db850e824163df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amuSF6XPVW7piLvKKAwRjA.png"/></div></div></figure><p id="c8c8" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">瞧啊。最后，我得到了我的merkle根，现在我的啤酒呢？:).</p><p id="7567" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated"><strong class="iw hu">总结</strong></p><p id="7887" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">那么，区块链的默克尔树有什么意义呢？</p><p id="e667" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">在本文中没有过多的细节，Merkle根最终包含在块头中，并提供了一种验证块中事务的方法。</p><p id="3281" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">块头包含先前块头的散列，该散列包括先前块的Merkle根等..将事务链接到第一个块(起源块),这意味着事务数据中的任何微小变化都会导致不同的Merkle根，这将使块无效</p><p id="ffe1" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">Merkle树的另一个关键用例是在<strong class="iw hu">简单支付验证</strong>中，您可以通过显示事务的Merkle分支来证明事务存在于块中。</p><p id="c80b" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">我已经包含了一个GitHub链接到完整的代码【https://github.com/chidionyema/merkleroot<a class="ae lh" href="https://github.com/chidionyema/merkleroot" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="3883" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">你可以用来自https://www.blockchain.com/<a class="ae lh" href="https://www.blockchain.com/" rel="noopener ugc nofollow" target="_blank">的任何块散列替换代码中的块散列，Merkle根应该是相同的。</a></p><p id="d337" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kd jg jh ji kh jk jl jm kl jo jp jq jr hm dt translated">放弃</p><ul class=""><li id="fb46" class="li lj ht iw b ix iy jb jc kd lk kh ll kl lm jr ln lo lp lq dt translated">这只是<em class="iv">获取它的工作代码</em>:)</li></ul><blockquote class="mj"><p id="9aa5" class="mk ml ht bd mm mn mo mp mq mr ms jr ek translated"><a class="ae lh" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mu mv mw mx my la fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mt"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>