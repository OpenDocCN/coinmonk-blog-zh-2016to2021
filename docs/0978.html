<html>
<head>
<title>Paxos made simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的Paxos帕克索</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/paxos-made-simple-3b83c05aac37?source=collection_archive---------1-----------------------#2018-07-09">https://medium.com/coinmonks/paxos-made-simple-3b83c05aac37?source=collection_archive---------1-----------------------#2018-07-09</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="4647" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">摘要</h2></div><p id="851c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Paxos帕克索在展示图表/图片时非常简单。(Lamport对本文的摘要只有一行文字:Paxos算法，用简单的英语表述，非常简单)</p><h2 id="1285" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">介绍</h2><p id="9e44" class="pw-post-body-paragraph ji jj ht jk b jl kz iu jn jo la ix jq jr lb jt ju jv lc jx jy jz ld kb kc kd hm dt translated">分布式系统使用许多商用机器来实现高可用性和可伸缩性。这样的机器不是可靠的实体，它们经常出现和消失。在这种系统中，通常需要就“某些事情”达成一致，即达成共识。这里的“某物”取决于上下文。例如:</p><p id="4670" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在一个在许多分支机构运营并进行许多交易的数字化系统(如银行)中，需要对所有账户有一个一致的看法。在给定的时间点，银行有一个一致的状态，这反过来又转化为所有银行账户中的正确金额。实现这一点的一种方法是在一定数量的服务器节点上维护有序的操作日志(一个服务器节点是不够的，因为它可能会停机，从而影响可用性和可伸缩性)。这些服务器节点上有序日志的一致视图确保了系统中所有账户的一致视图:基本上，银行成为一个状态机，它将所有账户的当前状态和调整账户以反映最新交易的有序操作日志作为输入。从这里开始，我们将只担心这些需要维护有序日志一致性的服务器节点。</p><p id="571a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因此，每个服务器节点都有自己的日志，当用户从自己的账户中存钱或取钱时，节点可以相互通信以建立订单。这样，一个客户端可以连接到一个服务器，而另一个客户端可以连接到不同的服务器，并且仍然可以获得银行当前状态(即帐户值)的相同视图。此外，请记住，故障是非拜占庭式的，即银行中的服务器节点不会受到合谋和恶意更改日志的激励。(这里需要注意的是，比特币网络也需要解决类似的问题，但由于节点的不信任性质，故障可能是拜占庭式的)</p><p id="593a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在，让我们看看所有节点如何能够在一致的日志视图上达成一致。一个更简单的问题是，首先要弄清楚节点如何能在一个不变的值上达成一致，即事务X和y(这里事务X是日志的索引。让我们暂时忽略它)，Y是节点网络需要在所有节点上的日志中的索引X处达成一致并提交的值。让我们称之为基本的Paxos。一旦我们建立了这一点，我们就可以使用它作为构建块来实现分布式有序日志。</p><blockquote class="le"><p id="d548" class="lf lg ht bd lh li lj lk ll lm ln kd ek translated">交易新手？试试<a class="ae lo" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae lo" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><h2 id="f010" class="ke kf ht bd kg kh lp kj kk kl lq kn ko jr lr kq kr jv ls kt ku jz lt kw kx ky dt translated">共识问题定义—基本共识</h2><ol class=""><li id="13aa" class="lu lv ht jk b jl kz jo la jr lw jv lx jz ly kd lz ma mb mc dt translated">即使提出了单个值，网络最终也会识别并选择它。(C1)</li><li id="0e63" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">一旦网络选择了该值，它就不能被覆盖。(C2)</li><li id="6e7e" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">节点听不到一个值被选择，除非它真的被网络选择了。(C3)</li></ol><h2 id="623c" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">建议值的组成部分和状态</h2><p id="56f6" class="pw-post-body-paragraph ji jj ht jk b jl kz iu jn jo la ix jq jr lb jt ju jv lc jx jy jz ld kb kc kd hm dt translated">在这个算法中，有两个主要部分:提议者(P)和接受者(A)。还有一个听者(L)，但是对于讨论的大部分来说就没那么有趣了。每个节点充当所有三个节点。提议者根据客户的要求提出价值，比如存放一些钱。接受者接受值，当有多数/法定人数时，建议的值被选择并提交到日志。因此，建议值会经历以下状态。选择状态是值的最终状态，在值被选择之前，在P和A之间可能有很多来回。参见下面的图1。</p><figure class="mj mk ml mm fq mn fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mi"><img src="../Images/31d2dd650e8e95e42a29e603327054f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Be5uerc0AxdIZcy_xFjhHQ.jpeg"/></div></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek"><strong class="bd my">States of a proposed “Value” and Lack of majority scenarios</strong></figcaption></figure><p id="e7df" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">图表上的命名:</strong></p><ol class=""><li id="d37f" class="lu lv ht jk b jl jm jo jp jr mz jv na jz nb kd lz ma mb mc dt translated">N1和N2是服务器节点。</li><li id="c932" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">随着时间的推移，图从左到右显示了每台服务器正在做什么。</li><li id="4515" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">点通常代表给定节点在时间尺度上的给定时间的值的建议。</li><li id="1ab6" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">提议/准备和接受/选择是同义词。</li></ol><p id="bff7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">图2解释了在网络中缺乏多数是如何发生的。由于没有多数，一个选定的价值观不会出现。</p><h2 id="76c3" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">提议者(P)和接受者(A)的角色</h2><p id="b58c" class="pw-post-body-paragraph ji jj ht jk b jl kz iu jn jo la ix jq jr lb jt ju jv lc jx jy jz ld kb kc kd hm dt translated">提议者提出价值，接受者接受价值。让我们定义初始RPC来达成共识。</p><ol class=""><li id="00d0" class="lu lv ht jk b jl jm jo jp jr mz jv na jz nb kd lz ma mb mc dt translated">p调用在所有As上准备(v) RPC。有些A会返回一些值，但是我们暂时忽略这些。</li><li id="a69f" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">一旦多数A返回，P可以调用accept(v)给那些A(取决于从1返回的值)。有可能返回值不会导致共识，然后P将不得不再次进行新一轮的准备(Vnew)。</li></ol><h2 id="f199" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">进化算法</h2><p id="db0f" class="pw-post-body-paragraph ji jj ht jk b jl kz iu jn jo la ix jq jr lb jt ju jv lc jx jy jz ld kb kc kd hm dt translated">基于“共识问题定义”一节中的问题定义，算法需要具有以下特性:</p><p id="3144" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="nc">调整1 </em></p><p id="41b2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">任何一个A都必须接受它收到的第一个值来满足C1。当只有一个prepare(v)调用时，这样做很好。如果提出了一个以上的值，那么就会导致上面图2中提到的问题——“缺乏多数”。</p><p id="6a85" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="nc">调整2 </em></p><p id="1798" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因此，为了补救这一点并达成某种共识，A必须接受不止一个值。这会导致之前选择的值被覆盖的问题，这违反了问题定义中定义的C2。见图“值-覆盖”:在这个N5提出v2，在一个值v1已经被多数同意之后。</p><figure class="mj mk ml mm fq mn fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff nd"><img src="../Images/9fa2131a66fbd77d8610c7490ec00aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJo2XINpg764I2h1xGfJgA.jpeg"/></div></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek">Value overwritten when a node can accept more than one value</figcaption></figure><p id="a4d4" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="nc">调整3 </em></p><p id="96c8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因此，为了补救2，在上面的同一个图中，当N5将要提议/准备v2时，它可以检查是否有先前选择的值。如果有，那么它将建议(v1)而不是v2。这被称为两阶段协议——先检查，然后提议。</p><p id="da41" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="nc">调整4 </em></p><p id="899f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这个解决方案仍然有一些问题。这些取决于N5提案何时开始。它可以在接受或选择任何值之前开始。这种情况可能发生在提议者或接受者身上。见图“接受者-拒绝”。在这种情况下，N3拒绝v2，因为后来的提议覆盖了已经达成的共识。</p><figure class="mj mk ml mm fq mn fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff nd"><img src="../Images/5a20d7ee7f5a42a03059125173def4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kg39njfRBGXfRpIzDrRLlw.jpeg"/></div></div></figure><p id="0c1f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="nc">调整5 </em></p><p id="5262" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">关于N5第二个提案的时间安排的另一个问题如图“旧提案-拒绝”所示。这里v2首先到达法定人数，然后v1和N1:propose(v1)稍后到达。当N5开始时，没有达成共识，所以它不可能知道v1，而不是v2。</p><figure class="mj mk ml mm fq mn fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff nd"><img src="../Images/3778f699dd23d9c97e4f51bf7675d917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5lnMjD8szVaRA0stWVmwzA.jpeg"/></div></div></figure><p id="2b9d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了解决这个问题，节点N3需要拒绝较旧的提议，即较早开始的提议——N1:v1。这可以通过为每个提案指定一个全球唯一的序列号来实现:</p><ol class=""><li id="1d42" class="lu lv ht jk b jl jm jo jp jr mz jv na jz nb kd lz ma mb mc dt translated"><counter> <node-id>即低位保存node-id，高位保存单调递增的计数器。</node-id></counter></li><li id="2439" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">或者给每个服务器节点分配一些不连续的唯一id集，然后它们可以单调增加。</li><li id="8005" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">服务器需要将这些值保存到磁盘上，这样它们就可以从崩溃中恢复，并且总是从它们的终端发出更高的建议号。</li><li id="930e" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">接受者必须在磁盘上记住编号最高的提议和他们接受的价值。</li></ol><h2 id="8d82" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">形式化算法</h2><p id="c7c8" class="pw-post-body-paragraph ji jj ht jk b jl kz iu jn jo la ix jq jr lb jt ju jv lc jx jy jz ld kb kc kd hm dt translated">有两个重要的项目需要跟踪。一个是提案编号本身，第二个是提案的价值。请记住，当你通读时，这两个是不同的实体。</p><ol class=""><li id="ff8d" class="lu lv ht jk b jl jm jo jp jr mz jv na jz nb kd lz ma mb mc dt translated">提议者发送提议号n，并使用prepare方法将其广播到所有节点。</li><li id="57ca" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">接受者查看该建议，并承诺不接受任何更低的建议，即数量小于n。如果接受者看到更高的建议数量，则拒绝该建议。</li><li id="c1e9" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">此外，一旦接受者接受建议<strong class="jk hu">值</strong>，它将只接受来自更高建议编号的相同建议值。</li><li id="0ee0" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">如果大多数接受者回复，那么接受者使用它回复的最高建议号的值v。当多数人不同意时，那么算法需要回到步骤1。</li><li id="8e19" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">提议者现在创建一个具有数字n和值v的接受消息，并将其发送给在步骤2中响应的接受者。</li><li id="f423" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">接受者将接受此建议<strong class="jk hu">编号</strong>和<strong class="jk hu">值</strong>，如果他们尚未回复更高的建议编号。</li></ol><h2 id="cafc" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">关键要点</h2><ol class=""><li id="f881" class="lu lv ht jk b jl kz jo la jr lw jv lx jz ly kd lz ma mb mc dt translated">“准备和接受”的两阶段方法确保唯一能够获胜的<strong class="jk hu">值</strong>是既准备好又被接受的值。只要一些P可以在大多数节点上获得其准备和接受消息，基本的paxos将返回该值。</li><li id="d88a" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated"><strong class="jk hu">僵局:</strong>他的方法的问题是，它仍然会遇到没有法定人数的情况。如果序列是这样的，这些消息到达节点N3，并由N1和N5发送:<em class="nc">:N1:准备(1)，N5:准备(2)，N1:接受(1)，N1:准备(3)，N5:接受(2)。</em>这里N5:prepare(2)覆盖N1:prepare(1)并切断N1:accept(1)。在N5可以执行N5:accept(2)之前，N1带着N1的更高编号的提议:prepare(3)回来，并切断N5:Accept(2)。</li></ol><h2 id="9f79" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">如何打破僵局</h2><p id="6470" class="pw-post-body-paragraph ji jj ht jk b jl kz iu jn jo la ix jq jr lb jt ju jv lc jx jy jz ld kb kc kd hm dt translated">最后一节中的僵局问题似乎是一个大问题，但它可以很容易地解决。节点可以在执行准备呼叫之前使用一些随机延迟。这将有助于一些提议者进入其准备和接受呼叫。虽然，对每条消息都这样做可能有点多。因此，兰波特建议使用“杰出提议者”的概念。该组节点可以使用基本paxos(和随机延迟)本身来选举一个杰出的提议者，然后使该唯一节点成为提议者节点，从而避免持续的僵局。</p><h2 id="d509" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">扩展基本Paxos以生成复制日志</h2><p id="4902" class="pw-post-body-paragraph ji jj ht jk b jl kz iu jn jo la ix jq jr lb jt ju jv lc jx jy jz ld kb kc kd hm dt translated">回到前面的银行复制日志的例子，需要发生的是所有服务器节点需要就日志的状态达成一致。日志中的每个索引代表一个事务。一些事务可以而且将会并行发生，因此服务器可以接受多个请求并将这些请求提交给不同的索引——只要有仲裁。<em class="nc">确保银行账户一致性的关键是状态转换应该按顺序应用——一个接一个。</em></p><p id="2f33" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因此，关注复制的日志:</p><ol class=""><li id="ccaa" class="lu lv ht jk b jl jm jo jp jr mz jv na jz nb kd lz ma mb mc dt translated">每个节点可以运行一个与日志中每个索引对应的基本paxos实例。</li><li id="a616" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">每个节点可以同时选择多个指数，并就该指数的对数值达成一致。</li><li id="c19c" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">领导人选举有助于减少对提议价值的争论</li><li id="fdf6" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">领导者可以将针对多个日志索引的批量准备调用合并到单个准备调用中，从而消除大多数准备调用。</li><li id="bd67" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc dt translated">可能需要一个心跳消息系统来发现一个领导者已经不在了，然后其他人需要成为领导者和提议者。当领导者倒下时，系统无法前进。</li></ol><p id="5f45" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">结论</strong></p><p id="ff9b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我发现约翰·奥斯特胡特对Basic- paxos的解释非常有用。这篇笔记中的数字是受他的演讲的启发。他进一步详细介绍了多Paxos，以及配置变化(即添加服务器)如何影响paxos，我现在不打算介绍这些内容。一般来说，分布式复制日志在许多应用程序中似乎是一个有用的概念。这可能值得阅读更多的实际实现，以及他们遇到了什么问题。</p><blockquote class="le"><p id="38ad" class="lf lg ht bd lh li lj lk ll lm ln kd ek translated">加入Coinmonks <a class="ae lo" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae lo" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae lo" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="ke kf ht bd kg kh lp kj kk kl lq kn ko jr lr kq kr jv ls kt ku jz lt kw kx ky dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="lu lv ht jk b jl kz jo la jr lw jv lx jz ly kd ne ma mb mc dt translated"><a class="ae lo" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae lo" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd ne ma mb mc dt translated"><a class="ae lo" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae lo" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd ne ma mb mc dt translated"><a class="ae lo" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae lo" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="6157" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd ne ma mb mc dt translated"><a class="ae lo" href="https://coincodecap.com/bookmap-review-2021-best-trading-software" rel="noopener ugc nofollow" target="_blank"> Bookmap评论</a> | <a class="ae lo" href="https://coincodecap.com/crypto-exchange-usa" rel="noopener ugc nofollow" target="_blank">美国5大最佳加密交易所</a></li><li id="f5bb" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd ne ma mb mc dt translated"><a class="ae lo" href="https://coincodecap.com/ftx-futures-trading" rel="noopener ugc nofollow" target="_blank">如何在FTX交易所交易期货</a> | <a class="ae lo" href="https://coincodecap.com/okex-vs-binance" rel="noopener ugc nofollow" target="_blank"> OKEx vs币安</a></li><li id="719e" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd ne ma mb mc dt translated"><a class="ae lo" href="https://coincodecap.com/coinloan-review" rel="noopener ugc nofollow" target="_blank"> CoinLoan评论</a> | <a class="ae lo" rel="noopener" href="/coinmonks/youhodler-4-easy-ways-to-make-money-98969b9689f2"> YouHodler评论</a> | <a class="ae lo" href="https://coincodecap.com/blockfi-review" rel="noopener ugc nofollow" target="_blank"> BlockFi评论</a></li><li id="4ec1" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd ne ma mb mc dt translated"><a class="ae lo" href="https://coincodecap.com/profittradingapp-for-binance" rel="noopener ugc nofollow" target="_blank">XT.COM评论</a> | <a class="ae lo" href="https://coincodecap.com/xt-com-review" rel="noopener ugc nofollow" target="_blank">币安评论</a></li><li id="f33b" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd ne ma mb mc dt translated"><a class="ae lo" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae lo" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd ne ma mb mc dt translated"><a class="ae lo" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">开发人员的最佳加密API</a></li><li id="b359" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd ne ma mb mc dt translated">最佳<a class="ae lo" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="lu lv ht jk b jl md jo me jr mf jv mg jz mh kd ne ma mb mc dt translated">杠杆代币的终极指南</li></ul></div></div>    
</body>
</html>