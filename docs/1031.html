<html>
<head>
<title>Lacking Insights in ERC223 &amp; ERC827 Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对ERC223和ERC827的实施缺乏洞察力</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/lacking-insights-in-erc223-erc827-implementation-26be5e7c3cd7?source=collection_archive---------3-----------------------#2018-07-13">https://medium.com/coinmonks/lacking-insights-in-erc223-erc827-implementation-26be5e7c3cd7?source=collection_archive---------3-----------------------#2018-07-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="de38" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">ATN令牌自定义调用错误分析</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/49b1c64bcda3adf131c637e86efc8a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOlxCoXq1faNmKA-3ie2Bg.jpeg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Photo by <a class="ae jy" href="https://unsplash.com/photos/geNNFqfvw48?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Michał Parzuchowski</a> on <a class="ae jy" href="https://unsplash.com/search/photos/chaos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0a7f" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">2018年6月20日，AI科技网(ATN)报道了一起针对ATN智能合约的攻击:一名黑客通过ATN代币合约中的bug将自己的地址设置为<code class="eh kv kw kx ky b">owner</code>，并于2018年5月11日为自己发放了1100万ATN代币。ATN团队找到了漏洞，发现了黑客方法，并立即升级了合同。黑客利用传递<strong class="kb hu"> ERC223合同</strong>中的自定义回退函数和<code class="eh kv kw kx ky b">ds-auth</code>审批支票，然后在ERC223合同调用该CUSTOM_CALL时调用该合同的函数。</p><p id="3f85" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt">Afterwards, '<a class="ae jy" href="https://blog.csdn.net/u011721501/article/details/80757811" rel="noopener ugc nofollow" target="_blank">隐形人真忙</a>' of Baidu Security also shared experience of 'call injection attack in Ethereum smart contracts' in Xianzhi Security Summit. This bug originates from a common practice: calling an arbitrary function appointed by the contract caller from another contract after invoking a function in the current one, while the bug in ATN contract reveals the danger of this approach: the contract caller could bypass authority checks or attack others with the identity of contract itself via this feature.</p><p id="f386" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><strong class="kb hu">目前以太坊上部署的存在类似漏洞的ERC20合约数量:146 </strong></p><p id="679c" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">危险代码的链接:</p><ul class=""><li id="8b6c" class="kz la ht kb b kc kd kf kg ki lb km lc kq ld ku le lf lg lh dt translated"><a class="ae jy" href="https://github.com/Dexaran/ERC223-token-standard/blob/16d350ec85d5b14b9dc857468c8e0eb4a10572d3/ERC223_Token.sol#L70" rel="noopener ugc nofollow" target="_blank">有风险的ERC223实现</a></li><li id="b050" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated"><a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/dc1e352cc49565ba0a33c346006655cf63681ff5/contracts/token/ERC827/ERC827Token.sol" rel="noopener ugc nofollow" target="_blank">有风险的ERC827实现</a></li></ul><p id="ac08" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">更新:</p><ul class=""><li id="2db8" class="kz la ht kb b kc kd kf kg ki lb km lc kq ld ku le lf lg lh dt translated">从open-zeppelin中删除了ERC827代码<a class="ae jy" href="#e46e" rel="noopener ugc nofollow">【2】</a></li><li id="7be9" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated">奥古斯托创建了一个<a class="ae jy" href="https://gitter.im/ERC827/Lobby" rel="noopener ugc nofollow" target="_blank"> gitter频道</a>来讨论ERC827标准，并且有一个新的<a class="ae jy" href="https://github.com/windingtree/erc827/pull/2" rel="noopener ugc nofollow" target="_blank">提案</a>来改进它</li></ul><h1 id="393e" class="ln lo ht bd lp lq lr ls lt lu lv lw lx iz ly ja lz jc ma jd mb jf mc jg md me dt translated">ATN事件分析</h1><p id="7fa3" class="pw-post-body-paragraph jz ka ht kb b kc mf iu ke kf mg ix kh ki mh kk kl km mi ko kp kq mj ks kt ku hm dt translated">ERC223是Dexaran于2017年3月5日提出的令牌标准草案<a class="ae jy" href="#d11d" rel="noopener ugc nofollow">【3】</a>解决发送给一个ERC20合约的令牌的处理问题。ERC20有两种方式转移令牌:一种是直接调用<code class="eh kv kw kx ky b">transfer()</code>，另一种是调用<code class="eh kv kw kx ky b">approve()</code>+<code class="eh kv kw kx ky b">transferFrom()</code>——先审批，后转移。当智能协定承担接收者角色时，需要采用后一种方法，否则发送到协定地址的令牌将被永远锁定。</p><p id="db3e" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">下面是ERC223 draft的<strong class="kb hu">正确示例</strong>:契约调用<code class="eh kv kw kx ky b">transfer()</code>时，检查<code class="eh kv kw kx ky b">to</code>地址是否为契约。如果是，它调用目标契约中的<code class="eh kv kw kx ky b">tokenFallback()</code>来处理发送给契约的令牌。不存在滥用客户呼叫。</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="1609" class="mo lo ht ky b fv mp mq l mr ms">// Correct draft code sample<br/>contract ERC223 {<br/>  function transfer(address to, uint value, bytes data) {<br/>        uint codeLength;<br/>        assembly {<br/>            codeLength := extcodesize(_to)<br/>        }<br/>        balances[msg.sender] = balances[msg.sender].sub(_value);<br/>        balances[_to] = balances[_to].add(_value);<br/>        if(codeLength&gt;0) {<br/>            // Require proper transaction handling.<br/>            ERC223Receiver receiver = ERC223Receiver(_to);<br/>            receiver.tokenFallback(msg.sender, _value, _data);<br/>        }<br/>    }<br/>}</span></pre><p id="7eda" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><strong class="kb hu"> ERC223是ERC20的超集，旨在取代ERC20成为新的令牌合同标准</strong>，但一年多来仍未被广泛接受。只有一小部分项目使用了它。</p><p id="276c" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这是ATN Token不幸采用的ERC223的<strong class="kb hu">错误实现</strong>。允许用户通过任意的<code class="eh kv kw kx ky b">_custom_fallback</code>从<code class="eh kv kw kx ky b">_to</code>地址调用任何功能。</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="ce6b" class="mo lo ht ky b fv mp mq l mr ms">// CUSTOM_CALL abusing<br/>function transferFrom(<br/>    address _from, <br/>    address _to, <br/>    uint256 _amount, <br/>    bytes _data, <br/>    string _custom_fallback<br/>    ) <br/>    public returns (bool success)<br/>{<br/>    ...<br/>    ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);<br/>    receiving.call.value(0)(byte4(keccak256(_custom_fallback)), _from, amout, data);<br/>    ...<br/>}</span></pre><p id="5ee8" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">关于ATN漏洞的报告称，其合同提到了ERC 223<a class="ae jy" href="#1dd2" rel="noopener ugc nofollow">【4】</a>的建议实施。调查此问题后，我们发现确实与dex aran<a class="ae jy" href="#a137" rel="noopener ugc nofollow">【5】</a>维护的ERC223-token-standard repo的推荐分支<code class="eh kv kw kx ky b">transfer()</code>类似:</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="2ed2" class="mo lo ht ky b fv mp mq l mr ms">// CUSTOM_CALL abusing<br/>function transfer(<br/>    address _to, <br/>    uint _value, <br/>    bytes _data, <br/>    string _custom_fallback<br/>    ) <br/>    public returns (bool success) <br/>{<br/>    ...<br/>    assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));<br/>    ...<br/>}v</span></pre><p id="ff83" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这其实是有风险的。ConsenSys的<a class="ae jy" href="https://github.com/ConsenSys/smart-contract-best-practices" rel="noopener ugc nofollow" target="_blank"> <em class="mt">智能合约安全最佳实践指南</em> </a>敦促开发者避免合约外部调用。黑客在这次攻击中将<code class="eh kv kw kx ky b">setOwner(address)</code>伪装成<code class="eh kv kw kx ky b">_custom_fallback</code>，而目标地址<code class="eh kv kw kx ky b">_to</code>正是ATN合约本身，从而间接调用了ATN合约的<code class="eh kv kw kx ky b">setOwner(address)</code>。<code class="eh kv kw kx ky b">msg.sender</code>成为了ATN的令牌契约本身从而通过了<code class="eh kv kw kx ky b">ds-auth</code>中的<code class="eh kv kw kx ky b">isAuthorized()</code>考验。</p><p id="3de2" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">EVM在读取参数时不会检查参数的数量。黑客叫完<code class="eh kv kw kx ky b">setOwner(adddress)</code>后，EVM只看了左边的<code class="eh kv kw kx ky b">_from</code>。因此，当应用低级<code class="eh kv kw kx ky b">call()</code>进行参数传递时，参数数和函数要求的和之间的差异不会出现错误。结果，黑客毫无困难地构建了攻击参数。</p><h1 id="52a1" class="ln lo ht bd lp lq lr ls lt lu lv lw lx iz ly ja lz jc ma jd mb jf mc jg md me dt translated">滥用定制呼叫的危险</h1><p id="2509" class="pw-post-body-paragraph jz ka ht kb b kc mf iu ke kf mg ix kh ki mh kk kl km mi ko kp kq mj ks kt ku hm dt translated">回到<code class="eh kv kw kx ky b">_custom_fallback</code>实现。在我们看来，作为一个通用的令牌接口，设计者应该考虑尽可能多的情况，以避免引入潜在的风险和漏洞。假设上面的<code class="eh kv kw kx ky b">_custom_fallback</code>接口被广泛接受，更多类似的安全问题还在后面。一个健壮的界面设计应该是简单、易操作和直接的。草案中的<code class="eh kv kw kx ky b">tokenFallback()</code>接口本来可以处理ERC20的问题，但是引入<code class="eh kv kw kx ky b">_custom_fallback</code>会扰乱开发者并被滥用。</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="418a" class="mo lo ht ky b fv mp mq l mr ms">function approveAndCall(<br/>    address _spender,<br/>    uint256 _value,<br/>    bytes _data<br/>  )<br/>    public<br/>    payable<br/>    returns (bool)<br/>  {<br/>    // require(_spender != address(this));<br/>    approve(_spender, _value);<br/>    require(_spender.call.value(msg.value)(_data));<br/>    return true;<br/>  }</span></pre><p id="d7da" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">在大多数情况下，当我们将智能合同地址传递给ERC20 <code class="eh kv kw kx ky b">approve()</code>时，另一方无法获得后续步骤的相关通知，常见的解决方案是<code class="eh kv kw kx ky b">receiverCall</code>。上面的代码片段是一个实现，不幸的是包含了严重的CUSTOM_CALL滥用。执行<code class="eh kv kw kx ky b">approveAndCall()</code>后，将运行<code class="eh kv kw kx ky b">_spender</code>定义的其他操作。</p><p id="3bc9" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><strong class="kb hu">注意这一条。</strong></p><p id="8229" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><strong class="kb hu">后果:</strong>这些类型的契约旨在允许用户在任何地址上定义<code class="eh kv kw kx ky b">call()</code>函数，这是高风险的。通过获取合同的身份，黑客可以很容易地进行任何操作。</p><p id="fc94" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这通常会导致3种危险的结果:</p><ul class=""><li id="697e" class="kz la ht kb b kc kd kf kg ki lb km lc kq ld ku le lf lg lh dt translated"><strong class="kb hu">第一个</strong>:允许攻击者以一个有漏洞的契约的身份窃取其他契约中的令牌</li><li id="6bed" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated"><strong class="kb hu">第二</strong>:借助<code class="eh kv kw kx ky b">ds-auth</code>绕过合同中的权限检查</li><li id="996c" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated"><strong class="kb hu">第三个</strong>:允许攻击者用一个有漏洞的合同的身份来窃取其他账户中被批准的令牌</li></ul><p id="6f80" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">第一个例子:假设有问题的契约A有B/C/D令牌，黑客可以将<code class="eh kv kw kx ky b">_spender</code>地址设置为目标令牌契约(例如B的地址)并选择<code class="eh kv kw kx ky b">_data</code>来调用<code class="eh kv kw kx ky b">transfer(address,uint256)</code>，黑客将A的令牌以契约A的身份转移出去将没有任何障碍。上面代码中的<code class="eh kv kw kx ky b">_spender != address(this)</code>只能保护一个令牌。</p><p id="2666" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">如果管理各种令牌的智能合约允许自定义<code class="eh kv kw kx ky b">call()</code>，那么里面的令牌都有危险。</p><p id="cf1e" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">第二个例子:ATN事件中的黑客利用合同身份绕过<code class="eh kv kw kx ky b">ds-auth</code>权限限制。</p><p id="5ebf" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">第三个例子:假设用户X批准了管理10，000个B令牌的错误合同A，黑客可以通过这个错误窃取B调用<code class="eh kv kw kx ky b">transferFrom</code>。</p><h1 id="1bac" class="ln lo ht bd lp lq lr ls lt lu lv lw lx iz ly ja lz jc ma jd mb jf mc jg md me dt translated">ERC223的草图和接口之间的不一致</h1><p id="c53a" class="pw-post-body-paragraph jz ka ht kb b kc mf iu ke kf mg ix kh ki mh kk kl km mi ko kp kq mj ks kt ku hm dt translated">经过进一步调查，我们发现ERC223接口草案中没有使用<code class="eh kv kw kx ky b">_custom_fallback</code>的描述。</p><p id="281f" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这是由草案定义的接口:</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="69bd" class="mo lo ht ky b fv mp mq l mr ms">contract ERC223Interface {<br/>    uint public totalSupply;<br/>    function balanceOf(address who) constant returns (uint);<br/>    function transfer(address to, uint value);<br/>    function transfer(address to, uint value, bytes data);<br/>    event Transfer(address indexed from, address indexed to, uint value, bytes data);<br/>}</span></pre><p id="fbf5" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">两个<code class="eh kv kw kx ky b">transfer()</code>界面中没有出现名为<code class="eh kv kw kx ky b">_custom_fallback</code>的参数。</p><p id="dd74" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">让我们检查一下草案说明:</p><blockquote class="mu mv mw"><p id="983f" class="jz ka mt kb b kc kd iu ke kf kg ix kh mx kj kk kl my kn ko kp mz kr ks kt ku hm dt translated"><em class="ht">如果接收者是一个契约ERC223令牌契约将尝试在接收者契约上调用tokenFallback函数。如果接收方没有tokenFallback函数，则协定事务将失败。tokenFallback函数类似于以太网事务的Fallback函数。它可以用来处理传入的事务。</em></p></blockquote><p id="182b" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">要点是，如果令牌接收者是一个ERC223合约，那么调用它的<code class="eh kv kw kx ky b">tokenFallback()</code>。如果目标没有<code class="eh kv kw kx ky b">tokenFallback()</code>，交易失败。这里<code class="eh kv kw kx ky b">tokenFallback()</code>在以太坊交易中作为默认<code class="eh kv kw kx ky b">fallback</code>使用。</p><p id="62b9" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">ERC223草案有一个明确的目标:为令牌契约定义<code class="eh kv kw kx ky b">tokenFallback()</code>来处理收到的令牌。尽管ERC223代码的主分支中没有<code class="eh kv kw kx ky b">_custom_fallback</code>，但推荐分支引入了一个带有<code class="eh kv kw kx ky b">_custom_fallback</code>的<code class="eh kv kw kx ky b">transfer()</code>实现，并且没有警告。</p><h1 id="53ed" class="ln lo ht bd lp lq lr ls lt lu lv lw lx iz ly ja lz jc ma jd mb jf mc jg md me dt translated">ERC223实现中的其他错误</h1><p id="329a" class="pw-post-body-paragraph jz ka ht kb b kc mf iu ke kf mg ix kh ki mh kk kl km mi ko kp kq mj ks kt ku hm dt translated">其实ERC223推荐分支还有其他bug。</p><p id="80db" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">在处理字节时，<code class="eh kv kw kx ky b">call()</code>会触发EVM级的bug，导致数据<a class="ae jy" href="#075b" rel="noopener ugc nofollow">【6】</a>不一致。</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="1814" class="mo lo ht ky b fv mp mq l mr ms">// ERC223_Token.sol#L70<br/>assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));</span></pre><p id="a28d" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">在某些情况下，事件处理索引字节变量<a class="ae jy" href="#090b" rel="noopener ugc nofollow">【7】</a>会出现错误。</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="c83d" class="mo lo ht ky b fv mp mq l mr ms">// ERC223_Interface.sol#L18<br/>event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);</span></pre><p id="8282" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">可以肯定地说，ERC223推荐分支不可靠，请尽量不要应用该代码。</p><h1 id="909a" class="ln lo ht bd lp lq lr ls lt lu lv lw lx iz ly ja lz jc ma jd mb jf mc jg md me dt translated">EVM的参数传递机制</h1><p id="1341" class="pw-post-body-paragraph jz ka ht kb b kc mf iu ke kf mg ix kh ki mh kk kl km mi ko kp kq mj ks kt ku hm dt translated">为了更好地理解这个漏洞，我们将探究EVM调用函数和传递参数的机制。看看这个样本</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="bf6c" class="mo lo ht ky b fv mp mq l mr ms">contract A{<br/>    function transfer(address to, uint256 value){<br/>  	      return;<br/>    }<br/>}</span></pre><p id="13bb" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">首先来介绍一下EVM的参数传递:当调用一个函数时，如果它有参数，我们通常需要根据ABI指定的类型来构造输入。例如，如果以太坊以<code class="eh kv kw kx ky b">transfer(address to, uint256 value)</code>的形式调用<code class="eh kv kw kx ky b">transfer()</code>，它将函数签名哈希值的前4个字节作为<code class="eh kv kw kx ky b">function selector</code>并计算<code class="eh kv kw kx ky b">sha3(transfer(address,uint256))</code>，那么结果就是<code class="eh kv kw kx ky b">0xA9059CBB</code>，加上<code class="eh kv kw kx ky b">to</code>的地址，256位就变成了</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="a580" class="mo lo ht ky b fv mp mq l mr ms">0x0000000000000000000000003f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be</span></pre><p id="9b4f" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><code class="eh kv kw kx ky b">value</code>也被插入256位计算</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="4960" class="mo lo ht ky b fv mp mq l mr ms">0x000000000000000000000000000000000000000000000000000000e8d4a51000</span></pre><p id="0a9a" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">最后，我们有一个完整的呼叫数据:</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="6cfe" class="mo lo ht ky b fv mp mq l mr ms">0xa9059cbb0000000000000000000000003f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be000000000000000000000000000000000000000000000000000000e8d4a51000</span></pre><p id="25e5" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">将事务和calldata一起发送，以太坊可以完成函数调用。当以太坊节点收到请求时，它会将呼叫数据和智能合同字节码加载到EVM中。字节码是在编译时生成的，这样就可以同时处理参数。字节码只检查<code class="eh kv kw kx ky b">calldata</code>是否比最小要求短，而不是是否太长。编译器会生成一系列带有数学运算的<code class="eh kv kw kx ky b">CALLDATALOAD</code>来提取函数所需的参数。首先，它计算调用的目标函数:</p><p id="0df2" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><code class="eh kv kw kx ky b">CALLDATALOAD</code>指令会将交易的calldata ( <code class="eh kv kw kx ky b">0xa9059cbb0000000000000000000000003f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be000000000000000000000000000000000000000000000000000000e8d4a51000</code>)加载到堆栈中，并将前256位除以<code class="eh kv kw kx ky b">0x100000000000000000000000000000000000000000000000000000000</code>，然后得到<code class="eh kv kw kx ky b">0xA9059CBB</code>。每一个其他参数将以类似的方式提取。然而，当参数太多时，字节码和EVM不会处理参数，而是省略这一步。总而言之，这个特性源于编译器。黑客可以很容易地在CUSTOM_CALL上构造攻击参数。</p><h1 id="35de" class="ln lo ht bd lp lq lr ls lt lu lv lw lx iz ly ja lz jc ma jd mb jf mc jg md me dt translated">高风险的ERC827实施</h1><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff na"><img src="../Images/5dfb8fba6b09c3f578b0bac354665611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5Omm9NK4dmwr9V1AOgyGg.png"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Risk Warning on EIP827 Draft Page</figcaption></figure><p id="da6e" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">类似的ERC827 Token draft也有这个问题<a class="ae jy" href="#0dc3" rel="noopener ugc nofollow">【8】</a>。下面的代码来自<strong class="kb hu"> openzeppelin-solidity </strong>的ERC827 buggy实现:</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="32ae" class="mo lo ht ky b fv mp mq l mr ms">function transferAndCall(address _to, uint256 _value,bytes _data)<br/>    public payable returns (bool)<br/>{<br/>    require(_to != address(this));<br/>    super.transfer(_to, _value);<br/>    require(_to.call.value(msg.value)(_data));<br/>    return true;<br/>}</span></pre><p id="0775" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">程序在<code class="eh kv kw kx ky b">transferAndCall()</code>完成事务后，会调用<code class="eh kv kw kx ky b">_to</code>地址上的函数，参数由调用者设置。由于检查<code class="eh kv kw kx ky b">_to != address(this)</code>，代码无法绕过结合<code class="eh kv kw kx ky b">ds-auth</code>库(<code class="eh kv kw kx ky b">second result</code>)的权限检查，同时可能引入上面的<code class="eh kv kw kx ky b">first result</code>和<code class="eh kv kw kx ky b">second result</code>，管理bug契约的令牌(通过‘this’契约攻击其他契约)。</p><p id="3787" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">除此之外，许多ERC20令牌合约都实现了类似的<code class="eh kv kw kx ky b">call()</code>，这是非常危险的。在某些情况下，它允许攻击者窃取合同令牌并绕过权限检查。</p><h1 id="86e3" class="ln lo ht bd lp lq lr ls lt lu lv lw lx iz ly ja lz jc ma jd mb jf mc jg md me dt translated">更正“receiverCall”上的ERC20和ERC721实现</h1><p id="723a" class="pw-post-body-paragraph jz ka ht kb b kc mf iu ke kf mg ix kh ki mh kk kl km mi ko kp kq mj ks kt ku hm dt translated">正确的“receiverCall”程序应该对被调用函数的签名进行硬编码，以防止攻击者任意指定<strong class="kb hu">为</strong>。以下是两个正确的“receiverCall”示例:</p><p id="c252" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">(1)通过声明Receiver函数进行“receiverCall”</p><p id="f1e9" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">以<a class="ae jy" href="http://ethereum.org/" rel="noopener ugc nofollow" target="_blank">ethereum.org</a>维护的ERC20代码为例:</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="ae5c" class="mo lo ht ky b fv mp mq l mr ms">function approveAndCall(address _spender, uint256 _value, bytes _extraData)<br/>    public returns (bool success) <br/>{<br/>    tokenRecipient spender = tokenRecipient(_spender);<br/>    if (approve(_spender, _value)) {<br/>        spender.receiveApproval(msg.sender, _value, this, _extraData);<br/>        return true;<br/>    }<br/>}</span></pre><p id="9207" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">“receiverCall”的行为类似于普通的函数调用。</p><p id="f128" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">(2)通过接收函数的<strong class="kb hu">签名常量</strong>运行‘Receiver call’</p><p id="3f14" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这个正确的片段来自ConsenSys的Token-Factory</p><pre class="jj jk jl jm fq mk ky ml mm aw mn dt"><span id="f249" class="mo lo ht ky b fv mp mq l mr ms">/* Approves and then calls the receiving contract */<br/>function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {<br/>    allowed[msg.sender][_spender] = _value;<br/>    Approval(msg.sender, _spender, _value);<br/><br/>    //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.<br/>    //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)<br/>    //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.<br/>    if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) { throw; }<br/>    return true;<br/>    }</span></pre><p id="33d9" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">有些存储库正确地实现了“receiverCall”</p><ul class=""><li id="3b98" class="kz la ht kb b kc kd kf kg ki lb km lc kq ld ku le lf lg lh dt translated"><a class="ae jy" href="https://github.com/svenstucki/ERC677" rel="noopener ugc nofollow" target="_blank">https://github.com/svenstucki/ERC677</a></li><li id="9d4f" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated"><a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC721/ERC721BasicToken.sol#L349" rel="noopener ugc nofollow" target="_blank">https://github . com/open zeppelin/open zeppelin-solidity/blob/master/contracts/token/ERC 721/ERC 721 basic token . sol # L349</a></li><li id="d9f3" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated"><a class="ae jy" href="https://github.com/ConsenSys/Token-Factory/blob/master/contracts/HumanStandardToken.sol" rel="noopener ugc nofollow" target="_blank">https://github . com/ConsenSys/Token-Factory/blob/master/contracts/humanstandardtoken . sol</a></li><li id="dd6a" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated"><a class="ae jy" href="https://github.com/ethereum/ethereum-org/blob/b46095815f52cf328ecf7676b2b38284d48fba58/solidity/token-advanced.sol#L138" rel="noopener ugc nofollow" target="_blank">https://github . com/ether eum/ether eum-org/blob/b 46095815 f 52 cf 328 ECF 7676 B2 b 38284d 48 FBA 58/solidity/token-advanced . sol # L138</a></li></ul><p id="95ec" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><em class="mt">特别感谢清新科技的吴玉会，他与我们讨论了这个话题，并提供了反馈和意见。要了解更多信息，请查看由SECBIT Labs维护的</em> <a class="ae jy" href="https://github.com/sec-bit/awesome-buggy-erc20-tokens" rel="noopener ugc nofollow" target="_blank"> <em class="mt">可怕的Buggy ERC-20令牌</em> </a> <em class="mt">开源回购。</em></p><h1 id="678e" class="ln lo ht bd lp lq lr ls lt lu lv lw lx iz ly ja lz jc ma jd mb jf mc jg md me dt translated">结论</h1><ul class=""><li id="aac4" class="kz la ht kb b kc mf kf mg ki nb km nc kq nd ku le lf lg lh dt translated">ERC223标准的行为与接口定义不同，官方回购中的两个分支实现不一致。谨慎使用<strong class="kb hu">官方代码</strong></li><li id="49c8" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated">ERC827也容易受到攻击</li><li id="a59b" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated">小心使用低级调用</li><li id="ede7" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated">需要很好地理解EVM调用合同函数的机制</li></ul><h1 id="8067" class="ln lo ht bd lp lq lr ls lt lu lv lw lx iz ly ja lz jc ma jd mb jf mc jg md me dt translated">参考</h1><ul class=""><li id="c926" class="kz la ht kb b kc mf kf mg ki nb km nc kq nd ku le lf lg lh dt translated">[1] <a class="ae jy" href="https://atn.io/resource/aareport.pdf" rel="noopener ugc nofollow" target="_blank"> ATN报道</a></li><li id="e46e" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated">[2] <a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1045" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin移除了ERC827 </a></li><li id="d11d" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated">[3] <a class="ae jy" href="https://github.com/ethereum/EIPs/issues/223" rel="noopener ugc nofollow" target="_blank"> ERC-223令牌标准建议草案</a></li><li id="1dd2" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated">[4]<a class="ae jy" href="https://github.com/ATNIO/atn-contracts/blob/7203781ad8d106ec6d1f9ca8305e76dd1274b181/src/ATN.sol#L114" rel="noopener ugc nofollow" target="_blank">ATN . sol transfer from()</a></li><li id="a137" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated">[5]<a class="ae jy" href="https://github.com/Dexaran/ERC223-token-standard/blob/16d350ec85d5b14b9dc857468c8e0eb4a10572d3/ERC223_Token.sol#L70" rel="noopener ugc nofollow" target="_blank">ERC 223 _ token . sol transfer()函数</a></li><li id="075b" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated">[6] <a class="ae jy" href="https://github.com/Dexaran/ERC223-token-standard/issues/50" rel="noopener ugc nofollow" target="_blank"> ERC223-token-standard第50期</a></li><li id="090b" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated">[7] <a class="ae jy" href="https://github.com/Dexaran/ERC223-token-standard/issues/51" rel="noopener ugc nofollow" target="_blank"> ERC223-token-standard第51期</a></li><li id="0dc3" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated">[8] <a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/f18c3bc438b366f9cb3a8613f5be160c2cbced5e/contracts/token/ERC827/ERC827Token.sol#L73" rel="noopener ugc nofollow" target="_blank"> ERC827Token.sol </a></li><li id="66ab" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated">[9] <a class="ae jy" href="https://peckshield.com/2018/06/23/evilReflex/" rel="noopener ugc nofollow" target="_blank">在多个ERC20智能合同中发现新的evilReflex错误(CVE-2018–12702，CVE-2018–12703)</a></li><li id="3d63" class="kz la ht kb b kc li kf lj ki lk km ll kq lm ku le lf lg lh dt translated">[10] <a class="ae jy" href="https://huobiglobal.zendesk.com/hc/en-us/articles/360000110521-HADAX-Suspends-18T-and-GVE-Deposits-and-Withdrawals" rel="noopener ugc nofollow" target="_blank"> HADAX暂停18T和GVE存取款</a></li></ul></div><div class="ab cl ne nf hb ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hm hn ho hp hq"><p id="70c9" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><a class="ae jy" href="https://secbit.io" rel="noopener ugc nofollow" target="_blank"><strong class="kb hu"><em class="mt">sec bit</em></strong></a><em class="mt">由一群加密货币爱好者创立。我们正在研究智能合同安全、智能合同形式验证、加密协议、编译、合同分析、博弈论和加密经济学。</em></p></div></div>    
</body>
</html>