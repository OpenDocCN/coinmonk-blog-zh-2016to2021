<html>
<head>
<title>Understanding One Way Hash Functions #HowToBUIDL (5/n)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解单向哈希函数# how to guidl(5/n)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/understanding-one-way-hash-functions-howtobuidl-5-n-6c5887c08c3?source=collection_archive---------4-----------------------#2018-05-22">https://medium.com/coinmonks/understanding-one-way-hash-functions-howtobuidl-5-n-6c5887c08c3?source=collection_archive---------4-----------------------#2018-05-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="d098" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">哈希::每个加密系统的构建块</h2></div><h2 id="a49c" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">以太坊充分利用了Keccak/SHA-3算法。</h2><p id="ca1b" class="pw-post-body-paragraph kg kh ht ki b kj kk iu kl km kn ix ko jt kp kq kr jx ks kt ku kb kv kw kx ky hm dt translated">具体来说，以太坊&amp; Solidity用的是Keccack-256版本的SHA-3。</p><p id="8ec0" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">出于某种原因，这似乎是Dapp开发者的商业秘密。虽然散列绝对是所有密码系统的关键组成部分，但我们不需要重新发明轮子来编写运行在密码平台上的系统和智能契约。<br/>你不需要了解<strong class="ki hu"> SHA-3 </strong>的工作原理。我重复一遍:<br/>你不需要了解<strong class="ki hu"> SHA-3 </strong>是如何工作的。再说一次:<br/>你不需要了解<strong class="ki hu"> SHA-3 </strong>是如何工作的。明白了吗？很好。现在… <br/> <em class="le">你应该明白</em> <strong class="ki hu"> <em class="le">为什么要用</em> </strong> <em class="le">哈希了。</em></p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff lf"><img src="../Images/be861935fcad1a81ec4e0de6ed50b208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j31QNJQ4uw8j4OJFmgZx3Q.png"/></div></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">The sponge construction for hash functions. <em class="lv">Pi</em> are input, <em class="lv">Zi</em> are hashed output. The unused “capacity” <em class="lv">c</em>should be twice the desired resistance to <a class="ae lw" href="https://en.wikipedia.org/wiki/Collision_attack" rel="noopener ugc nofollow" target="_blank">collision</a> or <a class="ae lw" href="https://en.wikipedia.org/wiki/Preimage_attack" rel="noopener ugc nofollow" target="_blank">preimage attacks</a>.</figcaption></figure><p id="78ae" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">SHA-3是加密原始族Keccak的子集。SHA-3采用海绵结构，数据被<em class="le">吸收</em>到海绵中，然后结果被<em class="le">挤出</em>。</p><p id="018c" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">一个<strong class="ki hu"> <em class="le">散列函数</em> </strong> <em class="le"> </em>是可以用来将任意<strong class="ki hu"><em class="le"/></strong>大小的数据映射到固定 大小的<strong class="ki hu"> <em class="le">数据的任何函数。哈希函数返回的值称为哈希值、哈希代码、摘要或简称为哈希。</em></strong></p><p id="5bde" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">一个<strong class="ki hu"> <em class="le">单向哈希函数</em> </strong>展现出以下性质:<br/> A)不可逆；从摘要中确定消息在计算上是不可行的，B)抗冲突；找到一个以上的消息来提供给定的摘要是不切实际的，以及C)高雪崩效应；任何微小的变化都有重大的消化变化。d)确定性。相同的输入必须总是映射到相同的输出。</p><blockquote class="lx ly lz"><p id="b700" class="kg kh le ki b kj kz iu kl km la ix ko ma lb kq kr mb lc kt ku mc ld kw kx ky hm dt translated">打个比方:烤一个蛋糕<em class="ht"> <br/>你有黄油、糖、鸡蛋、面粉、盐、发酵粉、牛奶、香草、糖霜，你把所有这些配料混合在一起，混合在一起，放在烤箱里加热。出来一个蛋糕。但是你能拿一块蛋糕回去把每一种成分都取出来吗？想象一下，从蛋糕中取出一个鸡蛋有多难。实际上，这是不可能的。</em></p></blockquote><p id="51f0" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">因为输出的数据总是唯一的，我们可以做一些有趣的事情，比如从给定的<em class="le">公钥</em>中导出特定的钱包<em class="le">地址</em>，这意味着相同的公钥每次都映射到相同的钱包地址。</p><h2 id="fa60" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">确定性数字指纹。</h2><figure class="lg lh li lj fq lk fe ff paragraph-image"><div class="fe ff md"><img src="../Images/19508c1d1a99496ebef0d764efb63b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/0*JqS5Xzzu7WPYz5Re.png"/></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">hashing function creates a fingerprint</figcaption></figure><p id="ba90" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">我们还可以创建文档的<strong class="ki hu"><em class="le"/></strong>数字指纹，并将作者提供的文档的<strong class="ki hu"> <em class="le">哈希</em> </strong>与完全可读文档的独立计算哈希进行比较。只要哈希匹配，我们就知道文档没有被传递消息的中介篡改。即使是微小的变化也会对指纹产生巨大的雪崩效应，使得伪造变化几乎不可能，但如果系统中有不良行为者，则很容易识别。我们过去已经讨论过散列作为一种机制用于<a class="ae lw" rel="noopener" href="/@dan.ryan.emmons/bitcoin-mining-proof-of-work-fb09ba124783">挖掘和工作证明</a>，但是现在我们更感兴趣的是我们可能希望如何在我们的智能合同中使用散列。</p><p id="9c73" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">让我们试试这个。启动松露开发控制台:</p><pre class="lg lh li lj fq me mf mg mh aw mi dt"><span id="4a19" class="ji jj ht mf b fv mj mk l ml mm"><strong class="mf hu">truffle develop</strong></span></pre><p id="c80d" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated"><code class="eh mn mo mp mf b">web3.js</code>库有很好的<a class="ae lw" href="https://web3js.readthedocs.io/en/1.0/web3-utils.html#sha3" rel="noopener ugc nofollow" target="_blank">文档</a>。<br/>让我们用不同的样本输入来试试<code class="eh mn mo mp mf b">sha3</code>:</p><pre class="lg lh li lj fq me mf mg mh aw mi dt"><span id="545e" class="ji jj ht mf b fv mj mk l ml mm">web3.sha3("Ladies and gents, this is the moment you've waited for")<br/>'<strong class="mf hu">0x698b948227d9bd31126f12d50b31991dacaea46f28293ee551d057094af30080</strong>'</span><span id="efa0" class="ji jj ht mf b fv mq mk l ml mm">web3.sha3("Ladies and Gents, this is the moment you've waited for")<br/>'<strong class="mf hu">0x8075374896d5dbb7027d9b5b710b3097f48513d287c18c49e7307c9089a7367f</strong>'</span><span id="2cba" class="ji jj ht mf b fv mq mk l ml mm">web3.sha3("Been searching in the dark, your sweat soaking through the floor")<br/>'0x081cbc70e6cc9c8a295d90f9a3b62c7e3122376111ade597a346ec9cefb1bcc2'</span><span id="63c0" class="ji jj ht mf b fv mq mk l ml mm">web3.sha3("And buried in your bones there's an ache that you can't ignore")<br/>'0x5e997b2a5c35920d3766cca0cce578911bcb252758c2bfd49888eaca331e7051'</span><span id="b9d3" class="ji jj ht mf b fv mq mk l ml mm">web3.sha3("Taking your breath, stealing your mind")<br/>'0x6c68baed17efc0033efafc53618aae61c666c0440cbc3f87e8b586ffe8dda623'</span><span id="d46e" class="ji jj ht mf b fv mq mk l ml mm">web3.sha3("And all that was real is left behind")<br/>'0x76fb4b778db420f198c73a8976b7e8ce5cee4e3ec742b8d073da1225440bd077'</span></pre><p id="19e8" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">一些在线工具可供你试用，如果你不想编码…<br/><a class="ae lw" href="https://emn178.github.io/online-tools/keccak_256.html" rel="noopener ugc nofollow" target="_blank">https://emn178.github.io/online-tools/keccak_256.html</a></p><p id="a471" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">一些需要快速注意的事情:1)即使将<code class="eh mn mo mp mf b">g</code>改为<code class="eh mn mo mp mf b">G</code>，输出也会有很大的变化。2)无论<code class="eh mn mo mp mf b">sha3</code>函数的输入消息有多长，输出总是64个十六进制字符或32个字节。Solidity方便地为我们提供了一个存储这个的数据类型:<code class="eh mn mo mp mf b">bytes32</code>。</p><p id="c8ce" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">举个例子，夏洛克的整个冒险故事。如果对整本书进行哈希运算，得到的keccak256 / SHA3hash是</p><pre class="lg lh li lj fq me mf mg mh aw mi dt"><span id="ea67" class="ji jj ht mf b fv mj mk l ml mm">'0xe2af31201f97e4d24df87332465243f8e56f046bc268a790540ce2a258bed40c'</span></pre><p id="bfb1" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">这产生了有趣的后果。因为我们知道哈希函数是确定性的，所以将<em class="le">哈希数据</em>存储在智能合同的<em class="le">存储器</em>中意味着记录在公共区块链上的数字指纹可以与原始文档进行比较，并在未来的某个日期进行独立验证。此外，我们知道存在高雪崩效应，因此即使输入数据中的一位发生变化，也会导致输出数据发生剧烈变化。也许这将有助于确定数据的来源，或者艺术品的所有权记录，作为真实性/质量的指南。</p><p id="d31f" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">一个非常简单的智能合约示例将为第一个记录传递给合约的唯一的<code class="eh mn mo mp mf b">fingerprint</code>的人记录<code class="eh mn mo mp mf b">msg.sender</code>。如果一个条目已经存在，一个<code class="eh mn mo mp mf b">storeFingerprint</code>函数将抛出一个异常。另一个函数可以采用任意长度的<code class="eh mn mo mp mf b">data</code>字符串，然后计算数据的<code class="eh mn mo mp mf b">keccak256</code>。对于合同的客户来说，预先计算sha3哈希会便宜得多，但是为了方便起见，我们提供了两个<code class="eh mn mo mp mf b">function</code>选项。</p><pre class="lg lh li lj fq me mf mg mh aw mi dt"><span id="0152" class="ji jj ht mf b fv mj mk l ml mm">pragma solidity ^0.4.23;</span><span id="aeb0" class="ji jj ht mf b fv mq mk l ml mm">contract Provenance {</span><span id="a0ed" class="ji jj ht mf b fv mq mk l ml mm">    mapping (bytes32=&gt;address) public fingerprints;</span><span id="c9ba" class="ji jj ht mf b fv mq mk l ml mm">    function storeFingerprint( bytes32 fingerprint ) public {<br/>        require(fingerprints[fingerprint] == 0x0);<br/>        fingerprints[fingerprint] = msg.address;<br/>    }</span><span id="7461" class="ji jj ht mf b fv mq mk l ml mm">    function storeDataFingerprint( string data ) public {<br/>        storeFingerprint( keccak256(data) );<br/>    }</span><span id="7d96" class="ji jj ht mf b fv mq mk l ml mm">}</span></pre><p id="0116" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated"><em class="le"> Dan Emmons是</em><a class="ae lw" href="http://www.emmonspired.com/" rel="noopener ugc nofollow" target="_blank"><em class="le">Emmonspired LLC</em></a><em class="le">的所有者，a </em> <a class="ae lw" href="http://cryptoconsortium.org/lookup/6f0d14" rel="noopener ugc nofollow" target="_blank"> <em class="le">认证比特币专业人士</em> </a> <em class="le">，认证以太坊开发者，全栈开发者，加密货币项目顾问。他还是一个名为</em><a class="ae lw" href="https://www.youtube.com/watch?v=SVBZ7mdgGcA" rel="noopener ugc nofollow" target="_blank"><em class="le"># ByteSizeBlockchain</em></a><em class="le">的Youtube频道和iTunes播客的创造者。</em></p></div><div class="ab cl mr ms hb mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hm hn ho hp hq"><p id="dde4" class="pw-post-body-paragraph kg kh ht ki b kj kz iu kl km la ix ko jt lb kq kr jx lc kt ku kb ld kw kx ky hm dt translated">如果你真的有兴趣了解更多关于SHA3的内部细节，维基百科有几篇关于这个问题的文章。</p><div class="my mz fm fo na nb"><a href="https://en.wikipedia.org/wiki/NIST_hash_function_competition" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab ej"><div class="nd ab ne cl cj nf"><h2 class="bd hu fv z el ng eo ep nh er et hs dt translated">NIST哈希函数竞赛-维基百科</h2><div class="ni l"><h3 class="bd b fv z el ng eo ep nh er et ek translated">NIST散列函数竞赛是由美国国家标准和…</h3></div><div class="nj l"><p class="bd b gc z el ng eo ep nh er et ek translated">en.wikipedia.org</p></div></div></div></a></div><div class="my mz fm fo na nb"><a href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithms" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab ej"><div class="nd ab ne cl cj nf"><h2 class="bd hu fv z el ng eo ep nh er et hs dt translated">安全散列算法-维基百科</h2><div class="ni l"><h3 class="bd b fv z el ng eo ep nh er et ek translated">安全散列算法是由美国国家安全研究所发布的一系列加密散列函数</h3></div><div class="nj l"><p class="bd b gc z el ng eo ep nh er et ek translated">en.wikipedia.org</p></div></div></div></a></div><div class="my mz fm fo na nb"><a href="https://en.wikipedia.org/wiki/Fingerprint_%28computing%29" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab ej"><div class="nd ab ne cl cj nf"><h2 class="bd hu fv z el ng eo ep nh er et hs dt translated">指纹(计算)-维基百科</h2><div class="ni l"><h3 class="bd b fv z el ng eo ep nh er et ek translated">在计算机科学中，指纹算法是映射任意大的数据项(例如…</h3></div><div class="nj l"><p class="bd b gc z el ng eo ep nh er et ek translated">en.wikipedia.org</p></div></div><div class="nk l"><div class="nl l nm nn no nk np lp nb"/></div></div></a></div></div></div>    
</body>
</html>