<html>
<head>
<title>Inheritance in Solidity demystified with analysis of depth-first and breadth-first resolution of contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过分析深度优先和广度优先的合同解决方案，解除了继承的神秘性</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/inheritance-in-solidity-debunked-3d8dd32d3a99?source=collection_archive---------1-----------------------#2020-04-18">https://medium.com/coinmonks/inheritance-in-solidity-debunked-3d8dd32d3a99?source=collection_archive---------1-----------------------#2020-04-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="da06" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Solidity是为<a class="ae jo" rel="noopener" href="https://medium.com/coinmonks/ethereum/home">以太坊区块链</a>编写智能合同最常用的编程语言。在本文中，我们将探讨可靠性语言的一个重要特征，那就是<strong class="is hu">继承</strong>。</p><p id="6a1b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Solidity的继承受到Python的启发，并使用<strong class="is hu"> C3线性化</strong>，也称为<strong class="is hu">方法解析顺序(MRO) </strong>来解析基类(Solidity中的契约)。本文讨论的主题是如何通过<strong class="is hu"> C3线性化</strong>算法以特定顺序解析基本智能合约，以获得最终的智能合约。理解<strong class="is hu"> C3线性化</strong>算法并不是理解继承所必需的，也超出了本文的范围。</p><p id="763c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将把我们的<a class="ae jo" href="https://blog.coincodecap.com/tag/smart-contact/" rel="noopener ugc nofollow" target="_blank">智能契约</a>布局在一个基于菱形的继承图中，以更好地了解基础契约的解析。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ju jv l"/></div></figure><p id="3461" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们在上述文件中有四个合同，即<strong class="is hu"> A、B、C </strong>和<strong class="is hu"> D </strong>。协定D继承自B和C，协定B继承自协定a。派生协定D的基础协定的解析从右向左进行。D之后要解决的第一个契约是B，然后是A，最后是C。合同的解决顺序可以描述为:</p><p id="014d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> D- &gt; B- &gt; A- &gt; C </strong></p><p id="0da0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们已经在Solidity的官方文档中读到了用于解决基础契约的深度优先方法，我们将通过在Remix中部署契约D来验证它，并检查事件<code class="eh jw jx jy jz b">Event</code>的日志，因为它是为每个包含在继承图中的契约发出的。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="fe ff ka"><img src="../Images/7de74728de8eafff12d02323a5cf3fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_xxIYRdkKcAWqUEUEHP7w.png"/></div></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">depth-first Inheritance</figcaption></figure><p id="24c2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">上面的屏幕截图显示了当我们部署契约d时，Remix中的日志输出。输出中的日志按照这样的顺序排列，最后一个日志表示第一个发出的事件，第一个日志表示最后一个发出的事件。如果我们查看日志的“args”参数，我们可以看到合同的构造函数是按照<strong class="is hu"> D- &gt; B- &gt; A- &gt; C </strong>的顺序执行的。这允许我们验证当选择用于解析的下一个契约是A而不是c时，在契约B的解析中使用的深度优先方法。</p></div><div class="ab cl kl km hb kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hm hn ho hp hq"><p id="c3e3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果契约C也继承了契约A，并且我们提出了菱形继承，那么基础契约的解析顺序会是一样的吗？</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ju jv l"/></div></figure><p id="fc43" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">上面的文件有相同的契约，唯一的区别是现在契约C也继承了契约A，我们有一个菱形的继承图。现在，如果我们部署合同D，并在下面的快照中查看日志:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="fe ff ks"><img src="../Images/416942db4f47d03ad40a19c2a895ad15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMZFo3np8DVVk3dJ83d1Tg.png"/></div></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">breadth-first inheritance</figcaption></figure><p id="a130" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">合同的解决顺序为<strong class="is hu"> D- &gt; B- &gt; C- &gt; A </strong>。我们可以从上面快照的日志中看到，协定B的解析不涉及协定A的解析，并且算法在解析协定B之后立即解析协定C，跳过协定A。这是因为协定A后来也作为另一个协定基的一部分出现在继承链中。这几乎看起来像是广度优先的方法。这里的问题是，只选择继承链中最后一个出现的契约进行解析，其他的都被丢弃。当解析协定(协定B)时，该算法查看基础协定(协定A)并检查该协定是否是继承链中后来存在的另一个协定的基础，如果是(协定C)，则该协定被丢弃，并且在该协定最后一次出现时进行解析(协定A)。</p><p id="c95b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还需要考虑到，这种继承应该对<strong class="is hu"> C3线性化</strong>算法有效。如果我们从契约A和B继承契约D，使得<code class="eh jw jx jy jz b">contract D is B, A {}</code>并试图编译契约D，我们将不会成功，因为这种继承对于<strong class="is hu"> C3线性化</strong>是无效的。我们实际上是要求契约A覆盖契约B，而契约B又覆盖契约A，因此继承图是不可能的。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="fe ff kt"><img src="../Images/d75fcf57604225d6ac9e3becf3a543ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lWHIHbjwIUXMCkFa1D4Q1g.jpeg"/></div></div></figure><blockquote class="ku"><p id="3c5b" class="kv kw ht bd kx ky kz la lb lc ld jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="lf lg lh li lj jt fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff le"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>