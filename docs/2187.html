<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/coinmonks/predicting-the-user-score-of-metacritic-user-reviews-of-video-games-using-keras-functional-api-and-87222f7034f6?source=collection_archive---------0-----------------------#2019-04-30">https://medium.com/coinmonks/predicting-the-user-score-of-metacritic-user-reviews-of-video-games-using-keras-functional-api-and-87222f7034f6?source=collection_archive---------0-----------------------#2019-04-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/ee4b9fe1a4fa64522f62b36b71952e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbR3zTt7fMf1H_efMgNriA.jpeg"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Photo by <a class="ae ig" href="https://unsplash.com/photos/p0j-mE6mGo4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Lorenzo Herrera</a> on <a class="ae ig" href="https://unsplash.com/@lorenzoherrera?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2e7d" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">使用Keras functional API和Tensorflow预测视频游戏的Metacritic用户评论的用户得分。</p><p id="0b3f" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">我们能根据发布在<a class="ae ig" href="http://metacritic.com/game/" rel="noopener ugc nofollow" target="_blank"> Metacritic </a>上的用户评论预测一款视频游戏的得分吗？在本帖中，我们将使用Keras functional API和Tensorflow后端来尝试完成这项任务。</p><p id="baf3" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">我们将使用<a class="ae ig" href="https://www.kaggle.com/dahlia25/metacritic-video-game-comments" rel="noopener ugc nofollow" target="_blank">这个巨大的kaggle数据集</a>，其中包括metascore(来自专业评论的数据集)和前5000款游戏的用户评论(或评论)。</p><p id="b0bb" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">这个故事将包括:</p><ul class=""><li id="906f" class="jg jh ij ik b il im ip iq it ji ix jj jb jk jf jl jm jn jo dt translated">创建两个keras模型，一个<em class="jp">宽</em>，一个<em class="jp">深</em></li><li id="5596" class="jg jh ij ik b il jq ip jr it js ix jt jb ju jf jl jm jn jo dt translated">使用Keras functional API加入它们</li><li id="3079" class="jg jh ij ik b il jq ip jr it js ix jt jb ju jf jl jm jn jo dt translated">创建具有多个输出的keras生成器</li><li id="9f43" class="jg jh ij ik b il jq ip jr it js ix jt jb ju jf jl jm jn jo dt translated">使用训练好的模型来预测任意用户评论的给定分数</li></ul><p id="81e4" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">使用 <a class="ae ig" href="https://colab.research.google.com/github/enriqueav/MetacriticUserscore/blob/master/metacritic_user_scores.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ik jv">这个url </strong> </a>，所有代码都可以直接在Google Colaboratory中<strong class="ik jv">执行。该脚本也可用<strong class="ik jv">克隆</strong> <a class="ae ig" href="https://github.com/enriqueav/MetacriticUserscore" rel="noopener ugc nofollow" target="_blank"> <strong class="ik jv">本Github资源库</strong> </a>。</strong></p></div><div class="ab cl jw jx hb jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hm hn ho hp hq"><p id="20f6" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated"><strong class="ik jv">注</strong>:最初的想法和部分代码的灵感来自Tensorflow官方媒体账户的一个惊人的故事，其中<a class="ae ig" rel="noopener" href="/tensorflow/predicting-the-price-of-wine-with-the-keras-functional-api-and-tensorflow-a95d1c2c1b03">他们根据评论</a>预测葡萄酒的价格。当前故事的目标是探索上述故事中未涉及的几个主题:</p><ul class=""><li id="7e92" class="jg jh ij ik b il im ip iq it ji ix jj jb jk jf jl jm jn jo dt translated">比较两种模型的性能</li><li id="1ca0" class="jg jh ij ik b il jq ip jr it js ix jt jb ju jf jl jm jn jo dt translated">当宽表示不适合Google Colab的内存时，使用数据生成器。</li><li id="5fdb" class="jg jh ij ik b il jq ip jr it js ix jt jb ju jf jl jm jn jo dt translated">使用更深层次的网络和<a class="ae ig" href="https://stats.stackexchange.com/questions/241645/how-to-explain-dropout-regularization-in-simple-terms" rel="noopener ugc nofollow" target="_blank">辍学进行正规化</a></li><li id="5dac" class="jg jh ij ik b il jq ip jr it js ix jt jb ju jf jl jm jn jo dt translated">监控测试集的性能，发送validation_data。</li><li id="73a2" class="jg jh ij ik b il jq ip jr it js ix jt jb ju jf jl jm jn jo dt translated">当然，探索不同的数据集</li></ul><h1 id="9512" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">简介:函数API与顺序API</h1><p id="9c84" class="pw-post-body-paragraph ih ii ij ik b il lb in io ip lc ir is it ld iv iw ix le iz ja jb lf jd je jf hm dt translated">顺序API是入门Keras最简单的方法，根据官方文档，顺序模型<em class="jp">代表层的线性堆栈</em>。它基本上允许你用几行代码创建一个神经网络:</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="c627" class="lp ke ij ll b fv lq lr l ls lt"><strong class="ll jv">from</strong> keras.models <strong class="ll jv">import</strong> Sequential<br/><strong class="ll jv">from</strong> keras.layers <strong class="ll jv">import</strong> Dense, Activation</span><span id="8f00" class="lp ke ij ll b fv lu lr l ls lt">model = Sequential() <br/>model.add(Dense(32, input_dim=784))<br/>model.add(Activation('relu'))</span></pre><p id="e607" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">另一方面，函数式API更加灵活。它允许我们定义更复杂的流程，比如多个输出和输入、有向无环图等。</p><pre class="lg lh li lj fq lk ll lm ln aw lo dt"><span id="61b7" class="lp ke ij ll b fv lq lr l ls lt"><strong class="ll jv">from</strong> keras.layers <strong class="ll jv">import</strong> Input, Dense <br/><strong class="ll jv">from</strong> keras.models <strong class="ll jv">import</strong> Model  </span><span id="899f" class="lp ke ij ll b fv lu lr l ls lt"><em class="jp"># This returns a tensor</em> <br/>inputs = Input(shape=(784,))  </span><span id="f50b" class="lp ke ij ll b fv lu lr l ls lt"><em class="jp"># a layer instance is callable on a tensor, and returns a tensor</em> <br/>x = Dense(64, activation='relu')(inputs)<br/>x = Dense(64, activation='relu')(x) <br/>predictions = Dense(10, activation='softmax')(x)  </span><span id="087f" class="lp ke ij ll b fv lu lr l ls lt"><em class="jp"># This creates a model that includes</em> <br/><em class="jp"># the Input layer and three Dense layers</em> <br/>model = Model(inputs=inputs, outputs=predictions)</span></pre><p id="ffec" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">这就是为什么我们要使用功能API将我们的<strong class="ik jv">宽</strong>和<strong class="ik jv">深</strong>模型加入到一个单一的组合架构中的原因。</p><h1 id="a3d8" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">第一步:获取数据和预处理</h1><p id="ee57" class="pw-post-body-paragraph ih ii ij ik b il lb in io ip lc ir is it ld iv iw ix le iz ja jb lf jd je jf hm dt translated">第一步是直接从Github存储库中下载并解压缩数据集为. csv文件。一旦我们的文件系统中有了这个文件，我们将使用<a class="ae ig" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html" rel="noopener ugc nofollow" target="_blank"> pandas的read_csv </a>把它转换成一个数据帧。</p><p id="e86f" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">接下来，我们将用<a class="ae ig" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sample.html" rel="noopener ugc nofollow" target="_blank">熊猫打乱数据帧中的行。DataFrame.sample </a>，使用固定的<code class="eh lv lw lx ll b">random_state</code>。这意味着shuffle每次都会给出相同的结果，因此我们将始终拥有相同的训练集和测试集，以实现可重复性。最后，我们通过删除和过滤短评论(少于200个字符)来执行一些其他的数据清理。</p><figure class="lg lh li lj fq hv"><div class="bz el l di"><div class="ly lz l"/></div></figure><h1 id="b295" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">步骤2:创建训练集和测试集</h1><p id="644e" class="pw-post-body-paragraph ih ii ij ik b il lb in io ip lc ir is it ld iv iw ix le iz ja jb lf jd je jf hm dt translated">接下来，我们将数据分为训练集(80%)和测试集(20%)。由于我们在洗牌中使用了固定的<code class="eh lv lw lx ll b">random_state</code>，这将总是有相同的结果。</p><figure class="lg lh li lj fq hv"><div class="bz el l di"><div class="ly lz l"/></div></figure><h1 id="c578" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">步骤3:创建Keras标记器</h1><p id="3777" class="pw-post-body-paragraph ih ii ij ik b il lb in io ip lc ir is it ld iv iw ix le iz ja jb lf jd je jf hm dt translated">我们将创建一个Keras记号赋予器，它允许我们通过将每个文本转换成整数序列(每个整数都是字典中记号的索引)或向量(来自Keras文档的<a class="ae ig" href="https://keras.io/preprocessing/text/" rel="noopener ugc nofollow" target="_blank">)来对文本语料库进行矢量化。这个记号化器将在我们的数据生成器中使用(稍后将详细介绍)，用于我们的<strong class="ik jv">宽</strong>和<strong class="ik jv">深</strong>模型。</a></p><p id="472b" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">我们还定义了一个重要的超参数:词汇量。您可以尝试更改这个数字以获得不同的结果。</p><figure class="lg lh li lj fq hv"><div class="bz el l di"><div class="ly lz l"/></div></figure><h1 id="8c59" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">步骤4:创建宽模型</h1><p id="57c2" class="pw-post-body-paragraph ih ii ij ik b il lb in io ip lc ir is it ld iv iw ix le iz ja jb lf jd je jf hm dt translated"><strong class="ik jv">宽</strong>模型将采用文本的稀疏表示，这意味着它将指示词汇表中的哪些单词出现在文本中，而不考虑顺序。这种类型的表示通常被称为<strong class="ik jv">单词包。</strong></p><p id="e473" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">当我们解释数据生成器时，我们将会详细介绍如何从用户评论中创建<strong class="ik jv">单词包</strong>(使用之前定义的<em class="jp">标记器</em>)。</p><figure class="lg lh li lj fq hv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="fb85" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">在输入层之后，我们增加了一个256个单元的密集层，以及一个用于调整的<a class="ae ig" href="https://stats.stackexchange.com/questions/241645/how-to-explain-dropout-regularization-in-simple-terms" rel="noopener ugc nofollow" target="_blank">脱落层</a>。简而言之，辍学是用来避免过度适应网络。</p><h1 id="7cc3" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">步骤5:创建深度模型</h1><p id="7d44" class="pw-post-body-paragraph ih ii ij ik b il lb in io ip lc ir is it ld iv iw ix le iz ja jb lf jd je jf hm dt translated">对于深度模型，我们将使用单词嵌入来表示用户评论。来自<a class="ae ig" href="https://keras.io/layers/embeddings/" rel="noopener ugc nofollow" target="_blank"> Keras文档</a>，嵌入层:</p><blockquote class="ma mb mc"><p id="1375" class="ih ii jp ik b il im in io ip iq ir is md iu iv iw me iy iz ja mf jc jd je jf hm dt translated">将正整数(索引)转换为固定大小的密集向量。例如[[4]，[20]]--&gt;[[0.25，0.1]，[0.6，-0.2]]</p></blockquote><p id="fae8" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">换句话说:</p><blockquote class="ma mb mc"><p id="1181" class="ih ii jp ik b il im in io ip iq ir is md iu iv iw me iy iz ja mf jc jd je jf hm dt translated">单词嵌入提供了单词及其相关含义的密集表示。</p><p id="3c9f" class="ih ii jp ik b il im in io ip iq ir is md iu iv iw me iy iz ja mf jc jd je jf hm dt translated">它们是对更简单的单词模型表示中使用的稀疏表示的改进。</p><p id="3f19" class="ih ii jp ik b il im in io ip iq ir is md iu iv iw me iy iz ja mf jc jd je jf hm dt translated">单词嵌入可以从文本数据中学习，并在项目中重用。它们也可以作为在文本数据上拟合神经网络的一部分来学习。</p></blockquote><figure class="lg lh li lj fq hv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="dba3" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">正如我们对<strong class="ik jv">宽</strong>模式所做的那样，我们添加了一个带有漏失正则化的额外密集层，以避免过度拟合。</p><h1 id="6248" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">第六步。使用函数API连接模型</h1><p id="f5ab" class="pw-post-body-paragraph ih ii ij ik b il lb in io ip lc ir is it ld iv iw ix le iz ja jb lf jd je jf hm dt translated">连接我们到目前为止创建的两个模型的关键点是使用<code class="eh lv lw lx ll b">keras.layers.concatenate</code>，它将接受一个数组，该数组包含先前创建的<strong class="ik jv">宽</strong>和<strong class="ik jv">深</strong>模型的输出(第2行)。</p><figure class="lg lh li lj fq hv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="0ff2" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">之后，我们添加另一个密集层与辍学正则化。还请注意，<code class="eh lv lw lx ll b">keras.Model</code>将接受两个输入，包含在一个数组<code class="eh lv lw lx ll b">[wide_model.input, deep_model.input]</code>中(第6行)。</p><h1 id="7008" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">步骤7:准备数据生成器</h1><p id="6748" class="pw-post-body-paragraph ih ii ij ik b il lb in io ip lc ir is it ld iv iw ix le iz ja jb lf jd je jf hm dt translated">根据我们的执行环境的特征，可能会也可能不会将所有数据集都放入内存。当我第一次尝试在Google Colab笔记本中创建所有训练集的单词包时，我很快就遇到了内存不足的错误。因此需要一个Keras数据生成器。你可以在这里阅读更详细的解释，但是基本上使用数据生成器，你用训练集的<em class="jp">块</em>来填充模型，每一步一个，而不是一次填充所有的东西。</p><p id="7794" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">为此，首先我们声明一个辅助函数<code class="eh lv lw lx ll b">process_comments</code>，它将获取用户评论的一个子集，并将创建和返回单词包和它们的嵌入版本。这是使用<code class="eh lv lw lx ll b">Tokenizer.texts_to_matrix</code>和<code class="eh lv lw lx ll b">Tokenizer.texts_to_sequences</code>完成的。</p><p id="010c" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">记住<strong class="ik jv">字包</strong>和<strong class="ik jv">嵌入</strong>表示分别是<strong class="ik jv">宽</strong>和<strong class="ik jv">深</strong>模型的输入。</p><figure class="lg lh li lj fq hv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="31f5" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">函数<code class="eh lv lw lx ll b">process_comments</code>将由我们的数据生成器调用，传递小批量的用户评论。我们将数据生成器定义如下:</p><figure class="lg lh li lj fq hv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="f450" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">在第10行中，我们只获取单步执行所需的一批注释，在第12行中，我们调用<code class="eh lv lw lx ll b">process_comments</code>来获取<strong class="ik jv">单词包</strong>和<strong class="ik jv">嵌入的</strong>版本的这些注释。第13行获取了集合的相同部分，但是只有标签<code class="eh lv lw lx ll b">y</code>，在本例中是评论的用户分数，一个0到10之间的数字。</p><h1 id="4d97" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">步骤8:声明回调</h1><p id="2184" class="pw-post-body-paragraph ih ii ij ik b il lb in io ip lc ir is it ld iv iw ix le iz ja jb lf jd je jf hm dt translated">这一步是完全可选的，但我想把它包括在内，因为这是我通常添加到Keras培训中的内容。我们将定义一个<a class="ae ig" href="https://keras.io/callbacks/" rel="noopener ugc nofollow" target="_blank"> Keras回调</a>在每个时期结束时运行。</p><figure class="lg lh li lj fq hv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="b1fe" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">如果这段代码中的一些行看起来有点复杂，不要担心。基本上，我们想要实现的是在每个时期结束时评估当前模型的性能。我们使用当前权重运行预测<code class="eh lv lw lx ll b">Model.predict_generator</code>，并计算实际得分和预测得分之间的平均误差。自然，我们希望在测试集上有这样的预测(训练中从未见过的例子)。</p><p id="33e8" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">最后，我们将这个回调的一个实例存储在变量<code class="eh lv lw lx ll b">print_callback</code>中，在下一步中我们将把它发送给<code class="eh lv lw lx ll b">fit_generator</code>函数。</p><h1 id="5e04" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">第九步:开始训练-最后-</h1><p id="95e5" class="pw-post-body-paragraph ih ii ij ik b il lb in io ip lc ir is it ld iv iw ix le iz ja jb lf jd je jf hm dt translated">我们终于准备好开始训练了。由于我们使用数据生成器，我们将调用<code class="eh lv lw lx ll b">Model.it_generator</code>，而不是通常的<code class="eh lv lw lx ll b">Model.fit</code>。你可能注意到的另一个不同是，我们也将测试集作为<code class="eh lv lw lx ll b">validation_data</code>发送，这将导致训练集和测试集的损失和准确性将在每个时期打印。</p><figure class="lg lh li lj fq hv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="5239" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">最后，我们还发送上一步中创建的回调，我们将在每个时期结束后预测和评估模型。这将稍微扰乱传统训练阶段的输出，因为我们将在每个时期后看到这些线中的一条</p><p id="58ed" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated"><code class="eh lv lw lx ll b">Epoch: 1. Average prediction difference: 1.3173</code></p><p id="313f" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">这个数字表示平均而言，预测分数与实际分数相差多少。</p><p id="1a1e" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated"><strong class="ik jv">注意</strong>:当然，这个度量与我们选择的损失度量只有微小的不同:<strong class="ik jv">均方误差</strong>。</p><h1 id="e3f0" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">第十步:完成</h1><p id="1edc" class="pw-post-body-paragraph ih ii ij ik b il lb in io ip lc ir is it ld iv iw ix le iz ja jb lf jd je jf hm dt translated">仅仅经过两三个时期，该模型预测的评论分数的平均偏差在1.2分左右。我们可以看到一些使用特殊参数<code class="eh lv lw lx ll b">print_predictions</code>调用回调函数的预测分数与实际分数的例子。</p><figure class="lg lh li lj fq hv"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="7ea6" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">考虑到用户评论比专业评论更难预测，结果还不错，因为它们缺乏专业评论所期望的<em class="jp">彻底性</em>。它们也可能包含相当多的讽刺<em class="jp">和</em>，这对NLP系统来说总是很困难的。</p><h1 id="9895" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">附加1:分别比较连接模型与宽模型或深模型</h1><p id="62fb" class="pw-post-body-paragraph ih ii ij ik b il lb in io ip lc ir is it ld iv iw ix le iz ja jb lf jd je jf hm dt translated">我们还制作了几个额外的笔记本来比较这种组合模式与仅使用每种基本模式的情况。</p><ul class=""><li id="4bfa" class="jg jh ij ik b il im ip iq it ji ix jj jb jk jf jl jm jn jo dt translated"><a class="ae ig" href="https://github.com/enriqueav/MetacriticUserscore/blob/master/only_wide_model.ipynb" rel="noopener ugc nofollow" target="_blank">在本笔记本</a>中，我们只使用了<strong class="ik jv">宽</strong>型号。</li><li id="22d5" class="jg jh ij ik b il jq ip jr it js ix jt jb ju jf jl jm jn jo dt translated"><a class="ae ig" href="https://github.com/enriqueav/MetacriticUserscore/blob/master/only_deep_model.ipynb" rel="noopener ugc nofollow" target="_blank">而在这一款</a>中，只有<strong class="ik jv">深</strong>型号。</li></ul><p id="f0fe" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">模型预测得分和实际得分之间的平均偏差约为(数字越小，预测越好):</p><ul class=""><li id="626c" class="jg jh ij ik b il im ip iq it ji ix jj jb jk jf jl jm jn jo dt translated">组合型号:<strong class="ik jv"> 1.20 </strong></li><li id="ba45" class="jg jh ij ik b il jq ip jr it js ix jt jb ju jf jl jm jn jo dt translated">仅限宽款:<strong class="ik jv"> 1.45 </strong></li><li id="2135" class="jg jh ij ik b il jq ip jr it js ix jt jb ju jf jl jm jn jo dt translated">仅限深度型号:<strong class="ik jv"> 1.60 </strong></li></ul><p id="5164" class="pw-post-body-paragraph ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf hm dt translated">我们可以看到，组合模型的性能确实优于单独工作的各个组件。</p><h1 id="b61a" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated"><strong class="ak">额外2:使用模型预测其他评论</strong></h1><p id="1893" class="pw-post-body-paragraph ih ii ij ik b il lb in io ip lc ir is it ld iv iw ix le iz ja jb lf jd je jf hm dt translated">我们可以预测任意用户评论的分数，如下例所示</p><figure class="lg lh li lj fq hv"><div class="bz el l di"><div class="ly lz l"/></div></figure><h1 id="598b" class="kd ke ij bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">要做:</h1><ul class=""><li id="d85c" class="jg jh ij ik b il lb ip lc it mg ix mh jb mi jf jl jm jn jo dt translated">尝试添加一些分类值作为输入(平台、年份、发行商)，甚至是Metascore。</li><li id="d82d" class="jg jh ij ik b il jq ip jr it js ix jt jb ju jf jl jm jn jo dt translated">尝试使用递归神经网络(LSTM？)在深度模型中。</li><li id="cfda" class="jg jh ij ik b il jq ip jr it js ix jt jb ju jf jl jm jn jo dt translated">这个模型对其他媒体的元评论有用吗？电影、音乐等？</li><li id="aee4" class="jg jh ij ik b il jq ip jr it js ix jt jb ju jf jl jm jn jo dt translated">找到了使用相同的训练/测试集获得更好结果的方法？请在评论中告诉我。</li></ul></div></div>    
</body>
</html>