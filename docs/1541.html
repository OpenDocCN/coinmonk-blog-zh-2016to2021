<html>
<head>
<title>Smart Contract Exploits Part 2 — Featuring Capture the Ether (Math)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合约利用第2部分—以捕获以太(数学)为特色</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/smart-contract-exploits-part-2-featuring-capture-the-ether-math-31a289da0427?source=collection_archive---------2-----------------------#2018-09-23">https://medium.com/coinmonks/smart-contract-exploits-part-2-featuring-capture-the-ether-math-31a289da0427?source=collection_archive---------2-----------------------#2018-09-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="61c1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是《捕捉以太》的第二部分。在起草我的笔记后，我决定先研究数学部分，最后以账户+杂项结束。数学部分，顾名思义，主要关注基于数学的挑战，围绕溢出，操纵可靠性存储机制，以及简单草率的编码。如果你还没有这样做，请尝试一下挑战，因为我个人认为这是捕捉以太开始变得真正有趣的地方。</p><p id="810b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于错过第一部分的人:<a class="ae jo" rel="noopener" href="/@Enigmatic1256/smart-contract-exploits-part-1-featuring-capture-the-ether-lotteries-8a061ad491b">https://medium . com/@ enigmatic 1256/smart-contract-exploits-part-1-featured-capture-the-ether-lotteries-8a 061 ad 491 b</a></p><p id="9ebd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">可以找到这些挑战的网站:<a class="ae jo" href="https://capturetheether.com/challenges/" rel="noopener ugc nofollow" target="_blank">https://capturetheether.com/challenges/</a><br/>这些挑战的作者是非常聪明的smarx，抓住他的推特账号@smarx。</p><p id="7d80" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">和以前一样，这篇文章需要一些关于Solidity及其相关开发工具的知识。</p><p id="5160" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">事不宜迟——前方有巨大的剧透！</p><h1 id="5c54" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">7.象征性销售</h1><p id="b1a4" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="97f2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要赢，我们将需要耗尽合同创建时放入合同的初始1乙醚押金。只有两个函数<code class="eh kz la lb lc b"><em class="ld">buy()</em></code>和<code class="eh kz la lb lc b"><em class="ld">sell()</em></code>我们可以访问，因此必须有一种方法让我们达到这样一种状态:我们可以卖出比我们可以买断该合同更多的东西，以使它有资格获得<code class="eh kz la lb lc b"><em class="ld">address(this).balance &lt; 1 ether</em></code>。</p><p id="dbe9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它可能不会立即显现出来；有可能会溢出合同。钥匙在线上<code class="eh kz la lb lc b"><em class="ld">require(msg.value == numTokens * PRICE_PER_TOKEN)</em></code>。<code class="eh kz la lb lc b"><em class="ld">PRICE_PER_TOKEN</em></code>是一个以太常数，所有的计算都将使用数字10亿。然后，我们可以通过将<code class="eh kz la lb lc b"><em class="ld">PRICE_PER_TOKEN</em></code>乘以一个巨大的数来溢出支票，将其与msg.value的等价模数相匹配，给我们自己一个巨大的数<code class="eh kz la lb lc b"><em class="ld">numTokens</em></code>,随后我们可以提取存放在合同中的乙醚，以使值为&lt; 1乙醚。</p><p id="e42c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以首先我们需要弄清楚我们可以使用什么数字来合理地溢出，允许我们发送一个合理数量的以太网来完成所需的检查。uint256最大值为2 * * 256–1，即:</p><p id="31ed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt">115792089237316195423570985008687907853269984665640564039457584007913129639935</p><p id="72e6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将它乘以10 * 18，所以我们去掉最后18位，得到:</p><p id="3f28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt">115792089237316195423570985008687907853269984665640564039457</p><p id="e05a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">加上1，再乘以10 * 18，我们将得到:</p><p id="4312" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt">115792089237316195423570985008687907853269984665640564039458000000000000000000</p><p id="161f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这将溢出到415992086870360064，略低于半个以太。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/f0707ca64a0de6681e2d5902ae7ba5fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0MwM4QQ6BNJHXn0x.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Writing a small test to see if we get 415992086870360064.</figcaption></figure><p id="6f74" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们知道了号码，只需要以115792089237316195423570985008687907853269984665640564039458为参数调用<code class="eh kz la lb lc b"><em class="ld">buy()</em></code>，同时发送415992086870360064魏随我们交易，就会溢出并给我们一笔巨量代币:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/945f4827dabdd7d838d0c3f8763ec7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GVsZPTsO2ND1viNW.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Executing the exploit.</figcaption></figure><p id="18d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">随后，我们可以调用sell with 1来退还我们发送到合同的1 ether，在合同中留下0.41…64 ether，这将为我们赢得挑战。</p><h1 id="cd67" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">8.象征鲸</h1><p id="abfe" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="438f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">快速浏览一下，我们可以看到该契约最有可能出现溢出漏洞，这一点可以通过在没有边界检查的情况下随意使用算术运算(例如SafeMath库)来证明。尽管我认为这个契约的主要失败是草率的编码，抛开绑定检查不谈——<code class="eh kz la lb lc b"><em class="ld">transferFrom</em></code>调用<code class="eh kz la lb lc b"><em class="ld">_transfer</em></code>，它从msg.sender发送令牌，而不是在from和to地址之间发送。</p><p id="a9af" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">攻击序列将如下所示:</p><ol class=""><li id="fb56" class="lp lq ht is b it iu ix iy jb lr jf ls jj lt jn lu lv lw lx dt translated">允许一个代理帐号从玩家那里获得任意多的津贴。</li><li id="9788" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">从代理帐户，执行球员和另一个帐户之间的转移。这将溢出代理帐户上的余额，给它大量的令牌。</li><li id="1824" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">从代理帐户向玩家转移代币，使其余额超过1，000，000。</li></ol><p id="be53" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">启动Visual Studio，用Nethereum创建解决方案(同样，任何其他库都可以):</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff md"><img src="../Images/ef664315e0d346396e5505cc063cd8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W-whg7IQv_QcvMUH.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">The sequence of exploit.</figcaption></figure><p id="2e6b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行它，我们应该得到:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff me"><img src="../Images/8a99f564d2e434fa75d7c1db0ef4a94e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wBdInXUSCQ9VkGmD.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">And… Success.</figcaption></figure><h1 id="93f0" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">9.退休基金</h1><p id="e6d5" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="5967" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个合同发生的事情实际上只集中在<code class="eh kz la lb lc b"><em class="ld">collectPenalty()</em></code>上，因为due require(msg . sender = = owner)，其中owner是Ether factory合同的捕获者，我们永远不能调用retract()。然后重点是collectPenalty()来执行我们的利用。</p><p id="e761" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们如何利用这份合同取决于EVM的怪癖。本质上，如果我们能强迫一些醚进入契约，使<code class="eh kz la lb lc b"><em class="ld">address(this).balance &gt; startBalance</em></code>促使溢出到变量提取，我们将能耗尽这个契约中的每一个醚。这两种方法在Solidity文档中有很好的记录:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mf"><img src="../Images/a5a90dfe92009b6f71a591f5500e2c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ev1DgneUDEqBuda0.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Forcing ether to a contract with a coinbase transaction or selfdestruct.</figcaption></figure><p id="6a88" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">还有第三种方式——因为合同地址是确定性生成的——基本上是黄皮书中记载的RLP格式的发送方地址和随机数的keccak256结果的最右侧160位，如下所示:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/707084d9cd340e075b3be0b1a3e1cf6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/0*eCg4eePMmZ9cVhMi.png"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Deriving a contract address.</figcaption></figure><p id="ab5c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，可以计算出退休基金合同将具有哪个地址，因为我们可以计算出nonce和部署合同的地址；但是让我们来看看最简单的选择。</p><p id="466f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">简而言之，我们需要做的是写一个契约，用一些ethers加载它，用我们打算利用的契约的地址执行selfdestruct，然后调用<code class="eh kz la lb lc b"><em class="ld">collectPenalty()</em></code>。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/25368eaffbbdc93614d2fa01130bc734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NKMQnCi0jJHuki-h.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Firing up Remix, deploy and calling selfdestruct.</figcaption></figure><p id="7ca7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">随后，在令牌鲸挑战契约上调用<code class="eh kz la lb lc b"><em class="ld">collectPenalty()</em></code>，我们就大功告成了！</p><h1 id="b6e6" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">10.绘图</h1><p id="538c" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="e88a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是一个非常有趣的开发，它将让我们更好地理解可靠性存储模式是如何工作的。与其他的略有不同，这个契约不需要任何以太存款，但要求我们以某种方式将<code class="eh kz la lb lc b"><em class="ld">isComplete</em></code>变为真实。唯一允许我们写入契约的函数是<code class="eh kz la lb lc b"><em class="ld">set()</em></code>，所以让我们从那里着手解决问题。</p><p id="6dd9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh kz la lb lc b"><em class="ld">set()</em></code>函数允许我们写入一个数组<code class="eh kz la lb lc b"><em class="ld">map[]</em></code>，我们可以指定要写入的值以及确切的数组位置。现在回想一下，EVM将协定存储作为256位指针乘以32字节值槽来处理(因此32字节键对应32字节值)。此外，我们这里的数组是一个动态数组，EVM无法假设要保留多少状态存储，因此有一个保留的槽来确定数组的大小，随后该槽的keccak256哈希作为存储值的地址。这很有趣，因为这意味着如果我们能够以某种方式扩展数组的范围，甚至覆盖<code class="eh kz la lb lc b"><em class="ld">isComplete</em></code>变量存储，我们就可以访问并覆盖变量的值，前提是我们能够找到要写入的地址！</p><p id="becd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这实际上是一个相当好的记录利用，它在2017年赢得了秘密的可靠性编码竞赛:<a class="ae jo" href="https://github.com/Arachnid/uscc/tree/master/submissions-2017/doughoyte" rel="noopener ugc nofollow" target="_blank">https://github . com/Arachnid/uscc/tree/master/submissions-2017/doughoyte</a></p><p id="2504" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在对于漏洞本身——从漏洞契约中，我们被允许写入契约的任意位置，因为我们可以指定参数<code class="eh kz la lb lc b"><em class="ld">key</em></code>。虽然USCC2017漏洞利用依赖于下溢来导致数组的索引绕过数组的边界，但在这里我们可以改为指定uint256减2的最大值(因为if语句将数组长度扩展1)作为参数<code class="eh kz la lb lc b"><em class="ld">key</em></code>的输入来绕过数组边界，然后通过从数组的哈希偏移中环绕uint256来计算出哪个地址<code class="eh kz la lb lc b"><em class="ld">isComplete</em></code>，这将我们带到存储槽0x0的地址。</p><p id="8e85" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">(请注意，下面的示例是在编译器设置为Solidity v0.4.17的情况下完成的。这很重要，将在下面进一步解释)。</p><p id="936f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，我们通过输入2 * * 256–2和一个随机值(比如2 ),使用函数<code class="eh kz la lb lc b"><em class="ld">set()</em></code>强制数组越界:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/29071f642000dd8ae9c6f74739a82a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YnvQ8HCUDbdkZr21.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Forcing array to be out-of-bounds — Note the value being the maximum of uint256.</figcaption></figure><p id="7798" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，我们计算需要使用哪个地址来访问<code class="eh kz la lb lc b"><em class="ld">isComplete</em></code>。在这种情况下，0x b 10 e 2d 527612073 b 26 EEC DFD 717 E6 a 320 cf 44 B4 afac 2 b 0732 9 fcb 2 b 7 fa 0 cf 6是数组变量开始的地址槽，因此我们可以运行以下Python脚本对其进行包装:</p><p id="324b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh kz la lb lc b"><em class="ld">print '0x{0:02x}'.format(2**256 - 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6)</em></code></p><p id="6a14" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它返回us 0 x4 ef 1d 2 ad 89 EDF 8 C4 d 91132028 e 8195 CDF 30 bb 4b 5053d 4 F8 CD 260341d 4805 f 30a</p><p id="9912" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果我们直接用值为1的函数<code class="eh kz la lb lc b"><em class="ld">set()</em></code>访问这个地址:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/f18f3803174cfdb08189bdcbee2c431d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CGFzH_RXE0gClWCd.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Setting the value of this storage slot to 1.</figcaption></figure><p id="22d5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh kz la lb lc b"><em class="ld">isComplete</em></code>最终将返回true:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/353d24376247b69f17d82da619aa6286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RVNeY1Dk1HNaxOYa.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">What sorcery is this??</figcaption></figure><p id="f547" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有趣的是，Solidity v0.4.22有一个错误修复，它实际上使这种性质的契约更容易被破解——如果我们指向一个大于现有数组长度的索引，它会跳过不必要的数组存储(我相信这是为了节省汽油成本),当我们能够找出哪个地址槽0x0时，这无意中允许我们将一个值直接推入槽0x0。对于v0.4.22之前的版本，当试图跳过大量阵列插槽时，会出现“没有气体”错误。CaptureTheEther上的合同已经被重新编译，以允许在v0.4.22上利用漏洞。</p><p id="6a9a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们在v0.4.22上重新编译并尝试一下，使用相同的参数0x 4 ef 1 D2 ad 89 EDF 8 C4 d 91132028 e 8195 CDF 30 bb 4b 5053d 4 f 8 CD 260341d 4805 f 30 a和值1:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/113df05e21930bfc925918c396cd9029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sHjIY8e9V_bmj3Eg.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Entering value directly to the address of the storage slot.</figcaption></figure><p id="27a5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意，长度被自动推送到所需的位置，如果我们访问isComplete:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/63726086b8c7d3f4ee0f9cf6ccd7c50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hD2R_xuUgFgQTOwa.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Entering value directly to the address of the storage slot.</figcaption></figure><p id="0317" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这种利用的真正目的是问自己，“当一个函数的状态改变到一个数组时，是否应该允许它用一个作为数组索引的输入参数来这样做”？</p><h1 id="e1d0" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">11.捐款</h1><p id="2f4a" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="2a5a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">啊。这个…太可怕了。这份合同本身写得很糟糕，不应该通过基本审查。<code class="eh kz la lb lc b"><em class="ld">donate()</em></code>功能并不完全工作，即使通过目视检查没有注意到，一旦运行该功能也应该是显而易见的。</p><p id="fe3d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">基本上，有两个问题:</p><ol class=""><li id="ff76" class="lp lq ht is b it iu ix iy jb lr jf ls jj lt jn lu lv lw lx dt translated">捐赠结构没有正确声明—试图指向该结构的指针导致了一些相当奇怪的行为，即直接访问契约存储槽，允许我们覆盖其他契约状态变量。</li><li id="6f17" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">比例计算错误——它似乎想要将输入的值缩放到1以太，但是将它乘以10**36，因此我们可以发送一个msg.value，它实际上是<code class="eh kz la lb lc b"><em class="ld">etherAmount / 10**36</em></code>，这是我假设合同真正希望收到的值的一小部分。</li></ol><p id="d985" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们测试一下可以调用什么行为。我们试试派1个卫进来，用<code class="eh kz la lb lc b"><em class="ld">etherAmount</em></code> = 10**36。</p><p id="7cd6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">恐怖。整个Owner变量被覆盖了！</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/d51fd2dcc930a1cc661ccf45c096c511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/0*5qiCI8NcRag3ofu8.png"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Hmmmmm. c097ce7bc90715b34b9f1000000000 is not the original owner.</figcaption></figure><p id="b0ac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果我们仔细看看Remix上的代码，Remix已经抛出了一个警告(如下)。基本上，以这种方式声明捐赠会创建一个指向协定存储的指针，而不是一个临时内存存储，代码稍后会将该临时内存存储推送到捐赠数组。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mi"><img src="../Images/dd26036d4e4e92dbd67c497948c8123d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jWZi7yOaQ0F5q64X.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">So never ignore warnings.</figcaption></figure><p id="6e6d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">换句话说，写现实中的<code class="eh kz la lb lc b"><em class="ld">donation.timestamp</em></code>和<code class="eh kz la lb lc b"><em class="ld">donation.etherAmount</em></code>就是写存储指针0和指针1，其中存储指针1反映了变量<code class="eh kz la lb lc b"><em class="ld">Owner</em></code>，赋予我们操纵这个变量的能力。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mj"><img src="../Images/756db65b3001a353db53ecd058315dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c0O1j-rqT8h5uRvr.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Note the updates are done to storage slot 1 and 0 respectively.</figcaption></figure><p id="c96f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们如何利用这一点？十六进制c097ce7bc90715b34b9f1000000000是指我们输入的以太量，为10**36。在这种情况下，我们可以通过使用十六进制到十进制转换器计算出我们地址的uint256等价物来编辑Owner变量，将其作为参数传递给<code class="eh kz la lb lc b"><em class="ld">etherAmount</em></code>，同时发送与<code class="eh kz la lb lc b"><em class="ld">etherAmount / 10**36</em></code>等价的msg.value，有效地给予我们的地址从合同中提取所有资金的访问权。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/c2a78fcc537a17feb54ae1ce58f45d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LSOgvyVoQsqKjItO.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Convert your address from hex to decimal, using it as a parameter.</figcaption></figure><p id="73f2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所有这些都可以通过声明捐赠内存<code class="eh kz la lb lc b"><em class="ld">donation</em></code>来规避(如果我们想要正确地反映捐赠的数量，还需要让<code class="eh kz la lb lc b"><em class="ld">scale</em></code>正确地反映10**18)。</p><h1 id="5c39" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">12.五十年</h1><p id="d4e3" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="16fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">整个CaptureTheEther挑战赛的最高分是2000分。下面关于如何利用这个合同的描述将是相当长的，所以请原谅我。</p><p id="8496" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">本质上，漏洞本身与我们迄今为止所经历的并没有什么不同，然而，在我们耗尽之前，这个契约需要执行一些漏洞的正确顺序。</p><p id="8263" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从一些观察开始:</p><ol class=""><li id="a11d" class="lp lq ht is b it iu ix iy jb lr jf ls jj lt jn lu lv lw lx dt translated"><code class="eh kz la lb lc b"><em class="ld">upsert()</em></code>函数上的“else”语句没有正确声明贡献变量，而是依赖于“if”语句中的早期声明，这创建了一个指向该结构的指针。这意味着…同样，我们有机会直接利用合同存储片段0和1。</li><li id="61d1" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">这几天可能会对我们有利。</li><li id="d80f" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">“else”语句上的代码<code class="eh kz la lb lc b"><em class="ld">queue.push</em></code>应该将贡献结构的副本(内存)推送到现有数组。由于<code class="eh kz la lb lc b"><em class="ld">contribution.amount</em></code>和<code class="eh kz la lb lc b"><em class="ld">contribution.unlockTimeStamp</em></code>导致我们直接访问存储槽…我们最终会将什么推送到这里的数组<code class="eh kz la lb lc b"><em class="ld">queue</em></code>？</li></ol><p id="7af3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们确认我们的观察。</p><ol class=""><li id="93e9" class="lp lq ht is b it iu ix iy jb lr jf ls jj lt jn lu lv lw lx dt translated">输入一个值对，其中索引不为0，而<code class="eh kz la lb lc b"><em class="ld">timestamp = queue[0].timestamp + 86400</em></code>的msg.value为0，用0覆盖槽0x0，用时间戳+ 86400覆盖0x1。这些分别映射到<code class="eh kz la lb lc b"><em class="ld">queue</em></code>的长度和变量<code class="eh kz la lb lc b"><em class="ld">head</em></code>。</li><li id="36a6" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">这意味着如果我们想保留<code class="eh kz la lb lc b"><em class="ld">queue</em></code>的数组长度，我们需要在调用<code class="eh kz la lb lc b"><em class="ld">upsert()</em></code>时增加msg.value。</li><li id="006f" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">这个很简单。输入时间戳为2 * * 256–86400的内容，下一轮我们可以输入0作为时间戳。请记住，我们需要在每次使用<code class="eh kz la lb lc b"><em class="ld">upsert()</em></code>时发送一个递增的wei (msg.value ),以允许我们在每次推送新元素时适当地保留数组的长度。</li></ol><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/a88ef30c65a80fe4396cc7772730558e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EEQzPe6bi46-noE3.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Point 1 — Notice storage slots (key) 0x0 and 0x1 — Being 0 and timestamp + 86400</figcaption></figure><p id="482e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在没有指定msg.value的情况下，如果我们执行一个索引为1、时间戳为+ 86400的<code class="eh kz la lb lc b"><em class="ld">upsert()</em></code>，我们可以看到金额和时间戳+ 86400的值1被推送到数组中。继续使用索引2和时间戳+ 172800，我们可以看到1和时间戳+ 172800被推送到阵列。另一方面，如果我们在推送新元素时指定一个递增的msg.value来增加数组长度，同时重复同样的事情，我们会看到每个元素的数量随着数组长度的增加而增加(或者更准确地说，基于msg.value + 1，因为它将数组长度递增msg.value <strong class="is hu">，然后</strong>用最新的元素推送数组)。</p><p id="72cf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">了解了所有这些，让我们来看看如何为这个合同拼凑一个漏洞。检查<code class="eh kz la lb lc b"><em class="ld">withdraw()</em></code>函数的代码，我们可以看到，如果索引的时间戳已经过期(超过当前时间),我们可以传入我们想要撤回的索引。这里使用变量<code class="eh kz la lb lc b"><em class="ld">head</em></code>是为了防止我们遍历已经退出的索引。因此，为了利用这个契约，我们至少需要满足以下条件:a)拥有我们想要撤销的索引的时间戳，b)将head设置为0，这样我们就可以撤销最初的贡献。为了达到这种状态，我们可以执行如下序列:</p><ol class=""><li id="3822" class="lp lq ht is b it iu ix iy jb lr jf ls jj lt jn lu lv lw lx dt translated">用index = 1(金额变成2)调用<code class="eh kz la lb lc b"><em class="ld">upsert()</em></code>，时间戳= 2 * * 256–86400，msg.value = 1魏。<br/>结果是元素被追加到队列数组(queue.length = 2)，而contract总共保存1个ether和1个wei。变量<code class="eh kz la lb lc b"><em class="ld">header</em></code>将是2 * * 256–86400。</li><li id="5462" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">调用<code class="eh kz la lb lc b"><em class="ld">upsert()</em></code>，index = 2(金额变为3)，timestamp = 0，msg.value = 2魏。<br/>结果是元素被追加到队列数组(queue.length = 3)中，契约总共保存1个ether和3个wei。变量<code class="eh kz la lb lc b"><em class="ld">header</em></code>将为0。<br/>请注意，此时，我们还不能退出合同，因为总金额(10**18 + 2 + 3)大于合同持有的实际价值(1乙醚3魏)。因此，我们需要在合同中加入更多的醚，并从早期的指数中撤出，并试图将剩余的作为一个单独的过程排出。</li><li id="39f1" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">调用<code class="eh kz la lb lc b"><em class="ld">upsert()</em></code>索引= 3(金额变成4)，时间戳= 86400，msg.value = 3魏。<br/>结果是元素被追加到队列数组(queue.length = 4)中，契约总共保存1个ether和6个wei。变量<code class="eh kz la lb lc b"><em class="ld">header</em></code>将是86400。</li><li id="da9b" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">调用<code class="eh kz la lb lc b"><em class="ld">upsert()</em></code>，索引= 4(金额变成5)，时间戳= 2 * * 256–86400，msg.value = 4魏。<br/>结果是元素被追加到队列数组(queue.length = 5)中，契约总共保存1个ether和10个wei。变量<code class="eh kz la lb lc b"><em class="ld">header</em></code>将是2 * * 256–86400。</li><li id="2ad6" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">调用<code class="eh kz la lb lc b"><em class="ld">upsert()</em></code>索引= 5(金额变成6)，时间戳= 0，msg.value = 5魏。<br/>结果是元素被追加到队列(array.length = 6)中，并且契约总共保存1个ether和15个wei。变量<code class="eh kz la lb lc b"><em class="ld">header</em></code>将为0。</li><li id="b200" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">现在，我们可以在索引3上调用<code class="eh kz la lb lc b"><em class="ld">withdraw()</em></code>。这就让我们可以退掉1以太+ 2卫+ 3卫+ 4卫，剩下6卫的合同就要被榨干了。</li></ol><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/1426145fccede3e418ac0d48ec70d360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dfB-f1i2L5LH_rVW.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Contract drained successfully — Leaving with 6 wei.</figcaption></figure><p id="aa00" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们已经成功榨干了合同。请注意，默认情况下<code class="eh kz la lb lc b"><em class="ld">returnTotal</em></code>不存在——添加它是为了让我在测试时快速检查合同余额。</p><p id="1a2a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们怎么榨干剩下的6个魏呢？回想一下，我们可以在不发送msg.value的情况下执行一个<code class="eh kz la lb lc b"><em class="ld">upsert()</em></code>，这将导致<code class="eh kz la lb lc b"><em class="ld">contribution.amount</em></code>为1。我们需要弄清楚的是，当<code class="eh kz la lb lc b"><em class="ld">contribution.amount is 1</em></code>时，我们如何达到<code class="eh kz la lb lc b"><em class="ld">contribution.timestamp</em></code>为0的状态。这可以简单地通过在时间戳2 * * 256–86400和0之间交替来完成，这允许我们到达<code class="eh kz la lb lc b"><em class="ld">contribution.amount = 1</em></code>和<code class="eh kz la lb lc b"><em class="ld">contribution.timestamp = 0</em></code>。随后，从索引0开始撤回。重复这些动作6次，我们将能够完全耗尽此合同！</p><p id="28d5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这整个序列可能看起来有点抽象和难以理解，所以我有下面的要点链接，它显示了我是如何在VB中使用Nethereum执行这个漏洞利用的。网络:</p><p id="2723" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://gist.github.com/Enigmatic331/1af7f92d221bd831fc81f50ac8cd72ea" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/enigmatic 331/1 af 7 f 92d 221 BD 831 fc 81 f 50 AC 8 CD 72 ea</a></p><h1 id="f416" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">结论</h1><p id="701f" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">这就结束了这个多部分系列的第二部分。在一份聪明的合同上保持价值是有风险的，它保持的价值越多，审查合同的人越多越好。一些关键要点:</p><ol class=""><li id="a002" class="lp lq ht is b it iu ix iy jb lr jf ls jj lt jn lu lv lw lx dt translated">总是有一双额外的眼睛来检查你的代码；如果没有其他人可以帮助你，那么就尽可能地彻底——回顾、单元测试、回顾、尝试破解你自己的代码、清洗并重复。</li><li id="f9b4" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">如果您正在开发存储大量价值的生产代码，最好的选择是聘请像ChainSecurity这样的智能合同审计员，对您的合同进行专业审计。</li><li id="8288" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">使用SafeMath进行算术运算。句号。</li><li id="7e01" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">不要依赖用户输入来分配数组索引。代码，因此这可以由智能合约在内部处理。</li></ol><p id="6005" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这些系列的最后一部分将在几周内完成，其中一两个挑战稍微超出了简单地破解智能合同的范围。会很有趣。而且…如果你还没有，我仍然鼓励你在此期间尝试其余的挑战——祝你一切顺利！</p><blockquote class="mk"><p id="dfac" class="ml mm ht bd mn mo mp mq mr ms mt jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mv mw mx my mz kw fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mu"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>