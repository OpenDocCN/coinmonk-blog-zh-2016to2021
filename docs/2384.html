<html>
<head>
<title>DelegateCall: Calling Another Contract Function in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DelegateCall:在Solidity中调用另一个合同函数</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/delegatecall-calling-another-contract-function-in-solidity-b579f804178c?source=collection_archive---------0-----------------------#2019-09-01">https://medium.com/coinmonks/delegatecall-calling-another-contract-function-in-solidity-b579f804178c?source=collection_archive---------0-----------------------#2019-09-01</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/14abbf7b3204355827a2a1586127fec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hlqUpQMrXwX3aTBh08oizg.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by NOAA on Unsplash</figcaption></figure><p id="f224" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在这篇文章中，我们将看到如何调用另一个契约函数。而且我们更深入地谈论了关于<code class="eh kd ke kf kg b">delegatecall</code></p><p id="5fae" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在编写以太坊SmartContract代码时，有些情况下我们需要与其他契约进行交互。在坚固性上，为了这个目的，有几种方法可以达到这个目的。</p><h2 id="587a" class="kh ki ht bd kj kk kl km kn ko kp kq kr jq ks kt ku ju kv kw kx jy ky kz la lb dt translated">如果我们知道目标合同ABI，我们可以直接使用函数签名</h2><p id="e717" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">假设我们已经部署了一个名为“存储”的简单契约，它允许用户保存一个值。</p><pre class="lh li lj lk fq ll kg lm ln aw lo dt"><span id="32d2" class="kh ki ht kg b fv lp lq l lr ls">pragma solidity ^0.5.8;</span><span id="12cf" class="kh ki ht kg b fv lt lq l lr ls">contract Storage {<br/>    uint public val;</span><span id="e881" class="kh ki ht kg b fv lt lq l lr ls">constructor(uint v) public {<br/>        val = v;<br/>    }</span><span id="6892" class="kh ki ht kg b fv lt lq l lr ls">function setValue(uint v) public {<br/>        val = v;<br/>    }<br/>}</span></pre><p id="a1bc" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们希望部署另一个名为“机器”的合同，它是“存储”合同的调用方。“机器”引用“存储”契约并改变其值。</p><pre class="lh li lj lk fq ll kg lm ln aw lo dt"><span id="5614" class="kh ki ht kg b fv lp lq l lr ls">pragma solidity ^0.5.8;</span><span id="e4e4" class="kh ki ht kg b fv lt lq l lr ls">import "./Storage.sol";</span><span id="d42f" class="kh ki ht kg b fv lt lq l lr ls">contract Machine {<br/>    Storage public s;</span><span id="ed8c" class="kh ki ht kg b fv lt lq l lr ls">constructor(Storage addr) public {<br/>        s = addr;<br/>        calculateResult = 0;<br/>    }<br/>    <br/>    function saveValue(uint x) public returns (bool) {<br/>        s.setValue(x);<br/>        return true;<br/>    }</span><span id="f782" class="kh ki ht kg b fv lt lq l lr ls">function getValue() public view returns (uint) {<br/>        return s.val();<br/>    }<br/>}</span></pre><p id="6b95" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在这种情况下，我们知道“存储”的<a class="ae lu" href="https://solidity.readthedocs.io/en/develop/abi-spec.html" rel="noopener ugc nofollow" target="_blank"> ABI </a>和它的地址，这样我们就可以用这个地址初始化现有的“存储”契约，ABI告诉我们如何调用“存储”契约的功能。我们可以看到“机器”契约调用<code class="eh kd ke kf kg b">setValue()</code>的“存储”功能。</p><p id="6ab9" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">并编写测试代码来检查【机器】<code class="eh kd ke kf kg b">saveValue()</code>是否真正调用【存储】<code class="eh kd ke kf kg b">setValue()</code>功能并改变其状态。</p><pre class="lh li lj lk fq ll kg lm ln aw lo dt"><span id="9f38" class="kh ki ht kg b fv lp lq l lr ls">const StorageFactory = artifacts.require('Storage');<br/>const MachineFactory = artifacts.require('Machine');</span><span id="9609" class="kh ki ht kg b fv lt lq l lr ls">contract('Machine', accounts =&gt; {<br/>  const [owner, ...others] = accounts;</span><span id="9f1b" class="kh ki ht kg b fv lt lq l lr ls">beforeEach(async () =&gt; {<br/>    Storage = await StorageFactory.new(new BN('0'));<br/>    Machine = await MachineFactory.new(Storage.address);<br/>  });</span><span id="de7d" class="kh ki ht kg b fv lt lq l lr ls">describe('#saveValue()', () =&gt; {<br/>    it('should successfully save value', async () =&gt; {<br/>      await Machine.saveValue(new BN('54'));<br/>      (await Storage.val()).should.be.bignumber.equal(new BN('54'));<br/>    });<br/>  });<br/>});</span></pre><p id="7e9a" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">测试通过了！</p><pre class="lh li lj lk fq ll kg lm ln aw lo dt"><span id="2b9b" class="kh ki ht kg b fv lp lq l lr ls">Contract: Machine<br/>  After initalize<br/>    #saveValue()<br/>      ✓ should successfully save value (56ms)</span><span id="22c5" class="kh ki ht kg b fv lt lq l lr ls">1 passing (56ms)</span></pre><h2 id="7dfc" class="kh ki ht bd kj kk kl km kn ko kp kq kr jq ks kt ku ju kv kw kx jy ky kz la lb dt translated">如果我们不知道目标合同ABI，使用呼叫或委托呼叫</h2><p id="d4db" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">但是如果调用者(在这个例子中是“机器”契约)不知道目标契约的ABI呢？</p><p id="996f" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">尽管如此，我们可以用<code class="eh kd ke kf kg b">call()</code>和<code class="eh kd ke kf kg b">delegatecall()</code>调用目标契约的函数。</p><p id="e4a3" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在解释以太坊的稳固性<code class="eh kd ke kf kg b">call()</code>和<code class="eh kd ke kf kg b">delegatecall()</code>之前，看看EVM如何保存合约的变量对理解<code class="eh kd ke kf kg b">call()</code>和<code class="eh kd ke kf kg b">delegatecall()</code>会有所帮助。</p><h2 id="9032" class="kh ki ht bd kj kk kl km kn ko kp kq kr jq ks kt ku ju kv kw kx jy ky kz la lb dt translated">EVM如何将字段变量保存到存储器中</h2><p id="92b9" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">在以太坊中，有两种空间用于保存契约的字段变量。一个是“内存”，一个是“存储”。而什么‘foo被保存到存储器’意味着‘foo’的值被永久地记录到状态中。</p><p id="3683" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">那么一个契约中的这么多变量怎么可能不互相重叠地址空间呢？EVM将槽号分配给字段变量。</p><pre class="lh li lj lk fq ll kg lm ln aw lo dt"><span id="8fe7" class="kh ki ht kg b fv lp lq l lr ls">contract Sample1 {<br/>    uint256 first;  // slot 0<br/>    uint256 second; // slot 1<br/>}</span></pre><figure class="lh li lj lk fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lv"><img src="../Images/ee9c8d13bdf6a492e64ac5a1705ee16d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*HbQflFnXyorD6WhXU7sE8g.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">EVM saves field variables using slot</figcaption></figure><p id="2edf" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">因为<code class="eh kd ke kf kg b">first</code>在“样本1”中首先被声明，所以它被分配了0个槽。每个不同的变量通过其槽号来区分。</p><p id="3989" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在EVM中，它在智能合约存储中有2个⁵⁶槽，每个槽可以保存32字节大小数据。</p><h2 id="6052" class="kh ki ht bd kj kk kl km kn ko kp kq kr jq ks kt ku ju kv kw kx jy ky kz la lb dt translated">如何调用智能合同函数</h2><p id="f7c9" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">和Java、Python等通用编程代码一样，Solidity函数可以看作是一组命令。当我们说“函数被调用”时，这意味着我们将特定的上下文(如参数)注入到该组命令(函数)中，命令在该上下文中被一个接一个地执行。</p><p id="cbe6" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">和功能、命令组、地址空间可以通过其名称找到。</p><p id="2b5e" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在以太坊中函数调用可以用长达4 + 32 * N字节的字节码来表示。这个字节码由两部分组成。</p><ul class=""><li id="132f" class="lw lx ht jh b ji jj jm jn jq ly ju lz jy ma kc mb mc md me dt translated"><strong class="jh hu">函数选择器</strong>:这是函数调用字节码的前4个字节。这是通过散列目标函数的名称加上它的参数类型(不包括空格)生成的。比如<code class="eh kd ke kf kg b">savaValue(uint)</code>。目前，以太坊使用keccak-256哈希函数来创建函数选择器。基于这个函数选择器，EVM可以决定在契约中应该调用哪个函数。</li><li id="ef42" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated"><strong class="jh hu">函数参数</strong>:将参数的每个值转换成一个固定长度为32字节的十六进制字符串。如果有多个参数，请连接</li></ul><p id="d469" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">如果用户将这个4 + 32 * N字节的字节码传递给事务的数据字段。EVM可以找到应该执行哪个函数，然后向该函数注入参数。</p><h2 id="ce3c" class="kh ki ht bd kj kk kl km kn ko kp kq kr jq ks kt ku ju kv kw kx jy ky kz la lb dt translated">用测试案例解释委托通话</h2><h2 id="bb10" class="kh ki ht bd kj kk kl km kn ko kp kq kr jq ks kt ku ju kv kw kx jy ky kz la lb dt translated">语境</h2><p id="c0f7" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">我们讲智能合约函数怎么调用的时候有一个词“上下文”。实际上,“上下文”这个词在软件中是一个非常通用的概念，其含义会根据<em class="mk">上下文</em>而有所变化。</p><p id="6fe6" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">当我们谈到程序的执行时，我们可以说“上下文”就像所有环境变量或执行点的状态一样。例如，在程序“A”的执行点上，执行该程序的用户名是“zeroFruit”，那么用户名“zeroFruit”可以是程序“A”的上下文。</p><p id="7e36" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在以太坊智能合约中，有许多上下文，其中一个代表性的内容是“谁执行此合约”。你可能会在Solidity代码中看到<code class="eh kd ke kf kg b">msg.sender</code>很多，<code class="eh kd ke kf kg b">msg.sender</code>地址的值根据谁执行这个契约函数而变化。</p><h2 id="13e5" class="kh ki ht bd kj kk kl km kn ko kp kq kr jq ks kt ku ju kv kw kx jy ky kz la lb dt translated">委派电话</h2><p id="35ca" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated"><strong class="jh hu"> DelegateCall，顾名思义，是调用方契约调用目标契约函数的调用机制，但是当目标契约执行其逻辑时，上下文不在执行调用方契约的用户上，而是在调用方契约上。</strong></p><figure class="lh li lj lk fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ml"><img src="../Images/d3fef43203daa10da05d3635e5a2e628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PwYIsFyDM60IW4KuDkUncA.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Context when the contract calls another contract</figcaption></figure><figure class="lh li lj lk fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ml"><img src="../Images/dd5a70fee41eea7aff28f20c1ba554e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4OB3IwTF1AkW6zH3tJv8Tw.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Context when contract delegatecall another contract</figcaption></figure><p id="4e6e" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">那么当合同委托给目标时，存储的状态会发生怎样的变化？</p><p id="6f16" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">因为当delegatecall到target时，上下文在调用者契约上，所有的状态改变逻辑都反映在调用者的存储上。</p><p id="9d6d" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">例如，我们有代理合同和商业合同。代理合同委托调用业务合同函数。如果用户调用代理契约，代理契约将委托调用业务契约，功能将被执行。但是所有状态更改都将反映在代理契约存储中，而不是业务契约中。</p><h2 id="865a" class="kh ki ht bd kj kk kl km kn ko kp kq kr jq ks kt ku ju kv kw kx jy ky kz la lb dt translated">判例案件</h2><p id="835a" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">这是之前解释的合同的扩展版本。除了测试存储将如何改变之外，它仍然有“存储”作为字段和<code class="eh kd ke kf kg b">addValuesWithDelegateCall</code>、<code class="eh kd ke kf kg b">addValuesWithCall</code>。而“机器”有<code class="eh kd ke kf kg b">calculateResult</code>、<code class="eh kd ke kf kg b">user</code>用于保存加法结果和调用此功能的人各一个。</p><pre class="lh li lj lk fq ll kg lm ln aw lo dt"><span id="aaa4" class="kh ki ht kg b fv lp lq l lr ls">pragma solidity ^0.5.8;</span><span id="2a4a" class="kh ki ht kg b fv lt lq l lr ls">import "./Storage.sol";</span><span id="a2de" class="kh ki ht kg b fv lt lq l lr ls">contract Machine {<br/>    Storage public s;<br/>    <br/>    uint256 public calculateResult;<br/>    <br/>    address public user;<br/>  <br/>    event AddedValuesByDelegateCall(uint256 a, uint256 b, bool success);<br/>    event AddedValuesByCall(uint256 a, uint256 b, bool success);<br/>    <br/>    constructor(Storage addr) public {<br/>        ...<br/>        calculateResult = 0;<br/>    }<br/>    <br/>  ...<br/>    <br/>    function addValuesWithDelegateCall(address calculator, uint256 a, uint256 b) public returns (uint256) {<br/>        (bool success, bytes memory result) = calculator.delegatecall(abi.encodeWithSignature("add(uint256,uint256)", a, b));<br/>        emit AddedValuesByDelegateCall(a, b, success);<br/>        return abi.decode(result, (uint256));<br/>    }<br/>    <br/>    function addValuesWithCall(address calculator, uint256 a, uint256 b) public returns (uint256) {<br/>        (bool success, bytes memory result) = calculator.call(abi.encodeWithSignature("add(uint256,uint256)", a, b));<br/>        emit AddedValuesByCall(a, b, success);<br/>        return abi.decode(result, (uint256));<br/>    }<br/>}</span></pre><p id="799d" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这是我们的目标合同“计算器”。它还有<code class="eh kd ke kf kg b">calculateResult</code>和<code class="eh kd ke kf kg b">user</code>。</p><pre class="lh li lj lk fq ll kg lm ln aw lo dt"><span id="67ae" class="kh ki ht kg b fv lp lq l lr ls">pragma solidity ^0.5.8;</span><span id="bb86" class="kh ki ht kg b fv lt lq l lr ls">contract Calculator {<br/>    uint256 public calculateResult;<br/>    <br/>    address public user;<br/>    <br/>    event Add(uint256 a, uint256 b);<br/>    <br/>    function add(uint256 a, uint256 b) public returns (uint256) {<br/>        calculateResult = a + b;<br/>        assert(calculateResult &gt;= a);<br/>        <br/>        emit Add(a, b);<br/>        user = msg.sender;<br/>        <br/>        return calculateResult;<br/>    }<br/>}</span></pre><h2 id="6c4b" class="kh ki ht bd kj kk kl km kn ko kp kq kr jq ks kt ku ju kv kw kx jy ky kz la lb dt translated">测试addValuesWithCall</h2><p id="d046" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">这是我们的<code class="eh kd ke kf kg b">addValuesWithCall</code>测试代码。我们需要测试的是</p><ul class=""><li id="1db9" class="lw lx ht jh b ji jj jm jn jq ly ju lz jy ma kc mb mc md me dt translated">因为上下文是在“计算器”而不是“机器”上，所以加法结果应该保存到“计算器”存储器中</li><li id="3cf0" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">所以【计算器】<code class="eh kd ke kf kg b">calculateResult</code>应该是3，而<code class="eh kd ke kf kg b">user</code>地址应该设置为“机器”地址。</li><li id="4df6" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">而【机器】<code class="eh kd ke kf kg b">calculateResult</code>应为0，而<code class="eh kd ke kf kg b">user</code>为0地址。</li></ul><pre class="lh li lj lk fq ll kg lm ln aw lo dt"><span id="d859" class="kh ki ht kg b fv lp lq l lr ls">describe('#addValuesWithCall()', () =&gt; {<br/>  let Calculator;<br/>      <br/>  beforeEach(async () =&gt; {<br/>    Calculator = await CalculatorFactory.new();<br/>  });<br/>      <br/>  it('should successfully add values with call', async () =&gt; {<br/>    const result = await Machine.addValuesWithCall(Calculator.address, new BN('1'), new BN('2'));</span><span id="6542" class="kh ki ht kg b fv lt lq l lr ls">expectEvent.inLogs(result.logs, 'AddedValuesByCall', {<br/>      a: new BN('1'),<br/>      b: new BN('2'),<br/>      success: true,<br/>    });</span><span id="7984" class="kh ki ht kg b fv lt lq l lr ls">(result.receipt.from).should.be.equal(owner.toString().toLowerCase());<br/>    (result.receipt.to).should.be.equal(Machine.address.toString().toLowerCase());</span><span id="ef53" class="kh ki ht kg b fv lt lq l lr ls">(await Calculator.calculateResult()).should.be.bignumber.equal(new BN('3'));<br/>    (await Machine.calculateResult()).should.be.bignumber.equal(new BN('0'));</span><span id="cccb" class="kh ki ht kg b fv lt lq l lr ls">(await Machine.user()).should.be.equal(constants.ZERO_ADDRESS);<br/>    (await Calculator.user()).should.be.equal(Machine.address);<br/>  });<br/>});</span></pre><p id="6347" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">并按预期测试通过！</p><pre class="lh li lj lk fq ll kg lm ln aw lo dt"><span id="515a" class="kh ki ht kg b fv lp lq l lr ls">Contract: Machine<br/>  After initalize<br/>    #addValuesWithCall()<br/>      ✓ should successfully add values with call (116ms)</span><span id="4997" class="kh ki ht kg b fv lt lq l lr ls">1 passing (116ms)</span></pre><h2 id="a87a" class="kh ki ht bd kj kk kl km kn ko kp kq kr jq ks kt ku ju kv kw kx jy ky kz la lb dt translated">测试addValuesWithDelegateCall</h2><p id="eff2" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">这是我们的<code class="eh kd ke kf kg b">addValuesWithCall</code>测试代码。我们需要测试的是</p><ul class=""><li id="b6a2" class="lw lx ht jh b ji jj jm jn jq ly ju lz jy ma kc mb mc md me dt translated">因为上下文是在“机器”而不是“计算器”上，所以加法结果应该保存到“机器”存储器中</li><li id="9d00" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">所以【计算器】<code class="eh kd ke kf kg b">calculateResult</code>应该是0，而<code class="eh kd ke kf kg b">user</code>地址应该设置为零地址。</li><li id="5eeb" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">而【机器】应该是3，<code class="eh kd ke kf kg b">user</code>应该是EOA。</li></ul><pre class="lh li lj lk fq ll kg lm ln aw lo dt"><span id="954b" class="kh ki ht kg b fv lp lq l lr ls">describe('#addValuesWithDelegateCall()', () =&gt; {<br/>  let Calculator;<br/>  <br/>  beforeEach(async () =&gt; {<br/>    Calculator = await CalculatorFactory.new();<br/>  });<br/>  <br/>  it('should successfully add values with delegate call', async () =&gt; {<br/>    const result = await Machine.addValuesWithDelegateCall(Calculator.address, new BN('1'), new BN('2'));</span><span id="0ea2" class="kh ki ht kg b fv lt lq l lr ls">expectEvent.inLogs(result.logs, 'AddedValuesByDelegateCall', {<br/>      a: new BN('1'),<br/>      b: new BN('2'),<br/>      success: true,<br/>    });</span><span id="e3dd" class="kh ki ht kg b fv lt lq l lr ls">(result.receipt.from).should.be.equal(owner.toString().toLowerCase());<br/>    (result.receipt.to).should.be.equal(Machine.address.toString().toLowerCase());</span><span id="4b4e" class="kh ki ht kg b fv lt lq l lr ls">// Calculator storage DOES NOT CHANGE!<br/>    (await Calculator.calculateResult()).should.be.bignumber.equal(new BN('0'));<br/>    <br/>    // Only calculateResult in Machine contract should be changed<br/>    (await Machine.calculateResult()).should.be.bignumber.equal(new BN('3'));</span><span id="838a" class="kh ki ht kg b fv lt lq l lr ls">(await Machine.user()).should.be.equal(owner);<br/>    (await Calculator.user()).should.be.equal(constants.ZERO_ADDRESS);<br/>  });<br/>});</span></pre><p id="20dc" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">但是失败了！什么？？？</strong>哪里来的“562046206989085878832492993516240920558397288279”？</p><pre class="lh li lj lk fq ll kg lm ln aw lo dt"><span id="5cd8" class="kh ki ht kg b fv lp lq l lr ls">0 passing (236ms)<br/>1 failing</span><span id="196f" class="kh ki ht kg b fv lt lq l lr ls">1) Contract: Machine<br/>     After initalize<br/>       #addValuesWithDelegateCall()<br/>         should successfully add values with delegate call:</span><span id="637c" class="kh ki ht kg b fv lt lq l lr ls">AssertionError: expected '562046206989085878832492993516240920558397288279' to equal '3'<br/>    + expected - actual</span><span id="7795" class="kh ki ht kg b fv lt lq l lr ls">-562046206989085878832492993516240920558397288279<br/>    +3</span></pre><p id="0ac1" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">正如我们之前提到的，每个字段变量都有自己的槽。而当我们delegate call“Calculator”时，上下文是在“Machine”上，但是槽号是基于“Calculator”的。所以因为“计算器”逻辑用<code class="eh kd ke kf kg b">calculateResult</code>覆盖了<code class="eh kd ke kf kg b">Storage</code>地址，所以从<code class="eh kd ke kf kg b">calculateResult</code>到<code class="eh kd ke kf kg b">user</code>，测试失败。</p><p id="cf50" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">基于这些知识，我们可以找到‘562046206989085878832492993516240920558397288279’来自哪里。这是EOA的十进制版本。</p><figure class="lh li lj lk fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mm"><img src="../Images/e5b5099bf605b79cd41a949e43082245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5EZxbu2IB9p3ACCy2PXyg.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">“Calculator” contract field variable overrides “Machine” contract field variable</figcaption></figure><p id="14aa" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">所以要解决这个问题，我们需要改变“机器”字段变量的顺序。</p><pre class="lh li lj lk fq ll kg lm ln aw lo dt"><span id="018e" class="kh ki ht kg b fv lp lq l lr ls">contract Machine {<br/>    uint256 public calculateResult;<br/>    <br/>    address public user;<br/>    <br/>    Storage public s;<br/>    <br/>    ...<br/>}</span></pre><p id="7f99" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">最后，测试通过了！</p><pre class="lh li lj lk fq ll kg lm ln aw lo dt"><span id="8b1a" class="kh ki ht kg b fv lp lq l lr ls">Contract: Machine<br/>  After initalize<br/>    #addValuesWithDelegateCall()<br/>      ✓ should successfully add values with delegate call (106ms)</span><span id="0c7b" class="kh ki ht kg b fv lt lq l lr ls">1 passing (247ms)</span></pre><h2 id="3782" class="kh ki ht bd kj kk kl km kn ko kp kq kr jq ks kt ku ju kv kw kx jy ky kz la lb dt translated">包裹</h2><p id="9a06" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">在这篇文章中，我们看到了如何从契约中调用另一个契约的函数。</p><ul class=""><li id="bfa6" class="lw lx ht jh b ji jj jm jn jq ly ju lz jy ma kc mb mc md me dt translated">如果我们知道目标函数的ABI，我们可以直接使用目标函数签名</li><li id="8542" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">如果我们不知道目标函数的ABI，我们可以使用<code class="eh kd ke kf kg b">call()</code>，或者<code class="eh kd ke kf kg b">delegatecall()</code>。但是在<code class="eh kd ke kf kg b">delegatecall()</code>的情况下，我们需要关心字段变量的顺序。</li></ul><h2 id="84dc" class="kh ki ht bd kj kk kl km kn ko kp kq kr jq ks kt ku ju kv kw kx jy ky kz la lb dt translated">源代码</h2><p id="78d1" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">如果您想自己测试，您可以在这个资源库中找到代码。</p><div class="mn mo fm fo mp mq"><a href="https://github.com/zeroFruit/upgradable-contract/tree/feat/delegatecall" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hu fv z el mv eo ep mw er et hs dt translated">零水果/可升级合同</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">这个库是为了演示两件事如何委托调用，调用可以在可靠性如何升级智能…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">github.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne iz mq"/></div></div></a></div><blockquote class="nf"><p id="b34a" class="ng nh ht bd ni nj nk nl nm nn no kc ek translated">加入Coinmonks <a class="ae lu" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae lu" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae lu" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="kh ki ht bd kj kk np km kn ko nq kq kr jq nr kt ku ju ns kw kx jy nt kz la lb dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="lw lx ht jh b ji lc jm ld jq nu ju nv jy nw kc mb mc md me dt translated"><a class="ae lu" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae lu" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="14e6" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated"><a class="ae lu" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae lu" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated"><a class="ae lu" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae lu" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="f33b" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated"><a class="ae lu" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae lu" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">开发人员的最佳加密API</li><li id="b359" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">最佳<a class="ae lu" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated"><a class="ae lu" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li><li id="95d1" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated"><a class="ae lu" href="https://coincodecap.com/best-vpns-for-crypto-trading" rel="noopener ugc nofollow" target="_blank">最适合加密交易的VPN</a></li><li id="918f" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated"><a class="ae lu" href="https://coincodecap.com/blockchain-analytics" rel="noopener ugc nofollow" target="_blank">最佳加密分析或链上数据</a> | <a class="ae lu" href="https://coincodecap.com/bexplus-review" rel="noopener ugc nofollow" target="_blank"> Bexplus评论</a></li><li id="51af" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated"><a class="ae lu" href="https://coincodecap.com/nft-marketplaces" rel="noopener ugc nofollow" target="_blank">NFT十大市场造币集锦</a></li><li id="f72f" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated"><a class="ae lu" href="https://coincodecap.com/ascendex-staking" rel="noopener ugc nofollow" target="_blank">AscendEx Staking</a>|<a class="ae lu" href="https://coincodecap.com/bot-ocean-review" rel="noopener ugc nofollow" target="_blank">Bot Ocean Review</a>|<a class="ae lu" href="https://coincodecap.com/bitcoin-wallets-india" rel="noopener ugc nofollow" target="_blank">最佳比特币钱包</a></li><li id="4ec1" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated"><a class="ae lu" href="https://coincodecap.com/bitget-review" rel="noopener ugc nofollow" target="_blank"> Bitget回顾</a>|<a class="ae lu" href="https://coincodecap.com/gemini-vs-blockfi" rel="noopener ugc nofollow" target="_blank">Gemini vs block fi</a>|<a class="ae lu" href="https://coincodecap.com/okex-futures-trading" rel="noopener ugc nofollow" target="_blank">OKEx期货交易</a></li></ul></div></div>    
</body>
</html>