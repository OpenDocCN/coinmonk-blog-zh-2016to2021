<html>
<head>
<title>How to create an upgradeable smart contract using OpenZeppelin SDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用OpenZeppelin SDK创建可升级的智能合约</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-create-an-upgradeable-smart-contract-using-openzeppelin-sdk-example-of-fixing-smart-260dfbfd5bae?source=collection_archive---------1-----------------------#2019-08-05">https://medium.com/coinmonks/how-to-create-an-upgradeable-smart-contract-using-openzeppelin-sdk-example-of-fixing-smart-260dfbfd5bae?source=collection_archive---------1-----------------------#2019-08-05</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="2613" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">修复易受下溢/溢出攻击的智能合约的示例</h2></div><p id="231d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在本教程中，我们将使用OpenZeppelin SDK来修复易受下溢/溢出攻击的智能合约。首先，我们将准备我们的环境，创建带有一些错误的可升级智能合同，并对其进行测试。然后，我们将更新代码，升级智能合同，最后，我们将检查它是否安全。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ke"><img src="../Images/9c54dd5b039156a57962a8559b801829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wN5t9ILU0fpnhbMX2vtng.jpeg"/></div></div></figure><h1 id="8af3" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">智能合约中的可升级性</h1><p id="d67e" class="pw-post-body-paragraph ji jj ht jk b jl li iu jn jo lj ix jq jr lk jt ju jv ll jx jy jz lm kb kc kd hm dt translated">原则上，智能合约是不可变的。一旦部署到网络上，就无法更改。不幸的是，在智能合同中，就像在所有软件中一样，错误经常发生。有时它们可能会花费数百万美元…但是不要担心！现在我们有了OpenZeppelin SDK(前ZeppelinOS)——升级我们的智能合同和修复错误的强大工具。<em class="ln"> OpenZeppelin SDK是一个开发、部署和运营以太坊和所有其他EVM和eWASM驱动的区块链</em>上的智能合同项目的平台，正如其<a class="ae lo" href="https://docs.openzeppelin.com/sdk/2.5/" rel="noopener ugc nofollow" target="_blank">文档</a>所说。其最重要的功能之一是智能合约的可升级性。</p><h1 id="a96a" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">环境准备</h1><p id="6ea7" class="pw-post-body-paragraph ji jj ht jk b jl li iu jn jo lj ix jq jr lk jt ju jv ll jx jy jz lm kb kc kd hm dt translated">您需要安装用于创建和升级智能合同的基本软件。你可以在我的<a class="ae lo" rel="noopener" href="/@paulina.blaszk/how-to-write-and-deploy-first-smart-contract-in-solidity-0-5-x-and-truffle-5-x-x-3054ec5328ad">上一篇文章</a>中找到安装Node.js和NPM、Ganache的说明。</p><h1 id="872a" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">OpenZeppelin SDK安装</h1><p id="422a" class="pw-post-body-paragraph ji jj ht jk b jl li iu jn jo lj ix jq jr lk jt ju jv ll jx jy jz lm kb kc kd hm dt translated">为了全局安装OpenZeppelin SDK，我们运行一个命令:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="7e12" class="lu kr ht lq b fv lv lw l lx ly">npm install -g @openzeppelin/cli</span></pre><p id="0ddd" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要检查您是否已经安装了OpenZeppelin SDK或确保安装过程成功，您可以验证您的软件版本:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="fb61" class="lu kr ht lq b fv lv lw l lx ly">oz --version</span></pre><p id="eee9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在所有OpenZeppelin SDK命令中，我都使用了从<code class="eh lz ma mb lq b">openzeppelin</code>简写而来的<code class="eh lz ma mb lq b">oz</code>。</p><p id="2f22" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我目前使用的是OpenZeppelin SDK v2.5.1。</p><h1 id="6c75" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">项目设置</h1><p id="73f3" class="pw-post-body-paragraph ji jj ht jk b jl li iu jn jo lj ix jq jr lk jt ju jv ll jx jy jz lm kb kc kd hm dt translated">我们必须为我们的项目创建一个新目录，然后导航到它:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="f87e" class="lu kr ht lq b fv lv lw l lx ly">mkdir hello-oz<br/>cd hello-oz</span></pre><h1 id="c508" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">项目启动</h1><p id="2516" class="pw-post-body-paragraph ji jj ht jk b jl li iu jn jo lj ix jq jr lk jt ju jv ll jx jy jz lm kb kc kd hm dt translated">首先，我们需要创建“package.json”文件:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="a88b" class="lu kr ht lq b fv lv lw l lx ly">npm init -y</span></pre><p id="0dea" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们运行这个带有<code class="eh lz ma mb lq b">-y</code>标志的命令来生成package.json，而不让它问任何问题——它将采用默认值。当然，如果你想个性化它，你可以只使用<code class="eh lz ma mb lq b">npm init</code>和回答给定的问题。</p><p id="ff73" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">接下来，我们终于可以初始化我们的第一个OpenZeppelin SDK项目了:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="4fde" class="lu kr ht lq b fv lv lw l lx ly">oz init</span></pre><p id="d87b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们将被要求输入项目名称和版本——我们可以使用<em class="ln"> hello-oz </em>名称，选择版本1.0.0并按enter键接受。</p><p id="91d1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一个命令<code class="eh lz ma mb lq b">oz init </code>在<code class="eh lz ma mb lq b">.openzepplin</code>目录下创建文件<code class="eh lz ma mb lq b">project.json</code>。它存储了我们项目的一般配置(清单版本、初始化项目的名称、它的版本以及关于我们项目包含的合同的信息)。</p><h1 id="1d69" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">创建智能合同示例</h1><p id="0be0" class="pw-post-body-paragraph ji jj ht jk b jl li iu jn jo lj ix jq jr lk jt ju jv ll jx jy jz lm kb kc kd hm dt translated">当我们在代码中发现一个bug时，智能合约不变性的问题可能会特别突出。如果没有可升级性，我们对这样一个智能合同就无能为力，它可能成为黑客攻击的一个很大的目标。对于我们的示例，我们将创建易受下溢/上溢攻击的智能契约(您可以在这里<a class="ae lo" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#integer-overflow-and-underflow" rel="noopener ugc nofollow" target="_blank">阅读更多信息</a></p><p id="3410" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在<code class="eh lz ma mb lq b">project.json</code>文件中，我们可以看到存储我们的合同的对象是空的，所以是时候创建我们的智能合同了。首先，我们在<em class="ln">合同</em>目录中添加新文件。我们可以称之为<code class="eh lz ma mb lq b">HelloOz.sol</code>。我们的智能合同将包含:</p><ul class=""><li id="52bb" class="mc md ht jk b jl jm jo jp jr me jv mf jz mg kd mh mi mj mk dt translated">字符串状态变量<em class="ln">名称</em>(仅用于测试)</li><li id="590b" class="mc md ht jk b jl ml jo mm jr mn jv mo jz mp kd mh mi mj mk dt translated">uint256状态变量<em class="ln"> inc </em></li><li id="a607" class="mc md ht jk b jl ml jo mm jr mn jv mo jz mp kd mh mi mj mk dt translated">uint256状态变量<em class="ln"> dec </em></li><li id="6bdc" class="mc md ht jk b jl ml jo mm jr mn jv mo jz mp kd mh mi mj mk dt translated">功能<em class="ln">减量</em>(从所选数字中减去1)</li><li id="a207" class="mc md ht jk b jl ml jo mm jr mn jv mo jz mp kd mh mi mj mk dt translated">功能<em class="ln">增加</em>(将所选数字加1)</li></ul><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="d100" class="lu kr ht lq b fv lv lw l lx ly">pragma solidity ^0.5.0;</span><span id="25d7" class="lu kr ht lq b fv mq lw l lx ly">contract HelloOz {<br/>  string public name;<br/>  uint256 public dec;<br/>  uint256 public inc;</span><span id="71dd" class="lu kr ht lq b fv mq lw l lx ly">  function decrement(uint256 x) public returns (uint256) {<br/>      return dec = x - 1;<br/>  }</span><span id="ac93" class="lu kr ht lq b fv mq lw l lx ly">  function increment(uint256 x) public returns (uint256) {<br/>      return inc = x + 1;<br/>  }<br/>}</span></pre><p id="c60a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在可升级的智能合约中，我们使用<em class="ln"> init </em>函数，而不是<em class="ln">构造函数</em>。为什么？部署智能合约实例时，执行<em class="ln">构造函数</em>。在基于代理的可升级性系统中，这种情况永远不会发生。这就是为什么我们使用<em class="ln">初始化器</em>。为此，在HelloOz.sol开始时，就在<code class="eh lz ma mb lq b">pragma</code>之后，我们必须从OpenZeppelin Upgrades导入合同<code class="eh lz ma mb lq b">Initializable.sol</code>:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="05b2" class="lu kr ht lq b fv lv lw l lx ly">import "@openzeppelin/upgrades/contracts/Initializable.sol"</span></pre><p id="d7e4" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当然，要使用OpenZeppelin升级(以前的ZeppelinOS库<code class="eh lz ma mb lq b">zos-lib</code>)我们必须将它安装在我们的项目目录中，所以我们必须运行一个命令:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="e652" class="lu kr ht lq b fv lv lw l lx ly">npm install <a class="ae lo" href="http://twitter.com/openzeppelin/upgrades" rel="noopener ugc nofollow" target="_blank">@openzeppelin/upgrades</a> --save</span></pre><p id="50ff" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在我们可以将我们的智能契约定义为<em class="ln">可初始化的</em>并添加<em class="ln"> init </em>函数。</p><p id="5331" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">整个合同代码是:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="663b" class="lu kr ht lq b fv lv lw l lx ly">pragma solidity ^0.5.0;<br/>import "@openzeppelin/upgrades/contracts/Initializable.sol";</span><span id="b0bd" class="lu kr ht lq b fv mq lw l lx ly">contract HelloOz is Initializable {<br/>    string public name;<br/>    uint256 public dec;<br/>    uint256 public inc;</span><span id="d113" class="lu kr ht lq b fv mq lw l lx ly">    function initialize(string memory _name) initializer public {<br/>        name = _name;<br/>    }</span><span id="46ba" class="lu kr ht lq b fv mq lw l lx ly">    function decrement(uint256 x) public returns (uint256) {<br/>        return dec = x - 1;<br/>    }</span><span id="c11c" class="lu kr ht lq b fv mq lw l lx ly">    function increment(uint256 x) public returns (uint256) {<br/>        return inc = x + 1;<br/>    }<br/>}</span></pre><p id="5463" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们可以检查我们的智能合约是否正确编译</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="cc2a" class="lu kr ht lq b fv lv lw l lx ly">oz compile</span></pre><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff mr"><img src="../Images/7cf7f72fb35988c5245e77d7ca663547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X915vKGvuurVc8VT3EPAEA.png"/></div></div></figure><p id="92e0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在是享受最大乐趣的时候了——让我们将智能合约部署到网络上，测试它并修复错误！</p><h1 id="8716" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">创建智能合同的可升级实例</h1><p id="7a2b" class="pw-post-body-paragraph ji jj ht jk b jl li iu jn jo lj ix jq jr lk jt ju jv ll jx jy jz lm kb kc kd hm dt translated">我们必须运行我们的开发网络(Ganache)。现在，我们可以通过以下方式部署智能合约的可升级实例:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="e801" class="lu kr ht lq b fv lv lw l lx ly">oz create</span></pre><p id="be33" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">运行此命令后，我们必须选择我们的合同名称和网络。问题<em class="ln">的答案创建实例后，是否希望在实例上调用函数？</em>为<code class="eh lz ma mb lq b">y</code>，我们可以选择<code class="eh lz ma mb lq b">initialize</code>功能并输入参数。结果是:</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ms"><img src="../Images/c502aebca8009fe738616ff027d366f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hhgNNlBpusSymtuudegxFw.png"/></div></div></figure><p id="142b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你的HelloOz代理的“地址”是我们可以在控制台中看到的白色地址，稍后我们将与它进行交互。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff mt"><img src="../Images/ffd54bd3684f56012508565ce1b9323b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gC-v3vRm3hY6HDKoVPy1lg.png"/></div></div></figure><p id="2f8a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们也可以在<code class="eh lz ma mb lq b">.openzepplin</code>目录下的<code class="eh lz ma mb lq b">dev-&lt;number&gt;.json</code>底部找到我们的智能合约</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="e0a2" class="lu kr ht lq b fv lv lw l lx ly">"proxies": {<br/>    "hello-oz/HelloOz": [<br/>      {<br/>        "address": "0x1161e67eFf76cb6F7Fb18d52F674D3e9C59dc950",<br/>        "version": "1.0.0",<br/>        "implementation": "0x64786cCD5C1C2572CEe97B09ed1F12fa0857a561",<br/>        "admin": "0x1aA7817c55ACee80426e10eAB66320F686539880",<br/>        "kind": "Upgradeable"<br/>      }<br/>    ]<br/>  }</span></pre><p id="18e5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">“实施”是当前智能合同版本的地址，当我们升级我们的智能合同时，它会发生变化。</p><h1 id="3514" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">与我们的智能合同互动</h1><p id="b763" class="pw-post-body-paragraph ji jj ht jk b jl li iu jn jo lj ix jq jr lk jt ju jv ll jx jy jz lm kb kc kd hm dt translated">现在我们可以测试我们的智能合约是如何工作的。为了与它通信，我们将使用<code class="eh lz ma mb lq b">openzeppelin send-tx</code>和<code class="eh lz ma mb lq b">openzeppelin call</code>。运行这些命令后，我们必须选择网络、实例、功能和(需要时)。</p><p id="cc51" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">开始时，我们可以检查状态变量的值:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="a02d" class="lu kr ht lq b fv lv lw l lx ly">oz call</span></pre><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff mu"><img src="../Images/2b9afb5551e26c9007faf0b9bcc5fc61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XwFsX1LFjhS3n2w5ZJUdLw.png"/></div></div></figure><p id="7597" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们可以看到<em class="ln">名称</em>被正确初始化，并且<em class="ln"> dec和</em> ind返回0。</p><p id="76c2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在，我们可以通过运行以下命令，用一个简单的数字(例如5)来检查我们的<em class="ln">减量</em>函数:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="cf1e" class="lu kr ht lq b fv lv lw l lx ly">oz send-tx</span></pre><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff mv"><img src="../Images/01f62efe6bb3e5b7c3a4f71ae93f4a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqQ_dnmg0sjQmtqsQIDNkA.png"/></div></div></figure><p id="f81f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们可以用<em class="ln">增量</em>做同样的事情</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff mv"><img src="../Images/b162ff4eff3374aee9bb81b8f38c2044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_c2QyJmcERko-4L47UWXhA.png"/></div></div></figure><p id="ad81" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">从表面上看，我们的结果看起来不错。</p><p id="3847" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在是时候将<em class="ln">功能递减</em>为0:</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff mw"><img src="../Images/bdd30624e0bb7712dcaf0ad4b152a6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HcRg1vBx0d6XTenRKP6zVw.png"/></div></div></figure><p id="91ba" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">和<em class="ln">用<code class="eh lz ma mb lq b">115792089237316195423570985008687907853269984665640564039457584007913129639935</code>增加</em>(这是你能通过的最大uint256实度——2^256–1):</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff mx"><img src="../Images/2a45b361b13498dace5d3d34016ca8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iE_aj1jWpGD6ntH4-4APOQ.png"/></div></div></figure><p id="95cc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">结果不正确！</p><p id="231f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在我们知道我们的智能合约有一个缺陷，容易受到攻击。那怎么办呢？不要担心，我们使用ZeppelinOS，所以我们可以通过几个简单的步骤升级我们的代码。</p><h1 id="793e" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">升级合同</h1><p id="822f" class="pw-post-body-paragraph ji jj ht jk b jl li iu jn jo lj ix jq jr lk jt ju jv ll jx jy jz lm kb kc kd hm dt translated">怎么才能修好？我们应该在所有算术运算的智能契约中使用SafeMath库。</p><p id="017b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们将使用OpenZeppelin合同:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="e7a3" class="lu kr ht lq b fv lv lw l lx ly">import "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol";</span></pre><p id="6240" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要使用它，我们必须将EVM包链接到我们的项目:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="1bf1" class="lu kr ht lq b fv lv lw l lx ly">oz link @openzeppelin/contracts-ethereum-package</span></pre><p id="0edd" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">请注意，我们通常导入<code class="eh lz ma mb lq b">openzeppelin/contracts-ethereum-package</code>而不是<code class="eh lz ma mb lq b">openzeppelin-solidity</code>。有什么区别？<code class="eh lz ma mb lq b">contracts-ethereum-package</code>是EVM包的库，它们已经被部署到区块链(你可以在本文的<a class="ae lo" href="https://blog.openzeppelin.com/open-source-collaboration-in-the-blockchain-era-evm-packages/" rel="noopener ugc nofollow" target="_blank">中阅读更多关于<code class="eh lz ma mb lq b">contracts-ethereum-package</code>和<code class="eh lz ma mb lq b">openzeppelin-solidity</code>的区别)。</a></p><p id="c16b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们的<code class="eh lz ma mb lq b">project.json</code>文件被更新并包含一个具有依赖关系的新对象:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="194e" class="lu kr ht lq b fv lv lw l lx ly">"dependencies": {<br/>  "@openzeppelin/contracts-ethereum-package": "^2.2.0"<br/>},</span></pre><p id="cbca" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在我们必须更新我们的<code class="eh lz ma mb lq b">HelloOz</code>智能合同的代码。我们需要更改SafeMath函数的加减字符。</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="6850" class="lu kr ht lq b fv lv lw l lx ly">function decrement(uint256 x) public returns (uint256) {     <br/>  return dec = x.sub(1);<br/>}<br/>function increment(uint256 x) public returns (uint256) {<br/>  return inc = x.add(1);   <br/>}</span></pre><p id="c19b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们还必须在状态变量下添加下面的语句:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="f924" class="lu kr ht lq b fv lv lw l lx ly">using SafeMath for uint256;</span></pre><p id="e466" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们的代码全更新了<code class="eh lz ma mb lq b">HelloOz</code> <em class="ln"> : </em></p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="86ac" class="lu kr ht lq b fv lv lw l lx ly">pragma solidity ^0.5.0;<br/>import "@openzeppelin/upgrades/contracts/Initializable.sol";<br/>import "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol";</span><span id="d3f7" class="lu kr ht lq b fv mq lw l lx ly">contract HelloOz is Initializable {<br/>    string public name;<br/>    uint256 public dec;<br/>    uint256 public inc;</span><span id="88bd" class="lu kr ht lq b fv mq lw l lx ly">    using SafeMath for uint256;</span><span id="f8f9" class="lu kr ht lq b fv mq lw l lx ly">    function initialize(string memory _name) initializer public {<br/>        name = _name;<br/>    }</span><span id="86b1" class="lu kr ht lq b fv mq lw l lx ly">function decrement(uint256 x) public returns (uint256) {<br/>        return dec = x.sub(1);<br/>    }</span><span id="888b" class="lu kr ht lq b fv mq lw l lx ly">function increment(uint256 x) public returns (uint256) {<br/>        return dec = x.add(1);<br/>    }<br/>}</span></pre><p id="1d87" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">重要！</strong></p><p id="6f56" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">升级智能合同时，我们<strong class="jk hu">无法</strong>:</p><p id="3c00" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">-改变现有变量的类型，</p><p id="a1df" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">-更改变量声明的顺序，</p><p id="fabb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">-删除现有变量，</p><p id="7810" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">-在现有变量之前引入一个新变量。</p><p id="e00c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你可以在ZeppelinOS文档中阅读更多关于升级模式的信息。</p><p id="cb32" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们可以使用以下命令更新我们的项目:</p><pre class="kf kg kh ki fq lp lq lr ls aw lt dt"><span id="c188" class="lu kr ht lq b fv lv lw l lx ly">oz upgrade</span></pre><p id="6f61" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在，我们可以用<code class="eh lz ma mb lq b">openzeppelin send-tx</code> ( <em class="ln">用0递减</em>，用<code class="eh lz ma mb lq b">115792089237316195423570985008687907853269984665640564039457584007913129639935</code>递增)再次测试我们的智能合约</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff mw"><img src="../Images/ef7772de00a66c038d7614e5d24ddd89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ix4uFbh3HeCE4z5dAW7okQ.png"/></div></div></figure><p id="cf21" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">两个交易都恢复了！</p><p id="3bb9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">多亏了OpenZeppelin SDK，我们已经更新了智能合约的代码，并防止了溢出/下溢攻击！</strong></p><p id="356e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果您有任何问题，请随时发表评论。</p><blockquote class="my"><p id="6ca1" class="mz na ht bd nb nc nd ne nf ng nh kd ek translated"><a class="ae lo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nj nk nl nm nn kj fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ni"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>