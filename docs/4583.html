<html>
<head>
<title>Starting with Polkadot Development (Part II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Polkadot开发开始(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/starting-with-polkadot-development-part-ii-53c36be5556c?source=collection_archive---------3-----------------------#2021-05-17">https://medium.com/coinmonks/starting-with-polkadot-development-part-ii-53c36be5556c?source=collection_archive---------3-----------------------#2021-05-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/913b84befc1a373e18b82086d2c694ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dm80D3wlWOk3CiufgySbsQ.jpeg"/></div></div></figure><div class=""/><p id="5d10" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在本教程的<a class="ae jz" rel="noopener" href="/coinmonks/starting-with-polkadot-development-92bba9c993ec">前一部分</a>中，我们学习了如何使用Docker在我们的本地环境中设置一个开发节点。我们还启动了Polkadot.js开源UI项目，并与这个节点连接，允许我们在不广播到整个网络的情况下进行交易。现在我们要通过阅读代码来学习。</p><h1 id="3362" class="ka kb ie bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">创建Node.js项目并连接</h1><p id="b14e" class="pw-post-body-paragraph jb jc ie jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">以开发模式启动我们的节点给了我们几个用点填充的账户(Polkadot的货币)。我们可以(也将会)使用它们，但是一般来说，创建一个帐户对于任何开发工作都是至关重要的，所以我们最好了解一下它是如何完成的。我们的任务是通读Polkadot.js项目的代码，并在Node.js上实现它。但是由于这个项目的代码库是高度优化的，可读性较差，我们将首先使用Node直接跳到一个工作示例。进入一个新文件夹，然后:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="b87a" class="lm kb ie li b fv ln lo l lp lq">npm init --yes # easy way to create Node.js project</span></pre><p id="d410" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这将创建一个<strong class="jd if"> package.json </strong>文件，而不会问我们太多问题。默认情况下，它期望一个<strong class="jd if"> index.js </strong>文件作为应用程序的入口点，所以让我们将它添加到我们的项目中。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="cadd" class="lm kb ie li b fv ln lo l lp lq">touch index.js</span></pre><p id="dc87" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我们将简单地运行它</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="c7e9" class="lm kb ie li b fv ln lo l lp lq">node index.js</span></pre><p id="77ef" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后我们需要安装<a class="ae jz" href="https://www.npmjs.com/package/@polkadot/api" rel="noopener ugc nofollow" target="_blank">波尔卡多特模块</a>，我们将通过它与网络进行通信。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="90cc" class="lm kb ie li b fv ln lo l lp lq">npm i <strong class="li if">@polkadot/api</strong> --save</span></pre><p id="ef03" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我们的<strong class="jd if"> index.js </strong>文件中，我们现在可以用两种模式初始化客户端，HTTP和WS (Web Sockets)。还记得在本教程的第一部分<a class="ae jz" rel="noopener" href="/coinmonks/starting-with-polkadot-development-92bba9c993ec">中，我们是如何启动我们的服务器w <code class="eh lr ls lt li b"><strong class="jd if">--ws-external</strong></code>的吗？这意味着启用WS连接，我们不打算使用它。</a></p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="8f33" class="lm kb ie li b fv ln lo l lp lq">// index.js<br/><strong class="li if"><em class="lu">const</em></strong> { ApiPromise, WsProvider } = require('@polkadot/api');<br/><br/><strong class="li if"><em class="lu">const</em></strong> connect = <strong class="li if">async</strong> () =&gt; {<br/>    <strong class="li if"><em class="lu">const</em></strong> wsProvider = <strong class="li if">new</strong> WsProvider('ws://127.0.0.1:9944');<br/>    <strong class="li if"><em class="lu">const</em></strong> api = new ApiPromise({ provider: wsProvider });<br/>    <strong class="li if">return</strong> api.isReady;<br/>};<br/><br/>connect().then((api) =&gt; {<br/>    <strong class="li if"><em class="lu">console</em></strong>.log(`Our client is connected: ${api.isConnected}`);<br/>}).catch((err) =&gt; {<br/>    <strong class="li if"><em class="lu">console</em></strong>.error(err)<br/>}).finally(() =&gt; <strong class="li if"><em class="lu">process</em></strong>.exit());</span></pre><p id="603a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们通过WSProvide初始化客户端，另一种方法是使用<a class="ae jz" href="https://learn.figment.io/network-documentation/polkadot/tutorials/intro-pathway-polkadot-basics/2.-create-a-polkadot-account" rel="noopener ugc nofollow" target="_blank"> HttpProvider </a>。<code class="eh lr ls lt li b"><strong class="jd if">api.isReady</strong></code>返回一个在客户端实例中解析的承诺，然后我们可以用它来检查上面的连接是否为<strong class="jd if">真</strong>。</p><h1 id="1955" class="ka kb ie bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">创建帐户</h1><p id="ae90" class="pw-post-body-paragraph jb jc ie jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">接下来，我们需要创建一个这样的帐户。首先，我们初始化一个<strong class="jd if">钥匙圈</strong>，你可以把它想象成一个内部商店，保存一个构成账户的<strong class="jd if">密钥对</strong>。更具体地说，尽管我们正在大大简化，但账户是由<strong class="jd if">公共</strong>和<strong class="jd if">私有</strong>密钥组成的。一个地址，比如初始化时通过<code class="eh lr ls lt li b"><strong class="jd if">--alice</strong></code>标志免费生成的地址，本质上是一个公钥的散列，而私钥是签署交易的东西，必须保密。密钥环是一种很好的方法，可以防止私钥暴露给代码的其余部分，同时保持签署事务的能力。将此添加到我们的文件中</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="2ed4" class="lm kb ie li b fv ln lo l lp lq"><strong class="li if"><em class="lu">const</em></strong> { mnemonicGenerate } = require('@polkadot/util-crypto');<br/><strong class="li if"><em class="lu">const</em></strong> { Keyring } = require('@polkadot/keyring');</span><span id="55b1" class="lm kb ie li b fv lv lo l lp lq"><strong class="li if"><em class="lu">const</em></strong> keyring = <strong class="li if">new</strong> Keyring({type: 'sr25519'});<br/><strong class="li if"><em class="lu">const</em></strong> mnemonic = mnemonicGenerate();<br/><strong class="li if"><em class="lu">const</em></strong> account = keyring.addFromMnemonic(mnemonic);</span><span id="fb0a" class="lm kb ie li b fv lv lo l lp lq"><strong class="li if">console</strong>.log(`Address: ${account.address}`);<br/><strong class="li if">console</strong>.log(`Mnemonic: "${mnemonic}"`);</span></pre><p id="550f" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">私钥/公钥对通常是通过一种算法创建的，该算法采用一个称为种子的输入值。这里的见解是，算法是确定性的，这意味着在没有输入的情况下，它每次运行时都会生成相同的密钥，这不是我们现在所期望的<strong class="jd if">了，是吗？种子区分了这个算法的初始变量，因此它通常是随机的。这就是<code class="eh lr ls lt li b"><strong class="jd if">mnemonicGenerate()</strong></code>所做的，它创造了一个随机的种子。然而，它返回的值不是一个数字，而是一个单词列表。这种方法最初由比特币提出，后来被大多数加密货币采用。你看到的单词本质上是字典中的一个偏移量。连接偏移，你得到种子。顾名思义，这是一种更简单的方式来存储初始化秘密，即使是在你自己的大脑中！</strong></p><p id="fa68" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你可能会问，为什么要保存它？请记住如何将密钥派生算法描述为确定性的。这意味着，如果您使用相同的助记符生成一个密钥对，您就会得到相同的密钥，这是不可或缺的。让我们也加入这个功能。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="fe50" class="lm kb ie li b fv ln lo l lp lq"><strong class="li if"><em class="lu">const</em></strong> { mnemonicValidate } = require('@polkadot/util-crypto');</span><span id="f3fe" class="lm kb ie li b fv lv lo l lp lq"><strong class="li if"><em class="lu">const</em></strong> createAccount = (mnemonic) =&gt; {<br/>    mnemonic = mnemonic &amp;&amp; mnemonicValidate(mnemonic) <br/>        ? mnemonic <br/>        : mnemonicGenerate();<br/>    <strong class="li if"><em class="lu">const</em></strong> account = keyring.addFromMnemonic(mnemonic);<br/>    <strong class="li if">return</strong> { account, mnemonic };<br/>}</span></pre><p id="0af1" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这里，我们可以选择传递一个现有的助记符，并使用它来生成我们的键。从<code class="eh lr ls lt li b"><strong class="jd if">.addFromMnemonic(...)</strong></code>函数返回的对象是一种叫做<code class="eh lr ls lt li b"><strong class="jd if">KeyringPair</strong></code>的特殊类型。如果我们在<strong class="jd if"> Typescript </strong>中编程，我们会得到一个显式类型，但是因为我们没有，我们不能在我们的代码中看到它，而且它还在那里。这个对象有一个<strong class="jd if">地址</strong>字段，它将地址保存为一个字符串，所以让我们检查一下我们所做的是否有效。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="56a5" class="lm kb ie li b fv ln lo l lp lq"><strong class="li if"><em class="lu">const</em></strong> { account: <strong class="li if">acc1</strong>, <strong class="li if">mnemonic</strong> } = createAccount();<br/><strong class="li if"><em class="lu">const</em></strong> { account: <strong class="li if">acc2</strong> } = createAccount(mnemonic);<br/><br/><strong class="li if">console</strong>.log(`Mnemonic: "${<strong class="li if">mnemonic</strong>}"`);<br/><strong class="li if">console</strong>.log(`- Address 1: ${<strong class="li if">acc1</strong>.address}`);<br/><strong class="li if">console</strong>.log(`- Address 2: ${<strong class="li if">acc2</strong>.address}`);</span></pre><p id="8713" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我的例子中，输出是这样的:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="94cc" class="lm kb ie li b fv ln lo l lp lq">Mnemonic: "cruel leader remember night skill clump question focus nurse neck battle federal"<br/>- Address 1: <strong class="li if">5HW9P7pCSMK3wUYy5gxcC6MZaJVUwNriY9z5EAQjSrqfRjLw</strong><br/>- Address 2: <strong class="li if">5HW9P7pCSMK3wUYy5gxcC6MZaJVUwNriY9z5EAQjSrqfRjLw</strong></span></pre><p id="60d4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">地址是相同的，因为我们重复使用了相同的助记符。但是这些地址(或者更确切地说，地址)“在网络上吗？”</p><p id="1f9a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以从本教程的第一部分开始刷新我们的Polkadot.js UI，但是我们看不到我们新创建的地址。它在哪里？我们需要向网络广播吗？简而言之，答案是否定的。除了交易中的参考，地址实际上并不存在。只要有一些包含地址的交易，它对网络是可见的，并且可以用各种工具查询，否则，它还不如不存在。</p><p id="106e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们就这么做吧。复制打印在您的终端上的助记短语，并转到本地运行的Polkadot UI，按“添加帐户”并将其粘贴到下面的框中:</p><figure class="ld le lf lg fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lw"><img src="../Images/647dec22808c5ac936af4e88dfafd72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qm_9V-ujQKJRC2TPQ6NDgA.png"/></div></div></figure><p id="864d" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">勾选<strong class="jd if">“我已经安全保存了我的助记种子”</strong>，点击<strong class="jd if">下一步。</strong>“添加一个名字，姑且称之为<strong class="jd if">“MEDIUM _ 1”，</strong>和一个密码。您应该在列表的底部看到您在Node.js应用程序上创建的地址。这仍然不能使该地址在网络上以某种方式“公开”，但是我们可以将资金从我们在本地启动这个Polkadot节点时为我们创建的其他帐户之一转移到该地址中。</p><figure class="ld le lf lg fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lw"><img src="../Images/afe70acda98bb575329a9a541d0e3b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J7SLF0-7YWdPfB8SQI2Z-A.png"/></div></div></figure><p id="edd0" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下拉列表中找到账户，设置金额，然后点击转账。因为帐户<strong class="jd if"> ALICE </strong>是自动创建的，所以没有设置密码。</p><figure class="ld le lf lg fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lw"><img src="../Images/95aca3b341c2ebcaf28b935ade9fe01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2c6Xd9jnnwOnjfo-rB8wRQ.png"/></div></div></figure><p id="6ebf" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您可能已经注意到，在您选择从<strong class="jd if"> ALICE </strong>发送的资金数量进入新账户之前，会有一段延迟。这是因为要完成一个事务，需要在一个新的块中“挖掘”它。在加密领域，<a class="ae jz" href="http://investopedia.com/tech/how-does-bitcoin-mining-work" rel="noopener ugc nofollow" target="_blank">挖掘</a>是将新块添加到区块链的过程，该过程包括在Polkadot网络上传播的所有最新事务。根据你所在的网络，一个新块的时间将会继续，但是如果你已经按照我在本教程第一部分中展示的方式<a class="ae jz" rel="noopener" href="/coinmonks/starting-with-polkadot-development-92bba9c993ec">设置了你的Polkadot节点，这个时间间隔应该是<strong class="jd if">6</strong>18】秒。你可以通过导航到<strong class="jd if">网络&gt;浏览器</strong>选项卡并检查左上方的计时器来查看生成的块。</a></p><figure class="ld le lf lg fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lw"><img src="../Images/2ce68ee1bdd7717b2f1959b929cc1281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HE_xD6ncCiyRHxFY3f9a1A.png"/></div></div></figure><h1 id="bc6a" class="ka kb ie bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">从网络上读取我们的余额</h1><p id="6efb" class="pw-post-body-paragraph jb jc ie jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">我们实际上如何检查这些资金？由于地址是确定的，只要我们保存了助记符，我们就可以随心所欲地重新创建它们。转移资金的实际交易没有保存在任何本地应用程序中，而是保存在区块链本身上，这本身是不可改变的。因此，我们实际需要的是使用我们刚刚粘贴到UI中的助记符重新创建地址，并调用API上的函数来获取资金。</p><p id="db96" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Node.js应用程序的完整代码如下所示:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="85ae" class="lm kb ie li b fv ln lo l lp lq"><strong class="li if"><em class="lu">const</em></strong> balance = await api.derive.balances?.all(account);<br/><strong class="li if"><em class="lu">const</em></strong> available = balance.availableBalance;</span></pre><p id="15fc" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">注意<code class="eh lr ls lt li b"><strong class="jd if">availableBalance</strong></code>如何返回<strong class="jd if">而不是</strong>一个数字，而是一个对象。该对象是一个“大数字”，这意味着通过将数值表示为字节数组来提高数值存储的准确性。为了得到一个可读的值，我们称之为<code class="eh lr ls lt li b"><strong class="jd if">.toNumber()</strong></code> <strong class="jd if"> </strong>。</p><p id="ac46" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">但是，在此之前，我们需要了解这笔金额是以何种货币计价的。Polkadot币<a class="ae jz" href="https://wiki.polkadot.network/docs/en/learn-DOT" rel="noopener ugc nofollow" target="_blank">被称为<strong class="jd if">点</strong> </a>，但就像比特币一样，金额通常以更小的分数表示，这使得它们在浮点运算可能有损失的软件层上易于管理。由于Polkadot在某种程度上是“网络不可知的”，因为它是一个“网络的网络”，我们需要直接从我们连接的网络中获得这个分数，并用它来划分我们的数量。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="b3ad" class="lm kb ie li b fv ln lo l lp lq"><strong class="li if"><em class="lu">const</em></strong> dots = available / (10 ** api.registry.chainDecimals);</span></pre><p id="6d5a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Node.js应用程序的完整代码如下所示:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="a880" class="lm kb ie li b fv ln lo l lp lq">// index.js</span><span id="f2bf" class="lm kb ie li b fv lv lo l lp lq"><strong class="li if"><em class="lu">const</em></strong> { <br/>    mnemonicGenerate, <br/>    mnemonicValidate <br/>} = require('@polkadot/util-crypto');</span><span id="3baa" class="lm kb ie li b fv lv lo l lp lq"><strong class="li if"><em class="lu">const</em></strong> { <br/>    ApiPromise, <br/>    WsProvider <br/>} = require('@polkadot/api');</span><span id="0f64" class="lm kb ie li b fv lv lo l lp lq"><strong class="li if"><em class="lu">const</em></strong> { <br/>    Keyring <br/>} = require('@polkadot/keyring');</span><span id="3e76" class="lm kb ie li b fv lv lo l lp lq"><strong class="li if"><em class="lu">const</em></strong> keyring = <strong class="li if">new</strong> <strong class="li if">Keyring</strong>({type: 'sr25519'});</span><span id="8cfe" class="lm kb ie li b fv lv lo l lp lq"><strong class="li if"><em class="lu">const</em></strong> connect = <strong class="li if">async</strong> () =&gt; {<br/>    <strong class="li if">const</strong> wsProvider = new WsProvider('ws://127.0.0.1:9944');<br/>    <strong class="li if">const</strong> api = new ApiPromise({ provider: wsProvider });<br/>    <strong class="li if">return</strong> api.isReady;<br/>};<br/><br/><strong class="li if"><em class="lu">const</em></strong> createAccount = (mnemonic) =&gt; {<br/>    mnemonic = mnemonic &amp;&amp; mnemonicValidate(mnemonic) <br/>         ? mnemonic <br/>         : mnemonicGenerate();<br/>    const account = keyring.addFromMnemonic(mnemonic);<br/>    return { account, mnemonic };<br/>}</span><span id="18fc" class="lm kb ie li b fv lv lo l lp lq"><strong class="li if"><em class="lu">const</em></strong> main = <strong class="li if">async</strong> (api) =&gt; {<br/>    <strong class="li if">console</strong>.log(`Our client is connected: ${api.isConnected}`);<br/><br/>    <strong class="li if"><em class="lu">const</em></strong> mnemonic = 'cruel leader remember night skill clump question focus nurse neck battle federal';</span><span id="eee6" class="lm kb ie li b fv lv lo l lp lq"><strong class="li if">    <em class="lu">const</em></strong> { account: <strong class="li if">medium1</strong> } = createAccount(mnemonic);</span><span id="51fa" class="lm kb ie li b fv lv lo l lp lq"><strong class="li if">    <em class="lu">const</em></strong> balance = <strong class="li if">await</strong> api.derive.balances.all(medium1.address);<br/>    <strong class="li if"><em class="lu">const</em></strong> available = balance.availableBalance.<strong class="li if">toNumber()</strong>;<br/>    <strong class="li if"><em class="lu">const</em></strong> dots = available / (<strong class="li if">10</strong> ** api.registry.<strong class="li if">chainDecimals</strong>);<br/>    <strong class="li if"><em class="lu">const</em></strong> print = dots.toFixed(<strong class="li if">4</strong>);</span><span id="483d" class="lm kb ie li b fv lv lo l lp lq"><strong class="li if"><em class="lu">    </em>console</strong>.log(`Address ${medium1.address} has ${print} DOT`);<br/>};</span><span id="b8b0" class="lm kb ie li b fv lv lo l lp lq"><strong class="li if">connect()</strong>.then(main).catch((err) =&gt; {<br/>    <strong class="li if"><em class="lu">console</em></strong>.error(err)<br/>}).finally(() =&gt; <strong class="li if"><em class="lu">process</em></strong>.exit());</span></pre><blockquote class="lx ly lz"><p id="d32a" class="jb jc lu jd b je jf jg jh ji jj jk jl ma jn jo jp mb jr js jt mc jv jw jx jy hm dt translated">注意:建议使用<strong class="jd if">而不是</strong>处理普通的JS数值，就像我们在这里做的那样，而是使用<strong class="jd if"> BN </strong>(大数值)实例。我们将在下一个教程中这样做。</p></blockquote><p id="78c6" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">完成交易</p><p id="9827" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你可能已经注意到了</p><p id="2c77" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们在本教程的第3部分中看看如何以编程方式完成所有这些。</p></div></div>    
</body>
</html>