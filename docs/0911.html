<html>
<head>
<title>SPAM DETECTOR USING NAIVE BAYES</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用朴素贝叶斯的垃圾邮件检测器</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/spam-detector-using-naive-bayes-c22cc740e257?source=collection_archive---------3-----------------------#2018-06-30">https://medium.com/coinmonks/spam-detector-using-naive-bayes-c22cc740e257?source=collection_archive---------3-----------------------#2018-06-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/0221c322502344ef04613094dada3457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iPZhb4Tlz_nxDZKTEOxFw.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">photo is completely irrelevant to the post!!!</figcaption></figure><h2 id="86aa" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated">感应</h2><p id="5ec7" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn jq ko kp kq ju kr ks kt jy ku kv kw kx hm dt translated">在这篇文章中，我将实现<strong class="kf hu"> <em class="ky">朴素贝叶斯</em> </strong>算法来检测垃圾短信。如果你对<strong class="kf hu"> <em class="ky">朴素贝叶斯</em> </strong>算法不熟悉，我推荐你去访问<a class="ae kz" rel="noopener" href="/@jindeshubham/naive-bayes-theorem-d8854a41ea08"> <strong class="kf hu"> <em class="ky">这个</em></strong></a><strong class="kf hu"><em class="ky"/></strong>我曾经讲解过算法的地方。我们将建立模型，该模型将把<a class="ae kz" href="https://archive.ics.uci.edu/ml/datasets/SMS+Spam+Collection" rel="noopener ugc nofollow" target="_blank"> <strong class="kf hu"> <em class="ky">数据集</em></strong></a><strong class="kf hu"><em class="ky"/></strong>SMS消息分类为垃圾消息或非垃圾消息。对于垃圾短信可能是什么样子有一定程度的直觉是很重要的。通常它们会有“免费”、“赢”、“赢家”、“现金”、“奖品”之类的词，因为这些文字旨在吸引你的眼球，并在某种程度上诱使你打开它们。此外，垃圾邮件往往有全大写的单词，也往往使用许多感叹号</p><h2 id="a453" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated"><strong class="ak">步骤1.1:了解我们的数据集</strong></h2><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff la"><img src="../Images/115412675b580307d7841c724dc8510a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wh6ccAdr8I3GwdbeHaikmg.png"/></div></div></figure><p id="f2eb" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">数据集中的列目前还没有命名，如您所见，有2列。</p><p id="19f7" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">第一列有两个值，“ham”表示该邮件不是垃圾邮件，“spam”表示该邮件是垃圾邮件。</p><p id="6a9c" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">第二列是正在分类的SMS消息的文本内容。</p><h2 id="f5a7" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated">步骤1.2:数据预处理</h2><p id="9748" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn jq ko kp kq ju kr ks kt jy ku kv kw kx hm dt translated">现在，我们对数据集有了基本的了解，让我们将标签转换为二进制变量，0表示“ham”(即不是垃圾邮件)，1表示“spam”，以便于计算。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lk"><img src="../Images/50f26d3fe4c0fd7e9681d2ed038a18b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gTIIJzvyJOVxwEszeXylGw.png"/></div></div></figure><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ll"><img src="../Images/cdec34ba6da7ce79a9408ce145c41cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URhHla3XVutmRFqzF29yPA.png"/></div></div></figure><h2 id="158c" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated">步骤2.1:单词袋</h2><p id="84e6" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn jq ko kp kq ju kr ks kt jy ku kv kw kx hm dt translated">我们的数据集中有大量的文本数据(5，572行数据)。大多数ML算法依赖于数字数据作为输入，而电子邮件/sms消息通常是大量的文本。</p><p id="2399" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">在这里，我们要介绍单词包(BoW)概念，这个术语用于指定需要处理的具有“单词包”或文本数据集合的问题。BoW的基本思想是获取一段文本，并计算该文本中单词的频率。值得注意的是，BoW概念单独处理每个单词，单词出现的顺序无关紧要。</p><p id="4117" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">我们的目标是将这组文本转换为频率分布矩阵，如下所示:</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lm"><img src="../Images/0e793c0a6df8f39680103ad4057dfec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g9I-ONkuvjfARs9TpNEdbQ.png"/></div></div></figure><p id="ca5e" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">这里我们可以看到，文档按行编号，每个单词是一个列名，对应的值是该单词在文档中的出现频率。</p><p id="11fa" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">让我们分解一下，看看我们如何使用一小组文档来完成这种转换。</p><p id="1a1e" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">为了解决这个问题，我们将使用sklearns <a class="ae kz" href="http://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html#sklearn.feature_extraction.text.CountVectorizer" rel="noopener ugc nofollow" target="_blank">计数矢量器</a>方法，该方法执行以下操作:</p><h1 id="e0e5" class="ln jg ht bd jh lo lp lq jl lr ls lt jp lu lv lw jt lx ly lz jx ma mb mc kb md dt translated">步骤2.3:在scikit-learn中实现单词包</h1><p id="2cfd" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn jq ko kp kq ju kr ks kt jy ku kv kw kx hm dt translated">既然我们已经从零开始实现了BoW概念，那么让我们继续使用scikit——学习以干净简洁的方式完成这个过程。我们将使用与上一步相同的文档集。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff me"><img src="../Images/750bacfd05154ba3cabcdbe177599107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xx9fgeoqnOAI7UfjG1oqQ.png"/></div></div></figure><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mf"><img src="../Images/72ac4196761dc3bec63992b931a32c6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fpMy5Ub6DEIiYWWe_Y-ivg.png"/></div></div></figure><p id="4a01" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">CountVectorizer会将所有文本转换成<strong class="kf hu"> <em class="ky">小写，</em> </strong>会删除所有<strong class="kf hu"> <em class="ky">标点符号</em> </strong>和所有<strong class="kf hu"> <em class="ky">停用词</em> </strong>。</p><pre class="lb lc ld le fq mg mh mi mj aw mk dt"><span id="2971" class="jf jg ht mh b fv ml mm l mn mo">CountVectorizer(analyzer='word', binary=False, decode_error='strict',<br/>        dtype=&lt;class 'numpy.int64'&gt;, encoding='utf-8', input='content',<br/>        lowercase=True, max_df=1.0, max_features=None, min_df=1,<br/>        ngram_range=(1, 1), preprocessor=None, stop_words=None,<br/>        strip_accents=None, token_pattern='(?u)\\b\\w\\w+\\b',<br/>        tokenizer=None, vocabulary=None)</span></pre><p id="3b8a" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">在文档上应用计数矢量器。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mp"><img src="../Images/69089e79c0305fde1fd46cae0db0bc01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UMdf4sDsKM9F_RX0_Bizsw.png"/></div></div></figure><p id="3bd4" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">现在我们需要将文档表示为单词的频率。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mq"><img src="../Images/1f12636816d71fe205b4a20d49f4e3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*39MIYv_FAuVpejEK72vH2w.png"/></div></div></figure><p id="7bf8" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">现在，我们有了一个清晰的文档表示，即文档中单词的频率分布。为了更容易理解，我们的下一步是将这个数组转换成dataframe，并适当地命名这些列。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mr"><img src="../Images/209b66b30950da4e6e857e8279b8d8d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUtPSKxtXR6yTJ-KNOkV5g.png"/></div></div></figure><h2 id="bf8f" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated">步骤3.1:训练和测试集</h2><p id="7d04" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn jq ko kp kq ju kr ks kt jy ku kv kw kx hm dt translated">现在我们已经了解了如何处理单词袋问题，我们可以回到我们的数据集，继续我们的分析。在这方面，我们的第一步是将数据集分成训练集和测试集，以便稍后测试我们的模型。</p><p id="53e2" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">我们将从<strong class="kf hu"><em class="ky">sk learn . cross _ validation</em></strong>模块中使用<strong class="kf hu"><em class="ky">train _ test _ split</em></strong>。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ms"><img src="../Images/4a4b184ede5bc4e7852fdc3fc53a57c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6zjFYSTlV2wS7g64BDKRQ.png"/></div></div></figure><h2 id="6d46" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated">步骤3.2:将单词包处理应用到我们的数据集。</h2><p id="a297" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn jq ko kp kq ju kr ks kt jy ku kv kw kx hm dt translated">现在我们已经分割了数据，我们的下一个目标是遵循步骤2:单词包中的步骤，并将我们的数据转换为所需的矩阵格式。为此，我们将像以前一样使用CountVectorizer()。这里需要考虑两个步骤:</p><ul class=""><li id="7332" class="mt mu ht kf b kg lf kk lg jq mv ju mw jy mx kx my mz na nb dt translated">首先，我们必须将我们的训练数据(<code class="eh nc nd ne mh b">X_train</code>)放入<code class="eh nc nd ne mh b">CountVectorizer()</code>并返回矩阵。</li><li id="4c6f" class="mt mu ht kf b kg nf kk ng jq nh ju ni jy nj kx my mz na nb dt translated">其次，我们必须转换我们的测试数据(<code class="eh nc nd ne mh b">X_test</code>)来返回矩阵。</li></ul><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nk"><img src="../Images/79adffbb2a58f3b0d382947dc1965c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lqhUHY4Ka_ar0czPK0H68w.png"/></div></div></figure><h2 id="1514" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated">步骤4:使用scikit-learn实现朴素贝叶斯</h2><p id="35c7" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn jq ko kp kq ju kr ks kt jy ku kv kw kx hm dt translated">我们将使用sklearns <code class="eh nc nd ne mh b">sklearn.naive_bayes</code>方法对我们的数据集进行预测。</p><p id="ab58" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated">具体来说，我们将使用多项式朴素贝叶斯实现。这个特定的分类器适合于具有离散特征的分类(例如在我们的例子中，文本分类的字数)。它接受整数字数作为输入。另一方面，高斯朴素贝叶斯更适合连续数据，因为它假设输入数据具有高斯(正态)分布。你可以在这里找到不同的朴素贝叶斯变种<a class="ae kz" href="http://scikit-learn.org/stable/modules/naive_bayes.html" rel="noopener ugc nofollow" target="_blank"><strong class="kf hu"><em class="ky"/></strong></a>。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nl"><img src="../Images/a9740695119cb9a7576ab9fce5c13321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E0pK6IMjSDvqkejAoqq5Jg.png"/></div></div></figure><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nm"><img src="../Images/77799b4722c8d3d7f58a706700e52437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3P0US6VDzhnYiEHGZqJHDQ.png"/></div></div></figure><h2 id="d49a" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated">步骤5:评估我们的模型</h2><p id="2e01" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn jq ko kp kq ju kr ks kt jy ku kv kw kx hm dt translated">既然我们已经对测试集进行了预测，我们的下一个目标是评估我们的模型做得有多好。有各种各样的机制可以做到这一点，但首先让我们快速回顾一下。</p><p id="f3dc" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated"><strong class="kf hu">准确性</strong>衡量分类器做出正确预测的频率。它是正确预测的数量与预测总数(测试数据点的数量)的比率。</p><p id="dedf" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated"><strong class="kf hu"> Precision </strong>告诉我们被我们归类为垃圾邮件的邮件中，实际上有多少是垃圾邮件。它是真阳性(分类为垃圾邮件的单词，实际上是垃圾邮件)与所有阳性(分类为垃圾邮件的所有单词，无论分类是否正确)的比率，换句话说，它是</p><p id="fb3e" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated"><code class="eh nc nd ne mh b">[True Positives/(True Positives + False Positives)]</code></p><p id="23c3" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated"><strong class="kf hu"> Recall(sensitivity) </strong>告诉我们实际上是垃圾邮件的邮件中有多少被我们归类为垃圾邮件。它是真阳性(分类为垃圾邮件的单词，实际上是垃圾邮件的单词)与所有实际上是垃圾邮件的单词的比率，换句话说，它是</p><p id="c84d" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn jq lh kp kq ju li ks kt jy lj kv kw kx hm dt translated"><code class="eh nc nd ne mh b">[True Positives/(True Positives + False Negatives)]</code></p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nn"><img src="../Images/80b62d8b4003fa612766ff554ec07e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3NfK5J0zSrb5_XUmt83vHw.png"/></div></div></figure><h2 id="0310" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated"><strong class="ak">结论</strong></h2><p id="5106" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn jq ko kp kq ju kr ks kt jy ku kv kw kx hm dt translated">与其他分类算法相比，朴素贝叶斯的一个主要优势是它能够处理大量的特征。在我们的例子中，每个单词都被视为一个特征，有成千上万个不同的单词。此外，即使存在不相关的特征，它也能很好地执行，并且相对不受它们的影响。它的另一个主要优点是相对简单。“朴素贝叶斯”开箱即用，很少需要调整它的参数，除非通常在数据分布已知的情况下。它很少过拟合数据。另一个重要的优势是，对于它可以处理的数据量来说，它的模型训练和预测时间非常快。总而言之，朴素贝叶斯真的是算法中的瑰宝！</p></div></div>    
</body>
</html>