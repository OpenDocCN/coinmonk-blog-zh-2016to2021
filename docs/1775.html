<html>
<head>
<title>Time and clocks and ordering of events in a distributed system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式系统中的时间、时钟和事件排序</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/time-and-clocks-and-ordering-of-events-in-a-distributed-system-cdd3f6075e73?source=collection_archive---------0-----------------------#2018-11-13">https://medium.com/coinmonks/time-and-clocks-and-ordering-of-events-in-a-distributed-system-cdd3f6075e73?source=collection_archive---------0-----------------------#2018-11-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="5db8" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">介绍</h2></div><p id="e0d8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在这篇文章中，我们将讨论分布式系统中时间的概念。我们在日常生活中很大程度上依赖时间来点菜。一件事“发生在”另一件事之前，是一种由时间编码的关系，使用物理时钟作为传递时间的机制。所以事件的排序是通过现实世界中的物理时钟来完成的。在分布式系统中，需要更仔细地理解时间的概念。在不依赖可能不准确的物理时钟的情况下，核心问题变成了我们如何定义节点集合系统中事件的顺序。每个节点可以建立自己的本地事件顺序。但是如何在多个节点上建立事件的一致顺序呢？这种顺序对于解决分布式锁定这样的问题非常重要，分布式锁定是一种共享资源，一次只能由一个节点使用，只要另一个节点没有请求锁定，请求锁定资源的节点就需要被授予锁定。在这种情况下，局部顺序是不够的，需要跨多个节点建立一些全局顺序。</p><h2 id="ad3a" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">分布式系统中事件的部分排序</h2><p id="0e13" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">在分布式系统中定义事件顺序的一种方法是使用物理时钟。所以“之前发生的”事件可以用系统中的t1 &lt; t2. But clocks are not accurate, can drift and are not necessarily synchronized in lock-step. So this paper takes another approach to define “happened before” relation. (The meaning of “partial order” will become clear later. )</p><p id="3b60" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">A distributed system can be defined as a collection of processes. A process essentially consists of a queue of events(which can be anything — like an instruction, or a subprogram, or anything meaningful) and has apriori order. In this system, when processes communicate with each other, sending of a message is defined as an event. Let’s establish a more precise definition of “happens before” (⇢) in such a system.</p><ol class=""><li id="064d" class="lf lg ht jk b jl jm jo jp jr lh jv li jz lj kd lk ll lm ln dt translated">In the same process, if event a comes before event b, then a ⇢ b</li><li id="6006" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">When process i sends some message at a to process j and process j acknowledges this message at b, then a ⇢ b</li><li id="f79d" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">Happens before is transitive. a ⇢ b and b ⇢ c, then a ⇢ c.</li><li id="6938" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">Two events a and b are described as concurrent when a hasn’t happened before b and b hasn’t happened before a. This condition generally reflects the fact that process i may not have knowledge about all events that could have happened in process j. So we cannot establish authoritative order in the system — this also makes it clear that we have only a <strong class="jk hu"> <em class="lt">偏序</em> </strong>来描述。如果不依靠物理时间，系统中可能会有许多事件无法建立有意义的顺序。</li></ol><p id="80d4" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">举一些例子可能是有用的。</p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="fe ff lu"><img src="../Images/441a1b1fe29d126b114d72d456671e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jfRoG8tHMbnTErbQCN0tA.png"/></div></div><figcaption class="mg mh fg fe ff mi mj bd b be z ek">Partial ordering of events in the system. Vertical bars are processes. Wavy arrows are messages. A dot is an event. Time elapses bottom up.</figcaption></figure><p id="71b5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">正如你在左上图中看到的，p1和⇢ p2是同一个过程中的事件。由于从过程q向过程p发送消息，q1 ⇢ p2。如果我们考虑时间自下而上流逝，并且如果我们考虑物理时间，q3似乎发生在p3之前。但是在这个系统中，我们将这些事件称为并发事件。两个进程都不知道这些事件—此时没有因果关系。但是我们可以说的是，q3 ⇢ p4，因为q3⇢q5和q5 ⇢ p4。类似地，我们可以说p1 ⇢ r3。现在已经看了一些例子，很明显，设想⇢ b的另一种方式是事件a可以因果地影响事件b。类似地，上面提到的q3和p3没有因果关系。</p><h2 id="5241" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">逻辑时钟</h2><p id="8587" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">Lamport的论文引入了一个新的函数，本质上是一个计数器，在每一个可以给事件分配一个数字的进程中。让我们称这个函数为Ci(a ),作为事件a的进程I中的计数器。系统中没有物理时钟。函数C(a)建立了不变量，即事件a必定发生在b之前，那么C(a) &lt; C(b)。使用此功能，可以利用以下两个条件建立系统中事件的部分排序:</p><p id="8460" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">C1: Ci(a) &lt; Ci(b)如果在同一个进程I中a发生在b之前，这可以在给定的进程中使用一个简单的计数器来实现。</p><p id="7e13" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">C2:当进程I在事件a发送消息，而进程j在事件b确认消息时，那么Ci(a) &lt; Cj(b)</p><p id="e83a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这些时钟功能可以被认为是在一个进程中定期发生的滴答。在任何两个事件之间，至少需要有一个这样的分笔成交点。每个分笔成交点实际上增加了分配给前一个分笔成交点的数字。这在上图的右侧进行了说明。相似编号的刻度跨越流程边界连接。在相同的过程中，触摸或穿过分笔成交点边界以停留在下一个事件上。跨流程发送消息时，该消息需要跨越或接触一个刻度线边界，以定义“发生在之前”事件。</p><p id="8db0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这可以通过以下方式实现:</p><p id="1cd6" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">IR1:这个服从C1。这可以通过在系统中任意两个连续事件之间增加Ci(a)来实现。</p><p id="257d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">IR2:这是一个实现C2。这可以通过将Ci(a)作为时间戳发送给进程j来完成。当进程j在事件b确认收到该消息时，它需要设置Cj(b)。Cj(b)将被设置为≥当前Cj且大于Ci(a)/时间戳的值。</p><h2 id="39ff" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">系统中事件的总排序</h2><p id="845b" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">到目前为止，逻辑时钟系统已经建立了系统中事件的部分顺序。仍然有并发的事件，打破束缚是有用的，特别是对于引言中描述的锁定问题——有人需要获得锁。这可以通过引入任意的进程优先级来实现。如果出现平局，优先级较低的进程将获得之前发生的事件。更正式地说，一个⇥ b的总序a(注意新型箭头)可以定义为:</p><ol class=""><li id="1de7" class="lf lg ht jk b jl jm jo jp jr lh jv li jz lj kd lk ll lm ln dt translated">Ci(a) &lt; Cj(b).</li><li id="6cfa" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">If Ci(a) = Cj(b), then use Pi &lt; Pj.</li></ol><p id="63c7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">These two conditions imply that ⇥ completes the partial relationship ⇢. If two events are partially ordered then they are totally ordered already. While partial ordering is unique in the given system of events, total ordering may not be.</p><h2 id="d725" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">Distributed locks using total ordering</h2><p id="cbe3" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">Consider the following problem which can be quite common in distributed systems. The central idea of the problem is to access a shared resource, but only one process can access it at any time. More formal conditions can be specified as:</p><ol class=""><li id="f95d" class="lf lg ht jk b jl jm jo jp jr lh jv li jz lj kd lk ll lm ln dt translated">A process which has been granted a resource, must release it before any other process can acquire it.</li><li id="fc22" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">Resource access requests should obey the order in which requests are made</li><li id="42ae" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">If every process releases the resource it asked for, then eventually access is granted for that resource.</li></ol><p id="a4a6" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">One possible solution could be to introduce a centralized scheduler. While one issue is that it is a completely centralized, another is that ordering condition 2 may not work. Consider the scenario: Process i asking for a resource to the scheduler. Then it informs process j about the request. Process j now asks for the same resource, but its message reaches the scheduler before process i’s. This means that event order was not obeyed. To address this issue, we can use total ordering based off of IR1 and IR2. With this, every event is totally ordered in the system. As long as all the processes know about requests made by other processes, the correct ordering can be enforced. A decentralized solution can be designed such that each process keeps a queue of lock and unlock operations.</p><ol class=""><li id="0cf9" class="lf lg ht jk b jl jm jo jp jr lh jv li jz lj kd lk ll lm ln dt translated">Process i asking for a resource lock, uses the current timestamp and puts lock(T,Pi) in the queue. It also sends this message to all other processes.</li><li id="6320" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">All other processes put this message in their queue and send the response back with a new timestamp Tn.</li><li id="55d2" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">To unlock a resource, process i, sends unlock(T, Pi) message to all processes and removes the lock(T, Pi) message from its own queue.</li><li id="253d" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">Process Pj, upon getting unlock message, removes lock(T, Pi) message from its queue.</li><li id="5edd" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">Process Pi is free to use the resource i.e. gets its lock request granted when: it has the lock(T, Pi) messages in its queue with T enforcing the<strong class="jk hu"> <em class="lt">总顺序</em> </strong>使得T在队列中的任何其他消息之前。此外，进程Pi需要等待，直到它从系统中时间戳晚于t的所有进程接收到消息。</li></ol><h2 id="5778" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">结论</h2><p id="cc3b" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">在分布式系统中，时间/事件顺序的概念相当复杂。在分布式系统中，确保因果排序的逻辑时钟的想法是非常有用的，而不必依赖于物理时钟。Lamport的逻辑时钟确保如果a ⇢ b那么，C(a) &lt; C(b). It is also good to understand that if C(a) &lt; C(b) then it doesn’t necessarily mean that a ⇢ b. If we just looked at C(j) and C(k) and C(j) happened to be less than C(k), then those could be concurrent events and processes may not have communicated with each other yet. This later property, of just looking at some timestamps and realizing the causality, is achieved by <a class="ae ke" href="https://en.wikipedia.org/wiki/Vector_clock" rel="noopener ugc nofollow" target="_blank">向量时钟</a>。</p><blockquote class="mk"><p id="0284" class="ml mm ht bd mn mo mp mq mr ms mt kd ek translated">加入Coinmonks <a class="ae ke" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ke" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae ke" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="kf kg ht bd kh ki mu kk kl km mv ko kp jr mw kr ks jv mx ku kv jz my kx ky kz dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="lf lg ht jk b jl la jo lb jr mz jv na jz nb kd nc ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd nc ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae ke" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="a245" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd nc ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/top-3-telegram-channels-for-crypto-traders-in-2021-8385f4411ff4">密码电报信号</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="874f" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd nc ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/buy-bitcoin-in-india-feb50ddfef94">购买比特币印度</a> | <a class="ae ke" rel="noopener" href="/coinmonks/pionex-review-exchange-with-crypto-trading-bot-1e459d0191ea"> Pionex评论</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="957b" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd nc ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度的加密交易所</a> | <a class="ae ke" rel="noopener" href="/coinmonks/bitcoin-savings-account-e65b13f92451">比特币储蓄账户</a></li><li id="fce2" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd nc ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/cloudbet-casino-review" rel="noopener ugc nofollow" target="_blank"> Cloudbet赌场评论</a> | <a class="ae ke" href="https://coincodecap.com/ignition-casino-review" rel="noopener ugc nofollow" target="_blank">点火赌场评论</a></li><li id="a2b9" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd nc ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/binance-fees-8588ec17965">币安费用</a> | <a class="ae ke" rel="noopener" href="/coinmonks/botcrypto-review-2021-build-your-own-trading-bot-coincodecap-6b8332d736c7"> Botcrypto审查</a> | <a class="ae ke" rel="noopener" href="/coinmonks/hotbit-review-cd5bec41dafb"> Hotbit审查</a></li><li id="0df7" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd nc ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/myconstant-review" rel="noopener ugc nofollow" target="_blank"> MyConstant Review </a> | <a class="ae ke" href="https://coincodecap.com/best-swing-trading-bots" rel="noopener ugc nofollow" target="_blank"> 8款最佳摇摆交易机器人</a></li><li id="f33b" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd nc ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae ke" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd nc ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">开发人员的最佳加密API</a></li><li id="b359" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd nc ll lm ln dt translated">最佳<a class="ae ke" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd nc ll lm ln dt translated">杠杆代币的终极指南</li></ul></div></div>    
</body>
</html>