<html>
<head>
<title>A short story about over-fitting your neural network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个关于过度拟合你的神经网络的小故事</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/machine-learning-essentials-a-short-story-about-over-fitting-your-network-or-the-importance-of-c4229957410d?source=collection_archive---------11-----------------------#2018-06-26">https://medium.com/coinmonks/machine-learning-essentials-a-short-story-about-over-fitting-your-network-or-the-importance-of-c4229957410d?source=collection_archive---------11-----------------------#2018-06-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="0d24" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">一个关于过度拟合你的神经网络的小故事(或者Keras上验证数据的重要性)</h2></div><p id="46eb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt ke translated">这是一个简短的故事，讲述了添加一个验证分区的重要性，该分区将在每个时期进行评估，而不是等到训练结束后才测量训练模型在预测训练阶段从未见过的实例方面有多好，或者换句话说，概括问题。</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div class="fe ff kn"><img src="../Images/118ce67af15f352b34a0bb92a5ed36ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*HFiwHoMb34JB3q9tjoIEzw.png"/></div></figure><h1 id="cb98" class="kv kw ht bd kx ky kz la lb lc ld le lf iz lg ja lh jc li jd lj jf lk jg ll lm dt translated">部分灵感来自真实事件</h1><p id="5b1b" class="pw-post-body-paragraph ji jj ht jk b jl ln iu jn jo lo ix jq jr lp jt ju jv lq jx jy jz lr kb kc kd hm dt translated">让我们假设你正在Keras上使用递归神经网络开发一个文本分类器。一个二元问题，其中一个句子被逐字输入网络，预期输出是一个单值，预测该句子是“<strong class="jk hu">正</strong>还是“<strong class="jk hu">负</strong>”(无论在你的上下文中是什么意思)。是的，是的，就像我在之前的故事中详述的<a class="ae ls" rel="noopener" href="/@monocasero/text-classifier-with-keras-tensorflow-using-recurrent-neural-networks-ad63dd5fc316">😉：</a></p><p id="3a9c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了训练分类器，你不用像Keras 提供的那样使用预先准备好的数据集<a class="ae ls" href="https://keras.io/datasets/" rel="noopener ugc nofollow" target="_blank">。您已经创建了自己的集合，仔细准备了训练示例及其标签。</a></p><p id="5cda" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">此时您可能不知道，或者您不打算将验证数据发送到<a class="ae ls" href="https://keras.io/models/sequential/" rel="noopener ugc nofollow" target="_blank"> Keras fit函数</a>，但是您确实打算在训练结束时分割数据集进行评估(假设90%训练，10%评估)。为此目的<strong class="jk hu">你选择创建自己的函数来混洗和分割数据集</strong>，而不是使用一个已经可用的函数<a class="ae ls" href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank">(如sklearn的train_test_split </a>)。</p><blockquote class="lt"><p id="2848" class="lu lv ht bd lw lx ly lz ma mb mc kd ek translated"><strong class="ak"> <em class="md">然而，你在不知不觉中犯了一个错误！不是一起混洗训练集(X)和它们的标签(Y ),而是独立地混洗它们，因此你把所有的标签(Y)都混在一起了。</em>T19】</strong></p></blockquote><p id="059c" class="pw-post-body-paragraph ji jj ht jk b jl me iu jn jo mf ix jq jr mg jt ju jv mh jx jy jz mi kb kc kd hm dt translated">你把标签弄乱了！但既然你还不知道，你就开始训练吧。因为句子的真实性质和它的标签之间没有真正的关系，所以训练会一塌糊涂，对吗？对吗？</p><p id="0b3e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">与我们预期的相反，乍一看，它并不像是一片混乱:</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="fe ff mj"><img src="../Images/af547f8226d00f7954ebc71db2cfc77e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIE8m5w9aUoVpGg7vwHVeg.png"/></div></div></figure><p id="3a1a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如你所见，10个时期和超过1小时的训练已经过去，损失(损失:0.3721)正在减少，并且训练集上的准确度已经稳定地增加到80% (acc: 0.8067)！发生了什么事？</p><p id="9299" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">使用一个相当复杂的网络架构，特别是没有正则化(像在这种情况下)，<strong class="jk hu">训练将能够适应调整到例子的细节以及它们的噪声</strong>。在这种情况下，由于标签是混淆的，训练集主要是随机噪声，不知何故，网络仍然能够“学习”这种噪声的细节。</p><h1 id="fcbe" class="kv kw ht bd kx ky kz la lb lc ld le lf iz lg ja lh jc li jd lj jf lk jg ll lm dt translated">那你应该怎么做？</h1><p id="6c18" class="pw-post-body-paragraph ji jj ht jk b jl ln iu jn jo lo ix jq jr lp jt ju jv lq jx jy jz lr kb kc kd hm dt translated">如果您已经开始了相同的训练，向fit(或fit_generator)函数发送验证数据，则每个时期您都会看到<strong class="jk hu">验证集(val_acc，最后一列)上的精度根本没有增加</strong>，而且损失(val_loss:)在增加(在时期10结束时从0.6935增加到1.4955):</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="fe ff mo"><img src="../Images/7cdde94ccfc3055c4431e10575c73c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVGwA8gZRbJytc9zoDIanQ.png"/></div></div></figure><blockquote class="lt"><p id="f023" class="lu lv ht bd lw lx mp mq mr ms mt kd ek translated">毫不奇怪，对于训练过程中从未见过的例子，分类器不比抛硬币好。</p></blockquote><p id="f3c4" class="pw-post-body-paragraph ji jj ht jk b jl me iu jn jo mf ix jq jr mg jt ju jv mh jx jy jz mi kb kc kd hm dt translated">如果您发送验证数据，您将能够在少量时间后检测到这种问题，而不是等到培训结束时才发现有问题。</p><h1 id="f08c" class="kv kw ht bd kx ky kz la lb lc ld le lf iz lg ja lh jc li jd lj jf lk jg ll lm dt translated">怎么做？</h1><p id="dfe7" class="pw-post-body-paragraph ji jj ht jk b jl ln iu jn jo lo ix jq jr lp jt ju jv lq jx jy jz lr kb kc kd hm dt translated">这很简单，如果你使用的是<a class="ae ls" href="https://keras.io/models/model/" rel="noopener ugc nofollow" target="_blank"><strong class="jk hu">model . fit</strong></a><strong class="jk hu"/>(没有数据生成器)有一个参数可以从训练集中自动拆分:</p><ul class=""><li id="0fd2" class="mu mv ht jk b jl jm jo jp jr mw jv mx jz my kd mz na nb nc dt translated"><strong class="jk hu"> validation_split </strong>:在0和1之间浮动。用作验证数据的训练数据部分。该模型将把这部分训练数据分开，不在其上训练，并且将在每个时期结束时评估该数据的损失和任何模型度量。在洗牌之前，从提供的<code class="eh nd ne nf ng b">x</code>和<code class="eh nd ne nf ng b">y</code>数据的最后样本中选择验证数据。</li></ul><p id="9a30" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">另一方面，使用<strong class="jk hu"> model.fit_generator </strong>，您将需要发送带有以下参数的验证数据或数据生成器:</p><ul class=""><li id="9e9d" class="mu mv ht jk b jl jm jo jp jr mw jv mx jz my kd mz na nb nc dt translated"><strong class="jk hu"> validation_data </strong>:可以是</li></ul><ol class=""><li id="e4c5" class="mu mv ht jk b jl jm jo jp jr mw jv mx jz my kd nh na nb nc dt translated">验证数据的生成器或<code class="eh nd ne nf ng b">Sequence</code>对象</li><li id="8cdb" class="mu mv ht jk b jl ni jo nj jr nk jv nl jz nm kd nh na nb nc dt translated">元组<code class="eh nd ne nf ng b">(x_val, y_val)</code></li><li id="045d" class="mu mv ht jk b jl ni jo nj jr nk jv nl jz nm kd nh na nb nc dt translated">元组<code class="eh nd ne nf ng b">(x_val, y_val, val_sample_weights)</code></li></ol><p id="d79a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在每个时期结束时在其上评估损失和任何模型度量。该模型不会根据此数据进行训练。</p><ul class=""><li id="0081" class="mu mv ht jk b jl jm jo jp jr mw jv mx jz my kd mz na nb nc dt translated"><strong class="jk hu">验证_步骤</strong>:仅当<code class="eh nd ne nf ng b">validation_data</code>为发电机时相关。在每个时期结束时停止之前，从<code class="eh nd ne nf ng b">validation_data</code>发生器产生的总步骤数(样品批次)。它通常应等于认证数据集的样本数除以批次大小。<code class="eh nd ne nf ng b">Sequence</code>可选:如果未指定，将使用<code class="eh nd ne nf ng b">len(validation_data)</code>作为步数。</li></ul><h1 id="6fc2" class="kv kw ht bd kx ky kz la lb lc ld le lf iz lg ja lh jc li jd lj jf lk jg ll lm dt translated">更多信息:</h1><ul class=""><li id="ec9e" class="mu mv ht jk b jl ln jo lo jr nn jv no jz np kd mz na nb nc dt translated"><a class="ae ls" href="https://keras.io/models/sequential/" rel="noopener ugc nofollow" target="_blank">https://keras.io/models/sequential/</a></li><li id="87ac" class="mu mv ht jk b jl ni jo nj jr nk jv nl jz nm kd mz na nb nc dt translated"><a class="ae ls" href="https://machinelearningmastery.com/overfitting-and-underfitting-with-machine-learning-algorithms/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/over fitting-and-under fitting-with-machine-learning-algorithms/</a></li><li id="ecb4" class="mu mv ht jk b jl ni jo nj jr nk jv nl jz nm kd mz na nb nc dt translated"><a class="ae ls" href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank">http://sci kit-learn . org/stable/modules/generated/sk learn . model _ selection . train _ test _ split . html</a></li><li id="f352" class="mu mv ht jk b jl ni jo nj jr nk jv nl jz nm kd mz na nb nc dt translated"><a class="ae ls" href="https://stanford.edu/~shervine/blog/keras-how-to-generate-data-on-the-fly.html" rel="noopener ugc nofollow" target="_blank">https://Stanford . edu/~ sher vine/blog/keras-how-to-generate-data-on-the-fly . html</a></li></ul></div></div>    
</body>
</html>