<html>
<head>
<title>Build a smart contract that transfers ERC20 token from your wallet to other ERC20 compliant wallet- Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个智能合约，将您的电子钱包中的ERC20令牌转移到其他ERC20兼容电子钱包-第1部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/build-a-smart-contract-that-transfers-erc20-token-from-your-wallet-to-other-addresses-or-erc20-ee8dc35f40f6?source=collection_archive---------0-----------------------#2018-07-31">https://medium.com/coinmonks/build-a-smart-contract-that-transfers-erc20-token-from-your-wallet-to-other-addresses-or-erc20-ee8dc35f40f6?source=collection_archive---------0-----------------------#2018-07-31</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/40e2de927ad67f12fd9caed7ce737670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*uByMsj92sG_u-IOl.gif"/></div></figure><h2 id="295f" class="ix iy ht bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju dt translated">概观</h2><p id="bea2" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp hm dt translated">在本教程中，您将构建一个智能合约，用于将ERC20令牌转移到任何ERC20兼容的钱包，包括元掩码和交换地址。本教程中显示的方法是forkdelta等分散式交换所使用的方法的简化版本。在第一部分中，我们将编写和测试智能契约，在下一篇文章中，我们将使用Reactjs构建UI。</p><blockquote class="kq"><p id="f0df" class="kr ks ht bd kt ku kv kw kx ky kz kp ek translated"><a class="ae la" href="https://coincodecap.com/category/wallets" rel="noopener ugc nofollow" target="_blank">发现并回顾最佳加密钱包</a></p></blockquote><h2 id="23e2" class="ix iy ht bd iz ja lb jc jd je lc jg jh ji ld jk jl jm le jo jp jq lf js jt ju dt translated">我会学到什么？</h2><p id="a005" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp hm dt translated">您将学习如何编写和测试一个智能契约，该契约可以将令牌从您的钱包转移到其他ERC20兼容地址。</p><ul class=""><li id="ffd1" class="lg lh ht jx b jy li kc lj ji lk jm ll jq lm kp ln lo lp lq dt translated">分散式交易所存取特征机制如何工作</li><li id="3274" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated">如何在solidity中编写智能合同来转移ERC20令牌</li><li id="e43e" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated">测试您的智能合约并通过truffle控制台与之交互</li></ul><h2 id="1c9a" class="ix iy ht bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju dt translated">要求</h2><p id="75b8" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp hm dt translated">本教程对Dapps初学者并不友好，所以建议你先了解一下ERC20令牌的工作原理，并具备编写solidity代码的基本知识。</p><p id="338c" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">出于本教程的目的，需要在您的系统上安装以下软件。</p><ul class=""><li id="9586" class="lg lh ht jx b jy li kc lj ji lk jm ll jq lm kp ln lo lp lq dt translated">Trufflesuite <a class="ae la" href="https://github.com/trufflesuite/truffle" rel="noopener ugc nofollow" target="_blank">安装指南在此</a></li><li id="45c2" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated">Ganache <a class="ae la" href="https://github.com/trufflesuite/ganache/releases" rel="noopener ugc nofollow" target="_blank">私人区块链服务器</a></li><li id="3a1f" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated">为chrome、firefox、opera安装Metamask <a class="ae la" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"/></li></ul><p id="300c" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">本教程假设您使用的是<em class="lz"> UNIX操作系统</em></p><h2 id="76ff" class="ix iy ht bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju dt translated">写我们的合同</h2><figure class="mb mc md me fq iu fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/997cc3a39682d7aa6ed0111fcdf8e9d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/0*CZWVBw7MOdLL99bw.png"/></div></figure><p id="a54f" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">此图说明了该流程的工作步骤。</p><ul class=""><li id="c961" class="lg lh ht jx b jy li kc lj ji lk jm ll jq lm kp ln lo lp lq dt translated">首先，向以太网发布一个ERC20令牌</li><li id="a6b8" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated">令牌被分配一个约定地址并具有一个ABI</li><li id="d2a3" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated">持有令牌的地址批准代表其消费的合同</li><li id="9b28" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated">然后，合同将令牌发送到接收地址</li></ul><p id="b5c8" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">够清楚了！！</p><h2 id="daa3" class="ix iy ht bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju dt translated">说够了，让我们开始编码</h2><p id="5a4b" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp hm dt translated">到目前为止，我假设您已经安装了所有的需求，所以启动<em class="lz"> Ganache </em>然后导航到您的工作目录并创建一个文件夹，将其命名为<em class="lz"> TokenZendR </em>。从您的终端导航到<em class="lz"> TokenZendR </em>目录，并运行命令<code class="eh mf mg mh mi b">truffle init</code>，您现在应该看到类似如下的输出。</p><figure class="mb mc md me fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="fe ff mj"><img src="../Images/6bb4d539ef60645bca2557375c5ca9a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vct1jkNcaV1pG4uR.png"/></div></div></figure><p id="f34c" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">在任何你喜欢的编辑器中打开项目目录，我更喜欢在激活solidity插件的情况下使用PhpStorm(我很喜欢这个编辑器)。在根目录下创建一个<em class="lz"> package.json </em>文件，并将以下内容粘贴到其中。</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="aba3" class="ix iy ht mi b fv ms mt l mu mv">{  <br/>  "dependencies": {  <br/>  "babel-register": "^6.23.0",  <br/>  "babel-polyfill": "^6.26.0",  <br/>  "babel-preset-es2015": "^6.18.0"  <br/>  },  <br/>  "devDependencies": {  <br/>  "openzeppelin-solidity": "^1.10.0",  <br/>  "chai": "^4.1.2",  <br/>  "chai-as-promised": "^7.1.1",  <br/>  "chai-bignumber": "^2.0.2"  <br/>  }  <br/>}</span></pre><p id="457f" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">接下来打开truffle.js项目，用以下内容替换它</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="2882" class="ix iy ht mi b fv ms mt l mu mv">require('babel-register');  <br/>require('babel-polyfill');  <br/>  <br/>module.exports = {  <br/>  networks: {  <br/>  development: {  <br/>  host: "127.0.0.1",  <br/>  port: 7545,  <br/>  network_id: "*" // Match any network id  <br/>  }  <br/> }};</span></pre><p id="742c" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">从项目根目录下的控制台运行<code class="eh mf mg mh mi b">npm install</code>来安装package.json中指定的所有包。</p><p id="3c8b" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">到现在为止，您可能想知道为什么您的<em class="lz"> package.json </em>中需要依赖项。在编写我们的测试时，我们需要<em class="lz"> babel </em>和<em class="lz"> chai </em>，并且我们将需要扩展<em class="lz">ERC 20</em>open zeppelin-solidity框架的令牌契约接口。</p><p id="9fb6" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">不，我们需要为本教程创建两个<em class="lz"> ERC20 </em>令牌智能合约，并将它们部署在我们的私有区块链(<em class="lz"> Ganache </em>)上，这样我们就可以使用它们来测试我们的令牌发送者合约，因为我们无法访问我们网络(<em class="lz"> 5777 </em>)外部已经部署的令牌，例如<em class="lz"> testnet </em>、mainnet</p><p id="51ee" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">在联系人文件夹中创建两个文件BearToken.sol和CubToken.sol，并将以下内容粘贴到其中。</p><p id="43df" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated"><code class="eh mf mg mh mi b">BearToken.sol</code></p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="9f2a" class="ix iy ht mi b fv ms mt l mu mv">pragma solidity ^0.4.19;  <br/>  <br/>import "openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol";  <br/>import "openzeppelin-solidity/contracts/ownership/Ownable.sol";  <br/>  <br/>/**  <br/>* @title BearToken is a basic ERC20 Token  <br/>*/  <br/>contract BearToken is StandardToken, Ownable{  <br/>  <br/>  uint256 public totalSupply;  <br/>  string public name;  <br/>  string public symbol;  <br/>  uint32 public decimals;  <br/>  <br/>  /**  <br/> * @dev assign totalSupply to account creating this contract */  constructor() public {  <br/>  symbol = "BEAR";  <br/>  name = "BearToken";  <br/>  decimals = 5;  <br/>  totalSupply = 100000000000;  <br/>  <br/>  owner = msg.sender;  <br/>  balances[msg.sender] = totalSupply;  <br/>  <br/>  emit Transfer(0x0, msg.sender, totalSupply);  <br/> }}</span></pre><p id="fbf6" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">这只是一个ERC20 token BearToken，符号为<em class="lz"> BEAR </em>，总供应量为1000亿，总供应量分配给契约的创建者。它扩展了<em class="lz"> StandardToken </em>和<em class="lz"> Ownable </em>契约。</p><p id="c8f0" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated"><code class="eh mf mg mh mi b">Cub.sol</code></p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="3517" class="ix iy ht mi b fv ms mt l mu mv">pragma solidity ^0.4.19;  <br/>  <br/>import "openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol";  <br/>import "openzeppelin-solidity/contracts/ownership/Ownable.sol";  <br/>  <br/>/**  <br/>* @title BearToken is a basic ERC20 Token  <br/>*/  <br/>contract CubToken is StandardToken, Ownable{  <br/>  <br/>  uint256 public totalSupply;  <br/>  string public name;  <br/>  string public symbol;  <br/>  uint32 public decimals;  <br/>  <br/> /**  <br/> * @dev assign totalSupply to account creating this contract <br/> */  <br/> constructor() public {  <br/>  symbol = "CUB";  <br/>  name = "CubToken";  <br/>  decimals = 5;  <br/>  totalSupply = 100000000000;  <br/>  <br/>  owner = msg.sender;  <br/>  balances[msg.sender] = totalSupply;  <br/>  <br/>  emit Transfer(0x0, msg.sender, totalSupply);  <br/> }}</span></pre><p id="bbb5" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">这只是一个ERC20 token CubToken，符号为<em class="lz"> CUB </em>，总供应量为1000亿，总供应量分配给合同的创建者。它扩展了<em class="lz"> StandardToken </em>和<em class="lz"> Ownable </em>契约。</p><p id="e243" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">让我们为这两个合同添加迁移。按以下顺序运行以下命令。</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="6975" class="ix iy ht mi b fv ms mt l mu mv">truffle console</span><span id="7f70" class="ix iy ht mi b fv mw mt l mu mv">truffle(development)&gt; create migration bear_token_migration </span><span id="fef4" class="ix iy ht mi b fv mw mt l mu mv">truffle(development)&gt; create migration cub_token_migration</span></pre><p id="c8b7" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">上面的命令将为我们的两个合同创建两个迁移文件，格式为<em class="lz">{ timestamp } _ bear _ token _ migration . js</em>和<em class="lz">{ timestamp } _ cub _ token _ migration . js</em>。接下来用这个替换两个文件的内容。</p><p id="3804" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated"><code class="eh mf mg mh mi b">*{timestamp}_bear_token_migration.js*</code></p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="c2f1" class="ix iy ht mi b fv ms mt l mu mv">let BearToken = artifacts.require("./BearToken.sol");  <br/>  <br/>module.exports = function(deployer) {  <br/>  deployer.deploy(BearToken);  <br/>};</span></pre><p id="1991" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated"><code class="eh mf mg mh mi b">*{timestamp}_cub_token_migration.js*</code></p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="edd1" class="ix iy ht mi b fv ms mt l mu mv">let CubToken = artifacts.require("./CubToken.sol");  <br/>  <br/>module.exports = function(deployer) {  <br/>  deployer.deploy(CubToken);  <br/>};</span></pre><p id="eb31" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">现在我们已经有了那个集合，继续编译和迁移您的契约。</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="d69f" class="ix iy ht mi b fv ms mt l mu mv">truffle(development)&gt; compile</span><span id="066e" class="ix iy ht mi b fv mw mt l mu mv">truffle(development)&gt; migrate</span></pre><figure class="mb mc md me fq iu fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/84911f3a317dc24985cde52f2ce000be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/0*a2tDpMnY__X1gUtG.png"/></div></figure><p id="b8ec" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">上图显示两个合同都已经编译并部署在网络上，你的项目目录现在应该有一个包含<em class="lz"> json </em>文件的<code class="eh mf mg mh mi b">build</code>文件夹，仔细查看其中一个文件，你会发现它包含合同的<em class="lz"> abi </em>和编译成字节码的it代码以及其他一些信息。</p><p id="4ff2" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">在我们开始为两个契约编写测试之前，让我们从控制台开始研究契约。当你在编写测试和修复bug(如果需要的话)之前与你的合同进行交互时，它会给你更多的信心。在控制台上记录两个合同的合同地址很重要</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="78da" class="ix iy ht mi b fv ms mt l mu mv">BearToken: 0xeec918d74c746167564401103096d45bbd494b74<br/>CubToken: 0xecfcab0a285d3380e488a39b4bb21e777f8a4eac</span></pre><p id="6fc8" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">让我们简单地检查<em class="lz"> BearToken </em>的名称、符号和总供应量，并记录合同创建者的余额，记住在我们的合同中，我们将总供应量记入合同创建者账户。</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="38f9" class="ix iy ht mi b fv ms mt l mu mv">truffle(development)&gt; Bear = BearToken.at("0xeec918d74c746167564401103096d45bbd494b74")</span><span id="0844" class="ix iy ht mi b fv mw mt l mu mv">truffle(development)&gt; Bear.name()</span><span id="8555" class="ix iy ht mi b fv mw mt l mu mv">truffle(development)&gt; Bear.totalSupply()</span><span id="62e9" class="ix iy ht mi b fv mw mt l mu mv">truffle(development)&gt; Bear.balanceOf(web3.eth.accounts[0])</span></pre><figure class="mb mc md me fq iu fe ff paragraph-image"><div class="fe ff my"><img src="../Images/3a2443181b5549ad6f172216645fe66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/0*_gvO-hsgJrPP6oen.png"/></div></figure><p id="359b" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">好运👌</p><p id="ea40" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">现在我们有两个<em class="lz"> ERC20 </em>令牌要测试，接下来让我们创建处理传输的<em class="lz"> TokenZendR </em>契约。</p><p id="129e" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">创建一个新合同，<em class="lz"> TokenZendR.sol </em></p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="b9f9" class="ix iy ht mi b fv ms mt l mu mv">pragma solidity ^0.4.23;  <br/>  <br/>import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";  <br/>import "openzeppelin-solidity/contracts/lifecycle/Pausable.sol";  <br/>  <br/>contract TokenZendR is Ownable, Pausable {</span><span id="dea3" class="ix iy ht mi b fv mw mt l mu mv">}</span></pre><p id="4c14" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">该契约扩展了openzeppelin库中的Ownable和Pausable契约，您将很快看到我们使用的这些契约中的方法。</p><p id="961e" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated"><em class="lz"> ERC20.sol </em>是所有<em class="lz"> ERC20 </em>兼容令牌必须实现的<em class="lz"> ERC20 </em>标准接口，详见<a class="ae la" href="https://github.com/ethereum/EIPs/issues/20" rel="noopener ugc nofollow" target="_blank">https://github.com/ethereum/EIPs/issues/20</a>。</p><p id="829e" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">接下来定义保存每次传输的数据结构，用它更新合同。</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="d868" class="ix iy ht mi b fv ms mt l mu mv">/**  <br/>* @dev Details of each transfer  <br/>* @param contract_ contract address of ER20 token to transfer  <br/>* @param to_ receiving account  <br/>* @param amount_ number of tokens to transfer to_ account  <br/>* @param failed_ if transfer was successful or not  <br/>*/  <br/>struct Transfer {  <br/>  address contract_;  <br/>  address to_;  <br/>  uint amount_;  <br/>  bool failed_;  <br/>}</span></pre><p id="4101" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">添加一个映射，保存每个用户在<em class="lz">事务</em>数组上的所有传输索引，其中每个用户地址都是一个所有事务索引数组的键。</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="3f0e" class="ix iy ht mi b fv ms mt l mu mv">/**  <br/>* @dev a mapping from transaction ID's to the sender address  <br/>* that initiates them. Owners can create several transactions  <br/>*/  <br/>mapping(address =&gt; uint[]) public transactionIndexesToSender;</span><span id="a361" class="ix iy ht mi b fv mw mt l mu mv">/**  <br/>* @dev a list of all transfers successful or unsuccessful  <br/>*/  <br/>Transfer[] public transactions;</span></pre><p id="7792" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">我们定义了一个address类型的所有者属性，它保存启动该契约的地址，而令牌将保存契约支持传输的所有<em class="lz"> ERC20 </em>令牌的地址。</p><p id="d4e8" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">值得注意的一点是这些漂亮的代码</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="4ee7" class="ix iy ht mi b fv ms mt l mu mv">ERC20 public ERC20Interface;</span></pre><p id="dbfd" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">这些实现了<em class="lz"> ERC20 </em>接口，允许我们在使用令牌契约地址时调用方法<code class="eh mf mg mh mi b">approve</code>和<code class="eh mf mg mh mi b">transferFrom</code>。这将在本教程后面的<em class="lz"> transferToken </em>方法中变得更加清晰。</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="d092" class="ix iy ht mi b fv ms mt l mu mv">address public owner;  <br/>  <br/>/**  <br/>* @dev list of all supported tokens for transfer  <br/>* @param string token symbol  <br/>* @param address contract address of token  <br/>*/  <br/>mapping(bytes32 =&gt; address) public tokens;  <br/>  <br/>ERC20 public ERC20Interface;</span></pre><p id="271a" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">传输成功或失败时发出的事件</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="6b4b" class="ix iy ht mi b fv ms mt l mu mv">/**  <br/>* @dev Event to notify if transfer successful or failed  <br/>* after account approval verified  <br/>*/  <br/>event TransferSuccessful(address indexed from_, address indexed to_, uint256 amount_);  <br/>  <br/>event TransferFailed(address indexed from_, address indexed to_, uint256 amount_);</span></pre><p id="ec5f" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">在本合同中，我们主要想做三件事，即:</p><ul class=""><li id="6f3a" class="lg lh ht jx b jy li kc lj ji lk jm ll jq lm kp ln lo lp lq dt translated">添加此合同支持的新令牌的地址</li><li id="19ca" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated">如果我们可以添加令牌，我们也希望能够删除它</li><li id="1a6e" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated">最后是转让权，这是本合同要履行的主要内容。</li></ul><p id="f06a" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">我们也许可以考虑增加一个从合同中提取资金的支付方法，以防有人觉得慈善…😉</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="9d01" class="ix iy ht mi b fv ms mt l mu mv">/**  <br/>* @dev add address of token to list of supported tokens using  <br/>* token symbol as identifier in mapping  <br/>*/  <br/>function addNewToken(bytes32 symbol_, address address_) public onlyOwner returns (bool) {  <br/>  tokens[symbol_] = address_;  <br/>  <br/>  return true;  <br/>}  <br/>  <br/>/**  <br/>* @dev remove address of token we no more support  <br/>*/  <br/>function removeToken(bytes32 symbol_) public onlyOwner returns (bool) {  <br/>  require(tokens[symbol_] != 0x0);  <br/>  <br/>  delete(tokens[symbol_]);  <br/>  <br/>  return true;  <br/>}  <br/>  <br/>/**  <br/>* @dev method that handles transfer of ERC20 tokens to other address  <br/>* it assumes the calling address has approved this contract  <br/>* as spender  <br/>* @param symbol_ identifier mapping to a token contract address  <br/>* @param to_ beneficiary address  <br/>* @param amount_ numbers of token to transfer  <br/>*/  <br/>function transferTokens(bytes32 symbol_, address to_, uint256 amount_) public whenNotPaused{  <br/>  require(tokens[symbol_] != 0x0);  <br/>  require(amount_ &gt; 0);  <br/>  <br/>  address contract_ = tokens[symbol_];  <br/>  address from_ = msg.sender;  <br/>  <br/>  ERC20Interface = ERC20(contract_);  <br/>  <br/>  uint256 transactionId = transactions.push(  <br/>  Transfer({  <br/>  contract_:  contract_,  <br/>        to_: to_,  <br/>        amount_: amount_,  <br/>        failed_: true  <br/>  })  <br/> );  <br/>  transactionIndexesToSender[from_].push(transactionId - 1);  <br/>  <br/>  if(amount_ &gt; ERC20Interface.allowance(from_, address(this))) {  <br/>  emit TransferFailed(from_, to_, amount_);  <br/>  revert();  <br/> }  <br/>  ERC20Interface.transferFrom(from_, to_, amount_);  <br/>  <br/>  transactions[transactionId - 1].failed_ = false;  <br/>  <br/>  emit TransferSuccessful(from_, to_, amount_);  <br/>}  <br/>  <br/>/**  <br/>* @dev allow contract to receive funds  <br/>*/  <br/>function() public payable {}  <br/>  <br/>/**  <br/>* @dev withdraw funds from this contract  <br/>* @param beneficiary address to receive ether  <br/>*/  <br/>function withdraw(address beneficiary) public payable onlyOwner whenNotPaused {  <br/>  beneficiary.transfer(address(this).balance);  <br/>}</span></pre><h1 id="64fe" class="mz iy ht bd iz na nb nc jd nd ne nf jh ng nh ni jl nj nk nl jp nm nn no jt np dt translated">把所有的放在一起</h1><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="b730" class="ix iy ht mi b fv ms mt l mu mv">pragma solidity ^0.4.23;  <br/>  <br/>import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";  <br/>import "openzeppelin-solidity/contracts/lifecycle/Pausable.sol";  <br/>  <br/>contract TokenZendR is Ownable, Pausable {  <br/>  <br/>  /**  <br/> * @dev Details of each transfer * @param contract_ contract address of ER20 token to transfer * @param to_ receiving account * @param amount_ number of tokens to transfer to_ account * @param failed_ if transfer was successful or not */  struct Transfer {  <br/>  address contract_;  <br/>  address to_;  <br/>  uint amount_;  <br/>  bool failed_;  <br/> }  <br/>  /**  <br/> * @dev a mapping from transaction ID's to the sender address * that initiates them. Owners can create several transactions */  mapping(address =&gt; uint[]) public transactionIndexesToSender;  <br/>  <br/>  <br/>  /**  <br/> * @dev a list of all transfers successful or unsuccessful */  Transfer[] public transactions;  <br/>  <br/>  address public owner;  <br/>  <br/>  /**  <br/> * @dev list of all supported tokens for transfer * @param string token symbol * @param address contract address of token */  mapping(bytes32 =&gt; address) public tokens;  <br/>  <br/>  ERC20 public ERC20Interface;  <br/>  <br/>  /**  <br/> * @dev Event to notify if transfer successful or failed * after account approval verified */  event TransferSuccessful(address indexed from_, address indexed to_, uint256 amount_);  <br/>  <br/>  event TransferFailed(address indexed from_, address indexed to_, uint256 amount_);  <br/>  <br/>  constructor() public {  <br/>  owner = msg.sender;  <br/> }  <br/>  /**  <br/> * @dev add address of token to list of supported tokens using * token symbol as identifier in mapping */  function addNewToken(bytes32 symbol_, address address_) public onlyOwner returns (bool) {  <br/>  tokens[symbol_] = address_;  <br/>  <br/>  return true;  <br/> }  <br/>  /**  <br/> * @dev remove address of token we no more support */  function removeToken(bytes32 symbol_) public onlyOwner returns (bool) {  <br/>  require(tokens[symbol_] != 0x0);  <br/>  <br/>  delete(tokens[symbol_]);  <br/>  <br/>  return true;  <br/> }  <br/>  /**  <br/> * @dev method that handles transfer of ERC20 tokens to other address * it assumes the calling address has approved this contract * as spender * @param symbol_ identifier mapping to a token contract address * @param to_ beneficiary address * @param amount_ numbers of token to transfer */  function transferTokens(bytes32 symbol_, address to_, uint256 amount_) public whenNotPaused{  <br/>  require(tokens[symbol_] != 0x0);  <br/>  require(amount_ &gt; 0);  <br/>  <br/>  address contract_ = tokens[symbol_];  <br/>  address from_ = msg.sender;  <br/>  <br/>  ERC20Interface = ERC20(contract_);  <br/>  <br/>  uint256 transactionId = transactions.push(  <br/>  Transfer({  <br/>  contract_:  contract_,  <br/>            to_: to_,  <br/>            amount_: amount_,  <br/>            failed_: true  <br/>  })  <br/> );  <br/>  transactionIndexesToSender[from_].push(transactionId - 1);  <br/>  <br/>  if(amount_ &gt; ERC20Interface.allowance(from_, address(this))) {  <br/>  emit TransferFailed(from_, to_, amount_);  <br/>  revert();  <br/> }  <br/>  ERC20Interface.transferFrom(from_, to_, amount_);  <br/>  <br/>  transactions[transactionId - 1].failed_ = false;  <br/>  <br/>  emit TransferSuccessful(from_, to_, amount_);  <br/> }  <br/>  /**  <br/> * @dev allow contract to receive funds */  function() public payable {}  <br/>  <br/>  /**  <br/> * @dev withdraw funds from this contract * @param beneficiary address to receive ether */  function withdraw(address beneficiary) public payable onlyOwner whenNotPaused {  <br/>  beneficiary.transfer(address(this).balance);  <br/> }}</span></pre><h1 id="ab98" class="mz iy ht bd iz na nb nc jd nd ne nf jh ng nh ni jl nj nk nl jp nm nn no jt np dt translated">编写我们的测试</h1><p id="a4b1" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp hm dt translated">如果你还在松露控制台上，运行<code class="eh mf mg mh mi b">create test</code>命令或返回命令<code class="eh mf mg mh mi b">truffle console</code>，运行如下所示的命令创建两个测试文件。</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="d235" class="ix iy ht mi b fv ms mt l mu mv">truffle(development)&gt; create test token_management</span><span id="98fa" class="ix iy ht mi b fv mw mt l mu mv">truffle(development)&gt; create test token_transfer</span></pre><p id="2987" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">如果您检查您的项目<code class="eh mf mg mh mi b">test</code>，您的两个测试文件将会用一个默认断言创建。打开<code class="eh mf mg mh mi b">token_management.js</code>文件，清除当前内容，然后导入文件开头的chai和合同。</p><p id="f015" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated"><strong class="jx hu"> PS: </strong>为了避免在运行您的第一个测试时遇到错误，也清空<em class="lz"> token_transfer.js </em>的内容。</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="ea79" class="ix iy ht mi b fv ms mt l mu mv">const TokenZendR = artifacts.require('./TokenZendR.sol');  <br/>  <br/>const should = require('chai')  <br/> .use(require('chai-as-promised'))  <br/> .should();  <br/>  <br/>let sender;  <br/>  <br/>contract('token_management', async (accounts) =&gt; {<br/>	<br/>}</span></pre><p id="863f" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">该测试将运行测试，以检查从合同中添加、更新和删除令牌是否正常工作。在运行每个测试之前，我们想添加一个缺省令牌，如果你还不习惯使用<code class="eh mf mg mh mi b">asyn/await</code>，你可能想仔细阅读一下。</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="a337" class="ix iy ht mi b fv ms mt l mu mv">beforeEach(async () =&gt; {  <br/>	  sender = await TokenZendR.new();  <br/>	  await sender.addNewToken('OPEN', '0x69c4bb240cf05d51eeab6985bab35527d04a8c64');  <br/>	});</span></pre><p id="8995" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">接下来是我们添加令牌的第一个断言</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="80ba" class="ix iy ht mi b fv ms mt l mu mv">it("should add new supported token", async() =&gt; {  <br/>  let address = await sender.tokens.call('OPEN');  <br/>  <br/>  address.should.equal('0x69c4bb240cf05d51eeab6985bab35527d04a8c64');  <br/>});</span><span id="3319" class="ix iy ht mi b fv mw mt l mu mv">truffle(development)&gt; test</span></pre><figure class="mb mc md me fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="fe ff nq"><img src="../Images/6cb2edbc4f57c16c2d8ddab1c88209fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BF8fsWHPsvmnEwqr.png"/></div></div></figure><p id="3747" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">断言它是否正确更新了令牌地址</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="b73e" class="ix iy ht mi b fv ms mt l mu mv">it("should update supported token address", async() =&gt; {  <br/>  await sender.addNewToken('OPEN', '0x3472059945ee170660a9a97892a3cf77857eba3a');  <br/>  <br/>  let address = await sender.tokens.call('OPEN');  <br/>  <br/>  address.should.equal('0x3472059945ee170660a9a97892a3cf77857eba3a');  <br/>});</span><span id="2b95" class="ix iy ht mi b fv mw mt l mu mv">truffle(development)&gt; test</span></pre><figure class="mb mc md me fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="fe ff nr"><img src="../Images/5cbece83a5aec7b00ad52e4b01ba4349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OfB8b19QBdi9SQf-.png"/></div></div></figure><p id="99a6" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">最后断言一个令牌被移除</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="fa75" class="ix iy ht mi b fv ms mt l mu mv">it("should remove unused supported token address", async() =&gt; {  <br/>  await sender.removeToken('OPEN');  <br/>  <br/>  let address = await sender.tokens.call('OPEN');  <br/>  <br/>  address.should.equal('0x0000000000000000000000000000000000000000');  <br/>});</span><span id="b20d" class="ix iy ht mi b fv mw mt l mu mv">truffle(development)&gt; test</span></pre><figure class="mb mc md me fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="fe ff nq"><img src="../Images/3263d5c1a81e736c95fe2bebe94d21ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6JLJw8a6Ccu-4tVA.png"/></div></div></figure><p id="53a7" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">把所有的放在一起</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="607a" class="ix iy ht mi b fv ms mt l mu mv">const TokenZendR = artifacts.require('./TokenZendR.sol');  <br/>  <br/>const should = require('chai')  <br/> .use(require('chai-as-promised'))  <br/> .should();  <br/>  <br/>let sender;  <br/>  <br/>contract('token_management', async (accounts) =&gt; {  <br/>	  beforeEach(async () =&gt; {  <br/>	  sender = await TokenZendR.new();  <br/>	  await sender.addNewToken('OPEN', '0x69c4bb240cf05d51eeab6985bab35527d04a8c64');  <br/>	 }); <br/>	 <br/>	  it("should add new supported token", async() =&gt; {  <br/>	  let address = await sender.tokens.call('OPEN');  <br/>	  <br/>	  address.should.equal('0x69c4bb240cf05d51eeab6985bab35527d04a8c64');  <br/>	  }); <br/>	 <br/>	  it("should update supported token address", async() =&gt; {  <br/>	  await sender.addNewToken('OPEN', '0x3472059945ee170660a9a97892a3cf77857eba3a');  <br/>	  <br/>	  let address = await sender.tokens.call('OPEN');  <br/>	  <br/>	  address.should.equal('0x3472059945ee170660a9a97892a3cf77857eba3a');  <br/>	  });  <br/>	 <br/>	  it("should remove unused supported token address", async() =&gt; {  <br/>	  await sender.removeToken('OPEN');  <br/>	  <br/>	  let address = await sender.tokens.call('OPEN');  <br/>	  <br/>	  address.should.equal('0x0000000000000000000000000000000000000000');  <br/>	 });<br/> });</span></pre><p id="005d" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">最后，让我们测试一下契约是否真的可以传递令牌，以确认一切都正常工作。导入三份合同，柴在文件最上面。</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="19cb" class="ix iy ht mi b fv ms mt l mu mv">const TokenZendR = artifacts.require('./TokenZendR.sol');  <br/>const BearToken = artifacts.require('./BearToken.sol');  <br/>const CubToken = artifacts.require('./CubToken.sol');  <br/>  <br/>const BigNumber = web3.BigNumber;  <br/>  <br/>const should = require('chai')  <br/> .use(require('chai-as-promised'))  <br/> .use(require('chai-bignumber')(BigNumber))  <br/> .should();</span></pre><p id="9be3" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">在运行每个测试之前，创建所有合同的新实例。</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="e02e" class="ix iy ht mi b fv ms mt l mu mv">const TokenZendR = artifacts.require('./TokenZendR.sol');  <br/>const BearToken = artifacts.require('./BearToken.sol');  <br/>const CubToken = artifacts.require('./CubToken.sol');  <br/>  <br/>const BigNumber = web3.BigNumber;  <br/>  <br/>const should = require('chai')  <br/> .use(require('chai-as-promised'))  <br/> .use(require('chai-bignumber')(BigNumber))  <br/> .should();  <br/>  <br/>let sender, bear, cub;  <br/>  <br/>contract('token_management', async (accounts) =&gt; {  <br/>  <br/>	 let accountA, accountB, accountC, accountD;  <br/>	  <br/>	 [accountA, accountB, accountC, accountD ] = accounts;  <br/>	  <br/>	 beforeEach(async () =&gt; {  <br/>	  sender = await TokenZendR.new();  <br/>	  bear = await BearToken.new();  <br/>	  cub = await CubToken.new();  <br/>	  <br/>	  await sender.addNewToken('BEAR', bear.address);  <br/>	  await sender.addNewToken('CUB', cub.address);  <br/>	 });<br/> }</span></pre><p id="e507" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">测试地址二的余额是否等于合同成功转让的<em class="lz">承载</em>令牌的金额。</p><pre class="mb mc md me fq mo mi mp mq aw mr dt"><span id="abf9" class="ix iy ht mi b fv ms mt l mu mv">it("should be able to transfer sender token to another wallet", async() =&gt; { <br/>  // When transfering  token, multiple by<br/>  //figure of decimal to get exact token e.g<br/>  //to send 5 BEAR = 5e5, where 5 is the decimal places <br/>  let amount = new BigNumber(500000e5);  <br/>  <br/>  //Account a approve contract to spend on behalf<br/>  await bear.approve(sender.address, amount,{from: accountA});  <br/>  <br/>  await sender.transferTokens('BEAR',accountB, amount,{from: accountA});  <br/>  <br/>  let balance = ((await bear.balanceOf(accountB)).toString());  <br/>  <br/>  balance.should.equal(amount.toString())  <br/>});</span><span id="53ba" class="ix iy ht mi b fv mw mt l mu mv">truffle(development)&gt; test</span></pre><figure class="mb mc md me fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="fe ff ns"><img src="../Images/9b32a35f5231abd45ffea724b772c6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7I_RlQhNFCszoNO8.png"/></div></div></figure><p id="1bf8" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated">本教程已经成功地向您展示了如何建立一个合同，将<em class="lz"> ERC20 </em>代币从您的地址转移到任何其他<em class="lz"> ERC20 </em>兼容的钱包甚至交易所。你可以在testnet或者main net上用现有的令牌比如<em class="lz"> GTO </em>或者<em class="lz"> TRX </em>进行测试。</p><h1 id="1b23" class="mz iy ht bd iz na nb nc jd nd ne nf jh ng nh ni jl nj nk nl jp nm nn no jt np dt translated">第二部分</h1><p id="11e8" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp hm dt translated">本教程的结论部分可以在<a class="ae la" rel="noopener" href="/coinmonks/building-ethereum-dapps-with-reactjs-truffle-contract-web3-a-ui-for-tokenzendr-a-smart-bf345478b116"> <em class="lz">这里</em> </a>中找到</p><h1 id="c33a" class="mz iy ht bd iz na nb nc jd nd ne nf jh ng nh ni jl nj nk nl jp nm nn no jt np dt translated">代码库</h1><p id="cc7d" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp hm dt translated">完整的智能合同代码可以在这里找到&amp;克隆<a class="ae la" href="https://github.com/slim12kg/tokenzendr-contract" rel="noopener ugc nofollow" target="_blank">https://github.com/slim12kg/tokenzendr-contract</a></p><p id="8cce" class="pw-post-body-paragraph jv jw ht jx b jy li ka kb kc lj ke kf ji lw kh ki jm lx kk kl jq ly kn ko kp hm dt translated"><strong class="jx hu">想要学习使用节点API构建Defi储蓄智能合约，以便与智能合约进行交互？</strong>👇👇👇</p><div class="nt nu fm fo nv nw"><a href="https://www.udemy.com/course/the-complete-solidity-mastery-course/" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab ej"><div class="ny ab nz cl cj oa"><h2 class="bd hu fv z el ob eo ep oc er et hs dt translated">完整的坚实掌握课程</h2><div class="od l"><h3 class="bd b fv z el ob eo ep oc er et ek translated">大家好，我的名字是奥卢瓦费米。在接下来的8年里，我一直在构建可伸缩的web应用程序…</h3></div><div class="oe l"><p class="bd b gc z el ob eo ep oc er et ek translated">www.udemy.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok iv nw"/></div></div></a></div><blockquote class="kq"><p id="ea3a" class="kr ks ht bd kt ku ol om on oo op kp ek translated">加入Coinmonks <a class="ae la" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae la" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae la" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="ix iy ht bd iz ja lb jc jd je lc jg jh ji ld jk jl jm le jo jp jq lf js jt ju dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="lg lh ht jx b jy jz kc kd ji oq jm or jq os kp ln lo lp lq dt translated"><a class="ae la" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae la" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="14e6" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated"><a class="ae la" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae la" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated"><a class="ae la" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">电网交易</a> | <a class="ae la" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="f33b" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated"><a class="ae la" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae la" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated"><a class="ae la" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">面向开发人员的最佳加密API</a></li><li id="b359" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated">最佳<a class="ae la" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated">杠杆代币的终极指南</li><li id="95d1" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated"><a class="ae la" href="https://coincodecap.com/best-vpns-for-crypto-trading" rel="noopener ugc nofollow" target="_blank">加密交易的最佳VPN</a></li><li id="918f" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated"><a class="ae la" href="https://coincodecap.com/blockchain-analytics" rel="noopener ugc nofollow" target="_blank">最佳加密分析或链上数据</a> | <a class="ae la" href="https://coincodecap.com/bexplus-review" rel="noopener ugc nofollow" target="_blank"> Bexplus评论</a></li><li id="51af" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated"><a class="ae la" href="https://coincodecap.com/nft-marketplaces" rel="noopener ugc nofollow" target="_blank">NFT十大市场造币集锦</a></li><li id="f72f" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated"><a class="ae la" href="https://coincodecap.com/ascendex-staking" rel="noopener ugc nofollow" target="_blank">AscendEx Staking</a>|<a class="ae la" href="https://coincodecap.com/bot-ocean-review" rel="noopener ugc nofollow" target="_blank">Bot Ocean Review</a>|<a class="ae la" href="https://coincodecap.com/bitcoin-wallets-india" rel="noopener ugc nofollow" target="_blank">最佳比特币钱包</a></li><li id="4ec1" class="lg lh ht jx b jy lr kc ls ji lt jm lu jq lv kp ln lo lp lq dt translated"><a class="ae la" href="https://coincodecap.com/bitget-review" rel="noopener ugc nofollow" target="_blank"> Bitget回顾</a>|<a class="ae la" href="https://coincodecap.com/gemini-vs-blockfi" rel="noopener ugc nofollow" target="_blank">Gemini vs block fi</a>|<a class="ae la" href="https://coincodecap.com/okex-futures-trading" rel="noopener ugc nofollow" target="_blank">OKEx期货交易</a></li></ul></div></div>    
</body>
</html>