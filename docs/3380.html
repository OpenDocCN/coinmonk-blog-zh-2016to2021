<html>
<head>
<title>A Websocket Client using the Java 11 WebSocket API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Java 11 WebSocket API的Websocket客户端</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-bitfinex-websocket-client-with-the-java-net-http-websocket-api-3fa873224996?source=collection_archive---------0-----------------------#2020-09-19">https://medium.com/coinmonks/a-bitfinex-websocket-client-with-the-java-net-http-websocket-api-3fa873224996?source=collection_archive---------0-----------------------#2020-09-19</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="517a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于一个小型加密项目，我想使用Bitfinex WebSocket API实时获取市场数据。github上有完整的代码。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/7f34ff1c281dcf12d4ce0e9cf02e8035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nc6lJVvZqEbJy32f30gtwA.png"/></div></div></figure><p id="ca4f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从Java SE 11开始，JDK包含了一个<a class="ae ka" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/package-summary.html" rel="noopener ugc nofollow" target="_blank">客户端WebSocket API </a>。javadoc包含一些代码示例，但是您不能开箱即用这些示例。在网上搜索“java websocket client ”,会发现大部分旧的JSR 352 websocket的例子和指南。设置好一切来完成工作并不像预期的那么简单，所以我写了这个小教程。</p><p id="67a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">只要合适，我就在我的项目中使用vert.x，还有一个websocket客户端API。但遗憾的是，vert.x websocket客户端有一个小缺点，它不能与重定向☹一起工作，尽管我们不使用vert.x websocket客户端，但我们使用vert.x作为我们的小应用程序的基础。</p><p id="2e90" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">足够的话，我们开始编码。要构建并连接到websocket服务器，构建器需要一个侦听器，它将侦听传入的数据包:</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="4880" class="kg kh ht kc b fv ki kj l kk kl"><strong class="kc hu">class </strong>BitfinexListener(<strong class="kc hu">val vertx</strong>: Vertx) : WebSocket.Listener {<br/><br/>    <strong class="kc hu">override fun </strong>onOpen(webSocket: WebSocket?) {<br/>        <strong class="kc hu">super</strong>.onOpen(webSocket)<br/>        <em class="km">LOGGER</em>.info(<strong class="kc hu">"websocket opened"</strong>)<br/>        <strong class="kc hu">this</strong>.<strong class="kc hu">vertx</strong>.periodicStream(60000).toObservable()<br/>          .subscribe <strong class="kc hu">{ </strong>i <strong class="kc hu">-&gt;<br/>            val </strong>pingTxt = JsonObject().put(<strong class="kc hu">"event"</strong>, <strong class="kc hu">"ping"</strong>)<br/>                           .put(<strong class="kc hu">"cid"</strong>, <em class="km">Random</em>(2020).nextInt())<br/>                           .encode()<br/>            webSocket?.sendText(pingTxt, <strong class="kc hu">true</strong>)?<br/>             .thenRun <strong class="kc hu">{-&gt; </strong><em class="km">LOGGER</em>.info(<strong class="kc hu">"sent ping {}"</strong>, pingTxt)<strong class="kc hu">}<br/>          }<br/>    </strong>}<br/><br/>    <strong class="kc hu">var parts</strong>: MutableList&lt;CharSequence?&gt; = <br/>            <em class="km">MutableList</em>(0) <strong class="kc hu">{ </strong>index: Int <strong class="kc hu">-&gt; "" }<br/>    var accumulatedMessage</strong>: CompletableFuture&lt;*&gt; =<br/>            CompletableFuture&lt;Any&gt;()<br/><br/>    <strong class="kc hu">override fun </strong>onText(webSocket: WebSocket,<br/>                         message: CharSequence?,<br/>                         last: Boolean): CompletionStage&lt;*&gt;? {<br/>        <strong class="kc hu">parts</strong>.add(message)<br/>        webSocket.request(1)<br/>        <strong class="kc hu">if </strong>(last) {<br/>            <strong class="kc hu">val </strong>completeMessage = <strong class="kc hu">parts</strong>.<em class="km">joinToString</em>(separator = <strong class="kc hu">""</strong>) <br/>                   <strong class="kc hu">{ </strong>charSequence <strong class="kc hu">-&gt; </strong>charSequence ?: <strong class="kc hu">"" }<br/>            parts</strong>.clear()<br/>            <strong class="kc hu">accumulatedMessage</strong>.complete(<strong class="kc hu">null</strong>)<br/>            <strong class="kc hu">val </strong>cf: CompletionStage&lt;*&gt; = <strong class="kc hu">accumulatedMessage<br/>            accumulatedMessage </strong>= CompletableFuture&lt;Any&gt;()<br/>            onMessage(completeMessage)<br/>            <strong class="kc hu">return </strong>cf<br/>        }<br/>        <strong class="kc hu">return accumulatedMessage<br/>    </strong>}<br/><br/>    <strong class="kc hu">fun </strong>onMessage(message: String) {<br/>        <strong class="kc hu">val </strong>bitfinexMessage = Json.decodeValue(message)<br/>        // ... see repo at github for full code<br/>    }<br/>}</span></pre><p id="01c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们覆盖onOpen方法来建立对bitfinex的周期性ping。重要的一点是，当您<strong class="is hu">覆盖onOpen时，您必须调用super.onOpen </strong>，否则客户端不会向服务器发送任何数据。</p><p id="837e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我花了很多时间才找到这个错误。因为监听器是一个接口，所以我不习惯调用接口的超方法。但在这种情况下这很重要。Java 8中引入的接口中默认方法的概念还没有成为我的第二天性。</p><p id="b480" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">onText消息收集所有传输的文本数据，直到一个文本完成(这通常是对inText的一次调用)。在文本完成时，文本通过onMessage方法中的vert.x eventbus发送。</p><p id="d43a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们可以使用这个监听器设置一个verticle来表示到bitfinex的连接:</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="b63a" class="kg kh ht kc b fv ki kj l kk kl"><strong class="kc hu">class </strong>BitfinexConnection : AbstractVerticle() {<br/><br/>    <strong class="kc hu">var webSocket</strong>: WebSocket? = <strong class="kc hu">null<br/><br/>    override fun </strong>start() {<br/>        <em class="km">LOGGER</em>.info(<strong class="kc hu">"deploying BitfinexConnection"</strong>)<br/>        <strong class="kc hu">val </strong>subs = <strong class="kc hu">vertx</strong>.sharedData()<br/>                .getLocalMap&lt;Int,String&gt;(<strong class="kc hu">"bitfinex.subscriptions"</strong>)<br/>        <strong class="kc hu">val </strong>listener = BitfinexListener(<strong class="kc hu">this</strong>.<strong class="kc hu">vertx</strong>, subs)<br/>        <strong class="kc hu">val </strong>client = HttpClient.newHttpClient()<br/>        <strong class="kc hu">val </strong>uri = URI.create(<strong class="kc hu">"wss://api-pub.bitfinex.com/ws/2")</strong><br/>        <strong class="kc hu">this</strong>.<strong class="kc hu">webSocket </strong>= client.newWebSocketBuilder()<br/>                     .buildAsync(uri), listener).join()</span><span id="ef4b" class="kg kh ht kc b fv kn kj l kk kl">        <strong class="kc hu">vertx</strong>.eventBus()<br/>             .consumer&lt;JsonObject(<em class="km">BITFINEX_EB_ADDRESS</em>)<br/>             .handler <strong class="kc hu">{ </strong>jsonMsg <strong class="kc hu">-&gt;<br/>            <br/>          if </strong>( <strong class="kc hu">webSocket</strong>==<strong class="kc hu">null </strong>|| <strong class="kc hu">webSocket</strong>?.isOutputClosed()!!) {<br/>              jsonMsg.reply(JsonObject()<br/>                            .put(<strong class="kc hu">"message"</strong>, <strong class="kc hu">"websocket closed"</strong>)<br/>                            .put(<strong class="kc hu">"statusCode"</strong>,503))<br/>                <strong class="kc hu">return</strong>@handler<br/>          }<br/>          <strong class="kc hu">val </strong>bitfinexMessage = jsonMsg.body().encode()<br/>          <strong class="kc hu">this</strong>.<strong class="kc hu">webSocket</strong>?.sendText(bitfinexMessage,<strong class="kc hu">true</strong>)?<br/>           .thenRun<strong class="kc hu">{ </strong><em class="km">LOGGER</em>.debug(<strong class="kc hu">"delivered {} "</strong>, bitfinexMessage)<strong class="kc hu">}<br/>        }<br/>    </strong>}<br/>}</span></pre><p id="fd83" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该类简单明了，在verticle的start方法中，初始化并启动了到公共bitfinex api的websocket连接。通过vert.x eventbus消息应该被直接发送到websocket，因此我们在地址BITFINEX_EB_ADDRESS上启动一个消费者。</p><p id="ada9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后一步，我们将所有东西放在一起，并尝试订阅tBTCUSD股票:</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="ce96" class="kg kh ht kc b fv ki kj l kk kl"><strong class="kc hu">fun </strong>main() {<br/>  <strong class="kc hu">val </strong>vertx = Vertx.vertx()<br/>  <strong class="kc hu">val </strong>symbol = <strong class="kc hu">"tBTCUSD"<br/>  </strong>vertx.rxDeployVerticle(BitfinexConnection::<strong class="kc hu">class</strong>.<em class="km">java</em>.<em class="km">name</em>)<br/>    .subscribe(<br/>        <strong class="kc hu">{ </strong>id <strong class="kc hu">-&gt;<br/>            </strong><em class="km">LOGGER</em>.info(<strong class="kc hu">"deployed bitfinex connection {}"</strong>, id)<br/>            <strong class="kc hu">val </strong>address = <strong class="kc hu">"ticker." </strong>+ symbol<br/>            vertx.eventBus()<br/>               .consumer&lt;JsonArray&gt;(address)<br/>               .handler <strong class="kc hu">{ </strong>jsonMsg <strong class="kc hu">-&gt;<br/>                  </strong><em class="km">LOGGER</em>.info(<strong class="kc hu">"received {} {}"</strong>, address,<br/>                        jsonMsg.body().encodePrettily())<br/>               <strong class="kc hu">}<br/></strong>            <strong class="kc hu">val </strong>subscribeMessage = JsonObject()<br/>                  .<em class="km">bfxSubscribeTickerMessage</em>(symbol)<strong class="kc hu">           <br/>            </strong>vertx.eventBus()<br/>                .send(<em class="km">BITFINEX_EB_ADDRESS</em>, subscribeMessage)<br/><br/>       <strong class="kc hu">}</strong>,<br/>       <strong class="kc hu">{ </strong>t: Throwable? <strong class="kc hu">-&gt; <br/>         </strong><em class="km">LOGGER</em>.error(<strong class="kc hu">"deployment failed"</strong>, t) <strong class="kc hu">}<br/>   </strong>)<br/>}</span></pre><p id="605f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">main方法启动Vertx并部署bitfinex websocket verticle。当部署完成时，我们向websocket verticle发送一条带有订阅负载的消息，并在一个特殊的eventbus地址上启动一个消费者。</p><p id="9d26" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你可以在github上找到所有代码，克隆它，确保你已经安装了Java 11或更高版本，并运行它:</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="6ad6" class="kg kh ht kc b fv ki kj l kk kl">.<strong class="kc hu">/gradlew run</strong></span></pre><p id="4457" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我希望本教程能让您在项目中快速启动websocket客户端代码。</p></div></div>    
</body>
</html>