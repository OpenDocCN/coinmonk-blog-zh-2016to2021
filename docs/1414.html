<html>
<head>
<title>C++ Guide for EOS Development — Call by value / reference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">EOS开发的C++指南—通过值/引用调用</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/c-guide-for-eos-development-call-by-value-reference-8dd8481f0647?source=collection_archive---------0-----------------------#2018-08-28">https://medium.com/coinmonks/c-guide-for-eos-development-call-by-value-reference-8dd8481f0647?source=collection_archive---------0-----------------------#2018-08-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/505bc75a49064b97940be3e61c9abbd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m4iRvlXop42WtkI6.png"/></div></div></figure><div class=""/><blockquote class="jb jc jd"><p id="cd98" class="je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这篇文章是我的<a class="ae kd" href="https://cmichel.io/categories/learneos" rel="noopener ugc nofollow" target="_blank">EOS开发人员C++指南</a>的一部分</p></blockquote><ol class=""><li id="8faa" class="ke kf ie jh b ji jj jm jn kg kh ki kj kk kl kc km kn ko kp dt translated"><a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-basics/" rel="noopener ugc nofollow" target="_blank">基础知识</a></li><li id="86d3" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated"><a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-call-by-value-reference/" rel="noopener ugc nofollow" target="_blank">通过值/引用调用&amp;指针</a></li><li id="7aad" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated">类和结构</li><li id="cc06" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated">模板</li><li id="4ddf" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated">迭代器</li><li id="e3ce" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated">λ表达式</li><li id="1bfe" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated">多指数</li><li id="c61b" class="ke kf ie jh b ji kq jm kr kg ks ki kt kk ku kc km kn ko kp dt translated">头文件</li></ol><h2 id="2dbb" class="kv kw ie bd kx ky kz la lb lc ld le lf kg lg lh li ki lj lk ll kk lm ln lo lp dt translated">通过值/引用调用</h2><p id="918f" class="pw-post-body-paragraph je jf ie jh b ji lq jk jl jm lr jo jp kg ls js jt ki lt jw jx kk lu ka kb kc hm dt translated">参数如何传递给函数是C++中的一个重要概念。对于初学者来说，这通常很难理解，因为在Java或JavaScript等语言中，您没有这些不同的方法来传递参数。您可以通过值调用<strong class="jh if">或引用调用<strong class="jh if">将参数传递给函数。它们之间的区别在于，在按值调用中，实际参数的副本<strong class="jh if">被创建，被调用的函数在副本上操作。而在引用调用中，参数在内存中的位置(地址)被传递给函数。也就是说，函数将在<em class="jg">相同的、相同的</em>对象上操作，因此，对象上的任何修改将在函数调用之外持续，因为当函数返回时，这些改变当然不会被恢复。让我们来看一个例子:</strong></strong></strong></p><pre class="lv lw lx ly fq lz ma mb mc aw md dt"><span id="13d0" class="kv kw ie ma b fv me mf l mg mh">#include &lt;iostream&gt;<br/><br/>// this is call by value<br/>// the integer x is copied and any modification is done on the copy <br/>void test_by_value(int x) {<br/>  x = 1;<br/>}<br/><br/>// call by reference is done using the `&amp;` after the type<br/>// no copy is created, behind the scenes the memory location is passed<br/>// and the same number is used<br/>void test_by_ref(int&amp; x) {<br/>  x = 2;<br/>}<br/><br/>int main() {<br/>  std::cout &lt;&lt; "Hello World!\n";<br/>  int number = 0;<br/>  test_by_value(number);<br/>  // outputs 0, number unchaged<br/>  std::cout &lt;&lt; "test_by_value " &lt;&lt; number &lt;&lt; "\n";<br/><br/>  test_by_ref(number);<br/>  // outputs 2(!), number changed<br/>  std::cout &lt;&lt; "test_by_ref " &lt;&lt; number &lt;&lt; "\n";<br/>}</span></pre><p id="93bb" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">注意，无论是通过值传递还是通过引用传递，调用方<em class="jg">的代码都是完全相同的。打电话的人总是刚过<code class="eh mi mj mk ma b">number</code>。对于引用调用，在函数的参数列表中使用一个符号<code class="eh mi mj mk ma b">&amp;</code>作为指示符。调用方的不可区分性使得无法推断您的数据是否作为函数副作用的一部分被修改。C++之所以有这两种类型，是因为C++默认的问题答案:<strong class="jh if">性能</strong>。创建大对象的副本需要时间，只要重用现有对象就可以避免。您可以通过将参数声明为<code class="eh mi mj mk ma b">const</code>来禁止修改参数:</em></p><pre class="lv lw lx ly fq lz ma mb mc aw md dt"><span id="fdfc" class="kv kw ie ma b fv me mf l mg mh">int test_by_ref(const int&amp; x) {<br/>  // this raises a compile time error now <br/>  // x = 2;<br/><br/>  // reading is OK<br/>  return x + 2;<br/>}</span></pre><p id="9a73" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">同样的行为不仅适用于<code class="eh mi mj mk ma b">int</code>，也适用于所有其他数据类型(<code class="eh mi mj mk ma b">string</code>、<code class="eh mi mj mk ma b">vector</code> s)和类对象。</p><blockquote class="jb jc jd"><p id="46f5" class="je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">使用引用调用是一个很好的实践，因为它通常更有性能，并且不要通过将参数声明为<code class="eh mi mj mk ma b">const</code>来修改它们</p></blockquote><p id="9fe0" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">例如，<a class="ae kd" href="http://drake.mit.edu/styleguide/cppguide.html#Reference_Arguments" rel="noopener ugc nofollow" target="_blank">谷歌C++风格指南</a>指出:</p><blockquote class="jb jc jd"><p id="46d6" class="je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">所有通过引用传递的参数都必须标记为const。</p></blockquote><pre class="lv lw lx ly fq lz ma mb mc aw md dt"><span id="d002" class="kv kw ie ma b fv me mf l mg mh">In fact, it is a very strong convention in Google code that input arguments are values or const references while output arguments are pointers.</span></pre><p id="c099" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">我们现在理解了<code class="eh mi mj mk ma b">values</code>和<code class="eh mi mj mk ma b">const references</code>，那么让我们来谈谈Google所说的<em class="jg">输出参数是指针</em>是什么意思。</p><h2 id="9261" class="kv kw ie bd kx ky kz la lb lc ld le lf kg lg lh li ki lj lk ll kk lm ln lo lp dt translated">两颗北极指极星</h2><p id="af64" class="pw-post-body-paragraph je jf ie jh b ji lq jk jl jm lr jo jp kg ls js jt ki lt jw jx kk lu ka kb kc hm dt translated">指针是存储另一个变量的内存地址的变量。它们在C中被大量使用，因为它没有<em class="jg">引用调用</em>。相反，在C中，你定义一个指针变量来存储你的参数的内存位置，然后通过值传递这个指针变量。</p><p id="9a04" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">让我们看看如何用C语言编写我们的<code class="eh mi mj mk ma b">test</code>函数:</p><pre class="lv lw lx ly fq lz ma mb mc aw md dt"><span id="f691" class="kv kw ie ma b fv me mf l mg mh">int number = 0;<br/><br/>// in C++<br/>void test_by_ref(int&amp; x) {<br/>  x = 2;<br/>}<br/>test_by_ref(number);<br/><br/>// in C<br/>void test_by_pointer(int* px) {<br/>    // remember the value of px is the address of x<br/>    // to get the actual value of x we need to dereference the pointer by using `*` <br/>  *x = 2;<br/>}<br/><br/>// pointers are defined by &lt;type&gt;*<br/>// you get the address of a variable by using &amp;<br/>int* pnumber = &amp;number;<br/>test_by_pointer(pnumber);<br/>// or without intermediate pointer variable<br/>test_by_pointer(&amp;number);</span></pre><p id="d578" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">指向<code class="eh mi mj mk ma b">int</code>变量的指针被定义为<code class="eh mi mj mk ma b">int*</code>，指向<code class="eh mi mj mk ma b">string</code>的指针将被定义为<code class="eh mi mj mk ma b">string*</code>。然而<em class="jg">任何</em>指针的实际大小都是一样的:<code class="eh mi mj mk ma b">sizeof(int*) == sizeof(string*)</code>。直观上，指针可以被看作一个32位或64位的变量，这取决于平台，<code class="eh mi mj mk ma b">unsigned int</code>变量的<strong class="jh if">值是另一个变量的内存地址</strong>。</p><blockquote class="jb jc jd"><p id="befc" class="je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">那么为什么我们需要指定指针的<em class="ie">类型</em>(<code class="eh mi mj mk ma b">int*</code>或<code class="eh mi mj mk ma b">string*</code>)呢？</p></blockquote><p id="e20b" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">好问题。当试图访问指针指向的变量<em class="jg">的值时，类型变得很重要。在我们的例子中，为了从我们的<code class="eh mi mj mk ma b">int* pnumber</code>指针中获得<code class="eh mi mj mk ma b">number</code>的值，我们需要<strong class="jh if">解引用指针</strong>。这是由指针变量上的<code class="eh mi mj mk ma b">*</code>操作符完成的:<code class="eh mi mj mk ma b">int numberValue = *pnumber</code>为了知道指针应该读取多少字节，我们需要定义指针</em>的<em class="jg">类型。</em></p><p id="dd66" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">例如，您可以这样逐字节读取整数变量:</p><pre class="lv lw lx ly fq lz ma mb mc aw md dt"><span id="5b64" class="kv kw ie ma b fv me mf l mg mh">uint32_t number = 0x01020304;<br/>// we need to cast it to uint8_t* because &amp;number is of type unit32_t*<br/>// remember the pointers all have the same range as they all store memory addresses<br/>uint8_t* p = (uint8_t*)(&amp;number);<br/>for(int i = 0; i &lt; 4; i++) {<br/>    std::cout &lt;&lt; "Byte " &lt;&lt; i &lt;&lt; ": " &lt;&lt; std::to_string(*(p+i)) &lt;&lt; "\n";<br/>}</span></pre><p id="453d" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">如你所见，我们可以对指针进行计算。这叫做<strong class="jh if">指针算法</strong>。这里，<code class="eh mi mj mk ma b">*(p+i)</code>是指在<code class="eh mi mj mk ma b">p</code>的存储单元中向前移动<code class="eh mi mj mk ma b">i</code>倍指针类型的大小(<code class="eh mi mj mk ma b">sizeof(uint8_t)</code>)并读取一个<code class="eh mi mj mk ma b">uint8_t</code>。</p><blockquote class="jb jc jd"><p id="7f40" class="je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">C++里我们还需要指针吗？</p></blockquote><p id="c152" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">尽管在C++中使用更简单的<code class="eh mi mj mk ma b">references</code>可以做很多事情，但是你仍然会经常遇到指针，例如，当使用<em class="jg">迭代器</em>或<em class="jg">输出参数</em>时。输出参数类似于函数中的<code class="eh mi mj mk ma b">return</code>值，除了它们作为指针参数传递，然后在函数中修改被引用的对象。让我们来看一个例子:</p><pre class="lv lw lx ly fq lz ma mb mc aw md dt"><span id="199a" class="kv kw ie ma b fv me mf l mg mh">void split(const std::string &amp;name, std::string *first, std::string *last)<br/>{<br/>    std::size_t pos = name.find(" ");<br/>    *first = name.substr(0, pos);<br/>    *last = name.substr(pos + 1);<br/>}<br/>std::string name = "Dan Larimer";<br/>std::string first, last;<br/>split(name, &amp;first, &amp;last);</span></pre><p id="9c3f" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">这里的<code class="eh mi mj mk ma b">first</code>和<code class="eh mi mj mk ma b">last</code>是指针输出参数，包含<code class="eh mi mj mk ma b">split</code>函数完成后的计算结果。当您需要返回一个以上的值时，比如在我们的例子中需要返回两个 <code class="eh mi mj mk ma b">string</code>时，输出参数通常用在真正的返回参数(<code class="eh mi mj mk ma b">string split(...) { ... return &lt;string&gt; }</code>)上。</p><blockquote class="jb jc jd"><p id="4f3d" class="je jf jg jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">难道我们不能通过使用引用而不是指针作为输出参数来达到同样的目的吗？</p></blockquote><p id="9ff2" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">是的，我们可以重写该函数，改为使用<em class="jg">引用</em>输出参数:</p><pre class="lv lw lx ly fq lz ma mb mc aw md dt"><span id="9efa" class="kv kw ie ma b fv me mf l mg mh">void split(const std::string &amp;name, std::string&amp; first, std::string&amp; last)<br/>{<br/>    std::size_t pos = name.find(" ");<br/>    first = name.substr(0, pos);<br/>    last = name.substr(pos + 1);<br/>}<br/>std::string name = "Dan Larimer";<br/>std::string first, last;<br/>split(name, first, last);</span></pre><p id="49cc" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">你喜欢什么由你决定，归结为个人风格。Google C++ Styleguide更喜欢使用<em class="jg">指针</em>作为输出参数的一个原因是，它在调用者站点清楚地表明<strong class="jh if">参数可能会发生变异。</strong></p><p id="ee0b" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">然而，能够阅读和理解引用和指针是很重要的。</p><p id="b107" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">现在，您可能对向函数传递参数的许多不同方式感到困惑。对于初学C++的开发人员来说，这通常是最大的学习体验，所以不要担心。在某些时候，你会看到共同的，重复的模式。</p><figure class="lv lw lx ly fq hv fe ff paragraph-image"><a href="https://learneos.one#modal"><div class="fe ff ml"><img src="../Images/1f74e4492a59c157e7cd57d76ecc4d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qi3ZMQc5Hi7XAruD.png"/></div></a></figure></div><div class="ab cl mm mn hb mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hm hn ho hp hq"><p id="6289" class="pw-post-body-paragraph je jf ie jh b ji jj jk jl jm jn jo jp kg jr js jt ki jv jw jx kk jz ka kb kc hm dt translated">最初发布于<a class="ae kd" href="https://cmichel.io/cpp-guide-for-eos-development-call-by-value-reference/" rel="noopener ugc nofollow" target="_blank"> cmichel.io </a></p><figure class="lv lw lx ly fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mt"><img src="../Images/0b0fdb99f4c5b4224a379fd4754f2a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jQGedC9C9CId2_tM.gif"/></div></div></figure><blockquote class="mu"><p id="97f5" class="mv mw ie bd mx my mz na nb nc nd kc ek translated"><a class="ae kd" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="nf ng nh ni nj hv fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ne"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>