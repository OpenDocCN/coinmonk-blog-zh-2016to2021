# 工作证明

> 原文：<https://medium.com/coinmonks/proof-of-work-40ade6af2708?source=collection_archive---------4----------------------->

![](img/a04df1d8f3ea04851c2a7593339a5b2b.png)

在谈论工作证明的概念之前，我们将讨论计算机科学中一个非常著名的问题，称为**拜占庭将军**问题——或者它的一个稍微修改的版本。

爱丽丝、鲍勃、查理和道格是拜占庭军队的四名将军，他们想要征服布洛克城。每个将军都有他/她的部队，他们在布洛克城的城墙外等候。尽管拜占庭军队的每个单位的士兵数量都超过了封锁城市的总人口数量，但封锁城市拥有高科技防御，拜占庭军队的所有将军必须立即发动协同攻击才能拿下这座城市——他们四个人必须同时攻击，只有这样他们才有机会征服这座城市。但是这里有一个小问题——每个将军都在城外不同的地方。他们之前都没有见过另一位将军，所以没有一位将军有任何方法来识别信使或证明他们收到的消息实际上是来自试图征服这座城市的三位将军中的一位。封锁城的市民知道这一点，并试图在城外传播假消息来迷惑将军们。

四位将军将如何协同作战，同时发动攻击拿下 BlockCity？

事实证明，我们可以使用区块链中使用的工作证明概念来解决这个问题。

现在，假设鲍勃想给其他将军发送以下消息-

> 13 日星期五拂晓发起攻击

其他三位将军不确定这条消息是鲍勃发出的，还是街区城市居民的诡计。将军们甚至不知道其他将军是否会同意进攻这个日期。

如果你知道散列是如何工作的，你就会意识到每个字符串的散列都会给出一个唯一的输出。

例如，如果我使用 [sha-256 算法](https://emn178.github.io/online-tools/sha256.html)(比特币使用的同一个算法)，在 13 日星期五黎明散列上述*攻击*消息，我总是得到以下输出-

> 2077 b 09d 4d 2d 6d 7 b 2 af 4c 4484 DC C5 fafddfcef 25 D5 a4 c 44 EB 72769 c 8 BD 55 ca 6

你可以试试[这里](https://emn178.github.io/online-tools/sha256.html)。

现在让我们向消息中添加一个名为 count 的变量，并尝试将消息作为字典(或 Javascript 中的对象)进行散列。一会儿就会明白我们为什么要这样做，请耐心听我说！

要哈希的对象-

```
{
    count: 0, 
    message: "Attack at dawn on Friday the 13th"
}
```

> hash—308 CCB 8 a 7 F3 a 048359 aad 7d 27 ce 44d 216 b 5386 BF 861 ba 89 ECE 141 C3 a5 c8 df 65 e

如果我改变计数，哈希也会改变。比如说。如果计数是要散列的“1”字符串-

```
{
    count: 1, 
    message:   "2077b09d4d2d6d7b2af4cc4484dcc5fafddfcef25d5a4c44eb72769c8bd55ca6"
}
```

> hash-8208 E5 bb 1 f 14 f 10 eeb 11 B4 c 18 EB 3 a 577 fa 6026d 2799 f1 B4 bb 1c 7 a 1723903762

现在爱丽丝是四个将军中最聪明的。她注意到她可以使用哈希法来解决拜占庭军队面临的问题。她说，只有当她收到的消息的哈希以两个零开头时，她才会认为该消息有效。

现在散列函数的输出是随机的。因此，如果我们想得到一个消息的散列，在开头有两个零，我们必须不断改变输入，直到我们通过反复试验在前面得到两个零。现在，想要发送消息的 Bob 无法更改消息，所以他会命令他的士兵不断更改 count 变量，直到整个字符串(message + count)的 hash 在开头有两个零。士兵们从 0 开始，在第 316 次尝试时，他们成功了-

要散列的字符串-

```
{
    count: 316,
    message: "Attack at dawn on Friday the 13th"
}
```

> hash-00e 978 e 541d 9 ba 82 fa 0 E6 b 8 feeda 91 a 6683 FD 91375 BC 364 ad 624 d6f 068 e 69937

散列一个字符串 316 次需要大量的工作，证明鲍勃的士兵做了这项工作就是散列本身。Alice 可以散列计数为 316 的字符串。现在她知道是谁给她发了这条信息，她做了几次哈希运算来得到开头的两个零。316 次很容易，连 BlockCity 的市民都能做这个工作，发个假消息。但是，如果要求是开头的三个或四个零(这很难实现)，该怎么办呢？可能需要数百或数千次尝试(改变计数)才能获得所需的哈希，而街区城市的居民将无法产生相同的哈希来证明他们做了足够的工作。同时，Bob、Charlie 和 Doug 拥有一支完整的军队，他们可以不断散列和发送所需计数的消息，以证明他们是拥有军队来完成这项艰苦工作的人。因此，证明他们事实上是将军，他们的信息是合法的。

现在你可能会问我，如果一个公民第一次尝试哈希时幸运地得到了正确的计数会怎么样？虽然这在理论上是可能的，但我们可以通过发送几条消息来解决这个问题，每条消息的开头都有四个零。如果没有人力来计算哈希值，公民不可能每次都走运。

*   信息 1:13 号星期五拂晓发动攻击
*   信息 2:我是鲍勃，我想确认 13 号星期五拂晓的袭击
*   信息 3:封锁城市将在 13 号星期五的黎明被攻击。

如此等等。

没有足够人力的街区城市的居民不可能计算出每次都从 3 或 4 个零开始的散列值。

您现在可能已经猜到了，在区块链，工作证明的相同概念用于证明一个人已经使用了创建一个块所需的计算资源量。虽然与上面的问题不同，我们不必发送同一消息的不同版本。发布一次就够了。我们将在以后的文章中更多地讨论比特币如何实现工作证明。

本文原载博客，blockchainiseasy . github . io .
[https://blockchainiseasy.github.io/proof-of-work/](https://blockchainiseasy.github.io/proof-of-work/)

如果你喜欢你所读到的，并想了解更多，请查看我们关于[分布式账本](/@vsurya.ayyagari/distributed-ledger-6c3508ee73bf)的文章。