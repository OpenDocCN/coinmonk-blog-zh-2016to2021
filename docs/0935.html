<html>
<head>
<title>Ethereum Smart Contract Development with a Web App — Part 2 : Testing and Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Web应用程序开发以太坊智能合约—第2部分:测试和部署</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethereum-smart-contract-development-with-a-web-app-part-2-testing-and-deployment-34a885e750b2?source=collection_archive---------4-----------------------#2018-07-03">https://medium.com/coinmonks/ethereum-smart-contract-development-with-a-web-app-part-2-testing-and-deployment-34a885e750b2?source=collection_archive---------4-----------------------#2018-07-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/766f63077dbb7b8ac78b64d957729a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRJGVOBfbSApdV7Heu8t9Q.jpeg"/></div></div></figure><p id="0a7c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在本指南中，您将了解将web应用程序转换为dApp所需的全部知识。本教程非常适合那些有一些创建智能合同的经验，但是不知道如何真正应用他们的知识用dapp做一些有用的东西的人。那我们开始吧。</p><p id="c5d9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">ICOs，智能合约，Mist，Remix，Metamask，geth，web3。如果你花一点时间尝试进入以太坊开发的世界，你很可能已经看到了这一切。</p><p id="b093" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一些人将智能合约部署到测试网络，另一些人指导你阅读黄皮书，还有一些人鼓励你使用truffle套件，因为它非常出色。而你在那里，不知道具体要做什么，也不知道一切是如何配合的。</p><p id="73a6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是博客系列的第二部分，包含以下章节。</p><ol class=""><li id="c118" class="jz ka ht jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated"><a class="ae ki" rel="noopener" href="/@priyalwalpita/ethereum-smart-contract-development-with-a-web-app-part-1-develop-the-smart-contract-ee2a7c735936">在solidity中开发智能合同，并将其部署在其中一个测试网络中</a></li><li id="954a" class="jz ka ht jd b je kj ji kk jm kl jq km ju kn jy ke kf kg kh dt translated">在真实网络(Rinkeby Network)中自动测试和部署您的智能合约</li><li id="91ad" class="jz ka ht jd b je kj ji kk jm kl jq km ju kn jy ke kf kg kh dt translated">构建一个前端web层来与智能合约进行交互。</li><li id="d158" class="jz ka ht jd b je kj ji kk jm kl jq km ju kn jy ke kf kg kh dt translated">在您自己的多节点以太网上部署智能合约</li></ol><p id="8e8d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果你还没有看完<a class="ae ki" rel="noopener" href="/@priyalwalpita/ethereum-smart-contract-development-with-a-web-app-part-1-develop-the-smart-contract-ee2a7c735936">的第一部分</a>，我建议你浏览一下第一部分，然后开始关注这篇文章。如果你对以太坊和solidity中的智能合约开发很熟悉，那么你可以进入这篇文章。</p><p id="1c1b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们将使用我们在第一部分中开发的相同的智能合约。在这篇文章中，我们使用<a class="ae ki" href="https://truffleframework.com/" rel="noopener ugc nofollow" target="_blank">松露框架</a>来签约创建、本地测试和部署。最终，智能合同将被部署到Rinkeby测试网络中进行真正的测试。</p><p id="555c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Truffle框架包含了一个很棒的工具集来执行许多以太坊操作，但即使是现在仍有许多开发在进行。这个框架被认为不是那么稳定。所以当你使用这样一个框架时，你需要做好失败的准备。</p><p id="30f9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">设置测试和部署环境</strong></p><p id="a15b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上一篇文章中，我们已经使用了<a class="ae ki" href="http://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a> online IDE来创建我们的智能合约，并使用了它自己的测试环境。当你在生产级的真实应用程序中工作时，一个在线IDE是不够的。</p><p id="a0a0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在您的本地计算机中设置以下文件夹结构以继续。无需在文件中添加任何内容，只需暂时保留空白即可。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff ko"><img src="../Images/b049cdff311a6cfc6144a1b4b7f71253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*-b1kiCKqQEKPXuV9.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 1 : Folder Structure</figcaption></figure><p id="be41" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我使用Linux作为操作系统，VS代码作为本地IDE。但是你可以使用任何你喜欢的操作系统或者集成开发环境。</p><p id="47bc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">转到项目文件夹的根目录，执行npm init命令。这将初始化所有需要的文件结构和需要的库。为所有必需的参数提供默认值。</p><p id="4d98" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下一步我们需要配置编译器。我们将使用solidity编译器来编译我们的智能合同。</p><p id="b68b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">&gt; npm安装—保存solc</p><p id="bb95" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，我们需要将合同代码从Remix复制并粘贴到multiauth.sol文件中。</p><p id="809f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后我们需要创建我们的compile.js文件，如下所示。</p><pre class="kp kq kr ks fq kx ky kz la aw lb dt"><span id="9b20" class="lc ld ht ky b fv le lf l lg lh"><strong class="ky hu">const</strong> path = require('path');<br/><strong class="ky hu">const</strong> fs = require('fs');<br/><strong class="ky hu">const</strong> solc = require('solc'); <br/><br/><strong class="ky hu">const</strong> sourcePath = path.resolve(__dirname,'contracts','multiauth.sol');<br/><br/><strong class="ky hu">const</strong> source = fs.readFileSync(sourcePath,'utf8');<br/><br/>console.log(solc.compile(source,<strong class="ky hu">1</strong>));</span></pre><p id="c442" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这个编译脚本读取源文件并使用solc编译器编译它。</p><p id="5585" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">保存compiler.js文件并运行编译命令，如下所示。</p><p id="4ab5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">&gt;节点compile.js</p><p id="20b2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果一切顺利，它会在控制台中给出以下输出。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff ko"><img src="../Images/4b9606f950bf4619a35b04eb1261275f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*MShniwOZz2rbY7K0.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 2 : Compile output</figcaption></figure><p id="b617" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">编译器输出许多属性，如字节码、接口和操作码。如果你还记得上一篇文章，我提到过solidity编译器输出两个我们可以利用的部分，字节码和ABI(应用二进制接口)。运行在EVM和接口之上的二进制文件中的字节码是我们用来将智能合约与任何第三方应用程序集成的。</p><p id="5b11" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">测试合同</strong></p><p id="f0c9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">编译之后，我们需要确保我们编译的契约运行正常，没有任何故障。记住，伙计们，不像我们每天编译和执行的其他程序，以太坊合同是和钱联系在一起的。因此，您需要确保您的代码中没有错误，因为您不希望最终将一些自动事务发送给错误的人。</p><p id="5a46" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">手动测试是一项低效且乏味的任务。因此，我们需要自动化测试过程，以便在任何更改之后，我们可以用更少的努力快速测试我们的智能合同。</p><p id="8a78" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们需要建立一个本地测试网络，Ganache(正式名称为TestRPC)可以用于这个目的。Ganache将提供与Remix的测试版EVM相同的服务。我们将使用Web3库(它与契约的ABI交互)来执行我们的测试。下图说明了测试设置。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff li"><img src="../Images/34b1af32bb09b00886a954102766d95b.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/0*w7SoKyZsV_6xF-sL.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 3 : Bytecode and ABI interface with Ganache</figcaption></figure><p id="ec37" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，我们需要安装Web3、Ganache和mocha(测试框架)，如下所示。</p><p id="ea84" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">&gt; npm安装—保存摩卡</p><p id="d2f1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">&gt; npm安装—保存ganache-cli</p><p id="29a2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">&gt; npm安装—保存web3@1.0.0-beta.26</p><p id="531c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们正在安装Web3版本1.0，因为它支持异步/等待调用和承诺，这对我们的异步编程模式很有用。以前的web3版本只支持异步代码的回调。</p><p id="7aa0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在Web3中，我们需要指定一个提供者来负责与任何以太网(在我们的例子中是Ganache)的接口。Mocha框架提供了所有需要的测试功能，比如断言等..如下更改package.json文件以包含mocha框架。(只需更改脚本-&gt;测试属性。</p><pre class="kp kq kr ks fq kx ky kz la aw lb dt"><span id="9277" class="lc ld ht ky b fv le lf l lg lh">{<br/>  "name": "mutiauth",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "mocha"<br/>  },<br/>  "author": "",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "ganache-cli": "^6.1.4",<br/>    "mocha": "^5.2.0",<br/>    "solc": "^0.4.24",<br/>    "web3": "^1.0.0-beta.26"<br/>  }<br/>}</span></pre><p id="0829" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Ganache提供了一些未锁定的缺省值(您不需要担心这些帐户的私有/公共密钥)来测试我们的合同。</p><p id="8fd4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">编辑multiauth.test.js文件，如下所示，列出我们所有的ganache本地测试帐户。</p><p id="0921" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">注意，我们在这里执行一个空断言，只是为了列出我们的测试帐户。</p><pre class="kp kq kr ks fq kx ky kz la aw lb dt"><span id="8b08" class="lc ld ht ky b fv le lf l lg lh"><strong class="ky hu">const</strong> assert = require('assert');<br/><strong class="ky hu">const</strong> ganache = require('ganache-cli');<br/><strong class="ky hu">const</strong> Web3 = require('web3');<br/><br/><br/><strong class="ky hu">const</strong> provider = ganache.provider();<br/><strong class="ky hu">const</strong> web3 = <strong class="ky hu">new</strong> Web3(provider);<br/><br/>beforeEach( async ()=&gt; {<br/><br/>    // Get list of all accounts       <br/>     web3.eth.getAccounts() <br/>         .then(fetchedAccounts =&gt; {<br/>            console.log(fetchedAccounts);<br/>        });    <br/>    <br/>});<br/><br/>describe('MultiAuth',()=&gt;{<br/>    it('contract deployment',()=&gt;{});<br/>});</span></pre><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff ko"><img src="../Images/bfe69a704ce87fc380a3427446b83723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*sYEt5TucFxXGxkn4.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 4 : Ganache testaccounts</figcaption></figure><p id="3935" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您可以看到它包含10个测试帐户。这些账户预装了足够的ETH，所以我们可以用它们来汇款和执行其他功能。</p><p id="9fb8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，我们将把我们的契约部署到Ganache，并测试部署过程。在改变测试脚本之前，我们需要对我们的编译脚本做一个小小的改动。之前，我们只是记录了编译命令的输出。为了将这个输出注入到测试脚本中，我们需要做如下的改变。</p><p id="77f9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">module . exports = solc . compile(source，1)。合同[':多授权']；</p><p id="3b77" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如下更新测试脚本。</p><pre class="kp kq kr ks fq kx ky kz la aw lb dt"><span id="36af" class="lc ld ht ky b fv le lf l lg lh"><strong class="ky hu">const</strong> assert = require('assert');<br/><strong class="ky hu">const</strong> ganache = require('ganache-cli');<br/><strong class="ky hu">const</strong> Web3 = require('web3');<br/><br/><br/><strong class="ky hu">const</strong> provider = ganache.provider();<br/><strong class="ky hu">const</strong> web3 = <strong class="ky hu">new</strong> Web3(provider);<br/><br/>//get output of the compilers  <br/><strong class="ky hu">const</strong> {<strong class="ky hu">interface</strong>,bytecode} = require('../compile');<br/><strong class="ky hu">let</strong> auth;<br/><strong class="ky hu">let</strong> accounts;<br/><br/>beforeEach( async ()=&gt; {<br/><br/>    // Get list of all accounts       <br/>    accounts = await web3.eth.getAccounts();<br/><br/>    auth = await <strong class="ky hu">new</strong> web3.eth.Contract(JSON.parse(<strong class="ky hu">interface</strong>))<br/>        .deploy({data:bytecode, arguments:[[accounts[<strong class="ky hu">1</strong>],accounts[<strong class="ky hu">2</strong>]],accounts[<strong class="ky hu">3</strong>]]})<br/>        .send({from:accounts[<strong class="ky hu">0</strong>], gas: '1000000', value: '2000000000'});<br/>    <br/>});<br/><br/>describe('MultiAuth',()=&gt;{<br/>    it(' Deployment and log ', async ()=&gt;{<br/>        console.log(auth);<br/>    });<br/> <br/>});</span></pre><p id="2dd8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这个测试脚本中，我们将导入compile.js文件的输出，并将接口和字节码元素赋给一个常量。然后，我们使用ABI(接口变量)将所需的参数传递到契约中。我们需要指定初始气体量、我们正在部署的帐户以及智能合同的初始值。</p><p id="dec0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，我们将部署过程的输出记录到控制台中。如果一切顺利，您将能够在控制台中检查部署的结果。</p><p id="ccec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">是时候写下一些真实的断言来测试我们的智能契约了。我们将测试以下项目。</p><p id="8bdb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">1.接收器</p><p id="dc46" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">2.合同余额</p><p id="78b0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">3.审批过程</p><p id="a0d4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">4.接收方的最终余额</p><p id="123c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下面是使用断言的完整测试脚本。</p><pre class="kp kq kr ks fq kx ky kz la aw lb dt"><span id="a4ea" class="lc ld ht ky b fv le lf l lg lh"><strong class="ky hu">const</strong> assert = require('assert');<br/><strong class="ky hu">const</strong> ganache = require('ganache-cli');<br/><strong class="ky hu">const</strong> Web3 = require('web3');<br/><br/><br/><strong class="ky hu">const</strong> provider = ganache.provider();<br/><strong class="ky hu">const</strong> web3 = <strong class="ky hu">new</strong> Web3(provider);<br/><br/>//get output of the compilers  <br/><strong class="ky hu">const</strong> {<strong class="ky hu">interface</strong>,bytecode} = require('../compile');<br/><strong class="ky hu">let</strong> auth;<br/><strong class="ky hu">let</strong> accounts;<br/><br/>beforeEach( async ()=&gt; {<br/><br/>    // Get list of all accounts       <br/>    accounts = await web3.eth.getAccounts();<br/><br/>    auth = await <strong class="ky hu">new</strong> web3.eth.Contract(JSON.parse(<strong class="ky hu">interface</strong>))<br/>        .deploy({data:bytecode, arguments:[[accounts[<strong class="ky hu">1</strong>],accounts[<strong class="ky hu">2</strong>]],accounts[<strong class="ky hu">3</strong>]]})<br/>        .send({from:accounts[<strong class="ky hu">0</strong>], gas: '1000000', value: '20000000000000000000'});<br/>    <br/>});<br/><br/>describe('MultiAuth',()=&gt;{<br/><br/>    it('Testing Receiver  ', async ()=&gt;{<br/>        assert.equal(await auth.methods.receiver().call(),accounts[<strong class="ky hu">3</strong>]);<br/>    });<br/><br/>    it('Testing The Contract balance  ', async ()=&gt;{<br/>        <strong class="ky hu">const</strong> bal = await auth.methods.getContractBalance().call();<br/>        assert.equal(bal,'20000000000000000000');   <br/>    }); <br/><br/>    it('Testing The Approval ', async ()=&gt;{<br/>       await auth.methods.approve().send({from:accounts[<strong class="ky hu">1</strong>]}); // First approver <br/>       await auth.methods.approve().send({from:accounts[<strong class="ky hu">2</strong>]}); // Second approver     <br/>    });<br/><br/>    it('Testing The Receivers balance ', async ()=&gt;{         <br/>      <strong class="ky hu">const</strong> accBal = await  web3.eth.getBalance(accounts[<strong class="ky hu">3</strong>]);<br/>      assert.ok(accBal &gt;= <strong class="ky hu">120000000000000000000</strong>);        <br/>     });<br/>});</span></pre><p id="be9c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">执行以下命令来运行测试。</p><p id="86b5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">&gt; npm运行测试</p><p id="cb82" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果您的所有测试都通过了，您将能够看到如下消息。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff lj"><img src="../Images/d9cf6e5759c1e673861e56be6e2caec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/0*bX8HcxGz5uaUb_Ne.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 5: Test results</figcaption></figure><p id="c751" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">将合同部署到真实的测试网络中</strong></p><p id="6745" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">测试成功后，现在我们需要将合同部署到真实的网络中。在本帖中，我们将把智能合约部署到Rinkeby网络中。</p><p id="eb37" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">与我们的测试环境不同，Rinkeby网络没有开放的测试帐户。因此，首先，我们需要在Rinkeby网络中设置几个示例帐户。你可以使用<a class="ae ki" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank">元蒙版</a>工具轻松做到这一点。</p><p id="bebd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">将元蒙版工具安装到你的浏览器中，你就可以随心所欲地创建多个账户。为了得到一些乙醚测试(在林克比)，你使用<a class="ae ki" href="https://faucet.rinkeby.io/" rel="noopener ugc nofollow" target="_blank">林克比水龙头。</a>你需要做的就是在社交媒体网站上发布你的账户地址。</p><p id="5d95" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了将我们的合同部署到一个真实的网络中，我们必须有一个以太坊节点。但是配置它并不是一件容易的事情，这也超出了这篇博文的范围。因此，我们将使用<a class="ae ki" href="https://infura.io/" rel="noopener ugc nofollow" target="_blank"> Infura </a>来部署我们的合同。一旦你注册，你会得到一个API密钥和每个网络的端点。我们要去那些API端点部署我们的合同。</p><p id="741c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以下是高级部署图。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff lk"><img src="../Images/2e1631f68b782da4a8e7118f9545bd99.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/0*cYU3AH4EvEI84drb.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 6 : Deployment diagram</figcaption></figure><p id="282c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，我们需要编写部署脚本。首先，你需要安装松露钱包提供者如下。</p><p id="2635" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">&gt; npm安装—保存truffle-hdwallet-provider</p><p id="e5aa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下面是deploy.js代码。</p><pre class="kp kq kr ks fq kx ky kz la aw lb dt"><span id="04a2" class="lc ld ht ky b fv le lf l lg lh"><strong class="ky hu">const</strong> HDWalletProvider = require('truffle-hdwallet-provider');<br/><strong class="ky hu">const</strong> Web3 = require('web3');<br/><strong class="ky hu">const</strong> {<strong class="ky hu">interface</strong>,bytecode} = require('./compile');<br/><br/><strong class="ky hu">const</strong> provider = <strong class="ky hu">new</strong> HDWalletProvider(<br/>    '&lt;your mnemonic&gt;',<br/>    'https://rinkeby.infura.io/&lt;your Infura API Endpoint&gt;'<br/><br/>);<br/><br/><strong class="ky hu">const</strong> web3 = <strong class="ky hu">new</strong> Web3(provider);<br/><br/><strong class="ky hu">const</strong> deploy = async () =&gt; {<br/>    <strong class="ky hu">const</strong> accounts = await web3.eth.getAccounts();<br/><br/>    console.log('Deploying to the Network using account : ', accounts[<strong class="ky hu">0</strong>]); <br/><br/>    <strong class="ky hu">const</strong> result = await <strong class="ky hu">new</strong> web3.eth.Contract(JSON.parse(<strong class="ky hu">interface</strong>))<br/>     .deploy({data: '0x'+ bytecode, arguments: [['0x61Ee7fA43ff49d4E9CC680E6031F074bd4BF85c7','0xBdAb9d885443A1D381EF4c03600d80FED63ABf46'],'0x9De226640854E3b2408cDFD486663bEaC3C072EC']})<br/>     .send({gas: '1000000', from : accounts[<strong class="ky hu">0</strong>], value: '2000000' });<br/><br/>    console.log('Contract Deployed to : ', result.options.address);<br/>};<br/><br/>deploy();</span></pre><p id="c228" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们使用truffle-hdwallet-provider来配置Infura API。注意传入元掩码助记符和InfuraAPI来访问我们的帐户。然后，我们需要在部署脚本中指定正确的参数列表和其他相关参数。请确保提供有效的地址作为参数，因为我们需要使用这些帐户执行智能合同。</p><p id="5c4f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，我们将记录我们已经部署了智能合约的地址，因为我们需要知道我们的智能合约是在哪里部署的。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff ko"><img src="../Images/7b312392b032fe1bfaad89390393b794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*wiAldhi5_PSee1Jq.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 7 : Deployment output</figcaption></figure><p id="35bb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以使用<a class="ae ki" href="https://rinkeby.etherscan.io/" rel="noopener ugc nofollow" target="_blank"> EtherScan </a>来分析您的智能合约在何处以及如何部署。它记录了Rinkeby网络中的所有交易，并使用易于使用的网页进行展示。</p><p id="4297" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了分析我们所做的交易，复制合同的部署地址并粘贴到搜索栏中。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff ko"><img src="../Images/8522db4fd1b6a8a498e3e7eec33f866e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*WBq4gMCZQGkqBLrv.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 8 : Deployed Smart contract details</figcaption></figure><p id="9bef" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您可以看到合同的余额、块号、部署合同的地址等..因此，如果我们准备好了一个web应用程序，那么我们就可以与这个契约进行交互。我们将在这个博客系列的下一部分讨论这个问题。</p><p id="7b57" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">但在那之前，我们有一种方法可以用混音来测试。在你的浏览器中打开Remix工具，进入Run标签。将环境更改为Injected Web3。现在，您可以看到帐户设置为您在元蒙版工具中选择的帐户，余额就是该帐户的余额。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/37ff7b50ecb657daa5850c5445512874.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/0*fDtTvnkIgg3KgC9i.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 9: Remix Account properties</figcaption></figure><p id="5bc1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">将已部署契约的地址复制到“At Address”部分，然后您就可以将已部署契约加载到Remix中。您可以检查余额、请求者地址等..使用混音工具。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/823b89c576ed2e699dd830622f5730bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/0*6Y2QI7uVlHBXOrSw.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 10 : Testing in Remix</figcaption></figure><p id="c745" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">使用Remix执行合同的功能</strong></p><p id="1f35" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，从元掩码工具中选择任何批准者帐户。使用帐户下拉菜单确保您在连接帐户中。尝试使用“批准”按钮批准合同。</p><p id="6592" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您将从Meta mask wallet得到一个提示，询问您是否同意执行交易。因此，这将发送一些以太网到目标地址(合同的地址)。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/465e83de50033719eb37deeaf2574bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/0*AQUqzRC48O898pgF.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 11 : Confirm Metamask transaction</figcaption></figure><p id="fd48" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">给你一些时间来挖掘你的交易(是的，现在你是在一个真正的以太网:D)并使用合同中的批准者按钮分析批准状态。您可以看到第一个审批人批准了合同。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/9038ac6b16bb100d3c32d23ce8502cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/0*D_QrahzGlQrnNJq9.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 12 : Smart contract approval status</figcaption></figure><p id="99fe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请所有必需的审批人批准合同。</p><p id="f201" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，去看看接收者的账户，看看那里发生了什么。您将能够看到特定的帐户收到了合同的余额。</p><p id="15d6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">结论</strong></p><p id="f11b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这篇文章中，我们使用mocha和truffle框架进行了智能合约测试。然后，我们将智能合约部署到一个真实的测试网络(Rinkeby)中，并使用Remix工具与部署的智能合约进行交互。</p><p id="2b0a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">希望在下一节中看到您，构建一个web应用程序来与这个智能契约进行交互。</p><p id="226d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你可以在<a class="ae ki" href="https://github.com/priyalwalpita/Ethreum-MultiAuth" rel="noopener ugc nofollow" target="_blank">这个git repo </a>中找到源代码文件。</p></div></div>    
</body>
</html>