<html>
<head>
<title>Linked Lists in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity中的链表</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/linked-lists-in-solidity-cfd967af389b?source=collection_archive---------0-----------------------#2017-11-14">https://medium.com/coinmonks/linked-lists-in-solidity-cfd967af389b?source=collection_archive---------0-----------------------#2017-11-14</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="2c54" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们需要一个高效的结构来存储智能契约中的大量条目，以便快速遍历。即使物品数量增加，添加新物品也必须非常便宜。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/cd23fbb51ba2fdebb59b3430d45cad93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UicoMGZBZkoqvmXjWtlXcw.png"/></div></div></figure><p id="4b3e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">solidity中的映射数据类型非常适合存储信息，但是如果你不知道每一项的索引，就很难浏览。</p><p id="0f58" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有了一个链表，你就像一个链表一样存储了当前数据中<strong class="is hu">下一</strong>数据的索引。为了使<em class="ka">写</em>成为我们最有效的操作，我们想通过跟踪一个<strong class="is hu">头</strong>索引来将项目添加到列表的前面。当我们想要添加新元素时，我们将现有的<strong class="is hu">头</strong>索引作为新元素的<strong class="is hu">下一个</strong>索引，然后将<strong class="is hu">头</strong>设置为新元素。对于任何大小的列表，这种操作花费相同的计算量。当我们想要浏览数据时，我们从<strong class="is hu">头</strong>索引开始，并沿着<strong class="is hu">下一个</strong>索引的轨迹前进。</p></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><p id="d736" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们创建一个名为<strong class="is hu"> LinkedList </strong>的契约，它存储了所有链接在一起的<strong class="is hu">对象</strong>的列表。一个<strong class="is hu">对象</strong>是一个<em class="ka">结构</em>数据类型，它保存下一个对象的索引以及一个<strong class="is hu">名称</strong>和一个<strong class="is hu">编号</strong>。出于演示的目的，让我们假设这个契约旨在保存来自小的、虚构的地区的投票信息，其中<strong class="is hu"> name </strong>是候选人的名字，<strong class="is hu"> number </strong>是候选人在该地区获得的票数。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ki kj l"/></div></figure><p id="72ef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">同样，我们将跳过编译、部署和脚本机制，假设读者已经遵循了<a class="ae kk" href="https://concurrence.io/exploration/deployingacontract" rel="noopener ugc nofollow" target="_blank">之前的探索</a>。</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="d117" class="kq kr ht km b fv ks kt l ku kv">node compile LinkedList<br/>node deploy LinkedList<br/><br/>0xFD400Ff1b9f23b105386350309C0616A50c969bE</span></pre><p id="42cc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，让我们用一组类似于以下内容的事务填充合同:</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="15ec" class="kq kr ht km b fv ks kt l ku kv">node contract addEntry LinkedList null 93 "Bram"</span></pre><p id="b71e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">(这个条目说候选人<strong class="is hu">布拉姆</strong>获得了<strong class="is hu"> 93 </strong>张选票。)</p><p id="e036" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让一些地区报告他们的结果:</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="b634" class="kq kr ht km b fv ks kt l ku kv">node contract addEntry LinkedList null 26 "Hal"<br/>node contract addEntry LinkedList null 23 "Julian"<br/>node contract addEntry LinkedList null 27 "Hal"<br/>node contract addEntry LinkedList null 33 "Eva"<br/>node contract addEntry LinkedList null 23 "Julian"<br/>node contract addEntry LinkedList null 42 "Eva"<br/>node contract addEntry LinkedList null 34 "Hal"<br/>node contract addEntry LinkedList null 12 "Julian"<br/>node contract addEntry LinkedList null 57 "Hal"</span></pre><p id="4298" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，我们可以运行我们的<strong class="is hu"> getTotal() </strong>函数来计算总票数:</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="68b7" class="kq kr ht km b fv ks kt l ku kv">node contract getTotal LinkedList<br/><br/>TOTAL:370</span></pre><p id="087b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们可以免费运行<strong class="is hu"> getTotal() </strong>离线，但是如果我们需要改变合同的状态，我们将不得不支付汽油费用。让我们再深入探讨一下汽油成本，看看我们在处理什么。</p><p id="1b3e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们运行<strong class="is hu"> setTotal() </strong>函数，它将运行<strong class="is hu"> getTotal() </strong>，就像我们离线时那样，但它会将它写入<strong class="is hu"> writtenTotal </strong> <em class="ka"> uint </em>。因为状态发生了变化，网络中的每一个契约都必须遍历我们的链表，并最终达到相同的总数。这将耗费我们一些汽油:</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="fe38" class="kq kr ht km b fv ks kt l ku kv">node contract setTotal LinkedList</span></pre><p id="1cd4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">(在<a class="ae kk" href="https://ropsten.etherscan.io/tx/0xb09dcff01d528aa00dd1cee5703dee4fc8ee6383afc310cedd279f13614dc9c0" rel="noopener ugc nofollow" target="_blank"> etherscan.io </a>上的交易)</p><p id="e491" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要遍历列表，跟踪总数，并最终将总数写入state，需要花费<strong class="is hu"> 0.001034044 </strong> ether。</p><p id="e028" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">(参见<a class="ae kk" href="https://ropsten.etherscan.io/vmtrace?txhash=0xb09dcff01d528aa00dd1cee5703dee4fc8ee6383afc310cedd279f13614dc9c0" rel="noopener ugc nofollow" target="_blank"> etherscan.io </a>上的所有349个操作)</p><p id="5bf9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，如果我们使用<strong class="is hu"> resetTotal() </strong>函数在不遍历列表的情况下更改相同的状态，让我们看看代价是什么:</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="2c5f" class="kq kr ht km b fv ks kt l ku kv">node contract resetTotal LinkedList</span></pre><p id="fabd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">(在<a class="ae kk" href="https://ropsten.etherscan.io/tx/0x8fc15b5fe628b203323d0fe6c9f43bbf931066bfcdaf34f4185e83181a5a88d9" rel="noopener ugc nofollow" target="_blank"> etherscan.io </a>上的交易)</p><p id="3dcb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">哇，真便宜，才0.000292974 乙醚。所以也许我们可以减去这两个数字，然后大概算出遍历这个列表要花多少钱？</p><p id="2856" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以美元计算，假设ETH约为300美元，支付22 gwei的天然气，设置我们的uint值约为<strong class="is hu"> $0.09 </strong>，遍历我们的10个条目列表约为<strong class="is hu"> $0.22 </strong>以保持运行总数。回头看添加一个条目，按同样的速率，大约花费了<strong class="is hu"> $0.63 </strong></p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff kw"><img src="../Images/49cbb208d7bc965edfdf566ecac68425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*1K7nCxbvhAij1KjZCDeCxg.png"/></div></figure><p id="b6e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">记住<em class="ka">关注点分离</em>，让我们创建第二个契约，它将与<strong class="is hu"> LinkedList </strong>契约交互，而不是将功能直接写入<strong class="is hu"> LinkedList </strong>契约。这份契约将被称为<strong class="is hu">计票员</strong>，一旦达到<strong class="is hu">法定人数</strong>就将计票。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ki kj l"/></div></figure><p id="09ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用<em class="ka"> enum </em>数据类型，我们可以将出纳员编码为像状态机一样执行。注意<strong class="is hu"> countVotes() </strong>函数在检测到新的条件时是如何改变状态的。这里最重要的概念是<strong class="is hu">极限转向</strong>。由于gas限制(参见<a class="ae kk" href="https://en.wikipedia.org/wiki/Halting_problem" rel="noopener ugc nofollow" target="_blank">停止问题</a>，我们无法在一个事务中遍历整个列表。我们要做的是遍历它的一部分，然后跟踪事务之间的运行总数。在生产中，我们将使用<strong class="is hu"> msg.gas </strong>变量，但出于演示目的，我们一次只数四个。</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="6a20" class="kq kr ht km b fv ks kt l ku kv">node compile Teller<br/>node deploy Teller<br/><br/>0x3c67a0e63a967810fcC5e48F9a94c6D561D9a7cd</span></pre><p id="44fc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">链表</strong>合同的当前<strong class="is hu"> getTotal() </strong>正在返回<strong class="is hu"> 370 </strong>。因此，如果我们针对<strong class="is hu"> LinkedList </strong>合同地址运行<strong class="is hu"> countVotes() </strong>函数，那么<strong class="is hu">出纳员</strong>应该停留在状态<strong class="is hu"> 0 </strong>:</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="978f" class="kq kr ht km b fv ks kt l ku kv">node contract countVotes Teller null 0xFD400Ff1b9f23b105386350309C0616A50c969bE<br/>node contract getState Teller<br/><br/>STATE:0</span></pre><p id="0d59" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们进行最后一次计票，使总数超过所需的法定人数:</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="6e21" class="kq kr ht km b fv ks kt l ku kv">node contract addEntry LinkedList null 32 "Bram"<br/>node contract getTotal LinkedList<br/><br/>TOTAL:402</span></pre><p id="33a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，当我们触发<strong class="is hu"> countVotes() </strong>函数时，状态应该变为<strong class="is hu"> 1 </strong>，代表<strong class="is hu">count votes</strong>的状态:</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="8e52" class="kq kr ht km b fv ks kt l ku kv">node contract countVotes Teller null 0xFD400Ff1b9f23b105386350309C0616A50c969bE<br/>node contract getState Teller<br/><br/>STATE:1</span></pre><p id="3d4f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我们开始计票之前，让我们检查一下<strong class="is hu">出纳员</strong>合同中的几个变量:</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="15ae" class="kq kr ht km b fv ks kt l ku kv">node contract getCounted Teller<br/>COUNTED:0<br/><br/>node contract getCurrentPointer Teller<br/>CURRENTPOINTER:0x0000000000000000000000000000000000000000000000000000000000000000</span></pre><p id="8327" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在让我们开始第一轮计票，总共应该有前四张选票:</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="a1c9" class="kq kr ht km b fv ks kt l ku kv">node contract countVotes Teller null 0xFD400Ff1b9f23b105386350309C0616A50c969bE<br/><br/>node contract getCounted Teller<br/>COUNTED:4<br/><br/>node contract getCurrentPointer Teller<br/>CURRENTPOINTER:0xa286649c24c2fe84cceb42001867f0d66be3fcc1e9612f9974ed74d6fb86375f</span></pre><p id="14a4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在前四张选票合计后，我们也可以看到谁领先，但由于该州仍在计票，我们知道选举还没有结束:</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="c794" class="kq kr ht km b fv ks kt l ku kv">node contract getWinningName Teller<br/>WINNINGNAME:Hal<br/><br/>node contract getWinningVotes Teller<br/>WINNINGVOTES:91<br/><br/>node contract getState Teller<br/>STATE:1</span></pre><p id="ac79" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们通过运行<strong class="is hu"> countVotes() </strong>函数来结束选举，直到状态变为<strong class="is hu"> 2 </strong> ( <strong class="is hu">选举完成</strong>):</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="af7c" class="kq kr ht km b fv ks kt l ku kv">node contract countVotes Teller null 0xFD400Ff1b9f23b105386350309C0616A50c969bE<br/>node contract countVotes Teller null 0xFD400Ff1b9f23b105386350309C0616A50c969bE<br/><br/>node contract getState Teller<br/>STATE:2</span></pre><p id="1c79" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们可以确信我们已经选出了真正的获胜者，我们的选举已经结束:</p><pre class="jp jq jr js fq kl km kn ko aw kp dt"><span id="99ea" class="kq kr ht km b fv ks kt l ku kv">node contract getWinningName Teller<br/>WINNINGNAME:Hal<br/><br/>node contract getWinningVotes Teller<br/>WINNINGVOTES:144<br/><br/>node contract getTotal Teller null Bram<br/>TOTAL [Bram]:125<br/><br/>node contract getTotal Teller null Eva<br/>TOTAL [Eva]:75<br/><br/>node contract getTotal Teller null Julian<br/>TOTAL [Julian]:58</span></pre><p id="7329" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个链表和部分遍历概念将是我们如何在区块链上达成共识的基础。矿工会离线请求，并在链上发布他们的结果。然后，我们将遍历一个列表，根据结果添加“标记”记号，以找到最佳答案。</p><blockquote class="kx"><p id="7c04" class="ky kz ht bd la lb lc ld le lf lg jn ek translated"><a class="ae kk" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="li lj lk ll lm jt fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lh"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><p id="8bea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="ka">这是摘自</em> <a class="ae kk" href="https://concurrence.io/exploration/linkedlists/" rel="noopener ugc nofollow" target="_blank"> <em class="ka">的并发链表探索</em> </a>。</p><p id="9d4b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">阅读更多关于<a class="ae kk" href="https://concurrence.io" rel="noopener ugc nofollow" target="_blank">并发</a>和我们其他<a class="ae kk" href="https://concurrence.io/exploration/" rel="noopener ugc nofollow" target="_blank">探索</a>的信息。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ln kj l"/></div></figure></div></div>    
</body>
</html>