<html>
<head>
<title>Decoding the Storage of an Ethereum Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解码以太坊契约的存储</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/decoding-the-memory-of-an-ethereum-contract-52c256f83f07?source=collection_archive---------0-----------------------#2020-03-30">https://medium.com/coinmonks/decoding-the-memory-of-an-ethereum-contract-52c256f83f07?source=collection_archive---------0-----------------------#2020-03-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="afea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">本文是探讨以太坊虚拟机(EVM)存储机制的系列文章的第1部分。</p><p id="45fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="http://inuka.dev/an-ethereum-storage-decode-tool/" rel="noopener ugc nofollow" target="_blank">第2部分</a>介绍了使用本文中的概念编写的存储解码工具。</p><h2 id="caab" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated"><strong class="ak">以太坊记忆</strong></h2><p id="756b" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">EVM允许执行智能合同代码。约定状态或存储器存储在约定地址。这种存储可以被认为是位于契约地址的无限长的类似数组的数据结构。存储机制确保存储位置没有冲突，并遵循一组规则。使用这些规则，我们可以解码任何合同的状态。解码存储在地图中的数据需要知道所使用的密钥。使用RPC调用<a class="ae jo" href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getstorageat" rel="noopener ugc nofollow" target="_blank"> eth_getStorageAt </a>对合同数据进行解码。</p><h2 id="19fa" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated"><strong class="ak">插槽位置</strong></h2><p id="a903" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">智能合约的存储数组中变量的位置由它在代码中出现的顺序和变量的大小决定。这个位置称为插槽。如果变量小于256位，EVM会尝试在空间中装入多个变量，因此，多个变量可能会占用存储阵列中单个槽的空间。一个映射或数组将总是占用一个槽。数组和映射元素的位置遵循一组特殊的散列规则，本文将对此进行讨论。这些规则在<a class="ae jo" href="https://blog.coincodecap.com/tag/ethereum/" rel="noopener ugc nofollow" target="_blank">以太坊</a> <a class="ae jo" href="https://solidity.readthedocs.io/en/v0.4.20/miscellaneous.html#layout-of-state-variables-in-storage" rel="noopener ugc nofollow" target="_blank">文档</a>中也有描述。</p><p id="bf27" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下表(表1)简要总结了EVM遵循的分配规则。我们将查看两个契约示例，并使用表1中提供的规则对它们进行解码</p><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="fe ff kp"><img src="../Images/6f1d73204e5dc7d7de0e55cacf34c77e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xEFdN0g3OytHVyMY.png"/></div></div></figure><h2 id="e4a0" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated"><strong class="ak">256位变量的简单示例</strong></h2><p id="b1ca" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">首先让我们看一个简单的例子，所有变量都是256位(32字节长)。这样做允许我们在不考虑可变包装的情况下查看分配。</p><p id="ebb6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意，当对数字应用keccack哈希时，数字必须是0填充的64位值。</p><p id="0047" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所有的解码都是使用<a class="ae jo" href="https://blog.coincodecap.com/tag/ethereum/" rel="noopener ugc nofollow" target="_blank">以太坊</a> RPC调用<a class="ae jo" href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getstorageat" rel="noopener ugc nofollow" target="_blank">eth _ getstoraget</a>来执行的，在文章中表示为getstoraget。任何语言包装器如nethereum或web3j都可以用来调用这个RPC api。</p><p id="2f01" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下图(图1)显示了如何对协定的地址和传递给它的位置值进行GetStorageAt调用。图1左侧的数字是变量的位置。对于基本类型(uint、string等。)这个位置可以传入GetStorageAt来获取变量值。对于数组，位置将返回数组的长度。</p><p id="10fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通过将Keccack哈希传递给索引0的GetStorageAt来解码数组索引。数组的每个后续索引位于与位置相加的哈希值处。这可以被认为是访问指向数组的指针并增加它的位置来找到每个元素，类似于C或C++。</p><p id="f967" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">地图稍微复杂一点。传递给GetStoragetAt的每个键的位置值是键的keccack散列和映射声明的位置。对于多维映射，Keccack散列值被递归调用用于键和变量位置。请参见图1中的示例进行说明。</p><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/37a7c03ed360e241c65c52e8de6f5ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/0*UAkjzOEstNNk_hdB.png"/></div></figure><p id="44cf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来让我们看一个变量打包的例子。打包时要记住的一点是:</p><ol class=""><li id="3ad2" class="lc ld ht is b it iu ix iy jb le jf lf jj lg jn lh li lj lk dt translated">它只适用于出现顺序的基本变量类型(uint128、string、int等)。EVM将按照变量在代码中列出的顺序，在256位空间中封装尽可能多的变量。</li><li id="1f84" class="lc ld ht is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk dt translated">每个映射和数组变量将占用一个新的槽。</li><li id="aad9" class="lc ld ht is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk dt translated">数组变量映射将遵循打包规则。也就是说，如果元素小于256位，数组的多个索引将占用存储数组中的单个槽。</li></ol><p id="5486" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以太坊<a class="ae jo" href="https://solidity.readthedocs.io/en/develop/miscellaneous.html#layout-of-state-variables-in-storage" rel="noopener ugc nofollow" target="_blank">文档</a>中也解释了这些规则</p><p id="d919" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">图2显示并解释了发生的打包。当一个类型的长度小于256位时，EVM会尝试将额外的变量装入该槽中。EVM按照列出的顺序挑选要打包的变量。地图和数组总是出现在新的位置。但是，打包规则仍然适用于解码数组索引，打包规则仍然适用于存储在映射中的结构。参见图2，了解在这种情况下变量是如何存储的。</p><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/38749e904ca62602cd6d395c65cdfc6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/0*PmvfFsS7_tysfxJ3.png"/></div></figure><h2 id="2203" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated"><strong class="ak">继承</strong></h2><p id="7d86" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">关于继承的一个注记。当契约继承其他契约时，基础契约的存储变量按照继承顺序占据存储阵列的第一个槽。子类的存储变量会在后面出现。</p><h2 id="6f9a" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated"><strong class="ak">结论</strong></h2><p id="4791" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">如上所述，我们可以使用本文描述的规则来解码以太坊智能合约的记忆。<a class="ae jo" href="http://inuka.dev/an-ethereum-storage-decode-tool/" rel="noopener ugc nofollow" target="_blank">第2部分</a>将描述一个使用本文描述的规则编写的工具</p><blockquote class="lr"><p id="9dba" class="ls lt ht bd lu lv lw lx ly lz ma jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="mc md me mf mg ku fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mb"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div><div class="ab cl mh mi hb mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hm hn ho hp hq"><p id="0113" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="mo">原载于2020年3月30日</em><a class="ae jo" href="https://inuka.dev/decoding-the-memory-of-an-ethereum-contract/" rel="noopener ugc nofollow" target="_blank"><em class="mo">https://inuka . dev</em></a><em class="mo">。</em></p><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="fe ff mp"><img src="../Images/e9dbce386c4f90837b5db529a4c87766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fZu_SfnNF6m_BGbXlsl-A@2x.png"/></div></div></figure></div></div>    
</body>
</html>