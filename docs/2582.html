<html>
<head>
<title>K vs. Coq as Language Verification Frameworks (Part 2 of 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">k与Coq作为语言验证框架(第2部分，共3部分)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/k-vs-coq-as-language-verification-frameworks-part-2-of-3-a98ce2592f65?source=collection_archive---------7-----------------------#2019-12-12">https://medium.com/coinmonks/k-vs-coq-as-language-verification-frameworks-part-2-of-3-a98ce2592f65?source=collection_archive---------7-----------------------#2019-12-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="a494" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">作者:穆萨布·阿尔图基和布兰登·摩尔</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/b4e01630054c493044c6f9f076cdd579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yqm6c3I9IiZZSbWw.png"/></div></div></figure><p id="8bba" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在这篇文章的第1部分中，我们首先介绍了在一个语言验证框架中验证程序正确性的步骤，比如K和Coq。然后，我们描述了第一步，定义语言语法和程序结构，是如何在K和Coq中完成的，这是我们在语言IMP中的工作示例程序SUM，突出了两个框架之间的主要区别。</p><p id="85c4" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在这篇文章的第二部分，我们建立在前一部分介绍的定义的基础上，描述如何使用相同的示例SUM在K和Coq中实现语言的语义和测试语义，这是这个过程的第二步。本系列的第3部分解释了如何完成第三步(指定和验证属性)。</p><h1 id="5dc8" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">定义IMP的语义</h1><p id="c0f5" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">定义一种语言的形式模型L的第二步是给它的构造赋予形式语义。下面，我们定义语言IMP的语义。</p><h1 id="6a64" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">K中的执行规则</h1><p id="8ef5" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">K中的语义是通过重写称为配置的术语来指定的。一个配置由一组可能嵌套的单元组成，其中每个单元代表所指定语言的一个语义元素。一个基本单元是计算单元，它列出了一系列计算结构，这些结构定义了赋予程序语义的任务序列。还可以定义其他单元，比如绑定构造的命名环境、多线程语言的线程、动态内存分配的堆等等。要定义的特定配置是特定于语言的。例如，IMP是一种简单的带有变量的顺序编程语言，因此只需要一个简单的配置，包括计算单元<code class="eh lo lp lq lr b">&lt;k/&gt;</code>和状态单元<code class="eh lo lp lq lr b">&lt;state/&gt;</code>，用于将变量映射到值:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ls"><img src="../Images/3ddee343e5850e0f2d391cc56cd13ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P-N8d6nBoFh0A3f3.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek"><em class="lx">The (initial) K configuration of SUM</em></figcaption></figure><p id="a8d3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这也定义了IMP程序的初始配置，其中<code class="eh lo lp lq lr b">&lt;k/&gt;</code>单元包含要评估的整个程序(在K变量<code class="eh lo lp lq lr b">$PGM</code>中)，而<code class="eh lo lp lq lr b">&lt;state/&gt;</code>单元是空映射(由<code class="eh lo lp lq lr b">.Map</code>表示)。</p><p id="bc0c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">转换由K重写规则指定。利用配置的嵌套结构，可以在配置中应用K规则的地方本地指定K规则，并且仅提及规则所需的配置部分。配置抽象负责填充其他部分(参见<a class="ae kq" href="http://www.kframework.org/index.php/K_Tutorial" rel="noopener ugc nofollow" target="_blank"> K教程</a>)。例如，用变量的值替换变量的语义由以下规则给出:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ls"><img src="../Images/903229a59121af28fd4f6d2749377837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oD1uxZcrPz34BIDA.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek"><em class="lx">The K rule defining semantics of program variables</em></figcaption></figure><p id="3047" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">当要评估标识符<code class="eh lo lp lq lr b">X</code>时，该规则适用(计算单元<code class="eh lo lp lq lr b">&lt;k/&gt;</code>中堆栈顶部的计算)。该规则将标识符与其在<code class="eh lo lp lq lr b">&lt;state/&gt;</code>单元格中的对应映射进行匹配，并将<code class="eh lo lp lq lr b">X</code>重写为其值<code class="eh lo lp lq lr b">I</code>。</p><p id="55cf" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">对于像IMP这样简单的语言，大多数规则甚至没有提到配置中的单元，只在要简化的计算结构上进行匹配。例如，IMP中的<code class="eh lo lp lq lr b">+</code>的语义由以下规则给出:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ls"><img src="../Images/906286ba86c36767ee10d1f02b768e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HAOUaOF8XGA5SddG.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek"><em class="lx">The K rule defining semantics of </em><code class="eh lo lp lq lr b"><em class="lx">+</em></code></figcaption></figure><p id="02fb" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">IMP中算术符号的语义是使用K对整数的内置运算来定义的，比如<code class="eh lo lp lq lr b">+Int</code>用于整数加法。</p><p id="8595" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">IMP的所有构造的语义由K中总共16个规则指定(大致每个构造一个规则，只有3个规则明确提到单元格)，可以在这里找到<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/k/imp.k#L39-L60" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="fd47" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">Coq中的执行规则</h1><p id="8fd4" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">因为IMP是确定性的，即每个IMP程序至多计算一个值，函数作为语言结构的表示就足够了。然而，关系更一般，能够表达计算的内部步骤，就像小步骤结构操作语义定义暴露了评估程序构造的各个步骤。更复杂的语言(如并发和多线程语言)更自然地使用关系来定义。例如，K规则中的重写箭头<code class="eh lo lp lq lr b">=&gt;</code>定义了一个关系。</p><p id="1db5" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">因此，在Coq中，IMP中算术表达式的语义由状态上的二元转换关系捕获，其中状态是由算术表达式<code class="eh lo lp lq lr b">AExp</code>和<code class="eh lo lp lq lr b">Env</code>组成的一对<code class="eh lo lp lq lr b">(AExp, Env)</code>，当前环境<code class="eh lo lp lq lr b">AExp</code>将在其中被评估。环境由一组将字符串(变量名)关联到整数常量(IMP中变量可以映射到的唯一值)的对来建模。</p><p id="9ee5" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这个二元转换关系可以在Coq中定义为一个归纳定义的命题(Prop类型)，<code class="eh lo lp lq lr b">step_e</code>，它告诉我们一个给定的状态对是否属于该关系。以下是<code class="eh lo lp lq lr b">step_e</code>定义的摘录(参见<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/coq/imp.v#L71-L92" rel="noopener ugc nofollow" target="_blank">完整定义</a>):</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ls"><img src="../Images/6bd084b6ff9b9432e805865a28c53a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HpRtt04QQjRJyAUp.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek"><em class="lx">The Coq rules defining semantics of arithmetic expressions</em></figcaption></figure><p id="a108" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">例如，<code class="eh lo lp lq lr b">step_var</code>声明程序变量<code class="eh lo lp lq lr b">var v</code>在环境<code class="eh lo lp lq lr b">env</code>中一步计算出其值<code class="eh lo lp lq lr b">con x</code>(<code class="eh lo lp lq lr b">x</code>是从函数应用<code class="eh lo lp lq lr b">get v env</code>中获得的整数值，<code class="eh lo lp lq lr b">v</code>在<code class="eh lo lp lq lr b">env</code>中映射到该值)，这适用于所有程序变量和环境(回想一下<code class="eh lo lp lq lr b">con</code>是整数常量的构造函数)。另一个例子是<code class="eh lo lp lq lr b">step_plus</code>的情况，它表示任何形式为<code class="eh lo lp lq lr b">plus (con x) (con y)</code>的算术表达式，其中加法的操作数已经被计算为常数值，在一个步骤中计算为操作数之和的值，而不管当前环境如何(<code class="eh lo lp lq lr b">Z.add</code>是整数加法运算)。注意<code class="eh lo lp lq lr b">step_plus</code>、<code class="eh lo lp lq lr b">cong_plus_r</code>和<code class="eh lo lp lq lr b">cong_plus_l</code>是如何共同指定<code class="eh lo lp lq lr b">plus</code>的按值调用语义的，这对应于上面突出显示的K的<code class="eh lo lp lq lr b">strict</code>注释。</p><p id="c466" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">除了为算术表达式赋予语义的<code class="eh lo lp lq lr b">step_e</code>之外，我们还定义了另外两个关系作为归纳定义的命题<code class="eh lo lp lq lr b">step_b</code>和<code class="eh lo lp lq lr b">step_s</code>，它们分别为IMP中的布尔表达式和语句赋予语义。它们的定义遵循与<code class="eh lo lp lq lr b">step_e</code>相似的结构。<code class="eh lo lp lq lr b">step_b</code>的定义使用<code class="eh lo lp lq lr b">step_e</code>的定义，例如用于定义关系运算符的语义，而<code class="eh lo lp lq lr b">step_s</code>的定义使用<code class="eh lo lp lq lr b">step_e</code>和<code class="eh lo lp lq lr b">step_b</code>，例如用于IMP的条件语句和迭代语句。</p><p id="99b2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">最后，为了给完整的IMP程序赋予语义(变量声明列表后面跟着用<code class="eh lo lp lq lr b">pgm</code>构造的程序语句)，我们引入了另一个关系<code class="eh lo lp lq lr b">step_p</code>，它是根据上面的关系<code class="eh lo lp lq lr b">step_s</code>定义的。程序关系<code class="eh lo lp lq lr b">step_p</code>首先通过用适当的映射增加状态环境来处理所有变量声明，然后使用<code class="eh lo lp lq lr b">step_s</code>来执行程序语句。本质上，<code class="eh lo lp lq lr b">step_p</code>定义了IMP的一步语义。</p><p id="1361" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这些关系的完整定义见<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/coq/imp.v#L71-L139" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h1 id="61d0" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">测试SUM上的执行</h1><p id="0b4b" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">在开始严格验证求和正确性属性之前，我们展示了这两个框架在测试程序执行方面的比较，这是建立对形式语言语义充分性的信心的必要步骤。</p><h1 id="daea" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">在K中测试</h1><p id="63c9" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">K中的规范可以立即执行，提供了一种定义语言解释器的机制，这些解释器可以用来制作程序动画，评估语言设计和语言定义的发展，几乎不需要额外的工作(除了定义语言规范本身)。</p><p id="9a5b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">假设imp的语言定义作为K模块保存在文件<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/k/imp.k" rel="noopener ugc nofollow" target="_blank"> imp.k </a>中，调用imp.k上的K编译器<code class="eh lo lp lq lr b">kompile</code>会为imp生成一个解析器和一个解释器，可以用来解析和执行IMP程序。</p><p id="f85c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">例如，对于<code class="eh lo lp lq lr b">n</code>初始100，我们使用<code class="eh lo lp lq lr b">sum_pgm 100</code>给出的SUM程序，并将其存储在文件<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/k/sum/sum.imp" rel="noopener ugc nofollow" target="_blank"> sum.imp </a>中。命令<code class="eh lo lp lq lr b">kast sum.imp</code>输出SUM的K抽象语法树(AST)。此外，用<code class="eh lo lp lq lr b">krun sum.imp</code>运行程序输出执行程序产生的最终配置，n映射到0，sum映射到5050(从1到100的所有数字的和，n的初始值)。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ls"><img src="../Images/2c94ffb0078e3f6a75c137cc99fc1c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cF8bbgoj-ujQeqan.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek"><em class="lx">The final K configuration resulting from executing SUM</em></figcaption></figure><p id="477d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">注意，<code class="eh lo lp lq lr b">&lt;k/&gt;</code>单元具有空计算值<code class="eh lo lp lq lr b">.</code>,表示程序已经完全执行。</p><p id="c6fa" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">K执行工具，尤其是那些基于<a class="ae kq" href="https://github.com/kframework/llvm-semantics" rel="noopener ugc nofollow" target="_blank"> K的LLVM后端</a>的工具，都是针对执行效率进行优化的。事实上，在某些情况下，K与<code class="eh lo lp lq lr b">krun</code>的执行速度比手写解释器更快，例如<a class="ae kq" href="https://runtimeverification.com/firefly/" rel="noopener ugc nofollow" target="_blank"> Firefly的</a> K runner与<code class="eh lo lp lq lr b">ganache-cli</code>中的<code class="eh lo lp lq lr b">ethereumjs</code>相比。</p><h1 id="c60f" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">Coq中的测试</h1><p id="3a7a" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">Coq不是设计来自动产生解释器的，但是一些机器检查代码如何在语义下执行的测试可以通过以定理的形式陈述例子来进行。</p><p id="1c23" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">回想一下，在我们的Coq模型中，IMP的SUM表示为一个类型为<code class="eh lo lp lq lr b">Pgm</code>的术语，我们将它命名为<code class="eh lo lp lq lr b">sum_pgm</code>，如下所示:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ls"><img src="../Images/cbbf58398e5cb34ca6cd95ba56b95670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bSbqWTNt2-ZR9Kow.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek"><em class="lx">Coq Definition of SUM</em></figcaption></figure><p id="1752" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">使用该模型，我们可以测试具有值100的<code class="eh lo lp lq lr b">n</code>的和，即项<code class="eh lo lp lq lr b">sum_pgm 100</code>，通过显示<code class="eh lo lp lq lr b">sum_pgm 100</code>展示了以具有空环境的状态开始并以具有映射到0的环境<code class="eh lo lp lq lr b">n</code>和映射到5050的<code class="eh lo lp lq lr b">sum</code>的状态结束的执行轨迹，产生预期的结果:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ls"><img src="../Images/f38575a520a6a113e03f9b04c9e6fece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bqcjoj6wsttFJmK3.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek"><em class="lx">Execution lemma in Coq of SUM</em></figcaption></figure><p id="a4ae" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">执行轨迹由关系<code class="eh lo lp lq lr b">step_p</code>的自反传递闭包构成，由Coq的归纳定义命题<code class="eh lo lp lq lr b">clos_refl_trans_1n</code>计算。注意，最终状态的程序是空操作命令<code class="eh lo lp lq lr b">skip</code>，要求程序已经完全执行。</p><p id="c10a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">完成证明需要为每个执行步骤选择正确的步骤关系子句。使用Coq的证明策略来自动搜索提供了某种形式的自动执行。这需要几秒钟来完成一百次循环迭代，因此性能很低，但对于简单的例子来说是可以忍受的(程序和证明可以在这里找到<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/coq/execution.v#L15-L22" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="5d79" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">Coq还有其他选择，可以用额外的开发人员工作来创建更快的解释器。<a class="ae kq" href="https://coq.inria.fr/refman/addendum/extraction.html" rel="noopener ugc nofollow" target="_blank">程序提取</a>可以将Coq语言中的函数翻译成其他语言的代码，比如OCaml或Haskell，它们有很好的本地代码编译器。这仍然不能从定义为谓词的转换关系中自动产生解释器。开发人员必须编写一个执行步骤的函数，并且应该证明它等价于关系定义。</p><p id="750f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">原则上，函数可以被认为是语言的主要定义，但这可能可读性较差，并且更难证明其属性。从<a class="ae kq" href="https://softwarefoundations.cis.upenn.edu/lf-current/ImpCEvalFun.html" rel="noopener ugc nofollow" target="_blank">教科书</a>到<a class="ae kq" href="http://compcert.inria.fr/doc/html/compcert.cfrontend.Csem.html" rel="noopener ugc nofollow" target="_blank"> CompCert </a>这样的大型项目，Coq中的标准实践是使用归纳定义的关系作为语言的基本定义，就像我们上面做的那样。在Coq中，为更快的执行提供一个替代函数，并证明其正确性，被认为是“执行优化”。</p><h2 id="16b2" class="ly ks ht bd kt lz ma mb kx mc md me lb kd mf mg ld kh mh mi lf kl mj mk lh ml dt translated">下一步:属性验证…</h2><p id="868b" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">我们现在有了IMP的正式模型，定义了它的语法和语义，以及SUM的正式表示。下一步也是最后一步是正式指定正确性属性并验证程序的正确性。这将在本帖的第三部分中描述。</p></div><div class="ab cl mm mn hb mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hm hn ho hp hq"><p id="b36b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><em class="mt">原载于2019年12月12日</em><a class="ae kq" href="https://runtimeverification.com/blog/k-vs-coq-as-language-verification-frameworks-part-2-of-3/" rel="noopener ugc nofollow" target="_blank"><em class="mt">https://runtimeverification.com</em></a><em class="mt">。</em></p><blockquote class="mu"><p id="0e5c" class="mv mw ht bd mx my mz na nb nc nd kp ek translated"><a class="ae kq" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nf ng nh ni nj jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ne"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff nk"><img src="../Images/a06b758bdcc47dca7c2504f298674d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_s6JsD3P0hVj32E7t9EtGg.jpeg"/></div></a></figure></div></div>    
</body>
</html>