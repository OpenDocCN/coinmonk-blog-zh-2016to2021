<html>
<head>
<title>Deploy a Kafka-based Hyperledger Fabric network with Docker Swarm on multiple hosts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在多台主机上使用Docker Swarm部署基于Kafka的Hyperledger结构网络</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/deploy-a-cross-machine-kafka-based-multi-orderer-hyperledger-fabric-network-with-docker-swarm-8ccdd76bae5?source=collection_archive---------1-----------------------#2019-09-07">https://medium.com/coinmonks/deploy-a-cross-machine-kafka-based-multi-orderer-hyperledger-fabric-network-with-docker-swarm-8ccdd76bae5?source=collection_archive---------1-----------------------#2019-09-07</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="bf15" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">很少有关于在多台主机、服务器或机器上创建Hyperledger结构网络的结构化教程。您只能在官方Hyperledger Fabric文档中找到构建单机网络的指南，该文档根本不是分布式和分散式的。今天，让我们一起来做吧！</p><h1 id="a24e" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">什么是Docker Swarm？</h1><p id="2680" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">Docker Swarm是一个集群管理工具，支持不同容器在不同机器上的通信。我们还将利用覆盖网络，它是Docker Swarm之上的一个连接层。更多信息可以在<a class="ae kr" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/swarm/</a>和<a class="ae kr" href="https://docs.docker.com/network/overlay/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/network/overlay/</a>找到</p><h1 id="9ed5" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">在我们开始之前…</h1><h2 id="6830" class="ks jp ht bd jq kt ku kv ju kw kx ky jy jb kz la kc jf lb lc kg jj ld le kk lf dt translated">必须做的事</h2><ol class=""><li id="b81e" class="lg lh ht is b it km ix kn jb li jf lj jj lk jn ll lm ln lo dt translated">你应该知道<a class="ae kr" href="https://www.youtube.com/watch?v=SSo_EIwHSd4" rel="noopener ugc nofollow" target="_blank">区块链是什么</a>吧？😉</li><li id="1bb7" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo dt translated">准备三个安装了Linux Ubuntu的云实例或计算机</li><li id="8ab8" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo dt translated">安装Docker引擎社区版最新版本</li><li id="0738" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo dt translated">安装Docker Compose最新版本</li><li id="f168" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo dt translated">安装节点v8.4.0(最好使用nvm)</li><li id="ea5a" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo dt translated">将这个<a class="ae kr" href="https://github.com/whchengaa/hyperledger-fabric-technical-tutorial" rel="noopener ugc nofollow" target="_blank"> github库</a>克隆到三台机器上，并切换到分支<code class="eh lu lv lw lx b">cross-machine-swarm</code></li></ol><h2 id="b1ed" class="ks jp ht bd jq kt ku kv ju kw kx ky jy jb kz la kc jf lb lc kg jj ld le kk lf dt translated">宁可</h2><ol class=""><li id="d9db" class="lg lh ht is b it km ix kn jb li jf lj jj lk jn ll lm ln lo dt translated">了解Hyperledger结构背后的<a class="ae kr" href="https://hyperledger-fabric.readthedocs.io/en/release-1.1/key_concepts.html" rel="noopener ugc nofollow" target="_blank">关键概念</a></li><li id="6b77" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo dt translated">完成官方文档中的<a class="ae kr" href="https://hyperledger-fabric.readthedocs.io/en/release-1.1/build_network.html" rel="noopener ugc nofollow" target="_blank">“构建您的第一个网络”</a>教程</li></ol><h2 id="0397" class="ks jp ht bd jq kt ku kv ju kw kx ky jy jb kz la kc jf lb lc kg jj ld le kk lf dt translated">注意</h2><p id="ed3e" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">它基于Hyperledger Fabric release-1.1，尽管最新版本应该也可以工作</p><h1 id="622d" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">网络体系结构</h1><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff ly"><img src="../Images/5cc0286d6f101ecad299341a5d19b243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bvoS5E-x6Zs7g7EvuLxTqQ.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Network Architecture</figcaption></figure><p id="d377" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">上图显示了整体网络架构。组织1和组织2组件分别位于机器1和机器2中。基于Kafka的订购服务由部署在三台机器上的组件组成。除了节点应用程序之外的所有组件都使用Docker进行容器化。除了MongoDB之外的所有容器都通过Docker Swarm overlay网络相互通信。</p><p id="9fd2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每个组件的功能:</p><ul class=""><li id="22dc" class="lg lh ht is b it iu ix iy jb mo jf mp jj mq jn mr lm ln lo dt translated">对等:区块链分类帐和链码引擎(智能合同)</li><li id="aeb3" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn mr lm ln lo dt translated">CouchDB:具有丰富查询功能的状态数据库</li><li id="1932" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn mr lm ln lo dt translated">CA:注册并登记新用户</li><li id="f61e" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn mr lm ln lo dt translated">MongoDB:存储用户凭证</li><li id="061d" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn mr lm ln lo dt translated">Orderer:对事务进行排序，并将它们打包到一个块中</li><li id="9a05" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn mr lm ln lo dt translated">卡夫卡:共识协议</li><li id="fd3a" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn mr lm ln lo dt translated">zookeeper:Kafka的注册和配置服务</li><li id="cd65" class="lg lh ht is b it lp ix lq jb lr jf ls jj lt jn mr lm ln lo dt translated">节点应用程序:与区块链交互的API服务器</li></ul><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff ms"><img src="../Images/0cf94538d9a90660a3cb7e013a7b8bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHnYhQEcJMXo4fBzWYevHg.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Firewall Setting</figcaption></figure><p id="7796" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">上面列出端口需要公开，以便于跨机器联网。</p><p id="b40c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="mt">警告:</em> </strong> MongoDB和Mongo Express不应该在生产环境中暴露给所有外部IP。</p><h1 id="2fd7" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">编辑网络配置文件</h1><p id="5512" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">在<code class="eh lu lv lw lx b">hyperledger-fabric-technical-tutorial/balance-transfer/artifacts/network-config.yaml</code>中，将orderer1和所有Org 2组件的默认IP地址更改为机器2的实际IP地址。</p><p id="7d37" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该文件为节点应用程序提供了Org 1、Org 2组件和两个订购者的网络信息，以便发出API请求。由于node app没有部署在Docker Swarm网络中，因此外部通信必须通过指定IP地址来完成。</p><p id="b671" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于node应用程序不直接与Kafka和Zookeeper集群通信，因此不包括它们的IP地址。</p><p id="fd31" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">MongoDB连接配置文件在<code class="eh lu lv lw lx b">org1.yaml</code>和<code class="eh lu lv lw lx b">org2.yaml</code>中编码。由于MongoDB和node app位于同一台机器上，使用localhost就足以进行它们的通信。</p><h1 id="4e12" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">建立码头群和覆盖网络</h1><p id="6021" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">在机器1中，运行<code class="eh lu lv lw lx b">docker swarm init</code>作为管理器初始化Swarm网络。它返回类似于下面的结果。</p><pre class="lz ma mb mc fq mu lx mv mw aw mx dt"><span id="5ca7" class="ks jp ht lx b fv my mz l na nb">docker swarm join --token SWMTKN-1–4bg8u1sjnk6sjegcdba5f03ij5yespoqn1g3qhji7hn213qyw0-ee8h9oinejen29d1t9r6pw4pf 172.0.0.71:2377</span></pre><p id="b7f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在机器1终端中复制命令，并在机器2和机器3中运行，以加入群网络。以下是成功回复。</p><pre class="lz ma mb mc fq mu lx mv mw aw mx dt"><span id="a50b" class="ks jp ht lx b fv my mz l na nb">This node joined a swarm as a worker.</span></pre><p id="71f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在机器1中运行<code class="eh lu lv lw lx b">docker node ls</code>来列出群网络节点。您应该会看到三个节点。</p><p id="6a72" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在机器1中，运行<code class="eh lu lv lw lx b">docker network create --attachable --driver overlay fabric_net</code>创建名为fabric_net的覆盖网络。</p><p id="18f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在所有三台机器中运行<code class="eh lu lv lw lx b">docker network ls</code>。只有机器1显示了fabric_net，因为覆盖网络只能通过引入加入该覆盖网络的docker容器来扩展到其他节点。</p><p id="6908" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在机器2和机器3中，运行<code class="eh lu lv lw lx b">docker run -itd --name mybusybox --network fabric_net busybox</code>创建一个连接fabric_net的busybox docker容器。其实是不是busybox并不重要，调出任何一个加入fabric_net的容器都可以有同样的效果。</p><p id="0b6f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在2号机和3号机中再次运行<code class="eh lu lv lw lx b">docker network ls</code>，查看fabric_net是否存在。</p><p id="0ad6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果有任何错误，在所有三台机器上运行<code class="eh lu lv lw lx b">sudo systemctl restart docker</code>重新启动Docker引擎或在所有三台机器上运行<code class="eh lu lv lw lx b">docker swarm leave --force</code>离开Swarm网络并再次重复上述过程。</p><h1 id="ac9b" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">网络组件部署</h1><p id="e3d5" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">运行<code class="eh lu lv lw lx b">hyperledger-fabric-technical-tutorial/balance-transfer/</code>目录下的所有命令。</p><p id="45ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于所有机器，</p><p id="b589" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">移除所有现有容器以避免RAM过载。(确保没有其他重要的容器在运行)</p><pre class="lz ma mb mc fq mu lx mv mw aw mx dt"><span id="cd5c" class="ks jp ht lx b fv my mz l na nb">docker rm -f `docker ps -aq`</span></pre><p id="2065" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">清除未使用的Docker卷</p><pre class="lz ma mb mc fq mu lx mv mw aw mx dt"><span id="8aa1" class="ks jp ht lx b fv my mz l na nb">docker volume prune –f</span></pre><p id="092a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">移除缓存的Docker链码图像</p><pre class="lz ma mb mc fq mu lx mv mw aw mx dt"><span id="3276" class="ks jp ht lx b fv my mz l na nb">docker rmi -f $(docker images | grep “dev\|none\|test-vp\|peer[0–9]-” | awk ‘{print $3}’)</span></pre><p id="a1c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于机器3，</p><pre class="lz ma mb mc fq mu lx mv mw aw mx dt"><span id="abc9" class="ks jp ht lx b fv my mz l na nb">docker-compose -f artifacts/docker-compose-kafka.yaml up -d zookeeper0 zookeeper1</span><span id="3225" class="ks jp ht lx b fv nc mz l na nb">docker-compose -f artifacts/docker-compose-kafka.yaml up -d kafka0 kafka1</span><span id="feb6" class="ks jp ht lx b fv nc mz l na nb">docker-compose -f artifacts/docker-compose.yaml up -d orderer1.example.com</span></pre><p id="1619" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于机器2，</p><pre class="lz ma mb mc fq mu lx mv mw aw mx dt"><span id="7b65" class="ks jp ht lx b fv my mz l na nb">docker-compose -f artifacts/docker-compose-kafka.yaml up -d zookeeper2</span><span id="df30" class="ks jp ht lx b fv nc mz l na nb">docker-compose -f artifacts/docker-compose-kafka.yaml up -d kafka2 kafka3</span><span id="a731" class="ks jp ht lx b fv nc mz l na nb">docker-compose -f artifacts/docker-compose.yaml up -d peer0.org2.example.com peer1.org2.example.com ca.org2.example.com couchdb0.org2 couchdb1.org2</span></pre><p id="16a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于机器1，</p><pre class="lz ma mb mc fq mu lx mv mw aw mx dt"><span id="d674" class="ks jp ht lx b fv my mz l na nb">docker-compose -f artifacts/docker-compose.yaml up -d orderer0.example.com</span><span id="3463" class="ks jp ht lx b fv nc mz l na nb">docker-compose -f artifacts/docker-compose.yaml up -d peer0.org1.example.com peer1.org1.example.com ca.org1.example.com couchdb0.org1 couchdb1.org1</span><span id="a236" class="ks jp ht lx b fv nc mz l na nb">docker-compose -f artifacts/docker-compose-mongo.yaml up –d</span><span id="6e9f" class="ks jp ht lx b fv nc mz l na nb">npm install</span><span id="fee7" class="ks jp ht lx b fv nc mz l na nb">node app</span></pre><p id="8a86" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您的机器中没有docker图像，docker引擎将从互联网上获取所有图像。</p><p id="a1fd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于执行序列，应该首先部署zookeeper，然后是kafka和其他人。</p><h1 id="49e5" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">测试</h1><p id="b910" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">在机器1中打开一个新终端并运行<code class="eh lu lv lw lx b">./testAPIs.sh -l node</code>。</p><h1 id="0645" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">如果没有错误，恭喜！</h1><p id="12b3" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">您成功部署了跨机器Hyperledger Fabric网络！</p><p id="fb9a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你想了解更多关于源代码的内容，你可以从<a class="ae kr" href="https://github.com/whchengaa/hyperledger-fabric-technical-tutorial" rel="noopener ugc nofollow" target="_blank"> github库</a>的<code class="eh lu lv lw lx b">release-1.1</code>分支下下载“中级开发者Hyperledger Fabric技术指南. docx”。如果你遇到任何问题，随时联系我！</p><p id="3bd2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后但同样重要的是，如果你喜欢这个帖子，请为它鼓掌！:)</p><blockquote class="nd"><p id="108a" class="ne nf ht bd ng nh ni nj nk nl nm jn ek translated"><a class="ae kr" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="no np nq nr ns md fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nn"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>