<html>
<head>
<title>My First “Real” Magic Leap Project: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的第一个“真正的”Magic Leap项目:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/my-first-real-magic-leap-project-part-2-571d1017cda2?source=collection_archive---------5-----------------------#2018-08-03">https://medium.com/coinmonks/my-first-real-magic-leap-project-part-2-571d1017cda2?source=collection_archive---------5-----------------------#2018-08-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="843f" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">我们实现了许多应用程序状态来构建网格。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/b7dc1f5b89dedaf0de49feb08c40382c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*72Bu1iSGyUgQhzxJnXcLRg.jpeg"/></div></div></figure><p id="1d2b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">本文是从我的第一个“真正的”Magic Leap项目开始的系列文章的一部分:第一部分 。</p><p id="a4c1" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><strong class="jw hu">构建网格</strong></p><p id="06a8" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">当使用<em class="kr"> MLSpatialMapper </em>时，可以观察到其<em class="kr">变换</em>组件定义了网格对象将被构建<strong class="jw hu">和保留</strong>的体积。考虑到这一点，应用程序的第一步是让用户定义这个卷。</p><p id="2df2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">应用程序开始时<em class="kr"> MLSpatialMapper </em>被禁用，并处于<em class="kr">定位</em>状态，用户使用控制器(左手)定位半透明的蓝色立方体。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/164ca3f03f2432c9364ef4b4ab002937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ed4S8n5l7BqAPO243gKRPA.png"/></div></div></figure><p id="d990" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">通过用右手给出一个<em class="kr"> Ok </em>手姿势，用户将状态改变为<em class="kr">缩放</em>，其中用户使用控制器(在左手)来缩放立方体。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/3c4ee095f2db42591f618bb269717049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BlY-9DMVHVyWtsUdLFNI1w.png"/></div></div></figure><p id="5fd5" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">通过用右手给出一个<em class="kr"> Ok </em>手姿势，用户改变状态为<em class="kr">啮合；</em>隐藏立方体并启用<em class="kr"> MLSpatialMapper。</em>此时，<em class="kr"> MLSpatialMapper </em>将开始在体积中建立网格对象。</p><p id="3e86" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><strong class="jw hu">注</strong>:在模拟器中，网格对象的构建与用户的视野无关；就硬件而言，我认为它们只有在需要的时候才会被制造出来。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/684d59ab650d6ffac4d55e28718d6b1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ekBZAS6-gBB-mDhkQlAjzQ.png"/></div></div></figure><p id="3f58" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">实现这个功能相当于在场景中创建一个半透明的蓝色立方体(<em class="kr"> MeshingZone </em>)，移除不必要的<em class="kr"> Box Collider </em>组件，并添加以下组件。</p><p id="4af9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><em class="kr">Assets/Table/meshing zone . cs</em></p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ks kt l"/></div></figure><p id="b968" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">观察结果:</p><ul class=""><li id="6619" class="ku kv ht jw b jx jy ka kb kd kw kh kx kl ky kp kz la lb lc dt translated">将所有的实现放在一个文件中是非常简单的</li><li id="dc7f" class="ku kv ht jw b jx ld ka le kd lf kh lg kl lh kp kz la lb lc dt translated">这个文件中的关注点(应用程序状态、输入、hands、立方体和<em class="kr"> MLSpatialMapper </em>)的数量已经有点多了</li><li id="516f" class="ku kv ht jw b jx ld ka le kd lf kh lg kl lh kp kz la lb lc dt translated">当我们添加额外的游戏组件时；继续使用这种方法将无法很好地扩展</li></ul><p id="094b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><strong class="jw hu">状态管理</strong></p><p id="e64c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在这一点上，很明显，在前进之前实施状态管理策略是至关重要的。</p><p id="dc3b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">通过一点研究(<em class="kr"> Google </em>)和查看<em class="kr"> Magic Leap的</em> <a class="ae kq" href="https://creator.magicleap.com/learn/guides/magickit-dodge-project-files" rel="noopener ugc nofollow" target="_blank"> <em class="kr"> Dodge </em> </a>例子，一个流行的状态管理策略是使用有限状态机。这里的挑战是，似乎每个人都有自己的实现。</p><p id="d5c8" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">同样，我已经使用从web开发中借用的概念实现了一个类似的模式(<a class="ae kq" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> <em class="kr"> Redux </em> </a>)，并将继续使用这种方法。</p><div class="li lj fm fo lk ll"><a rel="noopener follow" target="_blank" href="/@johntucker_48673/unity-declarative-approach-borrowed-from-web-development-5f66ff179217"><div class="lm ab ej"><div class="ln ab lo cl cj lp"><h2 class="bd hu fv z el lq eo ep lr er et hs dt translated">Unity:从Web开发中借鉴的声明式方法</h2><div class="ls l"><h3 class="bd b fv z el lq eo ep lr er et ek translated">通过示例，我们探讨了编写声明性Unity代码的相关问题。最后，我们展示了一个受启发的模式…</h3></div><div class="lt l"><p class="bd b gc z el lq eo ep lr er et ek translated">medium.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz js ll"/></div></div></a></div><p id="188b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><strong class="jw hu">下一步</strong></p><p id="eb53" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在下一篇文章中，<a class="ae kq" rel="noopener" href="/@johntucker_48673/my-first-real-magic-leap-project-part-3-4691a7fc8329"> <em class="kr">我的第一个“真正的”Magic Leap项目:第3部分</em> </a>，我们使用类似于<em class="kr"> Redux </em>的状态管理策略重构当前的实现。</p></div></div>    
</body>
</html>