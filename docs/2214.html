<html>
<head>
<title>Demystifying Hyperledger Fabric (2/3): Private Data Collection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Hyperledger结构的神秘面纱(2/3):私人数据收集</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/demystifying-hyperledger-fabric-2-3-private-data-collection-164220ecafa5?source=collection_archive---------0-----------------------#2019-05-15">https://medium.com/coinmonks/demystifying-hyperledger-fabric-2-3-private-data-collection-164220ecafa5?source=collection_archive---------0-----------------------#2019-05-15</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/a987cba6934a320f70c732e9712643ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQZbuJ-OGIjfKsX8vzZatQ.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek"><a class="ae jf" href="https://www.hyperledger.org/projects/fabric" rel="noopener ugc nofollow" target="_blank">www.hyperledger.org/projects/fabric</a></figcaption></figure><p id="8383" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="ke">最初发表于</em><a class="ae jf" href="https://www.serial-coder.com/post/demystifying-hyperledger-fabric-private-data-collection/" rel="noopener ugc nofollow" target="_blank"><em class="ke">【www.serial-coder.com】</em></a><em class="ke">。</em></p><p id="083b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">欢迎来到<strong class="ji hu"> <em class="ke">揭秘Hyperledger面料系列</em> </strong>第二篇。本文假设读者已经了解<em class="ke"> Hyperledger Fabric架构</em>。如果你看过这篇文章，我建议你先看看<a class="ae jf" rel="noopener" href="/p/a2fdb587f6cb">上一篇文章</a>。</p><p id="5147" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在上一篇文章中，您已经学习了Hyperledger Fabric 的<em class="ke">基本架构。在本文中，您将了解到Fabric的另一个关键特性，称为<strong class="ji hu"> <em class="ke">私有数据收集</em> </strong>。</em></p><p id="7d16" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在Fabric版之前，当一组组织需要对加入同一通道的其他组织保密数据时，该组织子集必须创建一个新的单独通道。这导致了额外的管理开销，例如管理链码、背书策略、会员服务提供商配置等。此外，分离一个新的通道不能处理这样的情况，即一些组织可能需要保留一部分私有数据，但与其他组织共享其余的数据。</p><p id="cb9c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> <em class="ke">私有数据收集</em> </strong> <em class="ke"> </em>在Hyperledger Fabric版本中推出。通过此功能，被视为私有的数据可以配置为仅与授权组织共享，而公共数据可以在一个通道上与所有组织共享，而无需创建单独的通道。此外，该特征还使私人数据对订购服务保密，订购服务可能由未被授权查看数据的组织控制。</p><p id="4e3b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">本文的其余部分组织如下:</p><ul class=""><li id="0ff9" class="kf kg ht ji b jj jk jn jo jr kh jv ki jz kj kd kk kl km kn dt translated"><a class="ae jf" rel="noopener" href="/p/164220ecafa5#7a9b">隐私数据收集概述</a></li><li id="b739" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated"><a class="ae jf" rel="noopener" href="/p/164220ecafa5#581b">隐私数据收集的底层机制</a></li><li id="9541" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated"><a class="ae jf" rel="noopener" href="/p/164220ecafa5#67b3">带有私有数据的事务调用工作流</a></li><li id="5d73" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated"><a class="ae jf" rel="noopener" href="/p/164220ecafa5#4a4d">私有数据清除</a></li><li id="37a8" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated"><a class="ae jf" rel="noopener" href="/p/164220ecafa5#12ea">总结</a></li></ul></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><p id="7a9b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">隐私数据收集概述</strong></p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div class="fe ff la"><img src="../Images/13bac509ba4d5b22df94c97f380cc067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*C4TsYgKiKfiznWbCdDswQg.png"/></div><figcaption class="jb jc fg fe ff jd je bd b be z ek"><strong class="bd lf">Figure 1. Peer’s ledger enabled for Private Data Collection use</strong></figcaption></figure><p id="397f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> <em class="ke"> Fabric Peer </em> </strong>的<em class="ke">底层总账</em>启用<em class="ke">私有数据收集</em>使用<em class="ke"> </em>如图1所示。通常情况下，<strong class="ji hu"> <em class="ke">同行</em> </strong>的<em class="ke">总账</em>与<em class="ke">私有数据收集</em>使能<em class="ke"> </em>包括如下两个原语部分。</p><p id="9246" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">第一部分是<em class="ke">公共数据区</em>，它存储特定通道的所有公共数据和交易。<em class="ke">公共数据段</em>由两个实体组成，包括<em class="ke">公共块存储</em>和<em class="ke">公共状态数据库</em>，如图1上半部分所示。</p><p id="a0ba" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">具体来说，<strong class="ji hu"> <em class="ke">公共块存储</em> </strong>是一个区块链，它保存在通道上实例化的每个链代码的所有公共事务的历史。<strong class="ji hu"> <em class="ke">公共状态数据库</em> </strong>是一个全局状态存储器，为特定链码维护公共变量的当前状态。对于任何特定的通道，即<em class="ke"/><em class="ke">公共数据段</em>仅包含单个<strong class="ji hu"> <em class="ke">公共块存储实例</em> </strong>但是<em class="ke">段</em><em class="ke"/>可以包含多个<strong class="ji hu"> <em class="ke">公共状态数据库实例</em> </strong>基于在一个通道上实例化的多个<em class="ke">链码</em>。</p><p id="2c22" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">第二部分是<em class="ke">私有数据部分</em>，存储特定通道的所有私有数据和事务。<em class="ke">私有数据部分</em>由三个实体组成，包括<em class="ke">私有写集存储</em>、<em class="ke">私有状态数据库</em>和<em class="ke">临时存储数据库</em>，如图1的下半部分所示。</p><p id="2a54" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> <em class="ke">私有写集存储</em> </strong>为特定的<em class="ke">私有数据收集</em>收集所有私有事务的历史。每个<strong class="ji hu"> <em class="ke">对等</em> </strong>的<em class="ke">分类帐</em>可以包含多个<strong class="ji hu"> <em class="ke">私有写集存储实例</em> </strong>，这取决于为该<strong class="ji hu"> <em class="ke">特定对等</em> </strong>配置的多个<em class="ke">私有集合</em>。实际上，这种存储不是区块链，而是一种典型的日志持久数据库。</p><p id="e39c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> <em class="ke">私有状态数据库</em> </strong>是一个世界状态存储器，为一个特定的<em class="ke">私有集合</em>保存私有变量的当前状态。类似于<em class="ke">私有写集存储</em>的情况，多个<strong class="ji hu"> <em class="ke">私有状态数据库实例</em> </strong>可以由<strong class="ji hu"> <em class="ke">对等</em> </strong>的<em class="ke">分类帐</em>维护，依赖于为那个<strong class="ji hu"> <em class="ke">特定对等</em> </strong>配置的多个<em class="ke">私有集合</em>。</p><p id="4aa1" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="ke">私有数据段</em>中的最后一个实体是<strong class="ji hu"> <em class="ke">暂存数据库</em> </strong> <em class="ke">。</em>这种存储用作临时数据库，用于在事务调用过程中临时存储<em class="ke">私有数据</em>。稍后将解释关于<strong class="ji hu"> <em class="ke">暂时存储数据库</em> </strong>的更多细节。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lg"><img src="../Images/02c001d4ab6ff7f469231b2739b49f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lh-JNG70osIs9KhRU_QdBw.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek"><strong class="bd lf">Figure 2. Peers maintaining multiple Private Data Collections</strong></figcaption></figure><p id="eb51" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">任何<em class="ke">单个</em>链码都可以引用多个<strong class="ji hu"> <em class="ke">私有数据集合</em> </strong>。图2示出了来自不同组织的三个对等体在同一信道上引用<em class="ke">两个私有数据集合</em>。可以看到，<strong class="ji hu"> <em class="ke">所有三个对等体</em> </strong>都为<em class="ke">私有集合1号</em>维护了<em class="ke">私有状态数据库实例</em>。同时，<em class="ke">私有集合2号</em>的<em class="ke">私有状态数据库实例</em>仅由<strong class="ji hu"> <em class="ke"> Org1 </em> </strong>的<em class="ke">同级</em>和<em class="ke"> Org2 </em> 的<em class="ke">同级</em>私有管理。</p><p id="d67e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">有趣的是，<strong class="ji hu"> <em class="ke">公共状态数据库</em> </strong>通常存储特定链码的公共变量的当前状态。无论如何，这个数据库也存储与特定链码相关的修改过的私有数据集的散列。换句话说，私有数据的<em class="ke">散列将与公共数据一样被签署、排序并提交到通道上每个对等体的分类帐中。在将私有数据更新到每个授权对等体的分类帐中之前，该散列用于状态验证。哈希还用作审计目的的交易证据。这方面的更多内容将在后面讨论。</em></p><p id="89ed" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">尽管私有数据的<em class="ke">散列将被公开存储在通道上，但是没有未经授权的对等体可以将散列还原为原始内容。</em></p><figure class="lb lc ld le fq iu"><div class="bz el l di"><div class="lh li l"/></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Example of Private Data Collection definitions</figcaption></figure><p id="2e36" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">图2中的<strong class="ji hu"> <em class="ke">私有数据集合</em> </strong>可以转换成上面代码片段中的配置文件。然而，这篇文章不会涉及配置细节，只是给你一个如何配置<em class="ke">私有数据收集</em>的概念。如果你需要了解更多，请参考<a class="ae jf" href="https://hyperledger-fabric.readthedocs.io/en/latest/private-data-arch.html" rel="noopener ugc nofollow" target="_blank">这个链接</a>。</p><p id="6370" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们重点关注名为<strong class="ji hu"> <em class="ke"> policy </em> </strong>的集合属性。此属性定义允许哪些组织的对等方保留收集数据。换句话说，<strong class="ji hu"> <em class="ke">任何私有数据集合</em> </strong>都将根据这个<strong class="ji hu"> <em class="ke">策略</em> </strong>属性存储在授权对等体上。此外，为了使<em class="ke">私有集合</em>彼此保密，每个对等体将在<strong class="ji hu"> <em class="ke">独立私有状态数据库实例</em> </strong>以及<strong class="ji hu"> <em class="ke">独立私有写集存储实例</em> </strong>上存储<strong class="ji hu"> <em class="ke">不同集合</em> </strong>。</p></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><p id="581b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">隐私数据收集的底层机制</strong></p><p id="e5c7" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">本节将详细讨论<em class="ke">私有数据收集</em>的底层机制。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lj"><img src="../Images/cff90be22b00dcfa143e847e39dce3ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1hV4V1PrOei6tQC6adNvg.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek"><strong class="bd lf">Figure 3. Endorsement phase of the transaction invocation with Private Data</strong></figcaption></figure><p id="77c6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">带有私有数据的事务调用的认可阶段可以根据图3来描述。与正常的交易建议一样，<em class="ke">带有私有数据的交易建议</em>将在<strong class="ji hu"> <em class="ke">客户端</em> </strong>生成(图3中<em class="ke">步骤1 </em>)。然而，事务提议的有效载荷将由两部分组成，包括<em class="ke">函数参数</em>和<em class="ke">瞬态数据</em>。</p><p id="1504" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> <em class="ke">函数参数</em> </strong>包含公共链码函数参数，就像普通的事务建议一样。鉴于<strong class="ji hu"> <em class="ke">瞬态数据</em> </strong>包含私有数据参数，这些私有数据参数既不会被处理并存储到<strong class="ji hu"> <em class="ke">公共块存储</em> </strong>中，也不会被存储到<strong class="ji hu"> <em class="ke">公共状态数据库</em> </strong>中。换句话说，没有未经授权的对等方能够访问私有数据。</p><p id="fa0e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然后，生成的交易提议将被提交给选定的<strong class="ji hu"> <em class="ke">签署对等方</em> </strong>，以便模拟并签署它(图3中的<em class="ke">步骤2 </em>)。交易模拟过程结束后，包含实际私有模拟数据的某部分模拟结果称为<strong class="ji hu"> <em class="ke">私有读写集</em> </strong>将被临时存储到<strong class="ji hu"> <em class="ke">暂存数据库</em> </strong>中的每个<strong class="ji hu"> <em class="ke">背书对等</em> </strong>的<em class="ke">总账</em>(图3中的<em class="ke">步骤3 </em>)中。</p><p id="2aa0" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">每个<strong class="ji hu"> <em class="ke">背书的同行</em> </strong>依次、 尝试将生成的<strong class="ji hu"> <em class="ke">私有读写集</em> </strong>通过<em class="ke">八卦数据传播协议</em>传播给至少<strong class="ji hu"><em class="ke"/></strong>n个<em class="ke">授权组织</em>内的其他集合成员对等体(图3中的<em class="ke">步骤4 </em> 其中<strong class="ji hu"> <em class="ke"> n </em> </strong>是在背书时<strong class="ji hu"> <em class="ke">私有数据</em> </strong>需要分发到的成员对等体的最小数量(值<strong class="ji hu"><em class="ke"/></strong>由<em class="ke">私有数据收集定义</em>中指定的属性<strong class="ji hu"><em class="ke">required peercount</em></strong>控制)。</p><p id="61de" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">上述步骤对于数据冗余非常重要。如果<strong class="ji hu"> <em class="ke">认可对等体</em> </strong>在事务提交时间期间变得不可用，则作为集合成员但在认可时间尚未接收到<strong class="ji hu"> <em class="ke">私有读写集</em> </strong>的其他对等体将能够从<em class="ke">对等体</em>中拉出此<strong class="ji hu"> <em class="ke">私有数据</em> </strong>即<strong class="ji hu"> <em class="ke">私有数据</em> </strong></p><p id="14a9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> <em class="ke">认可对等体</em> </strong>将认可提议响应，当且仅当它能够成功地将<strong class="ji hu"> <em class="ke">私有读写集</em> </strong>分发给至少<strong class="ji hu"> <em class="ke"> n个</em> </strong>其他集合成员对等体。接下来，被认可的提议响应被发送回<strong class="ji hu"> <em class="ke">客户端</em> </strong>(图3中的<em class="ke">步骤5 </em>)。被认可的提议响应将包含两部分信息，即<em class="ke">公共读写集</em>和<em class="ke">私有读写集</em>的哈希。</p><p id="27b4" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> <em class="ke">公共读写集</em> </strong>包含与被调用事务相关的公共变量的变化列表。私有读写集 的<strong class="ji hu">Hash是之前已经存储在<strong class="ji hu"> <em class="ke">临时存储数据库</em> </strong>中的私有变量修改列表的Hash值(图3中<em class="ke">步骤3 </em>)。私有读写集 </strong>的<strong class="ji hu"> <em class="ke"> hash将用于状态验证，然后将私有数据更新到每个授权对等体的账本中。建议响应的这两个部分将被排序、验证并提交到<strong class="ji hu"> <em class="ke">公共块存储</em> </strong>和<strong class="ji hu"> <em class="ke">公共状态数据库</em> </strong>。</em></strong></p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lk"><img src="../Images/22f77d318750aea13974ba51700db141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yHz_IJs_RJThrLmJyhbbJw.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek"><strong class="bd lf">Figure 4. Ordering and validation-commitment phases of the transaction invocation with Private Data</strong></figcaption></figure><p id="ab96" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">带有私有数据的事务调用的排序和确认提交阶段可以根据图4进行描述。在交易提议已经被<strong class="ji hu"> <em class="ke">认可对等方</em></strong><strong class="ji hu"><em class="ke">客户端</em> </strong>生成与<em class="ke">组被认可的提议响应</em>捆绑的交易，然后将该交易发送给<strong class="ji hu"> <em class="ke">订购方</em> </strong>(图4中的<em class="ke">步骤1 </em>)。</p><p id="8ae9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">接下来，<strong class="ji hu"> <em class="ke">排序器</em> </strong>对接收到的事务(包括其他事务)进行排序，生成一个新的有序事务块，并将生成的块分发给通道上的所有<strong class="ji hu"><em class="ke"/></strong>【对等体】(图4中的<em class="ke">步骤2 </em>)。</p><p id="9006" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然后，每个<strong class="ji hu"> <em class="ke">对等</em> </strong>逐个处理接收到的块中的每个事务。也就是说，每个<strong class="ji hu"><em class="ke"/></strong>对等体对照其本地<strong class="ji hu"> <em class="ke">公共状态数据库</em> </strong>验证事务的<em class="ke">公共读集</em>，并将事务的<em class="ke">公共写集</em>提交到其本地<strong class="ji hu"> <em class="ke">公共块存储</em> </strong> <em class="ke"> </em>以及更新</p><p id="43c5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">接下来，每个<strong class="ji hu"> <em class="ke">对等</em> </strong>检测到正在处理的事务包含私有读写集合 的<strong class="ji hu"> <em class="ke">哈希。如果任何<strong class="ji hu"> <em class="ke">对等体</em> </strong>发现它是被授权查看该确切私有数据集合的成员，那么<strong class="ji hu"> <em class="ke">对等体</em> </strong>将使用<strong class="ji hu"> <em class="ke">散列值</em> </strong>来验证存储在其<strong class="ji hu"> <em class="ke">临时存储数据库</em> </strong>中的<strong class="ji hu"> <em class="ke">确切私有读写集合</em> </strong>的存在。</em></strong></p><p id="15b5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果<strong class="ji hu"/><strong class="ji hu"><em class="ke"/> </strong>中存在<strong class="ji hu"> <em class="ke">精确私有读写集</em><em class="ke">，对等</em></strong>将对照<strong class="ji hu"> <em class="ke">私有状态数据库</em> </strong>验证<strong class="ji hu"><em class="ke"/></strong>，并将<strong class="ji hu"> <em class="ke">私有写集</em> </strong>提交到其<strong class="ji hu"> <em class="ke">私有写中最后，<strong class="ji hu"> <em class="ke">对等</em> </strong>将<strong class="ji hu"> <em class="ke">私有读写集</em> </strong>从<strong class="ji hu"> <em class="ke">暂态存储数据库</em> </strong>(图4中<em class="ke">步骤4 </em>)中移除。</em></strong></p><p id="dcc0" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果有任何<strong class="ji hu"> <em class="ke">对等体</em> </strong>是精确私有数据集合的<em class="ke">成员，但在背书时缺少<strong class="ji hu"> <em class="ke">精确私有读写</em> </strong> <strong class="ji hu"> <em class="ke">集合</em> </strong>，则<strong class="ji hu"> <em class="ke">对等体</em> </strong>将发送对<strong class="ji hu"> <em class="ke">缺少私有读写集合【的pull请求<strong class="ji hu"> <em class="ke">请求的私有读写集合</em> </strong>将通过gossip协议被传送到<strong class="ji hu"> <em class="ke">请求对等体</em> </strong>并临时存储到其<strong class="ji hu"> <em class="ke">临时存储数据库</em> </strong>(图4中的<em class="ke">步骤6 </em>)。</em></strong></em></p><p id="4c21" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">稍后，<strong class="ji hu"> <em class="ke">中的对等</em> </strong>将验证<strong class="ji hu"> <em class="ke">收到的私有读写设置</em> </strong>与<strong class="ji hu"> <em class="ke">对应的哈希</em> </strong>。如果验证成功，<strong class="ji hu"> <em class="ke">对等体</em> </strong>对照其<strong class="ji hu"> <em class="ke">私有状态数据库</em> </strong>验证<strong class="ji hu"> <em class="ke">接收的私有读集</em> </strong>，并将<strong class="ji hu"> <em class="ke">私有写集</em> </strong>提交到其<strong class="ji hu"> <em class="ke">私有写集存储器</em> </strong>中。<strong class="ji hu"><em class="ke"/></strong>对等体也更新<strong class="ji hu"><em class="ke"/></strong>私有状态数据库，并最终从<strong class="ji hu"> <em class="ke">临时存储数据库</em> </strong>中删除<strong class="ji hu"><em class="ke"/></strong>(图4中<em class="ke">步骤7 </em>)。</p></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><p id="67b3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">私有数据的事务调用工作流</strong></p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ll"><img src="../Images/a5e89965698b885b010fb210ceb1cda3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OfRAqzM3CP6W24kmMJDBKQ.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek"><strong class="bd lf">Figure 5. The invocation workflow of the transaction with Private Data</strong></figcaption></figure><p id="f421" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">图5简要总结了使用私有数据进行Fabric事务调用的分步工作流:</p><ol class=""><li id="fe44" class="kf kg ht ji b jj jk jn jo jr kh jv ki jz kj kd lm kl km kn dt translated"><strong class="ji hu"> <em class="ke">客户端</em> </strong>做出包含<em class="ke">函数参数</em>和<em class="ke">瞬态数据</em>的交易提议，用<strong class="ji hu"> <em class="ke">用户</em> </strong>的证书对该提议进行签名，并将该交易提议发送到一组预先确定的<strong class="ji hu"> <em class="ke">背书对等体</em> </strong>上的<strong class="ji hu"> <em class="ke"> </em> </strong>特定通道。</li><li id="6c95" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd lm kl km kn dt translated">每个<strong class="ji hu"> <em class="ke">认可对等</em> </strong>从提案有效负载中验证<strong class="ji hu"> <em class="ke">用户</em> </strong>的身份和授权。如果验证检查通过，<strong class="ji hu"> <em class="ke">签核方</em> </strong>模拟交易。<strong class="ji hu"> <em class="ke">私有读写设置</em> </strong>从模拟结果被存储到<strong class="ji hu"> <em class="ke">暂存数据库</em> </strong>内<strong class="ji hu"> <em class="ke">对等</em> </strong>的<em class="ke">台账</em>。</li><li id="2d40" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd lm kl km kn dt translated">每个<strong class="ji hu"> <em class="ke">认可对等体</em> </strong>通过八卦协议将<strong class="ji hu"> <em class="ke">私有读写集</em> </strong>传播给其他<strong class="ji hu"> <em class="ke">授权对等体</em> </strong>用于数据冗余目的。</li><li id="1dd6" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd lm kl km kn dt translated">一旦<em class="ke">个私有数据传播成功</em>达到在<em class="ke">私有数据收集定义</em>、<strong class="ji hu">、<em class="ke">认可对等体</em>、</strong>中指定的最小所需计数，则生成包括私有读写集合、的<strong class="ji hu">、<em class="ke">散列的提议响应。然后，<strong class="ji hu"> <em class="ke">认可对等体</em> </strong>使用其证书对生成的响应进行认可，并最终将生成的响应发送回<strong class="ji hu"> <em class="ke">客户端</em> </strong>。</em></strong></li><li id="640e" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd lm kl km kn dt translated"><strong class="ji hu"> <em class="ke">客户端</em> </strong>累积并检查来自<strong class="ji hu"> <em class="ke">签核同行</em> </strong>的签核提案响应。然后，<strong class="ji hu"> <em class="ke">客户</em> </strong>向<strong class="ji hu"> <em class="ke">订购方</em> </strong>提交附有已背书的提案回复的交易。</li><li id="8cd9" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd lm kl km kn dt translated"><strong class="ji hu"> <em class="ke">排序器</em> </strong>对接收到的事务进行排序，生成新的有序事务块，并用其证书对生成的块进行签名。</li><li id="1b35" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd lm kl km kn dt translated"><strong class="ji hu"> <em class="ke">订购方</em> </strong>在相关信道上向所有<strong class="ji hu"> <em class="ke">对等方</em> </strong>广播生成的块。每个<strong class="ji hu"> <em class="ke">对等</em> </strong>对照<em class="ke">调用的链码</em>的e <em class="ke">拒绝策略</em>验证接收块中每个事务的认可，然后对照其<strong class="ji hu"> <em class="ke">公共状态数据库</em> </strong>验证每个事务的<strong class="ji hu"> <em class="ke">公共readset </em> </strong>。如果验证检查成功，则将每个事务的<strong class="ji hu"> <em class="ke">公共写集</em> </strong>更新到每个<strong class="ji hu"> <em class="ke">对等</em></strong><strong class="ji hu"><em class="ke">公共状态数据库</em> </strong>中。接收到的块也被追加到每个<strong class="ji hu"> <em class="ke">对等</em> </strong>的<strong class="ji hu"> <em class="ke">公共块存储器</em> </strong>中。随后，每个<strong class="ji hu"> <em class="ke">授权对等</em> </strong>对照私有读写集合的<em class="ke">哈希，验证临时存储在其<strong class="ji hu"> <em class="ke">临时存储数据库</em> </strong>(如果存在)中的<strong class="ji hu"> <em class="ke">私有读写集合</em> </strong>。<strong class="ji hu"> <em class="ke">对等</em> </strong>也验证了<strong class="ji hu"> <em class="ke">私有readset </em> </strong>对其<strong class="ji hu"> <em class="ke">私有状态数据库</em> </strong>。如果所有验证和确认过程成功，则将<strong class="ji hu"> <em class="ke">私有写集</em> </strong>更新到<strong class="ji hu"> <em class="ke">对等</em></strong><strong class="ji hu"><em class="ke">私有状态数据库</em> </strong>。<strong class="ji hu"> <em class="ke">私有写集</em> </strong>也被提交到<strong class="ji hu"> <em class="ke">对等</em></strong><strong class="ji hu"><em class="ke">私有写集存储</em> </strong>。最后，<strong class="ji hu"> <em class="ke">对等</em> </strong>从其<strong class="ji hu"> <em class="ke">暂存数据库</em> </strong>中删除<strong class="ji hu"> <em class="ke">私有读写集</em> </strong>。</em></li><li id="99e9" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd lm kl km kn dt translated">如果在背书时间内有<strong class="ji hu"> <em class="ke">授权的对等体</em> </strong>缺少<strong class="ji hu"> <em class="ke">私有读写集</em> </strong>，那么<strong class="ji hu"> <em class="ke">授权的对等体</em> </strong>将通过gossip协议向<strong class="ji hu"> <em class="ke">其他授权的对等体</em>发送对<strong class="ji hu"> <em class="ke">缺少私有读写集</em> </strong>的pull请求。</strong></li><li id="31bc" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd lm kl km kn dt translated"><strong class="ji hu"> <em class="ke">缺失的私有读写集</em> </strong>将通过gossip协议从<strong class="ji hu"> <em class="ke">请求对等体</em> </strong>转移到<strong class="ji hu"> <em class="ke">请求对等体</em> </strong>。因此，接收到的<strong class="ji hu"> <em class="ke">私有读写集</em> </strong>将在提交到<strong class="ji hu"><em class="ke"/></strong><strong class="ji hu"><em class="ke">私有状态数据库</em> </strong>和<strong class="ji hu"> <em class="ke">私有写集存储器</em> </strong>之前得到验证和确认(类似于<em class="ke">步骤7 </em>)。</li><li id="0fc6" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd lm kl km kn dt translated"><strong class="ji hu"> <em class="ke">客户端</em> </strong>从<strong class="ji hu"> <em class="ke"> EventHub服务</em> </strong>接收任何订阅的事件。</li></ol></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><p id="4a4d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">私有数据清除</strong></p><p id="713a" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">私有数据可以定期从对等体中清除。在<strong class="ji hu"> <em class="ke">私有数据收集定义</em> </strong>、<em class="ke"> </em>中，有一个收集属性叫做<strong class="ji hu"> <em class="ke"> blockToLive </em> </strong>，它表示私有数据应该在私有数据库中存在多长时间。假设我们将<strong class="ji hu"><em class="ke">block live</em></strong>设为<strong class="ji hu"><em class="ke"/></strong>50000。如果私有数据在50，000个数据块内未被修改，将自动从私有数据库中清除。如果<strong class="ji hu"> <em class="ke"> blockToLive </em> </strong>被<strong class="ji hu"> <em class="ke"> </em> </strong>设置为0，私有数据将无限期保存在私有数据库中。也就是说，私有数据永远不会被清除。更多信息，请参考<a class="ae jf" href="https://hyperledger-fabric.readthedocs.io/en/latest/private-data-arch.html" rel="noopener ugc nofollow" target="_blank">私有数据架构参考</a>。</p><p id="3c50" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">尽管<strong class="ji hu"> <em class="ke">私有数据</em> </strong>可能会从私有数据库中永久删除，但是<em class="ke">与被删除的私有数据</em>相对应的所有散列都不能被删除，因为它们被提交到<strong class="ji hu"> <em class="ke">公共块存储</em> </strong>，这是一个区块链。因此，<strong class="ji hu"> <em class="ke">散列</em> </strong>可以用作审计目的的交易证据，即使<em class="ke">原始私有数据</em>已经消失。</p></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><p id="12ea" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">总结</strong></p><p id="4701" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在这篇文章中，你已经学习了<strong class="ji hu"><em class="ke"/></strong><strong class="ji hu"><em class="ke">Hyperledger Fabric</em></strong>的关键特性之一。希望您了解Hyperledger Fabric如何更好地工作，如果您愿意，请随时留下您的宝贵意见或建议。感谢阅读:)</p><p id="b3b3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在本系列的最后一篇文章<a class="ae jf" rel="noopener" href="/p/f9a2046b4067">的下一篇文章</a>中，您将了解Hyperledger Fabric中的<strong class="ji hu"><em class="ke"/></strong><strong class="ji hu"><em class="ke">服务发现</em></strong><strong class="ji hu"><em class="ke"/></strong>和<strong class="ji hu"> <em class="ke">运营服务</em> </strong>。再次见到你。</p></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><p id="46fd" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">本系列文章组织如下:</p><ul class=""><li id="9281" class="kf kg ht ji b jj jk jn jo jr kh jv ki jz kj kd kk kl km kn dt translated"><a class="ae jf" rel="noopener" href="/p/a2fdb587f6cb">揭开Hyperledger Fabric的神秘面纱(1/3): Fabric架构</a></li><li id="610d" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated"><a class="ae jf" rel="noopener" href="/p/164220ecafa5">揭开总账结构的神秘面纱(2/3):私人数据收集</a></li><li id="efca" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated"><a class="ae jf" rel="noopener" href="/p/f9a2046b4067">揭开Hyperledger结构(3/3)的神秘面纱:网络流量处理、服务发现和运营服务</a></li></ul></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><p id="cda9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="ke">最初发表于</em><a class="ae jf" href="https://www.serial-coder.com/post/demystifying-hyperledger-fabric-private-data-collection/" rel="noopener ugc nofollow" target="_blank"><em class="ke">www.serial-coder.com</em></a><em class="ke">。</em></p><figure class="lb lc ld le fq iu fe ff paragraph-image"><a href="https://cryptofi.co"><div class="fe ff ln"><img src="../Images/e7b1dbc6a532a697c6844fdf0f0bbd30.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*HrFLDXz92JavTZXjhmvU7g.png"/></div></a></figure></div></div>    
</body>
</html>