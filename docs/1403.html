<html>
<head>
<title>Lessons Learned from Developing an NFL Survivor Pool on Ethereum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊上开发NFL幸存者池的经验教训</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/lessons-learned-from-developing-an-nfl-survivor-pool-on-ethereum-992dd4efbb25?source=collection_archive---------5-----------------------#2018-08-26">https://medium.com/coinmonks/lessons-learned-from-developing-an-nfl-survivor-pool-on-ethereum-992dd4efbb25?source=collection_archive---------5-----------------------#2018-08-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="480b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我最近开始在以太坊上开发一个NFL幸存者应用程序。对于那些不熟悉幸存者池的人来说，基本游戏规则如下:</p><ul class=""><li id="cd27" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated">支付所需的报名费加入幸存者池</li><li id="a934" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">每周选择一个你认为会赢的队。如果你的队赢了，你进入下一周。如果你的队输了，你就出局了。</li><li id="dc78" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">每个团队只能被挑选一次</li><li id="6a01" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">最后站着的人赢得奖金</li><li id="4555" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">如果所有剩下的球员被一次淘汰，或者当NFL赛季结束时还有多名球员，奖金将在他们之间平均分配</li></ul><figure class="kd ke kf kg fq kh fe ff paragraph-image"><div class="fe ff kc"><img src="../Images/d1c3953f2dcd17a666665f06e63b3697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*cd2YtEijU6pyt8pqXDrLxg.jpeg"/></div><figcaption class="kk kl fg fe ff km kn bd b be z ek"><a class="ae ko" href="https://bitedge.com/blog/nitrogen-sports-nfl-survivor-pool/" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="73fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这比我最初预期的要复杂一些。以下是我在开发过程中面临的各种挑战以及我是如何应对的。</p><h1 id="faac" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">获得游戏结果</h1><p id="618c" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">为了确定每周之后哪些球员留下来，我们需要知道哪些球队赢得了他们的NFL比赛，然后我们需要将这些获胜者与每个球员的选择进行比较。以不可信的方式将外部数据引入区块链是一个棘手的问题，尤其是当您需要将这些数据与每个加入的玩家进行比较时。</p><h2 id="4a65" class="ls kq ht bd kr lt lu lv kv lw lx ly kz jb lz ma ld jf mb mc lh jj md me ll mf dt translated">使用Oraclize的不可信方法</h2><p id="5430" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">一个相当不可信的解决方案是使用<a class="ae ko" href="http://www.oraclize.it/" rel="noopener ugc nofollow" target="_blank"> Oraclize </a>(你确实需要信任Oraclize)。我们可以通过两种方式使用该服务来确定NFL比赛的获胜者:</p><ol class=""><li id="08dd" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn mg ju jv jw dt translated">使用一个标准的API调用，在我之前写的<a class="ae ko" rel="noopener" href="/coinmonks/using-apis-in-your-ethereum-smart-contract-with-oraclize-95656434292e">教程</a>中有详细描述</li><li id="4c81" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn mg ju jv jw dt translated">使用<a class="ae ko" href="http://docs.oraclize.it/#data-sources-computation" rel="noopener ugc nofollow" target="_blank">计算数据源</a>不仅可以获得游戏赢家，还可以决定哪些玩家留下，哪些被淘汰。</li></ol><p id="655e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在最坏的情况下，我们总共需要联系甲骨文17次(在NFL赛季的17周中，每周一次)。使用选项1，假设我们可以在一个API调用中获得所有游戏结果，Oraclize默认gas参数将花费我们每周0.004 ETH或整个赛季0.068 ETH。这意味着，在目前约300美元/ETH的价格水平下，该合同将在整个赛季中花费约20美元来确定获胜者。这是在之前的<em class="mh">增加了字符串解析和操作的gas成本(这在可靠性上是复杂和昂贵的),以及确定剩余玩家所需的循环。由于解析结果和循环所有玩家以确定剩余玩家的成本和复杂性，所以排除了选项1。</em></p><p id="d520" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们看看选项2。Oraclize计算数据源要求脚本将计算结果打印为最后一行。这意味着我们可以:</p><ol class=""><li id="e36c" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn mg ju jv jw dt translated">打印一串获胜(或失败)的团队，并在Solidity中解析它们，或者</li><li id="070f" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn mg ju jv jw dt translated">使用一个更进一步的计算，打印出一个字符串，告诉我们还有哪些玩家</li></ol><p id="e0d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">方法1仍然引入了上文讨论的字符串操作和循环的复杂性，如果可能的话，我们希望避免这种复杂性，所以这不是一个好的选择。</p><p id="3ff1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了澄清方法2所建议的:假设我们有一个名为<code class="eh mi mj mk ml b">playersEntered</code>的地址数组，它存储每个进入的玩家的地址，还有一个名为<code class="eh mi mj mk ml b">isNotEliminated</code>的布尔数组，它存储每个玩家是否被淘汰。然后我们可以让脚本返回一个字符串，比如<code class="eh mi mj mk ml b">'1001110'</code>，其中第一个数字表示<code class="eh mi mj mk ml b">players[0]</code>还活着，但是<code class="eh mi mj mk ml b">players[1]</code>被消灭了。这种方法和上面的所有其他方法一样，需要我们遍历每个参与者来适当地更新契约的状态。随着玩家数量的增加，这样做的成本会变得很高，因此也是不利的。</p><h2 id="2407" class="ls kq ht bd kr lt lu lv kv lw lx ly kz jb lz ma ld jf mb mc lh jj md me ll mf dt translated">更加信任的方法</h2><p id="ccd3" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">在信任、成本和复杂性之间有一个权衡，这是一个可以探索的问题。</p><p id="8fbc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于所有玩家来说，如果他们因为为了合同所有者的利益而使用虚假的比赛结果而被错误地淘汰，这将是非常明显的。因此，另一种方法是，在我们自己的服务器上，调用API来获取NFL获胜者，然后确定我们自己服务器上的剩余球员。接下来，仍然使用我们的服务器，我们可以从我们的服务器调用一个合同函数，并提供一个剩余玩家的数组。我们可以用API提供的变量来更新保存玩家状态的契约变量，这样就不需要任何循环了！</p><p id="c7d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，即使很明显存在操纵行为，我们目前也没有为玩家提供一种方式来要回他们的钱。如果你想增加更多的信任，一个办法是使用某种类型的投票系统。实现一个用户调用的函数，如果他们认为他们被错误地淘汰了，如果超过X%的用户调用这个函数，所有的用户资金都被返回。这里的风险在赛季后期显现出来，那时只有少数球员留下。什么能阻止所有失败的玩家调用这个函数来要回他们的钱，不管结果是否是伪造的？</p><p id="1c3c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">就目前而言，我选择使用本节中描述的方法，因为这种方法简单且具有成本效益，尽管我不喜欢它需要信任合同所有者自己的API来确定剩余的参与者。这是我想在本合同的未来版本中更新的内容。</p><h1 id="f313" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">计划未来交易</h1><p id="8f7c" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">每周，需要调用各种合同函数来做一些事情，比如从API获取游戏结果，并更新本周的选择截止日期。理想情况下，这些函数将被自动调用，因此合同部署人员不需要每周手动调用它们。我们如何做到这一点？</p><p id="5337" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一个有趣的解决方案是使用<a class="ae ko" href="https://www.ethereum-alarm-clock.com/" rel="noopener ugc nofollow" target="_blank">以太网闹钟</a>，但是不幸的是它还没有在mainnet上部署(尽管它已经在Ropsten和Kovan testnets上部署)。它还依赖于激励人类进行函数调用，这意味着您将无法在专用网络上测试这种方法。</p><p id="1535" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">或者，如果您使用<a class="ae ko" href="https://geth.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Geth </a>或<a class="ae ko" href="https://www.parity.io/" rel="noopener ugc nofollow" target="_blank">奇偶校验</a>运行节点，您可以通过您的节点调度事务。<a class="ae ko" href="https://ethereum.stackexchange.com/questions/16464/how-to-schedule-a-transaction" rel="noopener ugc nofollow" target="_blank">这个StackExchange问题的答案</a>解释了您如何做到这一点。然而，我不运行一个节点，也不想设置一个，所以这个选项是不可行的。另一个缺点是，在通读合同时没有明确说明这个功能是如何实现的。</p><p id="679d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">第三种方法是激励玩家为我们调用所需的函数。我们可以通过向他们支付少量款项来实现这一点，作为调用该函数的奖励。显而易见的缺点是，仍然不能保证这个函数会被调用，尤其是如果报酬不够高的话。如果联邦医疗保险/美元价格发生变化，回报可能会变得不那么诱人，或者太高。此外，添加另一个用户可以调用的函数会增加合同的攻击面。</p><p id="1bb3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我所知道的下一个方法是使用<a class="ae ko" href="http://www.oraclize.it/" rel="noopener ugc nofollow" target="_blank">或</a>，无论是否有API调用。这不是一个标准的Oraclize用例，所以让我们在这里深入一点。使用Oraclize时，典型的执行流程如下所示:</p><ol class=""><li id="1b62" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn mg ju jv jw dt translated">手动调用合同中的某个函数<code class="eh mi mj mk ml b">foo()</code></li><li id="beac" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn mg ju jv jw dt translated"><code class="eh mi mj mk ml b">foo()</code>以应用编程接口查询作为<code class="eh mi mj mk ml b">oraclize_query()</code>的输入之一调用<code class="eh mi mj mk ml b">oraclize_query()</code></li><li id="918f" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn mg ju jv jw dt translated">Oraclize到达指定的API并等待响应</li><li id="c500" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn mg ju jv jw dt translated">Oraclize调用您的合同中的一个名为<code class="eh mi mj mk ml b">__callback()</code>的函数，并将查询结果传递给它</li></ol><p id="3d1e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">“技巧”来自步骤2，其中<code class="eh mi mj mk ml b">oraclize_query()</code>实际上允许您传入一个<a class="ae ko" href="http://docs.oraclize.it/#ethereum-quick-start-schedule-a-query-in-the-future" rel="noopener ugc nofollow" target="_blank">延迟参数</a>，它将API调用推迟指定的时间量。如果您以空字符串的形式输入API查询输入，Oraclize将不会抛出错误，并且现在将充当事务调度程序。简单例子见<a class="ae ko" href="https://ethereum.stackexchange.com/a/252/44133" rel="noopener ugc nofollow" target="_blank"> this StackExchange </a>答案。</p><p id="1107" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Oraclize方法的另一个好处是，它可以很容易地用于<a class="ae ko" href="http://docs.oraclize.it/#ethereum-quick-start-recursive-queries" rel="noopener ugc nofollow" target="_blank">调度递归查询</a>，使得每周重复我们的函数调用变得很容易。如上所述，这种方法的缺点是成本很高。由于它易于实现，而且我已经从以前的<a class="ae ko" rel="noopener" href="/coinmonks/using-apis-in-your-ethereum-smart-contract-with-oraclize-95656434292e">教程</a>中熟悉了Oraclize，所以我决定降低成本，使用这种方法。使用上一节中的数字，Oraclize查询的默认成本是0.004 ETH，相当于每周1.20美元。</p><p id="055d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后一个值得一提的选项是在您自己的服务器上建立一个<a class="ae ko" href="https://en.wikipedia.org/wiki/Cron" rel="noopener ugc nofollow" target="_blank"> cron作业</a>,根据需要从普通帐户调度函数调用。就像从一个节点调度事务一样，在阅读合同时并不清楚这是否实现了。</p><h1 id="2881" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">测试未来交易</h1><p id="7cd8" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">通常情况下，智能合约功能只能在特定时间内调用。在这种情况下，我们必须阻止玩家在游戏开始后选择他们的团队。那么我们如何做到这一点呢？</p><p id="8739" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将使用<a class="ae ko" href="https://github.com/trufflesuite/ganache-cli" rel="noopener ugc nofollow" target="_blank"> ganache-cli </a>和<a class="ae ko" href="https://truffleframework.com/truffle" rel="noopener ugc nofollow" target="_blank"> Truffle </a>编写我们的测试，并利用名为<code class="eh mi mj mk ml b">evm_increaseTime</code>的ganache特性来改变时间。这种方法允许我们随意增加EVM时间，所以我们可以在将来模拟呼叫。</p><p id="72bc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，这种方法似乎有一些问题，因为我不能让它正常工作。以下函数用于使用<code class="eh mi mj mk ml b">evm_increaseTime</code>方法增加EVM时间:</p><figure class="kd ke kf kg fq kh"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="6bb9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，从该代码片段的注释中可以看出，这并不能正常工作。根据<a class="ae ko" href="https://github.com/trufflesuite/ganache-cli/issues/394" rel="noopener ugc nofollow" target="_blank">这个</a>问题，我们需要在更改时间后挖掘一个区块，以使时间更改真正生效。我们使用<code class="eh mi mj mk ml b">evm_mine</code>方法来实现，如果我们检查ganache-cli时间戳，这看起来<em class="mh"> </em>确实有效。然而，如果我们在我们的契约中添加一个简单返回<code class="eh mi mj mk ml b">now</code>或<code class="eh mi mj mk ml b">block.timestamp</code>的函数，我们会看到时间改变没有被遵守。类似地，依赖于<code class="eh mi mj mk ml b">now</code>的测试会失败，因为合同不承认时间改变。下面的代码片段演示了这一点:</p><figure class="kd ke kf kg fq kh"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="4393" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里有一个关于这个<a class="ae ko" href="https://github.com/trufflesuite/ganache-cli/issues/336" rel="noopener ugc nofollow" target="_blank">的未决问题，因此我无法测试未来的交易。这有点令人失望，因为这个合同相当依赖于在特定时间发生的事情。如果有人有关于如何让它正常工作的建议，我很乐意听听！</a></p><blockquote class="mo"><p id="9e95" class="mp mq ht bd mr ms mt mu mv mw mx jn ek translated"><a class="ae ko" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mz na nb nc nd kh fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff my"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>