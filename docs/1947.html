<html>
<head>
<title>“Stack Too Deep”- Error in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“堆叠太深”-坚固性错误</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/stack-too-deep-error-in-solidity-608d1bd6a1ea?source=collection_archive---------0-----------------------#2019-01-07">https://medium.com/coinmonks/stack-too-deep-error-in-solidity-608d1bd6a1ea?source=collection_archive---------0-----------------------#2019-01-07</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/3b8b0b6cfd7b33ca70ce6c3004687224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*EP_QYlK_-Fgc2JclN_fLKA.png"/></div></figure><p id="71c5" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">新年快乐，愿我们在2019年都能大有作为！Aventus欢迎你从寒假回来，我们自己的Alex Pinto写了一篇关于坚固性错误的文章。</p></div><div class="ab cl jv jw hb jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hm hn ho hp hq"><p id="b270" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">当一个人开始在Solidity中编写智能合同时，迟早他/她会遇到一个非常讨厌的障碍。“堆栈过深”错误。人们很容易陷入这个陷阱，当这种情况发生时，往往很难找到出路。公平地说，根本原因不在于可靠性本身，而在于以太坊虚拟机(EVM)，因此可能会影响编译成EVM的其他语言(即LLL、Serpent、Viper)，但这是编写智能合同的日常工作中的一个微妙区别。</p><p id="33c8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">令人惊讶的是，考虑到这可能导致的烦恼程度，很难找到关于如何处理它的好资源，所以我决定写这篇文章，试图揭示它，为我自己的利益，也为其他可能对此感到绝望的人。</p><p id="68a4" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">一般来说，当代码需要访问堆栈中深度超过第16个元素(从上往下数)的槽时，就会产生这个错误。然而，我们可以通过多种方式实现这一目标。这篇文章的目的不是提供这个错误是如何产生的完整理论:根据我的经验，有太多的方法可以做到这一点。但是它将为通用触发器提供一个很好的理论基础，并有望让读者更加了解EVM是如何管理其堆栈的。甚至有可能将相同的逻辑扩展到发生错误的其他情况，并寻找避免错误的方法。</p><p id="b384" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在Solidity中，大多数类型(即基本类型，例如数字、地址和布尔值，但不是数组、结构或映射)都是通过值传递给函数的:当调用函数时，堆栈的一部分(即堆栈帧)被分配来保存函数返回时程序应该到达的返回位置(“返回地址”)以及函数值类型输入和输出参数的副本。每个参数通常在堆栈中保存一个槽，每个槽是256位。</p><p id="3cb8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这提供了解决“堆栈过深”错误的最基本方法:总共有16个以上的输入和输出参数。但是实际上，如果我们想让这个函数做一些有用的事情，我们必须非常小心，并且可能必须减少参数的数量。</p><p id="51fc" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">为了测试这一点，我在<a class="ae kc" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> <em class="kd"> Remix </em> </a>中创建了一个小契约，如下所示:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="4947" class="kn ko ht kj b fv kp kq l kr ks">pragma solidity ^0.4.24;<br/>contract TestStackError {<br/>  event LogValue(uint);<br/>  function logArg(uint a1) public {<br/>    emit LogValue(a1);<br/>  }<br/>}</span></pre><p id="17d4" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">Remix非常适合这样的调查，因为我们可以快速编写一个契约并查询它，但根本上是因为Remix提供了一个强大的调试器，具有操作码反汇编和堆栈、内存和存储的完整列表。在代码中来回移动也很容易，这是我在任何语言中拥有的最好的调试体验之一。</p><p id="d76f" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这个契约非常简单:它没有状态变量，只有一个函数，也非常简单。这个函数只接受一个参数并记录下来。</p><p id="a804" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我将这个合同复制到Remix中的一个新文件中，编译并部署它。应该没有错误和警告，所以我转到<em class="kd">运行</em>选项卡，并点击<em class="kd">部署</em>。</p><p id="e058" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">然后，我扩展SimpleFunction契约的列表，并在<em class="kd"> logArg </em>前面的框中输入一个值。我按下按钮，检查控制台中的输出:</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff kt"><img src="../Images/4c4943971d14652968459f246dd5f6db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lPrvLApnthc2G_N-"/></div></div></figure><p id="a766" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">如您所见，我输入了值<em class="kd"> 7 </em>，它作为日志中唯一的元素被返回。尽管日志值得另发一篇文章，但我还是要在这里提几件事。</p><p id="8017" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这是这个调用的JSON格式的logs对象:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="f9c0" class="kn ko ht kj b fv kp kq l kr ks">logs [<br/>{<br/>  "from": "0xef55bfac4228981e850936aaf042951f7b146e41",<br/>  "topic": "0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250",<br/>  "event": "LogValue",<br/>  "args": {<br/>    "0": "7",<br/>    "length": 1<br/>  }<br/>}</span></pre><ul class=""><li id="24a3" class="ky kz ht iz b ja jb je jf ji la jm lb jq lc ju ld le lf lg dt translated">日志是由solidity中的<code class="eh lh li lj kj b">emit</code>关键字创建的，它提高了solidity <code class="eh lh li lj kj b">event</code>并对应于<code class="eh lh li lj kj b">LOGn</code>操作码。</li><li id="e004" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">离线运行的客户端应用程序可以过滤日志。过滤器是日志中任何可用主题的条件。</li><li id="9c63" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">日志总是有一个主题0，它是事件签名的编码。</li><li id="8a8f" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">可以通过索引一个参数来创建更多的主题。最多可以有3个索引参数。其余的被认为是事件数据</li></ul><p id="26a3" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在这个简单的例子中，我们可以很容易地识别出只有一个主题(<code class="eh lh li lj kj b">"0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250"</code>)，数据显示为log对象的<code class="eh lh li lj kj b">args</code>成员的一部分。我们还可以验证代码是否按预期运行。</p><p id="e119" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在让我们测试这个契约的限制，并更改函数以接受最大数量的参数。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="56f5" class="kn ko ht kj b fv kp kq l kr ks">pragma solidity ^0.4.24;</span><span id="9d1c" class="kn ko ht kj b fv lp kq l kr ks">contract TestStackError {<br/>  event LogValue(uint);<br/>  function logArg(uint a1, uint a2, uint a3, uint a4,<br/>	uint a5, uint a6, uint a7, uint a8,<br/>	uint a9, uint a10, uint a11, uint a12,<br/>	uint a13, uint a14, uint a15, uint a16<br/>  ) public {<br/>    emit LogValue(a16);<br/>  }<br/>}</span></pre><p id="2826" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我有16个输入变量，没有输出变量，因此我只需要使用16个堆栈槽。我调用传递值1到16的函数，并发出最后一个值。我检查日志，发现值为16。太棒了，这个管用！</p><p id="09c6" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">然后，我对我的契约做了一个很小的修改:改为记录第一个参数:</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff kt"><img src="../Images/aed621b308a8e264adbba7e24a4a7cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sivXW-uI1SlS8Q1X"/></div></div></figure><p id="36c1" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">等等，什么？！简单地记录一个不同的参数已经把一个完美的契约变成了一个“栈太深”的错误。哇，这是怎么回事？</p><p id="36bc" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这不是固性所能阐明的。在这个层面上，这种变化看起来完全无害。我需要深入到EVM字节码中去理解发生了什么。但在此之前，我想做另一个测试，收集一些线索。我创建了这个契约的第三个版本，但是改为记录a2:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="5f8c" class="kn ko ht kj b fv kp kq l kr ks">pragma solidity ^0.4.24;</span><span id="0440" class="kn ko ht kj b fv lp kq l kr ks">contract TestStackError {<br/>  event LogValue(uint);<br/>  function logArg(uint a1, uint a2, uint a3, uint a4,<br/>	uint a5, uint a6, uint a7, uint a8,<br/>	uint a9, uint a10, uint a11, uint a12,<br/>	uint a13, uint a14, uint a15, uint a16<br/>  ) public {<br/>    emit LogValue(a2);<br/>  }<br/>}</span></pre><p id="e393" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这是可行的，并且记录了正确的值。我登录<code class="eh lh li lj kj b">a3</code>时也是如此。我假设<code class="eh lh li lj kj b">a2</code>和<code class="eh lh li lj kj b">a16</code>之间的所有参数都可以被正确记录。<br/>产生的操作码在以下三个文件中:</p><p id="c663" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><a class="ae kc" href="http://coders-errand.com/wp-content/uploads/2018/12/opcode_log_a2.txt" rel="noopener ugc nofollow" target="_blank"> <em class="kd">日志【a2】</em></a></p><p id="427e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><a class="ae kc" href="http://coders-errand.com/wp-content/uploads/2018/12/opcode_log_a3.txt" rel="noopener ugc nofollow" target="_blank"><em class="kd">【a3】</em></a></p><p id="f414" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><a class="ae kc" href="http://coders-errand.com/wp-content/uploads/2018/12/opcode_log_a16.txt" rel="noopener ugc nofollow" target="_blank"><em class="kd">【a16】</em></a></p><p id="aa48" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我比较了所有3个日志，第一个让我吃惊的是它们的大小都不同(行数)。第二件事是，在第237行之前，它们是显著相等的，只有一个例外。这一行之后的代码非常不同，显然是不可预测的。然而，由于这似乎是在函数返回之后发生的，我将简单地忽略它。</p><p id="1bbb" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">然后我把注意力集中在第237行和第198行之间的一个区别上。我很高兴地证实了一个想法，我曾认为这个想法可以解释堆栈过深错误——在代码的某些地方，我们逻辑上需要调用一些不存在的DUP或交换操作码。这里的情况确实如此:在第237行之前，所有3个版本都是相同的，只有第198行有一处不同:</p><ul class=""><li id="12f9" class="ky kz ht iz b ja jb je jf ji la jm lb jq lc ju ld le lf lg dt translated"><code class="eh lh li lj kj b">log(a2): DUP16</code></li><li id="29b9" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated"><code class="eh lh li lj kj b">log(a3): DUP15</code></li><li id="b1ad" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated"><code class="eh lh li lj kj b">log(a16): DUP2</code></li></ul><p id="f206" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">操作码DUPn复制堆栈第n层的值。这样的操作码只有16个，从DUP1到DUP16。DUP1将当前位于顶部的值的副本推送到堆栈中，DUP16复制堆栈中第16个最高的值。变量在参数列表中的位置和这一行中DUPn的值之间有明显的关系，如果我将其推断到案例日志(a1)，这条规则意味着我们将需要一个操作码DUP17。但是这样的操作码并不存在，它指向堆栈中比我们所能达到的更低的值，这证明了错误消息“Stack Too Deep”是正确的。</p><p id="5fbe" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">满足于此，我自然的好奇心提出了问题:这个DUP操作码在这里扮演什么角色？它的目的是什么？</p><p id="6c37" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">字节码令人生畏。上一次我带着某种程度的理解去看汇编代码是在我十几岁的时候，当时我正在玩Spectrum的Z80处理器。我没有任何使用EVM的经验，所以我不打算在脑子里解析200行类似汇编的清单。但是Remix在这方面确实提供了相当好的工具。在debug选项卡中，我们可以一个操作码一个操作码地重放事务操作码，并且一眼就能看到堆栈、内存和存储等的内容。</p><p id="59ae" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在我继续之前，我想把你引向Alejandro Santander在Zeppelin博客中关于汇编EVM代码结构的这一系列文章 。这是一个无价的介绍EVM大会，将节省我不得不解释样板。另一个非常有用的链接是这个EVM操作码 的<a class="ae kc" href="https://ethervm.io/" rel="noopener ugc nofollow" target="_blank"> <em class="kd">列表，这是我最喜欢用来查找每个操作码功能的参考。我强烈推荐。</em></a></p><p id="4848" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这个函数没有多少内容，大部分字节码都是重复的。操作码CALLDATALOAD出现了17次。第一个出现在代码的第一个块中，在函数分派之前。它检查calldata是否太短(第12行)，在这种情况下，该函数将恢复。之后，它将函数选择器与契约已知的方法进行比较(在本例中，只有一个:<code class="eh lh li lj kj b">e898288f</code>)，如果匹配，就将流程导向实现该函数的地址。否则，呼叫恢复。</p><p id="a17a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在这种情况下，代码已经调用了唯一的现有函数，因此流程跳转到地址70(第25行)来处理它。</p><p id="88fb" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">CALLDATALOAD的其余16个实例正好是我们拥有的参数数量，它们正好以9行的间隔出现，并且可能负责处理函数的每个参数。所以，我用Remix调试器运行了这几行，观察到它们确实将每个连续的参数加载到了堆栈中(我并不担心这9个操作码是如何复制这些数据的)。接下来是3个<code class="eh lh li lj kj b">POP</code>指令，清除我们不再需要的堆栈部分(用于计算要读取的下一个参数在调用数据中的位置)。此时，栈顶保存第16个参数，第二个元素保存第15个参数，依此类推。在这个阶段，堆栈的第16个元素是第一个参数。随后是函数的返回地址(<code class="eh lh li lj kj b">0x109</code>)和函数选择器。</p><p id="b652" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">然后，代码将topic 0 <code class="eh lh li lj kj b">fcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250</code>的32字节标识符推入堆栈，这将第一个输入推出堆栈的前16个元素，随后是DUP操作码，该操作码将日志事件的参数放在堆栈的顶部(例如<code class="eh lh li lj kj b">a2</code>或<code class="eh lh li lj kj b">a16</code>)。</p><p id="af69" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">接下来的20行左右让内存准备好在内存位置<code class="eh lh li lj kj b">0x80</code>保存日志事件的参数，并保证堆栈的前两个位置有这个地址和数据的长度(<code class="eh lh li lj kj b">0x20</code>)。然后，它调用操作码LOG1，该操作码使用堆栈中前3个位置的数据发出一个带有一个参数和一个主题的日志事件:</p><ul class=""><li id="7fd2" class="ky kz ht iz b ja jb je jf ji la jm lb jq lc ju ld le lf lg dt translated">0: <code class="eh lh li lj kj b">0x0000000000000000000000000000000000000000000000000000000000000080</code></li><li id="2261" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">1: <code class="eh lh li lj kj b">0x0000000000000000000000000000000000000000000000000000000000000020</code></li><li id="8436" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">2: <code class="eh lh li lj kj b">0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250</code></li></ul><p id="95dc" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">总共有五个LOGn操作码，LOG0到LOG4，其中n表示日志中主题的数量。Topic0始终是事件类型的标识符，由其签名的哈希定义，但可以通过使用LOG0跳过它，LOG0指定匿名事件。每个额外的主题都需要堆栈中的另一个槽，将更多的参数推出可达列表。</p><p id="3597" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">该分析表明，带有一个参数的事件阻止使用一个变量，因为topic0放在堆栈中事件数据之前。这引发了几个问题:</p><ul class=""><li id="df58" class="ky kz ht iz b ja jb je jf ji la jm lb jq lc ju ld le lf lg dt translated">如果我们有更多的话题呢？它们也放在数据之前吗？</li><li id="2167" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">而更多的事件争论有什么影响，是在话题之后推还是之前推？</li></ul><p id="9518" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">为了验证这一点，我将再次更改合同。请注意，事件可以有任意数量的参数，其中最多有3个可以被索引。索引参数成为主题，而其他参数则集中在数据部分。在这个阶段，我的假设是，每个主题(索引参数)将放在数据之前的堆栈中，因此将阻止对更多早期变量的访问。</p><p id="3ea6" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在我的测试中，我涵盖了几个场景，但它们都导致相同的结论，所以我将为您节省分钟的细节。我将用另一个有趣的反直觉的例子来说明，然后得出最后的结论。</p><p id="d596" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">首先，让我们试试这个版本的契约，其中事件有一个索引值和两个非索引值。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="262e" class="kn ko ht kj b fv kp kq l kr ks">pragma solidity ^0.4.24;</span><span id="2cc5" class="kn ko ht kj b fv lp kq l kr ks">contract TestStackError {<br/>  event LogValue(uint indexed a1, uint a2, uint a3);<br/>  function logArg(uint a1, uint a2, uint a3, uint a4,<br/>	uint a5, uint a6, uint a7, uint a8,<br/>	uint a9, uint a10, uint a11, uint a12,<br/>	uint a13, uint a14, uint a15, uint a16<br/>  ) public {<br/>    emit LogValue(a2, a3, a4);<br/>  }<br/>}</span></pre><p id="1c32" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这个函数的字节码(在函数分派之后)直到事件被发出为止是这样的:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="f67c" class="kn ko ht kj b fv kp kq l kr ks">265 JUMPDEST<br/>266 DUP15<br/>267 PUSH32 a5397a5faa0ec7cfb89428503b91a13bbd737592f7561e6773fa3e1458c8735c<br/>300 DUP16<br/>301 DUP16<br/>302 PUSH1 40<br/>304 MLOAD<br/>305 DUP1<br/>306 DUP4<br/>307 DUP2<br/>308 MSTORE<br/>309 PUSH1 20<br/>311 ADD<br/>312 DUP3<br/>313 DUP2<br/>314 MSTORE<br/>315 PUSH1 20<br/>317 ADD<br/>318 SWAP3<br/>319 POP<br/>320 POP<br/>321 POP<br/>322 PUSH1 40<br/>324 MLOAD<br/>325 DUP1<br/>326 SWAP2<br/>327 SUB<br/>328 SWAP1<br/>329 LOG2</span></pre><p id="d00f" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">发出事件的操作码是<code class="eh lh li lj kj b">LOG2</code>。这意味着我们有两个主题，一个是默认主题0(即事件签名)，另一个是事件签名中唯一的索引参数。其余两个值在内存中分组。<br/>如果我们检查这个操作码的<a class="ae kc" href="https://ethervm.io/#A2" rel="noopener ugc nofollow" target="_blank"> <em class="kd"> Ethervm </em> </a>，我们会看到从堆栈中读取的最后一个值，以及第一个被推送到它上面的<em class="kd"/>，是topic1，即索引参数— <code class="eh lh li lj kj b">a2</code>。最初，它被放置在堆栈的位置15。操作码<code class="eh lh li lj kj b">DUP15</code>将该值的副本放在堆栈的顶部，并因此将所有其他参数压下。比如从现在开始，<code class="eh lh li lj kj b">a2</code>在16号位，<code class="eh lh li lj kj b">a1</code>在17号位。</p><p id="a59d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">下一条指令将一个32位的值压入堆栈，这只是对应于主题0。这个值是硬编码的。这也有再次压制论点的效果。现在，<code class="eh lh li lj kj b">a2</code>在17号位。</p><p id="8002" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">以下指令是两个<code class="eh lh li lj kj b">DUP16</code>操作码。第一个复制位置16的值，这是当前的第三个参数<code class="eh lh li lj kj b">a3</code>。但是由于这将一个新元素推到堆栈上，当调用下一个操作码时，<code class="eh lh li lj kj b">DUP16</code>将把第四个参数复制到函数<code class="eh lh li lj kj b">a4</code>中。在这个阶段，在堆栈的顶部，我们有事件的数据(两个单词)、索引参数和事件唯一标识符。</p><p id="d941" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">下面几行将前两个值复制到内存中:</p><ul class=""><li id="0880" class="ky kz ht iz b ja jb je jf ji la jm lb jq lc ju ld le lf lg dt translated">(302–305):将内存<code class="eh lh li lj kj b">0x40</code>的内容放在堆栈的顶部，两次。这是事件数据在内存中的位置(在我的执行中是<code class="eh lh li lj kj b">0x80</code>)。</li><li id="edf4" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">(306–308):将第一个数据字放在内存的第一个空闲位置(即将<code class="eh lh li lj kj b">a3</code>放在位置<code class="eh lh li lj kj b">0x80<br/></code>)</li><li id="a472" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">(309–311):将内存中的下一个空闲位置放在堆栈的顶部</li><li id="3888" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">(312–314):将第二个数据字放在内存中的下一个空闲位置(即将<code class="eh lh li lj kj b">a4</code>放在位置<code class="eh lh li lj kj b">0xa0<br/></code>)</li><li id="ad2e" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">(315–321):在删除不再需要的值后，计算内存中的下一个空闲位置，并将其放在堆栈的顶部。</li><li id="9da1" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">(322–327):通过从内存中下一个空闲位置的当前值(保存在堆栈顶部)中减去该位置的初始地址，得出提交给事件的数据的长度。</li><li id="5f6c" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">(328):对堆栈的前两个元素重新排序，使第一个元素成为事件数据的开头，第二个地址成为该数据的长度。</li><li id="265e" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">(329):最后调用日志操作码。</li></ul><p id="2c80" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我给出了这个详细的解释，以便你可以理解这个过程是如何工作的，如果你愿意的话。在这种情况下，也许你现在可以解释下一个明显的奇怪现象。仅将事件的签名更改为:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="060d" class="kn ko ht kj b fv kp kq l kr ks">event LogValue(uint a1, uint indexed a2, uint a3);</span></pre><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff kt"><img src="../Images/8f534d1a84da66a9f88f647d9ab0cdb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I1P6ynrR_IeYmi4S"/></div></div></figure><p id="1f25" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">是的，另一个堆栈太深的错误。你能看出是什么引起的吗？<br/> …</p><p id="1b41" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt">……</p><p id="f146" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt">………</p><p id="d866" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">字节码变化不大。我们仍然有相同数量的主题，所以最后的操作码仍然是<code class="eh lh li lj kj b">LOG2</code>。并且它仍然期望以相同的顺序接收它的参数，即首先是主题，然后是数据。</p><p id="fdcf" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在，必须首先加载第二个主题，所以<code class="eh lh li lj kj b">a3</code>将是第一个用<code class="eh lh li lj kj b">DUP14</code>推入堆栈的值。那么topic0将被推出。现在，EVM将把需要存储在内存中的两个参数放在堆栈的顶部，<code class="eh lh li lj kj b">a2</code>和<code class="eh lh li lj kj b">a4</code>。这些最初是在位置15和13。然而，EVM已经两次推动，使这些位置17和15。不可能将第一个值放入堆栈(<code class="eh lh li lj kj b">DUP17</code>不存在)，因此会出现编译错误。</p><p id="e6a6" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在我们明白了这一点，我试着再改变一件事，将log函数改为:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="474a" class="kn ko ht kj b fv kp kq l kr ks">emit LogValue(a3, a2, a4);</span></pre><p id="7818" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这段代码是有效的，因为它非常接近于我改变索引参数顺序之前的最后一个代码块。在这段代码中，用<code class="eh lh li lj kj b">a2</code>调用了事件的索引值。在这个版本中，传递到那个位置的仍然是<code class="eh lh li lj kj b">a2</code>，其他保持不变。字节码的解释实际上是一样的。</p><h2 id="aa92" class="kn ko ht bd lq lr ls lt lu lv lw lx ly ji lz ma mb jm mc md me jq mf mg mh mi dt translated">结论</h2><p id="54de" class="pw-post-body-paragraph ix iy ht iz b ja mj jc jd je mk jg jh ji ml jk jl jm mm jo jp jq mn js jt ju hm dt translated">这是一个很长的帖子。如果您已经到了这一步，那么值得让您对正在发生的事情有一个有组织的看法，这样您就可以回到您的程序，并思考您的“堆栈过深”错误是否可能是由类似的行为引起的。虽然这篇文章只讨论了发出事件的情况，但是其他函数将使用其他操作码，但是仍然具有相同的逻辑，在需要一些计算时将函数参数(或中间值)复制到堆栈中。</p><p id="bc2d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">因此，以下是一些需要记住的简化笔记:</p><ul class=""><li id="c83f" class="ky kz ht iz b ja jb je jf ji la jm lb jq lc ju ld le lf lg dt translated">当一个函数被调用时，一个堆栈框架被创建。这从下到上包括:</li><li id="65ec" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">功能选择器</li><li id="7f95" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">寄信人地址</li><li id="2be3" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">函数最左边的值类型参数</li><li id="8c5e" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt">…</li><li id="e8dc" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">函数最右边的值类型参数</li><li id="30e7" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">“堆栈过深”错误取决于操作的核心操作码(如算术、散列、调用另一个函数、发出事件等)。)</li><li id="b967" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">如果这些核心操作是在纯函数参数上执行的，那么它们传递给函数的顺序可能决定“堆栈过深”错误的发生。(栈槽也可以用于中间计算和局部变量，但是我打算在以后的文章中研究这些。)</li><li id="49cd" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">了解操作码参数的数量和顺序至关重要。这些参数通常从堆栈中读取(唯一的例外是<code class="eh lh li lj kj b">PUSH</code>操作码)。</li><li id="bab5" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">在执行操作码之前，必须将操作码参数压入堆栈。每个<code class="eh lh li lj kj b">PUSH</code>将函数参数下移至少一个槽。堆栈中较深的函数参数是最先处理的参数，即函数签名中最左边的参数。</li><li id="406f" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">如果操作码操作中没有使用某些函数参数，那么它们应该出现在函数签名中的第一位，以减少操作码参数在需要堆栈时超出范围的机会。</li><li id="0e53" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">操作码使用堆栈中不同级别的参数。先推更深的层次。如果一个参数在另一个参数之后被压入，它也应该出现在函数签名中的前一个参数之后，否则它会在使用前将另一个参数压入堆栈。示例:</li></ul><ol class=""><li id="42ec" class="ky kz ht iz b ja jb je jf ji la jm lb jq lc ju mo le lf lg dt translated"><em class="kd">考虑一个具有两个索引参数</em> <code class="eh lh li lj kj b"><em class="kd">t1</em></code> <em class="kd">和</em> <code class="eh lh li lj kj b"><em class="kd">t2</em></code> <em class="kd">的事件，按此顺序调用一个具有多个参数的函数，其中</em> <code class="eh lh li lj kj b"><em class="kd">a1</em></code> <em class="kd">在</em> <code class="eh lh li lj kj b"><em class="kd">a2</em></code>之前</li><li id="c40c" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju mo le lf lg dt translated"><em class="kd">如果事件是用</em> <code class="eh lh li lj kj b"><em class="kd">t1 = a1</em></code> <em class="kd">和</em> <code class="eh lh li lj kj b"><em class="kd">t2 = a2</em></code> <em class="kd">发出的，那么操作码</em> <code class="eh lh li lj kj b"><em class="kd">LOG3</em></code> <em class="kd">就会被调用。</em></li><li id="66d3" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju mo le lf lg dt translated"><em class="kd">在调用这个操作码之前，</em> <code class="eh lh li lj kj b"><em class="kd">t2 = a2</em></code> <em class="kd">会先被压入堆栈。</em></li><li id="8a5d" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju mo le lf lg dt translated"><em class="kd">这会将</em> <code class="eh lh li lj kj b"><em class="kd">a1</em></code> <em class="kd">下推，到时候再推</em> <code class="eh lh li lj kj b"><em class="kd">t1 = a1</em></code> <em class="kd">的值就有不可达的风险。</em></li><li id="b367" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju mo le lf lg dt translated"><em class="kd">如果在函数签名中</em> <code class="eh lh li lj kj b"><em class="kd">a1</em></code> <em class="kd">在</em> <code class="eh lh li lj kj b"><em class="kd">a2</em></code> <em class="kd">之后，这将被避免，因为它在堆栈中比</em> <code class="eh lh li lj kj b"><em class="kd">a2</em></code> <em class="kd">更高。假设</em> <code class="eh lh li lj kj b"><em class="kd">a2</em></code> <em class="kd">被推送时是可达的，那么</em> <code class="eh lh li lj kj b"><em class="kd">a1</em></code> <em class="kd">之后也是可达的。</em></li></ol><ul class=""><li id="47a9" class="ky kz ht iz b ja jb je jf ji la jm lb jq lc ju ld le lf lg dt translated">上面的帖子只关注了<code class="eh lh li lj kj b">LOGn</code>操作码，特别是在堆栈中需要3或4个参数的版本。更困难的情况是调用其他契约或库中的函数，因为操作码<code class="eh lh li lj kj b">CALL</code>和<code class="eh lh li lj kj b">DELEGATECALL</code>各接受7或6个输入参数，操作码和函数参数之间有更多交互的可能性。</li></ul><p id="1847" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我希望这能给你一些关于如何调试和处理“栈太深”错误的线索。还有很多话要说，但那要等其他机会了。</p><p id="a16a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">下次见。</p></div><div class="ab cl jv jw hb jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hm hn ho hp hq"><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff mp"><img src="../Images/9c2558d79b8a408e9c5771eb58a52244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xh5WG6RxRX2-sFG8aCqGXQ.jpeg"/></div></div><figcaption class="mq mr fg fe ff ms mt bd b be z ek">Alexandre Pinto — Blockchain developer at Artos (Aventus Ecosystem Party)</figcaption></figure><p id="5812" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">Alex是我们生态系统合作伙伴Artos的软件工程师，在区块链工程团队工作。他拥有20年的技术工作经验，完成了计算机科学博士学位和密码学博士后学位。作为研究的一部分，Alex <a class="ae kc" href="https://www.researchgate.net/profile/Alexandre_Pinto2" rel="noopener ugc nofollow" target="_blank">发表了关于Kolmogorov复杂性、密码学、数据库匿名化和代码混淆的论文</a>。</p><p id="e3ed" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">Pinto还花了七年时间在Maia大学学院讲课，包括指导计算机科学和信息系统与软件学士学位课程。</p><p id="2a86" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这篇文章最初发表在他的博客上。</p><p id="4b45" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">既然你在这里，我们希望你能在<a class="ae kc" href="https://t.me/joinchat/HIDa30p_VOA2Mk-V14EVMA" rel="noopener ugc nofollow" target="_blank"><strong class="iz hu"/></a><strong class="iz hu"/><a class="ae kc" href="https://www.reddit.com/r/Aventus/" rel="noopener ugc nofollow" target="_blank"><strong class="iz hu">Reddit</strong></a><strong class="iz hu"/><a class="ae kc" href="https://twitter.com/AventusNetwork" rel="noopener ugc nofollow" target="_blank"><strong class="iz hu">Twitter</strong></a><strong class="iz hu"/><a class="ae kc" href="https://www.facebook.com/AventusNetwork/" rel="noopener ugc nofollow" target="_blank"><strong class="iz hu">【脸书</strong></a><strong class="iz hu"/><a class="ae kc" href="http://www.youtube.com/c/AventusNetwork" rel="noopener ugc nofollow" target="_blank"><strong class="iz hu">Youtube</strong><strong class="iz hu"/></a><a class="ae kc" href="https://www.instagram.com/aventusnetwork/" rel="noopener ugc nofollow" target="_blank"><strong class="iz hu">insta gram上与我们联系</strong></a></p><p id="0fa0" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">此外，我们已经为票务开发者/其他开发者建立了一个<a class="ae kc" href="https://www.linkedin.com/groups/12118192/" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hu"> LinkedIn群组</strong></a>来参与、加入我们并开始对话。</p><blockquote class="mu"><p id="18de" class="mv mw ht bd mx my mz na nb nc nd ju ek translated">加入Coinmonks <a class="ae kc" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae kc" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae kc" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="kn ko ht bd lq lr ne lt lu lv nf lx ly ji ng ma mb jm nh md me jq ni mg mh mi dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="ky kz ht iz b ja mj je mk ji nj jm nk jq nl ju ld le lf lg dt translated"><a class="ae kc" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae kc" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated"><a class="ae kc" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae kc" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated"><a class="ae kc" rel="noopener" href="/coinmonks/top-3-telegram-channels-for-crypto-traders-in-2021-8385f4411ff4">密码电报信号</a> | <a class="ae kc" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated"><a class="ae kc" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae kc" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="fac0" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated"><a class="ae kc" rel="noopener" href="/coinmonks/bigone-exchange-review-64705d85a1d4"> BigONE交易所点评</a> | <a class="ae kc" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">电网交易Bot </a></li><li id="007c" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated"><a class="ae kc" href="https://coincodecap.com/anny-trade-review" rel="noopener ugc nofollow" target="_blank">氹欞侊贸易评论</a> | <a class="ae kc" href="https://coincodecap.com/coinspot-review" rel="noopener ugc nofollow" target="_blank"> CoinSpot评论</a></li><li id="f2dd" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated"><a class="ae kc" href="https://coincodecap.com/crypto-exchange-in-singapore" rel="noopener ugc nofollow" target="_blank">新加坡十大最佳加密交易所</a> | <a class="ae kc" href="https://coincodecap.com/buy-axs-token" rel="noopener ugc nofollow" target="_blank">购买AXS </a></li><li id="45e2" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated"><a class="ae kc" href="https://coincodecap.com/best-crypto-to-invest-in-india-in-2021" rel="noopener ugc nofollow" target="_blank">投资印度的最佳加密软件</a> | <a class="ae kc" href="https://coincodecap.com/wazirx-p2p" rel="noopener ugc nofollow" target="_blank"> WazirX P2P </a></li><li id="1e2d" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated"><a class="ae kc" href="https://coincodecap.com/copy-trading-spain" rel="noopener ugc nofollow" target="_blank">西班牙5大最佳文案交易平台</a></li><li id="84e7" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated"><a class="ae kc" href="https://coincodecap.com/pionex-dual-investment" rel="noopener ugc nofollow" target="_blank"> Pionex双投</a> | <a class="ae kc" href="https://coincodecap.com/advcash-review" rel="noopener ugc nofollow" target="_blank"> AdvCash审核</a> | <a class="ae kc" href="https://coincodecap.com/uphold-review" rel="noopener ugc nofollow" target="_blank">光宗耀祖审核</a></li><li id="47a8" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">开发人员的最佳加密API</li><li id="b359" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated">最佳<a class="ae kc" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated"><a class="ae kc" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae kc" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="ky kz ht iz b ja lk je ll ji lm jm ln jq lo ju ld le lf lg dt translated"><a class="ae kc" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li></ul></div></div>    
</body>
</html>