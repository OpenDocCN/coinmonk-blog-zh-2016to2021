<html>
<head>
<title>Hyperledger composer — Docker Swarm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">hyperledger composer—Docker Swarm</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/hyperledger-composer-docker-swarm-a15bef803c8b?source=collection_archive---------0-----------------------#2018-02-09">https://medium.com/coinmonks/hyperledger-composer-docker-swarm-a15bef803c8b?source=collection_archive---------0-----------------------#2018-02-09</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/></div><div class="ab cl iq ir hb is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hm hn ho hp hq"><figure class="iy iz ja jb fq jc fe ff paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="fe ff ix"><img src="../Images/ae5bbc39965187645d0917c1eaf056dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VyuX8FD8RbLio9bjY7Tdlw.jpeg"/></div></div></figure><p id="e413" class="pw-post-body-paragraph jj jk ht jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hm dt translated">本文基于基本的hyperledger fabric-tools示例。</p><pre class="iy iz ja jb fq kh ki kj kk aw kl dt"><span id="2a1d" class="km kn ht ki b fv ko kp l kq kr">curl -O https://raw.githubusercontent.com/hyperledger/composer-tools/master/packages/fabric-dev-servers/fabric-dev-servers.zip</span><span id="d253" class="km kn ht ki b fv ks kp l kq kr">unzip fabric-dev-servers.zip</span></pre><p id="ae9e" class="pw-post-body-paragraph jj jk ht jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hm dt translated">目标是以fabric-tools为例，尝试使用docker swarm在多个节点上部署一个多对等解决方案。这些是我的发现。</p><h1 id="a575" class="kt kn ht bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">不断增加的资源</h1><p id="5b76" class="pw-post-body-paragraph jj jk ht jl b jm lq jo jp jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg hm dt translated">第一步是将加密资源挂载为NFS，这样它们就可以在整个网络中共享。我将导出文件设置如下:</p><pre class="iy iz ja jb fq kh ki kj kk aw kl dt"><span id="94cd" class="km kn ht ki b fv ko kp l kq kr">/srv/NFS *(rw,sync,no_subtree_check,no_root_squash,no_all_squash)</span></pre><p id="8047" class="pw-post-body-paragraph jj jk ht jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hm dt translated">在文件夹<code class="eh lv lw lx ki b">srv/NFS</code>中，我建立了<code class="eh lv lw lx ki b">cryptoconfig.yaml</code>文件和<code class="eh lv lw lx ki b">configtx.yaml</code>文件。从那里，我使用hyperledger工具设置资源。要将NFS卷安装到docker容器，需要将docker-compose从<code class="eh lv lw lx ki b">version ‘2'</code>更改为<code class="eh lv lw lx ki b">version ‘3.2'</code></p><p id="e7ab" class="pw-post-body-paragraph jj jk ht jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hm dt translated">下面是将驱动器安装到对等机的composer文件的设置示例:</p><pre class="iy iz ja jb fq kh ki kj kk aw kl dt"><span id="6342" class="km kn ht ki b fv ko kp l kq kr"><br/>peer0:<br/>    image: hyperledger/fabric-peer:x86_64-1.0.4<br/>    environment:<br/>      - CORE_LOGGING_PEER=debug<br/>      - CORE_CHAINCODE_LOGGING_LEVEL=DEBUG<br/>      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock<br/>      - CORE_PEER_ID=peer0<br/>      - CORE_PEER_ADDRESS=peer_peer0:7051    <br/>      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=net<br/>      - CORE_PEER_LOCALMSPID=MarsMSP<br/>      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/peer/msp<br/>      - CORE_LEDGER_STATE_STATEDATABASE=CouchDB<br/>      - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couch_couchdb0:5984<br/>      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@example.com/msp<br/>    working_dir: /etc/hyperledger/configtx<br/>    command: peer node start --peer-defaultchain=false<br/>    ports:<br/>      - 7051:7051<br/>      - 7053:7053<br/>    volumes:<br/>        - /var/run/:/host/var/run/<br/>        - /var/run/docker.sock:/var/run/docker.sock<br/>        - type: volume<br/>          source: tx<br/>          target: /etc/hyperledger/configtx<br/>          volume:<br/>            nocopy: true<br/>        - type: volume<br/>          source: peer0MSP<br/>          target: /etc/hyperledger/peer/msp<br/>          volume:<br/>            nocopy: true<br/><br/>volumes: <br/>  tx:<br/>    driver_opts:<br/>      type: "nfs"<br/>      o: "addr=XXX.XXX.XXX.XXX,nolock,soft,rw"<br/>      device: ":/srv/NFS"  <br/><br/>  peer0MSP:<br/>    driver_opts:<br/>      type: "nfs"<br/>      o: "addr=XXX.XXX.XXX.XXX,nolock,soft,rw"<br/>      device: ":/srv/NFS/crypto-config/peerOrganizations/or1.example.com/peers/peer0.example.com/msp"</span></pre><h1 id="6f38" class="kt kn ht bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">群体配置</h1><p id="9bc5" class="pw-post-body-paragraph jj jk ht jl b jm lq jo jp jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg hm dt translated">对于这个测试，我使用了三个节点。使用docker swarm文档，我将节点连接在一起。然后，在创建不同的堆栈之前，我创建了一个覆盖网络。</p><pre class="iy iz ja jb fq kh ki kj kk aw kl dt"><span id="8196" class="km kn ht ki b fv ko kp l kq kr">docker network create -d overlay --attachable net</span></pre><p id="90f2" class="pw-post-body-paragraph jj jk ht jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hm dt translated">在docker为每个堆栈编写yml文件时，覆盖网络被指定为外部网络。</p><pre class="iy iz ja jb fq kh ki kj kk aw kl dt"><span id="b932" class="km kn ht ki b fv ko kp l kq kr">networks:<br/>  net:<br/>    external:<br/>      name: net</span></pre><p id="c3ee" class="pw-post-body-paragraph jj jk ht jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hm dt translated">Docker stack deploy不像docker compose那样允许选项<code class="eh lv lw lx ki b">depends_on</code>，因此我为每个需要的组件创建了单独的compose文件。然后，我使用一个bash脚本文件来调用每个单独的堆栈。</p><pre class="iy iz ja jb fq kh ki kj kk aw kl dt"><span id="6445" class="km kn ht ki b fv ko kp l kq kr">docker network create -d overlay --attachable net</span><span id="03e1" class="km kn ht ki b fv ks kp l kq kr">docker stack deploy -c docker-compose.couch.yml couch <br/>sleep 5<br/>docker stack deploy -c docker-compose.otx.yml otx<br/>sleep 5<br/>docker stack deploy -c docker-compose.peers.yml peer<br/>docker stack deploy -c docker-compose.deploy.yml deploy</span></pre><p id="5fed" class="pw-post-body-paragraph jj jk ht jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hm dt translated">非标准的主要内容是在部署映像中。这是从一个<code class="eh lv lw lx ki b">hyperledger/fabric-tools</code>图像修改而来的，添加了composer开发工具。该图像然后共享来自NFS卷的基本作曲项目。使用这个映像，我可以将composer应用程序部署到swarm。当我在swarm中使用一个容器来部署我的composer应用程序时，我直接引用了容器，如下所示:</p><pre class="iy iz ja jb fq kh ki kj kk aw kl dt"><span id="790d" class="km kn ht ki b fv ko kp l kq kr">localhost:7051 --&gt; peer_peer0:7051<br/>localhost:7083 --&gt; peer_peer1:7051</span></pre><p id="9f76" class="pw-post-body-paragraph jj jk ht jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hm dt translated">在composer项目中更改<code class="eh lv lw lx ki b">connection.json</code>文件并直接引用容器，这意味着我可以登录到部署容器并部署业务网络档案。</p><blockquote class="ly"><p id="8398" class="lz ma ht bd mb mc md me mf mg mh kg ek translated"><a class="ae mi" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mk ml mm mn mo jc fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mj"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>