<html>
<head>
<title>Simple Refactoring with Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单可靠的重构</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/simple-refactoring-with-solidity-f37c1c1208a8?source=collection_archive---------5-----------------------#2018-09-28">https://medium.com/coinmonks/simple-refactoring-with-solidity-f37c1c1208a8?source=collection_archive---------5-----------------------#2018-09-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/bdbc9edb4041260a3ebe002ffec2e16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l4DDk2SmuBnMAsq9.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek"><a class="ae jf" href="https://artandlogic.com/2016/09/why-refactor/" rel="noopener ugc nofollow" target="_blank">Image Source</a></figcaption></figure><p id="bcaf" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">经典的电影台词是“我喜欢早晨重构的味道”，对吗？我就是这么记得的。</p><p id="e606" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我最近在研究一个客户的代码库，虽然我的任务只是确保代码按预期工作，但我不能停下来，而是认为一点点重构将大大有助于使代码更加简洁，运行成本更低，更容易阅读。</p><p id="d502" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">下面是一个(非常)干净的初始代码版本。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="4c5c" class="kn ko ht kj b fv kp kq l kr ks">pragma solidity ^0.4.22;</span><span id="98a0" class="kn ko ht kj b fv kt kq l kr ks">contract Voting {</span><span id="93fa" class="kn ko ht kj b fv kt kq l kr ks">  address[] public candidates;<br/>  mapping(address =&gt; uint) public votesReceived;</span><span id="21b9" class="kn ko ht kj b fv kt kq l kr ks">  function Voting(address[] candidateNames) public { <em class="ku">//330717 gas w/ 5 candidates</em></span><span id="fe5a" class="kn ko ht kj b fv kt kq l kr ks">    candidates = candidateNames;<br/>  }</span><span id="bbed" class="kn ko ht kj b fv kt kq l kr ks">  function voteForCandidate(address candidate) public { <em class="ku">//21404 gas</em><br/>    require(isValidCandidate(candidate));<br/>    votesReceived[candidate] += 1;<br/>  }</span><span id="4108" class="kn ko ht kj b fv kt kq l kr ks">  function totalVotesFor(address candidate) view public returns (uint) {<br/>    require(isValidCandidate(candidate));<br/>    return votesReceived[candidate];<br/>  }</span><span id="8820" class="kn ko ht kj b fv kt kq l kr ks">  function isValidCandidate(address candidate) view public returns (bool) {<br/>    for(uint i = 0; i &lt; candidates.length; i++) {<br/>      if (candidates[i] == candidate) {<br/>        return true;<br/>      }<br/>    }<br/>    return false;<br/>  }<br/>}</span></pre><p id="0b46" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">引起我注意的第一件事是对构造函数使用了现在已被否决的语法。在Solidity中，一个契约的构造函数曾经被定义为与契约本身具有完全相同的名称。也就是说，如果契约名为“<em class="ku"> Voting </em>”，那么名为“<em class="ku"> Voting </em>”的函数将被理解为它的构造函数，这是一个在部署时只运行一次的特殊函数，但名为“<em class="ku"> voting </em>”(小型大写字母)的函数将是一个普通的、普遍可访问的函数。这种语法结构是许多代价高昂的错误的来源，因为部署的合同未初始化，敏感的“管理”函数对任何<a class="ae jf" href="https://cryptoshirt.io/products/devops199-quote-i-accidentally-killed-it-tee" rel="noopener ugc nofollow" target="_blank"> <em class="ku"> devops199 </em> </a>开放… <a class="ae jf" href="https://solidity.readthedocs.io/en/latest/contracts.html" rel="noopener ugc nofollow" target="_blank">现在</a>我们使用一个名为“构造函数”的函数，这很难被忽略。</p><p id="05ed" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">接下来是数据结构。存储一个包含所有有效候选地址的数组代价很高。我的意思是，理想的成本是一个效用函数，让合同可以访问数据进行操作，所以在做出判断之前，我们需要看看合同用它做了什么。在这里，它通过使用“<em class="ku"> isValidCandidate </em>”函数和“<em class="ku"> require </em>”关键字来进行输入清理。呀，那肯定很贵。</p><p id="e0da" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">编写智能合同更接近于嵌入式设备的开发，而不是web开发，因为每一项计算都是通过“gas”机制进行计算和成本估算的。这使得循环和从状态的过度写入和读取是不明智的，因为如果从不同的智能契约调用，即使调用只读的“view”函数也将花费大量的时间，这是好的，因为这样一来，一个糟糕的开发人员将比一个好的开发人员花费更多的时间:-)</p><p id="020a" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们知道，Solidity为标识为“public”的数据类型提供了免费的getter函数，“<em class="ku"> totalVotesFor </em>”和“<em class="ku"> isValidCandidate </em>”函数只是通过简单地调用“<em class="ku">candidateAddr”来复制已经可用的功能。选票</em>和<em class="ku">候选人[_candidateAddr]。isValid </em>”分别，所以我决定把它们去掉。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="92bb" class="kn ko ht kj b fv kp kq l kr ks">pragma solidity ^0.4.25;</span><span id="107f" class="kn ko ht kj b fv kt kq l kr ks">contract RefactoredVoting {</span><span id="2e82" class="kn ko ht kj b fv kt kq l kr ks">    struct CandidateStruct {<br/>        bool isValid;<br/>        uint64 votes;<br/>    }<br/>    mapping(address =&gt; CandidateStruct) public candidates;</span><span id="f030" class="kn ko ht kj b fv kt kq l kr ks">    constructor(address[] _candidates) public { <em class="ku">//205108 gas w/ 5 candidates</em><br/>        for (uint i = 0; i &lt; _candidates.length; i++) {<br/>            candidates[_candidates[i]].isValid = true;<br/>        }<br/>    }</span><span id="9daa" class="kn ko ht kj b fv kt kq l kr ks">    function voteForCandidate(address _candidate) public { <em class="ku">//5910 gas</em><br/>        candidates[_candidate].votes += 1;<br/>    }<br/>}</span></pre><p id="27ed" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">用5个候选地址运行一个简单的测试表明，在天然气成本方面取得了一些良好的进展。部署现在花费大约205k汽油，低于大约330k，而“voteForCandidate”功能只需要大约6k汽油，低于原始代码中的大约21k。</p><p id="0737" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通过将投票保持为uint256(以太坊使用32字节的字)可以减少部署时的开销，但是投票函数膨胀到大约20k gas，老实说，我认为没有人会需要超过9223372036854775807的投票。:-)</p><blockquote class="kv"><p id="2e0a" class="kw kx ht bd ky kz la lb lc ld le kd ek translated"><a class="ae jf" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="lg lh li lj lk iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lf"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>