<html>
<head>
<title>Ethereum Smart Contract Development with a Web App — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Web应用程序开发以太坊智能合约—第3部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethereum-smart-contract-development-with-a-web-app-part-3-71cb51144249?source=collection_archive---------6-----------------------#2018-07-30">https://medium.com/coinmonks/ethereum-smart-contract-development-with-a-web-app-part-3-71cb51144249?source=collection_archive---------6-----------------------#2018-07-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/196c2cb4a67458882424cf2c15120f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RWE7v0Ic9bsVQ9pH.png"/></div></div></figure><p id="1a0c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这篇文章中，你将会学到一些如何将以太坊(使用solidity开发的)智能合约转换成有用的web应用程序的知识。这是以太坊智能联系人开发博客系列的第三部分。如果这是你提到的第一个帖子，我建议你访问以前的帖子，了解一些关于在以太坊中使用Solidity进行智能合约开发的知识。在本例中，我也将使用我们在前面部分中开发的智能合约。在这篇文章中，我只是在之前部署的智能合约中添加了一个用户界面层。</p><p id="97f2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以下是这个博客系列的其他主题。</p><ol class=""><li id="faea" class="jz ka ht jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated"><a class="ae ki" rel="noopener" href="/coinmonks/ethereum-smart-contract-development-with-a-web-app-part-1-develop-the-smart-contract-ee2a7c735936">在Solidity中开发智能合同，并将其部署在其中一个测试网络中</a></li><li id="39d3" class="jz ka ht jd b je kj ji kk jm kl jq km ju kn jy ke kf kg kh dt translated"><a class="ae ki" rel="noopener" href="/coinmonks/ethereum-smart-contract-development-with-a-web-app-part-2-testing-and-deployment-34a885e750b2">在真实网络(Rinkeby网络)中自动测试和部署您的智能合约</a></li><li id="af6f" class="jz ka ht jd b je kj ji kk jm kl jq km ju kn jy ke kf kg kh dt translated">构建一个前端web层来与部署的智能合同进行交互(本文)</li><li id="8cd3" class="jz ka ht jd b je kj ji kk jm kl jq km ju kn jy ke kf kg kh dt translated">在您自己的多节点以太网上部署智能合约</li></ol><p id="e964" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这篇文章中，我将使用ReactJs web toolkit开发一个web应用程序，与以太坊Rinkerby网络中部署的智能联系人进行交互。您可以使用任何其他语言/工具来开发web前端，但是，与其他工具相比，ReactJs包含一些很好的工具，您可以轻松地与Web3框架集成。</p><p id="3de9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先我们需要安装npm包来创建一个React应用程序。</p><p id="943e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">&gt; sudo NPM install-g create-react-app</p><p id="cfb0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后我们需要使用下面的命令创建react应用程序。</p><p id="c9e5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">&gt;创建-反应-应用程序多重授权</p><p id="4c52" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当您创建react应用程序时，它会创建一个样板模板，您可以从这里开始工作。它包含所需的主要文件，如index.heml、app.js、index.js、index.css等..</p><p id="8f00" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Web3是一个包，我们将使用它作为已部署智能合约的接口，并访问加密钱包(元掩码)</p><p id="5a9c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">&gt; npm安装—保存web3@1.0.0-beta.26</p><p id="c98e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们有东西开始我们的开发工作了。在开始开发工作之前，我想解释一件小事。我希望此时你已经熟悉了MetaMask钱包。如果您已经将它作为插件安装在浏览器中，它会自动将web3提供程序添加到您的浏览器中。因此，当我们开发我们的网络应用程序时，我们可以使用相同的插件。然而，问题是使用MetaMask安装的缺省Web3版本是0.2*(截至本文撰写之日)。但是我们需要Web3版本1.0来使用我们的智能合约。因此，我们需要做的是用我们需要的版本覆盖元掩码的默认版本。</p><p id="99af" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下图描述了Web3提供程序的格式。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff ko"><img src="../Images/926d4a22b7d3869cc81d270ec11f128e.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*Ts9JrIVE2PkAlK-x.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image : ReactJs App interface with Web3</figcaption></figure><p id="109c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，我们必须设置所需的库和样板工程。现在让我们关注如何处理编码，以便与我们在Rinkerby网络中部署的智能契约进行交互。</p><p id="d743" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，我们需要创建一个js文件来指定我们的ABI(应用程序二进制接口)和部署地址。如果你不知道如何得到它，请参考我以前在这个博客系列中的文章。</p><p id="7209" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这个例子中，我将使用multiauth.js文件来满足这个需求。</p><pre class="kp kq kr ks fq kx ky kz la aw lb dt"><span id="a4e0" class="lc ld ht ky b fv le lf l lg lh">import web3 <strong class="ky hu">from</strong> './web3';<br/><br/><strong class="ky hu">const</strong> deployeAddress = '<strong class="ky hu">0</strong>x101D450A5Cf279A4875fb31dA5791546406D0767';<br/><br/><strong class="ky hu">const</strong> deployedAbi = [{"constant":<strong class="ky hu">false</strong>,"inputs":[],"name":"approve","outputs":[],"payable":<strong class="ky hu">true</strong>,"stateMutability":"payable","type":"function"},{"constant":<strong class="ky hu">true</strong>,"inputs":[],"name":"getContractBalance","outputs":[{"name":"","type":"uint256"}],"payable":<strong class="ky hu">false</strong>,"stateMutability":"view","type":"function"},{"constant":<strong class="ky hu">true</strong>,"inputs":[],"name":"requester","outputs":[{"name":"","type":"address"}],"payable":<strong class="ky hu">false</strong>,"stateMutability":"view","type":"function"},{"constant":<strong class="ky hu">true</strong>,"inputs":[{"name":"","type":"uint256"}],"name":"approvers","outputs":[{"name":"approver","type":"address"},{"name":"isApproved","type":"bool"}],"payable":<strong class="ky hu">false</strong>,"stateMutability":"view","type":"function"},{"constant":<strong class="ky hu">true</strong>,"inputs":[],"name":"receiver","outputs":[{"name":"","type":"address"}],"payable":<strong class="ky hu">false</strong>,"stateMutability":"view","type":"function"},{"inputs":[{"name":"approversList","type":"address[]"},{"name":"receivedBy","type":"address"}],"payable":<strong class="ky hu">true</strong>,"stateMutability":"payable","type":"constructor"}];<br/><br/>export <strong class="ky hu">default</strong> <strong class="ky hu">new</strong> web3.eth.Contract(deployedAbi,deployeAddress);</span></pre><p id="3af1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们需要在代码中指定部署的地址(部署到Rinkerby网络中的智能合约的地址)和ABI，并从该文件中导出合约对象。</p><p id="f70a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">web3包封装在文件(web3.js)中，如下所示。</p><pre class="kp kq kr ks fq kx ky kz la aw lb dt"><span id="a1d4" class="lc ld ht ky b fv le lf l lg lh">import Web3 <strong class="ky hu">from</strong> 'web3';<br/><br/><strong class="ky hu">const</strong> web3 = <strong class="ky hu">new</strong> Web3(window.web3.currentProvider);<br/><br/>export <strong class="ky hu">default</strong> web3;</span></pre><p id="710f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该文件用于覆盖我们安装到该应用程序中的版本的MetaMask的默认web3版本(v0.20)。</p><p id="e911" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，也是最重要的，我们需要如下所示的app.js文件。我将带您浏览每个部分并描述其功能。</p><pre class="kp kq kr ks fq kx ky kz la aw lb dt"><span id="0960" class="lc ld ht ky b fv le lf l lg lh">import React, { Component } <strong class="ky hu">from</strong> 'react';<br/>import logo <strong class="ky hu">from</strong> './logo.svg';<br/>import './App.css';<br/>import web3 <strong class="ky hu">from</strong> './web3';<br/>import auth <strong class="ky hu">from</strong> './multiauth';<br/><br/><strong class="ky hu">class</strong> <strong class="ky hu">App</strong> extends Component {<br/><br/>  constructor(props){<br/>    super(props);<br/><br/>    <strong class="ky hu">this</strong>.state = {requester : '', receiver:'', balance: '', message:''};<br/>  }<br/><br/> <strong class="ky hu">async</strong>  <strong class="ky hu">componentDidMount</strong>(){<br/>    <strong class="ky hu">const</strong> requester = <strong class="ky hu">await</strong> auth.methods.requester().call();<br/>    <strong class="ky hu">const</strong> receiver = <strong class="ky hu">await</strong> auth.methods.receiver().call();<br/>    <strong class="ky hu">const</strong> approvers = <strong class="ky hu">await</strong> auth.methods.approvers(<strong class="ky hu">0</strong>).call();<br/>    <strong class="ky hu">const</strong> balance = <strong class="ky hu">await</strong> web3.eth.getBalance(auth.options.address);<br/><br/>    <strong class="ky hu">this</strong>.setState({requester,receiver,balance});<br/>  }<br/><br/>  onSubmit = <strong class="ky hu">async</strong> (<strong class="ky hu">event</strong>)=&gt;{<br/>      <strong class="ky hu">event</strong>.preventDefault();<br/>      <strong class="ky hu">const</strong> accounts = <strong class="ky hu">await</strong> web3.eth.getAccounts();<br/><br/>      <strong class="ky hu">this</strong>.setState({message: 'Approving the smart contract ..... Mining <strong class="ky hu">in</strong> process ! '});<br/>      <strong class="ky hu">await</strong> auth.methods.approve().send({<strong class="ky hu">from</strong>: accounts[<strong class="ky hu">0</strong>]});<br/>      <strong class="ky hu">this</strong>.setState({message: 'Smart Contract approved'});<br/>  };<br/><br/>  render() {<br/>    <strong class="ky hu">return</strong> (<br/>        &lt;div&gt;<br/>          &lt;h1&gt; Multi Party Auth systems  &lt;/h1&gt;<br/>          &lt;p&gt; This <strong class="ky hu">is</strong> approval <strong class="ky hu">is</strong> requested by {<strong class="ky hu">this</strong>.state.requester}&lt;/p&gt;<br/>          &lt;br/&gt;<br/>          &lt;p&gt; This <strong class="ky hu">is</strong> approval will be received By {<strong class="ky hu">this</strong>.state.receiver}&lt;/p&gt;<br/>          &lt;br/&gt;<br/>          &lt;p&gt; This <strong class="ky hu">is</strong> approval amount <strong class="ky hu">is</strong> :  { <strong class="ky hu">this</strong>.state.balance} Wei &lt;/p&gt;<br/>          &lt;hr/&gt;<br/>          &lt;form onSubmit={<strong class="ky hu">this</strong>.onSubmit}&gt;<br/>            &lt;h3&gt;Approve the contract&lt;/h3&gt;<br/>            &lt;div&gt;<br/>              &lt;input<br/>                <strong class="ky hu">value</strong> = {<strong class="ky hu">this</strong>.state.<strong class="ky hu">value</strong>}<br/>                onChange = { <strong class="ky hu">event</strong> =&gt; <strong class="ky hu">this</strong>.setState({<strong class="ky hu">value</strong> : <strong class="ky hu">event</strong>.target.<strong class="ky hu">value</strong>})}<br/>              /&gt;<br/>              &lt;button&gt;Aprove the contract&lt;/button&gt;<br/>            &lt;/div&gt;<br/>          &lt;/form&gt;<br/>          &lt;hr/&gt;<br/>          &lt;h3&gt;{<strong class="ky hu">this</strong>.state.message}&lt;/h3&gt;<br/>        &lt;/div&gt;<br/><br/>    );<br/>  }<br/>}<br/><br/>export <strong class="ky hu">default</strong> App;</span></pre><p id="86b5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦呈现了所有组件(componentDidMount方法)，应用程序就访问关于该智能合约的所需信息。我们可以在render方法中呈现这些信息。</p><p id="b99f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当应用程序启动时，它看起来如下。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff li"><img src="../Images/b52efa998ea08d0e7bf83aec07c421b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*TH06qLBf0UTtaE7g.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 2 : ReactJs App User Interface</figcaption></figure><p id="4366" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你可能会看到网页看起来不酷，但它会按要求做工作。</p><p id="0f91" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这个智能合同中，最重要的方法是批准。这是可以批准智能联系人的地方。如果您检查代码，您可能已经注意到我们正在使用一个基于索引的帐户来批准合同，如下所示。</p><p id="c8e5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">等待auth.methods.approve()。发送({发件人:帐户[0]})；</p><p id="b956" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这些帐户是从元掩码工具中获取的，帐户[0]表示元掩码中选定的帐户。该帐户通过MetaMask安装的内置web3与浏览器连接。</p><p id="3646" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦正确的用户触发了批准按钮，您可能会发现处理交易需要一些时间(大约30-120秒)。这是我们可以体验传统交易和区块链交易的主要区别。您可以在传统数据库驱动的应用程序中非常快速地(几毫秒)处理这种事务。但请记住，当涉及到区块链交易时，我们需要进行挖掘。</p><p id="3d25" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦用户单击approve按钮，MetaMask就会弹出，提示您批准继续进行交易。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff li"><img src="../Images/e167b944b7d49982b1985cc4e71e6d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*1PID0r-RKi1n4UeG.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Image 3 : MetaMask payment conformation</figcaption></figure><p id="99f5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您可以看到元掩码正在执行从您选择的帐户到部署的智能合约的地址的交易。</p><p id="5ead" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">结论</strong></p><p id="e308" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">恭喜你！您在以太坊网络中使用Solidity、Web3和ReactJs实现了一个端到端的应用。我希望你喜欢这个博客系列，并准备在Ethrerum中实现你自己的智能合同。ReactJs应用程序需要更多的修补，如验证、UI改进、异常处理等..但是它包含了你需要开始的所有骨架。</p><p id="85e2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果你有任何疑问/担忧，那么你可以给我发一封电子邮件到<a class="ae ki" href="https://www.linkedin.com/in/priyalwalpita/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae ki" href="https://twitter.com/@priyalthegeek" rel="noopener ugc nofollow" target="_blank"> Twitter </a>给我发信息。我只差一条消息:)感谢阅读！</p><blockquote class="lj"><p id="02af" class="lk ll ht bd lm ln lo lp lq lr ls jy ek translated"><a class="ae ki" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="lu lv lw lx ly iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lt"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>