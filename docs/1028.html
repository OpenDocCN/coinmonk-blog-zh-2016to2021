<html>
<head>
<title>A (Practical) Walkthrough of Smart Contract Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合同存储的(实用)演练</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-practical-walkthrough-smart-contract-storage-d3383360ea1b?source=collection_archive---------0-----------------------#2018-07-13">https://medium.com/coinmonks/a-practical-walkthrough-smart-contract-storage-d3383360ea1b?source=collection_archive---------0-----------------------#2018-07-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="b0e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在开始之前，已经有两个关于这个主题的极好的来源，它们很好地涵盖了大多数基本用例:</p><p id="b40e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个很棒，但是写得很扎实，这意味着不容易弄脏手进行测试:</p><div class="jo jp fm fo jq jr"><a href="https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/" rel="noopener  ugc nofollow" target="_blank"><div class="js ab ej"><div class="jt ab ju cl cj jv"><h2 class="bd hu fv z el jw eo ep jx er et hs dt translated">了解以太坊智能合约存储</h2><div class="jy l"><h3 class="bd b fv z el jw eo ep jx er et ek translated">以太坊智能合约使用一种不常见的存储模型，这种模型经常让新开发人员感到困惑。在这篇文章中，我将描述…</h3></div><div class="jz l"><p class="bd b gc z el jw eo ep jx er et ek translated">programtheblockchain.com</p></div></div><div class="ka l"><div class="kb l kc kd ke ka kf kg jr"/></div></div></a></div><p id="423b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">第二个是用javascript编写的，但是非常简短，没有任何测试:</p><div class="jo jp fm fo jq jr"><a rel="noopener follow" target="_blank" href="/aigang-network/how-to-read-ethereum-contract-storage-44252c8af925"><div class="js ab ej"><div class="jt ab ju cl cj jv"><h2 class="bd hu fv z el jw eo ep jx er et hs dt translated">如何阅读以太坊合约存储</h2><div class="jy l"><h3 class="bd b fv z el jw eo ep jx er et ek translated">每个人都在谈论合同中的数据是公开的，但不是每个人都知道如何阅读它。</h3></div><div class="jz l"><p class="bd b gc z el jw eo ep jx er et ek translated">medium.com</p></div></div><div class="ka l"><div class="kh l kc kd ke ka kf kg jr"/></div></div></a></div><p id="8641" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">本教程的目的是使用truffle采取一种更加测试驱动的方法，以便充分了解这些不同的数据结构是如何存储的。在这个过程中，我们还将创建一些简洁的工具。</p><blockquote class="ki"><p id="1b34" class="kj kk ht bd kl km kn ko kp kq kr jn ek translated"><a class="ae ks" href="https://coincodecap.com" rel="noopener ugc nofollow" target="_blank">发现并回顾最佳区块链软件</a></p></blockquote><p id="6d44" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hm dt translated">本教程不会介绍所有可能的存储方法，它将介绍一个包含许多但不是所有情况的暂停列表。值得一提的一种类型是数组。我们将查找并测试以下类型:</p><ol class=""><li id="0cb8" class="ky kz ht is b it iu ix iy jb la jf lb jj lc jn ld le lf lg dt translated">布尔运算</li><li id="69c5" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">尤因茨</li><li id="ea07" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">用线串</li><li id="d0a3" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">映射</li><li id="7f27" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">嵌套映射</li><li id="1bf8" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">地址</li></ol><p id="0400" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您迷路了，可以在这里找到本教程的完整代码:</p><div class="jo jp fm fo jq jr"><a href="https://github.com/TovarishFin/storage-coin-tutorial" rel="noopener  ugc nofollow" target="_blank"><div class="js ab ej"><div class="jt ab ju cl cj jv"><h2 class="bd hu fv z el jw eo ep jx er et hs dt translated">TovarishFin/存储-硬币-教程</h2><div class="jy l"><h3 class="bd b fv z el jw eo ep jx er et ek translated">存储-硬币-教程-代码存储教程发现在https://medium.codylamson.com</h3></div><div class="jz l"><p class="bd b gc z el jw eo ep jx er et ek translated">github.com</p></div></div><div class="ka l"><div class="lm l kc kd ke ka kf kg jr"/></div></div></a></div><p id="c920" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">说到这里……让我们开始吧。</p><h2 id="da82" class="ln lo ht bd lp lq lr ls lt lu lv lw lx jb ly lz ma jf mb mc md jj me mf mg mh dt translated">项目设置</h2><p id="e8bb" class="pw-post-body-paragraph iq ir ht is b it mi iv iw ix mj iz ja jb mk jd je jf ml jh ji jj mm jl jm jn hm dt translated">如果您还没有全球安装truffle:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="0e7c" class="ln lo ht ms b fv mw mx l my mz">yarn global add truffle</span></pre><p id="ca94" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">创建目录并输入:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="f6e4" class="ln lo ht ms b fv mw mx l my mz">mkdir contract-storage &amp;&amp; cd contract-storage</span></pre><p id="91f2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">启动松露项目:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="433d" class="ln lo ht ms b fv mw mx l my mz">truffle init</span></pre><p id="12cf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们创建将用于测试的契约:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="2323" class="ln lo ht ms b fv mw mx l my mz">touch contracts/StorageCoin.sol</span></pre><p id="146a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将使用OpenZeppelin的ERC20令牌来实现一些易于使用的存储，这可能更有关联:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="9a62" class="ln lo ht ms b fv mw mx l my mz">yarn add openzeppelin-solidity</span></pre><h2 id="6eb4" class="ln lo ht bd lp lq lr ls lt lu lv lw lx jb ly lz ma jf mb mc md jj me mf mg mh dt translated">写合同</h2><p id="3488" class="pw-post-body-paragraph iq ir ht is b it mi iv iw ix mj iz ja jb mk jd je jf ml jh ji jj mm jl jm jn hm dt translated">让我们使用OpenZeppelin的<code class="eh na nb nc ms b">PausableToken</code>创建一个简单的例子。将以下内容粘贴到<code class="eh na nb nc ms b">contracts/StorageCoin.sol</code>中:</p><figure class="mn mo mp mq fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="d0ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你不熟悉<code class="eh na nb nc ms b">PausableToken</code>，不要担心。在下一节中，我们将进一步研究它以及它所继承的任何契约。</p><p id="a9d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个契约将很好地完成，因为我们将使用以下数据类型:</p><ol class=""><li id="02a6" class="ky kz ht is b it iu ix iy jb la jf lb jj lc jn ld le lf lg dt translated">弦<code class="eh na nb nc ms b">name</code> &amp; <code class="eh na nb nc ms b">symbol</code></li><li id="b3a9" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">uint <code class="eh na nb nc ms b">totalSupply_</code>不是<code class="eh na nb nc ms b">decimals</code>是<code class="eh na nb nc ms b">private totalSupply_</code></li><li id="d42f" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">布尔<code class="eh na nb nc ms b">paused</code></li><li id="f3a2" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">地址<code class="eh na nb nc ms b">owner</code></li><li id="1b37" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">映射<code class="eh na nb nc ms b">balances</code></li><li id="c649" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">嵌套映射<code class="eh na nb nc ms b">allowance</code></li></ol><p id="de45" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">上面第二条有一些有趣的旁注:</strong></p><p id="2fcb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">小数不会被存储访问的原因是因为它不在那里！变量存在于代码中，而不是存储中。这允许一个人用这个做一些非常酷的把戏，我稍后会讲到。</p><p id="ed40" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将访问<code class="eh na nb nc ms b">private totalSupply_</code>的原因是，嗯，这是可能的。<code class="eh na nb nc ms b">private</code>任何对存储稍有了解的人都完全可以接触到变量。明确地说，这意味着当标记为私有时，您不应该假设用户无法访问任何内容。</p><h2 id="71f2" class="ln lo ht bd lp lq lr ls lt lu lv lw lx jb ly lz ma jf mb mc md jj me mf mg mh dt translated">准备编写测试</h2><p id="c9c8" class="pw-post-body-paragraph iq ir ht is b it mi iv iw ix mj iz ja jb mk jd je jf ml jh ji jj mm jl jm jn hm dt translated">在这一点上，有必要提一下存储是如何工作的。契约存储本质上类似于从<code class="eh na nb nc ms b">bytes32</code>到<code class="eh na nb nc ms b">bytes32</code>的映射。密钥可以很容易地解释为将字节转换为小数的数字:</p><p id="22cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">值从0开始按顺序存储:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="d306" class="ln lo ht ms b fv mw mx l my mz">0x00000000000000000000000000000000000000000000000000000000000000000</span></pre><p id="3346" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一直到⁵⁶或者1.157920892e77:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="59e6" class="ln lo ht ms b fv mw mx l my mz">0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></pre><p id="c91b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">给最后一个数字更多的背景…这是一个令人难以置信的巨大数字。地球上的原子比这个数字还少。</p><p id="1506" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">存储是按照合同代码中出现的顺序依次设置的。所有的存储都是以字节存储的，这意味着<a class="ae ks" href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/" rel="noopener ugc nofollow" target="_blank">了解ascii如何工作可能是个好主意</a>(字符串是以ascii而不是unicode编码的)。</p><p id="60d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">记住这一点，让我们找出变量在我们的契约中出现的顺序，包括继承。</p><p id="c0fd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们打算全局添加<code class="eh na nb nc ms b">truffle-flattener</code>，以便更好地了解存储在哪里。这个包将一个从不同文件的多个协定继承而来的协定转换成一个文件。它对于在<a class="ae ks" href="https://etherscan.io/" rel="noopener ugc nofollow" target="_blank"> etherscan </a>上验证合同也非常有用。</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="1ddb" class="ln lo ht ms b fv mw mx l my mz">yarn global add truffle-flattener</span></pre><p id="478f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们展平我们签订的合同，看看我们在这里做什么:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="dbca" class="ln lo ht ms b fv mw mx l my mz">truffle-flattener contracts/StorageCoin.sol &gt; StorageCoinFlattened.sol</span></pre><p id="8bcf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在你的根目录中打开<code class="eh na nb nc ms b">StorageCoinFlattened.sol</code>。你应该有和这个一样的:</p><figure class="mn mo mp mq fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure><h2 id="ef5a" class="ln lo ht bd lp lq lr ls lt lu lv lw lx jb ly lz ma jf mb mc md jj me mf mg mh dt translated">为简单存储编写测试</h2><p id="c468" class="pw-post-body-paragraph iq ir ht is b it mi iv iw ix mj iz ja jb mk jd je jf ml jh ji jj mm jl jm jn hm dt translated">让我们创建测试文件:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="0f84" class="ln lo ht ms b fv mw mx l my mz">touch test/StorageCoin.js</span></pre><p id="0ecc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是我们对<code class="eh na nb nc ms b">Storage.js</code>的基本布局:</p><figure class="mn mo mp mq fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="de04" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们有了布局，让我们创建我们的第一个工具！我们将创建一个函数来扫描指定数量的存储槽中的任何值。</p><p id="e468" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">创建一个新的<code class="eh na nb nc ms b">helpers.js</code>文件:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="3f73" class="ln lo ht ms b fv mw mx l my mz">touch test/helpers.js</span></pre><p id="90fd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们添加我们的老朋友，<code class="eh na nb nc ms b">BigNumber</code>和<code class="eh na nb nc ms b">chalk</code>来使事情变得更漂亮:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="3bab" class="ln lo ht ms b fv mw mx l my mz">yarn add "git+https://github.com/frozeman/bignumber.js-nolookahead.git" chalk</span></pre><p id="b0ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Truffle使用旧版本，所以我们必须确保安装正确的版本。</p><p id="bc1c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在打开<code class="eh na nb nc ms b">test/helpers.js</code>，让我们创建我们的第一个助手函数:</p><figure class="mn mo mp mq fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="bb06" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该函数将从第一个开始在存储槽中查找数据，直到连续10次只找到空槽。这里完成大部分工作的函数是<code class="eh na nb nc ms b">web3.eth.getStorageAt()</code>。这是我们从部署的智能合同中直接访问存储的方式。这也适用于mainnet或任何testnets上的合同。</p><p id="2748" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，让我们使用这个函数。更新<code class="eh na nb nc ms b">StorageCoin.js</code>喜欢这样:</p><figure class="mn mo mp mq fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="166f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们已经包含了助手函数和粉笔和工具。<code class="eh na nb nc ms b">chalk</code>只是为了颜色。为了正确注销对象，需要使用<code class="eh na nb nc ms b">util</code>。</p><p id="e31f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行<code class="eh na nb nc ms b">truffle test</code>看看我们有什么储物件。你应该得到这样的东西(但是有漂亮的颜色):</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="642e" class="ln lo ht ms b fv mw mx l my mz">local variables:<br/>totalSupply: 0x56bc75e2d63100000<br/>name: 0x53746f72616765436f696e<br/>symbol: 0x535443<br/>owner: 0x627306090abab3a6e1400e9345bc60c78a8bef57<br/>storage:<br/>[ { slot: 0, data: '0x0' },<br/>  { slot: 1, data: '0x056bc75e2d63100000' },<br/>  { slot: 2, data: '0x0' },<br/>  { slot: 3,<br/>    data: '0x01627306090abab3a6e1400e9345bc60c78a8bef57' },<br/>  { slot: 4,<br/>    data: '0x53746f72616765436f696e000000000000000000000000000000000000000016' },<br/>  { slot: 5,<br/>    data: '0x5354430000000000000000000000000000000000000000000000000000000006' },<br/>  { slot: 6, data: '0x0' },<br/>  { slot: 7, data: '0x0' },<br/>  { slot: 8, data: '0x0' },<br/>  { slot: 9, data: '0x0' },<br/>  { slot: 10, data: '0x0' },<br/>  { slot: 11, data: '0x0' },<br/>  { slot: 12, data: '0x0' },<br/>  { slot: 13, data: '0x0' },<br/>  { slot: 14, data: '0x0' } ]</span></pre><p id="8b78" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们试着破译这个，看看这里是什么。</p><p id="295a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">槽0是为平衡映射保留的空间。我们稍后将对此进行更深入的探讨。</p><p id="ff01" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果我们查看插槽1，我们可以看到，如果我们将十六进制值粘贴到工具中，它等于100e18。这是我们的<code class="eh na nb nc ms b">totalSupply</code>。我们知道这是<code class="eh na nb nc ms b">totalSupply</code>，因为映射以不同的方式存储，并且已经在slot 1中。</p><p id="79f6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">像槽0一样，槽2是另一个映射。这是嵌套的<code class="eh na nb nc ms b">allowed</code>映射。我们稍后也会深入探讨这一点。</p><p id="e95b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们可以立即知道槽3包含所有者地址。但是还有别的东西在那里…这是<code class="eh na nb nc ms b">paused</code>布尔。真将是<code class="eh na nb nc ms b">0x01</code>，假将是<code class="eh na nb nc ms b">0x00</code>。Solidity会尝试在一个储物格中放入多件物品。这正是这里发生的情况。</p><p id="7b10" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一旦将值粘贴到<a class="ae ks" href="https://www.rapidtables.com/convert/number/hex-to-ascii.html" rel="noopener ugc nofollow" target="_blank">十六进制到ascii转换器</a>中，就可以计算出插槽4。这是<code class="eh na nb nc ms b">name</code>变量。敏锐的眼睛可能会注意到结尾的<code class="eh na nb nc ms b">16</code>。当把<a class="ae ks" href="https://www.rapidtables.com/convert/number/hex-to-decimal.html?x=16" rel="noopener ugc nofollow" target="_blank">十六进制转换成十进制</a>时，可以看到这是22。22是字符串中数据的长度(不带0x前缀)。</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="3d51" class="ln lo ht ms b fv mw mx l my mz">'53746f72616765436f696e'.length === 22</span></pre><p id="d0cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">插槽5与插槽4的情况相同。当<a class="ae ks" href="https://www.rapidtables.com/convert/number/hex-to-ascii.html" rel="noopener ugc nofollow" target="_blank">转换成ascii </a>时，你会发现值是<code class="eh na nb nc ms b">STC</code>，我们的<code class="eh na nb nc ms b">symbol</code>变量。还可以看到数据的长度是6，和末尾的值一样。</p><p id="5ae2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">存储按顺序存储</strong></p><p id="e4ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这一点上你可能会疑惑…我以为这些是按顺序存放的？现在仍然是这样…但是如果你真的经历了每个契约的继承，你会发现顺序是不同的。在<code class="eh na nb nc ms b">node_modules</code>打开你的<code class="eh na nb nc ms b">openzeppelin-solidity</code>目录，你会看到顺序是这样的:<code class="eh na nb nc ms b">ERC20/Basictoken -&gt; StandardToken -&gt; PausableToken -&gt; StorageCoin</code></p><p id="cdb8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你会看到<code class="eh na nb nc ms b">BasicToken</code>，第一个继承顺序是<code class="eh na nb nc ms b">balances</code>，后面是<code class="eh na nb nc ms b">totalSupply</code>。然后<code class="eh na nb nc ms b">StandardToken</code>有了<code class="eh na nb nc ms b">allowed</code>。</p><p id="5d23" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh na nb nc ms b">PausableToken</code>继承自<code class="eh na nb nc ms b">Pausable</code>，而<code class="eh na nb nc ms b">Pausable</code>继承自<code class="eh na nb nc ms b">Ownable</code>，导致<code class="eh na nb nc ms b">paused</code>和<code class="eh na nb nc ms b">owner</code>成为下一个。</p><p id="3878" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，添加我们在<code class="eh na nb nc ms b">StorageCoin</code>中设置的变量。<code class="eh na nb nc ms b">name</code>最先出现，因为它首先被声明，然后是<code class="eh na nb nc ms b">symbol</code>。请记住，常量不是存储在存储器中，而是存储在部署的代码本身中。所以<code class="eh na nb nc ms b">decimals</code>在仓库里无处可寻。</p><p id="99c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们将测试块变成一组真实的测试:</p><figure class="mn mo mp mq fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="1982" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还需要在最后两个测试中使用的助手。把这个放到你的<code class="eh na nb nc ms b">helpers.js</code>文件里。请确保也将其导出:</p><figure class="mn mo mp mq fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="8655" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个函数从存储器中返回十六进制值的ascii版本。我们需要删除尾部的空字节以及末尾的长度声明。我们可以通过获取最后2个字符(长度)并使用它来表示切片应该在哪里结束(字符串的长度)来做到这一点。</p><h2 id="3ddb" class="ln lo ht bd lp lq lr ls lt lu lv lw lx jb ly lz ma jf mb mc md jj me mf mg mh dt translated">了解映射和嵌套映射存储</h2><p id="c2da" class="pw-post-body-paragraph iq ir ht is b it mi iv iw ix mj iz ja jb mk jd je jf ml jh ji jj mm jl jm jn hm dt translated">映射不同于我们到目前为止看到的简单类型。当映射被声明时，像任何其他类型一样，空间被顺序地为它保留，但是实际的值被存储在不同的槽中。为了找到插槽，您必须获取与密钥连接的插槽的sha3(keccak256)散列。</p><p id="2a88" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们可以用我们将构建的获取映射值的助手来说明这一点。</p><p id="47d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，我们需要另一个依赖项:</p><p id="9ffc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh na nb nc ms b">yarn add left-pad</code></p><p id="5ffd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后确保在<code class="eh na nb nc ms b">helpers.js</code>的顶部要求它:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="5b7e" class="ln lo ht ms b fv mw mx l my mz">const leftPad = require('left-pad')</span></pre><p id="b122" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">之后，将这些函数放入你的<code class="eh na nb nc ms b">helpers.js</code>文件中并导出<code class="eh na nb nc ms b">getMappingSlot</code>:</p><figure class="mn mo mp mq fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="9fec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们看看<code class="eh na nb nc ms b">getMappingSlot</code>。我们将槽和键都转换成十六进制(如果还没有的话),并且用空字节填充。他们两个都需要在本质上的<code class="eh na nb nc ms b">bytes32</code>。我们填充到64，因为每个字节是两个字符。</p><p id="4f2d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后我们从格式化的键和槽创建一个散列(总是键在前，槽在后！)这个散列是存储映射值的地方。一个32字节的散列可以被转换成一个数字。这个数字将在0到⁵⁶的范围内，如前所述，这是一个很大的数字。由于范围很大，一个贴图值几乎不可能与另一个值冲突。以这种方式设置映射是因为我们无法提前知道一个映射中会有多少元素。这样，它可以以非顺序的方式设置，其值不会被其他存储覆盖。</p><p id="e9f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<code class="eh na nb nc ms b">getMappingStorage</code>中，我们使用<code class="eh na nb nc ms b">getMappingSlot</code>并使用与之前相同的<code class="eh na nb nc ms b">web3.eth.getStorageAt()</code>函数。</p><h1 id="c17b" class="ng lo ht bd lp nh ni nj lt nk nl nm lx nn no np ma nq nr ns md nt nu nv mg nw dt translated">映射存储测试</h1><p id="6365" class="pw-post-body-paragraph iq ir ht is b it mi iv iw ix mj iz ja jb mk jd je jf ml jh ji jj mm jl jm jn hm dt translated">让我们使用刚刚创建的映射存储助手。将<code class="eh na nb nc ms b">helpers.js</code>中的<code class="eh na nb nc ms b">getMappingStorage</code>导入<code class="eh na nb nc ms b">StorageCoin.js</code>中，并在槽1测试前将该新测试块放入存储槽0中:</p><figure class="mn mo mp mq fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="ac6d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这里，您可以看到我们正在检查所有者余额是否与<code class="eh na nb nc ms b">totalSupply</code>匹配。请记住，在合同的构造者中，我们给了所有者全部供应。我们可以使用<code class="eh na nb nc ms b">BigNumber</code>将一个十六进制值转换成一个数字。然后，我们可以确保这与<code class="eh na nb nc ms b">totalSupply</code>匹配。</p><p id="507f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">亲自运行<code class="eh na nb nc ms b">truffle test</code>以查看所有测试是否通过。</p><h1 id="5504" class="ng lo ht bd lp nh ni nj lt nk nl nm lx nn no np ma nq nr ns md nt nu nv mg nw dt translated">了解嵌套映射存储</h1><p id="f169" class="pw-post-body-paragraph iq ir ht is b it mi iv iw ix mj iz ja jb mk jd je jf ml jh ji jj mm jl jm jn hm dt translated">在我们的<code class="eh na nb nc ms b">StorageCoin</code>契约中，我们还有一个名为<code class="eh na nb nc ms b">allowed</code>的嵌套映射，比如:<code class="eh na nb nc ms b">mapping(address =&gt; mapping(address =&gt; uint256))</code>。这基本上遵循与常规映射相同的模式，但是是以递归的方式。让我们再次进入助手函数，看看它是如何工作的。我们将添加一个名为<code class="eh na nb nc ms b">getNestedMappingStorage</code>的新函数，它将递归运行我们已经创建的<code class="eh na nb nc ms b">getMappingStorage</code>函数。使用新函数后，您的<code class="eh na nb nc ms b">helpers.js</code>文件应该类似于下图:</p><figure class="mn mo mp mq fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="1c1d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如你所见，这个函数没什么好花哨的。它只运行两次<code class="eh na nb nc ms b">getMappingSlot</code>函数，获取槽和密钥的散列，然后获取该散列并用第二个密钥对其进行散列。</p><p id="63b9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们在<code class="eh na nb nc ms b">StorageCoin.js</code>的测试中使用这个新函数。为了看到价值，我们需要设置一个余量。为此，我们还需要解除令牌的暂停。让我们同时为这两个步骤编写测试。以下是更新后的测试文件:</p><figure class="mn mo mp mq fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="3f4d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">测试文件已通过以下方式进行了更新:</p><ol class=""><li id="a6a6" class="ky kz ht is b it iu ix iy jb la jf lb jj lc jn ld le lf lg dt translated">在测试开始时删除了simpleStorage的日志</li><li id="ff17" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">在<code class="eh na nb nc ms b">owner</code>之后，将支出者添加到顶级测试中</li><li id="c8c7" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">增加了取消暂停的测试</li><li id="f3ef" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">增加了设定容差的测试</li><li id="bca1" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn ld le lf lg dt translated">添加了查找嵌套映射存储的测试</li></ol><p id="a607" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行<code class="eh na nb nc ms b">truffle test</code>并检查测试是否通过。您应该会得到与此类似的结果:</p><pre class="mn mo mp mq fq mr ms mt mu aw mv dt"><span id="589d" class="ln lo ht ms b fv mw mx l my mz">when accessing StorageCoin storage<br/>    Contract: StorageCoin<br/>      ✓ should have owner balance in slot 0 mapping (88ms)<br/>      ✓ should have totalSupply in slot 1<br/>      ✓ should have paused in slot 3<br/>      ✓ should have owner in slot 3 as well<br/>      ✓ should have name in slot 4<br/>      ✓ should have symbol in slot 5<br/>      ✓ should unpause the token as owner (56ms)<br/>      ✓ should set allowance for spender as owner (83ms)<br/>nested mapping slot:<br/>0xded101565a23504cd4339827add3a8b16f30ceff2912c1b6ef015848eade7942<br/>nested mapping value slot:<br/>0xd40f44dd33ce83ebf23375ff0b844b9aa265bbdfdf680d1743d07ed5bca013e5<br/>nested mapping value storage:<br/>0x015af1d78b58c40000<br/>allowance as number:<br/>25000000000000000000<br/>      ✓ should have owner allowance for spender at correct storage slot (109ms)</span></pre><p id="42fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您还将看到嵌套映射的不同值。我们之前已经知道你的津贴槽在槽2中，所以这是我们的第一个映射槽。然后，我们获取该值并用<code class="eh na nb nc ms b">owner</code>对其进行散列，并为嵌套映射槽打印该值。这是我们嵌套映射存在的地方，就像我们的第一个映射存在于slot 2。然后我们取这个值并用<code class="eh na nb nc ms b">spender</code>散列它以得到我们的嵌套映射值slot。这是实际的存储位置。嵌套映射值存储是十六进制的实际值。通过将它放入BigNumber中将其转换为小数，我们得到最后一个值，即<code class="eh na nb nc ms b">owner</code>给予<code class="eh na nb nc ms b">spender</code>的余量的小数。</p><p id="23d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在测试本身中，我们获取十进制值，并将其与通过getter函数<code class="eh na nb nc ms b">allowance()</code>从正常检索中获得的值进行比较。</p><p id="d9f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">做完这些后，如果你想保持整洁，就把它们拿掉😀。</p><h1 id="fd2f" class="ng lo ht bd lp nh ni nj lt nk nl nm lx nn no np ma nq nr ns md nt nu nv mg nw dt translated">为映射构建一些简洁的工具</h1><p id="56fa" class="pw-post-body-paragraph iq ir ht is b it mi iv iw ix mj iz ja jb mk jd je jf ml jh ji jj mm jl jm jn hm dt translated">我们已经找到了所有的储物空间……但是当有人牵着你的手时，这就简单多了。如果你在看一份完全不同的更复杂的合同呢？可能很难知道映射应该在哪个槽。</p><p id="eea7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们创建一对查找映射和嵌套映射的查找函数。将这两个函数添加到您的<code class="eh na nb nc ms b">helpers.js</code>文件的底部，并记住导出它们:</p><figure class="mn mo mp mq fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="e141" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于这些功能，没有太多的解释。我们只是从开始槽到结束槽迭代槽，并返回我们找到的任何值。</p><p id="112e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们在测试文件中使用它。将这两个测试添加到测试块的末尾:</p><figure class="mn mo mp mq fq nd"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="c0ab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">正如你所看到的，我们对之前的相关函数给出了相同的参数。我们只是将它设置为从槽0到20检查每个函数。这对于寻找复杂的存储非常有用。</p><p id="d716" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行<code class="eh na nb nc ms b">yarn test</code>查看结果，并检查测试是否通过。</p><h1 id="7206" class="ng lo ht bd lp nh ni nj lt nk nl nm lx nn no np ma nq nr ns md nt nu nv mg nw dt translated">结论&amp;下一步何去何从</h1><p id="4ff8" class="pw-post-body-paragraph iq ir ht is b it mi iv iw ix mj iz ja jb mk jd je jf ml jh ji jj mm jl jm jn hm dt translated">当访问存储时，嵌套映射可能会变得复杂。但是，在本教程中，我们没有涉及数组。如果您想了解如何检索其他类型。我建议要么查看这篇文章顶部的链接，要么查看关于此事的<a class="ae ks" href="http://solidity.readthedocs.io/en/v0.4.24/miscellaneous.html#layout-of-state-variables-in-storage" rel="noopener ugc nofollow" target="_blank">官方可靠性文档</a>。它也值得重复，因为它只是简单地提到:如果两个变量都可以放入一个32字节的槽，它们将被打包到同一个槽中。我们看到布尔型和地址打包在一起。查看储物件时，请记住这一点！</p><p id="b233" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你现在应该有了(大部分)检查任何合同存储的工具，不管是不是私有的。</p><blockquote class="ki"><p id="ab2e" class="kj kk ht bd kl km kn ko kp kq kr jn ek translated">加入Coinmonks <a class="ae ks" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ks" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae ks" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="ln lo ht bd lp lq nx ls lt lu ny lw lx jb nz lz ma jf oa mc md jj ob mf mg mh dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="ky kz ht is b it mi ix mj jb oc jf od jj oe jn of le lf lg dt translated"><a class="ae ks" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae ks" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn of le lf lg dt translated"><a class="ae ks" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae ks" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn of le lf lg dt translated"><a class="ae ks" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae ks" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="50d2" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn of le lf lg dt translated"><a class="ae ks" rel="noopener" href="/coinmonks/binance-trading-bots-d0d57bb62c4c">币安交易机器人</a> | <a class="ae ks" rel="noopener" href="/coinmonks/okex-review-6b369304110f"> OKEx评论</a> | <a class="ae ks" href="https://coincodecap.com/atani-review" rel="noopener ugc nofollow" target="_blank">阿塔尼评论</a></li><li id="3b1f" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn of le lf lg dt translated"><a class="ae ks" rel="noopener" href="/coinmonks/best-crypto-signals-telegram-5785cdbc4b2b">最佳加密交易信号电报</a> | <a class="ae ks" rel="noopener" href="/coinmonks/moonxbt-review-6e4ab26d037"> MoonXBT评论</a></li><li id="c44c" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn of le lf lg dt translated"><a class="ae ks" href="https://coincodecap.com/buy-shiba-bitbns" rel="noopener ugc nofollow" target="_blank">如何在Bitbns上购买柴犬(SHIB)币？</a> | <a class="ae ks" href="https://coincodecap.com/buy-floki-inu-token" rel="noopener ugc nofollow" target="_blank">购买弗洛基</a></li><li id="af80" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn of le lf lg dt translated"><a class="ae ks" href="https://coincodecap.com/coinflex-review" rel="noopener ugc nofollow" target="_blank"> CoinFLEX评论</a> | <a class="ae ks" href="https://coincodecap.com/aex-exchange-review" rel="noopener ugc nofollow" target="_blank"> AEX交易所评论</a> | <a class="ae ks" href="https://coincodecap.com/upbit-review" rel="noopener ugc nofollow" target="_blank"> UPbit评论</a></li><li id="29b5" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn of le lf lg dt translated"><a class="ae ks" href="https://coincodecap.com/best-cryptocurrency-blogs" rel="noopener ugc nofollow" target="_blank">十大最佳加密货币博客</a> | <a class="ae ks" href="https://coincodecap.com/youhodler-review" rel="noopener ugc nofollow" target="_blank"> YouHodler评论</a></li><li id="f33b" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn of le lf lg dt translated"><a class="ae ks" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae ks" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn of le lf lg dt translated"><a class="ae ks" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">面向开发人员的最佳加密API</a></li><li id="b359" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn of le lf lg dt translated">最佳<a class="ae ks" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn of le lf lg dt translated"><a class="ae ks" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae ks" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="ky kz ht is b it lh ix li jb lj jf lk jj ll jn of le lf lg dt translated"><a class="ae ks" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li></ul></div></div>    
</body>
</html>