<html>
<head>
<title>Tezos Explorer API Best Practices: #1 Don’t request the same blockchain data until it actually changes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tezos Explorer API最佳实践:#1不要请求相同的区块链数据，直到它实际发生变化</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/tezos-explorer-api-best-practices-1-dont-request-the-same-blockchain-data-until-it-actually-bf57b787ce59?source=collection_archive---------5-----------------------#2020-07-29">https://medium.com/coinmonks/tezos-explorer-api-best-practices-1-dont-request-the-same-blockchain-data-until-it-actually-bf57b787ce59?source=collection_archive---------5-----------------------#2020-07-29</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="b0d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Tezos生态系统发展非常迅速。Tezos基金会继续向开发者提供资助，最近宣布了第四批Tezos生态系统资助。祝贺所有获得资助的人！随着开发人员数量的增长，需求也在增长。其中之一与通过API从区块链获取数据有关。无论您是Tezos wallet、explorer、exchange、baker、public delegation service或任何DApp的开发人员，您都需要访问区块链的数据。</p><p id="2c03" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">自从<a class="ae jo" href="https://api.tzkt.io/" rel="noopener ugc nofollow" target="_blank"> Tezos API TzKT </a>的第一个版本发布以来，我们一直在不断地分析API的用法和各种行为模式。我们已经看到了好的和坏的模式，有时甚至是滥用的模式，这不仅给API带来了不必要的负载，而且使客户端应用程序非常低效。</p><p id="4838" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，我们决定开始这一系列文章，分享使用Tezos explorer API的最佳实践，我们已经在所有项目中成功地使用了很长时间。</p><h1 id="d790" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">目录</h1><ul class=""><li id="60ff" class="kn ko ht is b it kp ix kq jb kr jf ks jj kt jn ku kv kw kx dt translated">✅ <a class="ae jo" href="https://baking-bad.org/blog/2020/07/29/tezos-explorer-api-tzkt-how-often-to-make-requests/#how-often-to-make-requests" rel="noopener ugc nofollow" target="_blank">不请求相同的数据，直到它实际改变</a></li><li id="3e8d" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">🔜只请求你真正需要的东西</li><li id="cacd" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">🔜过滤API上的数据，而不是客户端上的数据</li><li id="9a39" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">🔜小心使用分页</li></ul><h1 id="b4d1" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">我需要多久发出一次API请求？</h1><figure class="le lf lg lh fq li fe ff paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="fe ff ld"><img src="../Images/eee3a6f10ad4b4b49942b65a5cc3d378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FkYfgu3RKnblqYaf.gif"/></div></div></figure><p id="f503" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是最重要的问题，不幸的是大多数用户也不知道正确的答案。</p><p id="3a45" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">例如，让我们考虑一个简单的应用程序，它在帐户余额变化时发送通知。这个假设的例子实际上演示了一些人如何使用TzKT Tezos API。</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="ea84" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">显然，这个例子效率极低，因为假设的作者不能正确回答数据应该多久被请求一次的问题。让我们试着修好它！</p><p id="fa1f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，我们需要了解Tezos区块链的数据多久更新一次。很明显，Tezos区块链中的数据更新的频率并不比块创建的频率高。我们需要的所有信息(如账户交易或余额更新)只能在添加冻结后出现。</p><p id="a28a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">完全没有必要每秒请求一次数据，因为更新的数据不会早于新块出现。至少我们可以用更简单、更快速的<a class="ae jo" href="https://api.tzkt.io/v1/head" rel="noopener ugc nofollow" target="_blank"> /head </a>请求替换<a class="ae jo" href="https://api.tzkt.io/v1/accounts/tz1NortRftucvAkD1J58L32EhSVrQEWJCEnB" rel="noopener ugc nofollow" target="_blank"> /accounts/{address} </a>请求，并跟踪<code class="eh lr ls lt lu b">level</code>字段以识别新块，当它被创建时，我们可以请求<a class="ae jo" href="https://api.tzkt.io/v1/accounts/tz1NortRftucvAkD1J58L32EhSVrQEWJCEnB" rel="noopener ugc nofollow" target="_blank"> /accounts/{address} </a>端点。</p><p id="48d5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，这也不是最有效的方法。如果我们记住块每分钟出现不超过一次(在mainnet上)，我们可以使我们的应用程序更加有效。在请求了<a class="ae jo" href="https://api.tzkt.io/v1/head" rel="noopener ugc nofollow" target="_blank"> /head </a>端点之后，我们可以很容易地计算出下一个时间段的估计时间，只需给上一个时间段加上一分钟。新块之前肯定不会出现，在这个时间之前再要求<a class="ae jo" href="https://api.tzkt.io/v1/head" rel="noopener ugc nofollow" target="_blank"> /head </a>是没有意义的。</p><p id="cc04" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，让我们像这样创建检查方法:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="83d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们可以使用这种方法作为一种限制器，以避免过多的请求和数据处理的过多迭代。</p><p id="f460" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这样，我们的通知程序看起来就像这样:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="f406" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如您所见，这个小小的改进帮助我们显著减少了API请求的数量，并节省了带宽和其他资源。</p><h1 id="861a" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">Tezos基于周期的数据</h1><p id="8ec2" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hm dt translated">有时，我们只需要在新的周期到来时做一些事情，例如计算并发送上一个周期的Tezos赌注奖励。在这种情况下，我们可以使用类似的方法:</p><figure class="le lf lg lh fq li"><div class="bz el l di"><div class="lp lq l"/></div></figure><h1 id="fcd4" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">结论</h1><p id="b2bd" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hm dt translated">因此，每次需要在循环中请求数据时，首先要了解数据更新的频率。没有理由在一分钟内请求一次以上的余额或账户交易，就像没有理由在每个周期内请求一次以上的未来奖励一样。</p><p id="a37e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">尝试在本地缓存关键数据，如最后一个块的时间或最后一个周期的编号，以了解何时希望在区块链中更新正确的数据，以及何时提出下一个请求。</p><h1 id="40e2" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">下一步是什么？</h1><p id="4fa0" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hm dt translated">这是“Tezos Explorer API最佳实践”系列的第一篇文章。在下一篇文章中，我们将讨论API请求中的数据选择。</p><p id="f103" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">敬请期待！</p></div><div class="ab cl ly lz hb ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hm hn ho hp hq"><p id="fbc4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="mf">原载于2020年7月29日https://baking-bad.org</em><a class="ae jo" href="https://baking-bad.org/blog/2020/07/29/tezos-explorer-api-tzkt-how-often-to-make-requests/" rel="noopener ugc nofollow" target="_blank"><em class="mf"/></a><em class="mf">。</em></p><blockquote class="mg"><p id="6feb" class="mh mi ht bd mj mk ml mm mn mo mp jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank"> <em class="mq">在您的收件箱中直接获得最佳软件交易</em> </a></p></blockquote><figure class="ms mt mu mv mw li fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mr"><img src="../Images/e18d5621d01d52fed55c68f9c4a132ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*G9dcpE13IXVglxfo.png"/></div></a></figure></div></div>    
</body>
</html>