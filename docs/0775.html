<html>
<head>
<title>Solidity at its best: an appetizer for the 1st Solidity Gas Golfing Contest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最佳的坚固性:第一届坚固性气体高尔夫比赛的开胃菜</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-at-its-best-an-appetizer-for-the-1st-solidity-gas-golfing-contest-56f394a053c3?source=collection_archive---------2-----------------------#2018-06-14">https://medium.com/coinmonks/solidity-at-its-best-an-appetizer-for-the-1st-solidity-gas-golfing-contest-56f394a053c3?source=collection_archive---------2-----------------------#2018-06-14</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/cd96150526e3c8b75da77f006f584154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Ppe_m8tyjBGk9KuoE96K_g.jpeg"/></div></figure><p id="c8a7" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><em class="jv">这篇文章将帮助你解决Solidity中的一个经典编程练习，并教你一些技巧，如何在开发Solidity智能合同时节省一些汽油</em></p><p id="c997" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">学习和提高编码技能的最有趣的方法是解决具有挑战性的练习。以太坊社区定期组织<a class="ae jw" href="https://ethglobal.co/" rel="noopener ugc nofollow" target="_blank">黑客马拉松</a>和竞赛，将聪明的合同开发者聚集在一起。迄今为止，我个人最喜欢的是以太坊的<a class="ae jw" href="https://twitter.com/nicksdjohnson" rel="noopener ugc nofollow" target="_blank">尼克·约翰逊</a>组织的竞赛。</p><p id="dd83" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">去年有一个惊人的<a class="ae jw" href="http://u.solidity.cc/" rel="noopener ugc nofollow" target="_blank">秘密可靠性编码竞赛</a>，目标是在ICO合同中加入难以发现的漏洞，这些漏洞可以被利用来丰富项目创建者。几个令人着迷的解决方案被<a class="ae jw" rel="noopener" href="/@weka/announcing-the-winners-of-the-first-underhanded-solidity-coding-contest-282563a87079">提交</a>呈现出我可能从未想到的漏洞。</p><p id="9b72" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">今年的目标是用尽可能少的气体来解决经典的编程任务。<a class="ae jw" href="https://g.solidity.cc/" rel="noopener ugc nofollow" target="_blank">竞赛</a>包含5个练习:整数排序、创建BrainFuck解释器、十六进制解码器、字符串搜索和从列表中删除重复元素。如果你想从整数排序练习<a class="ae jw" href="https://blog.cotten.io/thinking-in-solidity-6670c06390a9" rel="noopener ugc nofollow" target="_blank">开始，Tim Cotten </a>已经写了一篇极好的文章，我强烈推荐。我还想通过最后一个练习来引导你们完成我的旅程，并向你们展示我在这一路上所学到的东西。希望这能鼓励你看看其他的练习，并尝试一些可靠的编码；)</p><h1 id="7ace" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">设置</h1><p id="7edc" class="pw-post-body-paragraph ix iy ht iz b ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt ju hm dt translated">我是<a class="ae jw" href="https://github.com/trufflesuite/truffle" rel="noopener ugc nofollow" target="_blank">松露</a>的忠实粉丝，所以我使用竞赛的松露项目版本，可在<a class="ae jw" href="https://github.com/Arachnid/sggc" rel="noopener ugc nofollow" target="_blank">这里</a>获得。投入比赛是非常方便的。在编写了一些代码之后，您可以使用命令<code class="eh la lb lc ld b">truffle test test/Unique.js</code>快速测试您的解决方案是否通过了所有的测试向量。</p><h1 id="bccd" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated"><strong class="ak">挑战5:移除重复元素</strong></h1><p id="d995" class="pw-post-body-paragraph ix iy ht iz b ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt ju hm dt translated">问题非常简单:在Solidity中编写一个智能契约，它从一个整数列表中删除除第一个元素之外的所有元素，保留原始元素的顺序，并返回该列表。此外，输入列表可以是任意长度。</p><h1 id="4904" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">天真的解决方案</h1><p id="e41d" class="pw-post-body-paragraph ix iy ht iz b ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt ju hm dt translated">我想从一个简单而愚蠢的解决方案开始，只是为了有一个基准。一个简单的想法如下。</p><figure class="le lf lg lh fq iu"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="0425" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">返回长度小于2的每个输入数组，因为它们已经没有重复。之后，让我们使用一个单独的bool数组来跟踪哪个元素是重复的。这段代码使用了非常低效的嵌套循环。如果<strong class="iz hu"> n </strong>是输入数组的长度，它给出了一个<strong class="iz hu"> O(n ) </strong>算法。我们将<code class="eh la lb lc ld b">unique[]</code>数组复制到<code class="eh la lb lc ld b">unique2[]</code>数组可能看起来很奇怪。这是因为在Solidity中不可能调整内存中数组的大小。在测试了这个简单的解决方案后，我们看到我们通过了测试向量0和1:一个空数组和一个元素数组…太棒了！然而，对于大多数测试向量来说，它将耗尽气体。这个最初的失败表明我们应该瞄准一个<strong class="iz hu"> O(n) </strong>算法。如果只允许我们在数组上迭代一次，我们能找到所有的副本吗？OFC！</p><h1 id="7906" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">哈希表</h1><p id="2f68" class="pw-post-body-paragraph ix iy ht iz b ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt ju hm dt translated">自然的想法不是比较整数本身，而是比较它们的变换。因此，让我们将所有元素映射到插槽中，不同的元素映射到不同的插槽，而相同的元素显然驻留在同一个插槽中。哈希表非常适合这个任务。当我们遍历数组时，我们取一个整数，对它进行哈希运算，然后将这个整数映射到一个根据它的哈希计算出的键值。检测重复变得很容易，因为如果一个整数有重复，那么我们会多次将该整数映射到同一个槽。</p><h2 id="298c" class="lk jy ht bd jz ll lm ln kd lo lp lq kh ji lr ls kl jm lt lu kp jq lv lw kt lx dt translated">散列地址</h2><p id="8e5a" class="pw-post-body-paragraph ix iy ht iz b ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt ju hm dt translated">即使应用了加密的安全散列函数，也很容易发生将两个整数分配给同一个槽的情况。这叫碰撞。在我们的例子中，这显然是不想要的，因为两个不同的整数被映射到同一个槽，让我们相信它们是重复的，尽管它们不是。总之，这种冲突必须以某种方式来解决。散列冲突解决技术之一是开放寻址。</p><figure class="le lf lg lh fq iu"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="9250" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">直觉是，每当这样的冲突发生时，只要我们找到一个空槽(“key”)，我们就简单地在键空间中迭代。该整数被插入到第一个未被占用的槽中。这里存在固有的计算时间/空间权衡。随着插槽数量、密钥空间的增加，冲突数量减少。类似地，如果密钥空间变小，哈希冲突就更有可能发生。上面可以找到开放寻址散列表的简单且未优化的实现。这通过了所有的测试向量，燃烧了1149096气体。</p><p id="ad46" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们如何提高这一解决方案的效率？让我们使用一个更有效的散列函数。我们不需要<code class="eh la lb lc ld b">sha3</code>，一个加密哈希函数，对于我们的目的来说<code class="eh la lb lc ld b">mod</code>也很好，因为它很好地混合了数字。因此，如果我们简单地通过<code class="eh la lb lc ld b">uint hash = input[i] % lengthOfKeySpace</code>计算密钥，我们可以节省113380加仑汽油。</p><p id="2ced" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">代替<code class="eh la lb lc ld b">%</code>操作符，我们应该用按位操作符计算余数，因为按位操作符更接近机器代码。从以太坊黄皮书中可以看出，一个<code class="eh la lb lc ld b">mod</code>值5个汽油，而一个按位<code class="eh la lb lc ld b">and</code>值3个汽油。如果模数是2的幂，<code class="eh la lb lc ld b">n mod k</code>也可以给定为<code class="eh la lb lc ld b">n &amp; (k-1)</code>。因此，设<code class="eh la lb lc ld b">lengthOfKeySpace</code>为256，它是2的幂。用按位<code class="eh la lb lc ld b">and </code>计算模产生另一个46903气体节省。</p><p id="9c0c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">嗯嗯… 989623气？？？这还是太多了！如果我们应用不同的冲突解决技术呢？</p><h2 id="0c1e" class="lk jy ht bd jz ll lm ln kd lo lp lq kh ji lr ls kl jm lt lu kp jq lv lw kt lx dt translated">单独链接</h2><p id="22a3" class="pw-post-body-paragraph ix iy ht iz b ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt ju hm dt translated">另一种常见的冲突解决技术是独立链接。这个想法是每个槽都是独立的，每个槽都有一个单独的列表。每当我们在某个槽遇到冲突时，我们只是把要插入的整数推到列表的末尾。该列表通常被实现为一个链表。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/75db5e71966dd320eb433a74ec667d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/1*Cw6y5UATtLqEYZnUYJK7EA.gif"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">A visual explanation for separate chaining</figcaption></figure><p id="eb07" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">哈希表操作的时间是找到槽的时间，这个时间是常数，加上列表操作的时间。在一个好的哈希表中，每个桶有零个或一个条目，有时有两个或三个，但很少超过这个数量。因此，对于这些情况，在时间和空间上有效的结构是优选的。随着加载因子(在我们的例子中，每槽数的输入列表中的整数数)的增加，与开放式寻址相比，单独链接变得更快。原因是如果哈希表是密集的，那么更有可能发生冲突，因此需要在哈希表上迭代更多次来找到开放的地址。相反，分离链接不使用迭代来解决冲突，它只使用一个快速操作，即在槽列表的末尾追加。</p><figure class="le lf lg lh fq iu"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="71e3" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">事实证明，单独链接比开放式寻址更有效。这给了我们在块菌测试向量上总共957787个气体消耗。在竞赛的秘密测试向量上，我们的独立链接解决方案消耗792960汽油。好的，我们可以省略这些赋值，我们把0赋给<code class="eh la lb lc ld b">hashTable</code>或<code class="eh la lb lc ld b">index</code>因为EVM用它们的默认值初始化所有的数据结构，在整数数组的情况下是0。我们还可以通过使用前缀增量而不是后缀增量来使代码运行得更快一些。但总的来说，这并不能节省超过5136英镑的汽油。我们还没到那一步！有人可能会说这是茶杯里的风暴:在这项任务中，我们还远远没有处于领先地位。目前最快的解决方案只能燃烧309063气体。哎哟！</p><p id="bc26" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">你能打败它吗？接受挑战！</p><h1 id="8bda" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated"><strong class="ak">注意事项</strong></h1><p id="853d" class="pw-post-body-paragraph ix iy ht iz b ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt ju hm dt translated">正如你所看到的，我们在这个版本上离领先还很远，所以我们特意在这个版本上留了一些改进的空间。我希望你喜欢这趟旅程，现在你有勇气和胃口开始在Solidity中编写一些漂亮的智能合约。</p><p id="9dc7" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我不想剧透太多，但是我给你一些提示，如何让你的进场更有效率。</p><ol class=""><li id="0527" class="md me ht iz b ja jb je jf ji mf jm mg jq mh ju mi mj mk ml dt translated">请记住，只有<code class="eh la lb lc ld b">uniquify()</code>功能的气体成本被考虑在内。</li><li id="9f32" class="md me ht iz b ja mm je mn ji mo jm mp jq mq ju mi mj mk ml dt translated">我就把这个留在这里:<a class="ae jw" href="https://gastoken.io/" rel="noopener ugc nofollow" target="_blank">https://gastoken.io/</a>如果你知道我在说什么；)</li><li id="a5c4" class="md me ht iz b ja mm je mn ji mo jm mp jq mq ju mi mj mk ml dt translated">自己完事后一定要收拾干净！:)</li></ol><p id="6ca1" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">功劳归于<a class="ae jw" rel="noopener" href="/@Csyk"> Balázs Paulcsik </a>的<a class="ae jw" href="https://twitter.com/Csyk01" rel="noopener ugc nofollow" target="_blank">想法</a>和支持！</p><h1 id="8f9c" class="jx jy ht bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">保持下去！</h1><p id="bb5b" class="pw-post-body-paragraph ix iy ht iz b ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt ju hm dt translated">让我知道你是如何解决这个挑战的，或者你是否有其他更有效的方法来解决这个问题。我想听听这些想法；)</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/b6e3a06d70f3ba894cb9c7581147f50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*UZLj4yUiEPOE01ZJgqLrlw.jpeg"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Keep going and happy gas golfing!</figcaption></figure><p id="16f2" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">如果你想了解更多关于我即将开展的区块链相关项目，请关注我的<a class="ae jw" rel="noopener" href="/@Istvan_A_Seres"> Medium </a>或<a class="ae jw" href="https://twitter.com/Istvan_A_Seres" rel="noopener ugc nofollow" target="_blank"> Twitter </a>。争取更多，保持#buidl！</p></div></div>    
</body>
</html>