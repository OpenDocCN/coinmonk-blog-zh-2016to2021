<html>
<head>
<title>Blockchain Ep01: Demystifying the Chain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">区块链Ep01:揭开链的神秘面纱</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/linked-lists-blockchains-36f400915c15?source=collection_archive---------2-----------------------#2021-11-15">https://medium.com/coinmonks/linked-lists-blockchains-36f400915c15?source=collection_archive---------2-----------------------#2021-11-15</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="d657" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">作为金融界的一员，我意识到我们正处于一项关键技术的边缘。有些人甚至认为这是互联网3.0版，尽管去中心化的想法一直存在。所以很自然地，我想知道为什么每个人都认为这是区块链革命。</p><p id="405f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">正如我所有的未知之旅一样，这也是从书籍开始的，特别是Antony Lewis的— <a class="ae jo" href="https://www.amazon.in/Basics-Bitcoins-Blockchains-Antony-Lewis/dp/1642503436/ref=sr_1_2?crid=2UHBBG7D8LBX2&amp;keywords=the+basics+of+bitcoins+and+blockchains&amp;qid=1636994283&amp;qsid=262-1475325-7033158&amp;sprefix=The+basics+of%2Caps%2C290&amp;sr=8-2&amp;sres=1642503436%2CB07TJ49VX4%2CB07W7W162D%2CB09BJXMYJP%2CB09L8P462X%2CB09LPDYCCF%2CB09LT646CM%2CB09LT48QY6%2CB09LR3FMS7%2CB09LR1CLL6%2CB09LT4KBLG%2CB09LHZSNRS%2CB09B2M2XWX%2CB09KVBT3KL%2CB08W9NQKBN%2CB092DZQG69" rel="noopener ugc nofollow" target="_blank"> <em class="jp">《比特币基础》和《区块链</em> </a>。这本书以非常简单的语言，奠定了金融界对区块链的驱动需求——从什么是钱以及为什么我们当前世界的交易如此昂贵开始(<em class="jp">提示:集中式金融并不是真正非常集中</em>)。</p><p id="9c81" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在一系列博客文章中，我想概述一下我对区块链的理解，以及为什么我相信它真的有潜力改变世界。我写这些有两个主要目的-</p><ul class=""><li id="a76b" class="jq jr ht is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy dt translated">我相信写作有助于巩固知识</li><li id="9bb6" class="jq jr ht is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy dt translated">我想听听真正了解的人和爱好者的意见，这样我可以学得更好</li></ul><p id="74f6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这篇文章中，我将尝试建立一个非常原始的“区块链”，其协议类似于(但弱于)区块链。我从零开始，从我们所有人都见过的基础开始。希望在它结束时，我已经解释了链接块的真正含义。但是让我们从头开始，从第一个<em class="jp">啊哈！我有…</em></p><h1 id="bc89" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">啊哈时刻！</h1><p id="622b" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated"><strong class="is hu">区块链</strong>由两个东西组成——<strong class="is hu">区块</strong> <em class="jp">和</em> <strong class="is hu">链</strong>。当我开始与<strong class="is hu">区块链</strong>的旅程时，很长一段时间我都专注于<strong class="is hu">区块</strong>，去理解它们，去欣赏其中的天才。直到很晚我才意识到链条的美丽。不要误解我的意思，<strong class="is hu">块</strong>很重要，非常重要，没有链条它就不能工作。所以理解了<strong class="is hu">链</strong>是如何工作的，你就有了60%的把握。</p><p id="1667" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">那个<em class="jp">啊哈！那一刻，我意识到——我以前遇到过类似链条的东西…</em></p><h1 id="2c2b" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">数据结构</h1><p id="a8ec" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">我们都知道什么是数据——一条信息——你最新的帖子、一个单词、一个字母、一个像素、一个电脉冲！但是只有当数据有了结构，我们才能理解它。结构使我们能够处理数据，添加数据，删除数据。计算机也需要数据的结构。所以我们杰出的计算机科学家定义了不同的方式来组织数据。其中许多都来自我们都能理解的现实生活中的例子。</p><h2 id="cf30" class="lh kf ht bd kg li lj lk kk ll lm ln ko jb lo lp ks jf lq lr kw jj ls lt la lu dt translated">行列</h2><p id="8047" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">我们以前都排过队，可能在星巴克，在航空公司办理登机手续，或者如果你像我一样，在足球场。你总是排在队伍的最后，你总是排在最前面。插队是一种亵渎。</p><p id="f82d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">计算机队列的工作方式非常相似。您只能从队列的前面删除/处理数据，只能在末尾添加新数据。在计算机术语中，这也叫做<strong class="is hu">先进先出</strong>——先进先出。</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff lv"><img src="../Images/aa1a1bc9301e9b1b5878f38745887d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXoEpBFkqGx0dpqpzpDM_Q.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek"><em class="ml">If I got into the queue before you did, I’d want to exit before you did. Or we fight…</em></figcaption></figure><h2 id="898e" class="lh kf ht bd kg li lj lk kk ll lm ln ko jb lo lp ks jf lq lr kw jj ls lt la lu dt translated">大量</h2><p id="6346" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">把一本书叠在另一本书上，对几本书也这样做。你会注意到你总是添加到栈顶。现在，一本书一本书地拿走——你是从书架的顶部拿走的。所以最近添加的书会先离开！</p><p id="8329" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">计算机堆栈也是这样工作的。数据被添加到栈顶，也从栈顶移除。后进先出— <strong class="is hu">后进先出</strong></p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/7010aff123105fbc5f8812de493c1c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*1IZZIZ8tCnxKl2LrKwrBBA.png"/></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek"><em class="ml">If I join a queue after you, I want it to convert to stack immediately!</em></figcaption></figure><p id="49cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="jp">快速补充说明</em> </strong> <em class="jp"> <br/>队列和堆栈都是连续的——为了到达第5个数据(或人，或书),你必须遍历它前面的4个数据元素(或人，或书)。你不能跳，这不公平，也不可能。这是非常严格的——想象一下，如果你必须听4首歌才能听到第5首。真的想象一下——下图一点关联都没有；)</em></p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/28245e4b61468cd15611aa8f595a21d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/0*ifx06ZOpKq6vXZtZ"/></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">90’s kids, where art thou?</figcaption></figure><h2 id="59ef" class="lh kf ht bd kg li lj lk kk ll lm ln ko jb lo lp ks jf lq lr kw jj ls lt la lu dt translated">列表</h2><p id="e5fc" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">列表有点复杂，但也更灵活。您可以将数据添加到列表中的任何位置——开始、中间或结尾的任何位置；您可以从列表中的任何位置移除/process。想想你的购物清单。你可以以任何顺序购买这些物品，你也可以(如果不是在纸上)将它们添加到你想要的列表中的任何地方。</p><p id="6603" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了简化问题，让我们就列表由几个<strong class="is hu">元素</strong>组合而成的术语达成一致。元素存储数据。在计算机中，每个元素都有一个隐藏的属性，称为<strong class="is hu">索引</strong>。一个新元素可以被插入到列表中的任何一个<em class="jp">点</em>，所以必须有一种方法告诉计算机那个<em class="jp">点</em>是什么。这就是<strong class="is hu">索引</strong>所做的一切，<em class="jp">它的作用就像一个地址</em>。</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff mo"><img src="../Images/5f71fef8cbee347a8ef0a1d2da7d1932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mYoXwmsb1mbA0n3S9cCxgA.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Index is an address, Elements store data</figcaption></figure><h2 id="8160" class="lh kf ht bd kg li lj lk kk ll lm ln ko jb lo lp ks jf lq lr kw jj ls lt la lu dt translated">链接列表</h2><p id="bd1e" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">现在让我们尝试列表，让我们修改元素，以便它存储两条信息——当前元素的数据和序列中下一个元素的索引。在这样做的时候，我们将列表的元素链接在一起，因为每个元素都给了<em class="jp">到下一个元素的方向</em>。链表就像<em class="jp">寻宝</em>(或者<em class="jp">寻宝</em>)。每解决一个谜题都会给你下一个谜题的线索，直到你解决了这个新的谜题，你才能进入下一轮。</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff mp"><img src="../Images/226e9f2565e32d8066d979128d4e6eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhPfJa20fO51Bi9xfXd1_Q.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek"><em class="ml">Food for thought: Does LinkedIn connections have anything to do with Linked Lists?</em></figcaption></figure><p id="9082" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因为它变得有些复杂，让我们总结一下技术细节</p><ul class=""><li id="7359" class="jq jr ht is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy dt translated">链表中的每个元素包含两个部分——当前元素的<strong class="is hu">数据</strong>和下一个元素的<strong class="is hu">索引</strong>(或地址)</li></ul><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/772d924dd87be01f250ae1776434219c.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*fJMEpfaZQCa-5os7QSXP4g.png"/></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">An element of Linked List</figcaption></figure><ul class=""><li id="897f" class="jq jr ht is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy dt translated">您可以在链表的任何位置输入新元素；你只需要<em class="jp">插入</em>这个新元素，这样<strong class="is hu">链接</strong>就会以正确的方式更新</li></ul><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/b2efddad0b85cd20f8aeffdab1620417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*qHf2Hw7DMrZZVfVHmpBczQ.png"/></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Adding element D between elements B &amp; C. Letters represent the Index/Address</figcaption></figure><ul class=""><li id="57f6" class="jq jr ht is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy dt translated">只要更新<strong class="is hu">链接</strong>，就可以从链表的任何一点删除一个元素</li></ul><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/d9e7f43e7540725d6ec072133d327883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*dU0Vfs7nLyQleZx47WGGng.png"/></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Removing element B</figcaption></figure><p id="d5d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">链表的这些特性使得<em class="jp">成为一个链</em>(不是<strong class="is hu">链</strong>，还不是)。它是一个链，其中每个元素都连接到下一个，并且可以根据我们的需要修改多次，只要我们不断正确地更新链接。</p><p id="974b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">注意:链表有一些变体，但这不在这里讨论的范围之内。</em></p><h1 id="2640" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">构建链条</h1><p id="fb9c" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">从<em class="jp">链条</em>到<strong class="is hu">链条</strong>的跳跃需要一些修改。在接下来的几个步骤中，我们将尝试使用链表概念构建一个非常简单的“块链”。</p><p id="40c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">第零个修改是我现在将每个<em class="jp">元素</em>称为<strong class="is hu">块</strong>(还不是<strong class="is hu">块</strong>，大写很重要！)并稍微改变一下形状。我这样做是为了方便。</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/812a6467cb3d2a2de5449b4e0b37375c.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*yFmkDmAX-rGJPRwS_M4tuw.png"/></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">A ‘block’</figcaption></figure><p id="762f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">第一次修改非常小。我们只是翻转方向。不是每个块存储下一个块的<em class="jp">的地址，而是存储前一个</em>块的<em class="jp">的地址。</em></p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/00d4f9fd1955b01ec84f6fbb43f07825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*EsGf9N5AOGKtUXC5IbVdqA.png"/></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">‘Flipping’ the direction of links. This representation can start getting noisier. So the image below, represents the same idea in a different format.</figcaption></figure><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff mv"><img src="../Images/c0edb193aea2030015db75abac870c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44dC3tgo_AHNCZYsldBPzw.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Same idea as image above, but a tidier representation</figcaption></figure><p id="d0a4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，改变游戏规则的第二次修改！在链表中，我们只存储前一个(因为我们已经翻转了方向)块的地址。这里，让我们也按正确的顺序存储链中每个在前元素的地址<em class="jp">。因此，最后一个块包含了在它之前的每个块的地址，并按照它们出现的顺序排列。很微妙，但是很厉害！</em></p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff mw"><img src="../Images/bac7783b84d9516859a6ecadc31a9230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDQxpd1SjG6HykL81LyX2w.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Storing the entire ‘preceding’ history of links in each block</figcaption></figure><p id="7f2f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">第三个修改是<strong class="is hu">复制</strong>——很多很多的复制。这个块链保存在网络上的许多计算机上。每次我们对这个链做任何改变时，我们都将更新后的链重新共享给所有这些计算机。本质上，网络中的每台计算机都有一个完全相同的链条副本。</p><h2 id="21e6" class="lh kf ht bd kg li lj lk kk ll lm ln ko jb lo lp ks jf lq lr kw jj ls lt la lu dt translated">链式验证协议</h2><p id="915a" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">通过这些修改，我们已经远离了传统的数据结构领域。因此，现在是停下来反思我们所取得的成就的好时机。我们按照承诺建造了一个原始的“积木链”。这种结构的安全性非常弱，任何人都可以对链进行修改，只要他们遵循<em class="jp">链验证</em>的协议。</p><p id="32ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每次链被修改时，网络中的每台计算机都会收到更新，因为<strong class="is hu">重复</strong>。这将在每台计算机接受更新的链之前启动一个验证过程。检查每个块，看它们是否有正确的顺序存储前面的块的地址。如果所有块中的所有地址都排序正确，计算机将接受更新后的链并保存它。如果没有，它们拒绝更新的链并保留原始版本。因为每台计算机都可以独立验证链接是否正确，所以我们引入了<strong class="is hu">去中心化</strong>。<em class="jp">没有一台电脑能统治他们所有人</em>！</p><p id="373d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，让我们看看如何对这个链进行更改。</p><h2 id="df32" class="lh kf ht bd kg li lj lk kk ll lm ln ko jb lo lp ks jf lq lr kw jj ls lt la lu dt translated">在链的末端添加新的块</h2><p id="eae5" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">这很简单。即使在真实的<strong class="is hu">区块链</strong>中，这种情况也时有发生。添加新数据块是我们如何向“数据块链”添加更多数据，从而增加长度。如下所示，将块G添加到链中仅仅意味着从前面的块F中复制所有的地址，并向G上的地址添加额外的一行。</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff mx"><img src="../Images/b0fb3bd4240990de2effc8c35a52a3ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oiY-zVRST3ULjGM2pkOPYA.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">A new block at the end of the chain</figcaption></figure><h2 id="5d67" class="lh kf ht bd kg li lj lk kk ll lm ln ko jb lo lp ks jf lq lr kw jj ls lt la lu dt translated">在链的中间添加新的块</h2><p id="85f7" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">这没那么简单。因为如果我们不小心，我们可能会使<em class="jp">链验证</em>失败。在中间添加一个新块需要更新链中它后面的每个块。这不是不可能的，只是需要更多的工作。而只要我们做好这额外的工作，我们就会通过<em class="jp">链验证</em>！</p><p id="0aab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们在C块和d块之间增加一个新的G块。</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff my"><img src="../Images/74230fc3072f4f8996abdde951c8d6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F7T4HVbn0R9hMffBwcV6Ew.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">What did we miss?</figcaption></figure><p id="41d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一旦此更新作为<strong class="is hu">复制</strong>的结果与其他计算机共享，每台计算机独立运行<em class="jp">链验证</em>协议。从块F开始，每个地址看起来都很好，因为使用地址部分中的信息，计算机可以从块F遍历到块a。然后它试图从块E开始做同样的事情。但是验证失败，因为根据块E，<em class="jp"> D指向C </em>。不是真的！因为在块E验证失败，所以该更新被拒绝。</p><p id="2b27" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">可接受的更新应该是这样的</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff mz"><img src="../Images/bde6a44e32f9663cda2aacd31a6922cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BH93SBvGb3C-agYPC_yj8g.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek"><em class="ml">A change in every block after the new block is inserted!</em></figcaption></figure><h2 id="0f03" class="lh kf ht bd kg li lj lk kk ll lm ln ko jb lo lp ks jf lq lr kw jj ls lt la lu dt translated">在链的开始处添加新的块</h2><p id="3ef5" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">这几乎是从上面得出的结论。如果我们在链的开始添加一个新的块，我们只需要更新链中每个块的地址。我不想用另一张图来占用空间，但我想你现在已经明白了。最重要的一点是— <em class="jp">我们在链的更高层添加一个新的块，我们必须修改的块越多，我们必须做更多的工作来保持链的有效性！</em></p><h1 id="f99f" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">总之…</h1><p id="99f3" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">到目前为止，我们已经构建了一个非常原始的块链，其中向链中添加新块相对来说比在中间(或任何更高的位置)添加新块更容易。当然，这并非不可能。但这是额外的工作。如果以某种方式，我们可以使工作变得非常困难(或昂贵)，在链条中间插入任何东西都将变得不切实际。这就是<strong class="is hu">区块链</strong>的本质——在任何<strong class="is hu">模块</strong>上添加这条新的<em class="jp"> X点到Y点</em>的线路所需的工作是极其昂贵的，以至于不值得做一次以上(对于链末端的新模块)。</p><p id="d419" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">很多时候，我们读到类似<strong class="is hu">区块链</strong>是不可变的(也就是说不能修改)。事实并非如此。理论上，<strong class="is hu">区块链</strong>是可变的，它只是不实际(给定当前的计算基础设施)。</p><p id="7558" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我故意忽略了存储在块中的数据。如果我们想修改现有块中的数据，会发生什么情况呢？现在没有办法阻止这种情况。此外，我们创建的链以非常低效的方式维护地址，如果链变得非常长，地址线的数量将爆炸式增长，并可能变得比存储的数据大得多。为了存储5 MB的数据，你需要100 MB的地址，太疯狂了！但是我希望你现在能够欣赏<strong class="is hu">链条</strong>的<em class="jp">机构</em>。</p><p id="fb71" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你问的<strong class="is hu">块</strong>呢？这是我下一篇文章的主题。到时见…</p><h1 id="64d3" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">扣人心弦</h1><p id="bbed" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">真正的<strong class="is hu">区块链</strong>让地址维护变得更简单，同时让数据/链修改变得几乎不可能，只需一次计算机魔法的嗖嗖声。<strong class="is hu">磕磕碰碰</strong>！</p><blockquote class="na"><p id="cc3a" class="nb nc ht bd nd ne nf ng nh ni nj jn ek translated">加入Coinmonks <a class="ae jo" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jo" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h2 id="6048" class="lh kf ht bd kg li nk lk kk ll nl ln ko jb nm lp ks jf nn lr kw jj no lt la lu dt translated">也阅读</h2><div class="np nq fm fo nr ns"><a rel="noopener follow" target="_blank" href="/coinmonks/leveraged-token-3f5257808b22"><div class="nt ab ej"><div class="nu ab nv cl cj nw"><h2 class="bd hu fv z el nx eo ep ny er et hs dt translated">杠杆代币[多头代币]终极指南</h2><div class="nz l"><h3 class="bd b fv z el nx eo ep ny er et ek translated">杠杆化令牌是具有杠杆化风险敞口的ERC20令牌，不考虑保证金、要求、管理…</h3></div><div class="oa l"><p class="bd b gc z el nx eo ep ny er et ek translated">medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og mf ns"/></div></div></a></div><div class="np nq fm fo nr ns"><a href="https://blog.coincodecap.com/crypto-exchange" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab ej"><div class="nu ab nv cl cj nw"><h2 class="bd hu fv z el nx eo ep ny er et hs dt translated">最佳加密交易所| 2021年十大加密货币交易所</h2><div class="nz l"><h3 class="bd b fv z el nx eo ep ny er et ek translated">加密货币交易所的加密交易需要了解市场，这可以帮助你获得利润。之前…</h3></div><div class="oa l"><p class="bd b gc z el nx eo ep ny er et ek translated">blog.coincodecap.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og mf ns"/></div></div></a></div><div class="np nq fm fo nr ns"><a href="https://blog.coincodecap.com/best-swap-platforms" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab ej"><div class="nu ab nv cl cj nw"><h2 class="bd hu fv z el nx eo ep ny er et hs dt translated">2021年最佳加密交换平台| CoinCodeCap</h2><div class="nz l"><h3 class="bd b fv z el nx eo ep ny er et ek translated">如果我们看看今天的场景，许多加密货币交换平台提供了广泛的功能和深度…</h3></div><div class="oa l"><p class="bd b gc z el nx eo ep ny er et ek translated">blog.coincodecap.com</p></div></div><div class="ob l"><div class="oi l od oe of ob og mf ns"/></div></div></a></div></div></div>    
</body>
</html>