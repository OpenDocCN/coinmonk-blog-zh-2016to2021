<html>
<head>
<title>What Is Blockchain? Deep Explanation of Blockchain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是区块链？区块链深度解读</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/what-is-blockchain-blockchain-deep-explanation-5844284efdb4?source=collection_archive---------2-----------------------#2021-09-02">https://medium.com/coinmonks/what-is-blockchain-blockchain-deep-explanation-5844284efdb4?source=collection_archive---------2-----------------------#2021-09-02</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="d081" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">比特币中的哈希应用</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/8c879f0f89d148f759126895a4b39649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CeO0fE36L3yIaOg_jBzMKA.jpeg"/></div></div></figure><p id="e58a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在理解什么是区块链之前，我们应该知道什么是散列函数以及如何使用它。首先，我们来看看密码学研究者为什么要创造这样的函数。除了用户身份验证之外，我们还必须对正在发送的消息进行身份验证，并确保消息在传输过程中没有被篡改(数据完整性)，数据完整性是信息安全基本原则的组成部分之一。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/8221167d62fdc9aacd53100e5030a15c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*x3HnbVC2dw3fwHBYmesPrQ.png"/></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">CIA Triad</figcaption></figure><p id="0aa7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">所以为了这个目的，有一个总的想法:</p><ul class=""><li id="4840" class="kv kw ht jw b jx jy ka kb kd kx kh ky kl kz kp la lb lc ld dt translated">产生一个取决于消息和密钥的短比特序列</li><li id="46fb" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">为了对消息进行身份验证，伙伴将计算相同的位模式，假设他共享相同的密钥</li></ul><p id="2833" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">那么，什么是散列函数呢？固定长度的散列值H由函数H生成，函数H将任意长度的消息作为输入:<br/> <strong class="jw hu"> <em class="lj"> h = H(M) </em> </strong></p><p id="1f57" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们可以用它来表达上面的想法:</p><ul class=""><li id="4229" class="kv kw ht jw b jx jy ka kb kd kx kh ky kl kz kp la lb lc ld dt translated">a发送M和H(M)</li><li id="278b" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">b通过计算H(M)并检查匹配来验证消息</li></ul><p id="823b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">所以我们需要创建这样的函数来满足我们的需求，并且攻击它们是不可能的。这些函数应该有一些抗攻击的要求:</p><ul class=""><li id="1bce" class="kv kw ht jw b jx jy ka kb kd kx kh ky kl kz kp la lb lc ld dt translated">h可以应用于任何大小的消息</li><li id="4f3b" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">h产生固定长度的输出</li><li id="f0d0" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">计算H(M)很容易</li><li id="00e4" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">原像抗力性质:对于给定的H，找到M使得H(M) = h在计算上是不可行的</li><li id="12be" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">第二原像阻力性质:对于给定的M，计算上不可能找到M′≠M使得H(M′)= H(M)</li><li id="fa18" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">抗冲突性:用H(M)= H(M′)来寻找M，M′在计算上是不可行的</li></ul><p id="9be8" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">有许多不同的哈希函数，如果我们想列举一些流行的函数:</p><ul class=""><li id="3183" class="kv kw ht jw b jx jy ka kb kd kx kh ky kl kz kp la lb lc ld dt translated">MD5(消息摘要5)</li><li id="f5b9" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">SHA1(安全哈希算法1)</li><li id="6db4" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">SHA2家族:SHA-384 SHA-256 SHA-224，SHA 512</li><li id="68ef" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">SHA3(安全哈希算法3)</li></ul><p id="7532" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在我们已经介绍了散列函数，让我们看看它们是如何与我们的主题相关联的。在比特币协议中，哈希函数用于5个不同的地方:</p><ul class=""><li id="b608" class="kv kw ht jw b jx jy ka kb kd kx kh ky kl kz kp la lb lc ld dt translated">通过散列公钥产生<code class="eh lk ll lm ln b">public bitcoin address</code></li><li id="ca89" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">产生一个<code class="eh lk ll lm ln b">transaction digest</code>作为签署交易的输入</li><li id="f652" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">生成前一个块的散列以用于<code class="eh lk ll lm ln b">Blockchain</code>中的块头</li><li id="cb24" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">产生用于认证块中的事务的<code class="eh lk ll lm ln b">Merkle tree root</code>(沿着树向上使用散列)</li><li id="29c9" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">产生块的双重散列(带有随机数),以找到满足<code class="eh lk ll lm ln b">mining</code>中所需难度的块</li></ul><p id="53df" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">所以我们要解释所有这些。</p><h2 id="4800" class="lo lp ht bd lq lr ls lt lu lv lw lx ly kd lz ma mb kh mc md me kl mf mg mh mi dt translated">公共比特币地址</h2><p id="0d08" class="pw-post-body-paragraph ju jv ht jw b jx mj iu jz ka mk ix kc kd ml kf kg kh mm kj kk kl mn kn ko kp hm dt translated">让我们从生成比特币地址的第一个开始。每当用户想要接收或发送任何款项时，都应该在网络中有一个地址。你可以生成任意多的地址，现在一些钱包会为每一笔新交易自动生成一个新地址，这让你更加匿名。</p><p id="a83c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">让我们看看这些地址是如何像下图这样一步步生成的。您正在使用的任何操作系统都有一个生成随机数的内置函数。事实上，我们需要一个私钥和一个公钥来签署事务。通过使用操作系统的随机数生成器，我们生成一个随机数，这是我们的私钥，我们将看到的地址取决于这个私钥。所以我们的私钥就是图中的<em class="lj"> k </em> ( 256位)。我们将这个<em class="lj"> k </em>乘以G(这是spec256k1曲线上的一个生成点——我将在另一篇文章中解释椭圆曲线加密)，这个<em class="lj"> k </em> G就是我们可以给每个人的公钥。因此，当我们计算<em class="lj"> k </em> G时，它是曲线上一个具有Ux和Uy坐标的点，现在我们连接(Ux，Uy ),然后对其应用SHA256哈希函数，然后对输出应用另一个哈希函数(RIPEMD160 ),最终它是一个160位(20字节)输出。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mo"><img src="../Images/30f0473f7283afd7d2f047a1180b1992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iE-W1D8BIe1b5euUQISoCQ.png"/></div></div></figure><p id="c9dc" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们在RIPEMD-160哈希前面添加1 (0x00十六进制)字节作为版本字节(1是Base58编码)，该版本字节指示地址类型(我们将进一步看到不同的类型)。现在，我们对这21个字节应用SHA256两次，得到256位输出，然后我们剪切这256位输出的前4个字节(32位),并与之前的21位输出连接，现在，最终输出是一个25字节的地址，然后我们对其应用Base58编码，您会看到结果是上图末尾的可读字符串。所以你看到了我们在这个上下文中使用散列函数的次数。</p><h2 id="4b00" class="lo lp ht bd lq lr ls lt lu lv lw lx ly kd lz ma mb kh mc md me kl mf mg mh mi dt translated">交易摘要</h2><p id="172b" class="pw-post-body-paragraph ju jv ht jw b jx mj iu jz ka mk ix kc kd ml kf kg kh mm kj kk kl mn kn ko kp hm dt translated">我们在比特币系统中使用哈希函数的下一个地方是交易摘要。我们从不签署事务消息本身，我们总是首先对消息应用散列函数，然后签署事务摘要。例如，假设事务消息如下所示</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/72251b8732d7d6be23a3b32fa17b6b8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*sSSDaUMhlZiAgARFHSEmbg.png"/></div></figure><p id="3bd0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">事务消息绝对不是这样的(我将在另一篇文章中解释事务消息中的确切内容以及它们的区别),但现在只需想象它像上面的图片一样，所以当我们应用哈希函数时，我们有一个小的输出(256位),我们可以轻松地对它进行签名。事实上，事务摘要是两次应用SHA-256算法的结果。</p><h2 id="5e3d" class="lo lp ht bd lq lr ls lt lu lv lw lx ly kd lz ma mb kh mc md me kl mf mg mh mi dt translated">区块链和Merkle树</h2><p id="5629" class="pw-post-body-paragraph ju jv ht jw b jx mj iu jz ka mk ix kc kd ml kf kg kh mm kj kk kl mn kn ko kp hm dt translated">现在我们要深入我们的主要话题。我们从一个重要的概念<code class="eh lk ll lm ln b">Hash Pointers</code>开始，实际上，他们构建了我们的基础设施。</p><p id="1325" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">您可能熟悉数据结构中指针的概念。指针告诉我们特定的数据存储在内存中的什么地方，并指向存储在计算机内存中任何地方的值的地址。哈希指针是一个指针，指向在某个固定时间点存储数据以及该数据值的加密哈希的位置。常规指针为您提供了一种检索信息的方法，而散列指针也为您提供了一种验证信息没有改变的方法。</p><p id="c93b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><strong class="jw hu">实际上，</strong> <strong class="jw hu">数据存储在其中的地址就是数据的哈希</strong>。例如，下面的图片是blockchain.com<a class="ae mq" href="https://www.blockchain.com/" rel="noopener ugc nofollow" target="_blank">的</a>网站，这是一个查看区块和交易的浏览器，在这里你可以看到我们正在访问一个地址，其中有一个交易，交易显示0.015 <em class="lj"> BTC </em>从左边的地址发送到右边的地址，0.0845 <em class="lj"> BTC </em>返回到发送者地址。这个事务的hash就是我们要访问的地址，在图中用红线圈出。如果我们将散列函数应用于一个事务，并且与它的地址不匹配，这表明存在于地址中的数据被<strong class="jw hu">改变了，这里</strong>我们知道我们的消息(这里是事务)没有被认证，所以我们使用散列指针来创建<strong class="jw hu">认证的数据结构</strong>。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mr"><img src="../Images/4409f2c44db8737b9ce4baffab4ac6fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Cv9lhNxMBimZkKcd2lfvA.png"/></div></div></figure><p id="41c0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><strong class="jw hu"> <em class="lj">关键思想:</em> </strong></p><ul class=""><li id="b1b6" class="kv kw ht jw b jx jy ka kb kd kx kh ky kl kz kp la lb lc ld dt translated">采用任何基于指针的数据结构(比如链表)</li><li id="2e68" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">用加密哈希替换指针</li></ul><p id="59be" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们现在有了一个经过认证的数据结构。</p><p id="9abe" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><strong class="jw hu"> <em class="lj">区块链</em> </strong>是第一个也是最流行的认证数据结构，是一个使用哈希指针的链表。在一个常规的链表中，你有一系列的块，每个块都有数据和一个指向列表中前一个块的指针，而在区块链中，前一个块的指针将被替换为一个散列指针。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ms"><img src="../Images/bbd0c037f116b782baf60c635f60cf9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iWa-wOMMv2o_Bc9pL3DA8g.png"/></div></div></figure><p id="0e7c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">每个块不仅告诉我们前一个块的值在哪里，还包含该值的摘要，允许我们验证该值没有改变。</p><p id="6fa3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">再来看看下面这张来自<a class="ae mq" href="https://www.blockchain.com/" rel="noopener ugc nofollow" target="_blank">blockchain.com</a>探索者的图片，这次我们正在访问一个区块(区块编号565472 ),它显示了与之相关的一些信息，例如它包含3176个交易，并显示了这个区块中<em class="lj"> BTC </em>的总产量，或者开采池是F2Pool，以及当时开采的难度和区块回报。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mt"><img src="../Images/6bd618b75316ea3cfe064f2e8d8bd0f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4DWKAwBjpA0F9mIMfZY_Dw.png"/></div></div></figure><p id="b1e3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在这里，您可以看到数据块的哈希(以几个零开始),我们将此哈希作为数据块的地址来访问该数据块，因此这可以通过身份验证，因为我们可以访问其中的数据，并对其应用哈希函数，检查它是否与引用的地址匹配。您还可以看到，该数据块中存在上一个数据块哈希，如果我们单击它，我们会转到上一个数据块，实际上您可以看到区块链，但这有什么好处呢？</p><p id="9ae6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果对手修改区块链中任何地方的数据，将导致下一个块中的散列指针不正确。</p><p id="be69" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">对任何块的修改将永远传播:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mu"><img src="../Images/5de46aa317b6be3d7d1c5ccb9dc455ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uf6yfPsI_bqgFanCHejTvA.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">Tamper-evident Log</figcaption></figure><p id="c98f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">所以区块链正在给我们一个没有人可以修改的篡改明显的日志。</p><p id="60d4" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">因此，我们有一个经过验证的数据结构，所有事务的内容都存储在其中，并且我们确信这些事务的内容没有被更改。</p><h2 id="42b0" class="lo lp ht bd lq lr ls lt lu lv lw lx ly kd lz ma mb kh mc md me kl mf mg mh mi dt translated"><strong class="ak">默克尔树</strong></h2><p id="83fd" class="pw-post-body-paragraph ju jv ht jw b jx mj iu jz ka mk ix kc kd ml kf kg kh mm kj kk kl mn kn ko kp hm dt translated">比特币协议中使用的另一种认证数据结构是<strong class="jw hu"> Merkle树</strong>，其中<strong class="jw hu"> </strong>是哈希指针的二叉树。在区块链的每个块中，我们都有一个Merkle树，我们的事务都放在这个Merkle树的结构中。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/ddcc2012c3f5849afa76ece38199e7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*bQIwTuyrjzlk-55ts-mYUQ.jpeg"/></div></figure><p id="42ad" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">事务是Merkle树中的树叶(上图中的数据)，正如您所看到的，这些事务以二进制格式散列在一起，散列被散列在一起，我们继续，直到树的根，称为<strong class="jw hu"> <em class="lj"> Merkle Root </em> </strong>，Merkle Root是每个块头中出现的内容。</p><p id="9092" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在这个数据结构中，如果树中有<em class="lj"> n </em>个节点，那么只需要显示大约log( <em class="lj"> n </em>)项作为成员关系的证明。我们假设你想向某人证明你的事务(把蓝色圈起来的数据当作你的事务)存在于一个块中，一种方式是把整个区块链给那个人而当前的区块链大约是200 <em class="lj"> GB，</em>所以这种方式是不理性的因为，比如 您智能手机上的钱包不能包含200 <em class="lj"> GB </em>用于证明交易有效(当您想要从任何地址收款时，您应该确保该地址中存在金额，因此我们需要在块中显示交易成员)。</p><p id="8993" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">Merkle树提供了一种不用发送200 <em class="lj"> GB </em>信息就能证明有效性的方法。你只需要给那个人你的交易和上图中三个指定的散列(蓝色圆圈)，收到这些的人可以很容易地检查有效性，他只需要找到你的交易散列，然后分别用你给他的散列进行散列，如果他找到一个与块头中的Merkle根相匹配的Merkle根，成员资格证明就提供给log( <em class="lj"> n </em>)项。这是钱包正在使用的结构。</p><p id="baf5" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">要伪造证明，需要找到散列前像，从文章的第一部分，我们知道不可能找到具有良好设计的散列函数的散列前像。</p><p id="7e89" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">所以在比特币中，我们有两种哈希结构:</p><ul class=""><li id="1229" class="kv kw ht jw b jx jy ka kb kd kx kh ky kl kz kp la lb lc ld dt translated">块的散列链:这些块被链接在一起并且基于彼此</li><li id="2835" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated">每个块内部的Merkle事务树</li></ul><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mw"><img src="../Images/f15e7f706c835ec2d35cb4a96f75ffd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5HcUR0V8E-b7WRc-emLZXw.png"/></div></div></figure><h2 id="96dd" class="lo lp ht bd lq lr ls lt lu lv lw lx ly kd lz ma mb kh mc md me kl mf mg mh mi dt translated"><strong class="ak">结论</strong></h2><p id="4eb4" class="pw-post-body-paragraph ju jv ht jw b jx mj iu jz ka mk ix kc kd ml kf kg kh mm kj kk kl mn kn ko kp hm dt translated">所以我们研究了比特币中使用的数据结构，发现了区块链到底是什么，为什么它有用，为什么比特币使用这样一种经过认证的数据结构。比特币协议还有一个使用哈希函数的地方，我们在文章中提到过，那就是挖掘，但为了简洁起见，我们将在另一篇文章中解释。</p><p id="878c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我希望你喜欢它。</p><blockquote class="mx"><p id="84ce" class="my mz ht bd na nb nc nd ne nf ng kp ek translated">加入<a class="ae mq" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank"> Coinmonks电报频道</a>，了解加密交易和投资</p></blockquote><h2 id="7402" class="lo lp ht bd lq lr nh lt lu lv ni lx ly kd nj ma mb kh nk md me kl nl mg mh mi dt translated">另外，阅读</h2><ul class=""><li id="e326" class="kv kw ht jw b jx mj ka mk kd nm kh nn kl no kp la lb lc ld dt translated"><a class="ae mq" rel="noopener" href="/coinmonks/smart-contract-blockchain-splitwise-dapp-544d344c838e">智能合约开发&amp;部署</a></li><li id="c962" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated"><a class="ae mq" href="https://blog.coincodecap.com/binance-vs-kraken" rel="noopener ugc nofollow" target="_blank">币安vs北海巨妖</a> | <a class="ae mq" href="https://blog.coincodecap.com/pionex-dca-bot" rel="noopener ugc nofollow" target="_blank">美元成本平均交易机器人</a></li><li id="2a41" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated"><a class="ae mq" href="https://blog.coincodecap.com/stormgain-review" rel="noopener ugc nofollow" target="_blank"> Stormgain回顾</a> | <a class="ae mq" href="https://blog.coincodecap.com/bexplus-review" rel="noopener ugc nofollow" target="_blank"> Bexplus回顾</a> | <a class="ae mq" href="https://blog.coincodecap.com/binance-vs-bittrex" rel="noopener ugc nofollow" target="_blank">币安vs Bittrex </a></li><li id="dda8" class="kv kw ht jw b jx le ka lf kd lg kh lh kl li kp la lb lc ld dt translated"><a class="ae mq" href="https://blog.coincodecap.com/ftx-futures-trading" rel="noopener ugc nofollow" target="_blank">如何在FTX交易所交易期货</a> | <a class="ae mq" href="https://blog.coincodecap.com/okex-vs-binance" rel="noopener ugc nofollow" target="_blank"> OKEx vs币安</a></li></ul></div></div>    
</body>
</html>