<html>
<head>
<title>Bitcoin forecasts with stateless LSTM in Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tensorflow中无状态LSTM的比特币预测</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/bitcoin-forecasts-with-stateless-lstms-in-tensorflow-bad664db3497?source=collection_archive---------4-----------------------#2018-07-22">https://medium.com/coinmonks/bitcoin-forecasts-with-stateless-lstms-in-tensorflow-bad664db3497?source=collection_archive---------4-----------------------#2018-07-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/e08caed3064343077840e13a5ed1adcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7yNghnTpyKY7cGsRZT53BA.jpeg"/></div></div></figure><h2 id="02e3" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">介绍</h2><p id="f90d" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt hm dt translated"><strong class="kb hu">#动机</strong>加密货币是近年来最具颠覆性的技术之一。如今，市场的总市值达到了<a class="ae ku" href="https://coinmarketcap.com/all/views/all/" rel="noopener ugc nofollow" target="_blank">278</a>billions，据计算<a class="ae ku" href="https://www.statista.com/statistics/647374/worldwide-blockchain-wallet-users/" rel="noopener ugc nofollow" target="_blank">有2400万</a>人投资了比特币(比特币指的是整个市场，我用比特币指的是单一的加密货币)。即使目前市场不稳定，投机性很强，数据科学技术也可以为希望预测未来行为和趋势的投资者提供有价值的信息。由于噪音、波动性和重要指标的缺乏，这些指标可能无法在网上找到(或至少在公共和免费的公开来源中找到)，我们无法建立一个极其准确的预测环境。然而，数据分析技术可以在一定程度上为投资者提供一些信息，未来的股票市场价格可以在更精确的水平上进行评估。在这里，我提供了一个完整的Python框架来执行预测。即使我不期望预测非常精确，这项工作也可能是进一步发展和新改进的起点。</p><p id="9e59" class="pw-post-body-paragraph jz ka ht kb b kc kv ke kf kg kw ki kj jm kx kl km jq ky ko kp ju kz kr ks kt hm dt translated"><strong class="kb hu">#摘要</strong>在这篇文章中，我解释了如何通过使用多输出和多输入无状态递归神经网络来预测下一个比特币股票价格。在免费下载了一些数据后，建立了一个机器学习模型来预测第二天和下个月的股票价格。</p><p id="a768" class="pw-post-body-paragraph jz ka ht kb b kc kv ke kf kg kw ki kj jm kx kl km jq ky ko kp ju kz kr ks kt hm dt translated"><strong class="kb hu">#先决条件</strong>我假设你熟悉Python、递归神经网络和Tensorflow。如果不是这样，不要担心:确实有很多好东西(看看Karpathy的精彩解释<a class="ae ku" href="https://karpathy.github.io/2015/05/21/rnn-effectiveness/" rel="noopener ugc nofollow" target="_blank">这里</a>和NG的课程<a class="ae ku" href="https://www.coursera.org/specializations/deep-learning" rel="noopener ugc nofollow" target="_blank">这里</a>，<a class="ae ku" href="https://www.tensorflow.org/tutorials/" rel="noopener ugc nofollow" target="_blank">这里</a>而不是一些学习TF的教程)。我也会在旅途中提供一些关于一些技术细节的解释！完整的代码源代码可以在我的<a class="ae ku" href="https://github.com/colibri17/bitcoin" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>找到，大家看看吧！现在，让我们编码吧！</p></div><div class="ab cl la lb hb lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hm hn ho hp hq"><h2 id="13b2" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">编码—预处理</h2><p id="daea" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt hm dt translated"><strong class="kb hu"> #Data </strong>您需要向网络提供您认为对识别比特币趋势很重要的所有数据。这是至关重要的一步:你给网络的数据越好，它们与问题的相关性越高，你产生的预测就越好！在这方面，我通过<a class="ae ku" href="https://www.github.com/pydata/pandas-datareader" rel="noopener ugc nofollow" target="_blank">熊猫数据阅读器</a>库下载了一些比特币相关数据。我使用<a class="ae ku" href="https://www.quandl.com" rel="noopener ugc nofollow" target="_blank"> quandl </a>市场下载比特币和比特币密码货币。</p><p id="507e" class="pw-post-body-paragraph jz ka ht kb b kc kv ke kf kg kw ki kj jm kx kl km jq ky ko kp ju kz kr ks kt hm dt translated"><strong class="kb hu">#绘制</strong>下一步是绘制数据，以了解正在发生的事情。为此，在Jupyter笔记本中，您可以简单地使用<a class="ae ku" href="https://plot.ly" rel="noopener ugc nofollow" target="_blank"/>，这是一个可视化数据的极好资源。Plotly允许你放大情节，并以一种完整的javascript风格四处移动。</p><p id="d55b" class="pw-post-body-paragraph jz ka ht kb b kc kv ke kf kg kw ki kj jm kx kl km jq ky ko kp ju kz kr ks kt hm dt translated"><strong class="kb hu"> #RNNs </strong>现在，我们准备定义递归神经网络体系结构。我之前提到过，网络是多输出、多输入和状态完整的。但这意味着什么呢？</p><ul class=""><li id="30ff" class="lh li ht kb b kc kv kg kw jm lj jq lk ju ll kt lm ln lo lp dt translated">与许多其他机器学习算法不同，人工神经网络(和rnn)自然能够同时考虑多个时间序列输入和输出。换句话说，您可以同时向网络馈送多个时间序列数据，并决定不同的预测输出。例如，完全相同的网络可能能够基于全球定位系统坐标和天气条件(3个输入)预测轮胎的温度和压力(2个输出)。即一个<strong class="kb hu">多输入多输出</strong>递归神经网络。</li><li id="4410" class="lh li ht kb b kc lq kg lr jm ls jq lt ju lu kt lm ln lo lp dt translated">LSTM神经网络可以是<strong class="kb hu">无状态或</strong>状态。顾名思义，无状态LSTMs不跟踪网络及时传播的内部状态。处理完第一批序列后，他们将内部状态(但不是它们的权重)重置为初始值。相反，状态完整的LSTMs会记住各个训练批次的状态(和重量)。因此，虽然前者永远不会考虑大于序列长度的数据相关性，但后者可以记住多个时间步长的数据关系。</li></ul><p id="18fc" class="pw-post-body-paragraph jz ka ht kb b kc kv ke kf kg kw ki kj jm kx kl km jq ky ko kp ju kz kr ks kt hm dt translated"><strong class="kb hu"> #LSTM输入</strong>每个机器学习任务的第一步是对输入的数据进行预处理。根据输入数据集和要实现的模型，这可能涉及几个不同的任务:从清理数据到规范化列或平滑输入信号。在这方面，我做了以下工作:</p><ul class=""><li id="2a36" class="lh li ht kb b kc kv kg kw jm lj jq lk ju ll kt lm ln lo lp dt translated"><strong class="kb hu">标准化输入特征</strong>。在机器学习中，这种常见的做法主要允许基于梯度的优化算法更好地工作。此外，它通常还提供其他重要的<a class="ae ku" href="https://www.quora.com/Why-do-we-normalize-the-data" rel="noopener ugc nofollow" target="_blank">优势</a>。</li><li id="de87" class="lh li ht kb b kc lq kg lr jm ls jq lt ju lu kt lm ln lo lp dt translated"><strong class="kb hu">整形数据输入</strong>。数据必须以正确的格式提供给无状态rnn。输入数据必须是形状为<em class="lv"> B </em> x <em class="lv"> L </em> x <em class="lv"> F </em>的张量，其中<em class="lv"> B </em>是批量，<em class="lv"> L </em>是时间步长序列的长度，<em class="lv"> F </em>是输入特征的数量。在代码中，<code class="eh lw lx ly lz b">sentences_generator</code>函数将形状为<em class="lv"> L </em> x <em class="lv"> F </em>的一般时间序列转换为两个<em class="lv">N</em>x<em class="lv">L</em>x<em class="lv">F</em>和<em class="lv"> N x F </em>序列，分别为<em class="lv">、</em>，其中<em class="lv"> N </em>是您可以从数据中检索的总滚动序列数。前者作为输入训练，后者作为目标类。</li><li id="7111" class="lh li ht kb b kc lq kg lr jm ls jq lt ju lu kt lm ln lo lp dt translated"><strong class="kb hu">将数据分成训练验证和测试集</strong>。接下来，我将数据分成三个不相交的集合:用于构建模型的训练集，用于调整网络超参数的验证集，以及用于评估模型的未受破坏且完全不可见的测试集。因为我想预测未来的股票价格，所以训练、验证和测试数据集被及时排序，以便网络可以模拟具有一些历史数据的真实情况，以预测未来。</li><li id="56c8" class="lh li ht kb b kc lq kg lr jm ls jq lt ju lu kt lm ln lo lp dt translated"><strong class="kb hu">在每个时期的开始混洗训练数据</strong>。因为网络是无状态的，所以训练数据可以被打乱。该操作<a class="ae ku" href="https://www.quora.com/Why-do-we-need-to-shuffle-inputs-for-stochastic-gradient-descent" rel="noopener ugc nofollow" target="_blank">有助于</a>减少过度拟合，并提高小批量框架中批量梯度的近似值。</li></ul><p id="acd3" class="pw-post-body-paragraph jz ka ht kb b kc kv ke kf kg kw ki kj jm kx kl km jq ky ko kp ju kz kr ks kt hm dt translated">下面你可以按照代码实现所有这些步骤。因为训练数据在每个时期的开始被混洗，所以该操作在代码的下一个块中执行。</p><figure class="ma mb mc md fq iu"><div class="bz el l di"><div class="me mf l"/></div></figure></div><div class="ab cl la lb hb lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hm hn ho hp hq"><h2 id="2e38" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">编码—建模</h2><p id="f04c" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt hm dt translated">模型的实现是通过使用TF来完成的。与Keras不同，TF允许对正在开发的代码进行更多的控制，在更多的行级别上定义神经网络。在TF中，您可以完全定制您的模型，构建特定的损失函数或网络结构。同时，TF提供了一个完整的框架来评估你的模型在运行时的性能，叫做<a class="ae ku" href="https://www.tensorflow.org/guide/summaries_and_tensorboard" rel="noopener ugc nofollow" target="_blank">张量板</a>。它允许你在特定的时间步跟踪你选择的张量的值。通过这样做，您可以确定训练中权重开始偏离或验证损失停止减少的确切点。</p><p id="c6bb" class="pw-post-body-paragraph jz ka ht kb b kc kv ke kf kg kw ki kj jm kx kl km jq ky ko kp ju kz kr ks kt hm dt translated"><strong class="kb hu">#模型结构</strong>为了进行预测，我们生成了一个LSTM模型，该模型具有长度为10的128个训练批次作为输入，每个训练批次由4个特征形成。LSTM处理输入并产生10个输出张量，每个输出张量包含由128个特征组成的128个训练实例。因为我只需要考虑预测的最终时间步长(对应于第二天的预测)，所以我只考虑网络的最后输出，从而产生由128个特征形成的128个训练批次的张量。依次地，这被馈送到2个神经层，这允许逐渐减少特征维度，以产生由4个特征组成的128个训练元素。根据均方损失函数，将该输出与真实next值进行比较。您可以使用张量板查看网络结构:</p><figure class="ma mb mc md fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mg"><img src="../Images/669ac415c6ba0ca807bd8a5d045ec2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZPdSQaCsJDR7-WsvxLHhQw.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Network structure in tensor-board</figcaption></figure><p id="09d0" class="pw-post-body-paragraph jz ka ht kb b kc kv ke kf kg kw ki kj jm kx kl km jq ky ko kp ju kz kr ks kt hm dt translated"><strong class="kb hu"> #Logging </strong>在代码中，一些张量被添加到张量板要跟踪的变量集中。打开终端并键入以下内容:</p><pre class="ma mb mc md fq ml lz mm mn aw mo dt"><span id="66ad" class="jb jc ht lz b fv mp mq l mr ms">tensorboard --logdir ./rnn/run1</span></pre><p id="ac05" class="pw-post-body-paragraph jz ka ht kb b kc kv ke kf kg kw ki kj jm kx kl km jq ky ko kp ju kz kr ks kt hm dt translated">您现在可以看到要跟踪的参数的演变。还要注意，我以预先选择的时间步长保存模型，以便在固定点恢复整个网络状态。通过监控损失，您可以选择要使用的最终最佳模型:在验证集上获得最小值的模型是要选择的好的最终候选模型。</p><figure class="ma mb mc md fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mt"><img src="../Images/829947ed76e5ec695dcb3a3677221b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5vbQf1uT_cIYtYO8vHFQNg.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Training and validation loss evolutions</figcaption></figure><figure class="ma mb mc md fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mu"><img src="../Images/0bfa5a265a579146bad7f5aa90077ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hS2FelPQFWZMYdC-3Ssl5w.png"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Weights and biases of the last two layers of the network while training</figcaption></figure><p id="ea91" class="pw-post-body-paragraph jz ka ht kb b kc kv ke kf kg kw ki kj jm kx kl km jq ky ko kp ju kz kr ks kt hm dt translated">在下面，您可以看到执行所有这些操作的代码块:</p><figure class="ma mb mc md fq iu"><div class="bz el l di"><div class="me mf l"/></div></figure></div><div class="ab cl la lb hb lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hm hn ho hp hq"><h2 id="11a9" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">编码—评估</h2><p id="0365" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt hm dt translated"><strong class="kb hu">#测试数据</strong>每个机器学习过程的最后一部分是评估模型性能。用于此目的的测试数据必须是算法在训练期间根本没有处理的观察结果，以便您可以在真实世界场景中真正验证模型。此外，测试记录具有与训练集相同的数据分布也很重要。请记住，该算法是建立在训练数据之上的，并且(希望如此！)它设法适应底层的数据分布。因此，我假设数据分布不随时间变化，这样我就可以安全地使用历史训练数据来预测未来的市场价格。</p><p id="5ad3" class="pw-post-body-paragraph jz ka ht kb b kc kv ke kf kg kw ki kj jm kx kl km jq ky ko kp ju kz kr ks kt hm dt translated"><strong class="kb hu">#预测</strong>载入保存的网络后进行预测。执行两种预测:</p><ul class=""><li id="6485" class="lh li ht kb b kc kv kg kw jm lj jq lk ju ll kt lm ln lo lp dt translated"><strong class="kb hu">次日预测</strong>。对于训练、验证和测试集中的每个元素，我预测所有输入特征的下一个值。正如你在下图中看到的，误差很小。</li><li id="c183" class="lh li ht kb b kc lq kg lr jm ls jq lt ju lu kt lm ln lo lp dt translated"><strong class="kb hu">下月预测</strong>。要真正评估模型，仅仅产生第二天的预测是不够的，还需要获得很长时间的预测。第二天的预测确实被认为是接近真实情况的，因此可能会产生误导。相反，长期预测可以给出真实模型性能的感觉，反映真实情况并提供更有用的估计。为了做到这一点，我首先将所有的输入时间序列逐步移动一个，然后对下一个时间步进行新的预测。请注意，在第二种情况下，错误更加明显，即使预测似乎提供了某种未来趋势。</li></ul><figure class="ma mb mc md fq iu"><div class="bz el l di"><div class="me mf l"/></div></figure><h2 id="c721" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">丰富</h2><p id="9821" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt hm dt translated">这可能是本文最重要的部分。在此，我提出一些改进整个过程的建议:</p><ul class=""><li id="f4e2" class="lh li ht kb b kc kv kg kw jm lj jq lk ju ll kt lm ln lo lp dt translated"><strong class="kb hu">收集更多数据。</strong>机器学习中的很多典型问题，可以通过收集更多的数据来解决。在本文中，我使用非常小的样本量来构建神经网络。以更高的频率(每小时或每分钟)收集数据可以极大地帮助网络改善结果，并变得更能概括。</li><li id="13bc" class="lh li ht kb b kc lq kg lr jm ls jq lt ju lu kt lm ln lo lp dt translated"><strong class="kb hu">对变量</strong>进行更好的选择。找到问题的相关数据对于生成好的模型至关重要。几个变量可能会影响未来的比特币价格，选择那些可能为这项任务提供有价值信息的变量是至关重要的。那么美元/欧元的变化是否影响了比特币的价格呢？其他加密货币趋势会影响市场吗？</li><li id="1d2b" class="lh li ht kb b kc lq kg lr jm ls jq lt ju lu kt lm ln lo lp dt translated"><strong class="kb hu">平滑输入时间序列</strong>。预测股票价格的一个问题是输入时间序列中存在的固有噪声(如果你看一下<code class="eh lw lx ly lz b">volume</code>的图，你可以很容易地识别这种行为)。标准神经网络只是从输入到输出空间的优化的确定性映射，因此在目标类中遭受随机行为。</li><li id="1214" class="lh li ht kb b kc lq kg lr jm ls jq lt ju lu kt lm ln lo lp dt translated"><strong class="kb hu">使时间序列平稳</strong>。平稳时间序列保持时间步长上的均值、方差和协方差。大多数统计预测方法都是基于这样的假设，即通过使用数学变换可以使时间序列近似平稳。一个平稳化的序列相对容易预测:你只需简单地预测它的统计特性在将来会和过去一样！</li><li id="bd27" class="lh li ht kb b kc lq kg lr jm ls jq lt ju lu kt lm ln lo lp dt translated"><strong class="kb hu">超调神经网络参数</strong>。没有对网络进行调整，但这是建模的一个重要步骤。从学习率开始，您可以决定调整网络以找到与您提供的数据相关的最佳参数。</li><li id="b6ed" class="lh li ht kb b kc lq kg lr jm ls jq lt ju lu kt lm ln lo lp dt translated"><strong class="kb hu">改变目标变量。</strong>网络预测所有输入时间序列的次日值。为了及时概括未来的过程，我逐步改变输入时间序列，以包括最近的预测，然后做出新的预测。因此，随着我们不断预测时间的推移，误差自然会增加。例如，由于每个人都想知道一个月后价格是上涨还是下跌，您可能希望将目标变量重新定义为二进制输出(上涨还是下跌)。</li></ul></div><div class="ab cl la lb hb lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hm hn ho hp hq"><p id="438c" class="pw-post-body-paragraph jz ka ht kb b kc kv ke kf kg kw ki kj jm kx kl km jq ky ko kp ju kz kr ks kt hm dt translated">感谢您阅读文章！希望你喜欢。如果我有时间(呵呵呵！)，我想写第二个帖子，应用上面的一些建议来改善结果。请在评论中告诉我这对你来说是不是一个好主意！如果有不清楚的地方，欢迎提问，我会尽我所能回答你！</p></div></div>    
</body>
</html>