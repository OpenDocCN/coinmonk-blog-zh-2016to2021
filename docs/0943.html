<html>
<head>
<title>Predicting product sales through ads delivered on Social Networking Sites using k-N.N. in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的k-N.N，通过社交网站上的广告预测产品销售</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/predicting-product-sales-through-ads-delivered-on-social-networking-sites-using-k-n-n-in-python-b9f955d184af?source=collection_archive---------0-----------------------#2018-07-04">https://medium.com/coinmonks/predicting-product-sales-through-ads-delivered-on-social-networking-sites-using-k-n-n-in-python-b9f955d184af?source=collection_archive---------0-----------------------#2018-07-04</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/f0db7f4c83a212d31a08a9fe16951b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*rh2Ad1e4IrpRaBYsspvWKA.png"/></div></figure><blockquote class="ix iy iz"><p id="bd0e" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">简而言之，我们判断社交网站上的用户在点击网站上显示的广告后，最终是否会购买该产品。这对销售该产品的公司来说非常有帮助。假设一家汽车公司付费给社交网站(为了简单起见，我们从现在开始假设它是脸书)来展示其新上市汽车的广告。现在，由于该公司在很大程度上依赖于其新推出的汽车的成功，它会不遗余力地为汽车做广告。那还有什么比现在在最流行的平台上做广告更好的呢？但是如果我们只对正确的人群做广告呢？这可能有助于促进销售，因为我们将只向选定的人群展示汽车广告。<br/>所以这就是你的用武之地……<br/>汽车公司聘请你作为数据科学家，找出正确的人群，你需要向他们宣传汽车<br/>，并根据某些特征找出最有可能购买汽车的人，这些特征描述了以前通过点击广告购买汽车的用户类型<br/>。</p></blockquote><h1 id="b24f" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">那么这篇文章的读者是谁呢？</h1><p id="f1ba" class="pw-post-body-paragraph ja jb ht jd b je kx jg jh ji ky jk jl kz la jo jp lb lc js jt ld le jw jx jy hm dt translated">你可以是刚刚完成机器学习MOOC的人，也可以是正在寻找基于机器学习的更实用/动手项目的初露头角的数据科学家。</p><p id="76f2" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">如果你想将一些商业方面与机器学习结合起来，这也是相关的。</p><h1 id="597e" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">K.最近邻(k-N.N .)</h1><h2 id="cacc" class="lf ka ht bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls dt translated"><strong class="ak">温柔的介绍……</strong></h2><p id="ad6c" class="pw-post-body-paragraph ja jb ht jd b je kx jg jh ji ky jk jl kz la jo jp lb lc js jt ld le jw jx jy hm dt translated">k-NN算法是所有机器学习算法中最简单的。输入由特征空间中的<em class="jc"> k </em>个最接近的训练样本组成，而输出取决于<em class="jc"> k </em> -NN是用于分类还是回归:</p><p id="ed16" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">在<strong class="jd hu"> k-NN分类</strong>中，输出是一个类成员。对象通过其邻居的多数投票进行分类，对象被分配到其k个最近邻居中最常见的类别(k是正整数，通常很小)。如果k = 1，那么该对象被简单地分配给该单个最近邻的类。</p><p id="eb2d" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">在<strong class="jd hu"> <em class="jc"> k-NN回归</em> </strong>中，输出的是对象的属性值。这个值是它的<em class="jc"> k个</em>最近邻居的平均值。</p><blockquote class="ix iy iz"><p id="69e3" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这种特殊情况下，我们正在处理一个分类问题，因为我们需要将用户分类为那些想要或不想要汽车的人。</p></blockquote><h2 id="92d0" class="lf ka ht bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls dt translated">算法是如何工作的？</h2><p id="428c" class="pw-post-body-paragraph ja jb ht jd b je kx jg jh ji ky jk jl kz la jo jp lb lc js jt ld le jw jx jy hm dt translated">步骤1)选择K个邻居<br/>步骤2)根据欧几里德距离<br/>步骤3)在这K个邻居中，计算每个类别中数据点的数量<br/>步骤4)将新数据点分配到您计算出邻居最多的类别。</p><p id="9122" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">……现在你的模型准备好了！！</p><h1 id="b71a" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">我们还在等什么？我们开始吧！！</h1><h2 id="93bc" class="lf ka ht bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls dt translated">第1部分—数据预处理</h2><p id="3142" class="pw-post-body-paragraph ja jb ht jd b je kx jg jh ji ky jk jl kz la jo jp lb lc js jt ld le jw jx jy hm dt translated">导入库</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="8e70" class="lf ka ht ly b fv mc md l me mf"><em class="jc">import </em>numpy <em class="jc">as </em>np<br/><em class="jc">import </em>matplotlib.pyplot <em class="jc">as </em>plt<br/><em class="jc">import </em>pandas <em class="jc">as </em>pd</span></pre><p id="97d3" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">导入数据集</p><blockquote class="ix iy iz"><p id="a5b6" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">数据集包含关于社交网站上的用户的信息，并使用该信息作为我们的ML模型的特征，我们试图预测特定用户在点击社交网站上的广告后是否会继续购买特定产品。这个特殊的社交网络有一个商业客户，如前所述，是一家汽车公司，它通过在社交网站上添加广告来宣传自己。现在，社交网络的工作是收集用户是否购买了产品的信息。这种情况下的因变量是Purchased，如果用户购买汽车，则为1，否则为0。<br/>因此，这里的目标是创建一个分类器，通过预测用户是否购买产品，将每个用户归入正确的类别。</p></blockquote><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="356c" class="lf ka ht ly b fv mc md l me mf">dataset = pd.read_csv('Social_Network_Ads.csv')</span></pre><p id="96f5" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">打印数据集的前几个条目</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="24d2" class="lf ka ht ly b fv mc md l me mf">print(dataset.head())</span></pre><p id="673c" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">以下特征将被视为独立变量……<br/>…1)<strong class="jd hu">年龄</strong> <br/> …2) <strong class="jd hu">预计工资</strong> <br/>现在，你们中的一些人可能会奇怪，数据集还包含3个以上的列，为什么我们要删除它们？这个问题的答案很简单……我们很快就会知道为什么他们中的每一个都被抛弃了。<br/> …1) <strong class="jd hu">用户标识</strong> -用户标识对用户是否会购买汽车没有影响<br/> …2) <strong class="jd hu">性别</strong> -有些人可能会说性别会起作用，但这确实是一个主观的讨论。<br/>此外，由于性别是一个分类变量，我们必须对其使用变量编码器。</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="1621" class="lf ka ht ly b fv mc md l me mf">X = dataset.iloc[:, [2, 3]].values</span></pre><p id="19be" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">将因变量存储在y中，即购买，如果用户购买汽车，则为1，否则为0。</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="e504" class="lf ka ht ly b fv mc md l me mf">y = dataset.iloc[:, 4].values</span></pre><p id="d0eb" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">这是数据集的实际样子…</p><figure class="lt lu lv lw fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="fe ff mg"><img src="../Images/c59c557e41b053d25ae4da0daf2a3091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_usS4kC-v-m23j05PDjZ1w.png"/></div></div></figure><h2 id="e029" class="lf ka ht bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls dt translated">将数据集分为训练集和测试集</h2><p id="13d5" class="pw-post-body-paragraph ja jb ht jd b je kx jg jh ji ky jk jl kz la jo jp lb lc js jt ld le jw jx jy hm dt translated">导入交叉验证库，在Python的新版本中现在称为ModelSelection</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="7944" class="lf ka ht ly b fv mc md l me mf"><em class="jc">from </em>sklearn.model_selection <em class="jc">import </em>train_test_split</span></pre><p id="99c7" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">我们将数据分为75%用于训练，25%用于测试我们的数据</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="4c06" class="lf ka ht ly b fv mc md l me mf">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 0)</span></pre><p id="9245" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated"><strong class="jd hu">现在我们要应用特征缩放吗？</strong> <br/> <strong class="jd hu">是的</strong>，我们肯定会应用特征缩放，因为我们想要准确的预测，也就是说，我们想要预测哪些用户会购买或不购买汽车。</p><h2 id="c095" class="lf ka ht bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls dt translated">特征缩放</h2><p id="5a92" class="pw-post-body-paragraph ja jb ht jd b je kx jg jh ji ky jk jl kz la jo jp lb lc js jt ld le jw jx jy hm dt translated">导入库</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="fcc0" class="lf ka ht ly b fv mc md l me mf"><em class="jc">from </em>sklearn.preprocessing <em class="jc">import </em>StandardScaler</span></pre><p id="ba93" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">创建预处理类的标准标量对象</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="c023" class="lf ka ht ly b fv mc md l me mf">sc = StandardScaler()</span></pre><p id="605a" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">通过将标准标量对象拟合到我们的特征矩阵X_train来缩放X_train</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="ec4b" class="lf ka ht ly b fv mc md l me mf">X_train = sc.fit_transform(X_train)</span></pre><p id="d089" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">在相同的基础上缩放X_test</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="093e" class="lf ka ht ly b fv mc md l me mf">X_test = sc.transform(X_test)</span></pre><p id="9ff1" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">要真正看到差异并确认它们几乎达到相同的比例，如果你愿意，你可以…</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="21f1" class="lf ka ht ly b fv mc md l me mf">print(X_train)<br/>print(X_test)</span></pre><h1 id="c886" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">第2部分—拟合我们的k-n-n模型</h1><p id="d9b6" class="pw-post-body-paragraph ja jb ht jd b je kx jg jh ji ky jk jl kz la jo jp lb lc js jt ld le jw jx jy hm dt translated">将K-NN拟合到训练集</p><p id="24c3" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">所以我们需要导入scikit.neighbours库，并从中导入KNN分类器</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="55b3" class="lf ka ht ly b fv mc md l me mf"><em class="jc">from </em>sklearn.neighbors <em class="jc">import </em>KNeighborsClassifier</span></pre><p id="144a" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">创建类的对象… <br/>通过按Ctrl+Q显示文档并查看所有参数及其相应定义来检查分类器<br/>→最近邻数=5(默认)<br/>→指定公制为“闵可夫斯基”，幂为“2”，以使用k-N.N的欧几里德距离。== &gt;设置p=2</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="4804" class="lf ka ht ly b fv mc md l me mf">classifier = KNeighborsClassifier(n_neighbors = 5, metric = 'minkowski', p = 2)</span></pre><p id="2239" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">现在我们让分类器对象适合我们的训练集</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="036f" class="lf ka ht ly b fv mc md l me mf">classifier.fit(X_train, y_train)</span></pre><h1 id="e4ae" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">第3部分—预测测试集结果</h1><p id="3049" class="pw-post-body-paragraph ja jb ht jd b je kx jg jh ji ky jk jl kz la jo jp lb lc js jt ld le jw jx jy hm dt translated">由于分类器已经适合数据集，我们可以预测测试集的结果。</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="681b" class="lf ka ht ly b fv mc md l me mf">y_pred = classifier.predict(X_test)</span></pre><p id="965d" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">显示预测值</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="1abd" class="lf ka ht ly b fv mc md l me mf">print(y_pred)</span></pre><p id="5f2a" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">现在来计算我们模型的准确性…</p><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="0d13" class="lf ka ht ly b fv mc md l me mf">c=0<br/><em class="jc">for </em>i <em class="jc">in </em>range(0,len(y_pred)):<br/>    <em class="jc">if</em>(y_pred[i]==y_test[i]):<br/>        c=c+1<br/>accuracy=c/len(y_pred)<br/>print("Accuracy is")<br/>print(accuracy)</span></pre><p id="19dc" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">所以当你运行它时，你会得到大约93%的准确率，这对我们的分类器来说是一个巨大的成就。</p><p id="0515" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">我们以此结束我们的预测。现在下一部分是数据可视化，它帮助我们可视化模型的准确性和错误。</p></div><div class="ab cl ml mm hb mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hm hn ho hp hq"><h1 id="8d79" class="jz ka ht bd kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw dt translated">第4部分—数据可视化和混淆矩阵</h1><h2 id="33ac" class="lf ka ht bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls dt translated">可视化训练集结果</h2><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="15b2" class="lf ka ht ly b fv mc md l me mf"><em class="jc">from </em>matplotlib.colors <em class="jc">import </em>ListedColormap<br/>X_set, y_set = X_train, y_train<br/>X1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 1, stop = X_set[:, 0].max() + 1, step = 0.01),<br/>                     np.arange(start = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))<br/>plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),<br/>             alpha = 0.75, cmap = ListedColormap(('red', 'green')))<br/>plt.xlim(X1.min(), X1.max())<br/>plt.ylim(X2.min(), X2.max())<br/><em class="jc">for </em>i, j <em class="jc">in </em>enumerate(np.unique(y_set)):<br/>    plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],<br/>                c = ListedColormap(('red', 'green'))(i), label = j)<br/>plt.title('K-NN (Training set)')<br/>plt.xlabel('Age')<br/>plt.ylabel('Estimated Salary')<br/>plt.legend()<br/>plt.show()</span></pre><p id="7ea5" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">所以现在运行上面的代码后会显示类似这样的内容…</p><figure class="lt lu lv lw fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="fe ff mx"><img src="../Images/33942d6e8bdb6ddc3c36e107ecc78a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8JWvy1F7ayckEFCKthlygg.png"/></div></div></figure><p id="d0f4" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">在新打开的训练集图表中可以看到，我们有一个非常适合数据的非线性分类器。</p><p id="e46c" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">除了极少数错误分类的点…红色点在绿色区域，反之亦然，我们的模型在分类这些点方面做得相当不错。</p><h2 id="c31d" class="lf ka ht bd kb lg lh li kf lj lk ll kj kz lm ln kn lb lo lp kr ld lq lr kv ls dt translated">可视化测试集结果</h2><pre class="lt lu lv lw fq lx ly lz ma aw mb dt"><span id="4781" class="lf ka ht ly b fv mc md l me mf"><em class="jc">from </em>matplotlib.colors <em class="jc">import </em>ListedColormap<br/>X_set, y_set = X_train, y_train<br/>X1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 1, stop = X_set[:, 0].max() + 1, step = 0.01),<br/>                     np.arange(start = X_set[:, 1].min() - 1, stop = X_set[:, 1].max() + 1, step = 0.01))<br/>plt.contourf(X1, X2, classifier.predict(np.array([X1.ravel(), X2.ravel()]).T).reshape(X1.shape),<br/>             alpha = 0.75, cmap = ListedColormap(('red', 'green')))<br/>plt.xlim(X1.min(), X1.max())<br/>plt.ylim(X2.min(), X2.max())<br/><em class="jc">for </em>i, j <em class="jc">in </em>enumerate(np.unique(y_set)):<br/>    plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1],<br/>                c = ListedColormap(('red', 'green'))(i), label = j)<br/>plt.title('K-NN (Training set)')<br/>plt.xlabel('Age')<br/>plt.ylabel('Estimated Salary')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="lt lu lv lw fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="fe ff mx"><img src="../Images/bf8eae65ad33dc8bed78ac5912f2d541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yP2WXIO0beRxYQnsZNLl4w.png"/></div></div></figure><p id="42ee" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">就像我们在对测试集结果进行分析之前对训练集的图形进行分析一样…</p><p id="dcc8" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">然而，我们再次看到，大多数点都被正确分类，只是有几个例外，顺便说一下，这很好，因为我们试图防止我们的模型过度拟合，我们知道这可能是一个严重的威胁。</p><p id="0e57" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">现在，我们已经可视化了训练和测试集图，我们已经正式完成了模型的构建和数据可视化。</p><p id="0a1e" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">Yayyy！！所以你刚刚建立了一个k-n-n模型来预测在社交媒体上做广告的产品的销售。雇用你作为数据科学家的汽车公司现在将能够做出明智的决定，瞄准正确的人群，为其全新的汽车做广告，而你将是其巨大销售的原因。我希望你已经感到自豪了！！:P</p><p id="f403" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">我希望你喜欢我的教程！我将github(现在是Gitlab :P)链接附加到代码和数据集上。</p><p id="694d" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated"><a class="ae my" href="https://github.com/Sid-darthvader/Predicting_Product_Sales_through_ads_on_SocialMedia_using_k-N.N." rel="noopener ugc nofollow" target="_blank">https://github . com/Sid-Darth Vader/Predicting _ Product _ Sales _ through _ ads _ on _ social media _ using _ k-n . n .</a></p><p id="102c" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated"><strong class="jd hu">谁知道你的车型可能只是帮你宣传特斯拉的下一款车型；P </strong></p><p id="4ef9" class="pw-post-body-paragraph ja jb ht jd b je jf jg jh ji jj jk jl kz jn jo jp lb jr js jt ld jv jw jx jy hm dt translated">参考文献-机器学习课程，作者:基里尔·叶列缅科和哈德琳·德·庞特维斯</p></div></div>    
</body>
</html>