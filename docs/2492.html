<html>
<head>
<title>Verify a smart contract with Archetype</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用原型验证智能合同</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/verify-a-smart-contract-with-archetype-6e0ea548e2da?source=collection_archive---------1-----------------------#2019-11-05">https://medium.com/coinmonks/verify-a-smart-contract-with-archetype-6e0ea548e2da?source=collection_archive---------1-----------------------#2019-11-05</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="7261" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="http://archetype-lang.org/" rel="noopener ugc nofollow" target="_blank">原型</a>是一种简单的高级语言，用于在<a class="ae jo" href="https://tezos.com/" rel="noopener ugc nofollow" target="_blank"> Tezos区块链</a>上开发智能合约。它使得<em class="jp">能够通过将</em>合同转码为<a class="ae jo" href="http://why3.lri.fr/" rel="noopener ugc nofollow" target="_blank"> Why3 </a>来正式验证合同。有关原型语言的更多信息，请访问下面的链接:</p><div class="jq jr fm fo js jt"><a rel="noopener follow" target="_blank" href="/coinmonks/archetype-a-dsl-for-tezos-6f55c92d1035"><div class="ju ab ej"><div class="jv ab jw cl cj jx"><h2 class="bd hu fv z el jy eo ep jz er et hs dt translated">Tezos的DSL原型</h2><div class="ka l"><h3 class="bd b fv z el jy eo ep jz er et ek translated">Archetype是一种特定于领域的语言(DSL ),用于在Tezos区块链上开发智能合同，具有特定的焦点…</h3></div><div class="kb l"><p class="bd b gc z el jy eo ep jz er et ek translated">medium.com</p></div></div><div class="kc l"><div class="kd l ke kf kg kc kh ki jt"/></div></div></a></div><p id="3ff1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本文中，我们开发、指定并正式验证一个智能契约；通过正式验证，我们发现并修复错误，并确保它符合其规范。</p><p id="66f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面的视频是演示的放映(25分钟):</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="214f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面是演示的文本版本。</p><h1 id="ac15" class="kq kr ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">合同</h1><p id="e6d4" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">本演示的目标是为连锁<a class="ae jo" href="https://en.wikipedia.org/wiki/Loyalty_program" rel="noopener ugc nofollow" target="_blank">忠诚度计划</a>开发一份智能合同。这个契约记录了<em class="jp">里程</em>和里程<em class="jp">所有者</em>，有两个入口点:<em class="jp">添加</em>和<em class="jp">消费。</em></p><h2 id="737d" class="lt kr ht bd ks lu lv lw kw lx ly lz la jb ma mb le jf mc md li jj me mf lm mg dt translated">合同资产</h2><p id="94b1" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">英里<em class="jp">所有者</em>由地址值标识，拥有几英里(可能为零)。一英里由一个唯一的<em class="jp">字符串</em> id和一个截止日期来标识，因此一英里在其截止日期之后不能被消费。</p><p id="8c85" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面的模式说明了数据的基本建模:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mh"><img src="../Images/3421760142c44a91c9614668cd2380d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K2NjP-c5_sSeMioGG16eAA.png"/></div></div></figure><p id="b04e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对上述模型进行了优化。一英里增加一个<em class="jp">数量</em>值，以收集具有相同到期日期的几英里。例如，具有相同到期日期的3英里合并为一英里，其中<em class="jp">数量</em>值设置为3:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mn"><img src="../Images/9188de1dfc24cadc5f54fc92cccd4fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bVw6qdVS_a_z9vFiQsNtbA.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">3 miles with the same expiration date …</figcaption></figure><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff ms"><img src="../Images/d98ff5c5744026de06aa34921ca17315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6_Ch2ozpfCELLvNm778Oog.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">… merged into one asset.</figcaption></figure><h1 id="13e4" class="kq kr ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">密码</h1><p id="62f1" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">下面的代码片段是协定数据的原型实现:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mt kp l"/></div></figure><p id="cb0a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意，里程收集的类型(第11行)是<em class="jp">分区:</em>这是为了指定一个<em class="jp">里程</em>归一个且仅一个<em class="jp">所有者</em>所有。例如，这可以防止直接在英里集合中添加或删除英里。它必须通过车主的<em class="jp">英里</em>收集。</p><p id="282e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当向所有者的里程集合添加里程时，测试该里程是否已经存在；如果是，则<em class="jp">添加</em>指令失败。</p><p id="b006" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是通过单个英里集合实现的，并且<em class="jp">英里</em>字段被实现为英里标识符列表，而不是英里列表。</p><h2 id="e23b" class="lt kr ht bd ks lu lv lw kw lx ly lz la jb ma mb le jf mc md li jj me mf lm mg dt translated">行动</h2><p id="2cde" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated"><em class="jp"> add </em>动作有两个参数:一个所有者地址和一个要添加到该所有者的新英里:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mt kp l"/></div></figure><p id="924d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">业主</em>上面(第4行)是所有业主的<em class="jp">集合</em>。<em class="jp"> get </em>方法允许从地址中检索一个所有者(这是所有者标识符)。</p><p id="5449" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp"> add </em>方法(第5行)用于将资产添加到集合中(这里是<em class="jp"> o.miles </em>)。</p><p id="eb6c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">消费</em>动作有两个参数:一个所有者的地址<em class="jp"> ow </em>和这个所有者要消费的里程数<em class="jp"> qty </em>:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mt kp l"/></div></figure><p id="ba3d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因为每英里携带的<em class="jp">数量</em>字段，所以<em class="jp">消耗</em>动作的实现不是那么简单:</p><ul class=""><li id="9c55" class="mu mv ht is b it iu ix iy jb mw jf mx jj my jn mz na nb nc dt translated">车主有效里程的收集是用<em class="jp">选择</em>方法创建的(第4行)</li><li id="00ba" class="mu mv ht is b it nd ix ne jb nf jf ng jj nh jn mz na nb nc dt translated">里程被删除，直到删除的里程数等于<em class="jp">数量；为此，迭代每个有效英里:如果当前英里的数量小于要删除的剩余英里数(第9行)，则删除该英里(第11行)，剩余值减少其数量；否则，当前英里数减少(第14行),剩余数量设置为0(第13行)</em></li></ul><p id="a1b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个实现有两个错误:你能发现它们吗？下一节介绍的验证将有助于检测和修复它们。</p><h1 id="b3c2" class="kq kr ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">具体说明</h1><p id="3778" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">注意，英里资产的<em class="jp">数量</em>字段的类型是<em class="jp"> int </em>(即。<em class="jp">整数</em>上面<em class="jp">资产</em>部分的第6行)，可以是负数。但是，数量等于或小于零没有意义。我们希望对数量字段指定一些约束，特别是它应该保持<em class="jp">严格为正。</em></p><p id="fea8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">可以用<em class="jp">资产不变量</em>指定这样的约束(下面的第5到7行):</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mt kp l"/></div></figure><p id="6354" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这将为所有动作生成相应的证明义务(<em class="jp">添加</em>和<em class="jp">消耗</em>)。</p><p id="1393" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们希望从一个地址操作契约，也就是说，每个动作只能由这个地址调用。原型提供了一个专用的“修改器”<em class="jp">，由</em>(第4行)调用:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mt kp l"/></div></figure><p id="9e02" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">安全谓词<em class="jp"> only_by_role </em>(下面的第2行)可以在<em class="jp">安全</em>部分中使用，以指定任何操作都应该使用由admin:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mt kp l"/></div></figure><p id="5ee5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp"> no_storage_fail </em>谓词(上面的第3行)用于声明一个动作(这里是<em class="jp"> add </em>动作)不应该失败，无论是“找不到键”还是“存在键”异常。通常最好的做法是不要用<em class="jp">逻辑</em>异常编程，无论是显式的(用<em class="jp"> try … catch </em>机制)还是隐式的，就像智能合约中的那样，在失败的情况下会有回滚机制。最好用<em class="jp">显式打开执行分支，然后再用</em>控制。异常应该只用于硬件、网络…故障，也就是说，程序本身无法控制的任何事情。</p><p id="c4d7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">显然，<em class="jp">添加</em>操作不会出现这种情况，例如，如果ow与任何已记录的所有者都不对应，添加操作就会失败。</p><p id="3214" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这些安全谓词产生证明义务，如下面的验证部分所示。可用安全谓词的列表可以在这里找到<a class="ae jo" href="https://docs.archetype-lang.org/archetype-language/contract-specification#security-predicates" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="69bb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，我们要确保<em class="jp">消费</em>动作的实现符合删除数量英里的基本要求。制定这种要求的方式是在执行动作之前的存储状态与执行动作之后的存储状态之间建立算术关系:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mt kp l"/></div></figure><p id="25d7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">后置条件<em class="jp"> p1 </em>(上面第5行)字面意思是“在<em class="jp">消耗</em>的执行之后的数量字段<em class="jp">的总和等于</em>执行之前的<em class="jp">的总和减去<em class="jp">数量</em>的值”。</em></p><p id="2288" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">简要回顾一下，以下是验证前的完整合同代码:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mt kp l"/></div></figure><h1 id="4478" class="kq kr ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">核实</h1><p id="90f9" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">在本节中，我们将验证前一节中定义的4个谓词:</p><ul class=""><li id="be46" class="mu mv ht is b it iu ix iy jb mw jf mx jj my jn mz na nb nc dt translated">s0:任何动作只能由<em class="jp">管理员</em>角色调用</li><li id="a6b4" class="mu mv ht is b it nd ix ne jb nf jf ng jj nh jn mz na nb nc dt translated">s1:当访问存储器时，<em class="jp">添加</em>动作不会失败</li><li id="481e" class="mu mv ht is b it nd ix ne jb nf jf ng jj nh jn mz na nb nc dt translated">P0:<em class="jp">消耗</em>动作正好消耗<em class="jp">数量</em>英里</li><li id="b6c9" class="mu mv ht is b it nd ix ne jb nf jf ng jj nh jn mz na nb nc dt translated">i0:任何一英里的量值都是严格正的</li></ul><p id="2848" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">VS代码原型扩展提供了一个左侧面板，其中列出了谓词，并允许在每个要验证的谓词上调用<a class="ae jo" href="http://why3.lri.fr/" rel="noopener ugc nofollow" target="_blank"> why3 </a> ide:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff ni"><img src="../Images/4d2fb6a4c0b1b05523ca7c910831d422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ubX9uUSk1TtilHBJXelgTQ.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Archetype contract in VS Code</figcaption></figure><p id="3fff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">契约和谓词被转换成why3格式(whyml)。为了调用why3 ide，单击原型扩展面板中谓词右侧的检查图标。</p><p id="8d8f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了验证why3的属性，只需右键单击名为“Miles_with_expiration”的模块，并选择“Auto level 2”，如下所示(此处为安全谓词<em class="jp"> s0 </em>):</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff nj"><img src="../Images/23b6efd5ac11d24bdf5ccda91cce6473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cpZjj2qxopKJjQ4vRWufkg.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Why3 ide for security predicate s0</figcaption></figure><p id="6775" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Why3翻译<a class="ae jo" href="http://smtlib.cs.uiowa.edu/" rel="noopener ugc nofollow" target="_blank"> SMT语言</a>中的谓词，并调用SMT解算器(这里是Alter-Ergo、Z3和CVC4)。我们在上面的截图中看到，Why3已经为两个动作(添加和消费)生成了证明义务。</p><h2 id="ddfa" class="lt kr ht bd ks lu lv lw kw lx ly lz la jb ma mb le jf mc md li jj me mf lm mg dt translated">安全谓词s0</h2><p id="ade5" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">当谓词被验证时，问号变成绿色。<em class="jp">消耗</em>动作<em class="jp">不</em>变绿如下图:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff nk"><img src="../Images/8ce162a8121c533e5fbdf2dfaddf22e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdelmjS2xqMzY-JSdnW0-w.png"/></div></div></figure><p id="901a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是因为修饰符<strong class="is hu">调用的<em class="jp">在<em class="jp">消耗</em>动作中缺少</em></strong>。添加后，将验证s0属性:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff nl"><img src="../Images/b67f5c4232fec9c3d88908246b29abef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*afrRHilXZlHFD0tRpo1Inw.png"/></div></div></figure><h2 id="3574" class="lt kr ht bd ks lu lv lw kw lx ly lz la jb ma mb le jf mc md li jj me mf lm mg dt translated">安全谓词s1</h2><p id="ec25" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">上面的契约也没有验证<em class="jp"> no_storage_fail </em>谓词<em class="jp"> s1 </em>。当详细查看失败的证明义务时，我们看到可能会出现“找不到密钥”和“密钥存在”例外情况:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff nl"><img src="../Images/b017081e286c6a157f6822b9bc7114eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PIHS5e3WRAiNijLDsJSreA.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">A failing proof obligation for s1: the “get” method may generate a NotFound exception</figcaption></figure><p id="1a4a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们看到get方法可能会生成一个<em class="jp"> NotFound </em>异常(见上面的截图),而<em class="jp"> add </em>方法可能会生成一个<em class="jp"> KeyExist </em>异常。</p><p id="87cf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">解决方案是首先测试id为<em class="jp"> ow </em>的所有者是否存在。如果不存在，应创建一个新的所有者<strong class="is hu"/>。在任何情况下，如果<em class="jp"> newmile </em>的id已经存在，则<em class="jp"> add </em>应该会失败:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mt kp l"/></div></figure><p id="9644" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们看到了不允许代码失败的影响:它迫使我们处理所有情况，并使行为明确。在这里，我们只是忘记了在必要时创建一个所有者！s1现已通过验证:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff nm"><img src="../Images/ed5c3be9083078de386fd993195925ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nKKa6ELbvHPZgUjJN8udRg.png"/></div></div></figure><h2 id="db75" class="lt kr ht bd ks lu lv lw kw lx ly lz la jb ma mb le jf mc md li jj me mf lm mg dt translated">后置条件p0</h2><p id="58fa" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated"><em class="jp">消耗</em>动作的效果使用所有者<em class="jp"> ow </em>的有效里程的迭代。然后需要为why3提供p0的<strong class="is hu">循环不变量</strong>(why 3依赖于<a class="ae jo" href="https://en.wikipedia.org/wiki/Predicate_transformer_semantics" rel="noopener ugc nofollow" target="_blank"> <em class="jp">最弱的前提条件</em> </a>演算)。</p><p id="0d72" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是验证过程中最棘手的部分，因为它需要一些计算不变量的经验。</p><p id="8d3b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<em class="jp"> p0 </em>的情况下，不变量应该使用<em class="jp">余数</em>变量，该变量在迭代期间从<em class="jp">数量</em>减少到<em class="jp"> 0 </em>。在任何迭代中，我们都有这样的关系:</p><pre class="kj kk kl km fq nn no np nq aw nr dt"><span id="014a" class="lt kr ht no b fv ns nt l nu nv">mile.sum(the.quantity) = <br/>mile.before.sum(the.quantity) - qty + remainder</span></pre><p id="3d46" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">迭代结束时，<em class="jp">余数</em>变量等于0，重写为<em class="jp"> p0 </em>。</p><p id="0bdd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，why3仍然无法证明<em class="jp"> p0 </em>，因为要证明<em class="jp">余数</em>变量在迭代结束时等于0并不容易。为此，可以提供另一个不变量:</p><pre class="kj kk kl km fq nn no np nq aw nr dt"><span id="fd9b" class="lt kr ht no b fv ns nt l nu nv">0 &lt;= remainder &lt;= toiterate.sum(the.quantity)</span></pre><p id="56fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp"> toiterate </em>关键字指的是尚未迭代且仍将迭代的里程集合。在迭代结束时，<em class="jp"> toiterate </em>集合为空，其总和等于<em class="jp"> 0 </em>。</p><p id="4643" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面的原型片段说明了如何提供这些不变量(下面的第5–8行):</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mt kp l"/></div></figure><p id="df87" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">注意，我们必须命名迭代(上面的<em class="jp">循环</em>第7行)。</p><p id="a4fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">上面的代码验证了p0。然而，两个证明义务仍然失败。</p><p id="fb6f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">第一个对应于第二个循环不变量的初始化(上面的第15行):</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff nw"><img src="../Images/3cf1c106366e1b7e7a5bdb18890c2d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sz3TRdIk2tZPHKQcMfZJYg.png"/></div></div></figure><p id="7c85" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它无法证明余数变量在迭代开始时大于或等于0。由于在此阶段等于<em class="jp">数量</em>，解决方案包括添加一个<em class="jp">保护条件</em>，该条件要求<em class="jp">数量</em>大于或等于0。</p><p id="b394" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当当前英里<em class="jp">数量</em>大于<em class="jp">余数</em>变量时，第二失败证明义务对应于第二执行分支(上面的第23、24行)中主循环不变量<em class="jp">遗传性</em>的证明:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff nw"><img src="../Images/da1b966bf0f5e84f28743255cf24ca53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HlUMkdCpbpBP_agsEHT22g.png"/></div></div></figure><p id="5c65" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Why3突出显示了当前证明义务中不为真的分支条件(在上面截图中的紫色行317中)，这精确地指出了哪个执行分支有问题。</p><p id="8f79" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">问题是在更新当前英里数量字段之前，余数变量被设置为0 <em class="jp">。解决方案是交换指令行23和24。</em></p><p id="40de" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">消耗</em>动作的固定版本如下:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mt kp l"/></div></figure><h2 id="d8b9" class="lt kr ht bd ks lu lv lw kw lx ly lz la jb ma mb le jf mc md li jj me mf lm mg dt translated">不变量i0</h2><p id="acf5" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">每次修改英里集合时，都必须验证不变量i0。这里不变量没有被验证，无论是在动作<em class="jp">中添加</em>还是<em class="jp">消耗</em>。</p><p id="55f8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<em class="jp">添加</em>动作中，<em class="jp">添加</em>方法(上面的第8行)要求添加的英里(<em class="jp">新英里</em>)有一个<em class="jp">数量</em>字段严格为正:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff ni"><img src="../Images/ea9b1b84c5153fda745f4bc7f85e9312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mv6f_ASXEhlduF-Ox--Mlw.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">add method of owner’s mile collection requires a quantity field &gt; 0</figcaption></figure><p id="33c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">解决方案是添加一个保护条件(下面的第3–5行):</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mt kp l"/></div></figure><p id="0453" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<em class="jp">消耗</em>动作中，<em class="jp">更新</em>方法要求里程数量为正，如资产不变量所指定的，但是求解器无法证明这一点:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff nx"><img src="../Images/ff9338814877e51075e3bb6c57d41210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctY7cGIeCjBmgKejW-s6NQ.png"/></div></div></figure><p id="a59c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该分支是测试的<em class="jp"> else </em>分支</p><pre class="kj kk kl km fq nn no np nq aw nr dt"><span id="4883" class="lt kr ht no b fv ns nt l nu nv">m.quantity &lt; remainder</span></pre><p id="0eb1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">哪个是</p><pre class="kj kk kl km fq nn no np nq aw nr dt"><span id="1a29" class="lt kr ht no b fv ns nt l nu nv">m.quantity &gt;= remainder</span></pre><p id="adea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">事实上，当<em class="jp">数量</em>等于<em class="jp">余数</em>变量时，它记录一英里，其中<em class="jp">数量</em>值等于0，这与<em class="jp"> i0 </em>不符。</p><p id="1468" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">解决方案是将分支测试改为</p><pre class="kj kk kl km fq nn no np nq aw nr dt"><span id="b057" class="lt kr ht no b fv ns nt l nu nv">m.quantity &lt;= remainder</span></pre><h1 id="9bad" class="kq kr ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">结论</h1><p id="371a" class="pw-post-body-paragraph iq ir ht is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">由于原型的正式验证功能，我们已经能够开发一个<em class="jp">正确的</em>智能合同，实现链上忠诚度计划:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mt kp l"/></div></figure><p id="c895" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在可以安全地将原型契约代码转换为Ligo之类的低级语言，这样就可以生成迈克尔逊版本:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff ny"><img src="../Images/fcfbca442638974cf8159f57e8d3241d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMYxV3DaBiXIrp-r-spLEw.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Archetype generation commands</figcaption></figure><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff ny"><img src="../Images/09348c1fceb32dd811be2585fc54ba9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJmnROaL_gGJPyor_Xbp6A.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Ligo version of the contract</figcaption></figure><p id="81b3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">程序验证是发现和修复问题的一种非常强大的技术。这也是提高用户对合同的信任的一个非常好的方法，特别是当经过验证的属性易于阅读和理解的时候。</p><p id="d5c1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，我们注意到，安全性不是一个绝对的质量，而是相对于我们能够识别和制定的属性。</p><p id="2985" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以下是演示中使用的软件列表，供您重现:</p><ul class=""><li id="5d6b" class="mu mv ht is b it iu ix iy jb mw jf mx jj my jn mz na nb nc dt translated">原型0.1.10</li><li id="ebab" class="mu mv ht is b it nd ix ne jb nf jf ng jj nh jn mz na nb nc dt translated">VS代码1.39.2</li><li id="47e8" class="mu mv ht is b it nd ix ne jb nf jf ng jj nh jn mz na nb nc dt translated">为什么3 1.2.0</li><li id="db00" class="mu mv ht is b it nd ix ne jb nf jf ng jj nh jn mz na nb nc dt translated">替代疗法2.2.0</li><li id="0e24" class="mu mv ht is b it nd ix ne jb nf jf ng jj nh jn mz na nb nc dt translated">CVC4 1.6</li><li id="1f3b" class="mu mv ht is b it nd ix ne jb nf jf ng jj nh jn mz na nb nc dt translated">Z3 4.8.4</li></ul><p id="a02a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意，原型仍然在<em class="jp"> alpha </em>版本中。我们计划在年底发布版本1。</p><p id="c151" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在Twitter上关注我们，了解项目的最新进展:</p><div class="jq jr fm fo js jt"><a href="https://twitter.com/archetype_lang" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab ej"><div class="jv ab jw cl cj jx"><h2 class="bd hu fv z el jy eo ep jz er et hs dt translated">原型</h2><div class="ka l"><h3 class="bd b fv z el jy eo ep jz er et ek translated">来自基模(@ archetype _ lang)的最新推文。原型是一种特定于领域的语言，用于开发智能契约…</h3></div><div class="kb l"><p class="bd b gc z el jy eo ep jz er et ek translated">twitter.com</p></div></div><div class="kc l"><div class="nz l ke kf kg kc kh ki jt"/></div></div></a></div><figure class="kj kk kl km fq kn fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff oa"><img src="../Images/673b3528e0b341cca62769c9baa632cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bcTJUjFtXf1QtlWzlS04XQ.jpeg"/></div></a></figure><blockquote class="ob"><p id="5cc5" class="oc od ht bd oe of og oh oi oj ok jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="om on oo op oq kn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ol"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>