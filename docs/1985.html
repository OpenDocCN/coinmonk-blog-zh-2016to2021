<html>
<head>
<title>Scala hyperledger fabric client with akka actors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有akka actors的Scala hyperledger结构客户端</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/scala-hyperledger-fabric-client-bce18b6ca0bf?source=collection_archive---------2-----------------------#2019-01-17">https://medium.com/coinmonks/scala-hyperledger-fabric-client-bce18b6ca0bf?source=collection_archive---------2-----------------------#2019-01-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="f07f" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">Akka + Hlf -天作之合</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/65a8e4446cf71afc45990530ff66d82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyRw5kVd8HO6Y3kqRovegw.png"/></div></div></figure><h1 id="e615" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">快乐分类器:)</h1><p id="f143" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">这是我的hyperledger fabric博客系列的第二部分- <code class="eh li lj lk ll b">Happyledger</code>博客系列:)。在这篇文章中，我将讲述如何编写基于<code class="eh li lj lk ll b">scala</code>的hyperldger fabric客户端应用程序。大多数hyperledger fabric客户端应用程序都使用<code class="eh li lj lk ll b">node sdk</code>来编写。用基于jvm的语言尝试一下也是值得的。所以我编写了基于<code class="eh li lj lk ll b">scala</code>的客户端来与光纤网络交互。我的应用程序的完整源代码可从gitlab资源库获得，在<a class="ae lm" href="https://gitlab.com/rahasak-labs/hlf-peez" rel="noopener ugc nofollow" target="_blank">这里</a>。请克隆它并按照下面的步骤操作。</p><h1 id="18b0" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">1.启动结构网络</h1><p id="993e" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">在我之前的<a class="ae lm" rel="noopener" href="/@itseranga/hyperledger-fabric-setup-with-multiple-peers-and-orderers-with-kafka-542023787a6d">帖子</a>中，我展示了如何用多个订购者和kafka建立hyperledger fabric网络。在这篇文章中，我将用它来建立网络。如果你按照前面的帖子，并在网络上，你将结束以下运行的服务</p><ol class=""><li id="a7fc" class="ln lo ht ko b kp lp ks lq kv lr kz ls ld lt lh lu lv lw lx dt translated">一个<code class="eh li lj lk ll b">ca</code>集装箱</li><li id="ba76" class="ln lo ht ko b kp ly ks lz kv ma kz mb ld mc lh lu lv lw lx dt translated">三个<code class="eh li lj lk ll b">orderer</code>容器</li><li id="929c" class="ln lo ht ko b kp ly ks lz kv ma kz mb ld mc lh lu lv lw lx dt translated">三个<code class="eh li lj lk ll b">peer</code>容器</li><li id="348f" class="ln lo ht ko b kp ly ks lz kv ma kz mb ld mc lh lu lv lw lx dt translated">三个<code class="eh li lj lk ll b">zookeeper</code>容器</li><li id="bbab" class="ln lo ht ko b kp ly ks lz kv ma kz mb ld mc lh lu lv lw lx dt translated">四个<code class="eh li lj lk ll b">kafka</code>容器</li><li id="1d9a" class="ln lo ht ko b kp ly ks lz kv ma kz mb ld mc lh lu lv lw lx dt translated">一个<code class="eh li lj lk ll b">cli</code>容器</li></ol><h1 id="02eb" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">2.添加结构依赖性</h1><p id="85a3" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">为了让scala客户端与hlf网络<code class="eh li lj lk ll b">build.sbt</code>进行交互，需要拥有<code class="eh li lj lk ll b">hyperledger-fabric-java-sdk</code>依赖关系。下面是<code class="eh li lj lk ll b">build.sbt</code>文件依赖关系(它还有一些其他的依赖关系)。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="md me l"/></div></figure><h1 id="3a7c" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">3.实施结构用户</h1><p id="0bfd" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">为了与hlf网络交互，我们的客户需要有fabric用户(<code class="eh li lj lk ll b">admin</code>和<code class="eh li lj lk ll b">normal</code>用户)。所以在我们的应用程序中，我们需要定义一个实现<code class="eh li lj lk ll b">org.hyperledger.fabric.sdk.User</code>接口的用户。所以我创建了一个带有<code class="eh li lj lk ll b">case class</code>的<code class="eh li lj lk ll b">PeezUser</code>。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="md me l"/></div></figure><p id="147b" class="pw-post-body-paragraph km kn ht ko b kp lp iu kr ks lq ix ku kv mf kx ky kz mg lb lc ld mh lf lg lh hm dt translated">现在我们可以创建这个用户的实例，并与hlf网络对等体进行交互。</p><h1 id="5ff2" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">4.创建CA客户端</h1><p id="4cc2" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">hlf网络中的所有用户都需要有自己的证书材料。因为我们已经运行了<code class="eh li lj lk ll b">ca</code>服务，我们可以用它来为我们的用户生成加密材料。这就是拥有ca服务的优势。所有的用户密码资料都可以通过与ca服务通信来生成。</p><p id="c022" class="pw-post-body-paragraph km kn ht ko b kp lp iu kr ks lq ix ku kv mf kx ky kz mg lb lc ld mh lf lg lh hm dt translated">为了与ca服务交互，我们需要一个ca客户端。Fabric <code class="eh li lj lk ll b">java-sdk</code>提供了<code class="eh li lj lk ll b">HFCAClient</code>，我们可以使用它在scala应用程序中实例化一个ca客户端。这个函数将<code class="eh li lj lk ll b"> ca service uri</code>作为一个参数。在我们的例子中，我们在本地机器的<code class="eh li lj lk ll b">7054</code>端口上运行ca服务。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="md me l"/></div></figure><h1 id="dfe2" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">5.注册用户</h1><p id="8ecd" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">现在我们的ca客户端已经创建好了，所以我们可以通过生成加密材料来将用户注册到网络中。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="md me l"/></div></figure><p id="012e" class="pw-post-body-paragraph km kn ht ko b kp lp iu kr ks lq ix ku kv mf kx ky kz mg lb lc ld mh lf lg lh hm dt translated">hlf中有两类用户，<code class="eh li lj lk ll b">admin</code>和<code class="eh li lj lk ll b">normal user</code>。在这里，我有两个函数来注册不同的用户类型。<code class="eh li lj lk ll b">enrollAdmin</code>登记管理员用户。注册管理员用户时，it用户管理员用户凭证在docker-compose <code class="eh li lj lk ll b">ca service command</code>部分中定义。函数<code class="eh li lj lk ll b">enrollUser</code>注册普通用户(注意，要注册普通用户，我们需要管理员用户)。</p><p id="6cbb" class="pw-post-body-paragraph km kn ht ko b kp lp iu kr ks lq ix ku kv mf kx ky kz mg lb lc ld mh lf lg lh hm dt translated">注册用户时，ca客户端返回包含用户私钥和证书的<code class="eh li lj lk ll b">enrollment object</code>。在这里，我使用java对象序列化将注册对象保存在本地文件系统中。因此，当注册用户时，它首先检查给定用户是否已经通过<code class="eh li lj lk ll b">UserStore.get(userId)</code>功能注册。如果用户已经注册，我们采用注册用户(<code class="eh li lj lk ll b">UserStore</code>管理从文件系统保存和加载用户)。</p><h1 id="132a" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">6.创建结构客户端</h1><p id="9a92" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">接下来是创建<code class="eh li lj lk ll b">HFClient</code>中的hyperledger fabric客户端。该客户端通过hlf网络执行所有的事务处理、频道发现等。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="md me l"/></div></figure><h1 id="074d" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">7.连接到频道</h1><p id="0825" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">现在，我们可以使用之前创建的客户端连接到通道。当连接到通道时，我们需要定义<code class="eh li lj lk ll b">peer</code>、<code class="eh li lj lk ll b">orderer</code>和<code class="eh li lj lk ll b">channel name</code>。hlf中的所有对等点和订单都公开了<code class="eh li lj lk ll b">GRPC</code>端点(对等点和订单都有自己的GRPC端点可以对话)。我们需要如下定义对等点和订购点的GRPC端点，并连接到通道。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="md me l"/></div></figure><h1 id="0eae" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">8.执行查询事务</h1><p id="7a05" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">有两种类型的交易可以在结构链代码中执行，<code class="eh li lj lk ll b">query</code>和<code class="eh li lj lk ll b">invoke</code>。以下是在安装在我们光纤网络上的<code class="eh li lj lk ll b">mycc</code>链码上执行<code class="eh li lj lk ll b">query</code>交易的功能。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="md me l"/></div></figure><p id="3520" class="pw-post-body-paragraph km kn ht ko b kp lp iu kr ks lq ix ku kv mf kx ky kz mg lb lc ld mh lf lg lh hm dt translated">有一个builder自带<code class="eh li lj lk ll b">ChaincodeID</code>。我们可以用这个生成器设置<code class="eh li lj lk ll b">chaincode name</code>、<code class="eh li lj lk ll b">function</code>和<code class="eh li lj lk ll b">arguments</code>并执行查询。</p><h1 id="8338" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">9.执行调用事务</h1><p id="2be3" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">以下是在安装在我们光纤网络上的<code class="eh li lj lk ll b">mycc</code>链码上执行<code class="eh li lj lk ll b">invoke</code>交易的功能。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="md me l"/></div></figure><p id="98fe" class="pw-post-body-paragraph km kn ht ko b kp lp iu kr ks lq ix ku kv mf kx ky kz mg lb lc ld mh lf lg lh hm dt translated">在这里，我们需要首先向网络发送<code class="eh li lj lk ll b">TransactionProposal</code>。然后它将返回<code class="eh li lj lk ll b">ProposalResponse</code>列表。如果所有的响应都是正确的，我们可以用<code class="eh li lj lk ll b">sendTransaction</code>将交易发送到网络。</p><p id="4df1" class="pw-post-body-paragraph km kn ht ko b kp lp iu kr ks lq ix ku kv mf kx ky kz mg lb lc ld mh lf lg lh hm dt translated"><code class="eh li lj lk ll b">sendTransaction</code>函数返回带有<code class="eh li lj lk ll b">TransactionEvent</code>的<code class="eh li lj lk ll b">CompletableFuture</code>。我们可以处理未来并获得<code class="eh li lj lk ll b">TransactionEvent</code>来决定交易是否成功(交易是否包含在一个块中)。</p><h1 id="f41b" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">9.阿卡演员交流</h1><p id="2259" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">最后，我创建了<code class="eh li lj lk ll b">akka actor</code>来与上面定义的函数交互。它消耗<code class="eh li lj lk ll b">Init</code>和<code class="eh li lj lk ll b">Exec</code>消息。当<code class="eh li lj lk ll b">Init</code>消息到来时，演员设置<code class="eh li lj lk ll b">ca client</code>、<code class="eh li lj lk ll b">hlf client</code>和<code class="eh li lj lk ll b">channel</code>。当<code class="eh li lj lk ll b">ExecQuery</code>消息到来时，它执行对总账的查询交易。对于<code class="eh li lj lk ll b">ExecInvoke</code>消息，它执行对分类帐的调用事务。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="md me l"/></div></figure><h1 id="b73e" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">参考</h1><ol class=""><li id="a66e" class="ln lo ht ko b kp kq ks kt kv mi kz mj ld mk lh lu lv lw lx dt translated"><a class="ae lm" rel="noopener" href="/@itseranga/hyperledger-fabric-setup-with-multiple-peers-and-orderers-with-kafka-542023787a6d">https://medium . com/@ itseranga/hyperledger-fabric-setup-with-multiple-peers-and-orders-with-Kafka-542023787 a6d</a></li><li id="d701" class="ln lo ht ko b kp ly ks lz kv ma kz mb ld mc lh lu lv lw lx dt translated"><a class="ae lm" rel="noopener" href="/@lkolisko/hyperledger-fabric-sdk-java-basics-tutorial-a67b2b898410">https://medium . com/@ lkolisko/hyperledger-fabric-SDK-Java-basics-tutorial-a 67 B2 b 898410</a></li><li id="e8fa" class="ln lo ht ko b kp ly ks lz kv ma kz mb ld mc lh lu lv lw lx dt translated"><a class="ae lm" href="https://codeburst.io/a-concise-tutorial-on-working-with-hyperledger-fabric-java-sdk-a6f11d8bb5b0" rel="noopener" target="_blank">https://code burst . io/a-concise-tutorial-on-working-with-hyperledger-fabric-Java-SDK-a6 F11 d 8 bb 5b 0</a></li></ol><blockquote class="ml"><p id="ab9d" class="mm mn ht bd mo mp mq mr ms mt mu lh ek translated"><a class="ae lm" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mw mx my mz na jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mv"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>