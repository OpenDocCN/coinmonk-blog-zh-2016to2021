<html>
<head>
<title>How to Get the Execution Time of a Script</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何获取脚本的执行时间</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/kernel-space-vs-user-space-how-to-get-the-execution-time-of-a-script-11c56290d8f4?source=collection_archive---------3-----------------------#2018-07-11">https://medium.com/coinmonks/kernel-space-vs-user-space-how-to-get-the-execution-time-of-a-script-11c56290d8f4?source=collection_archive---------3-----------------------#2018-07-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><blockquote class="iq ir is"><p id="2959" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated"><strong class="iw hu">内核空间与用户空间</strong></p></blockquote><figure class="jt ju jv jw fq jx fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff js"><img src="../Images/2ec53c86de9b1e8176bb756b18a2bc59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRpSfh6-hsx4m4SipX2DJQ.jpeg"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek"><strong class="bd ki">CS Architecture</strong></figcaption></figure><p id="a915" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">几周前，我用Raspberry Pi 3 model B和shell脚本为一个<a class="ae km" rel="noopener" href="/coinmonks/raspberry-pi-3-model-b-shell-scripting-door-monitor-b44944f82d87">门监控器做了一个有趣的项目。我最近在Pi上连接了一个摄像头，并更新了脚本，以便在门打开时拍摄一张照片，并作为电子邮件通知的附件发送出去。</a></p><p id="5938" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">我遇到的一个问题是脚本的执行时间从最初的几秒钟增加到了17.58秒。我能够识别并隔离脚本中每一行的执行时间。我开始意识到<a class="ae km" href="https://www.raspberrypi.org/documentation/usage/camera/raspicam/raspistill.md" rel="noopener ugc nofollow" target="_blank"><strong class="iw hu"><em class="iv">raspi still</em></strong></a>命令用了5。87秒后执行。这导致完全无法捕捉开门的人的照片。</p><blockquote class="iq ir is"><p id="56fa" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated"><strong class="iw hu">如何减少raspistill的执行时间</strong></p></blockquote><p id="0f26" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">终端上的一个简单的<em class="iv"> raspistill </em>后跟“<em class="iv"> — help </em>”标签提供了有关图像参数命令的更多信息:</p><pre class="jt ju jv jw fq kn ko kp kq aw kr dt"><span id="9119" class="ks kt ht ko b fv ku kv l kw kx">pi@raspberrypi:~ $ raspistill --help </span><span id="398f" class="ks kt ht ko b fv ky kv l kw kx">Runs camera for specific time, and take JPG capture at end if requested  </span><span id="0dd8" class="ks kt ht ko b fv ky kv l kw kx">usage: raspistill [options]  <br/>Image parameter commands <br/>... </span><span id="311f" class="ks kt ht ko b fv ky kv l kw kx">-t, --timeout : Time (in ms) before takes picture and shuts down (if not specified, set to 5s)</span></pre><p id="1ee4" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">通过在脚本上指定图片拍摄前的时间，我能够将<em class="iv"> raspistill </em>的执行时间减少到几毫秒，如下所示:</p><figure class="jt ju jv jw fq jx"><div class="bz el l di"><div class="kz la l"/></div></figure></div><div class="ab cl lb lc hb ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hm hn ho hp hq"><h1 id="d402" class="li kt ht bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me dt translated">如何有效地获取脚本的执行时间</h1><p id="504e" class="pw-post-body-paragraph it iu ht iw b ix mf iz ja jb mg jd je kj mh jh ji kk mi jl jm kl mj jp jq jr hm dt translated">在这个过程中，我学习了<code class="eh mk ml mm ko b">time</code>命令，它用于获取另一个命令或脚本执行所需的时间:</p><pre class="jt ju jv jw fq kn ko kp kq aw kr dt"><span id="db40" class="ks kt ht ko b fv ku kv l kw kx">time yourscript.sh   // get execution for a script</span><span id="edf9" class="ks kt ht ko b fv ky kv l kw kx">time ls              // get execution time of ls command</span></pre><p id="7274" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">其给出了以下结果:</p><figure class="jt ju jv jw fq jx fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff mn"><img src="../Images/5609d9d45eeb04c674a7ec9026b32f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zWAlacPcLVloaCSGHqJ_w.jpeg"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">Terminal screenshot of “time ls” command</figcaption></figure><p id="fd01" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">现在，您可以注意到time命令提供了一个真实的用户和系统时间。理解用户空间和内核空间很重要。这些东西中的一个和另一个不一样。Real是指实际经过的时间；用户和系统仅指进程使用的CPU时间<em class="iv">。</em></p><blockquote class="iq ir is"><p id="98da" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated"><strong class="iw hu">真实、用户和系统处理时间统计</strong></p></blockquote><ul class=""><li id="0bff" class="mo mp ht iw b ix iy jb jc kj mq kk mr kl ms jr mt mu mv mw dt translated"><strong class="iw hu"> Real </strong>是挂钟时间——从通话开始到结束的时间。这是所有经过的时间，包括其他进程使用的时间片和进程被阻塞的时间(例如，如果它正在等待I/O完成)。</li><li id="3b79" class="mo mp ht iw b ix mx jb my kj mz kk na kl nb jr mt mu mv mw dt translated"><strong class="iw hu"> User </strong>是花费在进程内<strong class="iw hu"> <em class="iv">用户态</em> </strong>代码(内核外)<em class="iv">的CPU时间量。这只是执行进程所用的实际CPU时间。其他进程和进程被阻塞的时间不计入该数字。</em></li><li id="1abe" class="mo mp ht iw b ix mx jb my kj mz kk na kl nb jr mt mu mv mw dt translated"><strong class="iw hu"> Sys </strong>是在内核进程中花费的CPU时间。这意味着在内核中执行花费在系统调用<em class="iv">上的CPU时间，</em>与库代码相反，库代码仍然运行在用户空间中。像“用户”一样，这只是进程使用的CPU时间。下面简单介绍一下<strong class="iw hu"> <em class="iv">内核模式</em> </strong>(也称为‘supervisor’模式)和系统调用机制。</li></ul><p id="918a" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">会告诉你你的进程实际使用了多少CPU时间。请注意，这是跨所有CPU的，因此如果该进程有多个线程(并且该进程运行在具有多个处理器的计算机上)，它可能会超过<code class="eh mk ml mm ko b">Real</code>报告的挂钟时间(这通常会发生)。注意，在输出中，这些数字包括所有子进程(及其后代)的<code class="eh mk ml mm ko b">User</code>和<code class="eh mk ml mm ko b">Sys</code>时间，以及它们可能被收集的时间，例如被<code class="eh mk ml mm ko b">wait(2)</code>或<code class="eh mk ml mm ko b">waitpid(2)</code>收集的时间，尽管底层系统调用分别返回进程及其子进程的统计数据。</p><blockquote class="iq ir is"><p id="e9bf" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated"><strong class="iw hu"/>上报的统计数据来源<code class="eh mk ml mm ko b"><strong class="iw hu">time (1)</strong></code></p></blockquote><p id="0685" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated"><code class="eh mk ml mm ko b">time</code>报告的统计数据是从各种系统调用中收集的。<strong class="iw hu">用户</strong>和<strong class="iw hu">系统</strong>来自<code class="eh mk ml mm ko b"><a class="ae km" href="http://docs.oracle.com/cd/E23823_01/html/816-5168/wait-3c.html#scrolltoc" rel="noopener ugc nofollow" target="_blank">wait (2)</a></code>或<code class="eh mk ml mm ko b"><a class="ae km" href="http://linux.die.net/man/2/times" rel="noopener ugc nofollow" target="_blank">times (2)</a></code>，视具体系统而定。<strong class="iw hu">实际</strong>是根据从<code class="eh mk ml mm ko b"><a class="ae km" href="http://dell5.ma.utexas.edu/cgi-bin/man-cgi?gettimeofday+2" rel="noopener ugc nofollow" target="_blank">gettimeofday (2)</a></code>调用中收集的开始和结束时间计算的。根据系统的版本，<code class="eh mk ml mm ko b">time</code>还可以收集各种其他统计数据，例如上下文切换的次数。</p><p id="25af" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">在多处理器机器上，多线程进程或派生子进程的进程的运行时间可能小于总CPU时间，因为不同的线程或进程可能并行运行。此外，报告的时间统计数据来自不同的来源，因此为非常短的跑步任务记录的时间可能会出现舍入误差，如原始发帖者给出的示例所示。</p><h1 id="1f5b" class="li kt ht bd lj lk nc lm ln lo nd lq lr ls ne lu lv lw nf ly lz ma ng mc md me dt translated"><strong class="ak">内核与用户模式的简要介绍</strong></h1><p id="3966" class="pw-post-body-paragraph it iu ht iw b ix mf iz ja jb mg jd je kj mh jh ji kk mi jl jm kl mj jp jq jr hm dt translated">在Unix或任何受保护的内存操作系统上，“内核”或“管理程序”模式指的是CPU可以运行的特权模式。某些可能影响安全性或稳定性的特权操作只能在CPU以这种模式运行时进行。这些操作对应用程序代码不可用。</p><figure class="jt ju jv jw fq jx fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff nh"><img src="../Images/3efc3c026fd4287d4446942e57272e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoblOn9bJ-1TBLWV67uCzg.png"/></div></div></figure><p id="7965" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">这种动作的一个例子可能是操纵<a class="ae km" href="http://en.wikipedia.org/wiki/Memory_management_unit" rel="noopener ugc nofollow" target="_blank"> MMU </a>来获得对另一个进程的地址空间的访问。通常情况下，<a class="ae km" href="http://en.wikipedia.org/wiki/User_space" rel="noopener ugc nofollow" target="_blank">用户模式</a>代码不能做到这一点(有充分的理由)，尽管它可以从内核请求<a class="ae km" href="http://en.wikipedia.org/wiki/Shared_memory" rel="noopener ugc nofollow" target="_blank">共享内存</a>，其中的<em class="iv">可以被多个进程读取或写入。在这种情况下，共享内存是通过安全机制从内核显式请求的，为了使用它，两个进程都必须显式连接到共享内存。</em></p><figure class="jt ju jv jw fq jx fe ff paragraph-image"><div class="fe ff ni"><img src="../Images/6a02cd2cdff437377f86e3f070965d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*LSFiNK_qcor5MQ1ii4xjrA.png"/></div></figure><p id="3e5e" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">特权模式通常被称为'<strong class="iw hu">内核</strong>模式，因为内核是由运行在这种模式下的CPU执行的。为了切换到内核模式，您必须发出一个特定的指令(通常称为<a class="ae km" href="http://en.wikipedia.org/wiki/Trap_(computing)" rel="noopener ugc nofollow" target="_blank"> <em class="iv"> trap </em> </a>)，该指令将CPU切换到内核模式<em class="iv">运行，并从跳转表中保存的特定位置运行代码。</em></p><p id="b58e" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">出于安全原因，您不能切换到内核模式并执行任意代码——陷阱是通过一个地址表来管理的，除非CPU运行在管理模式下，否则不能写入该地址表。你用一个明确的陷阱号进行陷阱，地址在跳转表中查找；内核有有限数量的受控入口点。</p><p id="5deb" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">C库中的'<strong class="iw hu">系统</strong>'调用(尤其是手册页第2节中描述的那些)有一个用户模式组件，这是您实际上从C程序中调用的组件。在幕后，他们可能会向内核发出一个或多个系统调用来执行特定的服务，比如I/O，但他们仍然有代码在<em class="iv">用户模式</em>下运行。</p><p id="dab5" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">如果需要，也可以从任何<strong class="iw hu"><em class="iv"/></strong>用户空间代码直接向<strong class="iw hu"> <em class="iv">内核模式</em> </strong>发出陷阱，尽管您可能需要编写一段汇编语言来为调用正确设置寄存器。这里有一页描述了Linux内核提供的系统调用和设置寄存器的约定。</p><blockquote class="iq ir is"><p id="ffa1" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated"><strong class="iw hu">关于“系统”的更多信息</strong></p></blockquote><p id="bbcc" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">有些事情你的代码不能在用户模式下完成——比如分配内存或访问硬件(硬盘、网络等)。).这些都在内核的监管下，只有它能做到。你做的一些操作(如<code class="eh mk ml mm ko b">malloc</code>或<code class="eh mk ml mm ko b">fread</code> / <code class="eh mk ml mm ko b">fwrite</code>)会调用这些内核函数，这将算作“系统”时间。可惜并不是“<em class="iv">每次调用malloc都会计入'</em><strong class="iw hu"><em class="iv">sys</em></strong><em class="iv">' time</em>”这么简单。</p><blockquote class="iq ir is"><p id="c693" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">在C语言中，库函数<strong class="iw hu"> malloc </strong>用于在堆上分配一块内存。程序通过一个指针访问这个内存块，这个指针由malloc返回。当不再需要内存时，指针被传递给free，free释放内存，这样它<strong class="iw hu">可以</strong>用于其他目的。</p></blockquote><p id="d752" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je kj jg jh ji kk jk jl jm kl jo jp jq jr hm dt translated">对<code class="eh mk ml mm ko b">malloc</code>的调用将做一些自己的处理(仍然计入'<strong class="iw hu">用户</strong>时间)，然后在过程中的某个地方调用内核中的函数(计入'<strong class="iw hu">系统</strong>时间)。从内核调用返回后，在'<strong class="iw hu">用户</strong>'中会有更多的时间，然后<code class="eh mk ml mm ko b">malloc</code>会返回到你的代码中。至于切换发生的时间，以及在内核模式下花费了多少时间...你不能说。这取决于库的实现。此外，其他看似无害的函数也可能在后台使用<code class="eh mk ml mm ko b">malloc</code>之类的东西，这将再次在“sys”中占用一些时间。</p><blockquote class="iq ir is"><p id="04f6" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">这篇文章的一些内容是最初在S <a class="ae km" href="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1/556411#556411" rel="noopener ugc nofollow" target="_blank"> tack Overflow </a>上发布的答案的组合</p><p id="c4f7" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">如果你喜欢这篇文章，你可能也会喜欢“<a class="ae km" rel="noopener" href="/coinmonks/how-to-built-a-bidirectional-app-for-internet-of-thing-chat-with-python-fc926e605b0f"> <strong class="iw hu">如何构建物联网双向应用/用Python聊天</strong> </a>”</p><p id="cc1c" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">请给它几个掌声支持！</p></blockquote><blockquote class="nj"><p id="6a71" class="nk nl ht bd nm nn no np nq nr ns jr ek translated">干杯！！！</p></blockquote></div></div>    
</body>
</html>