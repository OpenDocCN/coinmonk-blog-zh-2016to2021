<html>
<head>
<title>Ethernaut Lvl 11 Elevator Walkthrough: How to abuse Solidity interfaces and function state modifiers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ethernaut Lvl 11电梯演练:如何滥用Solidity接口和函数状态修饰符</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethernaut-lvl-11-elevator-walkthrough-how-to-abuse-solidity-interfaces-and-function-state-41005470121d?source=collection_archive---------2-----------------------#2018-08-27">https://medium.com/coinmonks/ethernaut-lvl-11-elevator-walkthrough-how-to-abuse-solidity-interfaces-and-function-state-41005470121d?source=collection_archive---------2-----------------------#2018-08-27</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="e203" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">这是一个围绕<a class="ae ji" href="https://openzeppelin.org/" rel="noopener ugc nofollow" target="_blank"> Zeppelin </a>团队的<a class="ae ji" href="https://ethernaut.zeppelin.solutions/" rel="noopener ugc nofollow" target="_blank">智能合约安全拼图</a>的<a class="ae ji" rel="noopener" href="/@nicolezhu">深度系列</a>。我们学习关键的可靠性概念，以便100%靠自己解决难题。</h2></div><p id="47d0" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">这一层要求你乘电梯到顶层。</p></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="bf5f" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">什么是纯视图函数</h1><p id="34f1" class="pw-post-body-paragraph jj jk ht jl b jm le iu jo jp lf ix jr js lg ju jv jw lh jy jz ka li kc kd ke hm dt translated">实度函数有函数修饰符，在每个函数调用开始时执行。您已经熟悉了<strong class="jl hu">可见性修饰符</strong>，比如<code class="eh lj lk ll lm b">public</code>和<code class="eh lj lk ll lm b">private</code>，它们决定了谁可以调用这些函数。</p><p id="8a52" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">同样，<code class="eh lj lk ll lm b">pure</code>和<code class="eh lj lk ll lm b">view</code>是内置的<strong class="jl hu">状态修饰符</strong>。他们“承诺”<em class="ln"/>功能将如何与以太坊区块链上的数据交互，即<em class="ln">状态</em>。</p><p id="2e07" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">按照递增状态权限的顺序:</p><ul class=""><li id="62ce" class="lo lp ht jl b jm jn jp jq js lq jw lr ka ls ke lt lu lv lw dt translated"><code class="eh lj lk ll lm b">pure</code>:承诺函数<strong class="jl hu">既不读取也不修改状态</strong>。注意:在最近的编译器中，Pure取代了<code class="eh lj lk ll lm b">constant</code>。</li><li id="1fab" class="lo lp ht jl b jm lx jp ly js lz jw ma ka mb ke lt lu lv lw dt translated"><code class="eh lj lk ll lm b">view</code>:承诺函数<strong class="jl hu">只读取，不修改状态</strong></li><li id="6548" class="lo lp ht jl b jm lx jp ly js lz jw ma ka mb ke lt lu lv lw dt translated"><code class="eh lj lk ll lm b">default</code>:【no modifier】承诺<strong class="jl hu">将读取和修改状态</strong>的功能</li></ul><p id="039f" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">理论上，您应该遵循修改器的最佳实践(见下文):</p><figure class="md me mf mg fq mh fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mc"><img src="../Images/9f76cea1e4f2ba8e1b07fd4b11a77564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMsV86HlvH9Ib9bpT5pKlg.jpeg"/></div></div></figure><p id="9aaa" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jl hu">安全警告:</strong>在早期的编译器版本中，它<em class="ln">允许</em>而<em class="ln">在函数背叛它们的修饰符承诺时不给出警告</em>。所以一个<code class="eh lj lk ll lm b">pure</code>函数可以违背自己的承诺，修改函数状态，没有任何警告。</p><blockquote class="mo"><p id="0d0c" class="mp mq ht bd mr ms mt mu mv mw mx ke ek translated">重要的是将这些数据修饰符视为对数据可变性的承诺，而不是保证。</p></blockquote></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="232d" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">什么是接口</h1><p id="081c" class="pw-post-body-paragraph jj jk ht jl b jm le iu jo jp lf ix jr js lg ju jv jw lh jy jz ka li kc kd ke hm dt translated">接口允许不同的契约类相互通信。</p><p id="e914" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">把接口想象成一个ABI(或API)声明,它迫使契约都以相同的语言/数据结构进行通信。但是接口没有规定函数内部的逻辑，让开发人员实现自己的业务层。</p><blockquote class="mo"><p id="bb7f" class="mp mq ht bd mr ms mt mu mv mw mx ke ek translated">契约接口指定了什么，但没有指定如何</p></blockquote><h2 id="3732" class="my kn ht bd ko mz na nb ks nc nd ne kw js nf ng ky jw nh ni la ka nj nk lc nl dt translated"><strong class="ak">开发者通常使用接口:</strong></h2><ul class=""><li id="b3ad" class="lo lp ht jl b jm le jp lf js nm jw nn ka no ke lt lu lv lw dt translated"><strong class="jl hu">设计合同:</strong>在实施实际合同之前，先生成一个工作ABI。</li><li id="23f7" class="lo lp ht jl b jm lx jp ly js lz jw ma ka mb ke lt lu lv lw dt translated"><strong class="jl hu">对于令牌契约</strong>:通过声明一个共享语言，所以不同的契约可以使用这些令牌来处理它们的业务逻辑。</li><li id="b369" class="lo lp ht jl b jm lx jp ly js lz jw ma ka mb ke lt lu lv lw dt translated"><strong class="jl hu">未使用</strong>:一些开发人员想要<a class="ae ji" href="https://github.com/ethereum/solidity/issues/3420" rel="noopener ugc nofollow" target="_blank">完全废弃接口</a>，以支持抽象类*。</li></ul><blockquote class="np nq nr"><p id="8357" class="jj jk ln jl b jm jn iu jo jp jq ix jr ns jt ju jv nt jx jy jz nu kb kc kd ke hm dt translated">*注意:抽象类与接口有相似的安全漏洞。在抽象契约中，一些功能已经被编程，但是很容易被覆盖。</p></blockquote></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="2426" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">详细演练</h1><figure class="md me mf mg fq mh fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff nv"><img src="../Images/e96726ce1f24de8dc824d7607fd2be6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbF9wh05WAL47S_rSmpt7w.png"/></div></div></figure><p id="eee1" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">为了通过这一关，我们必须在一个单独的<code class="eh lj lk ll lm b">goTo()</code>函数调用中使这个检查<strong class="jl hu">首先</strong>返回true，然后<strong class="jl hu">返回false </strong>:</p><pre class="md me mf mg fq nw lm nx ny aw nz dt"><span id="c7c3" class="my kn ht lm b fv oa ob l oc od">// 1st check has to return false<br/>if (! building.isLastFloor(_floor)) {<br/>    floor = _floor;</span><span id="1aea" class="my kn ht lm b fv oe ob l oc od">// 2nd check has to return true<br/>      top = building.isLastFloor(floor);  //winning statement<br/>}</span></pre><p id="0b7d" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">请注意，Elevator.sol从未从Building接口实现过<code class="eh lj lk ll lm b">isLastFloor()</code>函数。</p><p id="577c" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">这意味着我们可以创建一个名为Building的恶意契约来实现这个功能。然后，如果我们从恶意契约中调用goto()，我们版本的<code class="eh lj lk ll lm b">isLastFloor</code>函数将在我们级别的Elevator.sol实例的上下文中使用<em class="ln">！</em></p><ol class=""><li id="f0ef" class="lo lp ht jl b jm jn jp jq js lq jw lr ka ls ke of lu lv lw dt translated">在<code class="eh lj lk ll lm b">Elevator.sol</code>下面，创建一个<code class="eh lj lk ll lm b">Building.sol</code>契约，最终在某个任意楼层调用<code class="eh lj lk ll lm b">Elevator.goto()</code>:</li></ol><pre class="md me mf mg fq nw lm nx ny aw nz dt"><span id="2034" class="my kn ht lm b fv oa ob l oc od">contract Building {<br/>    Elevator public el = Elevator(YOUR_LVL_INSTANCE); </span><span id="1e42" class="my kn ht lm b fv oe ob l oc od">    function hack() public {<br/>        el.goTo(1);<br/>    }<br/>}</span></pre><p id="1783" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">2.用一个开关实现<code class="eh lj lk ll lm b">isLastFloor</code>,保证先真后假的响应。确保您的函数声明和修饰符与接口一致:</p><figure class="md me mf mg fq mh"><div class="bz el l di"><div class="og oh l"/></div></figure><p id="ec5d" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">3.使用<a class="ae ji" href="http://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a>，调用hack()推倒所有多米诺骨牌。注意，尽管<code class="eh lj lk ll lm b">isLastFloor</code>承诺是一个<code class="eh lj lk ll lm b">pure</code>函数，但它确实改变了区块链状态。</p><p id="e772" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">一个快速的<code class="eh lj lk ll lm b">await contract.top()</code>现在显示我们在顶层。</p></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="c35c" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">关键安全要点</h1><ul class=""><li id="a8b1" class="lo lp ht jl b jm le jp lf js nm jw nn ka no ke lt lu lv lw dt translated">接口不保证协定的安全性。请记住，仅仅因为另一个契约使用了相同的接口，并不意味着它会按照预期的方式运行！</li><li id="1e23" class="lo lp ht jl b jm lx jp ly js lz jw ma ka mb ke lt lu lv lw dt translated">继承从接口扩展的契约时要小心。每一层抽象都通过信息模糊引入了安全问题。这使得每一代合同都比前一代越来越不安全。</li><li id="54ce" class="lo lp ht jl b jm lx jp ly js lz jw ma ka mb ke lt lu lv lw dt translated"><strong class="jl hu">你正在使用或继承的编译器版本</strong>是什么？<code class="eh lj lk ll lm b">View</code>和<code class="eh lj lk ll lm b">pure</code>承诺可能会在你不知情的情况下被违背！</li></ul><blockquote class="np nq nr"><p id="3e6b" class="jj jk ln jl b jm jn iu jo jp jq ix jr ns jt ju jv nt jx jy jz nu kb kc kd ke hm dt translated">“Solidity编译器不会强制执行<code class="eh lj lk ll lm b">view</code>或<code class="eh lj lk ll lm b">constant</code>函数不修改状态。这同样适用于<code class="eh lj lk ll lm b">pure</code>函数，它不应该读取状态，但它们可以。请务必阅读<a class="ae ji" href="http://solidity.readthedocs.io/en/develop/contracts.html#view-functions" rel="noopener ugc nofollow" target="_blank"> Solidity的文档</a>，并了解其注意事项。”—以太网</p></blockquote><h1 id="5396" class="km kn ht bd ko kp oi kr ks kt oj kv kw iz ok ja ky jc ol jd la jf om jg lc ld dt translated">更多级别</h1><div class="on oo fm fo op oq"><a rel="noopener follow" target="_blank" href="/coinmonks/ethernaut-lvl-10-re-entrancy-walkthrough-how-to-abuse-execution-ordering-and-reproduce-the-dao-7ec88b912c14"><div class="or ab ej"><div class="os ab ot cl cj ou"><h2 class="bd hu fv z el ov eo ep ow er et hs dt translated">以太网Lvl 10重入演练:如何滥用执行顺序和再现道…</h2><div class="ox l"><h3 class="bd b fv z el ov eo ep ow er et ek translated">这是一个围绕齐柏林团队的智能合同安全难题的深入系列。我们学习关键的可靠性概念…</h3></div><div class="oy l"><p class="bd b gc z el ov eo ep ow er et ek translated">medium.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe mm oq"/></div></div></a></div><div class="on oo fm fo op oq"><a rel="noopener follow" target="_blank" href="/coinmonks/ethernaut-lvl-12-privacy-walkthrough-how-ethereum-optimizes-storage-to-save-space-and-be-less-c9b01ec6adb6"><div class="or ab ej"><div class="os ab ot cl cj ou"><h2 class="bd hu fv z el ov eo ep ow er et hs dt translated">以太坊Lvl 12隐私演练:以太坊如何优化存储以节省空间和减少…</h2><div class="ox l"><h3 class="bd b fv z el ov eo ep ow er et ek translated">这是一个围绕齐柏林团队的智能合同安全难题的深入系列。我们学习关键的可靠性概念…</h3></div><div class="oy l"><p class="bd b gc z el ov eo ep ow er et ek translated">medium.com</p></div></div><div class="oz l"><div class="pf l pb pc pd oz pe mm oq"/></div></div></a></div><blockquote class="mo"><p id="e1c4" class="mp mq ht bd mr ms pg ph pi pj pk ke ek translated"><a class="ae ji" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="pm pn po pp pq mh fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff pl"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>