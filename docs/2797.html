<html>
<head>
<title>A Linked List Implementation for Ethereum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊的链表实现</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-linked-list-implementation-for-ethereum-a2915bf8122f?source=collection_archive---------1-----------------------#2020-03-02">https://medium.com/coinmonks/a-linked-list-implementation-for-ethereum-a2915bf8122f?source=collection_archive---------1-----------------------#2020-03-02</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="b66e" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">在Solidity中编写数据结构既奇怪又漂亮。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/a6d91538ca070774a43cec34828e7087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y00sLVMFPbDx5otzG_oDBw.jpeg"/></div></div></figure><p id="3574" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">几个月前，我为一个客户在<a class="ae kq" rel="noopener" href="https://medium.com/coinmonks/solidity/home"> Solidity </a>中实现了一个<a class="ae kq" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank">链表</a>。最近，我决定在Solidity中实现一个<a class="ae kq" href="https://gist.github.com/halfelf/db1ae032dc34278968f8bf31ee999a25" rel="noopener ugc nofollow" target="_blank">快速限价订单簿</a>,作为一个宠物项目(书呆子不是很有趣吗！)和链表又出现了。</p><p id="e7c0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">正如我最近在一篇关于何时使用不同数据结构的文章中所写的:</p><p id="2d84" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">当你需要保持插入顺序时，或者当你想在任意位置插入时，链表是你的数据结构的选择。</p><p id="3763" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我喜欢编写基本的构建模块，似乎没有人做过这一项，所以我很乐意去做。</p><p id="95ba" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在本文中，我将介绍单向和双向链表的实现，您可以根据自己的目的重用或修改它。所有的<a class="ae kq" href="https://github.com/HQ20/contracts/tree/master/contracts/lists" rel="noopener ugc nofollow" target="_blank">代码都可以在GitHub </a>中获得，或者作为一个npm包。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff kr"><img src="../Images/c24b2d8e5b59fc1e065ee9ea9d54c8df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zobE6VzVBV2S2zQo"/></div></div></figure><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ks"><img src="../Images/c7e28363f069cc465f7d47f644e7b088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JrPoORpmwzL-RMLa"/></div></div></figure><p id="2d17" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">*免责声明:在写这篇文章的时候，在对合同进行编码之后，我发现了来自<a class="ae kq" href="https://github.com/chriseth" rel="noopener ugc nofollow" target="_blank"> chriseth </a>的这个<a class="ae kq" href="https://github.com/ethereum/dapp-bin/blob/master/library/linkedList.sol" rel="noopener ugc nofollow" target="_blank">早期实现</a>。和他一样，我也考虑过用数组。与使用映射相比，它简化了新项目的创建，但也增加了删除的难度。</p><h1 id="ebce" class="kt ku ht bd kv kw kx ky kz la lb lc ld iz le ja lf jc lg jd lh jf li jg lj lk dt translated">履行</h1><p id="c161" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">在这篇文章中，我将忽略<a class="ae kq" rel="noopener" href="/coinmonks/solidity-and-object-oriented-programming-oop-191f8deb8316"> Solidity是一种面向对象的编程语言</a>,并在单个契约中编码列表。这样做可以让我专注于基础工作，比如数据使用。一个<a class="ae kq" href="https://github.com/HQ20/contracts/blob/new/lists/oop/contracts/drafts/lists/LinkedListOOP.sol" rel="noopener ugc nofollow" target="_blank"> OOP的实现是可能的</a>，但是它的权衡值得一篇独立的文章。</p><p id="9944" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在单一契约实体中实现一个链表并不是一件显而易见的事情。这段代码会非常方便，但是在可靠性上不可行，因为你不能使用递归<code class="eh lq lr ls lt b">structs</code>。</p><pre class="jj jk jl jm fq lu lt lv lw aw lx dt"><span id="2cd8" class="ly ku ht lt b fv lz ma l mb mc">contract ImpossibleLinkedList {<br/>   struct Item {<br/>      Item next;<br/>      address data;<br/>   }</span><span id="08a5" class="ly ku ht lt b fv md ma l mb mc">Item public head;</span></pre><p id="426d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">实体中存在的唯一动态契约变量是映射。甚至数组也是幕后的映射。考虑到这个限制，我能想到的Solidity中链表的最佳实现是基于这个:</p><pre class="jj jk jl jm fq lu lt lv lw aw lx dt"><span id="30a5" class="ly ku ht lt b fv lz ma l mb mc">contract LinkedList {<br/>  struct Item {<br/>    uint256 id;<br/>    uint256 next;<br/>    address data;<br/>}<br/>mapping (uint256 =&gt; Item) public items;<br/>uint256 public head;<br/>uint256 public idCounter;</span></pre><p id="e039" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">链表由<code class="eh lq lr ls lt b">Item</code>组成。<code class="eh lq lr ls lt b">Item</code>有一个惟一的id，另一个<code class="eh lq lr ls lt b">Item</code>的id的成员，以及一个作为数据有效载荷的地址。然后，所有创建的项目都存储在由<code class="eh lq lr ls lt b">Item</code> id索引的映射中。</p><p id="e613" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果您知道任何<code class="eh lq lr ls lt b">Item</code>的id，只需在映射中查找它，就可以以O(1)的代价检索它。如果您正在查看列表中的一个<code class="eh lq lr ls lt b">Item</code>，并且想要继续下一个，您必须检索item.next，这是一个<code class="eh lq lr ls lt b">Item</code> id，然后在映射中查找下一个<code class="eh lq lr ls lt b">Item</code>。</p><p id="abad" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果这让你感到困惑，不要难过。我也很困惑。我的第一个问题是“如果你可以任意地从一个链表中检索任何一个<code class="eh lq lr ls lt b">Item</code>，那么这个链表还有意义吗？”。</p><p id="16f7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">问题是，是的，有一个点，但范围非常有限。当您需要保持插入顺序时，以及当您想要在任意位置插入时，链表是您的数据结构的选择。事实上，你可以迭代列表，这在一定程度上是有用的，如果你必须在一个事务中这样做，列表不能无限增长。</p><p id="02ec" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><strong class="jw hu">当一个契约需要频繁使用有序列表中的几个项目时，您可以使用这种数据结构，您可以假设这些项目的大小有限。</strong></p><p id="783a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">例如，如果您需要一份合同来始终了解令牌的100个最大持有者，以便给他们一些额外津贴。</p><p id="fc49" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">与以前的文章不同，这次我不打算在这里粘贴整个代码。相反，我将把你引向<a class="ae kq" href="https://github.com/HQ20/contracts/contracts/lists" rel="noopener ugc nofollow" target="_blank">完全实现</a>。有一个单向链表的实现和另一个双向链表的实现，每一个都有大约200行代码，这是我为了最大程度的清晰而精心制作的。</p><p id="7de0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在这种情况下，我认为更重要的是讨论单链表和双向链表之间的权衡，特别是考虑到<a class="ae kq" href="https://blog.coincodecap.com/tag/ethereum/" rel="noopener ugc nofollow" target="_blank">以太坊</a>区块链在你可以<a class="ae kq" href="https://hackernoon.com/how-much-can-i-do-in-a-block-163q3xp2" rel="noopener ugc nofollow" target="_blank">安全执行的算法方面非常有限</a>。</p><h1 id="4f4a" class="kt ku ht bd kv kw kx ky kz la lb lc ld iz le ja lf jc lg jd lh jf li jg lj lk dt translated">使用</h1><p id="e834" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">当我开始实现链表时，我认为做双向链表会比单向链表更复杂。有趣的是，实现前者稍微容易一些。在每个项目中添加前一个项目的链接可以让您消除这种低效的方法:</p><pre class="jj jk jl jm fq lu lt lv lw aw lx dt"><span id="a738" class="ly ku ht lt b fv lz ma l mb mc">/**<br/> * @dev Given an Item, denoted by `_id`, returns the id of the Item<br/> * that points to it, or 0 if `_id` refers to the Head.<br/> */<br/>function findPrevId(uint256 _id) public view returns (uint256) {<br/>  if (_id == head) return 0;<br/>  Item memory prevItem = items[head];<br/>  <strong class="lt hu">while (prevItem.next != _id) {<br/>    prevItem = items[prevItem.next];<br/>  }<br/>  </strong>return prevItem.id;<br/>}</span></pre><p id="5431" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">那种说法是邪恶的。</p><p id="7737" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">当您知道一个项目并且想要在它之前插入另一个项目时，您可以随时使用这个方法。相当常见的用例。</p><p id="3e0a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">LinkedList.sol和DoubleLinkedList.sol之间的gas比较更能说明这个问题。对于这些测试，我使用了一个包含100个项目的列表。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff me"><img src="../Images/c04ae7569b32e73f2eb88a8a31a9a735.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*tM7vr08XvD8axd4S6KPQXA.png"/></div></div></figure><p id="f978" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh lq lr ls lt b">addHead</code>和<code class="eh lq lr ls lt b">insertAfter</code>与链表的运算都是O(1)，开销约100K gas。没有描述数据检索，但是假设我们使用映射，成本将是O(1)。</p><p id="51cf" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">问题是我们什么时候需要遍历列表。我们循环的每一个项目看起来花费了大约1K gas，如在<code class="eh lq lr ls lt b">findTailIdWithGas</code>中所见(这是一个将<code class="eh lq lr ls lt b">findTailId</code>包含在事务中的模拟函数，浪费了一些gas)。</p><p id="6d80" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">也许我们可以不在尾部添加项目或在已知项目前插入项目，但<code class="eh lq lr ls lt b">remove</code>功能更成问题。在链表中，你必须从头开始遍历列表来删除条目。在智能合同中，需要非常小心地使用成本为O(N)的方法，或者最好避免使用。</p><p id="7b7c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">双向链表更容易实现，也更实用，即使使用起来有点贵。</p><p id="cba6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在这种特定的情况下，气体阻塞限制大约为一千万，这意味着您不能删除距离头部超过10，000个位置的项目。这可能非常危险。</p><p id="0431" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">另一方面，对于DoubleLinkedList，所有方法都是O(1)。<code class="eh lq lr ls lt b">addHead</code>和<code class="eh lq lr ls lt b">insertAfter</code>比LinkedList中的开销更大，因为我们需要更新一个额外的指针。如果您需要在列表的末尾插入，在两个方向上查找相邻的项目，或者删除项目，您将受益于O(1)成本。我没有包括循环列表的气体成本，但它们应该与LinkedList相同。</p><p id="2635" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">正如我之前所说，有趣的是，对于相同的功能，DoubleLinkedList的部署成本比LinkedList低。没那么重要但是很有趣。</p><p id="ae70" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">和其他事情一样，你的里程会有所不同。也许你可以用一个单向链表，也许你需要一个双向链表。也许你应该使用一个数组。至少现在你都知道了。</p><h1 id="38e4" class="kt ku ht bd kv kw kx ky kz la lb lc ld iz le ja lf jc lg jd lh jf li jg lj lk dt translated">其他实现</h1><p id="ca5e" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">上面讨论的实现并不是唯一的实现，我只是认为它们很容易理解。还有其他有趣的实现可能更适合您的用例:</p><ul class=""><li id="6acd" class="mf mg ht jw b jx jy ka kb kd mh kh mi kl mj kp mk ml mm mn dt translated">您想要节省一些时间，那么从<code class="eh lq lr ls lt b">Item</code>结构中移除<code class="eh lq lr ls lt b">id</code>字段。你实际上并不需要它，真有趣。</li><li id="bcc6" class="mf mg ht jw b jx mo ka mp kd mq kh mr kl ms kp mk ml mm mn dt translated">你不喜欢结构，他们用一个映射代替每个结构变量作为状态变量，它会完全一样。</li><li id="a865" class="mf mg ht jw b jx mo ka mp kd mq kh mr kl ms kp mk ml mm mn dt translated">你很乐意在末尾添加一些项目，也许这些项目会在一段时间后过期:你可以使用<a class="ae kq" href="https://github.com/HQ20/contracts/blob/master/contracts/drafts/lists/RenounceableQueue.sol" rel="noopener ugc nofollow" target="_blank">renovable queue . sol</a>。对于传统的快速限价订单簿来说，这将非常有用。</li><li id="e230" class="mf mg ht jw b jx mo ka mp kd mq kh mr kl ms kp mk ml mm mn dt translated">如果列表中的所有项目都是唯一的，那么您可以使用<a class="ae kq" href="https://github.com/HQ20/contracts/blob/master/contracts/drafts/lists/OrderedSet.sol" rel="noopener ugc nofollow" target="_blank"> OrderedSet.sol </a>。我喜欢它的简洁和优雅。</li><li id="40c4" class="mf mg ht jw b jx mo ka mp kd mq kh mr kl ms kp mk ml mm mn dt translated">如果你的列表中的所有项目都是唯一的，但你不在乎顺序，那么你在一个规范的<a class="ae kq" href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">集合</a>之后，从<a class="ae kq" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/EnumerableSet.sol" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a>中获取它。</li></ul><h1 id="f827" class="kt ku ht bd kv kw kx ky kz la lb lc ld iz le ja lf jc lg jd lh jf li jg lj lk dt translated">结论</h1><p id="a341" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated"><a class="ae kq" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank">链表</a>是智能合约中考虑的第一个复杂数据结构。鉴于智能契约中的约束迫使我们尽可能简单地编码，有必要了解不同链表实现之间的权衡。</p><p id="79e8" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在本文中，我展示了单向链表和双向链表，指向准备重用的<a class="ae kq" href="https://github.com/HQ20/contracts/tree/master/contracts/lists" rel="noopener ugc nofollow" target="_blank">代码</a>。还提供了天然气成本分析以及安全使用指南。</p><p id="aa8c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">有机会编写基本的数据结构代码，我感到非常荣幸。有时候，编写智能合约就像回到了很多年前，那时编程意味着非常接近硬件，非常接近数学。我喜欢这样。</p><p id="6ca5" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果你正在考虑在一个项目中使用这个代码，想要做出贡献，或者有想法去探索，请<a class="ae kq" href="http://www.albertocuesta.es" rel="noopener ugc nofollow" target="_blank">给我写信</a>！与阅读我的人交谈总是一种乐趣:)</p><blockquote class="mt"><p id="833a" class="mu mv ht bd mw mx my mz na nb nc kp ek translated"><a class="ae kq" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ne nf ng nh ni jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nd"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff nj"><img src="../Images/e9dbce386c4f90837b5db529a4c87766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fZu_SfnNF6m_BGbXlsl-A@2x.png"/></div></a></figure></div></div>    
</body>
</html>