<html>
<head>
<title>CCKit: Routing and middleware for Hyperledger Fabric Golang chaincode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">cc kit:Hyperledger Fabric Golang chain code的路由和中间件</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/routing-and-middleware-for-developing-hyperledger-fabric-chaincode-written-in-go-90913951bf08?source=collection_archive---------2-----------------------#2018-05-20">https://medium.com/coinmonks/routing-and-middleware-for-developing-hyperledger-fabric-chaincode-written-in-go-90913951bf08?source=collection_archive---------2-----------------------#2018-05-20</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="cbff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有很多关于Hyperledger Fabric chaincode开发的例子和教程。本文描述了通过使用<a class="ae jo" href="https://github.com/s7techlab/cckit/" rel="noopener ugc nofollow" target="_blank"> CCKit </a>库简化和加速链代码开发的方法，包括实现基本的链代码构建组件——路由、中间件和链代码调用上下文，以及提供链代码测试实用程序。</p><h1 id="0417" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">链码组件</h1><p id="1470" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated"><a class="ae jo" href="http://hyperledger-fabric.readthedocs.io/en/release-1.1/chaincode4ade.html" rel="noopener ugc nofollow" target="_blank"> Chaincode </a>是一个程序，用<a class="ae jo" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>，Javascript或者Java编写。chain code(Fabric world中的智能合约)实现一些业务逻辑(例如，<a class="ae jo" rel="noopener" href="/coinmonks/erc20-token-as-hyperledger-fabric-golang-chaincode-d09dfd16a339"> ERC20令牌功能</a>)并与共享分类帐交互。链码必须实现规定的<code class="eh ks kt ku kv b">Chaincode interface</code>。</p><figure class="kw kx ky kz fq la"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="b407" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当chaincode接收到一个<code class="eh ks kt ku kv b">instantiate</code>或<code class="eh ks kt ku kv b">upgrade</code>事务时，就会调用<code class="eh ks kt ku kv b">Init</code>方法。<code class="eh ks kt ku kv b">Init</code>方法可以执行任何必要的初始化，包括设置默认的应用程序状态。响应于接收到处理交易提议的<code class="eh ks kt ku kv b">invoke</code>交易，调用<code class="eh ks kt ku kv b">Invoke</code>方法。</p><p id="6b7f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">chaincode“shim”API中的另一个接口是<code class="eh ks kt ku kv b"><a class="ae jo" href="https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim#ChaincodeStubInterface" rel="noopener ugc nofollow" target="_blank">ChaincodeStubInterface</a> </code>，用于访问和修改分类帐，并在chain code之间进行调用。</p><figure class="kw kx ky kz fq la"><div class="bz el l di"><div class="lb lc l"/></div></figure><h1 id="533a" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">链码示例</h1><p id="ed73" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">除了<a class="ae jo" href="http://hyperledger-fabric.readthedocs.io/en/release-1.1/chaincode4ade.html#pulling-it-all-together" rel="noopener ugc nofollow" target="_blank"> Hyperledger Fabric文档</a>之外，还提供了几个链码示例:</p><ul class=""><li id="b769" class="ld le ht is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll dt translated"><a class="ae jo" href="https://developer.ibm.com/code/patterns/build-a-blockchain-insurance-app/" rel="noopener ugc nofollow" target="_blank">区块链保险app </a> (2018)</li><li id="587e" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><a class="ae jo" href="https://github.com/hyperledger/fabric/blob/release-1.1/examples/chaincode/go/marbles02/marbles_chaincode.go" rel="noopener ugc nofollow" target="_blank">弹珠</a></li><li id="4abb" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><a class="ae jo" href="https://github.com/IBM-Blockchain-Archive/car-lease-demo/blob/master/Chaincode/src/vehicle_code/vehicles.go" rel="noopener ugc nofollow" target="_blank">汽车租赁演示</a> (2017)</li></ul><p id="1edc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它们都非常冗长，包含大量函数切换逻辑(某种“路由”)、参数号验证、json编组/解组等</p><figure class="kw kx ky kz fq la fe ff paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="fe ff lr"><img src="../Images/ea43b5b8c4e216db6231268033830d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDa_GzIHyZIPy0kaBiQAgQ.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Invoke hell</figcaption></figure><h1 id="61e7" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">链码方法路由库简介</h1><p id="4629" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">为了简化链代码开发，我们尝试在单个库<a class="ae jo" href="https://github.com/s7techlab/cckit" rel="noopener ugc nofollow" target="_blank"> CCKit </a>中组合常见的软件开发模式，如<strong class="is hu">路由、中间件</strong>和<strong class="is hu">调用上下文</strong>:</p><p id="fd1d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="mc">路由</em> </strong>指的是确定应用程序如何响应客户端对特定端点的请求。链码路由器使用有关如何将链码调用映射到特定处理程序的规则，以及在请求期间需要使用哪种中间件，例如如何将传入参数从<code class="eh ks kt ku kv b">[]byte</code>转换为目标类型(<code class="eh ks kt ku kv b">string</code>、<code class="eh ks kt ku kv b">struct</code>等)</p><p id="6297" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">调用</strong> <a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/router/context.go" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu">上下文</strong> </a> <strong class="is hu"> </strong>是ChaincodeStubInterface的抽象，代表当前chaincode调用的上下文。它保存请求、响应和客户端(身份)引用、转换后的参数以及状态和日志引用。由于<code class="eh ks kt ku kv b">Context</code>是一个接口，很容易用自定义方法扩展它。</p><p id="4c45" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="mc">中间件</em> </strong>函数是在链码的调用-响应循环中访问调用上下文、调用结果和下一个中间件函数的函数。下一个中间件功能通常用一个名为<code class="eh ks kt ku kv b">next</code>的变量来表示。</p><p id="166e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">中间件功能可以执行以下任务:</p><ul class=""><li id="a1f9" class="ld le ht is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll dt translated">将输入参数从字节片转换为所需的类型</li><li id="025b" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">检查访问控制要求</li><li id="ed13" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">结束请求-响应循环。</li><li id="4335" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">调用堆栈中的下一个中间件函数。</li></ul><p id="f6bb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://github.com/s7techlab/cckit" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">cc kit</strong></a><strong class="is hu"/>库包含了这些模式的实现并提供了:</p><ul class=""><li id="aac5" class="ld le ht is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll dt translated">集中式链代码调用处理</li><li id="4b59" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">中间件支持</li><li id="bc7d" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">链码方法访问控制</li><li id="e2cd" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">自动json编组/解组，条目密钥生成</li><li id="e5d9" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">测试工具(扩展版<a class="ae jo" href="https://github.com/hyperledger/fabric/blob/release-1.1/core/chaincode/shim/mockstub.go" rel="noopener ugc nofollow" target="_blank"> MockStub </a>)</li></ul><h1 id="e082" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">简单资产链代码—汽车注册示例</h1><p id="7793" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">我们将通过实现一个管理简单“资产”——汽车——的简单链码应用程序来演示路由器和中间件的使用。在本例中，只有一个机构可以注册汽车，所有机构都可以查看注册汽车的信息</p><h1 id="8c5b" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">【CCKit入门</h1><p id="fdbb" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">在开始之前，请确保从github.com获得CCkit:</p><blockquote class="md me mf"><p id="993a" class="iq ir mc is b it iu iv iw ix iy iz ja mg jc jd je mh jg jh ji mi jk jl jm jn hm dt translated">git克隆<a class="ae jo" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:s7techlab/cc kit . git</p></blockquote><p id="68ef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">并使用<em class="mc"> dep </em>命令获取依赖关系:</p><blockquote class="md me mf"><p id="cdbd" class="iq ir mc is b it iu iv iw ix iy iz ja mg jc jd je mh jg jh ji mi jk jl jm jn hm dt translated">dep确保-仅供应商</p></blockquote><h1 id="5f82" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">实现链码接口</h1><p id="e15f" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">与每个链码一样，它实现了<a class="ae jo" href="https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim#Chaincode" rel="noopener ugc nofollow" target="_blank">链码接口</a>，特别是<code class="eh ks kt ku kv b">Init</code>和<code class="eh ks kt ku kv b">Invoke</code>功能</p><figure class="kw kx ky kz fq la"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="b693" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我们的例子中，这个函数非常简单——在<code class="eh ks kt ku kv b">Init</code>函数中，我们放入用户的链码状态标识符，用户实例化链码(“所有者”)。在<code class="eh ks kt ku kv b">Invoke</code>中，我们将链码方法调用的处理委托给路由器。</p><h1 id="2c58" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">链码资产</h1><p id="6d8e" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">正如许多其他示例所示，资产可以表示为复杂的结构(Golang structs)。在键/值对设置中，链码本身可以将数据存储为字符串。因此，我们将在进入chaincode状态之前将struct封送到JSON字符串，并在从状态中获取后解组。</p><p id="8911" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">汽车的属性:</p><ol class=""><li id="17c0" class="ld le ht is b it iu ix iy jb lf jf lg jj lh jn mj lj lk ll dt translated">id(唯一字符串，将用作密钥)</li><li id="b948" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn mj lj lk ll dt translated">标题(字符串)</li><li id="03bd" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn mj lj lk ll dt translated">所有者(字符串)</li></ol><p id="b344" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还为汽车注册信息创建了有效载荷结构。它只包含字段，允许传递给链码。</p><figure class="kw kx ky kz fq la"><div class="bz el l di"><div class="lb lc l"/></div></figure><h1 id="e7fc" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">定义链码方法</h1><p id="dbed" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">在链码创建函数中，我们可以确定链码函数及其参数。在这个例子中，链码具有三个功能:</p><ul class=""><li id="0463" class="ld le ht is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll dt translated"><strong class="is hu"> carList </strong>，返回<code class="eh ks kt ku kv b">Car</code>结构的切片</li><li id="497b" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><strong class="is hu"> carList </strong>，获取汽车id并返回<code class="eh ks kt ku kv b">Car</code> struct</li><li id="fb30" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><strong class="is hu"> carRegister </strong>，取<code class="eh ks kt ku kv b">CarPayload</code>结构，返回汽车注册结果。只有链码所有者才允许访问此方法，访问控制是使用<code class="eh ks kt ku kv b">owner.Only</code>中间件实现的</li></ul><figure class="kw kx ky kz fq la"><div class="bz el l di"><div class="lb lc l"/></div></figure><h1 id="9461" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">链代码方法实现</h1><p id="bdda" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">路由器处理的Chaincode方法以<code class="eh ks kt ku kv b">Context</code>为参数，返回<code class="eh ks kt ku kv b">interface{}</code>和<code class="eh ks kt ku kv b">error</code>。</p><p id="0b6a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh ks kt ku kv b">func (router.Context) (interface{}, error)</code></p><p id="7da2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">返回值将自动转换为<code class="eh ks kt ku kv b">Pb.response</code> : <code class="eh ks kt ku kv b">interface{}</code>将被整理为【字节】，响应状态将根据<code class="eh ks kt ku kv b">error</code>值为<code class="eh ks kt ku kv b">shim.OK</code>或<code class="eh ks kt ku kv b">shim.Error</code>。</p><p id="a021" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">路由器中定义的方法参数将自动从字节片转换成所需的类型(<code class="eh ks kt ku kv b">string</code>或<code class="eh ks kt ku kv b">CarPayload</code> struct)</p><p id="7d80" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Chaincode函数也使用<code class="eh ks kt ku kv b">State</code>方法，这简化了与chaincode状态的交互。</p><figure class="kw kx ky kz fq la"><div class="bz el l di"><div class="lb lc l"/></div></figure><h1 id="111a" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">一起</h1><blockquote class="md me mf"><p id="17bb" class="iq ir mc is b it iu iv iw ix iy iz ja mg jc jd je mh jg jh ji mi jk jl jm jn hm dt translated"><a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cars/cars.go" rel="noopener ugc nofollow" target="_blank">https://github . com/s7techlab/cc kit/blob/master/examples/cars/cars . go</a></p></blockquote><figure class="kw kx ky kz fq la"><div class="bz el l di"><div class="lb lc l"/></div></figure><h1 id="4e5b" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">链码主文件</h1><p id="d317" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">最后，我们需要创建带有<code class="eh ks kt ku kv b">main</code>函数的主包，它将调用<a class="ae jo" href="https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim#Start" rel="noopener ugc nofollow" target="_blank">垫片。启动</a>功能。</p><blockquote class="md me mf"><p id="9b0a" class="iq ir mc is b it iu iv iw ix iy iz ja mg jc jd je mh jg jh ji mi jk jl jm jn hm dt translated"><a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cars/bin/cars/main.go" rel="noopener ugc nofollow" target="_blank">https://github . com/s7techlab/cc kit/blob/master/examples/cars/bin/cars/main . go</a></p></blockquote><figure class="kw kx ky kz fq la"><div class="bz el l di"><div class="lb lc l"/></div></figure><h1 id="f584" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">没有访问控制</h1><p id="1847" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">有了路由器，你可以很容易地改变访问控制逻辑，你只需要改变或删除路由器定义中的中间件调用。例如没有<code class="eh ks kt ku kv b">carRegister</code>功能的访问控制的链码。我们只修改了两段代码——路由器中的Init函数和注册<code class="eh ks kt ku kv b">carRegister</code>函数，而<code class="eh ks kt ku kv b">carRegister</code>函数体保持不变。</p><blockquote class="md me mf"><p id="f2cf" class="iq ir mc is b it iu iv iw ix iy iz ja mg jc jd je mh jg jh ji mi jk jl jm jn hm dt translated"><a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cars/cars_noacces_control.go" rel="noopener ugc nofollow" target="_blank">https://github . com/s7techlab/cc kit/blob/master/examples/cars/cars _ no acces _ control . go</a></p></blockquote><figure class="kw kx ky kz fq la"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="1867" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">和无访问控制链接代码主文件</p><blockquote class="md me mf"><p id="0cdd" class="iq ir mc is b it iu iv iw ix iy iz ja mg jc jd je mh jg jh ji mi jk jl jm jn hm dt translated"><a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cars/bin/cars_noac/main.go" rel="noopener ugc nofollow" target="_blank">https://github . com/s7techlab/cc kit/blob/master/examples/cars/bin/cars _ noac/main . go</a></p></blockquote><figure class="kw kx ky kz fq la"><div class="bz el l di"><div class="lb lc l"/></div></figure><h1 id="c4cd" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">测试链码</h1><p id="8e2f" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">为了测试，我们使用了<code class="eh ks kt ku kv b">MockStub</code>的扩展版本，我们添加了<code class="eh ks kt ku kv b">Creator</code>嘲讽和一些方法调用的糖。</p><figure class="kw kx ky kz fq la"><div class="bz el l di"><div class="lb lc l"/></div></figure><p id="616f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">关于链码测试的更多内容将在下一篇文章中介绍</p></div></div>    
</body>
</html>