<html>
<head>
<title>Caching Ethereum events with MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用MySQL缓存以太坊事件</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/caching-ethereum-events-with-mysql-18bfa3558355?source=collection_archive---------0-----------------------#2019-01-01">https://medium.com/coinmonks/caching-ethereum-events-with-mysql-18bfa3558355?source=collection_archive---------0-----------------------#2019-01-01</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/c7b04b12f0b3fc9795a4cf78c6aa2364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yyPfgcCGCuHZ5WVUXfk_jA.jpeg"/></div></div></figure><div class=""/><p id="b728" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这篇文章中，我将展示一个简单的缓存以太坊事件的方法。这里我不会描述什么是事件，因为有很多文章涉及这个主题(<a class="ae jz" href="https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e" rel="noopener ugc nofollow" target="_blank">这里是最完美的一个</a>)。我只想说，通常我们使用事件进行一些链外操作，例如跟踪令牌的传输或检索特定事务的过滤列表，就像一个很好的旧SQL查询一样。</p><p id="bb49" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">假设我们想做一个跟踪一些令牌转移的网站，一种以太扫描。我们肯定需要这样简单的操作，如:</p><ul class=""><li id="2c9e" class="ka kb ie jd b je jf ji jj jm kc jq kd ju ke jy kf kg kh ki dt translated">获取所有令牌转移</li><li id="81c5" class="ka kb ie jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">获取从特定以太坊地址进行的转账</li><li id="6948" class="ka kb ie jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">让转账转移到特定的以太坊地址</li><li id="81af" class="ka kb ie jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">获取高于或低于特定金额的转账</li><li id="bccc" class="ka kb ie jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">在特定时间范围内获得转移</li></ul><p id="4f7d" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们现在在web3中拥有的是<strong class="jd if"> getPastEvents </strong>方法，其用法示例如下</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="394d" class="kx ky ie kt b fv kz la l lb lc">let events = await contract.getPastEvents(  <br/>    "Transfer",  <br/>    {  <br/>      filter: {from:'0x0123456789abcdef0123456789abcdef01234567'},  <br/>      fromBlock: 0,  <br/>      toBlock: 'latest'  <br/>    }  <br/>  );</span></pre><p id="f8da" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这种方法的主要问题是，随着区块链的增长，它可能会很慢，特别是如果你没有运行自己的以太坊节点，而是使用像Infura或MyEtherApi这样的公共提供商。</p><p id="1360" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来——几乎不可能实现一些复杂的查询，因为过滤器对象的功能非常有限。</p><p id="a6e4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">此外，已经写入区块链的事件不能更改，只能随着时间的推移添加新的记录。这一事实和其他事实使事件成为缓存的完美目标。</p><h1 id="05fa" class="ld ky ie bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">数据库选择</h1><p id="2584" class="pw-post-body-paragraph jb jc ie jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">在这个例子中，我们将使用MySQL作为保存事件记录的数据库。MySQL能够存储原始JSON，然后使用JSON对象的属性编写查询，就像它们是普通的SQL列一样。</p><h1 id="9047" class="ld ky ie bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">我们应该储存什么？</h1><p id="3bcd" class="pw-post-body-paragraph jb jc ie jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">让我们仔细看看<strong class="jd if"> getPastEvents </strong>方法的结果，以了解我们处理的是什么数据。我举了一些币安硬币转移的例子。每个事件对象具有以下结构:</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="9584" class="kx ky ie kt b fv kz la l lb lc">{  <br/>"address": "0xB8c77482e45F1F44dE1745F52C74426C631bDD52",  <br/>"blockHash": "0x19e0d4c4cce0ed7c429b627fc6c5cc5c223c2e9218e233ab2b72e64e817cfcc2",  <br/>"blockNumber": 6813922,  <br/>"logIndex": 111,  <br/>"removed": false,  <br/>"transactionHash": "0x32d660785112b084135e0d4d2b53c0d67e851b735eacb486e44e52b7945b857d",  <br/>"transactionIndex": 84,  <br/>"id": "log_5ea90f71",  <br/>"returnValues": {  <br/>"0": "0x6ACe7E0abCF0dA3097Fa7155149dccd51E20EF82",  <br/>"1": "0xAc951701644936aA95C80ED9f358Fa28f8369075",  <br/>"2": "1000553200000000000",  <br/>"from": "0x6ACe7E0abCF0dA3097Fa7155149dccd51E20EF82",  <br/>"to": "0xAc951701644936aA95C80ED9f358Fa28f8369075",  <br/>"value": "1000553200000000000"  <br/>  },  <br/>"event": "Transfer",  <br/>"signature": "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",  <br/>"raw": {  <br/>"data": "0x0000000000000000000000000000000000000000000000000de2add590e16000",  <br/>"topics": [  <br/>"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",  <br/>"0x0000000000000000000000006ace7e0abcf0da3097fa7155149dccd51e20ef82",  <br/>"0x000000000000000000000000ac951701644936aa95c80ed9f358fa28f8369075 <br/>    ]  <br/>  }  <br/>}</span></pre><p id="e0c5" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如您所见，事件参数存储在<strong class="jd if"> returnValues </strong>属性中。<strong class="jd if"> blockNumber </strong>，<strong class="jd if"> transactionHash </strong>，<strong class="jd if"> logIndex </strong>也可能有用，我稍后会向您展示。</p><p id="552d" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们的目标是将这些JSON对象写入数据库，并实现可以无缝替换标准web3的<strong class="jd if"> getPastEvents </strong>方法的简单访问方法。</p><p id="9944" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下面是创建<strong class="jd if">转移</strong>表的SQL脚本。</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="66ee" class="kx ky ie kt b fv kz la l lb lc">CREATE  TABLE  `eth_cache`.`transfer` (  <br/>`id`  INT  NOT  NULL AUTO_INCREMENT,  <br/>`json`  JSON  NOT  NULL,  <br/>`from`  VARCHAR(45) GENERATED  ALWAYS  AS (json_unquote(json_extract(`json`,'$.returnValues.from'))) VIRTUAL,  <br/>`to`  VARCHAR(45) GENERATED  ALWAYS  AS (json_unquote(json_extract(`json`,'$.returnValues.to'))) VIRTUAL,  <br/>`value`  VARCHAR(45) GENERATED  ALWAYS  AS (json_unquote(json_extract(`json`,'$.returnValues.value'))) VIRTUAL,  <br/>`txHash`  VARCHAR(66) GENERATED  ALWAYS  AS (json_unquote(json_extract(`json`,'$.transactionHash'))) VIRTUAL,  <br/>`logIndex`  INT  GENERATED  ALWAYS  AS (json_unquote(json_extract(`json`,'$.logIndex'))),  <br/>PRIMARY KEY (`id`),  <br/>UNIQUE  INDEX  `IDX_UNIQUE` (`txHash`  ASC, `logIndex`  ASC));</span></pre><p id="a20e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">需要解释一些重要的事情:</p><ol class=""><li id="c24d" class="ka kb ie jd b je jf ji jj jm kc jq kd ju ke jy mf kg kh ki dt translated"><strong class="jd if"> json </strong>列被创建为json类型。这允许我们使用特殊的语法创建自动生成的列</li><li id="9dc6" class="ka kb ie jd b je kj ji kk jm kl jq km ju kn jy mf kg kh ki dt translated"><strong class="jd if">从</strong>、<strong class="jd if">到</strong>、<strong class="jd if">值</strong> —这些是自动生成的列。这个表达式乍一看似乎很复杂，但实际上非常简单。例如，列中的<strong class="jd if">值等于<strong class="jd if"> json </strong>列中存储的对象的<strong class="jd if"> returnValues.from </strong>属性。</strong></li><li id="5f10" class="ka kb ie jd b je kj ji kk jm kl jq km ju kn jy mf kg kh ki dt translated"><strong class="jd if"> txHash </strong>和<strong class="jd if"> logIndex </strong>。这些属性组合在一起可以识别每个事件对象。我们需要这些来为一行创建唯一的索引，从而防止偶然的事件重复。</li></ol><p id="ae17" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可选地，我们也可以添加数据库索引来提高性能。例如，对于<strong class="jd if">到</strong>列</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="6bf4" class="kx ky ie kt b fv kz la l lb lc">ALTER  TABLE  `eth_cache`.`transfer`  <br/>ADD  INDEX  `IDX_TO` (`to`  ASC);</span></pre><h1 id="523d" class="ld ky ie bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">履行</h1><h1 id="4bad" class="ld ky ie bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">先决条件</h1><ol class=""><li id="fcbc" class="ka kb ie jd b je ma ji mb jm mg jq mh ju mi jy mf kg kh ki dt translated">Node.js .我用的是8.4.0版本。</li><li id="2ec5" class="ka kb ie jd b je kj ji kk jm kl jq km ju kn jy mf kg kh ki dt translated">Web3 npm包与区块链进行交互。我们需要特定版本1.0.0-beta.35。使用最新版本beta.36导致在尝试检索某些事件时出现“<em class="mj">返回值无效，是否耗尽汽油</em>”错误。</li></ol><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="315c" class="kx ky ie kt b fv kz la l lb lc">npm install web3@1.0.0-beta.35 --save</span></pre><p id="c30f" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">3.要在JavaScript中使用MySQL数据库，我们应该安装<a class="ae jz" href="https://www.npmjs.com/package/mysql" rel="noopener ugc nofollow" target="_blank"> mysql </a>包</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="e1a6" class="kx ky ie kt b fv kz la l lb lc">npm install mysql --save</span></pre><p id="a6c7" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">4.最后一个——MySQL服务器。值得一提的是，我们将使用MySQL 5.7，因为最新的8.0版本似乎与<strong class="jd if"> mysql </strong>包不兼容(它在尝试连接时给了我一个奇怪的错误ER_NOT_SUPPORTED_AUTH_MODE)。</p><h1 id="19e1" class="ld ky ie bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">与MySQL交互</h1><p id="b312" class="pw-post-body-paragraph jb jc ie jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">在这个例子中，我们将利用连接池进行查询。</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="65c6" class="kx ky ie kt b fv kz la l lb lc">const mysql = require('mysql');  <br/>let pool = mysql.createPool({  <br/>	connectionLimit: &lt;connection limit&gt;,  <br/>	host: &lt;database server address&gt;,  <br/>	user: &lt;user&gt;,  <br/>	password: &lt;password&gt;,  <br/>	database: &lt;name of your database schema&gt;  <br/>});</span></pre><p id="02b0" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用一个混合版本的查询方法会更方便</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="b05f" class="kx ky ie kt b fv kz la l lb lc">const util = require('util');  <br/>pool.query = util.promisify(pool.query);</span></pre><p id="e68a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们可以使用下面的代码将一条记录插入到之前创建的<strong class="jd if"> transfer </strong>表中。</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="2417" class="kx ky ie kt b fv kz la l lb lc">async  function  writeEvent(event) {  <br/>   try {  <br/>     await pool.query(  <br/>       `Insert into \`transfer\` (\`json\`) VALUES    (\'${JSON.stringify(event)}\')`  <br/>     );  <br/>   } catch(e) {  <br/>     //if it's 'duplicate record' error, do nothing; <br/>     // otherwise rethrow  <br/>     if(e.code != 'ER_DUP_ENTRY') {  <br/>       throw e;  <br/>     }  <br/>   }  <br/>}</span></pre><p id="edfd" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里我们还检查可能的重复行插入。现在我们不想在这种情况下做任何特别的事情，可能我们已经在前面写了那些重复的事件或者类似的东西。所以我们只考虑这类异常的处理。</p><h1 id="118e" class="ld ky ie bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">基本缓存功能。</h1><p id="5c1e" class="pw-post-body-paragraph jb jc ie jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">让我们构造一个契约对象来从中检索事件。</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="b7e5" class="kx ky ie kt b fv kz la l lb lc">let contract = new web3.eth.Contract(abi, &lt;contractAddress&gt;);</span></pre><p id="af9b" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以在<strong class="jd if"> abi </strong>参数中只包含<strong class="jd if">转移</strong>事件接口，如下所示:</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="e2a3" class="kx ky ie kt b fv kz la l lb lc">let abi = [{  <br/>"anonymous": false,  <br/>"inputs": [  <br/>{ "indexed": true, "name": "from", "type": "address" },  <br/>{ "indexed": true, "name": "to", "type": "address" },  <br/>{ "indexed": false, "name": "value", "type": "uint256" }  <br/>],  <br/>"name": "Transfer",  <br/>"type": "event"  <br/>}];</span></pre><p id="bde0" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是缓存功能的基本版本。首先，我们获取事件对象，然后将它们逐个写入数据库。</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="c6b3" class="kx ky ie kt b fv kz la l lb lc">async  function  cacheEvents(fromBlock, toBlock) {  <br/>    let events = await contract.getPastEvents(  <br/>    "Transfer",  <br/>    { filter: {}, fromBlock: fromBlock, toBlock: toBlock }  <br/>    );  <br/>      <br/>    for(let event in events) {  <br/>      await writeEvent(event);  <br/>    }  <br/>}</span></pre><h1 id="dcf2" class="ld ky ie bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">常规区块链扫描</h1><p id="51d0" class="pw-post-body-paragraph jb jc ie jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">现在让我们将其扩展为一个简单的后台脚本，该脚本不断扫描区块链发出的事件。</p><p id="fee1" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一些效用函数</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="ac4a" class="kx ky ie kt b fv kz la l lb lc">const timeout = 30;  <br/>function  sleep(milliseconds) {  <br/>    return  new  Promise(resolve =&gt; <br/>        setTimeout(resolve, milliseconds)<br/>    );  <br/>}  <br/>  <br/>async  function  poll (fn) {  <br/>    await fn();  <br/>    await sleep(timeout*1000);  <br/>    await poll(fn);  <br/>}</span></pre><p id="2e20" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第一个是简单的<strong class="jd if"> async/await </strong>实现<strong class="jd if"> setTimeout </strong>。第二个用于<strong class="jd if"> fn </strong>的无限周期调用——工人函数。</p><p id="7002" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有了这些辅助功能，我们的背景扫描仪看起来非常简单</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="2c57" class="kx ky ie kt b fv kz la l lb lc">async  function  scan() {  <br/>    const MaxBlockRange = 500000;  <br/>    let latestCachedBlock = 0; // latest block written to database<br/>    let latestEthBlock = 0; // latest block in blockchain  <br/>	  <br/>    await poll(async () =&gt; {  <br/>	try {  <br/>          //get latest block written to the blockchain  <br/>	  latestEthBlock = await web3.eth.getBlockNumber();  <br/>	<br/>          //divide huge block ranges to smaller chunks, <br/>          // of say 500000 blocks max  <br/>	  latestEthBlock = Math.min(<br/>            latestEthBlock, <br/>            latestCachedBlock + MaxBlockRange<br/>          );  <br/>			  <br/>	  //if it is greater than cached block, search for events  <br/>	  if(latestEthBlock &gt; latestCachedBlock) {  <br/>	    await cacheEvents(latestCachedBlock, latestEthBlock);  <br/>			  <br/>	    //if everything is OK, update cached block value  <br/>	    latestCachedBlock = latestEthBlock + 1;  <br/>	  }  <br/>	} catch (e) {  <br/>	  //we might want to add some simple logging here  <br/>	  console.log(e.toString());  <br/>	}  <br/>  });  <br/>}</span></pre><p id="3cd2" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我解释一下'<strong class="jd if">latest eth block+1【T1]'的事情。Web3的<strong class="jd if"> getPastEvents(fromBlock，toBlock) </strong>返回在那个<strong class="jd if">【from，to】</strong>范围内写的事件，包括边框。因此，如果不递增，下一个<strong class="jd if"> cacheEvents </strong>调用将再次返回写入<strong class="jd if"> latestEthBlock </strong>的事件作为结果的一部分。</strong></p><p id="0719" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">尽管由于实现了唯一的索引，重复的事件不会被插入到数据库中，但是我们仍然不希望做这些额外的工作。</p><p id="946d" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于一个简单的背景扫描仪来说，这个实现应该足够了。然而，总有改进的余地。我们稍后再回到这个话题。现在，让我们快速看一下我们现在可以利用这些数据做些什么。</p><h1 id="f8f4" class="ld ky ie bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">检索事件</h1><p id="0b84" class="pw-post-body-paragraph jb jc ie jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">下面是一个从特定地址选择转账的函数示例</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="467f" class="kx ky ie kt b fv kz la l lb lc">async  function  selectTransfersFrom(sender) {  <br/>  return  await pool.query(`select json from transfer t where t.from = \'${sender}\'`);  <br/>}</span></pre><p id="8940" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们使用从列生成的<strong class="jd if">查询数据库。这里最值得注意的部分是函数的结果看起来就像web3的<strong class="jd if"> getPastEvents </strong>的结果。这使得重构当前代码更加容易。</strong></p><h1 id="3bd1" class="ld ky ie bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">进一步的改进</h1><p id="d7ed" class="pw-post-body-paragraph jb jc ie jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">事件对象包含许多对您的应用程序可能毫无用处的属性。最好在写入数据库之前删除多余的内容。这样我们就节省了很多空间。</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="d490" class="kx ky ie kt b fv kz la l lb lc">async  function  writeEvent(event) {  <br/>    try {  <br/>	delete event.raw;  <br/>	delete event.event;  <br/>	delete event.blockHash;  <br/>	delete event.type;  <br/>	delete event.id;  <br/>	delete event.signature;  <br/>		  <br/>	await pool.query(  <br/>          `Insert into \`transfer\` (\`json\`) VALUES (\'${JSON.stringify(event)}\')`  <br/>	);  <br/>    } catch(e) {  <br/>      // if it's 'duplicate record' error, do nothing, <br/>      // otherwise rethrow  <br/>      if(e.code != 'ER_DUP_ENTRY') {  <br/>	throw e;  <br/>      }  <br/>  }  <br/>}</span></pre><p id="ca0e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您可能也注意到了，当前版本的扫描器每次重新启动时都从#0块开始。当一直扫描到当前块时，它会尝试将重复记录插入到数据库中。我们可以通过在数据库中查询最新的缓存块来消除这些额外的工作。</p><p id="e5bb" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">不从块#0开始扫描也不错，但至少在部署契约时从块开始扫描。为了简单起见，您可以使用<a class="ae jz" href="http://etherscan.io/" rel="noopener ugc nofollow" target="_blank"> etherscan.io </a>来获得这些信息。</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="000a" class="kx ky ie kt b fv kz la l lb lc">async function getLatestCachedBlock() {  <br/>  const defaultInitialBlock = &lt;your contract’s deployment block&gt;;  <br/>	  <br/>  let dbResult = await pool.query(  <br/>    'select json_unquote(json_extract(`json`,\'$.blockNumber\')) \  <br/>	as block from transfer order by id desc limit 1'  <br/>    );  <br/>	<br/>  return dbResult.length &gt; 0 ? <br/>    parseInt(dbResult[0].block) : <br/>    defaultInitialBlock;  <br/>}</span></pre><p id="0b92" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里我们再次使用MySQL json函数来获取事件对象的<strong class="jd if"> blockNumber </strong>属性。</p><p id="675e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后更换旧的<strong class="jd if">扫描</strong>功能</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="63e4" class="kx ky ie kt b fv kz la l lb lc">let latestCachedBlock = 0;</span></pre><p id="c78e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有了新的</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="141e" class="kx ky ie kt b fv kz la l lb lc">let latestCachedBlock = await getLatestCachedBlock();</span></pre><h1 id="efaf" class="ld ky ie bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated">结论</h1><p id="372e" class="pw-post-body-paragraph jb jc ie jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">最后，我们创建了一个简单但有效的事件扫描器，它可以不断地将事件缓存到MySQL数据库中。如果您有任何问题，请随时联系我，我会尽力回答。</p><p id="1602" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">完整的源代码可以在这里找到<a class="ae jz" href="https://github.com/olekon/p1_eth_caching" rel="noopener ugc nofollow" target="_blank">https://github.com/olekon/p1_eth_caching</a>。</p><blockquote class="mk"><p id="d04b" class="ml mm ie bd mn mo mp mq mr ms mt jy ek translated"><a class="ae jz" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mv mw mx my mz hv fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mu"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>