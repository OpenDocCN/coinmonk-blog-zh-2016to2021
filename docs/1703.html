<html>
<head>
<title>Part 2: Implementing Blockchain and Cryptocurrency with PoW consensus algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第2部分:用PoW共识算法实现区块链和加密货币</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-in-node-js-part-2-4524d0bf36a1?source=collection_archive---------2-----------------------#2018-10-25">https://medium.com/coinmonks/implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-in-node-js-part-2-4524d0bf36a1?source=collection_archive---------2-----------------------#2018-10-25</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="5bd4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在node.js中使用工作共识算法证明，小规模、易于理解、全面、逐步实施区块链和加密货币</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/ca1a2e2c4224dbbeb2b00eaca6e45a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*4tiX8RcB0DnrDZZ0l8yxGw.jpeg"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Source: <a class="ae ka" href="https://en.bitcoinwiki.org/wiki/Proof-of-work" rel="noopener ugc nofollow" target="_blank">Bitcoin Wiki</a></figcaption></figure><p id="8f9a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<a class="ae ka" rel="noopener" href="/coinmonks/implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-part-1-545fb32be0c2">的上一篇文章</a>中，我们介绍了区块链和工作证明，还讨论了我们将要实现的代码的设计和架构。</p><p id="f2b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这篇文章中，我们将开始动手。</p><h1 id="82d6" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">先决条件:</h1><ol class=""><li id="488a" class="kz la ht is b it lb ix lc jb ld jf le jj lf jn lg lh li lj dt translated"><a class="ae ka" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>和<a class="ae ka" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a></li><li id="da7a" class="kz la ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated"><a class="ae ka" href="https://code.visualstudio.com/download" rel="noopener ugc nofollow" target="_blank">文本编辑器</a>(带有深色主题😛)</li><li id="eee4" class="kz la ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated"><a class="ae ka" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>或任何其他app与HTTP APIs交互。</li></ol><p id="ca4e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="lp">就是这样。</em> </strong></p><h1 id="f0a1" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">让我们编码:</h1><p id="5f1b" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">我们将从创建项目的根目录开始。为您的项目命名。假设是Nodechain。</p><pre class="jp jq jr js fq lt lu lv lw aw lx dt"><span id="8bba" class="ly kc ht lu b fv lz ma l mb mc">mkdir nodechain<br/>cd nodechain</span></pre><p id="27c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">创建新的节点项目</p><pre class="jp jq jr js fq lt lu lv lw aw lx dt"><span id="ae35" class="ly kc ht lu b fv lz ma l mb mc">npm init -y</span></pre><p id="3a28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们需要一个名为nodemon的包来运行我们的开发服务器，并在每次保存时重新加载服务器。这个工具让我们免去了很多麻烦。</p><pre class="jp jq jr js fq lt lu lv lw aw lx dt"><span id="adc4" class="ly kc ht lu b fv lz ma l mb mc">npm install nodemon --save-dev</span></pre><p id="bd10" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好吧。继续前进。</p><h1 id="ae01" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">街区</h1><p id="9d8a" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">区块链是由块组成的，所以让我们创建一个块类。块有4个主要属性:</p><p id="745c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">时间戳—块的创建时间，以毫秒为单位</p><p id="2c38" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">lastHash —链上最后一个块的哈希</p><p id="8a5d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">哈希-当前块的哈希</p><p id="427c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">数据—块或事务中的数据</p><p id="279f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，在根目录下创建一个新文件<code class="eh md me mf lu b">block.js</code>,并创建一个具有这些属性的类。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">The block class</figcaption></figure><p id="5cfd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">同样，让我们添加一个<code class="eh md me mf lu b">toString()</code>函数，它将以可读的格式打印块的细节。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">A readable printing function</figcaption></figure><p id="66c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在区块链中，每个数据块的哈希值是根据之前数据块的哈希值计算的。</p><p id="47c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于在链的开始没有积木，区块链有了创世纪积木的概念。创世街区服务于成为区块链起源的目的。这是一个硬编码的块，包含时间戳、lastHash、Hash和数据值的虚拟值。</p><p id="88a6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们用一些硬编码值给我们的块类添加一个静态的<code class="eh md me mf lu b">genesis()</code>函数。该函数将创建一个带有虚拟值的新块。这是静态的，因为我们不想创建一个实例来调用这个函数。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">What came first egg? Chicken? No the genesis block.</figcaption></figure><p id="9715" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来我们要添加到block类中的是基于数据和最后一个散列创建新块的能力。姑且称之为<code class="eh md me mf lu b">mineBlock()</code></p><p id="dc02" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个静态的<code class="eh md me mf lu b">mineBlock()</code>函数接受两个参数，最后一个块和数据，并基于这两项生成一个新的块。我们在整个项目中的许多功能将是静态的。</p><p id="3f3e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了生成哈希值，我们需要名为<code class="eh md me mf lu b">crypto-js</code>的节点包，让我们安装它。</p><pre class="jp jq jr js fq lt lu lv lw aw lx dt"><span id="1642" class="ly kc ht lu b fv lz ma l mb mc">npm i crypto-js --save</span></pre><p id="74b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从该模块导入sha-256函数。</p><pre class="jp jq jr js fq lt lu lv lw aw lx dt"><span id="9f59" class="ly kc ht lu b fv lz ma l mb mc">const SHA256 = require('crypto-js/sha256');</span></pre><p id="8154" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们不会直接使用散列函数，相反，我们将创建一个单独的函数，因为我们将来还会用到它。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">The backticks and dollar syntax, that’s ES6.</figcaption></figure><p id="2b4e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们用上面所有的东西创建一个<code class="eh md me mf lu b">mineBlock()</code>函数。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="c37c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将很快在这里添加更多的功能。</p><p id="5a8b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是我们到目前为止创建的块类。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">The Block</figcaption></figure><p id="54e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们已经创建了块类，我们必须测试它。为了测试这个类，我们最好创建一个测试环境。对于这个项目，我们将使用jest。</p><pre class="jp jq jr js fq lt lu lv lw aw lx dt"><span id="4b82" class="ly kc ht lu b fv lz ma l mb mc">npm i jest --save-dev</span></pre><p id="308e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lp">注意:如果你在安装jest时遇到问题，我曾经有过，试着降级到一个较低的版本，它对我很有效。</em></p><p id="1310" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用jest，我们可以在javascript项目中执行测试文件。为了找到测试文件，jest将查找扩展名为*.test.js的文件，因此为了测试我们的block类，让我们创建一个block.test.js文件。</p><p id="de0f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们创建一些测试用例。我们将测试构造函数、genesis、hash和mineBlock是否按预期工作。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Sweet tests</figcaption></figure><p id="0a61" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要运行该文件，请对package.json文件中的脚本进行一些更改。在其中添加一个测试脚本。</p><pre class="jp jq jr js fq lt lu lv lw aw lx dt"><span id="438a" class="ly kc ht lu b fv lz ma l mb mc">"test": "jest --watchAll"</span></pre><p id="3c89" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们来做测试。</p><pre class="jp jq jr js fq lt lu lv lw aw lx dt"><span id="e628" class="ly kc ht lu b fv lz ma l mb mc">npm run test</span></pre><p id="95c1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将通过两次测试，表明我们的功能运行良好。</p><p id="2b25" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">检查测试是否正常。对测试文件进行一些更改，然后再次运行测试。你会发现测试会失败。</p><p id="371d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">酷毙了。我们已经创建了一个基本块。让我们继续创建一个区块链类来链接这些块。</p><h1 id="93e0" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">区块链</h1><p id="185d" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hm dt translated">在根目录下创建一个<code class="eh md me mf lu b"> blockchain.js</code>文件。要创建区块链类，我们需要导入block类。</p><p id="1e8a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在构造函数中，我们会给链一个初始块。这里，我们将利用我们创建的静态genesis函数来开始我们的链。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">The blockchain class</figcaption></figure><p id="3855" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，让我们通过创建一个<code class="eh md me mf lu b">addBlock(data)</code>函数，给我们的区块链类添加更多块的能力。</p><p id="4c1b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里，我们将使用我们的<code class="eh md me mf lu b">mineBlock()</code>函数创建一个新的块，然后将它推送到链中。我们将访问链上的最后一个块，然后使用传递给<code class="eh md me mf lu b">addBLock()</code>的数据调用<code class="eh md me mf lu b">mineBlock()</code>函数</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">adding new block to the chain</figcaption></figure><p id="f964" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是我们的blockchain.js文件到目前为止的样子。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">The Blockchain</figcaption></figure><p id="84fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">酷毙了。考验我们区块链的时候到了。创建一个blockchain.test.js文件。</p><p id="26df" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们添加几个测试用例。</p><p id="5c1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将创建两个变量<code class="eh md me mf lu b">blockchain</code>，它们也将用于添加块。现在让我们测试一下<code class="eh md me mf lu b">addBlock()</code>函数。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Sweet tests</figcaption></figure><p id="7a2c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行测试，现在您将看到4个测试通过。</p><p id="e09a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，我们将向区块链添加更多功能来支持多个参与者。</p><p id="f698" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae ka" rel="noopener" href="/coinmonks/part-3-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-d9b8cb928e3e">第三部分:用PoW共识算法实现区块链和加密货币</a></p></div><div class="ab cl mi mj hb mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hm hn ho hp hq"><p id="1fdc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lp">感谢您的阅读。</em> <strong class="is hu"> <em class="lp">在下一部分中，我们将编写代码来验证区块链并添加对多个矿工的支持。</em> </strong> <em class="lp">希望你喜欢编码。如果你发现这很有帮助，请鼓掌。</em>T13】</p><p id="4ed5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你对区块链、以太坊或整个世界有任何疑问，请发表评论。:)</p><blockquote class="mp"><p id="5702" class="mq mr ht bd ms mt mu mv mw mx my jn ek translated"><a class="ae ka" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="na nb nc nd ne jt fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mz"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>