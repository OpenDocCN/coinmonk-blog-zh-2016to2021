<html>
<head>
<title>Deferred Transactions on EOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">EOS上的延期交易</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/deferred-transactions-on-eos-2418da961a43?source=collection_archive---------6-----------------------#2018-12-19">https://medium.com/coinmonks/deferred-transactions-on-eos-2418da961a43?source=collection_archive---------6-----------------------#2018-12-19</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div class="fe ff hr"><img src="../Images/7015db2f1d1dc3a07094b83e3f9af14f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*G38-QuOA1uoVSsoU.jpg"/></div></figure><div class=""/><p id="f2ca" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">EOS有两种方式发送动作，<em class="jv">内嵌</em>和<em class="jv">延迟</em>。内联动作可以直观地被视为同步执行，而延迟动作则被视为异步代码。<strong class="iz ib">内嵌动作</strong>可以从一个契约中派生出来，然后在与原始动作相同的事务中执行。它们是可靠的，因为它们被保证执行，并且它们可以使整个事务失败，恢复同一事务的先前动作的任何改变。(事务是在同一个块中执行的动作的列表。)</p><p id="20f4" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz ib">延期行动</strong>是由合同安排在未来某个时间执行的行动。<em class="jv">内联</em>动作的最大区别是它们甚至不能保证运行。该事务也可以被节点丢弃。同样，如果它们失败，调度延迟动作的事务是<em class="jv">而不是</em>恢复的。事实上，没有办法恢复它们，在执行延迟事务时，它们已经应用于前一个块中的区块链。延迟的事务也可以从代码中再次取消。</p><blockquote class="jw jx jy"><p id="cbc3" class="ix iy jv iz b ja jb jc jd je jf jg jh jz jj jk jl ka jn jo jp kb jr js jt ju hm dt translated">推迟的动作被安排在最好的情况下，在稍后的时间运行，由生产者决定。不能保证延迟的操作会被执行。<a class="ae kc" href="https://developers.eos.io/eosio-cpp/docs/communication-model#section-deferred-communication" rel="noopener ugc nofollow" target="_blank"> EOS开发门户</a></p></blockquote><p id="b1bc" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">由于延期交易的巨大缺点，人们可能会怀疑是否应该使用延期交易。延期交易肯定有其存在的权利。除了将来以编程方式安排一个动作的明显原因之外，它们还可以用于<strong class="iz ib">任何非必要的事情</strong>。EOSIO软件仅提供一定量的毫秒(30ms)来执行事务。注意，这个限制适用于<em class="jv">事务</em>，它的动作列表和产生的内联动作。延迟事务提供了一种绕过这种限制的方法，因为它们是在新事务中运行的。非必要的动作，如登录，或者可以由用户在不执行时再次手动触发的动作，如在跟踪余额的赌博合同中提取资金，可以被实现为延迟动作。</p><blockquote class="jw jx jy"><p id="5812" class="ix iy jv iz b ja jb jc jd je jf jg jh jz jj jk jl ka jn jo jp kb jr js jt ju hm dt translated">每个交易必须在30毫秒或更短时间内执行。如果一个事务包含多个操作，并且这些操作的总和大于30毫秒，则整个事务将失败。在对它们的操作没有并发性要求的情况下，这可以通过将消耗CPU的操作包含在单独的事务中来规避。<a class="ae kc" href="https://developers.eos.io/eosio-cpp/docs/communication-model#section-transaction-limitations" rel="noopener ugc nofollow" target="_blank"> EOS开发门户</a></p></blockquote><p id="37cb" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">以下是如何在EOS中创建延期交易:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="6b72" class="km kn ia ki b fv ko kp l kq kr">#include &lt;eosiolib/transaction.hpp&gt; // include this for transactions<br/><br/>class deferred_example : public eosio::contract<br/>{<br/>  public:<br/>    using contract::contract;<br/><br/>    // this action will be called by the deferred transaction<br/>    ACTION deferred(name from, const string &amp;message)<br/>    {<br/>        require_auth(from);<br/>        print("Printing deferred ", from, message);<br/>    }<br/><br/>    ACTION send(name from, const string &amp;message, uint64_t delay)<br/>    {<br/>        require_auth(from);<br/><br/>        eosio::transaction t{};<br/>        // always double check the action name as it will fail silently<br/>        // in the deferred transaction<br/>        t.actions.emplace_back(<br/>            // when sending to _self a different authorization can be used<br/>            // otherwise _self must be used<br/>            permission_level(from, "active"_n),<br/>            // account the action should be send to<br/>            _self,<br/>            // action to invoke<br/>            "deferred"_n,<br/>            // arguments for the action<br/>            std::make_tuple(from, message));<br/><br/>        // set delay in seconds<br/>        t.delay_sec = delay;<br/><br/>        // first argument is a unique sender id<br/>        // second argument is account paying for RAM<br/>        // third argument can specify whether an in-flight transaction<br/>        // with this senderId should be replaced<br/>        // if set to false and this senderId already exists<br/>        // this action will fail<br/>        t.send(now(), from /*, false */);<br/><br/>        print("Scheduled with a delay of ", delay);<br/>    }<br/>};<br/><br/>EOSIO_DISPATCH(deferred_example, (send)(deferred))</span></pre><p id="8cb2" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">该代码类似于发送内联操作的代码。不同之处在于，我们需要先创建一个新的空事务。发送交易时，需要指定<em class="jv">发送方id </em>。此id在您的合同发送的所有延期交易中必须是唯一的。它可用于识别对错误处理有用的事务，并在取消仍在<em class="jv">进行中的</em>即尚未执行的延迟事务时需要该事务。如果无法从您的合同上下文中创建唯一的发送方id，您可以为您的延期交易id创建一个计数器，并将其存储在合同中的一个<code class="eh ks kt ku ki b">eosio::singleton</code>中。调度延迟事务的工作原理是将事务“存放”在区块链上，这需要事务大小的RAM。可以指定付款人，并要求其授权。</p><p id="60ed" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">要取消与<code class="eh ks kt ku ki b">sender_id</code>的正在进行的交易，只需调用<code class="eh ks kt ku ki b">cancel_deferred(sender_id)</code>。</p><p id="9e6b" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">当延期交易失败时，<code class="eh ks kt ku ki b">eosio</code>向您的合同发送一个<code class="eh ks kt ku ki b">onerror</code>动作，带有<code class="eh ks kt ku ki b">sender_id</code>和交易数据:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="68a8" class="km kn ia ki b fv ko kp l kq kr">class deferred_example : public eosio::contract<br/>{<br/>    // ...<br/><br/>    void onError(const onerror &amp;error)<br/>    {<br/>        // this function should have a counter to not retry forever<br/>        print("Resending Transaction: ", error.sender_id);<br/>        transaction dtrx = error.unpack_sent_trx();<br/>        dtrx.delay_sec = 3;<br/>        dtrx.send(now(), _self);<br/>    }<br/><br/>    // ...<br/>};<br/><br/>extern "C" void apply(uint64_t receiver, uint64_t code, uint64_t action)<br/>{<br/>    if (code == "eosio"_n.value &amp;&amp; action == "onerror"_n.value)<br/>    {<br/>        eosio::execute_action(eosio::name(receiver), eosio::name(code), &amp;deferred_example::onError);<br/>    }<br/>    // ...<br/>}</span></pre><p id="0aa8" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">延迟事务导致<em class="jv">防御性编程</em>技术。您永远无法确定该操作是否被实际执行，因此您的契约需要在其表中表示当前状态，并重试该操作。如果延迟的事务会影响用户，比如发送资金，您应该总是有一个单独的操作，以非延迟的方式实现逻辑，并且可以由用户手动触发，比如取款操作。必要的核心逻辑应该由初始操作或内联操作来处理。</p><p id="a0f0" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">延迟事务在安排它的契约的许可下运行。这个契约还为产生的动作支付CPU /网络带宽成本。</p><blockquote class="jw jx jy"><p id="8f62" class="ix iy jv iz b ja jb jc jd je jf jg jh jz jj jk jl ka jn jo jp kb jr js jt ju hm dt translated">延期交易具有发送它们的合同的权威。<a class="ae kc" href="https://developers.eos.io/eosio-cpp/docs/communication-model#section-deferred-communication" rel="noopener ugc nofollow" target="_blank"> EOS开发门户</a></p></blockquote><p id="9cb2" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">请注意，延期交易只能提前45天安排。但是，您可以通过让延迟操作重复调度新的延迟事务，直到达到您想要的时间跨度，来解决这个问题。同样，这很容易失败，应该尽可能避免。</p><p id="929b" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">下面是EOS主网上关于事务的一些其他有趣的<a class="ae kc" href="https://github.com/CryptoLions/EOS-MainNet/blob/master/genesis.json" rel="noopener ugc nofollow" target="_blank">配置设置</a>。</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="d057" class="km kn ia ki b fv ko kp l kq kr">{<br/>  "initial_configuration": {<br/>    // ...<br/>    // the maximum billable cpu usage (in microseconds) that the chain will allow regardless of account limits<br/>    "max_transaction_cpu_usage": 150000,<br/>    // the minimum billable cpu usage (in microseconds) that the chain requires<br/>    "min_transaction_cpu_usage": 100,<br/>    // the maximum number of seconds that an input transaction's expiration can be ahead of the time of the block in which it is first included<br/>    "max_transaction_lifetime": 3600,<br/>    // the number of seconds _after_ the time a deferred transaction can first execute until it expires<br/>    "deferred_trx_expiration_window": 600,<br/>    // the maximum number of seconds that can be imposed as a delay requirement by authorization checks<br/>    // 45 days<br/>    "max_transaction_delay": 3888000,<br/>    "max_inline_action_size": 4096,<br/>    "max_inline_action_depth": 4,<br/>    "max_authority_depth": 6<br/>  }<br/>}</span></pre><p id="2e34" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这意味着我们可以提前45天安排事务，节点在事务到期前有10分钟时间执行事务。不幸的是，如果一个事务过期并且从未执行过，那么在您的合同的<code class="eh ks kt ku ki b">onerror</code>回调中不会通知您没有执行。这个<code class="eh ks kt ku ki b">onerror</code>动作只有在事务首先被执行，但由于断言错误而失败时才被调用。</p><p id="5b66" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">如果你想更多地了解EOS的沟通模式，<a class="ae kc" href="https://developers.eos.io/eosio-cpp/docs/communication-model" rel="noopener ugc nofollow" target="_blank">这篇文章</a>很有帮助。</p><figure class="kd ke kf kg fq hv fe ff paragraph-image"><a href="https://learneos.one#modal"><div class="fe ff kv"><img src="../Images/e69b8309c521ad6eb94c726beee8a1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zWuY6amxU1J-aFHO.png"/></div></a></figure></div><div class="ab cl kw kx hb ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hm hn ho hp hq"><p id="8f8d" class="pw-post-body-paragraph ix iy ia iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">最初发表于<a class="ae kc" href="https://cmichel.io/deferred-transactions-on-eos/" rel="noopener ugc nofollow" target="_blank"> cmichel.io </a></p><figure class="kd ke kf kg fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff ld"><img src="../Images/449450761cd76f44f9ae574333f9e9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKX2mtg7p1lOs7JmosPLsA.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek"><a class="ae kc" href="http://bit.ly/2G71Sp7" rel="noopener ugc nofollow" target="_blank">👆 <strong class="bd lm">Click to read today’s top story</strong> 👆</a></figcaption></figure><blockquote class="ln"><p id="eff4" class="lo lp ia bd lq lr ls lt lu lv lw ju ek translated"><a class="ae kc" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ly lz ma mb mc hv fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lx"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>