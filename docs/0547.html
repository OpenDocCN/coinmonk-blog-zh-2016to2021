<html>
<head>
<title>Write your next Ethereum Contract in Pyramid Scheme</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在传销中写下你的下一份以太坊合同</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/write-your-next-ethereum-contract-in-pyramid-scheme-6b6e4deadf2f?source=collection_archive---------11-----------------------#2018-05-16">https://medium.com/coinmonks/write-your-next-ethereum-contract-in-pyramid-scheme-6b6e4deadf2f?source=collection_archive---------11-----------------------#2018-05-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="b19a" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">Michael Burge创建<strong class="ak">金字塔</strong>:Scheme编程语言的一种方言，目标是以太坊虚拟机(EVM)。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ji"><img src="../Images/059762b3ffdcbe56dd6a52a6ec108f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*sN6fSA91cTjQwekT.jpg"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek"><a class="ae ju" href="https://twitter.com/PyramidLang" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="https://cryptofi.co/"><div class="fe ff jv"><img src="../Images/8eb99069c498a3c388e6b629c28eb400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*48iQrDOfp0En9N1bYAgW7g.png"/></div></a><figcaption class="jq jr fg fe ff js jt bd b be z ek"><strong class="bd jw">Create Crypto Invoices</strong></figcaption></figure><p id="29be" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated"><a class="ae ju" href="https://cryptofi.co/" rel="noopener ugc nofollow" target="_blank"> <strong class="jz hu"> <em class="kt"> Cryptofi —创建加密发票，跟踪您的加密支付</em> </strong> </a></p><blockquote class="ku kv kw"><p id="413f" class="jx jy kt jz b ka kb iu kc kd ke ix kf kx kh ki kj ky kl km kn kz kp kq kr ks hm dt translated"><strong class="jz hu">署名</strong> —这是<a class="ae ju" href="https://twitter.com/TheMichaelBurge" rel="noopener ugc nofollow" target="_blank"> Michael Burge的</a>博客文章<br/> <a class="ae ju" href="https://www.michaelburge.us/2017/11/28/write-your-next-ethereum-contract-in-pyramid-scheme.html" rel="noopener ugc nofollow" target="_blank">在传销中写下你的下一份以太坊合同</a>的转载作品，虽然这篇文章最初发布于2017年11月28日，但很少有部分是不准确的，因此要获得更新的信息，请查看这篇文章(<a class="ae ju" rel="noopener" href="/coinmonks/dsls-for-ethereum-contracts-380136177abd">以太坊合同的DSL</a>)。</p></blockquote></div><div class="ab cl la lb hb lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hm hn ho hp hq"><p id="5b22" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt lh translated">askell程序员经常在象牙塔里写代码，脑袋却在云里。在这个由多个部分组成的文章系列中，我们将尝试深入到C级以下。</p><p id="1560" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">我创建了<strong class="jz hu">金字塔</strong>:Scheme编程语言的一种方言，目标是以太坊虚拟机(EVM)。利用名副其实的<a class="ae ju" href="http://racket-lang.org/" rel="noopener ugc nofollow" target="_blank">球拍</a>实施传销。金字塔编译器目前有3512行代码，包括来自计算机程序的结构和解释的代码。</p><p id="8412" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">本文涵盖了金字塔编译器的高级设计:编译器的组件和金字塔的运行时环境。</p><p id="5afd" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">对Scheme、编译器或以太坊感兴趣的人会喜欢这个系列。最后，我将使用Pyramid来预订一本新书:<strong class="jz hu">用数学颠覆民族国家:以太坊黑客手册</strong>。鼓励读者订阅邮件列表以接收新文章。</p><h1 id="48b0" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">概观</h1><p id="ac94" class="pw-post-body-paragraph jx jy ht jz b ka mi iu kc kd mj ix kf kg mk ki kj kk ml km kn ko mm kq kr ks hm dt translated">金字塔编译器将纯文本转换成可执行的EVM代码。它的5个组成部分是:</p><ul class=""><li id="1a4c" class="mn mo ht jz b ka kb kd ke kg mp kk mq ko mr ks ms mt mu mv dt translated"><strong class="jz hu">解析器</strong>:将纯文本转换成AST。球拍通过其内置的<a class="ae ju" href="https://docs.racket-lang.org/reference/Reading.html#%28def._%28%28quote._~23~25kernel%29._read%29%29" rel="noopener ugc nofollow" target="_blank">阅读器</a>使这变得容易。</li><li id="5866" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated">编译器:SICP模式编译器的目标是一个有5个寄存器、8个操作、一个堆栈和13个内置操作的抽象机器。</li><li id="8ad0" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated"><strong class="jz hu">代码生成器</strong>:将抽象机器码转换成EVM汇编。</li><li id="42bc" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated">串行化器:将EVM汇编转换成可部署的EVM字节码。</li><li id="2fff" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated"><strong class="jz hu">调试器</strong>:模拟反汇编EVM字节码的Google Sheets脚本。</li></ul><p id="1918" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">金字塔计划的一个例子是</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="bc58" class="ng lr ht nc b fv nh ni l nj nk">(<strong class="nc hu">begin</strong><br/> (<strong class="nc hu">define</strong> (<strong class="nc hu">factorial</strong> n)<br/>  (<strong class="nc hu">if</strong> (= n 1)<br/>      1<br/>      (* n (<strong class="nc hu">factorial</strong> (- n 1)))))<br/> (<strong class="nc hu">factorial</strong> 5))</span></pre><p id="876a" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">。金字塔编译器输出一个长的十六进制字符串，可以使用<a class="ae ju" href="https://github.com/ethereum/web3.js/" rel="noopener ugc nofollow" target="_blank"> Web3 </a>库将其部署到一个真实的以太坊区块链:</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="94a3" class="ng lr ht nc b fv nh ni l nj nk"><strong class="nc hu">var</strong> <strong class="nc hu">from</strong> <strong class="nc hu">=</strong> "0x0703722a41e9ec7a0497043380a3cc6b16eb242d";<br/><strong class="nc hu">var</strong> code <strong class="nc hu">=</strong> "The output of the Pyramid compiler";<br/><strong class="nc hu">var</strong> gas <strong class="nc hu">=</strong> 10000000;<br/><br/><strong class="nc hu">var</strong> g_transactionHash;<br/><br/>web3.eth.sendTransaction({from: <strong class="nc hu">from</strong>, data: code, gas: gas}, <strong class="nc hu">function</strong>(err, transactionHash) {<br/>    g_transactionHash <strong class="nc hu">=</strong> transactionHash;<br/>});<br/><br/><strong class="nc hu">var</strong> receipt <strong class="nc hu">=</strong> web3.eth.getTransactionReceipt(g_transactionHash);<br/><br/>web3.eth.call({ from: <strong class="nc hu">from</strong>, to: receipt.contractAddress });<br/><em class="kt">// Output:</em><br/><em class="kt">// "0x0000000000000000000000000000000000000000000000000000000000000078"</em><br/><em class="kt">// Note: factorial(5) = 120 = 0x78</em></span></pre><p id="13ba" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">金字塔的完整语法是</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="d68d" class="ng lr ht nc b fv nh ni l nj nk"><em class="kt">; Constants</em><br/>5      <em class="kt">; Decimal integers</em><br/>#xff   <em class="kt">; Hexadecimal integers</em><br/>'hello <em class="kt">; Symbols - up to 32 8-bit ASCII characters</em><br/><br/><em class="kt">; Variables</em><br/>(<strong class="nc hu">define</strong> x 5)<br/>(<strong class="nc hu">set!</strong> x 10)<br/>x<br/><br/><em class="kt">; Conditional Execution</em><br/>(<strong class="nc hu">if</strong> true 10 100)<br/>(<strong class="nc hu">cond</strong> ((eq? x 'red)   #xff0000)<br/>      ((eq? x 'green) #x00ff00)<br/>      (<strong class="nc hu">else</strong>           #x0000ff))<br/><br/><em class="kt">; Sequential Execution</em><br/>(<strong class="nc hu">begin</strong><br/>  (<strong class="nc hu">define</strong> x 5)<br/>  (<strong class="nc hu">define</strong> y 6))<br/><br/><em class="kt">; Procedures</em><br/>(<strong class="nc hu">lambda</strong> (<strong class="nc hu">x</strong>) (* x x))        <em class="kt">; Anonymous</em><br/>(<strong class="nc hu">define</strong> (<strong class="nc hu">square</strong> x) (* x x)) <em class="kt">; Named</em><br/>(<strong class="nc hu">square</strong> 5)</span></pre><p id="c0a5" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">。所有其他语言特性都由<strong class="jz hu">金字塔标准库</strong>提供，它们是启动时安装到程序环境中的程序和变量定义。</p><h1 id="e818" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">抽象机器</h1><p id="eb16" class="pw-post-body-paragraph jx jy ht jz b ka mi iu kc kd mj ix kf kg mk ki kj kk ml km kn ko mm kq kr ks hm dt translated">金字塔解析后编译成<strong class="jz hu">抽象机器码</strong>。</p><p id="0355" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">在给出完整的语言之前，我将展示每种语法翻译成抽象机器代码的例子。编译器在SICP存档。</p><h1 id="7858" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">变量</h1><p id="b643" class="pw-post-body-paragraph jx jy ht jz b ka mi iu kc kd mj ix kf kg mk ki kj kk ml km kn ko mm kq kr ks hm dt translated">可以定义、修改和访问变量:</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="3a7e" class="ng lr ht nc b fv nh ni l nj nk">(<strong class="nc hu">define</strong> x 1234)<br/>(<strong class="nc hu">set!</strong> x 10)<br/>x</span></pre><p id="0454" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">定义<code class="eh nl nm nn nc b">(define x 1234)</code>编译成</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="c773" class="ng lr ht nc b fv nh ni l nj nk">(<strong class="nc hu">assign</strong> 'val (<strong class="nc hu">op</strong> 'box ((<strong class="nc hu">const</strong> 1234))))<br/>(<strong class="nc hu">perform</strong> (<strong class="nc hu">op</strong> 'define-variable! ((<strong class="nc hu">const</strong> 'x) (<strong class="nc hu">reg</strong> 'val) (<strong class="nc hu">reg</strong> 'env))))</span></pre><p id="39a5" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">。整数<code class="eh nl nm nn nc b">1234</code>被<strong class="jz hu">装箱</strong>，一个指向它的指针存储在<code class="eh nl nm nn nc b">val</code>寄存器中。普通整数没有类型:它们可能会被混淆为指针或符号。装箱将类型附加到值上。装箱的值总是指针。</p><p id="8f00" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">基本操作<code class="eh nl nm nn nc b">define-variable!</code>有三个参数:要定义的名称、要设置的值和环境。<code class="eh nl nm nn nc b">env</code>寄存器保存当前的环境。</p><p id="62b9" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">接下来的两行类似:</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="ae7d" class="ng lr ht nc b fv nh ni l nj nk"><em class="kt">; (set! x 10)</em><br/>(<strong class="nc hu">assign</strong> 'val (<strong class="nc hu">op</strong> 'box ((<strong class="nc hu">const</strong> 10))))<br/>(<strong class="nc hu">perform</strong> (<strong class="nc hu">op</strong> 'set-variable-value! ((<strong class="nc hu">const</strong> 'x) (<strong class="nc hu">reg</strong> 'val) (<strong class="nc hu">reg</strong> 'env))))<br/><br/><em class="kt">; x</em><br/>(<strong class="nc hu">assign</strong> 'val (<strong class="nc hu">op</strong> 'lookup-variable-value ((<strong class="nc hu">const</strong> 'x) (<strong class="nc hu">reg</strong> 'env))))</span></pre><p id="f0cf" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated"><code class="eh nl nm nn nc b">val</code>寄存器保存一个参数，或者一个操作的输出。通常，最后执行的金字塔语句将其结果存储在<code class="eh nl nm nn nc b">val</code>中。</p><h1 id="d42e" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">条件式</h1><p id="14a7" class="pw-post-body-paragraph jx jy ht jz b ka mi iu kc kd mj ix kf kg mk ki kj kk ml km kn ko mm kq kr ks hm dt translated"><code class="eh nl nm nn nc b">if</code>语句评估为其<strong class="jz hu">真分支</strong>或其<strong class="jz hu">假分支</strong>。该表达式</p><p id="6376" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated"><code class="eh nl nm nn nc b">(<strong class="jz hu">if</strong> true 10 100)</code></p><p id="901c" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">评估为<code class="eh nl nm nn nc b">10</code>，因为条件是<code class="eh nl nm nn nc b">true</code>并且10是真分支。</p><p id="3358" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated"><code class="eh nl nm nn nc b">if</code>不能是标准库过程，因为过程调用评估所有参数。<code class="eh nl nm nn nc b">if</code>语句有两个分支，但只计算一个。</p><p id="8309" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">那条<code class="eh nl nm nn nc b">if</code>语句编译成</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="1a54" class="ng lr ht nc b fv nh ni l nj nk"><em class="kt">; true is defined as 1</em><br/>(<strong class="nc hu">assign</strong> 'val (<strong class="nc hu">op</strong> 'lookup-variable-value ((<strong class="nc hu">const</strong> 'true) (<strong class="nc hu">reg</strong> 'env))))<br/><br/><em class="kt">; branch skips code depending on the test</em><br/>(<strong class="nc hu">test</strong> (<strong class="nc hu">op</strong> 'false? ((<strong class="nc hu">reg</strong> 'val))))<br/>(<strong class="nc hu">branch</strong> (<strong class="nc hu">label</strong> 'false-branch2))<br/><br/><em class="kt">; branch did not skip</em><br/>(<strong class="nc hu">label</strong> 'true-branch1)<br/>(<strong class="nc hu">assign</strong> 'val (<strong class="nc hu">op</strong> 'box ((<strong class="nc hu">const</strong> 10))))<br/>(<strong class="nc hu">goto</strong> (<strong class="nc hu">label</strong> 'after-if3))<br/><br/><em class="kt">; branch skipped</em><br/>(<strong class="nc hu">label</strong> 'false-branch2)<br/>(<strong class="nc hu">assign</strong> 'val (<strong class="nc hu">op</strong> 'box ((<strong class="nc hu">const</strong> 100))))<br/><br/>(<strong class="nc hu">label</strong> 'after-if3)</span></pre><p id="c94d" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">。<code class="eh nl nm nn nc b">if</code>将其结果存储在<code class="eh nl nm nn nc b">val</code>中，因为每个分支将其结果存储在<code class="eh nl nm nn nc b">val</code>中。</p><h1 id="f12f" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">程序</h1><p id="a8cd" class="pw-post-body-paragraph jx jy ht jz b ka mi iu kc kd mj ix kf kg mk ki kj kk ml km kn ko mm kq kr ks hm dt translated">过程定义是设置为Lambda的变量定义。一个Lambda创建一个<strong class="jz hu">编译好的程序</strong>，它是一个代码指针，也是一个环境。编译程序通过跳转到代码指针进入，通过跳转到<code class="eh nl nm nn nc b">continue</code>寄存器退出。</p><p id="b79c" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">下面是最简单的过程定义:</p><p id="2964" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated"><code class="eh nl nm nn nc b">(<strong class="jz hu">define</strong> (<strong class="jz hu">id</strong> x) x)</code></p><p id="d4d3" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">它编译成:</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="9fe0" class="ng lr ht nc b fv nh ni l nj nk">(<strong class="nc hu">assign</strong> 'val (<strong class="nc hu">op</strong> 'make-compiled-procedure ((<strong class="nc hu">label</strong> 'entry1) (<strong class="nc hu">reg</strong> 'env))))<br/>(<strong class="nc hu">goto</strong> (<strong class="nc hu">label</strong> 'after-lambda2))<br/><br/><em class="kt">; Lambda Body</em><br/>(<strong class="nc hu">label</strong> 'entry1)<br/>(<strong class="nc hu">assign</strong> 'env (<strong class="nc hu">op</strong> 'compiled-procedure-env ((<strong class="nc hu">reg</strong> 'proc))))<br/>(<strong class="nc hu">assign</strong> 'env (<strong class="nc hu">op</strong> 'extend-environment ((<strong class="nc hu">const</strong> <strong class="nc hu">'</strong>(<strong class="nc hu">x</strong>)) (<strong class="nc hu">reg</strong> 'argl) (<strong class="nc hu">reg</strong> 'env))))<br/>(<strong class="nc hu">assign</strong> 'val (<strong class="nc hu">op</strong> 'lookup-variable-value ((<strong class="nc hu">const</strong> 'x) (<strong class="nc hu">reg</strong> 'env))))<br/>(<strong class="nc hu">goto</strong> (<strong class="nc hu">reg</strong> 'continue))<br/><br/>(<strong class="nc hu">label</strong> 'after-lambda2)<br/>(<strong class="nc hu">perform</strong> (<strong class="nc hu">op</strong> 'define-variable! ((<strong class="nc hu">const</strong> 'id) (<strong class="nc hu">reg</strong> 'val) (<strong class="nc hu">reg</strong> 'env))))</span></pre><p id="78a2" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">编译Lambda主体后，使用第一个<code class="eh nl nm nn nc b">goto</code>跳过它，因为必须显式调用过程来执行它们的主体。</p><p id="04c5" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">当编译后的程序进入时，它们的参数在<code class="eh nl nm nn nc b">argl</code>寄存器中。Lambda首先将参数移动到环境中，然后运行主体。</p><p id="2683" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">显式调用(或应用程序)看起来像</p><p id="1166" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated"><code class="eh nl nm nn nc b">(<strong class="jz hu">id</strong> 5)</code></p><p id="69d5" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">。它看起来更短，但是编译的代码</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="5643" class="ng lr ht nc b fv nh ni l nj nk"><em class="kt">; Get code pointer and arguments</em><br/>(<strong class="nc hu">assign</strong> 'proc (<strong class="nc hu">op</strong> 'lookup-variable-value ((<strong class="nc hu">const</strong> 'id) (<strong class="nc hu">reg</strong> 'env))))<br/>(<strong class="nc hu">assign</strong> 'val (<strong class="nc hu">op</strong> 'box ((<strong class="nc hu">const</strong> 5))))<br/>(<strong class="nc hu">assign</strong> 'argl (<strong class="nc hu">op</strong> 'list ((<strong class="nc hu">reg</strong> 'val))))<br/><br/>(<strong class="nc hu">test</strong> (<strong class="nc hu">op</strong> 'primitive-procedure? ((<strong class="nc hu">reg</strong> 'proc))))<br/>(<strong class="nc hu">branch</strong> (<strong class="nc hu">label</strong> 'primitive-branch1))<br/><br/>(<strong class="nc hu">label</strong> 'compiled-branch2)<br/>(<strong class="nc hu">assign</strong> 'continue (<strong class="nc hu">label</strong> 'after-call3))<br/>(<strong class="nc hu">assign</strong> 'val (<strong class="nc hu">op</strong> 'compiled-procedure-entry ((<strong class="nc hu">reg</strong> 'proc))))<br/>(<strong class="nc hu">goto</strong> (<strong class="nc hu">reg</strong> 'val))<br/><br/>(<strong class="nc hu">label</strong> 'primitive-branch1)<br/>(<strong class="nc hu">assign</strong> 'val (<strong class="nc hu">op</strong> 'apply-primitive-procedure ((<strong class="nc hu">reg</strong> 'proc) (<strong class="nc hu">reg</strong> 'argl))))<br/><br/>(<strong class="nc hu">label</strong> 'after-call3)</span></pre><p id="f5ef" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">更长。</p><p id="3c14" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">过程可以是从Lambda创建的编译过程，也可以是内置的<strong class="jz hu">原语过程</strong>。它们目前在EVM级别上是相似的，但将来可能会得到优化。例如，原始过程可以在堆栈上传递它们的参数，而不是分配一个链表。</p><h1 id="1456" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">抽象机器语言</h1><p id="e0b7" class="pw-post-body-paragraph jx jy ht jz b ka mi iu kc kd mj ix kf kg mk ki kj kk ml km kn ko mm kq kr ks hm dt translated">这些表格总结了编译器所针对的抽象机器。</p><p id="8c3a" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">有8条指令:</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="4df9" class="ng lr ht nc b fv nh ni l nj nk">(<strong class="nc hu">label</strong> name)                 <em class="kt">; A location to jump to</em><br/>(<strong class="nc hu">assign</strong> register expression) <em class="kt">; Write the expression's result</em><br/>(<strong class="nc hu">test</strong> expression)            <em class="kt">; Decide if the next branch jumps</em><br/>(<strong class="nc hu">branch</strong> expression)          <em class="kt">; Conditionally jumps to a location</em><br/>(<strong class="nc hu">goto</strong> expression)            <em class="kt">; Unconditionally jumps to a location</em><br/>(<strong class="nc hu">save</strong> register)              <em class="kt">; Pushes a register onto the stack</em><br/>(<strong class="nc hu">restore</strong> register)           <em class="kt">; Pops the stack into a register</em><br/>(<strong class="nc hu">perform</strong> expression)         <em class="kt">; Executes an expression for side effects</em></span></pre><p id="76a7" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">4个表情:</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="67c7" class="ng lr ht nc b fv nh ni l nj nk">(<strong class="nc hu">label</strong> name)   <em class="kt">; The offset of a location in the final EVM bytecode</em></span><span id="f013" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">const</strong> value)  <em class="kt">; An unboxed integer, unboxed symbol, or list of consts</em></span><span id="2bb7" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">reg</strong> name)     <em class="kt">; One of `env`, `proc`, `continue`, `argl`, `val`. These are documented in the Code Generator section.</em></span><span id="38a6" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">op</strong> name args) <em class="kt">; One of the Operations below together with its arguments.</em></span></pre><p id="2286" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">13个原始操作:</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="89da" class="ng lr ht nc b fv nh ni l nj nk">(<strong class="nc hu">op</strong> 'make-compiled-procedure (<strong class="nc hu">label</strong> env))   <em class="kt">; A new Compiled Procedure</em></span><span id="d449" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">op</strong> 'compiled-procedure-entry (<strong class="nc hu">proc</strong>))       <em class="kt">; Compiled Procedure's label</em></span><span id="f151" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">op</strong> 'compiled-procedure-env (<strong class="nc hu">proc</strong>))         <em class="kt">; Compiled Procedure's env</em></span><span id="335f" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">op</strong> 'define-variable! (<strong class="nc hu">name</strong> value env))     <em class="kt">; New variable</em></span><span id="30ac" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">op</strong> 'set-variable! (<strong class="nc hu">name</strong> value env))        <em class="kt">; Change variable</em></span><span id="c4de" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">op</strong> 'lookup-variable-value (<strong class="nc hu">name</strong> env))      <em class="kt">; Access variable</em></span><span id="4b23" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">op</strong> 'box (<strong class="nc hu">value</strong>))                           <em class="kt">; Create Fixnum</em></span><span id="9f52" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">op</strong> 'extend-environment (<strong class="nc hu">names</strong> values env)) <em class="kt">; Create Frame</em></span><span id="d6fb" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">op</strong> 'primitive-procedure? (<strong class="nc hu">proc</strong>))           <em class="kt">; True if Primitive Procedure</em></span><span id="a481" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">op</strong> 'apply-primitive-procedure (<strong class="nc hu">proc</strong> argl)) <em class="kt">; Call Primitive Procedure</em></span><span id="adaf" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">op</strong> 'false? (<strong class="nc hu">value</strong>))                        <em class="kt">; Boolean NOT.</em></span><span id="4730" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">op</strong> 'list (<strong class="nc hu">value</strong>))                          <em class="kt">; Create one-element List</em></span><span id="bd4b" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">op</strong> 'cons (<strong class="nc hu">head</strong> tail))                      <em class="kt">; Create Pair</em></span></pre><h1 id="0c5e" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">编码发生器</h1><p id="a7c9" class="pw-post-body-paragraph jx jy ht jz b ka mi iu kc kd mj ix kf kg mk ki kj kk ml km kn ko mm kq kr ks hm dt translated">抽象机器是一个很好的中间目标，但是对EVM一无所知。<strong class="jz hu">代码生成器</strong>拥有EVM内存、指令、堆栈和存储的详细知识。它有两个责任:</p><ul class=""><li id="b701" class="mn mo ht jz b ka kb kd ke kg mp kk mq ko mr ks ms mt mu mv dt translated">将抽象的机器码转换成几乎EVM汇编</li><li id="1177" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated">初始化环境</li></ul><h1 id="9040" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">抽象汇编程序</h1><p id="6fc5" class="pw-post-body-paragraph jx jy ht jz b ka mi iu kc kd mj ix kf kg mk ki kj kk ml km kn ko mm kq kr ks hm dt translated">目标EVM伪程序集具有以下原语:</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="55d4" class="ng lr ht nc b fv nh ni l nj nk">(<strong class="nc hu">label</strong> name)          <em class="kt">; JUMPDEST, but remembers byte offset for eth-push</em></span><span id="4255" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">eth-asm</strong> symbol)      <em class="kt">; 1-byte EVM opcode</em></span><span id="de12" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">eth-push</strong> size value) <em class="kt">; size = integer | 'shrink. value = integer | label</em></span><span id="cb0d" class="ng lr ht nc b fv no ni l nj nk">(<strong class="nc hu">eth-unknown</strong> value)   <em class="kt">; 1 literal byte</em></span></pre><p id="37ab" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">序列化器<strong class="jz hu">将其转化为可部署的字节码。</strong></p><p id="0b8d" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">代码生成器必须实现前面部分中的每个指令、表达式和操作。抽象指令通常映射到单个汇编指令:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff np"><img src="../Images/8ae768bfa8048d158b4cd1a6c67eb44d.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/1*zOBkLl-O-9vfQ0CBafEAnQ.png"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek"><a class="ae ju" href="https://www.michaelburge.us/2017/11/28/write-your-next-ethereum-contract-in-pyramid-scheme.html" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="e052" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">因为抽象指令评估它们的参数，所以最终的EVM汇编可能长于零个或一个指令。代码生成器的复杂性在于表达式。</p><p id="819f" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">表达式将结果留在堆栈上。除了操作和列表常量之外，表达式都是单个指令:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nq"><img src="../Images/089801d32de06d7d7551b590509ea430.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*fKoJJUt-JICEUsR63X-eGw.png"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek"><a class="ae ju" href="https://www.michaelburge.us/2017/11/28/write-your-next-ethereum-contract-in-pyramid-scheme.html" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="d545" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">操作使用堆栈进行输入和输出。它们的参数本身就是表达式，虽然操作不把操作当参数。</p><p id="1775" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">表达式计算为普通的256位字:整数是256位，符号是最多32个8位ASCII字符(总共256位)，其他的都是指向动态分配对象的256位指针。</p><h1 id="79b8" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">存储器分配</h1><p id="5667" class="pw-post-body-paragraph jx jy ht jz b ka mi iu kc kd mj ix kf kg mk ki kj kk ml km kn ko mm kq kr ks hm dt translated">通过增加<code class="eh nl nm nn nc b">allocator</code>寄存器来分配内存。如果<code class="eh nl nm nn nc b">allocator</code>中的值是<code class="eh nl nm nn nc b">n</code>，那么将<code class="eh nl nm nn nc b">allocator</code>增加32会保留内存地址<code class="eh nl nm nn nc b">[n, n+32)</code>。通过减少分配器来释放内存:如果不释放在一个地址之后分配的所有地址，就不能释放这个地址。</p><p id="2f0f" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">金字塔不使用垃圾收集器。复杂的垃圾收集器可能会有不可预测的气体使用量，并且没有长寿命的EVM执行。将来，金字塔编译器可能会通过释放死变量或将变量放入堆栈来优化内存。</p><p id="6c46" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">金字塔值或者是<strong class="jz hu">标记的</strong>或者是<strong class="jz hu">未标记的</strong>(或者是<strong class="jz hu">装箱的</strong>或者是<strong class="jz hu">未装箱的</strong>)。未标记值是单个256位的字，要么指向标记值，要么暂时存在于堆栈中。标记值存储在分配的内存中。</p><p id="f7d7" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">标记值有7种<strong class="jz hu">原始类型</strong>:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nr"><img src="../Images/3546d2a09bf9c05a3f94d2513ae7dff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*2MEDH-PACZbo97tTGH5Njw.png"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek"><a class="ae ju" href="https://www.michaelburge.us/2017/11/28/write-your-next-ethereum-contract-in-pyramid-scheme.html" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="5307" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">标记值是指向一组256位字的指针。第一个单词是上表中的类型标签；其余的取决于类型。</p><p id="1416" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated"><strong class="jz hu">派生类型</strong>是原始类型的组合。文档使用它们来指定哪些原始值是有效的参数:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ns"><img src="../Images/7d858552ca3f81e7236942b64598d869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*BBeHjXxVWA8oLfJIT10yjw.png"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek"><a class="ae ju" href="https://www.michaelburge.us/2017/11/28/write-your-next-ethereum-contract-in-pyramid-scheme.html" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="1e09" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">未标记的值没有运行时类型信息，但在以下环境中使用:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nt"><img src="../Images/9cbb7a5c2c2870c7231b3d6d3c7efe10.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*fLJoupQ0BpkG1cAyR09xhA.png"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek"><a class="ae ju" href="https://www.michaelburge.us/2017/11/28/write-your-next-ethereum-contract-in-pyramid-scheme.html" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="f429" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">大部分内存都已分配，但仍有一些保留的内存位置:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nu"><img src="../Images/66015bf0185102623adac0f101b9a12d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*uT9OVhRQzk_nAajwvlC8ww.png"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek"><a class="ae ju" href="https://www.michaelburge.us/2017/11/28/write-your-next-ethereum-contract-in-pyramid-scheme.html" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="8302" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">调试编译器时，<code class="eh nl nm nn nc b">proc</code>、<code class="eh nl nm nn nc b">continue</code>和<code class="eh nl nm nn nc b">argl</code>的初始值很有用。它们不应该对用户代码可见。</p><h1 id="974e" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">初始化</h1><p id="94e3" class="pw-post-body-paragraph jx jy ht jz b ka mi iu kc kd mj ix kf kg mk ki kj kk ml km kn ko mm kq kr ks hm dt translated">在用户代码运行之前，保留的内存位置被设置为初始值，并安装金字塔标准库。</p><p id="7718" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">除了<code class="eh nl nm nn nc b">env</code>之外的一切都向内存写一个常数。<code class="eh nl nm nn nc b">env</code>首先获得一个新分配的空环境，然后通过定义几个原语过程对象来安装金字塔标准库。Pyramid的<code class="eh nl nm nn nc b">define</code>语法可以用于此，只是用户目前没有办法创建原始过程值。</p><p id="2be9" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">本文一开始就使用了这个例子:</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="4898" class="ng lr ht nc b fv nh ni l nj nk">(<strong class="nc hu">begin</strong><br/> (<strong class="nc hu">define</strong> (<strong class="nc hu">factorial</strong> n)<br/>  (<strong class="nc hu">if</strong> (= n 1)<br/>      1<br/>      (* (<strong class="nc hu">factorial</strong> (- n 1)) n)))<br/> (<strong class="nc hu">factorial</strong> 5))</span></pre><p id="33c4" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">这需要3个标准库函数:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nv"><img src="../Images/a4166ad6543bc945c95797742e6a677f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*E44QLxqg0qPdxxcKz7Yr-w.png"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek"><a class="ae ju" href="https://www.michaelburge.us/2017/11/28/write-your-next-ethereum-contract-in-pyramid-scheme.html" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="5244" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">原始过程是一个标记标签。通过跳转到栈上有两个项目的标签来调用它:一个指向参数列表的指针和一个返回地址。标签后面的代码应该:</p><ul class=""><li id="d1be" class="mn mo ht jz b ka kb kd ke kg mp kk mq ko mr ks ms mt mu mv dt translated">将参数从列表移动到堆栈</li><li id="ef21" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated">取消整数装箱</li><li id="9117" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated">应用EQ、MUL或子组件说明</li><li id="6c0a" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated">框出结果(EQ除外)</li><li id="a6d8" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated">跳转到寄信人地址</li></ul><p id="07ab" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">如果Pyramid支持内联EVM汇编，那么用户可以将他们自己的原语过程定义为一种特殊类型的Lambda。这比向代码生成器添加原语要好，因为用户可以删除他们不需要的函数。较短的程序更容易审计。期待在未来看到这一点的实现。</p><h1 id="8ddf" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">串行器</h1><p id="cf47" class="pw-post-body-paragraph jx jy ht jz b ka mi iu kc kd mj ix kf kg mk ki kj kk ml km kn ko mm kq kr ks hm dt translated">大多数编译后的程序直接在它们的目标平台上执行。EVM的不同之处在于编译后的程序实际上是<strong class="jz hu">程序初始化器</strong>。这个初始化器生成一个新的程序来处理所有未来的事务和消息。</p><p id="1bc9" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">金字塔串行化器将一个<strong class="jz hu">加载器</strong>前置到金字塔程序，该加载器返回金字塔程序:</p><pre class="jj jk jl jm fq nb nc nd ne aw nf dt"><span id="9631" class="ng lr ht nc b fv nh ni l nj nk">PUSH programSize<br/>PUSH afterLoader<br/>PUSH 0<br/>CODECOPY<br/>PUSH programSize<br/>PUSH 0<br/>RETURN</span></pre><p id="8767" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">其中<code class="eh nl nm nn nc b">programSize</code>是编译后金字塔字节码的字节大小，<code class="eh nl nm nn nc b">afterLoader</code>是加载器的字节大小(通常为14)。</p><p id="5b8c" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">串行器还计算每个标签的字节偏移量，并将其添加到<strong class="jz hu">符号表</strong>中。标签可以在使用后定义，因此串行化器发出0作为占位符，并将偏移量添加到<strong class="jz hu">重定位表</strong>。生成字节码后，符号表与重定位表匹配，字节码就地编辑。</p><p id="97ce" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">串行化器还为没有大小的推送计算出正确的大小:以太坊支持不同大小的<code class="eh nl nm nn nc b">PUSH</code>指令。</p><h1 id="89fe" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">进一步的工作</h1><p id="cb59" class="pw-post-body-paragraph jx jy ht jz b ka mi iu kc kd mj ix kf kg mk ki kj kk ml km kn ko mm kq kr ks hm dt translated">在本文中，我们研究了金字塔计划编译器的高级设计。为了保持它的可访问性，我省略了编译器的实现代码。在我的下一篇文章“用Google Sheets调试编译器后端”中，我将介绍代码生成器的实现，包括开发定制调试工具。</p><p id="1eba" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">该代码可在<a class="ae ju" href="https://github.com/MichaelBurge/pyramid-scheme" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><p id="0bcf" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">未来的金字塔文章可能包括:</p><ul class=""><li id="26c1" class="mn mo ht jz b ka kb kd ke kg mp kk mq ko mr ks ms mt mu mv dt translated">优化:词法寻址、活性分析、早期拆箱</li><li id="3ddf" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated">包管理器:用户想要共享代码。EVM语言可以有“内部”和“外部”模块</li><li id="8e51" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated">EVM工具:实现标准的ABI，允许其他合同语言和Javascript工具与Pyramid一起工作</li><li id="067b" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated">合同开发:接受预订书的合同的开发。</li></ul><p id="2b9a" class="pw-post-body-paragraph jx jy ht jz b ka kb iu kc kd ke ix kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">未来的以太坊文章可能包括:</p><ul class=""><li id="558c" class="mn mo ht jz b ka kb kd ke kg mp kk mq ko mr ks ms mt mu mv dt translated">安全:进行安全审计，常见陷阱，漏洞扫描器</li><li id="3917" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated">契约库:组织更大的代码库，调用与调用代码与委托调用</li><li id="f86a" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated">正式验证:绝对100%保证你的合同没有错误</li><li id="8e02" class="mn mo ht jz b ka mw kd mx kg my kk mz ko na ks ms mt mu mv dt translated">前端:使用合同作为后台数据存储建立一个电子商务商店</li></ul></div></div>    
</body>
</html>