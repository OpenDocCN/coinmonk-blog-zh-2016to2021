<html>
<head>
<title>My First “Real” Magic Leap Project: Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的第一个“真正的”魔术飞跃计划:第3部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/my-first-real-magic-leap-project-part-3-4691a7fc8329?source=collection_archive---------5-----------------------#2018-08-06">https://medium.com/coinmonks/my-first-real-magic-leap-project-part-3-4691a7fc8329?source=collection_archive---------5-----------------------#2018-08-06</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="1fca" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">用类似<em class="ji">的状态管理来重构前面的例子。</em></h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/3ad5f9c480f568c9198cab1978896615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svGgJTE3MQzuxvOVW0Mzhw.jpeg"/></div></div></figure><p id="2dee" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">本文是多部分系列文章的一部分，从<a class="ae kr" rel="noopener" href="/@johntucker_48673/my-first-real-magic-leap-project-part-1-de047aeaa65"> <em class="ks">我的第一个“真正的”魔法飞跃计划:第一部分</em> </a>开始。</p><p id="073b" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">本文的完整应用程序可从bounce repository的<a class="ae kr" href="https://github.com/larkintuckerllc/bounce/tree/part3" rel="noopener ugc nofollow" target="_blank"> <em class="ks"> part3 </em> </a>分支下载。</p><p id="17ab" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated"><strong class="jx hu">类似还原的状态管理</strong></p><p id="975f" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">我们继续使用状态管理策略重构前面的例子。我们的应用程序强烈借鉴了以下文章。</p><div class="kt ku fm fo kv kw"><a rel="noopener follow" target="_blank" href="/@johntucker_48673/unity-more-redux-like-patterns-abe7500519f3"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hu fv z el lb eo ep lc er et hs dt translated">统一:更多类似Redux的模式</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">探索一种健壮且易于故障诊断的方法来管理整个Unity应用程序的应用程序状态。</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">medium.com</p></div></div><div class="lf l"><div class="lg l lh li lj lf lk jt kw"/></div></div></a></div><p id="4b70" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">第一步是捕获我们先前存储在私有字段<em class="ks"> _state </em>中的内容，即<em class="ks">定位、缩放、网格划分</em>等，在全局状态下:</p><ul class=""><li id="16ca" class="ll lm ht jx b jy jz kb kc ke ln ki lo km lp kq lq lr ls lt dt translated"><em class="ks">方式</em>:An<em class="ks">enum；</em>定位、<em class="ks">定标</em>或<em class="ks">啮合</em>之一</li></ul><p id="d9d7" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">此外，因为<em class="ks">网格区域</em>游戏对象的位置和比例是<em class="ks">空间映射器</em>游戏对象所需要的，所以我们将它们暴露在全局状态下。</p><ul class=""><li id="d5ea" class="ll lm ht jx b jy jz kb kc ke ln ki lo km lp kq lq lr ls lt dt translated"><em class="ks"> MZPositionX </em>:游戏对象<em class="ks">网格区域</em>x位置的一个<em class="ks">int</em>；将x乘以100并截断</li><li id="0144" class="ll lm ht jx b jy lu kb lv ke lw ki lx km ly kq lq lr ls lt dt translated"><em class="ks"> MZPositionZ </em>:网游区游戏对象z位置的一个<em class="ks">点</em>；将z乘以100并截断</li><li id="5eec" class="ll lm ht jx b jy lu kb lv ke lw ki lx km ly kq lq lr ls lt dt translated"><em class="ks"> MZScaleX </em>:一个<em class="ks"> int </em>的x刻度的<em class="ks">网游区</em>游戏对象；将x乘以100并截断</li><li id="7f03" class="ll lm ht jx b jy lu kb lv ke lw ki lx km ly kq lq lr ls lt dt translated"><em class="ks"> MZScaleZ </em>:游戏对象的z标尺中的一个<em class="ks">int</em><em class="ks">网格区域</em>；将z乘以100并截断</li></ul><p id="9cc3" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">最后，<em class="ks">啮合区</em>游戏对象需要控制器上触摸板的x和y位置。</p><ul class=""><li id="04e3" class="ll lm ht jx b jy jz kb kc ke ln ki lo km lp kq lq lr ls lt dt translated"><em class="ks"> TouchX </em>:控制器上触摸板x位置的一个<em class="ks">int</em>；将x乘以10并截断</li><li id="97e1" class="ll lm ht jx b jy lu kb lv ke lw ki lx km ly kq lq lr ls lt dt translated"><em class="ks">触摸</em>:控制器上触摸板y位置的一个<em class="ks">int</em>；将y乘以10并截断</li></ul><p id="0059" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">一旦我们定义了全局状态，我们就把游戏对象连接起来，观察状态相关部分的变化。</p><p id="d454" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated"><strong class="jx hu">代码</strong></p><p id="0c8f" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">为了提供必要的结构，添加了相当数量的样板代码；例如，以下文件定义了全局<em class="ks">模式</em>状态。</p><p id="2a35" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated"><em class="ks">资产/鸭子/模式. cs </em></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="1be2" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">然后我们连线游戏对象来观察状态的变化；例如<em class="ks">啮合区</em>观察<em class="ks">模式</em>、<em class="ks">触摸式</em>、<em class="ks">触摸式</em>。</p><p id="18c2" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated"><em class="ks">Assets/Table/meshing zone . cs</em></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="beb3" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">与我们之前的例子不同，我们<strong class="jx hu">而不是</strong>维护游戏对象之间的引用；相反，我们通过全球国家分享信息</p><p id="661f" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">通过这种方法，我们将单个游戏对象上的代码分散到多个集中的游戏对象上:</p><ul class=""><li id="c10a" class="ll lm ht jx b jy jz kb kc ke ln ki lo km lp kq lq lr ls lt dt translated"><em class="ks"> InputHandler </em>:将控制器的触摸x和y值存入<em class="ks"> TouchX </em>和<em class="ks"> TouchY </em></li><li id="f46b" class="ll lm ht jx b jy lu kb lv ke lw ki lx km ly kq lq lr ls lt dt translated"><em class="ks"> KeyPoseHandler </em>:使用<em class="ks">模式</em>，根据手势更新<em class="ks">模式</em></li><li id="1b9e" class="ll lm ht jx b jy lu kb lv ke lw ki lx km ly kq lq lr ls lt dt translated"><em class="ks"> MLSpatialMapper </em>:使用<em class="ks">模式，PositionX、PositionZ、ScaleX </em>和<em class="ks"> ScaleZ </em>，设置其位置、刻度和启用状态。这是对通过提供的<em class="ks"> MLSpatialMapper </em>脚本(来自上一篇文章)提供的网格构建功能的补充</li><li id="5538" class="ll lm ht jx b jy lu kb lv ke lw ki lx km ly kq lq lr ls lt dt translated"><em class="ks"> MeshingZone </em>:使用<em class="ks"> Mode </em>、<em class="ks"> TouchX </em>和<em class="ks"> TouchY </em>，更新其位置、比例，并将其位置和比例存入<em class="ks"> PositionX、PositionZ、ScaleX </em>和<em class="ks"> ScaleZ </em></li></ul><p id="5cbc" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated"><strong class="jx hu">下一步</strong></p><p id="0457" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">在下一篇文章<a class="ae kr" rel="noopener" href="/@johntucker_48673/my-first-real-magic-leap-project-part-4-6da95d631acf"> <em class="ks">中，我的第一个“真正的”Magic Leap项目:第4部分</em> </a>中，我们实现了允许用户识别网格上的一个点(稍后放置一个球)的功能。</p></div></div>    
</body>
</html>