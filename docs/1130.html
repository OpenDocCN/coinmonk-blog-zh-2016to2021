<html>
<head>
<title>Adventures in Ethereum Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊发展中的冒险</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/adventures-in-ethereum-development-2c8a25936218?source=collection_archive---------9-----------------------#2018-07-24">https://medium.com/coinmonks/adventures-in-ethereum-development-2c8a25936218?source=collection_archive---------9-----------------------#2018-07-24</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/d17d6f45443de88c2ab85e4770ada9e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3tPBM2J_98gwVBfiaPDnHw.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">You’re gonna need coffee for this</figcaption></figure><p id="cdaf" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">大约一年前，我提交了一篇名为“本周我从使用可靠性、松露和Web3中学到的3件事”的文章。我监控着这个空间，密切关注着一些正在进行的开发，包括从11月开始<a class="ae kd" href="https://ethereum.stackexchange.com/a/30130/9955" rel="noopener ugc nofollow" target="_blank">为社区研究奇偶多重签名黑客做出贡献。</a></p><p id="4f9e" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">最近，我被邀请参加一个全公司范围的黑客马拉松，其中一些挑战涉及使用新兴技术来满足业务需求。由于软件许可管理是我直接参与的事情，我立即看到了一个用例，在这个用例中，我可以利用我在区块链开发方面的专业知识，在以太坊上提出一个基本的许可模型。</p><p id="3eda" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我开始研究不可替换令牌(ERC721)的开发，因为我想构建可以交易、移动、签入和签出等的许可证。这让我开始研究如何在行星间文件系统上存储与NFT氏症相关的元数据，这带来了另一系列独特的挑战。</p><p id="3989" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">最终，在所有这些原型制作之后(在黑客马拉松之前)，我认为这个项目超出了24小时活动的范围，我的团队转向了不同的方向。</p><p id="4472" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">然而，我想分享我在尝试软件许可管理的智能合同开发中发现的一些事情。尽情享受吧！</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><h1 id="96c4" class="kl km ht bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">1.松露现在有Ganache和毛毛雨！</h1><p id="dab8" class="pw-post-body-paragraph jf jg ht jh b ji lj jk jl jm lk jo jp jq ll js jt ju lm jw jx jy ln ka kb kc hm dt translated">我终于有了一个本地运行的testrpc节点的GUI！当我需要在调试时解析日志、块和事务时，这非常方便。然而，在几次迁移之后，实际的应用程序会变得非常缓慢；生成的日志数量似乎让应用程序不堪重负。</p><p id="9f91" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">此外，测试套件似乎更容易利用这段时间。我实现了几乎所有契约功能的测试，这是我非常感谢Truffle实现的。然而，我必须实现一个定制的实用函数来断言某些事件已经触发；看起来松露仍然很难在他们的测试程序中检测到这些事件。注意:这不是我自己想出来的，它基本上是从这里抄来的:</p><div class="lo lp fm fo lq lr"><a href="https://ethereum.stackexchange.com/questions/15353/how-to-listen-for-contract-events-in-javascript-tests/21661" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab ej"><div class="lt ab lu cl cj lv"><h2 class="bd hu fv z el lw eo ep lx er et hs dt translated">如何在JavaScript测试中监听契约事件？</h2><div class="ly l"><h3 class="bd b fv z el lw eo ep lx er et ek translated">我发现不是所有的事件都显示在truffle输出窗口中，尽管它们可能已经触发了…</h3></div><div class="lz l"><p class="bd b gc z el lw eo ep lx er et ek translated">ethereum.stackexchange.com</p></div></div></div></a></div><p id="c8ef" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">下面是:</p><figure class="ma mb mc md fq iu"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="cb16" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">此外，我能够使用毛毛雨将以太坊连接的商店集成到React应用程序中。它需要能够访问Truffle projects contracts文件夹中生成的合同JSON文件。此外，作为一名非React开发人员，我在弄清楚如何将毛毛雨连接到我的组件时有些困难。本教程对设置非常有帮助。</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><h1 id="25aa" class="kl km ht bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">2.<a class="ae kd" href="https://github.com/OpenZeppelin/openzeppelin-solidity" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a>拥有按照ERC规范构建的开源合同库</h1><p id="b3d7" class="pw-post-body-paragraph jf jg ht jh b ji lj jk jl jm lk jo jp jq ll js jt ju lm jw jx jy ln ka kb kc hm dt translated">因此，在尝试实现ERC721令牌时，OpenZeppelin是一个巨大的资源。安装库很容易:</p><pre class="ma mb mc md fq mg mh mi mj aw mk dt"><span id="2bce" class="ml km ht mh b fv mm mn l mo mp">npm install zeppelin-solidity</span></pre><p id="7652" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">然后参考/链接ERC721的库:</p><figure class="ma mb mc md fq iu"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="bb3c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">但是，在链接和开发过程中，我了解到ERC721令牌持有者<strong class="jh hu">必须</strong>实现<em class="mq">ERC 721接收者</em>和<strong class="jh hu">而不是</strong><em class="mq">ERC 721持有者</em>。我并不清楚ERC721Holder是一个样本契约，而不是一个可以构建的库。</p><p id="d294" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">此外，您可以扩展ERC721令牌来保存您想要的任何映射/数据。我延长了我的持牌时间。</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><h1 id="b9dc" class="kl km ht bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">3.无法存储合同代码，请检查您的汽油量</h1><p id="68bf" class="pw-post-body-paragraph jf jg ht jh b ji lj jk jl jm lk jo jp jq ll js jt ju lm jw jx jy ln ka kb kc hm dt translated">这通常意味着我还没有完全实现一个接口。在一个特殊的例子中，我意识到我没有正确地实现<em class="mq"> ERC721Receiver </em>构造函数。</p><p id="4bb8" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">基本上:</p><pre class="ma mb mc md fq mg mh mi mj aw mk dt"><span id="6283" class="ml km ht mh b fv mm mn l mo mp">constructor (address smartLicenseTokenAddress, string companyUri) public ERC721Receiver() /* &lt;--- IMPORTANT */ { <br/>  _smartLicense = SmartProductLicense(smartLicenseTokenAddress);<br/>  _companyUri = companyUri;<br/>  _owner = msg.sender;<br/>}</span></pre><p id="738b" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">而不是:</p><pre class="ma mb mc md fq mg mh mi mj aw mk dt"><span id="b519" class="ml km ht mh b fv mm mn l mo mp">constructor (address smartLicenseTokenAddress, string companyUri){ <br/>  _smartLicense = SmartProductLicense(smartLicenseTokenAddress);<br/>  _companyUri = companyUri;<br/>  _owner = msg.sender;<br/>}</span></pre><p id="2e3b" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">……哎呀。记住你的基本构造函数！</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><h1 id="0733" class="kl km ht bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">4.<a class="ae kd" href="https://ipfs.io/" rel="noopener ugc nofollow" target="_blank"> IPFS </a>用于元数据存储</h1><p id="60a8" class="pw-post-body-paragraph jf jg ht jh b ji lj jk jl jm lk jo jp jq ll js jt ju lm jw jx jy ln ka kb kc hm dt translated">还记得在链上存储数据是多么的昂贵吗？当存储ERC721令牌的唯一元数据时，这个问题的解决方案是使用<a class="ae kd" href="https://ipfs.io/" rel="noopener ugc nofollow" target="_blank">行星间文件系统</a>，这是一个存储不可变散列文件的分散式对等系统。文件的散列(链接)可以存储在chain上。这里有一个js-ipfs-api的链接，我用它连接到一个本地运行的ipfs守护进程，添加文件数据，然后检索它:</p><div class="lo lp fm fo lq lr"><a href="https://github.com/ipfs/js-ipfs-api" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab ej"><div class="lt ab lu cl cj lv"><h2 class="bd hu fv z el lw eo ep lx er et hs dt translated">ipfs/js-ipfs-api</h2><div class="ly l"><h3 class="bd b fv z el lw eo ep lx er et ek translated">js-ipfs-API——IPFS HTTP API的客户端库，用JavaScript实现。</h3></div><div class="lz l"><p class="bd b gc z el lw eo ep lx er et ek translated">github.com</p></div></div></div></a></div><p id="6b71" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">然而，在IPFS存储数据变得很麻烦，因为swarm peers在工作时被阻止(黑客马拉松正在那里举行)，所以我不得不实现一个工作区来本地存储和检索文件。</p><div class="lo lp fm fo lq lr"><a href="https://github.com/ipfs/go-ipfs/issues/4854" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab ej"><div class="lt ab lu cl cj lv"><h2 class="bd hu fv z el lw eo ep lx er et hs dt translated">IPFS swarm peers是“空的”，在windows上找不到Webui。问题#4854 ipfs/go-ipfs</h2><div class="ly l"><h3 class="bd b fv z el lw eo ep lx er et ek translated">版本IPFS 0.4.13类型bug(不确定)描述我在Windows 10上运行IPFS。ipfs守护程序正在运行。的…</h3></div><div class="lz l"><p class="bd b gc z el lw eo ep lx er et ek translated">github.com</p></div></div></div></a></div></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><h1 id="6d19" class="kl km ht bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">5.以太坊闹钟，用于安排通话</h1><p id="f4e2" class="pw-post-body-paragraph jf jg ht jh b ji lj jk jl jm lk jo jp jq ll js jt ju lm jw jx jy ln ka kb kc hm dt translated">以太坊闹钟停产了一段时间，最近才再次获得资助，这让我非常高兴，因为没有它们我无法安排执照检查。然而，我无法实现和测试预定的事务，因为这需要部署到一个测试网络，而不是本地运行的私有链(Ganache)。</p><p id="1a6e" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">然而，发现和了解在区块链协议上分散调度事务的过程就像坐过山车一样！<a class="ae kd" href="http://ethereum-alarm-clock-service.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">我强烈推荐你自己阅读这些文档。</a></p><p id="64fd" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我之所以使用预定的事务，而不是懒洋洋地检查然后计算，是因为我不希望在一个将被频繁调用的调用上出现潜在的状态变化。</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><p id="b66f" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">总之，我最终发现了一大堆非常酷的工具，可以用来在以太坊空间中构建智能合约。看到对区块链技术充满热情的开发人员在过去的一年中取得的进步真是令人难以置信！以太坊社区对这一领域开源开发的承诺确实鼓舞人心。</p><p id="c318" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">欢迎提问，或者查看我的<a class="ae kd" href="https://github.com/valkn0t" rel="noopener ugc nofollow" target="_blank"> Github </a>获取更多的Solidity代码示例！</p><p id="165f" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">哦，在推特上关注我吧！</p></div></div>    
</body>
</html>