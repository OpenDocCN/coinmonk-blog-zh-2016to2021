<html>
<head>
<title>Tensorflow — Graphs and Sessions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">张量流-图形和会话</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/tensorflow-graphs-and-sessions-c7fa116209db?source=collection_archive---------2-----------------------#2018-08-12">https://medium.com/coinmonks/tensorflow-graphs-and-sessions-c7fa116209db?source=collection_archive---------2-----------------------#2018-08-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/6706fe776bda4d69e20f946c5acb5c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aOYUa3hHKi9HlYnnFAipUQ.gif"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Image courtesy: tensorflow.org</figcaption></figure><p id="8891" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">Tensorflow一直是最受欢迎的高性能数值计算开源软件库，自谷歌开源以来，它在机器学习从业者中非常受欢迎。它已经成为深度学习项目的首选框架之一，因为它具有丰富的特性，能够在不降低灵活性和可伸缩性的情况下抽象大量样板代码和配置。然而，本文将尝试讨论一些底层的基本原则，这些原则在使用像Keras或Tensorflow估算器这样的高级API时是不必要的。</p><p id="9c85" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu"> <em class="kd">什么是图？</em>T3】</strong></p><p id="a3ce" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">Tensorflow有一个惰性评估，换句话说，Tensorflow将首先创建一个计算图形，将操作作为图形的节点，并对其边缘进行张量，当图形在会话中执行时，执行就会发生。这就是通常所说的专用于并行计算的<a class="ae ke" href="https://en.wikipedia.org/wiki/Dataflow_programming" rel="noopener ugc nofollow" target="_blank">数据流</a>编程模型。</p><p id="a390" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">例如在普通python中</p><figure class="kf kg kh ki fq iu"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="535d" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">将打印出的<strong class="jh hu"> <em class="kd"> Hello World </em> </strong>输入到输出中但是用Tensorflow、</p><figure class="kf kg kh ki fq iu"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="8605" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">将打印出的<strong class="jh hu"> <em class="kd">张量(" Const:0 "，shape=()，dtype=string) </em> </strong>输出到输出。这是因为我们还没有在会话中运行计算图形，所以Tensorflow仍然只创建了图形。</p><p id="6b75" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu"> <em class="kd">那么，使用图表有什么好处呢？</em> </strong></p><ul class=""><li id="9b0d" class="kl km ht jh b ji jj jm jn jq kn ju ko jy kp kc kq kr ks kt dt translated"><strong class="jh hu">排比。</strong>通过使用显式边来表示操作之间的依赖关系，系统很容易识别可以并行执行的操作。</li><li id="fe5d" class="kl km ht jh b ji ku jm kv jq kw ju kx jy ky kc kq kr ks kt dt translated"><strong class="jh hu">分布式执行。</strong>通过使用显式边缘来表示在操作之间流动的值，TensorFlow可以将您的程序划分到连接到不同机器的多个设备(CPU、GPU和TPU)上。TensorFlow在设备之间插入了必要的通信和协调。</li><li id="9e54" class="kl km ht jh b ji ku jm kv jq kw ju kx jy ky kc kq kr ks kt dt translated"><strong class="jh hu">编译。TensorFlow的XLA编译器可以使用数据流图中的信息来生成更快的代码，例如，通过融合相邻的操作。</strong></li><li id="8d0b" class="kl km ht jh b ji ku jm kv jq kw ju kx jy ky kc kq kr ks kt dt translated"><strong class="jh hu">便携性。</strong>数据流图是模型中独立于语言的代码表示。你可以在Python中建立一个数据流图，存储在SavedModel中，在C++程序中恢复，实现低延迟推理。</li></ul><p id="071c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu"> <em class="kd">让我们构建一个简单的图形并执行它</em> </strong></p><p id="feea" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">让我们创建一个计算图来计算圆的面积。计算圆的面积的数学函数是:a = πr^2</p><p id="8bf2" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">首先让我们定义我们的图表:</p><figure class="kf kg kh ki fq iu"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="e52a" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们有一个称为“pi”的常数和一个占位符“r ”,它将作为一个输入馈入到这个图形中。</p><p id="bfe7" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">让我们检查节点的图形和值。默认情况下，Tensorflow会为您创建一个图表，但您也可以创建自己的图表。</p><figure class="kf kg kh ki fq iu"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="154d" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">输出将类似于这样:[ <tf.operation type="Const">，<tf.operation type="Placeholder">，<tf.operation type="Mul">，<tf.operation type="Mul"/></tf.operation></tf.operation></tf.operation></p><figure class="kf kg kh ki fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff kz"><img src="../Images/422c7093f56b5cf3c468bda61a047801.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*5pWgkhpnopO3347E0ylN3w.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Graph generated by Tensorboard</figcaption></figure><p id="b6b1" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">要运行此图，让我们创建一个Tensorflow会话，并以r = 5作为输入运行该会话。</p><figure class="kf kg kh ki fq iu"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="3e75" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">您可以将之前在会话中定义的占位符值作为python字典提供，其中关键字是占位符名称，值可以是列表。</p><p id="9fcf" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这是Tensorflow的图表和会话中的一个秘密峰值。如何将这些用于神经网络将在以后的文章中讨论。然而，有了像Keras和Tensorflow Estimators这样的新的高级API，开发人员不再需要担心这些底层概念，但从长远来看，了解内部工作方式确实是有益的。</p><p id="e439" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">请在下面留下您的评论，如果您认为这将是有用的，请鼓掌并分享。谢谢！</p><p id="ba07" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu"> <em class="kd">原帖可在</em></strong><a class="ae ke" href="https://keshan.github.io/graphs-sessions/" rel="noopener ugc nofollow" target="_blank"><strong class="jh hu"><em class="kd">Keshan . github . io</em></strong></a>找到</p></div></div>    
</body>
</html>