<html>
<head>
<title>Meteor Ethereum Transaction Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">流星以太坊交易服务器</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/meteor-ethereum-transaction-server-784b26a247e?source=collection_archive---------4-----------------------#2018-08-19">https://medium.com/coinmonks/meteor-ethereum-transaction-server-784b26a247e?source=collection_archive---------4-----------------------#2018-08-19</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/238a4fa09764825d44c81f5a3ed70264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*td-bY79ZZEMzjBkPtJIB6A.png"/></div></div></figure><p id="9b0c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这可能会扼杀去中心化的想法，但是对于某些应用程序，我们需要一个服务器在区块链中进行事务处理。如果我们将使用<a class="ae jz" href="https://www.meteor.com" rel="noopener ugc nofollow" target="_blank"> Meteor </a>作为服务器，那么由于<a class="ae jz" href="https://blog.meteor.com/introducing-ddp-6b40c6aff27d" rel="noopener ugc nofollow" target="_blank"> DDP技术</a>，当一个新的交易被包含在块中并被确认时，客户端会及时收到更新。</p><p id="a453" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了制作一个流星以太坊交易服务器，我们在项目智能合同中加入了<a class="ae jz" href="https://github.com/sevriugin/LoyaltyCrowdsurance/tree/mainnet/build/contracts" rel="noopener ugc nofollow" target="_blank">工件</a>，在我们的例子中，这些工件是由<a class="ae jz" href="https://truffleframework.com" rel="noopener ugc nofollow" target="_blank"> Truffle </a>生产的。我们还需要<em class="ka"> Web3 </em>库和一个密钥库来保存服务器帐户。在我们的例子中，我们使用<a class="ae jz" href="https://github.com/trufflesuite/truffle-hdwallet-provider" rel="noopener ugc nofollow" target="_blank"><em class="ka">truffle-HD wallet-provider</em></a>作为密钥库，我们希望服务器可以使用两个地址来签署以太坊交易:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="a6cd" class="kk kl ht kg b fv km kn l ko kp">import { Meteor }           from 'meteor/meteor';<br/>import Web3                 from 'web3';<br/>import contract             from 'truffle-contract';<br/>import HDWalletProvider     from 'truffle-hdwallet-provider';<br/>import TokenLoyaltyArtifact from './build/contracts/TokenLoyalty.json';</span><span id="c83a" class="kk kl ht kg b fv kq kn l ko kp">export default class TokenLoyalty {<br/>  constructor() {<br/>    this.instance = undefined;<br/>    this.data = undefined;<br/>    this.web3Provider = new HDWalletProvider(Meteor.settings.mnemonic, Meteor.settings.networks.rinkeby, 0, 2);</span><span id="f9b7" class="kk kl ht kg b fv kq kn l ko kp">this.address = this.web3Provider.addresses[0];    // contract owner<br/>this.tokenAddr = this.web3Provider.addresses[1];  // token owner</span><span id="9dbd" class="kk kl ht kg b fv kq kn l ko kp">// ...</span><span id="0247" class="kk kl ht kg b fv kq kn l ko kp">}</span></pre><p id="8605" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="ka"> HDWalletProvider </em>构造函数中的最后一个参数要求<em class="ka">truffle-HD wallet-provider</em>生成两个账户，之后提供者可以签署来自这两个账户的交易。请注意，如果您不喜欢收到这样的错误</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="2d0d" class="kk kl ht kg b fv km kn l ko kp">TypeError: private key should be a Buffer</span></pre><p id="1c03" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在交易签名期间，您最好确保来自参数值的<em class="ka">中的所有字母都是小字母。</em></p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="408b" class="kk kl ht kg b fv km kn l ko kp">instance.payment(data.tokenId, {<strong class="kg hu">from: this.tokenAddr</strong>, gas:700000, gasPrice:"20000000000"})<br/>  .then(result =&gt; cb(result))<br/>  .catch(error =&gt; console.error(error));</span></pre><p id="22fe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如，在我们的例子中，当我们试图使用下面的常量代替this.tokenAddr时，就会产生<strong class="jd hu">‘私钥应该是一个缓冲区’</strong>错误</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="b853" class="kk kl ht kg b fv km kn l ko kp">const ownerAddress = "0x2952920b5813447f86D6c30Ad1e5C0975Fe563dd";</span></pre><p id="f831" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里有一些大写字母，但不是全部，这就是为什么很难注意到这一点。这个常数只是从<a class="ae jz" href="https://truffleframework.com/ganache" rel="noopener ugc nofollow" target="_blank"> Ganache </a>账户部分复制和过去的:</p><figure class="kb kc kd ke fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff kr"><img src="../Images/62f55ac8c5dd212530d14cd1c461a600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c3PXo3tDg3jxCGqJbk1myw.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">Ganache 1.1.0 ACCOUNTS</figcaption></figure><p id="0f03" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，当我们的密钥库准备就绪，我们可以使用<em class="ka"> HDWalletProvider </em>到<em class="ka"> </em> sing事务时，我们可以编写方法来调用智能契约函数，就像前面的例子一样，这时我们调用<em class="ka"> payment </em>并开始监听事件来更新我们服务器上的MongoDb集合。例如，当<em class="ka">payed</em>事件到达时，我们使用<em class="ka"> _setData </em>方法调用更新数据库状态的回调函数:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="caa8" class="kk kl ht kg b fv km kn l ko kp">instance.Paid().watch((err, responce) =&gt; {<br/>  if(err) {<br/>    console.error(err)<br/>  }<br/>  else {<br/>    that._setData({ event:responce.event,<br/>      tx:responce.transactionHash,<br/>      tokenId:responce.args.tokenId.toString(),<br/>      supPoolId:responce.args.subPoolId.toString(),<br/>    });<br/>  }<br/>});</span><span id="b071" class="kk kl ht kg b fv kq kn l ko kp">_setData(data) {<br/>  if(this.data !== data) {<br/>    this.data = data;<br/>    if(this.watch !== undefined) {<br/>      this.watch(data);<br/>    }<br/>  }<br/>}</span><span id="0b32" class="kk kl ht kg b fv kq kn l ko kp">setWatch(cb) {<br/>  this.watch = cb;<br/>}</span><span id="c7be" class="kk kl ht kg b fv kq kn l ko kp">// ...</span><span id="ed87" class="kk kl ht kg b fv kq kn l ko kp">let tokenLoyalty;</span><span id="3f1a" class="kk kl ht kg b fv kq kn l ko kp">if (Meteor.isServer) {<br/>  tokenLoyalty = new TokenLoyalty();<br/>  tokenLoyalty.setWatch(Meteor.bindEnvironment((data) =&gt; {<br/>    // ...<br/>    if(data.event === "Paid" &amp;&amp; <br/>      Tokens.collection.findOne({ nft_id: data.tokenId })) {<br/>        Tokens.collection.update({ nft_id: data.tokenId }, <br/>          { $set: { paid:true, inprogress:false } });<br/>        //...<br/>    }<br/>    // ...<br/>  }));<br/>}</span></pre><p id="b388" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我们的例子中，我们的智能合约有以下我们处理的事件:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="445f" class="kk kl ht kg b fv km kn l ko kp">/// payment event</span><span id="5cda" class="kk kl ht kg b fv kq kn l ko kp">event Paid(uint subPoolId, uint tokenId, uint value, uint debit, uint payment, uint timeStamp, uint closure);</span></pre><p id="274d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，我们使用<em class="ka"> responce.args.tokenId </em>进行集合更新。如果事件主题的类型是<em class="ka"> uint </em>和<em class="ka">T5】在这种情况下，<em class="ka"> responce.args.tokenId </em>的值将是一个大数字，如下所示</em></p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="60b8" class="kk kl ht kg b fv km kn l ko kp">BigNumber { s: 1, e: 0, c: [ 3 ] }</span></pre><p id="1259" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这就是为什么我们使用<em class="ka"> toString() </em>函数来拥有更方便的对象类型来存储和搜索。我们还需要在服务器端将回调函数封装在<em class="ka">meteor . bind environment()</em>方法调用中，否则您会得到以下错误消息:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="7edb" class="kk kl ht kg b fv km kn l ko kp">Error: Meteor code must always run within a Fiber.</span></pre><p id="a720" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们在使用我们的服务器进行智能合约测试时发现的另一个非常重要的发现是，函数调用的gas量必须设置为函数在所有情况下可以消耗的最大值。例如，下面的代码在大多数情况下都没有问题，但是当我们需要在<em class="ka"> create </em>调用期间将子池添加到我们的结构中时，会出现错误。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="5bd5" class="kk kl ht kg b fv km kn l ko kp">instance.create(data.member, data.clientId, {from: that.address,<br/>  gas:500000, gasPrice:"20000000000"})<br/>    .then(result =&gt; cb(result))<br/>    .catch(error =&gt; console.error(error));</span></pre><p id="a073" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">不幸的是，在这种情况下，我们会收到错误消息</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="f81a" class="kk kl ht kg b fv km kn l ko kp">Transaction: 0x4dbcf824185eb06d68e94f01b2542c134409b6793cadf9b3a1eb325a731769e2 exited with an error (status 0). Please check that the transaction:<br/>  - satisfies all conditions set by Solidity `require` statements.<br/>  - does not trigger a Solidity `revert` statement.</span></pre><p id="8fcd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">没有提到气体问题，我们已经花了一些时间在<a class="ae jz" href="https://rinkeby.etherscan.io/vmtrace?txhash=0x4dbcf824185eb06d68e94f01b2542c134409b6793cadf9b3a1eb325a731769e2" rel="noopener ugc nofollow" target="_blank"> etherscan.io </a>中了解到，SSTORE指令已经消耗了大部分剩余气体。</p><figure class="kb kc kd ke fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff kw"><img src="../Images/1e9ea06e0646f5d882b0ea5ae069e764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Spfz2lweDk2yJ18O8xF6g.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">etherscan.io <strong class="bd kx">GETH</strong> Trace for TxHash</figcaption></figure><p id="ef42" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，在我们将气体量从500000更改为900000后，<em class="ka">创建</em>事务顺利通过。需要说明的是，在DAPP环境中，由于有了<a class="ae jz" href="http://Metamask.io" rel="noopener ugc nofollow" target="_blank"> Metamask.io </a>气体预测功能，我们将不会遇到这样的问题，气体量将会相应调整。</p><p id="59f8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你可以在我们的<a class="ae jz" href="https://github.com/REGA-RS/meteor-token/tree/ethereum" rel="noopener ugc nofollow" target="_blank"> REGA风险分担库</a>找到流星以太坊交易服务器的代码，所有智能合约都在<a class="ae jz" href="https://github.com/sevriugin/LoyaltyCrowdsurance" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><blockquote class="ky"><p id="89e6" class="kz la ht bd lb lc ld le lf lg lh jy ek translated"><a class="ae jz" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="lj lk ll lm ln iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff li"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>