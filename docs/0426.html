<html>
<head>
<title>Hyperledger Sawtooth for a Beginner — Transactions and Batches</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的Hyperledger锯齿-事务和批</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/hyperledger-sawtooth-for-a-beginner-transactions-and-batches-7c9cf444ecb5?source=collection_archive---------3-----------------------#2018-05-03">https://medium.com/coinmonks/hyperledger-sawtooth-for-a-beginner-transactions-and-batches-7c9cf444ecb5?source=collection_archive---------3-----------------------#2018-05-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/afd3e472eef985b277e4bcfe49262202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*DWyy7KD54udGJ31BA_NHfA.png"/></div><figcaption class="ix iy fg fe ff iz ja bd b be z ek">source: <a class="ae jb" href="https://sawtooth.hyperledger.org/docs/core/releases/1.0/architecture/transactions_and_batches.html" rel="noopener ugc nofollow" target="_blank">HLST docs</a></figcaption></figure><p id="3d3b" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">上图是<a class="ae jb" href="http://sawtooth.hyperledger.org" rel="noopener ugc nofollow" target="_blank"> Hyperledger锯齿</a>架构中交易和批的每个字段的完整细分。</p><p id="d473" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">批次是系统中变化的的<em class="ka">原子单位。它是影响分类账状态的交易的集合。当一个批处理没有被完全处理时，其中的所有事务都会被暂停。这种结构简化了依赖机制，其中一个事务或一组事务需要验证前一个事务才能正常工作:那些具有相同或不冲突的依赖关系的事务一起进入一个批处理。</em></p><p id="a822" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">两种结构遵循相同的正确格式原则；例如，它们都包含并且通过它们的报头细节的散列来寻址。它们还需要签名和验证，以确保其正确性。</p><p id="f19f" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">如果你不知道在<a class="ae jb" href="https://en.wikipedia.org/wiki/Merkle_tree" rel="noopener ugc nofollow" target="_blank"> Merkle Tree </a>结构中签名有什么帮助，下面是发生的事情:</p><ul class=""><li id="fd73" class="kb kc ht je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">数据是字段的集合，这些字段被加在一起，并通过算法转换成一个唯一的字符串，称为<em class="ka">散列</em></li><li id="0e5f" class="kb kc ht je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">可以利用散列中其他字段的知识来解密字段</li><li id="3959" class="kb kc ht je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">更改底层数据会修改哈希</li><li id="a40d" class="kb kc ht je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">签名可以被验证为通过特定的公钥和特定的散列应用于散列</li></ul><p id="39b8" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">换句话说，所有内容都被序列化为这个唯一的字符串，该字符串经过签名以确保数据的可验证完整性。如果数据发生变化，签名的哈希解密将与原始哈希不匹配，我们就会知道发生了什么。</p><h2 id="bcb8" class="kp kq ht bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">更多的绒毛</h2><p id="a8a8" class="pw-post-body-paragraph jc jd ht je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hm dt translated">在依赖项和输入/输出下的文档中提供了一个非常酷的功能:</p><blockquote class="lp lq lr"><p id="3bb7" class="jc jd ka je b jf jg jh ji jj jk jl jm ls jo jp jq lt js jt ju lu jw jx jy jz hm dt translated">部分地址充当通配符，允许事务指定树的一部分，而不仅仅是叶节点。</p></blockquote><p id="c15d" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">这意味着可以通过指向树中较高位置的单个地址来检索一组给定的事务。</p><p id="690c" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">你可能不知道，但是锯齿波使用了一种独特的寻址格式。前3个字节-或6个字符-用于识别区块链的名称空间，然后后续的字符对指的是树中的下一个分支，直到到达树叶。</p><p id="f333" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">我发现这种格式在设计系统结构时特别容易使用。它非常直观，提供了一个可以简单缩放的模型。例如，系统可以按最大公约数对事务进行批处理，并将它们发送给指定的验证对等方。这通过在交易的网络范围内建立明确的责任划分简化了验证过程。</p><h2 id="8a64" class="kp kq ht bd kr ks kt ku kv kw kx ky kz jn la lb lc jr ld le lf jv lg lh li lj dt translated">好了，现在怎么办</h2><p id="f567" class="pw-post-body-paragraph jc jd ht je b jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv lo jx jy jz hm dt translated">我将尝试这个框架，并试图结合我稀疏的编程知识，为公司创造有趣的解决方案。如果你对entreprise软件的开发过程感兴趣，特别是如果你喜欢看一个初学者穿过茂密的丛林动物，你会在这里有宾至如归的感觉。</p><p id="dd09" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">反馈</p><figure class="lw lx ly lz fq iu fe ff paragraph-image"><a href="https://medium.com/coinmonks/hyperledger/home"><div class="fe ff lv"><img src="../Images/4ce276b12133bcf77775d9bbb8532843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ekG9A5ERn70rcJT4KDHudQ.png"/></div></a><figcaption class="ix iy fg fe ff iz ja bd b be z ek"><strong class="bd ma">Click to read more Hyperledger Stories</strong></figcaption></figure></div></div>    
</body>
</html>