<html>
<head>
<title>How to deploy and test system chaincodes on Hyperledger Fabric effectively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Hyperledger Fabric上有效地部署和测试系统链码</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-deploy-and-test-system-chaincodes-on-hyperledger-fabric-effectively-84851dac651f?source=collection_archive---------0-----------------------#2019-02-07">https://medium.com/coinmonks/how-to-deploy-and-test-system-chaincodes-on-hyperledger-fabric-effectively-84851dac651f?source=collection_archive---------0-----------------------#2019-02-07</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/8e0c5e6bdfdb63813edac9c683b03d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-ei8djglP1haQ3CL.png"/></div></div></figure><p id="4d02" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我一直在从事一个项目，该项目要求我在<a class="ae jz" href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/" rel="noopener ugc nofollow" target="_blank"> Hyperlerledger Fabric </a>上实现自定义系统链码(<strong class="jd hu"> SCC </strong>),我在2019年1月的大部分时间都在从事这个项目，并试图了解Fabric如何工作，以及测试和部署系统链码的最佳方式是什么。在这个过程中，我与hyperledger社区的一些成员进行了互动，他们在解释不明显的做法方面非常有帮助。在这篇文章中，我将尝试解释在测试时有效部署系统链代码的最佳步骤和实践。本教程将不详细讨论编写系统链代码，因为它们在文档中有详细介绍。</p><h2 id="0f5d" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku dt translated">为什么使用系统链码？</h2><p id="748a" class="pw-post-body-paragraph jb jc ht jd b je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju kz jw jx jy hm dt translated">如果你刚开始看面料，问这个问题，在大多数情况下，常规链码就足够了。但是，如果您需要在对等体中直接完成某些事情，而不是在受限的docker容器中，那么您将需要使用系统链代码。这方面的一个例子是拥有一个独立的通信媒介(即对等体之间的直接套接字通信)而不是使用通道。</p><h2 id="51ee" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku dt translated">怎么写系统链码？</h2><p id="af79" class="pw-post-body-paragraph jb jc ht jd b je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju kz jw jx jy hm dt translated">编写实际的系统链码与普通的链码没有太大的不同，有一个“<em class="la">垫片。Chaincode </em>"接口定义了一些需要由Chaincode实现的方法。我不会在此赘述，hyperledger <a class="ae jz" href="https://hyperledger-fabric.readthedocs.io/en/release-1.3/chaincode4ade.html" rel="noopener ugc nofollow" target="_blank">文档</a>对此做了很好的解释。</p><p id="9520" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于像对等ip查找系统链码这样的东西，下面的代码就可以了</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="b67e" class="ka kb ht lg b fv lk ll l lm ln">package main</span><span id="1759" class="ka kb ht lg b fv lo ll l lm ln">import (<br/> “fmt”</span><span id="2c54" class="ka kb ht lg b fv lo ll l lm ln">“github.com/hyperledger/fabric/core/chaincode/shim”<br/> pb “github.com/hyperledger/fabric/protos/peer”<br/>)</span><span id="f331" class="ka kb ht lg b fv lo ll l lm ln">// New returns an implementation of the chaincode interface.<br/>func New() shim.Chaincode {<br/> fmt.Println(“Hello”)</span><span id="cc43" class="ka kb ht lg b fv lo ll l lm ln"> peer1org1, err := net.LookupHost("peer1.org1.example.com")<br/> if err != nil {<br/>    log.Fatalf("net.LookupHost peer1.org1.example.com failed with %s\n", err)<br/>  }<br/>  fmt.Println(peer1org1) <br/>  return &amp;helloworldscc{}<br/>}</span><span id="5e56" class="ka kb ht lg b fv lo ll l lm ln">type helloworldscc struct{}</span><span id="5f08" class="ka kb ht lg b fv lo ll l lm ln">// Init implements the chaincode shim interface<br/>func (s *helloworldscc) Init(stub shim.ChaincodeStubInterface) pb.Response {<br/> return shim.Success(nil)<br/>}</span><span id="1c27" class="ka kb ht lg b fv lo ll l lm ln">// Invoke implements the chaincode shim interface<br/>func (s *helloworldscc) Invoke(stub shim.ChaincodeStubInterface) pb.Response {<br/> return shim.Success(nil)<br/>}</span></pre><h2 id="2107" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku dt translated">部署SCC</h2><p id="d5bb" class="pw-post-body-paragraph jb jc ht jd b je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju kz jw jx jy hm dt translated">部署SCC有两种选择。你可以用标准格式来部署它，就像查询系统chaincode和其他内置系统是如何部署的一样，即它们是静态链接的。选项是使用Go插件，并将SCC动态链接到对等体。</p><p id="1b13" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第一种方法的问题是需要为系统链代码中的每次更改重建docker映像。这需要6-10分钟。</p><p id="f651" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在第二种方法中，只需要构建Go插件并提供链接配置。我将介绍这种方法所需的步骤，以及如何运行端到端测试。</p><h2 id="f595" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku dt translated">构建SCC插件</h2><p id="4c87" class="pw-post-body-paragraph jb jc ht jd b je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju kz jw jx jy hm dt translated">系统链码插件可以用下面的标志来构建。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="7223" class="ka kb ht lg b fv lk ll l lm ln">go build -buildmode=plugin</span></pre><p id="9df4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了运行端到端测试，我们需要将其构建在与结构对等docker映像相同的平台中。以下命令将插件挂载到fabric-baseimage的docker容器中，并在那里构建插件。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="1782" class="ka kb ht lg b fv lk ll l lm ln">docker run -i --rm  -v PATH_TO_PLUGIN:/opt/gopath/src/github.com/PLUGIN_NAME -w /opt/gopath/src/github.com/PLUGIN_NAME \<br/>-v PATH_TO_FABRIC:/opt/gopath/src/github.com/hyperledger/fabric \<br/>hyperledger/fabric-baseimage:amd64-0.4.14 \<br/>go build -buildmode=plugin -tags</span></pre><h2 id="0c82" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku dt translated">设置Fabric以允许SCC插件的动态链接:</h2><p id="c0da" class="pw-post-body-paragraph jb jc ht jd b je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju kz jw jx jy hm dt translated">我们需要添加关于插件的信息，并在core.yaml文件中启用它。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="662f" class="ka kb ht lg b fv lk ll l lm ln">system:<br/>         cscc: enable<br/>         lscc: enable<br/>         escc: enable<br/>         vscc: enable<br/>         qscc: enable<br/>         helloworldscc: enable<br/> <br/> systemPlugins:<br/>       - enabled: true<br/>         name: helloworldscc<br/>         path: /opt/lib/helloworld.so<br/>         invokableExternal: true<br/>         invokableCC2CC: true</span></pre><p id="451f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在fabric 1.4版本中，SCC插件被禁用，但他们添加了一个秘密标志以允许更快的开发。这个问题的jira 有更多关于为什么他们禁用它的信息。</p><p id="5aee" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对等体必须使用以下标志来构建</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="38d8" class="ka kb ht lg b fv lk ll l lm ln">GO_TAGS+=" pluginsenabled" make peer</span></pre><p id="d5d9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">端到端测试使用docker容器，因此容器也应该使用</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="78cb" class="ka kb ht lg b fv lk ll l lm ln">DOCKER_DYNAMIC_LINK=true GO_TAGS+=" pluginsenabled" make peer-docker</span></pre><h2 id="cd41" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku dt translated">运行端到端测试:</h2><p id="ea33" class="pw-post-body-paragraph jb jc ht jd b je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju kz jw jx jy hm dt translated">我喜欢使用第一个出现在<a class="ae jz" href="https://github.com/hyperledger/fabric-samples" rel="noopener ugc nofollow" target="_blank"> fabric-samples </a>仓库中的网络环境。确保修改对等体的docker映像，以挂载一个指向先前core.yaml条目中提供的路径的卷。</p><h2 id="a1fa" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku dt translated">关于我:</h2><p id="1bb4" class="pw-post-body-paragraph jb jc ht jd b je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju kz jw jx jy hm dt translated">我是UIUC的计算机科学硕士研究生。我在由安德鲁·米勒教授领导的分散系统实验室工作</p><h2 id="60a2" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku dt translated">免责声明:</h2><p id="4208" class="pw-post-body-paragraph jb jc ht jd b je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju kz jw jx jy hm dt translated">我不是hyperledger fabric的开发人员，我的知识和观点仅限于我的用例。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><a href="http://bit.ly/2G71Sp7"><div class="fe ff lp"><img src="../Images/449450761cd76f44f9ae574333f9e9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKX2mtg7p1lOs7JmosPLsA.png"/></div></a><figcaption class="lq lr fg fe ff ls lt bd b be z ek"><a class="ae jz" href="http://bit.ly/2G71Sp7" rel="noopener ugc nofollow" target="_blank"><strong class="bd lu">Click to Read today’s top story</strong></a></figcaption></figure><blockquote class="lv"><p id="ffb8" class="lw lx ht bd ly lz ma mb mc md me jy ek translated"><a class="ae jz" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mg mh mi mj mk iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mf"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>