<html>
<head>
<title>Data structure in Ethereum | Episode 1: Recursive Length Prefix (RLP) Encoding/Decoding.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊中的数据结构|第1集:递归长度前缀(RLP)编码/解码。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919?source=collection_archive---------0-----------------------#2018-01-03">https://medium.com/coinmonks/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919?source=collection_archive---------0-----------------------#2018-01-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/08da31422d2755f010339487d305ea84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hOM50ezzz5EcM8COCzYSFg.png"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Image source: <a class="ae ig" href="https://www.behance.net/gallery/36191437/Mini-Machines-02" rel="noopener ugc nofollow" target="_blank"><strong class="bd ih">www.behance.net</strong></a> by <a class="ae ig" href="https://www.behance.net/pixego" rel="noopener ugc nofollow" target="_blank"><strong class="bd ih">pixego</strong></a></figcaption></figure><div class=""/><p id="2f26" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">有很多论文和博客解释以太坊是如何组织数据的，但是它们看起来都是不连贯的，很难了解全貌。为了帮助你，顺便确认我的理解，本系列将对以太坊中的数据结构问题进行逐一讲解。</p><blockquote class="kf"><p id="3424" class="kg kh ik bd ki kj kk kl km kn ko ke ek translated"><a class="ae ig" href="https://coincodecap.com" rel="noopener ugc nofollow" target="_blank">发现并回顾最佳区块链软件</a></p></blockquote><p id="b048" class="pw-post-body-paragraph jh ji ik jj b jk kp jm jn jo kq jq jr js kr ju jv jw ks jy jz ka kt kc kd ke hm dt translated">我将把这个主题分成5个主要部分和1个额外部分(我称之为1+部分):</p><ol class=""><li id="38e7" class="ku kv ik jj b jk jl jo jp js kw jw kx ka ky ke kz la lb lc dt translated">递归长度前缀(RLP)编码/解码。和1+表示十六进制前缀编码。</li><li id="fbba" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">Trie — Radix和默克尔。</li><li id="21c9" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">特里——帕特丽夏。</li><li id="ab93" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">例子。</li><li id="726a" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">状态树修剪。</li></ol></div><div class="ab cl li lj hb lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hm hn ho hp hq"><blockquote class="lp lq lr"><p id="31d2" class="jh ji ls jj b jk jl jm jn jo jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd ke hm dt translated">首先，我们要弄清楚RLP，那么RLP在以太坊的目的是什么？</p></blockquote><p id="eb75" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il"> <em class="ls">【递归长度前缀(RLP) </em> </strong></p><p id="4551" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">在计算机科学中，许多复杂的数据形式只能以一种正式格式存储或传输，数据序列化是必要的。因此，RLP是一种编码/解码算法，可以帮助以太坊序列化数据，并可以快速重建数据。</p><p id="065b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il"> <em class="ls"> RLP编码</em> </strong></p><p id="740b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">正如以太坊提到的，RLP编码函数接收一个项目。项目的定义如下</p><ul class=""><li id="2b73" class="ku kv ik jj b jk jl jo jp js kw jw kx ka ky ke lw la lb lc dt translated">字符串(将被转换为字节数组)是一个项目</li><li id="e7cf" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated">项目列表是一个项目</li></ul><p id="00fd" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">例如，以下所有对象都是项目:</p><ul class=""><li id="f571" class="ku kv ik jj b jk jl jo jp js kw jw kx ka ky ke lw la lb lc dt translated">“狗”</li><li id="84db" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt">[]</li><li id="c8c9" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated">[“狗”]</li><li id="a152" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated">[[]，"狗"，["猫"]，" "]</li></ul><p id="0248" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">RLD编码定义如下:</p><ol class=""><li id="1791" class="ku kv ik jj b jk jl jo jp js kw jw kx ka ky ke kz la lb lc dt translated">如果输入的是<code class="eh lx ly lz ma b">[0x00, 0x7f]</code>范围内的单个字节，那么本身就是RLP编码。</li><li id="f270" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">如果输入为非值(uint(0)，[]byte{}，string(" ")，空指针…)，RLP编码为<code class="eh lx ly lz ma b">0x80</code>。注意<code class="eh lx ly lz ma b">0x00</code>值字节是<strong class="jj il">而不是</strong>非值。</li><li id="e77a" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">如果输入是<code class="eh lx ly lz ma b">[0x80, 0xff]</code>范围内的特殊字节，RLP编码会将<code class="eh lx ly lz ma b">0x81</code>与字节<code class="eh lx ly lz ma b">[0x81, the_byte]</code>连接起来。</li><li id="7715" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">如果输入是一个2-55字节长的字符串，RLP编码由一个值为<code class="eh lx ly lz ma b">0x80</code>的单字节加上字符串的字节长度以及字符串的十六进制值数组组成。很容易看出第一个字节在<code class="eh lx ly lz ma b">[0x82, 0xb7]</code>范围内。<br/> <em class="ls">比如:</em> <code class="eh lx ly lz ma b">“hello world” = [<strong class="jj il">0x8b</strong>, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64]</code> <em class="ls">，因为</em> <code class="eh lx ly lz ma b">“hello world”</code> <em class="ls">在dec中有</em> <code class="eh lx ly lz ma b"><em class="ls">11</em></code> <em class="ls">字节或者在hex中有</em> <code class="eh lx ly lz ma b">0x0b</code> <em class="ls">，所以RLP编码的第一个字节是</em><code class="eh lx ly lz ma b">0x80 + 0x0b = <strong class="jj il">0x8b</strong></code><strong class="jj il"><em class="ls"/></strong><em class="ls">，在这之后我们串接</em> <code class="eh lx ly lz ma b">“hello word”</code> <em class="ls">的字节。</em></li><li id="667b" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">如果输入的字符串长度超过55个字节，RLP编码从左到右由3部分组成。第一部分是单个字节，值为<code class="eh lx ly lz ma b">0xb7</code>加上第二部分的字节长度。第二部分是字符串长度的十六进制值。最后一个是以字节为单位的字符串。第一个字节的范围是<code class="eh lx ly lz ma b">[0xb8, 0xbf]</code>。<br/> <em class="ls">例如:一个字符串有1024个“a”字符，所以编码为</em> <code class="eh lx ly lz ma b">“aaa…” = [<strong class="jj il">0xb9</strong>, <strong class="jj il">0x04</strong>, <strong class="jj il">0x00</strong>, 0x61, 0x61, …]</code> <em class="ls">。正如我们所看到的，从数组</em> <code class="eh lx ly lz ma b">0x61</code> <em class="ls">的第四个元素到最后是以字节为单位的字符串，这是第三部分。第二部分是</em> <code class="eh lx ly lz ma b"><strong class="jj il">0x04</strong>, <strong class="jj il">0x00</strong></code> <em class="ls">，它是字符串</em> <code class="eh lx ly lz ma b">0x0400 = 1024</code> <em class="ls">的长度。第一部分是</em> <code class="eh lx ly lz ma b"><strong class="jj il">0xb9</strong> = 0xb7 + 0x02</code> <em class="ls">，第二部分的长度是</em> <code class="eh lx ly lz ma b">0x02</code> <em class="ls">。</em></li><li id="b4d3" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">如果输入是空数组，RLP编码是单字节<code class="eh lx ly lz ma b">0xc0</code>。</li><li id="e587" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">如果输入是一个总有效载荷长度为0-55字节的列表，RLP编码由一个值为<code class="eh lx ly lz ma b">0xc0</code>的单字节加上列表的长度，然后是列表中项目的RLP编码的串联组成。第一个字节的范围是<code class="eh lx ly lz ma b">[0xc1, 0xf7]</code>。<br/> <em class="ls">例如:</em> <code class="eh lx ly lz ma b">[“hello”, “world”] = [0xcc, 0x85, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x85, 0x77, 0x6f, 0x72, 0x6c, 0x64]</code> <em class="ls">。在这个RLP编码中，</em> <code class="eh lx ly lz ma b">[0x85, 0x68, 0x65, 0x6c, 0x6c, 0x6f]</code> <em class="ls">是</em> <code class="eh lx ly lz ma b">“hello”</code> <em class="ls">的RLP编码，</em> <code class="eh lx ly lz ma b">[0x85, 0x77, 0x6f, 0x72, 0x6c, 0x64]</code> <em class="ls">是</em><code class="eh lx ly lz ma b">“world”</code><em class="ls"/><code class="eh lx ly lz ma b">0xcc = 0xc0 + 0x0c</code><em class="ls">的RLP编码，</em> <code class="eh lx ly lz ma b">0x0c = 0x06 + 0x06</code> <em class="ls">为总净荷长度。</em></li><li id="cfd9" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">如果输入是总有效载荷长度超过55字节的列表，RLP编码包括3个部分。第一个是单个字节，值为<code class="eh lx ly lz ma b">0xf7</code>加上第二部分的字节长度。第二部分是总有效载荷的长度。最后一部分是列表中项目的RLP编码的连接。第一个字节的范围是<code class="eh lx ly lz ma b">[0xf8, 0xff]</code>。</li><li id="0dab" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">还有一点，wiki以太坊里没有提到但是Golang源代码里有提到。带布尔型，<code class="eh lx ly lz ma b">true = 0x01</code>和<code class="eh lx ly lz ma b">false = 0x80</code>。</li></ol><p id="8975" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il"> <em class="ls"> RLP解码</em> </strong></p><p id="f3a6" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">当你弄清楚RLP编码是如何工作的时候，RLP解码就容易多了。实际上，RLP解码只是接收编码输入并解码数据的类型和长度。</p><ol class=""><li id="4705" class="ku kv ik jj b jk jl jo jp js kw jw kx ka ky ke kz la lb lc dt translated">根据输入的第一个字节，RLP解码分析数据的类型，实际数据的长度和偏移量。</li><li id="6cca" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">根据数据的类型和偏移量，对数据进行相应的解码。</li><li id="5e9a" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke kz la lb lc dt translated">如果可能，继续解码输入的其余部分。</li></ol><blockquote class="lp lq lr"><p id="e6f6" class="jh ji ls jj b jk jl jm jn jo jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd ke hm dt translated">RLP解码在维基以太坊有完整的解释，我不想浪费我们的时间重复一些不必要的东西。我会把参考资料放在下面。</p></blockquote><figure class="mc md me mf fq hv fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/77edc28c6afccc2d48e866c3599e0a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*M8HO1pKmz5mb8zoi5PUlkg.jpeg"/></div><figcaption class="ic id fg fe ff ie if bd b be z ek">When you don’t know something, just skip it by telling that it is easy. Hah.</figcaption></figure></div><div class="ab cl li lj hb lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hm hn ho hp hq"><p id="857a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il"> <em class="ls">潜入RLP </em> </strong></p><blockquote class="lp lq lr"><p id="7566" class="jh ji ls jj b jk jl jm jn jo jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd ke hm dt translated">事实上，以太坊维基已经解释了RLP非常容易理解，所以我只是通过我的写作风格提醒他们，我在这篇文章中期望的是潜入RLP并获得深入的理解。嗯，又来了<em class="ik">😑。</em></p><p id="5bbd" class="jh ji ls jj b jk jl jm jn jo jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd ke hm dt translated">还有一点，这里所有的想法只是我个人的观点，可能会被误解。所以，你应该重新检查它，说服自己，然后相信它，如果是正确的。</p></blockquote><p id="469e" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">正如我从维基以太坊读到的，RLP只关注字节、字符串和列表。一些额外的数据类型，如大数、布尔型、指针、滑动……是基于我们用来实现RLP的编程语言。</p><p id="be24" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">根据该文件，编码数据的第一个字节决定了数据的类型。</p><ul class=""><li id="e484" class="ku kv ik jj b jk jl jo jp js kw jw kx ka ky ke lw la lb lc dt translated"><code class="eh lx ly lz ma b">[0x00, 0x7f]</code>:字节</li><li id="7dde" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated"><code class="eh lx ly lz ma b">[0x80, 0xbf]</code>:字符串</li><li id="56bd" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated"><code class="eh lx ly lz ma b">[0xc0, 0xff]</code>:列表</li></ul><p id="2814" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il">第一个问题</strong>，我们为什么不用固定前缀，而用动态前缀？</p><p id="3c0a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">首先，你可以看到在RLP中，有时数据需要一些字节来描述数据的类型和长度，但有时数据本身也显示其类型和长度。</p><p id="af20" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">主要原因是为了节省内存空间。</p><p id="8369" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">如果我们尝试使用固定前缀，我们会将它们添加到我们想要编码的每个输入中，在某些情况下，主数据甚至比前缀更短。</p><p id="967b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">你可以说它将变得更容易阅读，但它只适用于人类。就计算机而言，它无法区分哪一个更复杂。计算机只是小心地运行代码的计算复杂度，在这种情况下，我很确定2个源代码的计算复杂度是一样的。</p><p id="f5c0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">此外，如果它是固定的，那么我们将使用多少字节？我们不确定。所以没必要。</p><p id="c7bb" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il">第二个问题</strong>，他们为什么选择<code class="eh lx ly lz ma b">0x7f, 0x80, 0xbf, 0xc0</code>作为检查点？</p><p id="1adc" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">按顺序想想就好了。我们不想使用任何前缀来编码单个字节，因为如果我们像在第一个问题中解释的那样使用固定前缀，存储编码数据将需要两倍(或三倍，或更多)的内存。所以我们需要确定一个范围，在这个范围内，字节由它自己编码。</p><figure class="mc md me mf fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mg"><img src="../Images/8e4cb471f2c4212c07ed34f6b9fe4caf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zH-2lVacfqRgwbifx4WXNQ.gif"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">ASCII Table.</figcaption></figure><p id="b6d0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">选择<code class="eh lx ly lz ma b">0x7f</code>可能不是偶然的。ASCII使用7位编码128个单个字符，对应<code class="eh lx ly lz ma b">0x7f</code>。我相信这就是选择<code class="eh lx ly lz ma b">[0x00, 0x7f]</code>的原因。然而，值为0x80的字节的RLP编码是什么？<br/>答案是我们加一个前缀，<code class="eh lx ly lz ma b">RLP_encode(0x80) = [0x81, 0x80]</code>。</p><p id="7815" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">之后，关于字符串和列表，我们别无选择，必须使用前缀。当他们把剩下的部分分成两半时，这是很明显的。<code class="eh lx ly lz ma b">[0x80, 0xbf]</code>用于字符串编码，而<code class="eh lx ly lz ma b">[0xc0, 0xff]</code>用于列表编码。</p><p id="5afe" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il">第三个问题</strong>，为什么一定要用一个range来描述一个类型而不是byte的唯一一个值，我相信byte的一个值就够了？</p><p id="4c38" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">是的，一个字节的值足以表示一种类型的数据，但是我们需要知道数据需要多长时间才能得到偏移量。为了做到这一点，如果我们只使用一个字节值来表示数据类型，我们必须添加更多的前缀。</p><p id="3a97" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">现在，你明白我们会遇到两个问题。首先，假设我们对字符串使用<code class="eh lx ly lz ma b">0x80</code>前缀，对列表使用<code class="eh lx ly lz ma b">0x81</code>前缀，那么我们浪费了这个字节来存储2个值，而它仍然可以做更多的事情。第二，我们似乎试图再次固定前缀(一个字节用于类型，一些字节用于数据长度),正如我在第一个问题中所讨论的，这可能会浪费很多内存。</p><p id="ffb9" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">我们选择一个字节范围，不仅对数据类型进行编码，还对数据长度进行编码。</p><p id="b6cf" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il">第四个问题</strong>，当数据长度超出前缀范围时，我们该怎么办？</p><p id="0775" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">这是一个可以理解的问题。我们在第一个字节后添加更多的动态前缀来表示数据的长度。例如，对于字符串类型的<code class="eh lx ly lz ma b">[0x80, 0xbf]</code>范围，根据我们上面所做的策略，我们将这个范围分成两半，一个(<code class="eh lx ly lz ma b">[0x80, 0xb7]</code>)用于长度在范围内的字符串，另一个(<code class="eh lx ly lz ma b">[0xb8, 0xbf]</code>)用于长度超出范围的字符串。列表也是如此。</p></div><div class="ab cl li lj hb lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hm hn ho hp hq"><p id="b374" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il"> <em class="ls">结论</em> </strong></p><p id="3f7d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">我不确定我上面的解释是否都是正确的，但至少，它给了我们一段关于RLP的动机和直觉的知识，所以我们可以部分地理解RLP是如何在以太坊工作的。</p><p id="423a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il"> <em class="ls">参考文献</em> </strong></p><p id="0078" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">来自维基以太坊的文档:</p><div class="hs ht fm fo hu mh"><a href="https://github.com/ethereum/wiki/wiki/RLP" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab ej"><div class="mj ab mk cl cj ml"><h2 class="bd il fv z el mm eo ep mn er et ij dt translated">以太坊/维基</h2><div class="mo l"><h3 class="bd b fv z el mm eo ep mn er et ek translated">维基-以太坊维基-</h3></div><div class="mp l"><p class="bd b gc z el mm eo ep mn er et ek translated">github.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv ia mh"/></div></div></a></div><p id="b5ad" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">RLP对原始戈兰语码:</p><div class="hs ht fm fo hu mh"><a href="https://github.com/ethereum/go-ethereum/tree/master/rlp" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab ej"><div class="mj ab mk cl cj ml"><h2 class="bd il fv z el mm eo ep mn er et ij dt translated">以太坊/围棋以太坊</h2><div class="mo l"><h3 class="bd b fv z el mm eo ep mn er et ek translated">以太坊-以太坊协议的官方go实现</h3></div><div class="mp l"><p class="bd b gc z el mm eo ep mn er et ek translated">github.com</p></div></div><div class="mq l"><div class="mw l ms mt mu mq mv ia mh"/></div></div></a></div><p id="ed09" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">我的github上的RLP带有一些调试行:</p><div class="hs ht fm fo hu mh"><a href="https://github.com/sontuphan/debug-geth/tree/master/rlp" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab ej"><div class="mj ab mk cl cj ml"><h2 class="bd il fv z el mm eo ep mn er et ij dt translated">sontuphan/debug-geth</h2><div class="mo l"><h3 class="bd b fv z el mm eo ep mn er et ek translated">在GitHub上创建一个帐户，为debug-geth开发做贡献。</h3></div><div class="mp l"><p class="bd b gc z el mm eo ep mn er et ek translated">github.com</p></div></div><div class="mq l"><div class="mx l ms mt mu mq mv ia mh"/></div></div></a></div><blockquote class="kf"><p id="f317" class="kg kh ik bd ki kj my mz na nb nc ke ek translated">加入Coinmonks <a class="ae ig" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ig" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae ig" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="nd ne ik bd nf ng nh ni nj nk nl nm nn js no np nq jw nr ns nt ka nu nv nw nx dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="ku kv ik jj b jk ny jo nz js oa jw ob ka oc ke lw la lb lc dt translated"><a class="ae ig" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae ig" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated"><a class="ae ig" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae ig" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated"><a class="ae ig" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae ig" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="50d2" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated"><a class="ae ig" rel="noopener" href="/coinmonks/binance-trading-bots-d0d57bb62c4c">币安交易机器人</a> | <a class="ae ig" rel="noopener" href="/coinmonks/okex-review-6b369304110f"> OKEx审查</a> | <a class="ae ig" href="https://coincodecap.com/atani-review" rel="noopener ugc nofollow" target="_blank">阿塔尼审查</a></li><li id="3b1f" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated"><a class="ae ig" rel="noopener" href="/coinmonks/best-crypto-signals-telegram-5785cdbc4b2b">最佳加密交易信号电报</a> | <a class="ae ig" rel="noopener" href="/coinmonks/moonxbt-review-6e4ab26d037"> MoonXBT评论</a></li><li id="c44c" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated"><a class="ae ig" href="https://coincodecap.com/buy-shiba-bitbns" rel="noopener ugc nofollow" target="_blank">如何在Bitbns上购买柴犬(SHIB)币？</a> | <a class="ae ig" href="https://coincodecap.com/buy-floki-inu-token" rel="noopener ugc nofollow" target="_blank">购买Floki </a></li><li id="af80" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated"><a class="ae ig" href="https://coincodecap.com/coinflex-review" rel="noopener ugc nofollow" target="_blank"> CoinFLEX评论</a> | <a class="ae ig" href="https://coincodecap.com/aex-exchange-review" rel="noopener ugc nofollow" target="_blank"> AEX交易所评论</a> | <a class="ae ig" href="https://coincodecap.com/upbit-review" rel="noopener ugc nofollow" target="_blank"> UPbit评论</a></li><li id="29b5" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated"><a class="ae ig" href="https://coincodecap.com/best-cryptocurrency-blogs" rel="noopener ugc nofollow" target="_blank">十大最佳加密货币博客</a> | <a class="ae ig" href="https://coincodecap.com/youhodler-review" rel="noopener ugc nofollow" target="_blank"> YouHodler评论</a></li><li id="f33b" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated"><a class="ae ig" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae ig" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated">开发人员的最佳加密API</li><li id="b359" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated">最佳<a class="ae ig" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated"><a class="ae ig" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae ig" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="ku kv ik jj b jk ld jo le js lf jw lg ka lh ke lw la lb lc dt translated"><a class="ae ig" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币的终极指南</a></li></ul></div></div>    
</body>
</html>