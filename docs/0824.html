<html>
<head>
<title>Accounting Base for Solidity Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可靠性智能合同的会计基础</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/accounting-base-for-solidity-smart-contracts-384c4d53eaaf?source=collection_archive---------6-----------------------#2018-06-22">https://medium.com/coinmonks/accounting-base-for-solidity-smart-contracts-384c4d53eaaf?source=collection_archive---------6-----------------------#2018-06-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/97cac8538fbf0b3c3c2619029692b19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Agw29dhSEy4CqFnijk-w_A.jpeg"/></div></div></figure><p id="ed3f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以太坊智能合约正被用来处理数十亿美元的价值，但令人惊讶的是，我还没有遇到一个处理<em class="jz">会计</em>的通用模式或库。在智能合约的上下文中，记账意味着以一种安全但易于理解的方式处理ether和ERC20令牌。</p><p id="5e6b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">为什么这是必要的？</strong>在开发智能合同时，有许多安全注意事项和细微差别需要考虑，但是如果有一个普遍接受和审核的模式，那么您不必在每次需要时都自己实现它。发送、接收和处理以太网和令牌可能是大多数智能合约最常见的功能之一，所以我提出了一个基本的<a class="ae ka" href="https://github.com/paradoxDAO/accounting/blob/master/contracts/Accounting.sol" rel="noopener ugc nofollow" target="_blank"> Accounting.sol </a>可以用作任何想要轻松处理不同帐户的智能合约的父合约。我将在下面概述会计的特性和使用案例:</p><h1 id="081d" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">详细描述</h1><p id="98ff" class="pw-post-body-paragraph jb jc ht jd b je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ld jw jx jy hm dt translated">首先，我使用<a class="ae ka" href="https://github.com/dapphub/ds-math/blob/master/src/math.sol" rel="noopener ugc nofollow" target="_blank"> DS-Math </a>进行安全的算术运算，但是为了简单起见，我把它变成了一个库，因为它原本是一个契约(我简单地把<code class="eh le lf lg lh b">library</code>的关键字改成了<code class="eh le lf lg lh b">contract</code>)。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="c8f5" class="lq kc ht lh b fv lr ls l lt lu">uint public totalETH; <br/>mapping (address =&gt; uint) public totalTokenBalances;</span></pre><p id="4f33" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第二，契约跟踪所计算的总ETH和令牌，因为ETH和令牌余额都可以在不执行任何代码的情况下改变。帐户是一种结构:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="94c4" class="lq kc ht lh b fv lr ls l lt lu">struct Account {<br/>	bytes32 name; <br/>	uint balanceETH;<br/>	mapping (address =&gt; uint) tokenBalances;<br/>}</span></pre><p id="3e8d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该名称可能不是每次使用都必须的，但为了清楚起见，还是包括在内。它不是强制设置的。会计基础有一个可用作默认帐户的“基础”帐户:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="5e06" class="lq kc ht lh b fv lr ls l lt lu">Account base = Account({<br/>	name: "Base",<br/>	balanceETH: 0<br/>});</span></pre><p id="d82c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">不同的可能事务有不同的事件:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="082b" class="lq kc ht lh b fv lr ls l lt lu">event <strong class="lh hu">ETHDeposited</strong>(bytes32 indexed account, address indexed from, uint value);     <br/>event <strong class="lh hu">ETHSent</strong>(bytes32 indexed account, address indexed to, uint value);     <br/>event <strong class="lh hu">ETHTransferred</strong>(bytes32 indexed fromAccount, bytes32 indexed toAccount, uint value);     <br/>event <strong class="lh hu">TokenTransferred</strong>(bytes32 indexed fromAccount, bytes32 indexed toAccount, address indexed token, uint value);     <br/>event <strong class="lh hu">TokenDeposited</strong>(bytes32 indexed account, address indexed token, address indexed from, uint value);         <br/>event <strong class="lh hu">TokenSent</strong>(bytes32 indexed account, address indexed token, address indexed to, uint value);</span></pre><p id="84af" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如您所见，您可以存放ETH和令牌，可以在内部帐户之间转移它们，还可以发送它们。</p><p id="931f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">存放乙醚和代币:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="f338" class="lq kc ht lh b fv lr ls l lt lu">function <strong class="lh hu">depositETH</strong>(Account storage a, address _from, uint _value) internal {<br/>         a.balanceETH = a.balanceETH.add(_value);<br/>         totalETH = totalETH.add(_value);<br/>         emit ETHDeposited(a.name, _from, _value);     <br/>}</span><span id="cce9" class="lq kc ht lh b fv lv ls l lt lu">function <strong class="lh hu">depositToken</strong>(Account storage a, address _token, address _from, uint _value)      <br/>internal noReentrance {<br/>	require(ERC20(_token).transferFrom(_from, address(this), 	_value));<br/>        totalTokenBalances[_token] = totalTokenBalances[_token].add	(_value);<br/>        a.tokenBalances[_token] = a.tokenBalances[_token].add	(_value);<br/>        emit TokenDeposited(a.name, _token, _from, _value);     <br/>}</span></pre><p id="a4a7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这些函数是内部的，所以您只需要在您的应付款和代币存款函数中使用它们。您自己为ether指定帐户和值(ether deposit函数实际上不会检查消息的值)。存放令牌需要批准，因此该函数将实际调用令牌契约并转移它们。</p><p id="f22b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您可以发送以太网和令牌，也可以与以太网进行交易，而无需担心重入、更新和检查余额:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="653a" class="lq kc ht lh b fv lr ls l lt lu">function <strong class="lh hu">sendETH</strong>(Account storage a, address _to, uint _value)      internal noReentrance {<br/>         require(a.balanceETH &gt;= _value);<br/>         require(_to != address(0));<br/>         a.balanceETH = a.balanceETH.sub(_value);<br/>         totalETH = totalETH.sub(_value);<br/>         _to.transfer(_value);<br/>         emit ETHSent(a.name, _to, _value);<br/>}</span><span id="6ce8" class="lq kc ht lh b fv lv ls l lt lu">function <strong class="lh hu">transact</strong>(Account storage a, address _to, uint _value, bytes data) internal noReentrance<br/>{<br/>         require(a.balanceETH &gt;= _value);<br/>         require(_to != address(0));<br/>         a.balanceETH = a.balanceETH.sub(_value);<br/>         totalETH = totalETH.sub(_value);<br/>         require(_to.call.value(_value)(data));                  	 emit ETHSent(a.name, _to, _value);<br/>}</span><span id="a045" class="lq kc ht lh b fv lv ls l lt lu">function <strong class="lh hu">sendToken</strong>(Account storage a, address _token, address _to, uint _value)      internal noReentrance      <br/>{<br/>         require(a.tokenBalances[_token] &gt;= _value);<br/>         require(_to != address(0));<br/>         a.tokenBalances[_token] = a.tokenBalances[_token].sub	(_value);<br/>         totalTokenBalances[_token] = totalTokenBalances[_token].sub	(_value);<br/>         require(ERC20(_token).transfer(_to, _value));<br/>         emit TokenSent(a.name, _token, _to, _value);<br/>}</span></pre><p id="5fe5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">从一个帐户转移到另一个帐户，也不用担心更新余额或检查不一致:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="a511" class="lq kc ht lh b fv lr ls l lt lu">function <strong class="lh hu">transferETH</strong>(Account storage _from, Account storage _to, uint _value) internal {<br/>         require(_from.balanceETH &gt;= _value);         	_from.balanceETH = _from.balanceETH.sub(_value);         	_to.balanceETH = _to.balanceETH.add(_value);<br/>        emit ETHTransferred(_from.name, _to.name, _value);     <br/>}</span><span id="5004" class="lq kc ht lh b fv lv ls l lt lu">function <strong class="lh hu">transferToken</strong>(Account storage _from, Account storage _to, address _token, uint _value) internal     <br/>{         require(_from.tokenBalances[_token] &gt;= _value);<br/>         _from.tokenBalances[_token] = _from.tokenBalances	[_token].sub(_value);<br/>         _to.tokenBalances[_token] = _to.tokenBalances[_token].add	(_value);<br/>         emit TokenTransferred(_from.name, _to.name, _token, 	_value);     <br/>}</span></pre><p id="0d2a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有几种会计基础合同变化:</p><ol class=""><li id="5dcf" class="lw lx ht jd b je jf ji jj jm ly jq lz ju ma jy mb mc md me dt translated">简单记帐—与上述相同，但没有令牌功能</li><li id="d41f" class="lw lx ht jd b je mf ji mg jm mh jq mi ju mj jy mb mc md me dt translated">会计——上面描述的那个</li><li id="5a14" class="lw lx ht jd b je mf ji mg jm mh jq mi ju mj jy mb mc md me dt translated">津贴会计—有限帐户的所有会计+功能，这些帐户具有以每秒<a class="ae ka" rel="noopener" href="/cryptolinks/maker-for-dummies-a-plain-english-explanation-of-the-dai-stablecoin-e4481d79b90">天</a>为单位的预设津贴。您可以将Dai或ETH存入有限的账户，当您提取ETH时，它会使用MakerDAO的价格反馈来检查汇率，并且在提取时只给您与您的津贴相等的ETH金额</li><li id="5cb1" class="lw lx ht jd b je mf ji mg jm mh jq mi ju mj jy mb mc md me dt translated">子帐户—允许拥有包含子帐户的超级帐户，以便可以清空超级帐户(子帐户的所有余额)，而无需更新子帐户。在您需要退还单笔金额或收集总计金额的情况下非常有用(例如，在众筹的情况下)。</li></ol><h1 id="576f" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">示例:</h1><h2 id="cabf" class="lq kc ht bd kd mk ml mm kh mn mo mp kl jm mq mr kp jq ms mt kt ju mu mv kx mw dt translated">存款箱</h2><figure class="li lj lk ll fq iu"><div class="bz el l di"><div class="mx my l"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek"><a class="ae ka" href="https://github.com/paradoxDAO/accounting/blob/master/examples/DepositBox.sol" rel="noopener ugc nofollow" target="_blank">DepositBox.sol</a></figcaption></figure><p id="0c78" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">注意合同的可读性有多强——任何人都可以把钱存入自己的账户并提取。还要注意的是，合同的所有者可以将<em class="jz">剩余的</em>乙醚和代币存入基本账户，这样就不会再丢失代币了！</p><h2 id="e49c" class="lq kc ht bd kd mk ml mm kh mn mo mp kl jm mq mr kp jq ms mt kt ju mu mv kx mw dt translated">工资单</h2><figure class="li lj lk ll fq iu"><div class="bz el l di"><div class="mx my l"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek"><a class="ae ka" href="https://github.com/paradoxDAO/accounting/blob/master/examples/Payroll.sol" rel="noopener ugc nofollow" target="_blank">Payroll.sol</a></figcaption></figure><p id="994a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的例子将津贴会计用于一个非常简单的工资合同——资金可以存入个人账户，所有者可以为每个账户设置津贴。</p><h2 id="7fb2" class="lq kc ht bd kd mk ml mm kh mn mo mp kl jm mq mr kp jq ms mt kt ju mu mv kx mw dt translated">资助活动</h2><figure class="li lj lk ll fq iu"><div class="bz el l di"><div class="mx my l"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek"><a class="ae ka" href="https://github.com/paradoxDAO/accounting/blob/master/examples/RefundableCampaign.sol" rel="noopener ugc nofollow" target="_blank">RefundableCampaign.sol</a></figcaption></figure><p id="957d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">任何人都可以为筹资目标做出贡献。如果达到了目标，所有者会收集所有资金，但如果没有达到，每个人都会得到全额退款。</p><h1 id="7380" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="d2a0" class="pw-post-body-paragraph jb jc ht jd b je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju ld jw jx jy hm dt translated">我预计未来公司的大部分财务活动都将在以太坊区块链上进行，因此我们需要一种更好的方式来概念化账户和处理价值。我已经为任何金融相关合同提出了一个会计基础，以安全、简单和可读地处理以太和ERC20令牌。欢迎建议和投稿！</p></div></div>    
</body>
</html>