<html>
<head>
<title>Part 4: Implementing Blockchain and Cryptocurrency with PoW consensus algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第4部分:用PoW共识算法实现区块链和加密货币</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/part-4-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-9201eb7e8a41?source=collection_archive---------1-----------------------#2018-10-27">https://medium.com/coinmonks/part-4-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-9201eb7e8a41?source=collection_archive---------1-----------------------#2018-10-27</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="3086" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在node.js中使用工作共识算法证明，小规模、易于理解、全面、逐步实施区块链和加密货币</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/ca1a2e2c4224dbbeb2b00eaca6e45a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*4tiX8RcB0DnrDZZ0l8yxGw.jpeg"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Source: <a class="ae ka" href="https://en.bitcoinwiki.org/wiki/Proof-of-work" rel="noopener ugc nofollow" target="_blank">Bitcoin Wiki</a></figcaption></figure><p id="a6d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<a class="ae ka" rel="noopener" href="/coinmonks/part-3-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-d9b8cb928e3e">之前的文章</a>中，我们为我们的区块链添加了多个贡献者的能力，并在其上创建了一个HTTP API。</p><p id="8962" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们可以与区块链互动，但我们仍然只有一个用户。为了拥有多个对等点，我们将制作一个p2p服务器，并使用WebSockets连接这些对等点。每个对等体与其他对等体通信并传输数据。</p><p id="5129" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我们启动我们的应用程序时，我们将连接到一些同行，当我们启动我们的应用程序时，我们将通过他们的地址。</p><h1 id="4a3a" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">P2P服务器</h1><p id="1304" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">我们需要一个p2p服务器，以便分散网络中的不同对等点可以通过网络相互发送块、链、事务和其他消息。</p><p id="70fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了在node.js中实现p2p服务器，我们需要一个名为<code class="eh le lf lg lh b">ws</code>的模块，这是一个轻量级的、易于使用的网络套接字模块。还有各种其他模块可用，但为了简单起见，我们将坚持使用这个模块。</p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="b575" class="lm kc ht lh b fv ln lo l lp lq">npm i ws --save</span></pre><p id="9cbc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在app内，目录下创建一个文件<code class="eh le lf lg lh b">p2p-server.js</code>。导入<code class="eh le lf lg lh b">ws</code>模块，为服务器定义一个<code class="eh le lf lg lh b">P2P_PORT</code>。像我们的HTTP服务器一样，我们可以使用环境变量从终端分配一个端口。</p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="1070" class="lm kc ht lh b fv ln lo l lp lq">const P2P_PORT = process.env.P2P_PORT || 5001;</span></pre><p id="07dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们需要一个<code class="eh le lf lg lh b">peers </code>列表，当我们启动应用程序时，我们将连接到它。每个对等体都有一个这样的地址</p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="ded8" class="lm kc ht lh b fv ln lo l lp lq">PEERS = ws://localhost:5002 P2P_PORT=5001 HTTP_PORT=3001 npm run dev</span><span id="12de" class="lm kc ht lh b fv lr lo l lp lq">const peers = process.env.PEERS ? process.env.PEERS.split(',') : [];</span></pre><p id="3951" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，我们可以将我们希望从终端连接到的对等点地址作为一个环境变量进行传递，并在以后访问我们的p2p服务器。</p><p id="9ae2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在让我们在p2p-server.js中创建一个P2pServer类，它将保存所有的消息处理程序和事件侦听器。</p><p id="b750" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">p2p服务器将有一个区块链变量，这将是我们在应用程序中使用的相同的区块链。因此，我们将传递一个区块链实例作为依赖项。我们的p2p服务器也有一个在给定时间内连接的套接字列表。</p><p id="bca3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们使用<code class="eh le lf lg lh b">peers</code>列表通过遍历每个对等体并将其套接字连接对象保存在套接字列表中以备后用来连接对等体。</p><p id="af1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们实施我们到目前为止所讨论的。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">P2pserver class</figcaption></figure><p id="0397" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我们的<code class="eh le lf lg lh b">app/index.js</code>文件中，我们将创建p2pserver的实例，传递区块链实例，然后启动p2pserver。</p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="f97d" class="lm kc ht lh b fv ln lo l lp lq">const P2pServer = require('./p2p-server.js');</span><span id="d09d" class="lm kc ht lh b fv lr lo l lp lq">const p2pserver = new P2pServer(blockchain);<br/>// passing blockchain as a dependency</span><span id="3f87" class="lm kc ht lh b fv lr lo l lp lq">.<br/>.<br/>.<br/>.</span><span id="4539" class="lm kc ht lh b fv lr lo l lp lq">p2pserver.listen(); // starts the p2pserver</span></pre><p id="04e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好了，现在让我们测试我们的p2p服务器。</p><p id="7629" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">启动终端，打开三个标签。在第一次选项卡运行中</p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="be9a" class="lm kc ht lh b fv ln lo l lp lq">npm run dev</span></pre><p id="3efc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在第二个</p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="ba45" class="lm kc ht lh b fv ln lo l lp lq">HTTP_PORT = 3002 P2P_PORT = 5002 PEERS = ws://localhost:5001 npm run dev</span></pre><p id="8c87" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在第三个</p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="4931" class="lm kc ht lh b fv ln lo l lp lq">HTTP_PORT = 3003 P2P_PORT = 5003 PEERS = ws://localhost:5002,ws://localhost:5001 npm run dev</span></pre><p id="8ab7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在第一个终端中，我们将得到输出</p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="6687" class="lm kc ht lh b fv ln lo l lp lq">Listening for peer to peer connection on port : 5001<br/>listening on port 3001<br/>Socket Connected<br/>Socket Connected</span></pre><p id="b2c1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在第二个终端中，我们将得到输出</p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="068a" class="lm kc ht lh b fv ln lo l lp lq">Listening for peer to peer connection on port : 5002<br/>listening on port 3002<br/>Socket Connected<br/>Socket Connected</span></pre><p id="0fda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在第一个终端中，我们将得到输出</p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="7b0e" class="lm kc ht lh b fv ln lo l lp lq">Listening for peer to peer connection on port : 5003<br/>listening on port 3003<br/>Socket Connected<br/>Socket Connected</span></pre><p id="26c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的插座现在互相连接了。</p><p id="a0f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">厉害！让我们使用这个P2P服务器来同步区块链，以构建一个完全分散的区块链网络。</p><p id="4b6d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们给p2p服务器添加一个消息处理程序。这个messageHandler函数将接受一个套接字作为参数。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">I handle your messages</figcaption></figure><p id="f455" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们需要将这个处理程序分配给每个套接字。每当我们在<code class="eh le lf lg lh b">connectSocket()</code>函数中建立一个新的连接时，我们都可以这样做。</p><p id="d19e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我们连接到对等体时，我们需要向它发送消息。因此，我们可以在连接上使用<code class="eh le lf lg lh b">socket.send()</code>来这样做，我们希望将我们的链发送给对等体。因此，当我们连接到一个套接字时，我们将把链作为消息发送给它们。</p><p id="657d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lu">注意:理想情况下，我们会发送块，因为链的大小非常大。但是为了简单起见，我们将发送整个链。</em></p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="2db8" class="lm kc ht lh b fv ln lo l lp lq">connectSocket(socket){</span><span id="a8d5" class="lm kc ht lh b fv lr lo l lp lq">// push the socket too the socket array<br/>        this.sockets.push(socket);<br/>        console.log("Socket connected");</span><span id="3c97" class="lm kc ht lh b fv lr lo l lp lq">// register a message event listener to the socket<br/>        this.messageHandler(socket);</span><span id="10ed" class="lm kc ht lh b fv lr lo l lp lq">// on new connection send the blockchain chain to the peer</span><span id="b4df" class="lm kc ht lh b fv lr lo l lp lq">socket.send(JSON.stringify(this.blockchain));<br/>}</span></pre><p id="5f5a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您运行两个不同的应用程序，您会看到另一个对等体的链打印在第一个对等体的控制台上，反之亦然。这意味着我们的套接字正在正确地相互发送消息。</p><p id="7ff9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了使我们的链与对等体的链同步，我们可以检查接收到的链是否有效和更长。我们已经在区块链类中实现了这个功能。让我们在p2pserver类中使用<code class="eh le lf lg lh b">replaceChain()</code>函数，当我们从一个对等点接收到一个链时。</p><p id="b949" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<code class="eh le lf lg lh b">messageHandler(socket)</code>功能中添加</p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="bb75" class="lm kc ht lh b fv ln lo l lp lq">this.blockchain.replaceChain(data);</span></pre><p id="1071" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了让我们的生活更容易，我们将在我们的p2pserver中添加两个助手函数<code class="eh le lf lg lh b">sendChain()</code>和<code class="eh le lf lg lh b">syncChain()</code>。</p><p id="63d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh le lf lg lh b">sendChain(socket)</code>将用于发送我们的链到一个套接字</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">The chain sender</figcaption></figure><p id="6dc4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh le lf lg lh b">syncChain(socket)</code>将在我们的索引文件中用来同步链</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ls lt l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">The chain synchronizer</figcaption></figure><p id="8dc8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，在我们的app/index.js文件中，每当我们向链中添加一个新块时，我们都可以使用<code class="eh le lf lg lh b">syncChain()</code>函数。</p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="8273" class="lm kc ht lh b fv ln lo l lp lq">app.post('mine',(req,res) =&gt; {<br/>    .<br/>    .<br/>    .<br/>    p2pserver.syncChain();<br/>}</span></pre><p id="ba3b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们为p2pserver编写的最终代码将类似于</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="cb10" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通过启动两个应用程序实例来测试这个功能。在第一个应用程序中添加新块。</p><p id="02d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在打开第二个终端，您将看到控制台中打印的输出。</p><pre class="jp jq jr js fq li lh lj lk aw ll dt"><span id="fe49" class="lm kc ht lh b fv ln lo l lp lq">Listening for peer to peer connection on port : 5002<br/>listening on port 3002<br/>Socket Connected<br/>Replacing the current chain with new chain</span></pre><p id="2d51" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您可以通过使用第二个应用程序的get端点来确认这一点。您可以对第二个实例进行同样的尝试，第一个实例的链将被更长的更改所取代。</p><p id="bef4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">太好了！我们的区块链开始同步了。</p><p id="5dd6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们已经创建了一个去中心化的网络，在这个网络中，对等体可以相互通信，并发送他们自己版本的区块链。基于链的长度，对等体可以选择忽略或替换接收到的链。</p><p id="613d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在下一篇文章中，我们将改进我们的工作证明算法，并增加随机数和难度的特性。</p><p id="5b6f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae ka" rel="noopener" href="/coinmonks/part-5-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-a7f8853d23dc">第五部分:用PoW共识算法实现区块链和加密货币</a></p></div><div class="ab cl lv lw hb lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hm hn ho hp hq"><p id="f8c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lu">感谢您的阅读。</em> <strong class="is hu"> <em class="lu">在下一部分中，我们将扩展我们的工作证明算法，并将随机数和难度的概念添加到我们的项目中。</em> </strong> <em class="lu">希望你喜欢编码。如果你发现这很有帮助，请鼓掌。</em>T11】</p><p id="4ed5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您对区块链、以太坊或整个世界有任何疑问，请发表评论。:)</p><blockquote class="mc"><p id="905e" class="md me ht bd mf mg mh mi mj mk ml jn ek translated"><a class="ae ka" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mn mo mp mq mr jt fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mm"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>