<html>
<head>
<title>Storage efficient TFRecord for images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图像的高效存储TFRecord</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/storage-efficient-tfrecord-for-images-6dc322b81db4?source=collection_archive---------2-----------------------#2018-06-21">https://medium.com/coinmonks/storage-efficient-tfrecord-for-images-6dc322b81db4?source=collection_archive---------2-----------------------#2018-06-21</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/77ae5b58d835fcbabbbdaa831d610b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7yCYMrpH9Mmyu1Ty"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">“Binders and boxes on shelves in a large archive” by <a class="ae jf" href="https://unsplash.com/@samuelzeller?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Samuel Zeller</a> on <a class="ae jf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl jg jh hb ji" role="separator"><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl"/></div><div class="hm hn ho hp hq"><p id="e398" class="pw-post-body-paragraph jn jo ht jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hm dt translated">机器和深度学习的核心支柱之一是训练模型时使用的数据，因为它们是算法能够归纳和创建相关模型的来源。使用Tensorflow时，有几种方法可以向这些模型提供数据，但推荐的方法是使用TFRecord格式，它基本上存储地图中结构化数据的字节数组。这些图中的每一个都可以很容易地解释为一个特征或示例，并且包含所有相关的信息，这些信息将在以后的训练和测试步骤中使用。</p><p id="5a31" class="pw-post-body-paragraph jn jo ht jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hm dt translated">大多数关于TFRecord的帖子直接创建了这些功能，却没有对存储进行必要的关注。当我尝试将TFRecord文件用于图像时，我遇到了有关大文件存储的问题，因为这些TFRecord文件开始增长到原始数据大小的10倍，这在处理大型数据集时会变得非常烦人。</p><p id="bb88" class="pw-post-body-paragraph jn jo ht jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hm dt translated">来自tensorflow repository 的这个封闭问题清楚地表明了这个问题，但也提供了一个非常有效的解决方案。我们将在创建TFRecord功能之前进行编码，而不是盲目地存储图像。</p><p id="6e23" class="pw-post-body-paragraph jn jo ht jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hm dt translated">(所有片段都是基于一个工作中的TFRecord构建脚本，可以在<a class="ae jf" href="https://github.com/tinenbruno/image-tfrecord-builder" rel="noopener ugc nofollow" target="_blank">这个资源库</a>中找到，并且是基于<a class="ae jf" href="https://kwotsin.github.io/tech/2017/01/29/tfrecords.html" rel="noopener ugc nofollow" target="_blank"> Kwot Sin </a>的工作。)</p></div><div class="ab cl jg jh hb ji" role="separator"><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl"/></div><div class="hm hn ho hp hq"><h2 id="9e51" class="kl km ht bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf dt translated">第一步。组织影像数据集</h2><p id="f22e" class="pw-post-body-paragraph jn jo ht jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk hm dt translated">首先，我们需要组织我们的数据集，使我们更容易处理它的类。实现这一点的一种方法是按以下方式构建它:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="0c7e" class="kl km ht lq b fv lu lv l lw lx">&gt; base_dir<br/>  &gt; classname 1<br/>    &gt; image 1<br/>    &gt; image 2<br/>    &gt; ...<br/>  &gt; classname 2<br/>    &gt; image 1<br/>    &gt; image 2<br/>    &gt; ...</span></pre><p id="b8d2" class="pw-post-body-paragraph jn jo ht jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hm dt translated">使用这种结构将允许我们简单地遍历文件夹来收集关于类名和图像路径的所有信息。</p><h2 id="2478" class="kl km ht bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf dt translated">第二步。分割数据集</h2><p id="2b2a" class="pw-post-body-paragraph jn jo ht jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk hm dt translated">我们将在数据集中创建两种类型的分割。第一个是评估您的机器学习模型的核心，是关于将数据集划分为训练和测试子集。顾名思义，训练数据集将用于模型的训练步骤，测试数据集将用于验证该模型。<br/>我们将创建的第二个分割是用于训练和测试数据集的碎片。正如这里所说的<a class="ae jf" href="https://github.com/tensorflow/tensor2tensor/issues/190#issuecomment-319565596" rel="noopener ugc nofollow" target="_blank"/>，分片可以加快你的阅读速度，而且通常最好不要有千兆字节大小的文件。如果数据集开始变得非常大，这将非常重要。</p><h2 id="fb72" class="kl km ht bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf dt translated">第三步。创建TFRecord文件</h2><p id="7c96" class="pw-post-body-paragraph jn jo ht jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk hm dt translated">我们将对使用OpenCV加载的每个图像进行编码，然后作为一个特性存储在TFRecord文件中。例如，我们可以使用<code class="eh ly lz ma lq b">cv2.imencode</code>将图像编码为JPEG。</p><p id="96c9" class="pw-post-body-paragraph jn jo ht jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hm dt translated"><em class="mb">编辑:注意，我们这里使用的是OpenCV，而不是raw文件打开。使用OpenCV可以在构建特征图之前对图像进行预处理。如果你想要的只是将图像存储在TFRecord文件中，那么你可以考虑使用</em> <code class="eh ly lz ma lq b"><em class="mb">with open(filename, 'rb'):</em></code> <em class="mb">。感谢</em><a class="mc md gr" href="https://medium.com/u/876d247489fb?source=post_page-----6dc322b81db4--------------------------------" rel="noopener" target="_blank"><em class="mb">Andrey Kite Gorin</em></a><em class="mb">的输入。</em></p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="0d57" class="kl km ht lq b fv lu lv l lw lx">encoded_image_string = cv2.imencode(‘.jpg’, image)[1].tostring()</span></pre><p id="5355" class="pw-post-body-paragraph jn jo ht jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hm dt translated">然后，我们可以简单地使用这个编码图像串来生成表示我们的特征的地图。因为我们的目标是获得一个精简的记录，所以我们将只存储后面步骤所需的最少信息。</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="10c5" class="kl km ht lq b fv lu lv l lw lx">label = tf.compat.as_bytes(example['classname'])<br/>image = tf.compat.as_bytes(encoded_image_string)</span><span id="112c" class="kl km ht lq b fv me lv l lw lx">feature = {<br/>  'train/label':_bytes_feature(label),<br/>  'train/image':_bytes_feature(image)<br/>}<br/><br/>tf_example = tf.train.Example(<br/>  features = tf.train.Features(feature=feature)<br/>)</span><span id="f126" class="kl km ht lq b fv me lv l lw lx">writer.write(tf_example.SerializeToString())</span></pre></div><div class="ab cl jg jh hb ji" role="separator"><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl"/></div><div class="hm hn ho hp hq"><h2 id="0ec4" class="kl km ht bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf dt translated">从TFRecords中读取</h2><p id="f1a4" class="pw-post-body-paragraph jn jo ht jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk hm dt translated">我可以在这里结束这篇文章，但是还有一件重要的事情要说:如何从TFRecord文件中读取。如前所述，TFRecord以结构化的方式存储特性，这是在构建TFRecord文件时定义的。然后，当从TFRecord文件中读取时，准确地知道正在读取的特征的结构是很重要的。如果您遵循本文的示例，那么当读取TFRecord文件时，我们将期望它被解析如下:</p><p id="1cd2" class="pw-post-body-paragraph jn jo ht jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hm dt translated"><em class="mb">编辑:正如Andrey Kite Gorin</em><a class="mc md gr" href="https://medium.com/u/876d247489fb?source=post_page-----6dc322b81db4--------------------------------" rel="noopener" target="_blank"><em class="mb">所评论的，在本参考中，在这种情况下使用FixedLenFeature而不是VarLenFeature，因为我们总是有一个包含</em> <strong class="jp hu"> <em class="mb">的特征，一个图像</em> </strong> <em class="mb">，或者换句话说，一个数组。这种情况与字节数组的大小无关。</em></a></p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="074a" class="kl km ht lq b fv lu lv l lw lx">features = tf.parse_single_example(<br/>  serialized_example,<br/>  features={<br/>    'train/label': tf.FixedLenFeature(tf.string),<br/>    'train/image': tf.FixedLenFeature(tf.string)<br/>  }<br/>)</span></pre><p id="90fb" class="pw-post-body-paragraph jn jo ht jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hm dt translated">我们还需要解码JPEG编码的图像，这可以使用:</p><p id="8bb3" class="pw-post-body-paragraph jn jo ht jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hm dt translated">编辑:正如安德烈·凯特·戈林评论的那样，在这种情况下使用<code class="eh ly lz ma lq b">tf.image.decode_jpeg()</code>可能是个更好的主意。</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="628e" class="kl km ht lq b fv lu lv l lw lx">cv2.imdecode(np.fromstring(img_data, dtype=np.uint8), -1</span></pre></div><div class="ab cl jg jh hb ji" role="separator"><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl"/></div><div class="hm hn ho hp hq"><h2 id="74a5" class="kl km ht bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf dt translated">结论</h2><p id="2340" class="pw-post-body-paragraph jn jo ht jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk hm dt translated">最后，我们将得到一个TFRecord格式的数据集，其大小接近原始数据。请记住，与训练时间相比，解码时间通常是微不足道的，这可能是一个节省存储费用的好办法。</p><p id="e51e" class="pw-post-body-paragraph jn jo ht jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk hm dt translated">感谢安德烈·凯特·戈林的贡献！</p><blockquote class="mf"><p id="84eb" class="mg mh ht bd mi mj mk ml mm mn mo kk ek translated">加入Coinmonks <a class="ae jf" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jf" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae jf" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="kl km ht bd kn ko mp kq kr ks mq ku kv jy mr kx ky kc ms la lb kg mt ld le lf dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="mu mv ht jp b jq lg ju lh jy mw kc mx kg my kk mz na nb nc dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae jf" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="mu mv ht jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc dt translated"><a class="ae jf" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae jf" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="mu mv ht jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc dt translated"><a class="ae jf" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae jf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="mu mv ht jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae jf" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="mu mv ht jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc dt translated">开发人员的最佳加密API</li><li id="b359" class="mu mv ht jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc dt translated">最佳<a class="ae jf" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="mu mv ht jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae jf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="mu mv ht jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li></ul></div></div>    
</body>
</html>