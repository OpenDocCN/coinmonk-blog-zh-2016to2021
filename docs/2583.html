<html>
<head>
<title>The More-Minimal Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更简单的代理</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48?source=collection_archive---------0-----------------------#2019-12-13">https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48?source=collection_archive---------0-----------------------#2019-12-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/19299aac6215768af17c627d3fdc1457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85hIV4ikszCuWXH1KbDPmw.jpeg"/></div></div></figure><p id="df35" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果你曾经研究过如何廉价地大规模部署合同，你可能会遇到<a class="ae jz" href="https://eips.ethereum.org/EIPS/eip-1167" rel="noopener ugc nofollow" target="_blank"> EIP-1167 </a>。这些最小代理契约对一个固定地址执行一个<code class="eh ka kb kc kd b">DELEGATECALL</code>，并且它们只用<strong class="jd hu">45个字节</strong> <em class="ke">(或者更少，如果你代理到一个从零字节开始的紧凑地址】</em>，这使得<strong class="jd hu">部署起来更加</strong>有效，代价是使用它会增加一些开销。</p><p id="2c09" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">标准正在激增，而且理由很充分——对于一组具有重复逻辑的合同来说，让该逻辑只存在于一个地方<em class="ke">是一个好主意(只要没有人使用该逻辑并且</em> <a class="ae jz" href="https://github.com/paritytech/parity-ethereum/issues/6995#issue-271523889" rel="noopener ugc nofollow" target="_blank"> <em class="ke">意外地杀死了它</em> </a> <em class="ke">，也就是)</em>。例如，它现在是OpenZeppelin SDK的一部分(他们刚刚发布了一个关于EIP-1167如何工作的<a class="ae jz" href="https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/" rel="noopener ugc nofollow" target="_blank">很棒的初级读本</a>)。见鬼，我自己不久前为擦除协议写了一个库，名为<a class="ae jz" href="https://github.com/0age/Spawner" rel="noopener ugc nofollow" target="_blank"> Spawner </a>，它给出了EIP-1167代理。重点是，这个EIP现在是一位数的ERC公司，实际上在野外被采用。</p><p id="0da2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这就是为什么我想在EIP-1167达到临界质量之前解决它一直困扰我的问题。也就是说，这个:<strong class="jd hu">它不像它可能的那样最小</strong>。</p><p id="4e46" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里是有问题的字节码，用EIP本身的说法拼写出来:</p><pre class="kf kg kh ki fq kj kd kk kl aw km dt"><span id="2e20" class="kn ko ht kd b fv kp kq l kr ks">0x363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3</span><span id="fa2e" class="kn ko ht kd b fv kt kq l kr ks">pc    op / pushdata  opcode              stack (top on the left)<br/>----  -------------  ------------------  -----------------------<br/>0x00  36             calldatasize        cds<br/>0x01  3d             returndatasize      0 cds<br/>0x02  3d             returndatasize      0 0 cds<br/>0x03  37             calldatacopy        <br/>0x04  3d             returndatasize      0<br/>0x05  3d             returndatasize      0 0 <br/>0x06  3d             returndatasize      0 0 0<br/>0x07  36             calldatasize        cds 0 0 0<br/>0x08  3d             returndatasize      0 cds 0 0 0<br/>0x09  73bebebebebe.  push20 0xbebebebe   0xbebe 0 cds 0 0 0<br/>0x1e  5a             gas                 gas 0xbebe 0 cds 0 0 0<br/>0x1f  f4             delegatecall        suc 0<br/>0x20  3d             returndatasize      rds suc 0<br/>0x21  82             dup3                0 rds suc 0<br/>0x22  80             dup1                0 0 rds suc 0<br/>0x23  3e             returndatacopy      suc 0<br/>0x24  90             swap1               0 suc<br/>0x25  3d             returndatasize      rds 0 suc<br/>0x26  91             swap2               suc 0 rds<br/>0x27  602b           push1 0x2b          0x2b suc 0 rds<br/>0x29  57             jumpi               0 rds<br/>0x2a  fd             revert<br/>0x2b  5b             jumpdest            0 rds<br/>0x2c  f3             return</span></pre><p id="ef2b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当你浏览这个的时候，有什么吸引你的呢？我将告诉你我最感兴趣的是什么——<code class="eh ka kb kc kd b">swap</code>操作码。我们可以做得更好:</p><pre class="kf kg kh ki fq kj kd kk kl aw km dt"><span id="1326" class="kn ko ht kd b fv kp kq l kr ks">0x3d3d3d3d363d3d37363d73bebebebebebebebebebebebebebebebebebebebe5af43d3d93803e602a57fd5bf3</span><span id="802a" class="kn ko ht kd b fv kt kq l kr ks">pc    op / pushdata  opcode              stack (top on the left)<br/>----  -------------  ------------------  ------------------------<br/>0x00  3d             returndatasize      0<br/>0x01  3d             returndatasize      0 0 <br/>0x02  3d             returndatasize      0 0 0<br/>0x03  3d             returndatasize      0 0 0 0<br/>0x04  36             calldatasize        cds 0 0 0 0<br/>0x05  3d             returndatasize      0 cds 0 0 0 0<br/>0x06  3d             returndatasize      0 0 cds 0 0 0 0<br/>0x07  37             calldatacopy        0 0 0 0<br/>0x08  36             calldatasize        cds 0 0 0 0<br/>0x09  3d             returndatasize      0 cds 0 0 0 0<br/>0x0a  73bebebebebe.  push20 0xbebebebe   0xbebe 0 cds 0 0 0 0<br/>0x1f  5a             gas                 gas 0xbebe 0 cds 0 0 0 0<br/>0x20  f4             delegatecall        suc 0 0<br/>0x21  3d             returndatasize      rds suc 0 0<br/>0x22  3d             returndatasize      rds rds suc 0 0<br/>0x23  93             swap4               0 rds suc 0 rds<br/>0x24  80             dup1                0 0 rds suc 0 rds<br/>0x25  3e             returndatacopy      suc 0 rds<br/>0x26  602a           push1 0x2a          0x2a suc 0 rds<br/>0x28  57             jumpi               0 rds<br/>0x29  fd             revert<br/>0x2a  5b             jumpdest            0 rds<br/>0x2b  f3             return</span></pre><p id="0d31" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">看到了吗？少了一辆<code class="eh ka kb kc kd b">swap</code>，多了一辆<code class="eh ka kb kc kd b">returndatasize</code>而不是一辆<code class="eh ka kb kc kd b">dup</code>。这转化为部署<em class="ke">(运行时代码少一个字节)</em>少200个gas，调用<em class="ke">少4个gas(我们去掉了成本三个gas的</em> <code class="eh ka kb kc kd b">swap</code> <em class="ke">，</em> <code class="eh ka kb kc kd b">returndatasize</code> <em class="ke">比</em> <code class="eh ka kb kc kd b">dup</code> <em class="ke"> ) </em>。</p><p id="c174" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是客观的改进，但是值得花费额外的努力来更新所有的工具，或者甚至修改EIP或者起草一个新的吗？我不知道。如果你有这样或那样的强烈意见，请告诉我。</p><blockquote class="ku"><p id="16ed" class="kv kw ht bd kx ky kz la lb lc ld jy ek translated"><a class="ae jz" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="lf lg lh li lj iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff le"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="kf kg kh ki fq iu fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff lk"><img src="../Images/a06b758bdcc47dca7c2504f298674d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_s6JsD3P0hVj32E7t9EtGg.jpeg"/></div></a></figure></div></div>    
</body>
</html>