<html>
<head>
<title>Uniswap Fork: Web3 with React Hooks And Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Uniswap Fork:带有React挂钩和Redux的Web3</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/uniswap-fork-web3-with-react-hooks-and-redux-ed407abffbc8?source=collection_archive---------4-----------------------#2021-09-08">https://medium.com/coinmonks/uniswap-fork-web3-with-react-hooks-and-redux-ed407abffbc8?source=collection_archive---------4-----------------------#2021-09-08</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="f029" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">本文将演示如何使用react钩子来评估/提交事务并从区块链中获取事件。我发现了许多可以遵循的实践，但是我发现的最好的一个是在Defi项目中。Defi项目需要创建复杂的组件来管理矿池、获取用户数据以及高效地提交事务。有时，您的React组件可能需要等待区块链事务来确认。在一些费用较低的情况下可能需要一天以上的时间。这就是为什么我克隆了Uniswap <a class="ae jo" href="https://github.com/Uniswap/uniswap-interface" rel="noopener ugc nofollow" target="_blank">存储库</a>，并学习了它们的组件如何与多个事务交互。监听事务状态并更新组件。</p><h1 id="fcd1" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">议程</h1><ul class=""><li id="f819" class="kn ko ht is b it kp ix kq jb kr jf ks jj kt jn ku kv kw kx dt translated">连接到钱包。</li><li id="2722" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">挂钩来评估/读取区块链中的值。</li><li id="88bd" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">钩子提交交易。</li><li id="cbe9" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">事件侦听器获取触发的区块链事件，并将它们分派到您的react状态。</li></ul><p id="16a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我将为每一部分提到来自<a class="ae jo" href="https://github.com/Uniswap/uniswap-interface" rel="noopener ugc nofollow" target="_blank"> Uniswap Interface </a>资源库的相关代码。</p><h1 id="9da0" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">将您的React应用程序连接到外部钱包</h1><p id="0eee" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">我将从MetaMask钱包开始，它将支持多个网络，如mainnet、Rinkeby、Ropsten、Goerli、Kovan、币安和localhost。</p><p id="7abe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，我将只为Mainnet网络添加Fortmatic、WalletConnect、WalletLinkm Portis钱包。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div class="fe ff lg"><img src="../Images/5a5d5adc3547a4c53a8632cbc1b8b2f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*lsrCaiWAEz_uyEROqlUdcg.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek"><code class="eh ls lt lu lv b">The final output should look like that</code></figcaption></figure><p id="454e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了注入钱包，我将使用<code class="eh ls lt lu lv b">@web3-react/injected-connector</code></p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="458c" class="ma jq ht lv b fv mb mc l md me">yarn add @web3-react/injected-connector</span></pre><p id="a0ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">添加支持的链Id:</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="fe59" class="ma jq ht lv b fv mb mc l md me">const SUPPORTED_CHAIN_IDS = [1, 4, 3, 42, 5, 56, 97, 1337]</span></pre><h2 id="8519" class="ma jq ht bd jr mf mg mh jv mi mj mk jz jb ml mm kd jf mn mo kh jj mp mq kl mr dt translated">连接到MetaMask Wallet</h2><p id="f255" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">导入<code class="eh ls lt lu lv b">InjectedConnector</code>并将支持的chainId作为参数传递</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="daf7" class="ma jq ht lv b fv mb mc l md me">import { InjectedConnector } from '@web3-react/injected-connector'</span><span id="bcd3" class="ma jq ht lv b fv ms mc l md me">const SUPPORTED_CHAIN_IDS = [1, 4, 3, 42, 5, 56, 97, 1337]</span><span id="6bad" class="ma jq ht lv b fv ms mc l md me">const injected = new InjectedConnector({ supportedChainIds: SUPPORTED_CHAIN_IDS})</span></pre><h2 id="4495" class="ma jq ht bd jr mf mg mh jv mi mj mk jz jb ml mm kd jf mn mo kh jj mp mq kl mr dt translated">连接到其他钱包</h2><p id="0ac7" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">其他钱包将只支持mainnet。(chainId为1的mainnet)</p><p id="ce48" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从<code class="eh ls lt lu lv b">web3-react</code>包中导入连接器</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="310a" class="ma jq ht lv b fv mb mc l md me">import { WalletConnectConnector } from '@web3-react/walletconnect-connector'</span><span id="5185" class="ma jq ht lv b fv ms mc l md me">import { WalletLinkConnector } from '@web3-react/walletlink-connector'</span><span id="e28d" class="ma jq ht lv b fv ms mc l md me">import { PortisConnector } from '@web3-react/portis-connector'</span><span id="9187" class="ma jq ht lv b fv ms mc l md me">import { FortmaticConnector } from './Fortmatic' <br/>/* You can check Fortmatic configuration here */</span></pre><p id="0967" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">初始化连接器</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="8ae7" class="ma jq ht lv b fv mb mc l md me">// mainnet only<br/>export const fortmatic = new FortmaticConnector({<br/>   apiKey: FORMATIC_KEY ?? '',<br/>   chainId: 1<br/>})</span><span id="6188" class="ma jq ht lv b fv ms mc l md me">// mainnet only<br/>export const portis = new PortisConnector({<br/>   dAppId: PORTIS_ID ?? '',<br/>   networks: [1]<br/>})</span><span id="044a" class="ma jq ht lv b fv ms mc l md me">// mainnet only<br/>export const walletlink = new WalletLinkConnector({<br/>   url: NETWORK_URLS[1],<br/>   appName: &lt;Replace me with app name&gt;,<br/>   appLogoUrl: &lt;Replace me with app logo url&gt;<br/>})</span></pre><p id="cfa8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">WalletConnect与其他钱包有些不同</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="eb4b" class="ma jq ht lv b fv mb mc l md me">export const walletconnect = new WalletConnectConnector({</span><span id="8b16" class="ma jq ht lv b fv ms mc l md me">   supportedChainIds: SUPPORTED_CHAIN_IDS,</span><span id="b18d" class="ma jq ht lv b fv ms mc l md me">   bridge: &lt;Replace me with WALLETCONNECT_BRIDGE_URL&gt;,</span><span id="a528" class="ma jq ht lv b fv ms mc l md me">   qrcode: true,</span><span id="b473" class="ma jq ht lv b fv ms mc l md me">   pollingInterval: 15000</span><span id="c95a" class="ma jq ht lv b fv ms mc l md me">})</span></pre><p id="b702" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">假设您想了解更多有关钱包连接的信息。我推荐这个文档<a class="ae jo" href="https://github.com/NoahZinsmeister/web3-react/tree/d0b038c748a42ec85641a307e6c588546d86afc2/docs" rel="noopener ugc nofollow" target="_blank">系列</a> s。你可以在<a class="ae jo" href="https://github.com/Uniswap/uniswap-interface/tree/main/src/connectors" rel="noopener ugc nofollow" target="_blank"> uniswap-interface连接器目录</a>中找到连接器的完整模块。</p><h1 id="9889" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">导入工件</h1><p id="f41a" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">为了调用我的智能合同，我需要导入ABI和地址。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/51803fe122f7551928ca95249432d197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*tcBzji7ubjHmzA1N7It8vQ.png"/></div></figure><p id="1023" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Uniswap添加内部的所有地址。<code class="eh ls lt lu lv b">index.ts</code></p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/20958538cb8804ad35d1fc89d8f5183c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*G1pw3rvALAFIn3brw0ijlA.png"/></div></figure><p id="f4f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我使用<a class="ae jo" href="https://hardhat.org/" rel="noopener ugc nofollow" target="_blank"> hardhat </a>和<a class="ae jo" href="https://www.alchemy.com/" rel="noopener ugc nofollow" target="_blank"> alchemy </a>进行智能合约部署。所以我不使用<code class="eh ls lt lu lv b">ABIs</code>而是使用工件(abi +契约地址)。为了导入你的合同，我使用了<code class="eh ls lt lu lv b">useContract</code>钩子。可以查看它的<a class="ae jo" href="https://github.com/Uniswap/uniswap-interface/blob/main/src/hooks/useContract.ts#L42" rel="noopener ugc nofollow" target="_blank">实现</a>。在连接到外部钱包并导入智能合约构件之后，我们就可以创建用于提交/评估交易的区块链服务了。</p><h1 id="d024" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">区块链服务</h1><p id="e956" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">在<code class="eh ls lt lu lv b">src/services</code>，我将创建一个<code class="eh ls lt lu lv b">Blockchain/</code>目录。这一部分不同于Uniswap存储库，因为我更喜欢创建一个额外的层来提交和读取事务。更灵活的做法是，在不修改大量代码的情况下，尽可能多地修改您的提供程序。</p><h2 id="f00e" class="ma jq ht bd jr mf mg mh jv mi mj mk jz jb ml mm kd jf mn mo kh jj mp mq kl mr dt translated">评估交易</h2><p id="3f8b" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">评估交易是一项简单的任务，因为您不需要使用提供者进行签名或连接到钱包。因为我使用的是Typescript，所以添加数据类型是非常必要的。</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="6d87" class="ma jq ht lv b fv mb mc l md me">import { Contract } from '<a class="ae jo" href="http://twitter.com/ethersproject/contracts" rel="noopener ugc nofollow" target="_blank">@ethersproject/contracts</a>'<br/>import { BigNumber } from 'ethers'</span></pre><p id="df4d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后评估事务服务是可重用的。它将协定对象、方法名和一组参数作为参数。</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="0459" class="ma jq ht lv b fv mb mc l md me">export async function evaluateTransaction(<br/>    contract: Contract | null,<br/>    methodName: string,<br/>    args: Array&lt;string | number | BigNumber&gt;<br/> ): Promise&lt;any&gt; {<br/>  try {<br/>    const methods = await contract?.callStatic<br/>    const bcValues = await methods?.[methodName](...args)<br/>    return bcValues<br/>  } catch (e) {<br/>     console.log(e)<br/>     return e<br/>  }<br/> }</span></pre><p id="3e4e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我准备创建第一个钩子来获取一个地址的ERC20余额。</p><p id="aaa6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">导入我想与之交互的<code class="eh ls lt lu lv b">evaluateTransaction</code>服务和合同</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="295f" class="ma jq ht lv b fv mb mc l md me">import { evaluateTransaction } from 'services/Blockchain/evaluateTransaction'<br/>import { useERC20Token } from './useContract'</span></pre><p id="1a9f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了使钩子尽可能地可用，并在任何事件动作中使用它们，我将使用<code class="eh ls lt lu lv b">useCallback</code>钩子(通过触发事件提交事务，在条件或另一个钩子中)</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="1e97" class="ma jq ht lv b fv mb mc l md me">export const useTokenBalance = (): ((address: string) =&gt; any) =&gt; {     const contract = useERC20Token(false) <br/> /*The parameter is a  boolean value to use signer or not. In our case, we don't need signer as we read from blockchain not submitting*/</span><span id="23a6" class="ma jq ht lv b fv ms mc l md me">     return useCallback((address: string) =&gt; {</span><span id="d46d" class="ma jq ht lv b fv ms mc l md me">           /*Will call use evaluate transaction here*/    </span><span id="c5fc" class="ma jq ht lv b fv ms mc l md me">    }},[])<br/>}</span></pre><p id="5358" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在使用<code class="eh ls lt lu lv b">evaluateTransaction</code>服务，只添加一个新行并传递给它1。合同对象:<code class="eh ls lt lu lv b">const contract = useERC20Token(false)</code></p><p id="a0a7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2.合同方法名称:<code class="eh ls lt lu lv b">balanceOf</code></p><p id="ff90" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3.参数数组:<code class="eh ls lt lu lv b">[address]</code></p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="1a91" class="ma jq ht lv b fv mb mc l md me">export const useTokenBalance = (): ((address: string) =&gt; any) =&gt; {     const contract = useERC20Token(false) <br/>return useCallback(async(address: string) =&gt; {<br/>   /* THE NEW LINE */<br/>   return await evaluateTransaction(contract, 'balanceOf', [address])<br/>}},[])<br/>}</span></pre><p id="e336" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我可以使用<code class="eh ls lt lu lv b">useTokenBalance</code>挂钩了</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="e845" class="ma jq ht lv b fv mb mc l md me">/* Inside a component or another hook */<br/>const getBlance = <!-- -->useTokenBalance() // get the callback value<br/>/* Call getBalance */<!-- --> <br/> getBalance(&lt;address&gt;) </span></pre><p id="801c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">就这样，现在您可以对需要从区块链调用的方法/变量做同样的事情来获取数据。您可以在Unsiwap <a class="ae jo" href="https://github.com/Uniswap/uniswap-interface/blob/2ee9b16c49ff22699ece4273b15039e96a23f626/src/hooks/useTotalSupply.ts#L11" rel="noopener ugc nofollow" target="_blank">存储库</a>上查看totalSupply示例。</p><h2 id="cd80" class="ma jq ht bd jr mf mg mh jv mi mj mk jz jb ml mm kd jf mn mo kh jj mp mq kl mr dt translated">提交交易</h2><p id="6265" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">提交交易稍微复杂一点。因为我们需要签署交易，连接到钱包，如果在区块链上触发了事件，我们需要捕捉它🎯</p><p id="9ebf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，在<code class="eh ls lt lu lv b">src/services/Blockchain/submitTransaction.ts</code>创建提交事务服务。导入，数据类型作为评估事务服务。</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="50fe" class="ma jq ht lv b fv mb mc l md me">import { BigNumber } from '@ethersproject/bignumber'<br/>import { Contract } from '@ethersproject/contracts'</span></pre><p id="8420" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">其次，创建<code class="eh ls lt lu lv b">submitTransaction</code>函数。与<code class="eh ls lt lu lv b">evaluateTransaction</code>类似，我解析方法名、参数数组和作为参数的契约对象。此外，我将作为提供者传递用户地址和<code class="eh ls lt lu lv b">libray</code>对象。</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="00ae" class="ma jq ht lv b fv mb mc l md me">export const submitTransaction = async (<br/>      methodsName: string,<br/>      args: Array&lt;string | number | BigNumber&gt; | undefined,<br/>      contract: Contract | null,<br/>      account: string | null, <br/>      library: any // the signature provider) =&gt; {<br/>      try {<br/>      /*Submit transaction here*/<br/>      } catch (e) {<br/>        console.log(e)<br/>        return e<br/>      }<br/>}</span></pre><p id="68ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要提交事务，我们需要首先创建它。一项交易包括三个强制性的特征</p><ol class=""><li id="57da" class="kn ko ht is b it iu ix iy jb mv jf mw jj mx jn my kv kw kx dt translated"><code class="eh ls lt lu lv b">from</code>提交者的地址</li><li id="dd71" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn my kv kw kx dt translated"><code class="eh ls lt lu lv b">to</code>智能合同地址</li><li id="688a" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn my kv kw kx dt translated"><code class="eh ls lt lu lv b">data</code>被调用方法和参数的编码数据。</li></ol><p id="113f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我使用契约对象中的<code class="eh ls lt lu lv b">encodeFunctionData</code>创建数据</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="a475" class="ma jq ht lv b fv mb mc l md me">const callData = contract?.interface.encodeFunctionData(methodsName, args)</span></pre><p id="3909" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">发送交易</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="233c" class="ma jq ht lv b fv mb mc l md me">const callData = contract?.interface.encodeFunctionData(methodsName, args)</span><span id="c071" class="ma jq ht lv b fv ms mc l md me">return library?.getSigner().sendTransaction({<br/>   from: account ? account : undefined,<br/>   to: contract?.address,<br/>   data: callData<br/>})</span></pre><p id="6a84" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在<code class="eh ls lt lu lv b">submitTransaction</code>应该是这个样子</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="c1ff" class="ma jq ht lv b fv mb mc l md me">export const submitTransaction = async (<br/>      methodsName: string,<br/>      args: Array&lt;string | number | BigNumber&gt; | undefined,<br/>      contract: Contract | null,<br/>      account: string | null, <br/>      library: any // the signature provider) =&gt; {<br/>      try {<br/>      const callData =   contract?.interface.encodeFunctionData(methodsName, args)</span><span id="35d8" class="ma jq ht lv b fv ms mc l md me">       return library?.getSigner().sendTransaction({<br/>          from: account ? account : undefined,<br/>          to: contract?.address,<br/>          data: callData<br/>       })<br/>      } catch (e) {<br/>        console.log(e)<br/>        return e<br/>      }<br/>}</span></pre><p id="8304" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Uniswap提交交易的方式<a class="ae jo" href="https://github.com/Uniswap/uniswap-interface/blob/5831328364708b251e12bdcb054ed2c6d20b1683/src/hooks/useSwapCallback.ts#L324" rel="noopener ugc nofollow" target="_blank">稍有不同</a>。</p><p id="e254" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">就这样，让我们创建一个用于转移ERC20令牌的挂钩。</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="97a7" class="ma jq ht lv b fv mb mc l md me">export const useTransfer = (): ((address: string, amount: string | number) =&gt; any) =&gt; {<br/>const contract = useStartFiToken(true)</span><span id="33c8" class="ma jq ht lv b fv ms mc l md me">/*Will import user address and provider here*/</span><span id="48cf" class="ma jq ht lv b fv ms mc l md me">return useCallback(<br/>  async (address: string, amount: string | number) =&gt; {<br/>      try {<br/>        /*Will call use submit transaction here*/<br/>      } catch (e) {<br/>         console.log('error', e)<br/>         return e<br/>       }<br/>},[])<br/>}</span></pre><p id="5fdc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从<code class="eh ls lt lu lv b">useActiveWeb3React</code>钩子中获取用户地址和签名者。这里已经实现<a class="ae jo" href="https://github.com/Uniswap/uniswap-interface/blob/main/src/hooks/web3.ts#L10" rel="noopener ugc nofollow" target="_blank">了</a></p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="2955" class="ma jq ht lv b fv mb mc l md me">const { account, library } = useActiveWeb3React()</span></pre><p id="96a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我可以安全地使用我的<code class="eh ls lt lu lv b">submitTransaction</code>绕过它了:</p><ol class=""><li id="c833" class="kn ko ht is b it iu ix iy jb mv jf mw jj mx jn my kv kw kx dt translated">方法名称</li><li id="5a4c" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn my kv kw kx dt translated">争论</li><li id="b252" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn my kv kw kx dt translated">合同对象</li><li id="7fd9" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn my kv kw kx dt translated">用户地址</li><li id="94bd" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn my kv kw kx dt translated">签名者对象</li></ol><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="d89c" class="ma jq ht lv b fv mb mc l md me">await submitTransaction('transfer', [address, amount], contract, account, library)</span></pre><p id="1a7d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后但同样重要的是，使用转移挂钩应该是这样的。</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="082b" class="ma jq ht lv b fv mb mc l md me">export const useTransfer = (): ((address: string, amount: string | number) =&gt; any) =&gt; {<br/>const contract = useStartFiToken(true)</span><span id="542f" class="ma jq ht lv b fv ms mc l md me">const { account, library } = useActiveWeb3React()<br/>return useCallback(<br/>  async (address: string, amount: string | number) =&gt; {<br/>      try {<br/>      await submitTransaction('transfer', [address, amount], contract, account, library)<br/>      } catch (e) {<br/>         console.log('error', e)<br/>         return e<br/>       }<br/>},[submitTransaction, account, contract, library])<br/>}</span></pre><p id="2cb3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在使用<code class="eh ls lt lu lv b">useTransfer</code>挂钩之前，您必须确保用户已连接到钱包。否则，您将发送<code class="eh ls lt lu lv b">account</code>(带有空值的用户地址)。如果您想在您的<code class="eh ls lt lu lv b">useTransfer</code>上处理此情况，您可以使用<code class="eh ls lt lu lv b">useWalletModalToggle</code>来切换此模式</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/449415d1bd0737f9254a9207903d69cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*5oGj_CF1h9iBpbyElkvyZA.png"/></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Wallet Modal Toggle on Uniswap</figcaption></figure><p id="631d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你可以查看<code class="eh ls lt lu lv b">useWalletModalToggle</code>T21的执行情况。它返回一个回调函数，这样我们就可以像这样使用它</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="adc7" class="ma jq ht lv b fv mb mc l md me">const toggleWalletModal = useWalletModalToggle()</span><span id="1adf" class="ma jq ht lv b fv ms mc l md me">if (!account) { <br/>     toggleWalletModal()<br/>     return `account: ${account} is not connected`<br/>}</span></pre><p id="d405" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">传送钩将看起来像这样</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="76c6" class="ma jq ht lv b fv mb mc l md me">export const useTransfer = (): ((address: string, amount: string | number) =&gt; any) =&gt; {</span><span id="189d" class="ma jq ht lv b fv ms mc l md me">const contract = useStartFiToken(true)</span><span id="e08b" class="ma jq ht lv b fv ms mc l md me">const transfer = useSubmitTransaction()</span><span id="3575" class="ma jq ht lv b fv ms mc l md me">const { account, library } = useActiveWeb3React()</span><span id="9f2a" class="ma jq ht lv b fv ms mc l md me">const toggleWalletModal = useWalletModalToggle()</span><span id="b198" class="ma jq ht lv b fv ms mc l md me">return useCallback(</span><span id="4339" class="ma jq ht lv b fv ms mc l md me"> async (address: string, amount: string | number) =&gt; {</span><span id="51e6" class="ma jq ht lv b fv ms mc l md me">   if (!account) {<br/>        toggleWalletModal()<br/>        return `account: ${account} is not connected`<br/>   }</span><span id="dc81" class="ma jq ht lv b fv ms mc l md me">   try {<br/>       return await transfer('transfer', [address, amount], contract, account, library)<br/>     } catch (e) {<br/>       console.log('error', e)<br/>       return e<br/>     }<br/>   },<br/>  [transfer, account, contract, library, toggleWalletModal]<br/> )<br/>}</span></pre><p id="66fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">⚠️注意⚠️钩子的返回值是挂起状态的事务处理方法。在某些情况下，您可能需要等到交易被确认。你可以通过使用。<code class="eh ls lt lu lv b">waitForTransaction</code></p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="5d88" class="ma jq ht lv b fv mb mc l md me">const transaction = await transfer('transfer', [address, amount], contract, account, library)</span><span id="3996" class="ma jq ht lv b fv ms mc l md me">return await library?.waitForTransaction(transaction.hash) // wait until transaction is confirmed</span></pre><p id="3077" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你需要小心使用<code class="eh ls lt lu lv b">wairForTransaction</code>,因为这会花费很多时间，这对你的用户来说可能是个糟糕的体验。如果您需要来自已提交事务的数据，我不建议返回值，因为这可能会花费很多时间，处理起来可能会很复杂，所以我更喜欢在智能合约上发出<a class="ae jo" href="https://docs.soliditylang.org/en/v0.8.6/contracts.html#events" rel="noopener ugc nofollow" target="_blank">事件</a>，并使用<code class="eh ls lt lu lv b">library.on()</code>监听器和合约事件过滤器监听事件</p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="9fe4" class="ma jq ht lv b fv mb mc l md me">import { useStartFiToken } from './useContract'</span><span id="5dde" class="ma jq ht lv b fv ms mc l md me">const tokenContract = useStartFiToken(false)<br/>const transferEvent = tokenContract?.filters.Transfer()</span></pre><p id="7778" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用<code class="eh ls lt lu lv b">useEffect</code>钩内的<code class="eh ls lt lu lv b">library.on</code></p><pre class="lh li lj lk fq lw lv lx ly aw lz dt"><span id="4596" class="ma jq ht lv b fv mb mc l md me">useEffect(() =&gt; {<br/>   if (transferEvent) {<br/>       library?.on(transferEvent, result =&gt; {<br/>          const eventLogs = <br/>tokenContract?.interface.parseLog({ data: result.data, topics: result.topics }).args})</span><span id="9ce6" class="ma jq ht lv b fv ms mc l md me">/*Dispatch eventLogs here*/</span><span id="a424" class="ma jq ht lv b fv ms mc l md me">}<br/>return () =&gt; {<br/>   library?.removeAllListeners(transferEvent as EventFilter)<br/>}}, [])</span></pre><p id="8c80" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我将在下一篇文章中进一步开发带有redux状态管理的事件监听器。我还会谈到交易签名。我希望我说清楚了。如果你有任何问题，请不要犹豫问我😃</p><blockquote class="na"><p id="003d" class="nb nc ht bd nd ne nf ng nh ni nj jn ek translated">加入<a class="ae jo" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank"> Coinmonks电报频道</a>，了解加密交易和投资</p></blockquote><h2 id="6048" class="ma jq ht bd jr mf nk mh jv mi nl mk jz jb nm mm kd jf nn mo kh jj no mq kl mr dt translated">也阅读</h2><div class="np nq fm fo nr ns"><a href="https://blog.coincodecap.com/crypto-exchange" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab ej"><div class="nu ab nv cl cj nw"><h2 class="bd hu fv z el nx eo ep ny er et hs dt translated">最佳加密交易所| 2021年十大加密货币交易所</h2><div class="nz l"><h3 class="bd b fv z el nx eo ep ny er et ek translated">加密货币交易所的加密交易需要了解市场，这可以帮助你获得利润…</h3></div><div class="oa l"><p class="bd b gc z el nx eo ep ny er et ek translated">blog.coincodecap.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og lm ns"/></div></div></a></div><div class="np nq fm fo nr ns"><a href="https://blog.coincodecap.com/crypto-lending" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab ej"><div class="nu ab nv cl cj nw"><h2 class="bd hu fv z el nx eo ep ny er et hs dt translated">2021年9大最佳加密贷款平台| CoinCodeCap</h2><div class="nz l"><h3 class="bd b fv z el nx eo ep ny er et ek translated">当谈到加密货币贷款时，大量因素等同于良好的收入状况。此外，借款的一部分…</h3></div><div class="oa l"><p class="bd b gc z el nx eo ep ny er et ek translated">blog.coincodecap.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og lm ns"/></div></div></a></div><div class="np nq fm fo nr ns"><a rel="noopener follow" target="_blank" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a"><div class="nt ab ej"><div class="nu ab nv cl cj nw"><h2 class="bd hu fv z el nx eo ep ny er et hs dt translated">2021年最佳加密交易机器人(免费和付费)</h2><div class="nz l"><h3 class="bd b fv z el nx eo ep ny er et ek translated">2021年币安、比特币基地、库币和其他密码交易所的最佳密码交易机器人。四进制，位间隙…</h3></div><div class="oa l"><p class="bd b gc z el nx eo ep ny er et ek translated">medium.com</p></div></div><div class="ob l"><div class="oi l od oe of ob og lm ns"/></div></div></a></div><div class="np nq fm fo nr ns"><a rel="noopener follow" target="_blank" href="/coinmonks/best-crypto-signals-telegram-5785cdbc4b2b"><div class="nt ab ej"><div class="nu ab nv cl cj nw"><h2 class="bd hu fv z el nx eo ep ny er et hs dt translated">最佳4个加密交易信号电报通道</h2><div class="nz l"><h3 class="bd b fv z el nx eo ep ny er et ek translated">这是乏味的找到正确的加密交易信号提供商。因此，在本文中，我们将讨论最好的…</h3></div><div class="oa l"><p class="bd b gc z el nx eo ep ny er et ek translated">medium.com</p></div></div><div class="ob l"><div class="oj l od oe of ob og lm ns"/></div></div></a></div><div class="np nq fm fo nr ns"><a href="https://blog.coincodecap.com/blockfi-review" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab ej"><div class="nu ab nv cl cj nw"><h2 class="bd hu fv z el nx eo ep ny er et hs dt translated">BlockFi评论2021:利弊和利率</h2><div class="nz l"><h3 class="bd b fv z el nx eo ep ny er et ek translated">今天，我们提出了一个全面的BlockFi评论，这是一个成立于2017年的加密贷款平台，拥有其…</h3></div><div class="oa l"><p class="bd b gc z el nx eo ep ny er et ek translated">blog.coincodecap.com</p></div></div><div class="ob l"><div class="ok l od oe of ob og lm ns"/></div></div></a></div><div class="np nq fm fo nr ns"><a rel="noopener follow" target="_blank" href="/coinmonks/buy-bitcoin-in-india-feb50ddfef94"><div class="nt ab ej"><div class="nu ab nv cl cj nw"><h2 class="bd hu fv z el nx eo ep ny er et hs dt translated">如何在印度购买比特币？2021年购买比特币的7款最佳应用[手机版]</h2><div class="nz l"><h3 class="bd b fv z el nx eo ep ny er et ek translated">如何使用移动应用程序购买比特币印度</h3></div><div class="oa l"><p class="bd b gc z el nx eo ep ny er et ek translated">medium.com</p></div></div><div class="ob l"><div class="ol l od oe of ob og lm ns"/></div></div></a></div><div class="np nq fm fo nr ns"><a rel="noopener follow" target="_blank" href="/coinmonks/best-crypto-tax-tool-for-my-money-72d4b430816b"><div class="nt ab ej"><div class="nu ab nv cl cj nw"><h2 class="bd hu fv z el nx eo ep ny er et hs dt translated">加密税务软件——五大最佳比特币税务计算器[2021]</h2><div class="nz l"><h3 class="bd b fv z el nx eo ep ny er et ek translated">不管你是刚接触加密还是已经在这个领域呆了一段时间，你都需要交税。</h3></div><div class="oa l"><p class="bd b gc z el nx eo ep ny er et ek translated">medium.com</p></div></div><div class="ob l"><div class="om l od oe of ob og lm ns"/></div></div></a></div><div class="np nq fm fo nr ns"><a href="https://blog.coincodecap.com/pionex-review-exchange-with-crypto-trading-bot" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab ej"><div class="nu ab nv cl cj nw"><h2 class="bd hu fv z el nx eo ep ny er et hs dt translated">Pionex评论-被动交易者的简单交易机器人</h2><div class="nz l"><h3 class="bd b fv z el nx eo ep ny er et ek translated">在本文中，我们将回顾Pionex，它提供了加密交易机器人自动化工具，集成了一个…</h3></div><div class="oa l"><p class="bd b gc z el nx eo ep ny er et ek translated">blog.coincodecap.com</p></div></div><div class="ob l"><div class="on l od oe of ob og lm ns"/></div></div></a></div><div class="np nq fm fo nr ns"><a href="https://blog.coincodecap.com/best-hardware-wallet-bitcoin" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab ej"><div class="nu ab nv cl cj nw"><h2 class="bd hu fv z el nx eo ep ny er et hs dt translated">存储比特币的最佳加密硬件钱包[2021]</h2><div class="nz l"><h3 class="bd b fv z el nx eo ep ny er et ek translated">保管您的数字资产很容易，但找到正确的存储方式却是一项繁琐的任务。在线钱包有一个风险…</h3></div><div class="oa l"><p class="bd b gc z el nx eo ep ny er et ek translated">blog.coincodecap.com</p></div></div><div class="ob l"><div class="oo l od oe of ob og lm ns"/></div></div></a></div></div></div>    
</body>
</html>