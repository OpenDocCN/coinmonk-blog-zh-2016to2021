<html>
<head>
<title>Solidity Smart Contract Tutorial With Building Real-World DAPP — Part 4: Transfer, Send and Call</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建真实世界DAPP的Solidity智能合约教程—第4部分:传输、发送和调用</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-smart-contract-tutorial-with-building-real-world-dapp-part-4-transfer-send-and-call-ea9d7386114c?source=collection_archive---------0-----------------------#2020-11-03">https://medium.com/coinmonks/solidity-smart-contract-tutorial-with-building-real-world-dapp-part-4-transfer-send-and-call-ea9d7386114c?source=collection_archive---------0-----------------------#2020-11-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/110f1d5fe13cc14132afc1f17a15f8c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Vd0_kZiCWN4wFdHZA3jPQ.jpeg"/></div></div></figure><p id="aace" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<a class="ae jz" href="https://bitnician.medium.com/solidity-smart-contract-tutorial-with-building-real-world-dapp-part-3-create-a-request-for-ead40e83384f" rel="noopener">的最后一篇文章</a>中，我们在合同中存储了自由职业者和雇主的地址，并使雇主能够在创建合同时存放一些乙醚。我们还增加了一个功能，让自由职业者一旦完成项目的一部分，创建一个付款请求。</p><p id="9606" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">BTW，如果你不了解项目目标，建议你快速看一下<a class="ae jz" href="https://bitnician.medium.com/solidity-smart-contract-tutorial-with-building-full-stack-dapp-part-1-introduction-65988e83b4a3" rel="noopener">第一部</a>。我已经解释了使用区块链和智能合约将解决什么问题，以及您将从这些文章中学到什么！🙂</p></div><div class="ab cl ka kb hb kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hm hn ho hp hq"><p id="e21a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在继续之前，让我说，在一些延迟之后，我已经开始继续这些文章。我一直忙于一些个人项目，比如我的网站。<br/>顺便说一句，我们开始使用solidity 6对合同进行编码。在我写新文章的这个时候，solidity 7已经发布了，所以，我们打算把solidity的版本改为0.7.4，这是最新的版本！</p><p id="6a4a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在将实度从6改为7后，我唯一修改的是构造函数的可见性。<br/>在solidity 7中，构造函数的可见性被忽略，除非你想创建一个<a class="ae jz" href="https://solidity.readthedocs.io/en/v0.7.4/contracts.html#abstract-contracts" rel="noopener ugc nofollow" target="_blank"> <strong class="jd hu">抽象</strong> </a> <strong class="jd hu"> </strong>契约。抽象契约只是一个不可部署的契约。我们正在编码的契约不是抽象的，所以把solidity的版本改成7以后就没必要用<code class="eh kh ki kj kk b">public</code>关键字了！</p></div><div class="ab cl ka kb hb kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hm hn ho hp hq"><p id="7c91" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这篇文章中，我们将创建一些解锁自由职业者请求以及支付自由职业者的功能。我们也将熟悉<strong class="jd hu">事件</strong>的可靠性。我们已经知道如何在合同中加入一些以太网，现在是时候了解一下安全中的<strong class="jd hu">撤回方法</strong>以及一些安全问题，比如<strong class="jd hu">重入攻击</strong>。<br/>好了，该开始编码了！🔥🤓</p></div><div class="ab cl ka kb hb kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hm hn ho hp hq"><p id="24fa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如我所说，自由职业者可以创建一个付款请求，对不对？该请求默认为<code class="eh kh ki kj kk b">lock</code>。<br/>因此，我们需要添加一个仅限于雇主的功能(使用我们的自定义<code class="eh kh ki kj kk b">modifiers</code>，并且可以将特定请求的状态从<code class="eh kh ki kj kk b"><em class="kl">lock</em></code>更改为<code class="eh kh ki kj kk b"><em class="kl">unlock</em></code>。就这么办吧！😊</p><p id="0f17" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，我将创建一个名为<code class="eh kh ki kj kk b">unlockRequest</code>的函数。它获取<code class="eh kh ki kj kk b">request</code>的索引并将<code class="eh kh ki kj kk b">locked</code>属性从<code class="eh kh ki kj kk b">true</code>更改为<code class="eh kh ki kj kk b">false</code>！</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="3c93" class="ku kv ht kk b fv kw kx l ky kz">function <em class="kl">unlockRequest</em>(uint256 _index) public {</span><span id="7e73" class="ku kv ht kk b fv la kx l ky kz">        Request storage request = requests[_index];<br/>        require(request.locked, "Already unlocked");<br/>        request.locked = false;</span><span id="777e" class="ku kv ht kk b fv la kx l ky kz">}</span></pre><p id="3378" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">看看上面的函数，看看我如何从<code class="eh kh ki kj kk b">requests</code>数组中获取一个条目，并将其存储在一个名为<code class="eh kh ki kj kk b">request</code>的变量中，变量的类型为<code class="eh kh ki kj kk b">Request</code>。注意，我使用了关键字<code class="eh kh ki kj kk b"><strong class="jd hu">storage</strong></code>来存储这个条目。<code class="eh kh ki kj kk b">storage</code>关键字本质上允许<code class="eh kh ki kj kk b">request</code>变量充当指向存储数组<code class="eh kh ki kj kk b">requests[]</code>的指针。<br/>在该功能中，我们首先检查给定的<code class="eh kh ki kj kk b">request</code>是否已经解锁。如果<code class="eh kh ki kj kk b">require</code>函数返回<code class="eh kh ki kj kk b">true</code>，意味着<code class="eh kh ki kj kk b">request</code>被锁定，我们可以将它的<code class="eh kh ki kj kk b">locked</code>值改为<code class="eh kh ki kj kk b">false</code>！</p><p id="306b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们在上一篇文章中学习了<code class="eh kh ki kj kk b">modifiers</code>。我们需要创建另一个<code class="eh kh ki kj kk b">modifier</code>，将<code class="eh kh ki kj kk b">unlockRequest</code> <em class="kl"> </em>功能<em class="kl"> </em>限制到<code class="eh kh ki kj kk b">employer</code>！</p><p id="b45b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们的修饰符应该是这样的:</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="ebfa" class="ku kv ht kk b fv kw kx l ky kz">modifier onlyEmployer() {</span><span id="e200" class="ku kv ht kk b fv la kx l ky kz">   require(msg.sender == employer, "Only Employer!");<br/>        _;</span><span id="b881" class="ku kv ht kk b fv la kx l ky kz">}</span></pre><p id="8476" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后，我们在<code class="eh kh ki kj kk b">unlockRequest</code>函数中使用它:</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="d8be" class="ku kv ht kk b fv kw kx l ky kz">function <em class="kl">unlockRequest</em>(uint256 _index) public onlyEmployer {</span><span id="7b20" class="ku kv ht kk b fv la kx l ky kz">        Request storage request = requests[_index];<br/>        require(request.locked, "Already unlocked");<br/>        request.locked = false;</span><span id="b3ee" class="ku kv ht kk b fv la kx l ky kz">}</span></pre><p id="7f3f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">好了，这个功能快完成了！✅ <br/>在这一点上，我认为这是一个学习如何在solidity中定义和发出事件的好机会。</p><h2 id="1a6c" class="ku kv ht bd lb lc ld le lf lg lh li lj jm lk ll lm jq ln lo lp ju lq lr ls lt dt translated">事件</h2><p id="2972" class="pw-post-body-paragraph jb jc ht jd b je lu jg jh ji lv jk jl jm lw jo jp jq lx js jt ju ly jw jx jy hm dt translated">为了在契约中定义一个事件，您可以通过在它前面加上关键字<code class="eh kh ki kj kk b">event</code>来标记它(在用法上类似于关键字<code class="eh kh ki kj kk b">function</code>)。然后，你将事件放在你想让其产生事件的函数体中。在最基本的形式中，一个事件就是打印一个日志。因此它有点像Javascript的<code class="eh kh ki kj kk b">console.log</code>。就这样，不多不少。实际上，除了将事件记录到区块链之外，它没有其他用途。然而，当我们开始编写UI时，我们可以将这些事件作为一种推送通知来监听。</p><p id="b75b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们创建一个事件，并在请求被解锁时发出它。首先，我将定义事件。(我把它写在我的契约顶部的某个地方，可能在构造函数上面)</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="fbed" class="ku kv ht kk b fv kw kx l ky kz">event RequestUnlocked(bool locked);</span></pre><p id="10a5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我的事件名是RequestUnlocked，它接受一个类型为<code class="eh kh ki kj kk b">boolean</code>的参数，并在发出时记录给定参数的值(是<code class="eh kh ki kj kk b">true</code>或<code class="eh kh ki kj kk b">false</code>)。</p><p id="f8c2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们在<code class="eh kh ki kj kk b">unlockRequest</code>函数中使用它:</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="f8c3" class="ku kv ht kk b fv kw kx l ky kz">function <em class="kl">unlockRequest</em>(uint256 _index) public onlyEmployer {</span><span id="7e7d" class="ku kv ht kk b fv la kx l ky kz">        Request storage request = requests[_index];<br/>        require(request.locked, "Already unlocked");<br/>        request.locked = false;</span><span id="2bc9" class="ku kv ht kk b fv la kx l ky kz">        emit RequestUnlocked(request.locked);</span><span id="09d8" class="ku kv ht kk b fv la kx l ky kz">}</span></pre><p id="a651" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">搞定了。✅</p><p id="4bda" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">重构我们之前的函数<br/> </strong>在上一篇文章中，我们有一个名为<code class="eh kh ki kj kk b">createRequest</code>的函数。我只是想为这个函数创建另一个事件。我的活动:</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="48bb" class="ku kv ht kk b fv kw kx l ky kz">event RequestCreated(string title, uint256 amount, bool locked, bool paid);</span></pre><p id="3ccf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该功能将是这样的:</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="5dd5" class="ku kv ht kk b fv kw kx l ky kz">function createRequest(string memory _title, uint256 _amount)<br/>        public<br/>        onlyFreelancer<br/>    {</span><span id="40da" class="ku kv ht kk b fv la kx l ky kz">        require(msg.sender == freelancer, "Only Freelancer!");</span><span id="919b" class="ku kv ht kk b fv la kx l ky kz">        Request memory request = Request({<br/>             title: _title,<br/>             amount: _amount,<br/>             locked: true,<br/>             paid: false<br/>        });</span><span id="df4c" class="ku kv ht kk b fv la kx l ky kz">        requests.push(request);<br/>        <br/>        emit RequestCreated(_title, _amount, request.locked,  <br/>        request.paid);<br/>    }</span></pre></div><div class="ab cl ka kb hb kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hm hn ho hp hq"><h2 id="0355" class="ku kv ht bd lb lc ld le lf lg lh li lj jm lk ll lm jq ln lo lp ju lq lr ls lt dt translated">实付地址</h2><p id="5493" class="pw-post-body-paragraph jb jc ht jd b je lu jg jh ji lv jk jl jm lw jo jp jq lx js jt ju ly jw jx jy hm dt translated">嗯，雇主可以解锁一个请求，这意味着自由职业者现在可以撤回所要求的付款。我们将创建一个函数，将这一取款功能添加到我们的合同中！💰但是，在此之前，我们需要学习更多关于稳健支付的知识！🤓</p><p id="2f22" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">应付款<br/> </strong>我们已经学习了solidity中的类型。我们知道<code class="eh kh ki kj kk b">address</code>类型用于存储160位以太坊地址。<br/>还有一种叫<code class="eh kh ki kj kk b">address payable</code>。<code class="eh kh ki kj kk b">address</code>和<code class="eh kh ki kj kk b">address payable</code>类型都存储160位以太坊地址。<br/>在Solidity版本0.5.0中引入了an <code class="eh kh ki kj kk b">address</code>和<code class="eh kh ki kj kk b">address payable</code>之间的区别。这个想法是为了区分可以收到钱的地址和不能收到钱的地址(用于其他目的)。简单来说，一个<code class="eh kh ki kj kk b">address payable</code>能接收以太，一个普通的<code class="eh kh ki kj kk b">address</code>不能。</p><p id="530e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">重构我们之前的代码<br/> </strong>好了，我们有了雇主和自由职业者的地址，在某些情况下，我们需要向这些地址转移一定量的醚。例如，当自由职业者决定从合同中提取一些乙醚时，我们需要将乙醚转移到他/她的地址。或者，如果项目没有在截止日期前完成，业主可以决定取消项目，并从合同中收回剩余的醚。因此，我们需要将这两个地址的类型从<code class="eh kh ki kj kk b">address</code>更改为<code class="eh kh ki kj kk b">address payable</code>:</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="fc8c" class="ku kv ht kk b fv kw kx l ky kz">address <strong class="kk hu">payable</strong> public employer;<br/>address <strong class="kk hu">payable</strong> public freelancer;</span></pre><p id="43a5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们还需要在构造函数中修改自由职业者地址的输入类型:</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="e788" class="ku kv ht kk b fv kw kx l ky kz">constructor(<strong class="kk hu">address</strong> <strong class="kk hu">payable</strong> _freelancer, uint256 _deadline) <br/>public payable {</span><span id="d894" class="ku kv ht kk b fv la kx l ky kz">        employer = msg.sender;<br/>        freelancer = _freelancer;<br/>        deadline = _deadline;<br/>        price = msg.value;</span><span id="fbde" class="ku kv ht kk b fv la kx l ky kz">}</span></pre><p id="5d3e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上面的函数中，我们将<code class="eh kh ki kj kk b">msg.sender</code>存储在了<code class="eh kh ki kj kk b">employer</code>变量中。<code class="eh kh ki kj kk b">msg.sender</code>总是返回一个<code class="eh kh ki kj kk b">address payable</code>类型！</p><p id="8ccc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在solidity中，我们也可以使用<code class="eh kh ki kj kk b">payable()</code>函数将<code class="eh kh ki kj kk b">address</code>转换为<code class="eh kh ki kj kk b">address payable</code>:</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="0167" class="ku kv ht kk b fv kw kx l ky kz">address payable myPayableAddress = payable(myPlainAddress);</span></pre><h2 id="01f1" class="ku kv ht bd lb lc ld le lf lg lh li lj jm lk ll lm jq ln lo lp ju lq lr ls lt dt translated">如何在固体中转移以太？</h2><p id="71d7" class="pw-post-body-paragraph jb jc ht jd b je lu jg jh ji lv jk jl jm lw jo jp jq lx js jt ju ly jw jx jy hm dt translated">有几种方法可以将乙醚转移到一个可支付的地址:</p><p id="1705" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kh ki kj kk b">someAddress.transfer()<br/>someAddress.send()<br/>someAddress.call{value: someValue}('')</code></p><p id="cf86" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">但是，也有一些关于固体转移醚的问题！</p><h2 id="a10b" class="ku kv ht bd lb lc ld le lf lg lh li lj jm lk ll lm jq ln lo lp ju lq lr ls lt dt translated">智能合约如何在转移以太的同时被黑？</h2><p id="17ac" class="pw-post-body-paragraph jb jc ht jd b je lu jg jh ji lv jk jl jm lw jo jp jq lx js jt ju ly jw jx jy hm dt translated">在编写智能合同时，您应该注意并防范一些已知的攻击。其中之一就是<strong class="jd hu">重入攻击。<br/> </strong>这个bug的第一个版本是关于在函数第一次调用完成之前，可能被重复调用的函数。<br/>这可能导致不同的函数调用以破坏性的方式相互作用。看下面例子的生命周期:</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="01e6" class="ku kv ht kk b fv kw kx l ky kz"><strong class="kk hu">contract Vulnerable</strong> <strong class="kk hu">{</strong></span><span id="ba78" class="ku kv ht kk b fv la kx l ky kz">function withdraw() public {</span><span id="f784" class="ku kv ht kk b fv la kx l ky kz"> <em class="kl">       // send ether to Attacker contract. Imagine, In our project,<br/>        // the freelancer send us a malicious contract address<br/>        // instead of an account address!</em><br/>    }</span><span id="e40b" class="ku kv ht kk b fv la kx l ky kz"><strong class="kk hu">}</strong></span><span id="2594" class="ku kv ht kk b fv la kx l ky kz"><strong class="kk hu">contract Attacker {</strong></span><span id="5200" class="ku kv ht kk b fv la kx l ky kz">fallback() external payable {</span><span id="3b02" class="ku kv ht kk b fv la kx l ky kz">      <em class="kl">//calling the withdraw function of the </em><strong class="kk hu"><em class="kl">Vulnerable contract</em></strong><br/>    }  </span><span id="1640" class="ku kv ht kk b fv la kx l ky kz"><strong class="kk hu">}</strong></span></pre><p id="edef" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">从上面可以看到，<code class="eh kh ki kj kk b">Vulnerable</code>合同的<code class="eh kh ki kj kk b">withdraw()</code>函数将以太网发送到该地址。地址是一份合同。<br/>每当一些醚存放到<code class="eh kh ki kj kk b">Attacker</code>契约中，就会执行<code class="eh kh ki kj kk b">fallback()</code>函数，如你所见，<code class="eh kh ki kj kk b">fallback()</code>函数可以一次又一次地调用<code class="eh kh ki kj kk b">Vulnerable</code>契约的<code class="eh kh ki kj kk b">withdraw()</code>函数……！</p><h2 id="8ebc" class="ku kv ht bd lb lc ld le lf lg lh li lj jm lk ll lm jq ln lo lp ju lq lr ls lt dt translated">重入攻击的第一种解决方案是什么？</h2><p id="b704" class="pw-post-body-paragraph jb jc ht jd b je lu jg jh ji lv jk jl jm lw jo jp jq lx js jt ju ly jw jx jy hm dt translated">在继续之前，让我们从气体开始！</p><p id="6006" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">什么是气？</strong> <br/>参与以太坊的每一项操作，无论是交易还是智能合约执行，都需要一定量的gas。<br/>例如，在上一篇文章中，雇主在部署合同时发送了3个乙醚，但他/她的钱包余额减少了3个乙醚多一点。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/13462edbcd7e637f0dee6f49bf4d480b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_FHYYGzGZznF-qYI4BdkUQ.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">An image from last article</figcaption></figure><p id="1eb4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是因为合同部署事务已经消耗了一些汽油。例如，假设部署交易可能花费1000汽油。我们将天然气价格定为0.000002 eth。所以我们的交易费会是1000 * 0.000002 = 0.002 eth。在接下来的文章中，我们将看到如何改变汽油价格</p><p id="68d1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae jz" href="https://github.com/bitnician/evm-opcodes" rel="noopener ugc nofollow" target="_blank"> <em class="kl">在这里你可以看到每一个动作所需要的气体量。</em>T24】</a></p><p id="3179" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">天然气如何能帮助我们！</strong> <br/>坚固性引入了<code class="eh kh ki kj kk b">transfer()</code>和<code class="eh kh ki kj kk b">send()</code>，引入这两个功能的全部原因是为了防止触点重入攻击。<br/><code class="eh kh ki kj kk b">transfer()</code>和<code class="eh kh ki kj kk b">send()</code>将转发2300气体津贴，该气体量对于这些功能是不可调节的。这个想法是2300 gas足以发出一个日志条目，但不足以进行一个可重入的调用来修改存储。</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="700c" class="ku kv ht kk b fv kw kx l ky kz"><strong class="kk hu">contract SenderContract</strong> <strong class="kk hu">{</strong></span><span id="4a07" class="ku kv ht kk b fv la kx l ky kz">    function withdraw() public {</span><span id="7a8c" class="ku kv ht kk b fv la kx l ky kz"><strong class="kk hu"><em class="kl">         //transfer() will  forwards 2300</em></strong></span><span id="5a3c" class="ku kv ht kk b fv la kx l ky kz">         someAddress.<strong class="kk hu">transfer</strong>(someAmount)</span><span id="2b22" class="ku kv ht kk b fv la kx l ky kz">     }<br/><strong class="kk hu">}</strong></span><span id="a96c" class="ku kv ht kk b fv la kx l ky kz"><strong class="kk hu">contract ReceiverContract {</strong></span><span id="5efe" class="ku kv ht kk b fv la kx l ky kz"><strong class="kk hu">    event</strong> Received(address, uint);</span><span id="acf2" class="ku kv ht kk b fv la kx l ky kz">    fallback() external payable {</span><span id="ce77" class="ku kv ht kk b fv la kx l ky kz"><strong class="kk hu">       // 2300 gas is only enough to emit a log, calling an external<br/>       // function consumes a large amount of gas</strong></span><span id="89e4" class="ku kv ht kk b fv la kx l ky kz"><strong class="kk hu">       emit</strong> Received(msg.sender, msg.value);<br/>    } <br/> <br/><strong class="kk hu">}</strong></span></pre><p id="8f73" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">send()和transfer()有什么区别？<br/> </strong>如果传输完成，<code class="eh kh ki kj kk b">send()</code>函数返回<code class="eh kh ki kj kk b">true</code>，否则返回<code class="eh kh ki kj kk b">false</code>。<br/>但是如果交易被拒绝，<code class="eh kh ki kj kk b">transfer()</code>函数会抛出一个错误。<br/> <code class="eh kh ki kj kk b">someAddress.transfer(someValue)</code>相当于<code class="eh kh ki kj kk b">require(someAddress.send(someValue))</code>，如果发送失败会自动回复。</p><h2 id="0137" class="ku kv ht bd lb lc ld le lf lg lh li lj jm lk ll lm jq ln lo lp ju lq lr ls lt dt translated">为什么我们不再使用传送和发送？</h2><p id="2e74" class="pw-post-body-paragraph jb jc ht jd b je lu jg jh ji lv jk jl jm lw jo jp jq lx js jt ju ly jw jx jy hm dt translated">当您想要使用<code class="eh kh ki kj kk b">transfer()</code>和<code class="eh kh ki kj kk b">send()</code>转移乙醚时，需要记住几件事:<br/>这些函数有助于我们转移乙醚，但在2020年12月之后，使用这些函数会有一些问题。🤔<br/>我简单解释一下为什么要避开<code class="eh kh ki kj kk b">send()</code>和<code class="eh kh ki kj kk b">transfer()</code>！我们在以前的文章中学习了<code class="eh kh ki kj kk b">fallback</code>和<code class="eh kh ki kj kk b">receive</code>函数。他们帮助我们接受合同。<br/><code class="eh kh ki kj kk b">fallback</code>和<code class="eh kh ki kj kk b">receive</code>功能以前消耗不到2300点汽油，现在会消耗更多。🙃<br/>举例来说，如果我们真的需要在我们的<code class="eh kh ki kj kk b">receive()</code>或<code class="eh kh ki kj kk b">callback()</code>函数内部写入存储，那么消耗的气体会比2300多！<br/>所以，如果收件人是合同的话，2300气可能不够！<br/><code class="eh kh ki kj kk b">transfer()</code>和<code class="eh kh ki kj kk b">send()</code>将转发2300气体津贴，该气体量对于这些功能是不可调节的。<br/>任何使用<code class="eh kh ki kj kk b">transfer()</code>或<code class="eh kh ki kj kk b">send()</code>的智能合同都是通过转发固定数量的天然气(2300英镑)来严格依赖天然气成本！<br/>应避免任何特定于天然气的代码，因为天然气成本会发生变化。</p><h2 id="4bc1" class="ku kv ht bd lb lc ld le lf lg lh li lj jm lk ll lm jq ln lo lp ju lq lr ls lt dt translated">现在应该使用call()来传输以太网</h2><p id="5cfa" class="pw-post-body-paragraph jb jc ht jd b je lu jg jh ji lv jk jl jm lw jo jp jq lx js jt ju ly jw jx jy hm dt translated"><code class="eh kh ki kj kk b">call</code>功能没有气体限制！因此，<code class="eh kh ki kj kk b">fallback()</code>或<code class="eh kh ki kj kk b">receive()</code>函数中的任何代码都将被执行，只要还有剩余的气体用于此目的:</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="fb22" class="ku kv ht kk b fv kw kx l ky kz">function withdraw() external {</span><span id="e499" class="ku kv ht kk b fv la kx l ky kz"><strong class="kk hu"><em class="kl">        // Using call instead of transfer or send</em></strong></span><span id="823d" class="ku kv ht kk b fv la kx l ky kz">        (bool success, bytes memory transactionBytes) =    <br/>        someAddress.call{value:someValue}('');<br/>        <br/>        require(success, "Transfer failed.");</span><span id="0271" class="ku kv ht kk b fv la kx l ky kz">}</span></pre><p id="2f88" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">可重入性呢？这可能是你看到上面代码的第一个想法。如果我们不再使用<code class="eh kh ki kj kk b">transfer()</code>和<code class="eh kh ki kj kk b">send()</code>，我们将不得不以更健壮的方式来防止重入。幸运的是，这个问题有很好的解决方案。</strong></p><p id="3536" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">使用重入防护<br/> </strong>我们用来防止重入的方法是显式地检查并拒绝这样的调用。这里有一个简单版本的可重入保护，这样你就可以明白这个想法了:</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="fc37" class="ku kv ht kk b fv kw kx l ky kz"><strong class="kk hu">bool locked = false;</strong></span><span id="f74e" class="ku kv ht kk b fv la kx l ky kz">function withdraw() external {</span><span id="d281" class="ku kv ht kk b fv la kx l ky kz"><strong class="kk hu">        require(!locked, "Reentrant call detected!");</strong><br/>        <br/>        <strong class="kk hu">locked = true;</strong><br/>        <br/>       (bool success, bytes memory transactionBytes) =    <br/>        someAddress.call{value:someValue}('');<br/>        <br/>        require(success, "Transfer failed.");<br/>        <br/>        <strong class="kk hu">locked = false;</strong><br/>    }</span></pre><p id="7570" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用上面的代码，如果一个重入调用被尝试，<code class="eh kh ki kj kk b">require</code>将拒绝它，因为<code class="eh kh ki kj kk b">lock</code>仍然被设置为<code class="eh kh ki kj kk b">true</code>😊<br/> <a class="ae jz" href="https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/" rel="noopener ugc nofollow" target="_blank">更多信息请点击这里！</a></p></div><div class="ab cl ka kb hb kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hm hn ho hp hq"><p id="a675" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">既然我们已经了解了很多关于在合同中转让乙醚的事情，那我们就来增加一个帮助自由职业者提取一些乙醚的功能吧！🤘</strong></p><p id="c9e4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，我声明一个名为<code class="eh kh ki kj kk b">locked</code>的新变量。既然我们要使用<code class="eh kh ki kj kk b">call()</code>，我们应该保护我们的契约免受可重入攻击。<br/>您可以将此代码添加到合同顶行的<code class="eh kh ki kj kk b">freelancer</code>和<code class="eh kh ki kj kk b">employer</code>变量下面。</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="1c25" class="ku kv ht kk b fv kw kx l ky kz">bool locked = false;</span></pre><p id="d99e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">其次，定义另一个<code class="eh kh ki kj kk b">event</code>并在我们的新函数中使用它也不错。我会把它写在我合同顶部的某个地方，可能在<code class="eh kh ki kj kk b">constructor</code>函数上面</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="3e85" class="ku kv ht kk b fv kw kx l ky kz">event RequestPaid(address receiver, uint256 amount);</span></pre><p id="b4a5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，我将编写函数并将其命名为payRequest:</p><pre class="km kn ko kp fq kq kk kr ks aw kt dt"><span id="19c3" class="ku kv ht kk b fv kw kx l ky kz">function payRequest(uint256 _index) public onlyFreelancer {<br/>        <br/>        require(!locked,'Reentrant detected!');<br/>        <br/>        Request storage request = requests[_index];<br/>        require(!request.locked, "Request is locked");<br/>        require(!request.paid, "Already paid");<br/>        <br/>        locked = true;<br/>        <br/>        (bool success, bytes memory transactionBytes) = <br/>        freelancer.call{value:request.amount}('');<br/>        <br/>        require(success, "Transfer failed.");<br/>        <br/>        request.paid = true;<br/>        <br/>        locked = false;<br/>        <br/>        emit RequestPaid(msg.sender, request.amount);<br/>    }</span></pre><p id="65fd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里我们首先检查一下契约是否没有被锁定。然后，直接从请求数组中获取项目。我们检查了该请求是否已经从雇主处解锁并且尚未支付。之后，我们把要求数量的乙醚转移给自由职业者。<br/>最后，我们更新要支付的请求，锁定合同并发出一个事件。</p><h1 id="bcdc" class="md kv ht bd lb me mf mg lf mh mi mj lj mk ml mm lm mn mo mp lp mq mr ms ls mt dt translated">结论</h1><p id="090b" class="pw-post-body-paragraph jb jc ht jd b je lu jg jh ji lv jk jl jm lw jo jp jq lx js jt ju ly jw jx jy hm dt translated">现在，您已经掌握了关于solidity智能合约中的支付和转账的非常好的信息，以及编写自己的合约时的一些安全问题。🔥</p><h1 id="c96d" class="md kv ht bd lb me mf mg lf mh mi mj lj mk ml mm lm mn mo mp lp mq mr ms ls mt dt translated">项目源代码</h1><p id="11d5" class="pw-post-body-paragraph jb jc ht jd b je lu jg jh ji lv jk jl jm lw jo jp jq lx js jt ju ly jw jx jy hm dt translated">你可以在我的GitHub repo中找到该项目的源代码:<br/><a class="ae jz" href="https://github.com/bitnician/Delance-truffle" rel="noopener ugc nofollow" target="_blank">【https://github.com/bitnician/Delance-truffle】T2</a></p><p id="f980" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">每一课都会有自己的分支。</p></div><div class="ab cl ka kb hb kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hm hn ho hp hq"><p id="ca77" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我叫贝扎德。我是一名区块链开发人员，拥有为企业区块链平台开发以太坊和Hyperledger fabric的经验。你可以通过我的用户名在twitter上找到我:<a class="ae jz" href="https://twitter.com/bitnician" rel="noopener ugc nofollow" target="_blank"><strong class="jd hu"><em class="kl">Bitnician</em></strong></a>。👈<br/>欢迎在这里或twitter上提出任何问题。</p><h2 id="be0b" class="ku kv ht bd lb lc ld le lf lg lh li lj jm lk ll lm jq ln lo lp ju lq lr ls lt dt translated">另外，阅读</h2><ul class=""><li id="02dc" class="mu mv ht jd b je lu ji lv jm mw jq mx ju my jy mz na nb nc dt translated">最好的<a class="ae jz" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="b851" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">密码本交易平台</a></li><li id="ae2d" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated">最好的<a class="ae jz" rel="noopener" href="/coinmonks/best-crypto-tax-tool-for-my-money-72d4b430816b">加密税务软件</a></li><li id="92e4" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/the-best-crypto-trading-platforms-in-2020-the-definitive-guide-updated-c72f8b874555">最佳加密交易平台</a></li><li id="d8fc" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated">最佳加密贷款平台</li><li id="4f10" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" href="https://bitquery.io/blog/best-blockchain-analysis-tools-and-software" rel="noopener ugc nofollow" target="_blank">最佳区块链分析工具</a></li><li id="d432" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/crypto-arbitrage-guide-how-to-make-money-as-a-beginner-62bfe5c868f6">加密套利</a>指南:新手如何赚钱</li><li id="aa54" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated">最佳<a class="ae jz" rel="noopener" href="/coinmonks/what-are-the-best-charting-platforms-for-cryptocurrency-trading-85aade584d80">加密制图工具</a></li><li id="15e1" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/ledger-vs-trezor-best-hardware-wallet-to-secure-cryptocurrency-22c7a3fd391e">莱杰vs特雷佐</a></li><li id="56fd" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated">了解比特币最好的<a class="ae jz" rel="noopener" href="/coinmonks/what-are-the-best-books-to-learn-bitcoin-409aeb9aff4b">书籍有哪些？</a></li><li id="170f" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/3commas-review-an-excellent-crypto-trading-bot-2020-1313a58bec92">3商业评论</a></li><li id="d145" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/aax-exchange-review-2021-67c5ea09330c"> AAX交易所评论</a> |推荐代码、交易费用、利弊</li><li id="54f9" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/deribit-review-options-fees-apis-and-testnet-2ca16c4bbdb2"> Deribit审查</a> |选项、费用、API和Testnet</li><li id="e34b" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/ftx-crypto-exchange-review-53664ac1198f"> FTX密码交易所评论</a></li><li id="d0c3" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/ngrave-zero-review-c465cf8307fc">n零审核</a></li><li id="1310" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/bybit-exchange-review-dbd570019b71">逐位交换审查</a></li><li id="8b1e" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/cryptohopper-vs-3commas-vs-shrimpy-a2c16095b8fe"> 3Commas vs Cryptohopper </a></li><li id="b18b" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated">最好的比特币<a class="ae jz" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069?source=friends_link&amp;sk=324dd9ff8556ab578d71e7ad7658ad7c">硬件钱包</a></li><li id="e7b1" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated">最佳<a class="ae jz" href="https://blog.coincodecap.com/best-monero-wallets" rel="noopener ugc nofollow" target="_blank"> monero钱包</a></li><li id="747f" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" href="https://blog.coincodecap.com/ledger-nano-s-vs-x" rel="noopener ugc nofollow" target="_blank">莱杰nano s vs x </a></li><li id="ace6" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" href="https://blog.coincodecap.com/bitsgap-3commas-quadency" rel="noopener ugc nofollow" target="_blank">bits gap vs 3 commas vs quad ency</a></li><li id="a274" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" href="https://blog.coincodecap.com/ledger-nano-s-vs-trezor-one-ledger-nano-x-trezor-t" rel="noopener ugc nofollow" target="_blank">莱杰纳米S vs特雷佐one vs特雷佐T vs莱杰纳米X </a></li><li id="44f0" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/blockfi-vs-celsius-vs-hodlnaut-8a1cc8c26630">block fi vs Celsius</a>vs Hodlnaut</li><li id="52d0" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/bitsgap-review-a-crypto-trading-bot-that-makes-easy-money-a5d88a336df2">bits gap review</a>——一个轻松赚钱的加密交易机器人</li><li id="92c0" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated">为专业人士设计的加密交易机器人</li><li id="22eb" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/primexbt-review-88e0815be858"> PrimeXBT审查</a> |杠杆交易、费用和交易</li><li id="62d2" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/ellipal-titan-review-85e9071dd029">埃利帕尔泰坦评论</a></li><li id="1a26" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" href="https://blog.coincodecap.com/secux-stone-hardware-wallet-review" rel="noopener ugc nofollow" target="_blank">赛克斯石评论</a></li><li id="31ff" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/blockfi-review-53096053c097"> BlockFi评论</a> |赚取高达8.6%的加密利息</li></ul></div></div>    
</body>
</html>