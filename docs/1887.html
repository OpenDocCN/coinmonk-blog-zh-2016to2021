<html>
<head>
<title>Advanced EOS Series — Part 3 — Secondary Indexes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级EOS系列—第3部分—二级索引</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/advanced-eos-series-part-3-secondary-indexes-1798f339cbb8?source=collection_archive---------0-----------------------#2018-12-17">https://medium.com/coinmonks/advanced-eos-series-part-3-secondary-indexes-1798f339cbb8?source=collection_archive---------0-----------------------#2018-12-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/3c23c8e914d726083e4d7b240da33bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDR8EaAMFVj9dY17rk3V1g@2x.jpeg"/></div></div></figure><div class=""/><p id="93af" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎回到高级EOS开发系列，在这里我将涉及到教程或课程很少涉及的高级技术和功能。本系列的目的是将您作为EOS网络上的分布式应用程序开发人员所需的技能整合在一起。每篇文章都是按照难度排序的，所以如果你想要一个总体的概述，我建议你从第一部分开始，一步步往上。这些例子的完整代码可以在GitHub 上找到<a class="ae jz" href="https://github.com/MitchPierias/Advanced-EOS-Examples" rel="noopener ugc nofollow" target="_blank">。</a></p><div class="hs ht fm fo hu ka"><a href="https://github.com/MitchPierias/Advanced-EOS-Examples/tree/master/03_Secondary-Indexes" rel="noopener  ugc nofollow" target="_blank"><div class="kb ab ej"><div class="kc ab kd cl cj ke"><h2 class="bd if fv z el kf eo ep kg er et id dt translated">MitchPierias/高级-EOS-示例</h2><div class="kh l"><h3 class="bd b fv z el kf eo ep kg er et ek translated">一系列EOS合同开发实例。通过创建…为MitchPierias/Advanced-EOS-Examples开发做出贡献</h3></div><div class="ki l"><p class="bd b gc z el kf eo ep kg er et ek translated">github.com</p></div></div><div class="kj l"><div class="kk l kl km kn kj ko ia ka"/></div></div></a></div></div><div class="ab cl kp kq hb kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hm hn ho hp hq"><blockquote class="kw kx ky"><p id="1f8d" class="jb jc kz jd b je jf jg jh ji jj jk jl la jn jo jp lb jr js jt lc jv jw jx jy hm dt translated">由于这些是高级或扩展的主题，我很危险地假设你已经知道了基础知识，并且正在寻求进一步的知识。出于这个原因，这些文章中共享的代码将只针对所讨论的目的进行精简。</p></blockquote><h1 id="0d87" class="ld le ie bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma dt translated">主要索引</h1><p id="ae2e" class="pw-post-body-paragraph jb jc ie jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx jy hm dt translated">到目前为止，您应该知道如何使用struct在EOS中定义多索引表，但是为了完整起见，让我们简要地浏览一下基本的表定义。</p><h2 id="b1bb" class="mg le ie bd lf mh mi mj lj mk ml mm ln jm mn mo lr jq mp mq lv ju mr ms lz mt dt translated">定义结构</h2><p id="366c" class="pw-post-body-paragraph jb jc ie jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx jy hm dt translated">我们将从定义我们的<code class="eh mu mv mw mx b">struct</code>开始，它需要<code class="eh mu mv mw mx b">primary_key </code>函数，这是我们调用<code class="eh mu mv mw mx b">find(KEY)</code>时使用的索引。现在让我们使用用户<code class="eh mu mv mw mx b">account_name</code>来获得唯一性，并在下一章介绍一个更通用的方法。</p><pre class="my mz na nb fq nc mx nd ne aw nf dt"><span id="1d4b" class="mg le ie mx b fv ng nh l ni nj">// @abi table items i64<br/>struct Item {<br/>  account_name      id;<br/>  string            name;<br/>  uint64_t          attack;<br/>  account_name      owner;<br/><br/>  auto primary_key() const { return id; };<br/>  EOSLIB_SERIALIZE(Item, (id)(name)(attack)(owner));<br/>};</span></pre><h2 id="a384" class="mg le ie bd lf mh mi mj lj mk ml mm ln jm mn mo lr jq mp mq lv ju mr ms lz mt dt translated">创建表</h2><p id="2017" class="pw-post-body-paragraph jb jc ie jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx jy hm dt translated">现在我们已经勾勒出了我们的结构。我们可以使用EOS库中的<code class="eh mu mv mw mx b">multi_index&lt;TABLE_NAME, TABLE_STRUCT&gt;</code>方法定义我们的多索引表；</p><pre class="my mz na nb fq nc mx nd ne aw nf dt"><span id="1baf" class="mg le ie mx b fv ng nh l ni nj">typedef multi_index&lt;N(items), Item&gt; items_table;</span></pre><p id="bf36" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我们的<code class="eh mu mv mw mx b">typedef</code>之后，我们可以简单地定义一个引用，然后在构造函数中初始化我们的表，或者我们可以根据需要在每个函数中初始化一个引用。</p><h1 id="f10a" class="ld le ie bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma dt translated">次要索引</h1><p id="d1d9" class="pw-post-body-paragraph jb jc ie jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx jy hm dt translated">让我们通过添加一个二级索引来扩展表的功能，以便根据条目各自的所有者来获取条目。我们的<code class="eh mu mv mw mx b">Item</code>结构现在看起来像这样；</p><pre class="my mz na nb fq nc mx nd ne aw nf dt"><span id="795b" class="mg le ie mx b fv ng nh l ni nj">// @abi table items i64<br/>struct Item {<br/>  auto              id;<br/>  string            name;<br/>  uint64_t          attack;<br/>  account_name      owner;<br/><br/>  auto primary_key() const { return id; };<br/>  uint64_t get_owner() const { return owner; };<br/>  EOSLIB_SERIALIZE(Item, (id)(name)(attack)(owner));<br/>};</span></pre><p id="6fb4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我在我们的<code class="eh mu mv mw mx b">primary_key</code>索引下面添加了一行<code class="eh mu mv mw mx b">unit64_t get_owner() const { return owner; };</code>。当被调用时，这个函数简单地返回<code class="eh mu mv mw mx b">owner</code>的值。</p><h2 id="e19f" class="mg le ie bd lf mh mi mj lj mk ml mm ln jm mn mo lr jq mp mq lv ju mr ms lz mt dt translated">定义二级索引</h2><p id="f024" class="pw-post-body-paragraph jb jc ie jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx jy hm dt translated">让我们将它定义为多索引表中的一个二级索引，这样我们可以在以后访问它；</p><pre class="my mz na nb fq nc mx nd ne aw nf dt"><span id="6f3d" class="mg le ie mx b fv ng nh l ni nj">typedef multi_index&lt;N(items), Item, indexed_by&lt;N(byowner), const_mem_fun&lt;Item, uint64_t, &amp;Item::get_owner&gt;&gt;&gt; item_table;</span></pre><p id="d0d6" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">不要让这一行吓到你，这只是我们之前的声明加上一个额外的参数。</p><pre class="my mz na nb fq nc mx nd ne aw nf dt"><span id="46c1" class="mg le ie mx b fv ng nh l ni nj">indexed_by&lt;N(byowner), const_mem_fun&lt;Item, uint64_t, &amp;Item::get_owner&gt;&gt;</span></pre><p id="25f2" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是定义我们的二级索引的线。我们使用<code class="eh mu mv mw mx b">indexed_by&lt;INDEX_NAME, LOOKUP_FUNCTION_DEFINITION&gt;</code>来指定名为<code class="eh mu mv mw mx b">byowner</code>的索引。</p><ul class=""><li id="2e04" class="nk nl ie jd b je jf ji jj jm nm jq nn ju no jy np nq nr ns dt translated">INDEX _ NAME可以是您喜欢的任何名称，并且不需要在语法上与我们的函数<code class="eh mu mv mw mx b">get_owner</code>匹配，只要记住它是我们将在稍后的操作中用来访问二级索引的名称。</li><li id="c06a" class="nk nl ie jd b je nt ji nu jm nv jq nw ju nx jy np nq nr ns dt translated">LOOKUP_FUNCTION_DEFINITION:在我们的示例中类似于<code class="eh mu mv mw mx b">cons_mem_fun&lt;STRUCT, RETURN_VALUE, LOOKUP_FUNCTION&gt;</code>,构造我们的二级索引函数，并将其分配给我们的索引定义函数。</li></ul><h2 id="47fd" class="mg le ie bd lf mh mi mj lj mk ml mm ln jm mn mo lr jq mp mq lv ju mr ms lz mt dt translated">使用二级索引</h2><p id="bb4f" class="pw-post-body-paragraph jb jc ie jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx jy hm dt translated">所以我们已经为我们的商品的<code class="eh mu mv mw mx b">owner</code>建立了索引，但是我们如何使用我们的索引来查找特定用户拥有的商品呢？为此，我们将进入一个操作，并使用多索引表方法<code class="eh mu mv mw mx b">get_index&lt;INDEX_NAME&gt;()</code>，让我们创建一个名为<code class="eh mu mv mw mx b">inventory</code>的操作来获取用户条目。</p><pre class="my mz na nb fq nc mx nd ne aw nf dt"><span id="8343" class="mg le ie mx b fv ng nh l ni nj">// @abi action<br/>void inventory(const account_name account) {<br/>  item_table items(_self, _self);<br/>  auto playerItems = items.get_index&lt;N(byowner)&gt;();<br/>  auto iter = playerItems.lower_bound(account);<br/>  while (iter != playerItems.end()) {<br/>    print("Item ", iter-&gt;name);<br/>    iter++;<br/>  }<br/>}</span></pre><p id="bdb9" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们打开下面的代码行，更深入地研究它负责什么；</p><pre class="my mz na nb fq nc mx nd ne aw nf dt"><span id="99f5" class="mg le ie mx b fv ng nh l ni nj">auto playerItems = items.get_index&lt;N(byowner)&gt;();</span></pre><p id="dd57" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这一行使用我们的<code class="eh mu mv mw mx b">item_table</code>实例的<code class="eh mu mv mw mx b">get_index</code>函数来获取我们之前定义的索引。注意，我们使用了之前指定的相同名称<code class="eh mu mv mw mx b">N(byowner)</code>来引用我们正在寻找的索引。</p><p id="35f7" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是二级索引，现在我们有了索引，我们可以执行所有我们通常用primary_index做的功能。在本例中，我们使用的是<code class="eh mu mv mw mx b">lower_bound</code>，但是您也可以使用<code class="eh mu mv mw mx b">find</code>、<code class="eh mu mv mw mx b">get</code>、<code class="eh mu mv mw mx b">upper_bound</code>、<code class="eh mu mv mw mx b">begin</code>或<code class="eh mu mv mw mx b">end</code>来适应您的特定用例。</p><blockquote class="ny"><p id="85fb" class="nz oa ie bd ob oc od oe of og oh jy ek translated"><a class="ae jz" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="oj ok ol om on hv fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff oi"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="my mz na nb fq hv fe ff paragraph-image"><a href="http://bit.ly/2G71Sp7"><div class="fe ff oo"><img src="../Images/449450761cd76f44f9ae574333f9e9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKX2mtg7p1lOs7JmosPLsA.png"/></div></a><figcaption class="op oq fg fe ff or os bd b be z ek"><a class="ae jz" href="http://bit.ly/2G71Sp7" rel="noopener ugc nofollow" target="_blank"><strong class="bd ot">Click to read today’s top story</strong></a></figcaption></figure></div></div>    
</body>
</html>