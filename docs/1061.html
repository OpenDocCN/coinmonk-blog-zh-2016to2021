<html>
<head>
<title>Parsing a Spreadsheet Into a JSON File Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python将电子表格解析成JSON文件</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/parsing-a-spreadsheet-into-a-json-file-using-python-6118f5c70bd3?source=collection_archive---------1-----------------------#2018-07-17">https://medium.com/coinmonks/parsing-a-spreadsheet-into-a-json-file-using-python-6118f5c70bd3?source=collection_archive---------1-----------------------#2018-07-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="88c1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">作者<a class="jo jp gr" href="https://medium.com/u/4bfaec1d4bb0?source=post_page-----6118f5c70bd3--------------------------------" rel="noopener" target="_blank">艾莎·阿尤布</a>，<a class="jo jp gr" href="https://medium.com/u/3c06fe5de28b?source=post_page-----6118f5c70bd3--------------------------------" rel="noopener" target="_blank">阿比尔·阿尔舒巴特</a></p><p id="a5a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以下文章解释了如何将. csv文件和. xls文件中的数据解析为。使用python的json文件，具有多级依赖性。</p><h1 id="b5ea" class="jq jr ht bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">传递CSV文件</h1><p id="c1b5" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">我们首先准备了一个包含大量冗余数据的CSV电子表格，我们将用嵌套的json格式表示这些数据。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/58fe8f13672ae37d4ea98412f415c653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*QbptXp79pNQ_W87kr5O5zg.png"/></div><figcaption class="lb lc fg fe ff ld le bd b be z ek">.csv file with multipe redundant data</figcaption></figure><p id="dca4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们希望通过创建多个嵌套级别来表示这些数据，因此我们的结构是:</p><p id="b81f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lf">帧将包含Id、名称、使用的协议和多个数据段。</em></p><p id="8613" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lf">一个段将包含一个段Id、名称、src/dest端口和多个数据包。</em></p><p id="c0e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lf">数据包将包含数据包id、src/dest MAC、src/dest IP和接收者。</em></p></div><div class="ab cl lg lh hb li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hm hn ho hp hq"><h2 id="9dfe" class="ln jr ht bd js lo lp lq jw lr ls lt ka jb lu lv ke jf lw lx ki jj ly lz km ma dt translated">现在我们已经准备好了数据，我们将开始编写Python脚本:</h2><p id="e535" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">我们将从导入与文件格式交互所需的库开始</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="24af" class="ln jr ht mc b fv mg mh l mi mj">import csv, json</span></pre><p id="ae29" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后我们将使用内置函数<strong class="is hu"> open() </strong>打开csv文件</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="993c" class="ln jr ht mc b fv mg mh l mi mj">f = open( 'filename.csv', 'rU' )</span></pre><p id="3486" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> DictReader() </strong>将加载。csv文件。我们将使用<strong class="is hu">字段名</strong>属性为电子表格的每一列添加一个适当的字段名。</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="cb7b" class="ln jr ht mc b fv mg mh l mi mj">reader = csv.DictReader( f, fieldnames = ("Protocol","Source Port","Destination Port","Source IP", "Destination IP", "Source MAC", "Destination MAC", "segment ID", "Frame name", "Frame ID", "segment name", "packet ID", "Receivers"))</span></pre><p id="37ed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后我们将创建两个列表，list <strong class="is hu"> store </strong>将收集我们将要解析的对象。至于list <strong class="is hu"> framenames </strong>，这将帮助我们跟踪我们的对象列表中存储了什么。</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="60bf" class="ln jr ht mc b fv mg mh l mi mj">store = []<br/>framenames = []</span></pre><p id="46fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将通过添加第一级缩进(frame)来开始解析。在浏览整个表单时，我们将在<strong class="is hu">框架</strong>级别创建一个对象，并添加框架内容，但我们将保持<strong class="is hu">段列表</strong>为空，因为它将填充下一级缩进。</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="3c00" class="ln jr ht mc b fv mg mh l mi mj"># Store frame names in a list</span><span id="92f1" class="ln jr ht mc b fv mk mh l mi mj">for row in reader:<br/>   frame = {"FrameName":row["Frame name"],<br/>   "FrameID": row["Frame ID"],<br/>   "protocol": row["Protocol"],<br/>   "segments":[]}</span></pre><p id="2e73" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">之后，我们将检查该帧是否已被添加到<strong class="is hu">帧名</strong>列表中。如果该框架的名称不在列表中，那么我们将把它添加到列表中。然后，我们将新的<strong class="is hu">帧</strong>对象添加到我们的<strong class="is hu">存储</strong>列表中，以添加到我们的json文件中。</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="330b" class="ln jr ht mc b fv mg mh l mi mj">   if row["Frame name"] not in framenames:<br/>      framenames.append(row["Frame name"])<br/>      store.append(frame)</span></pre><p id="728b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于我们的第二级缩进，我们将创建一个<strong class="is hu"> segment </strong>对象，并添加带有<strong class="is hu"> "" </strong>值的<strong class="is hu"> segmentname </strong>属性</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="6655" class="ln jr ht mc b fv mg mh l mi mj"># Create Objects for Frames, segments and packets<br/>segment = {"segmentName": "" }</span></pre><p id="f2c2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们将循环遍历存储在第一个缩进中的<strong class="is hu">帧</strong>，在每个帧中，我们将重新打开电子表格来遍历这些行，并在该帧中找到下一个<strong class="is hu">段</strong>。</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="4808" class="ln jr ht mc b fv mg mh l mi mj">for frame in store:<br/>   f = open( csvfile, 'rU' )<br/>   reader = csv.DictReader( f, fieldnames = ( "Protocol","Source Port","Destination Port","Source IP", "Destination IP", "Source MAC", "Destination MAC", "segment ID","Frame name", "Frame ID", "segment name", "packet ID", "Receivers"))</span></pre><p id="cc72" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，如果新的段名与框架的段名不匹配，我们将向该框架添加一个新的段对象及其所有属性</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="df03" class="ln jr ht mc b fv mg mh l mi mj">for row in reader:<br/>      if frame["FrameName"] == row["Frame name"]:<br/>         if segment["segmentName"] != row["segment name"]:<br/>            segment = {<br/>            "segmentID":row["segment ID"],<br/>            "segmentName": row["segment name"],<br/>            "srcPort":row["Source Port"],<br/>            "destPort":row["Destination Port"],<br/>            "packets":[{<br/>                "packetID":row["packet ID"],<br/>                "Receivers":row["Receivers"],<br/>                "destIP":row["Destination IP"],<br/>                "destMAC":row["Destination MAC"],<br/>                "srcIP": row["Source IP"],<br/>                "srcMAC":row["Source MAC"]<br/>            }]<br/>         }</span></pre><p id="d469" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后将segment对象添加到frame对象中，完成我们的第二级缩进。</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="7306" class="ln jr ht mc b fv mg mh l mi mj">            frame["segments"].append(segment)</span></pre><p id="5b19" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">否则，我们将创建一个数据包对象并填充其属性。之后，我们将把数据包对象添加到段对象中，这样我们就有了第三个缩进层次。</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="c425" class="ln jr ht mc b fv mg mh l mi mj">         else:<br/>            packet = {<br/>            "packetID":row["packet ID"],<br/>            "Receivers":row["Receivers"],<br/>            "destIP":row["Destination IP"],<br/>            "destMAC":row["Destination MAC"],<br/>            "srcIP": row["Source IP"],<br/>            "srcMAC":row["Source MAC"]<br/>            }<br/>            segment["packets"].append(packet)</span></pre><p id="1db7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，为了以JSON格式存储数据，我们将创建一个JSON文件</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="aeb9" class="ln jr ht mc b fv mg mh l mi mj"># Save the JSON<br/>f = open( 'data.json', 'w')</span></pre><p id="9af3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">并使用函数<strong class="is hu"> json.dumps </strong>将list <strong class="is hu"> store </strong>的内容写入其中</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="7ce6" class="ln jr ht mc b fv mg mh l mi mj">out = json.dumps(store, indent=4)<br/>f.write(out)</span></pre><h1 id="71c7" class="jq jr ht bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">解析Excel文件</h1><p id="cc7c" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">解析excel表格的步骤与解析csv文件的步骤几乎相同，除了一些我们将详细讨论的不同之处</p><p id="ecc5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的数据将与。csv文件，文件格式除外；会的。xls格式</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/58fe8f13672ae37d4ea98412f415c653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*QbptXp79pNQ_W87kr5O5zg.png"/></div><figcaption class="lb lc fg fe ff ld le bd b be z ek">.xls file with redundant data</figcaption></figure><p id="0be3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我们的脚本中，我们将导入所需的库来与新的文件格式进行交互</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="7c3e" class="ln jr ht mc b fv mg mh l mi mj">import xlrd</span></pre><p id="c482" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后我们将使用函数<strong class="is hu"> xlrd.open_workbook() </strong>打开Excel文件</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="1023" class="ln jr ht mc b fv mg mh l mi mj">book = xlrd.open_workbook('xlsfile.xls')</span></pre><p id="6d0a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">之后，我们将使用函数<strong class="is hu"> sheet_by_index() </strong>选择包含我们数据的工作表</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="37e9" class="ln jr ht mc b fv mg mh l mi mj">sh1 = book.sheet_by_index(0)</span></pre><p id="07c8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">同样，我们将创建两个列表，list <strong class="is hu"> store </strong>将收集我们将要解析的对象。和<strong class="is hu"> framenames </strong>，这个列表将帮助我们跟踪我们的对象列表中存储了什么。</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="09fd" class="ln jr ht mc b fv mg mh l mi mj">store = []<br/>framenames = []</span></pre><p id="03cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将通过添加第一级缩进(框架)来开始解析。浏览表单时，我们将检查<strong class="is hu">帧</strong>是否已被添加到我们的列表<strong class="is hu">帧名</strong>中。如果该框架的名称不在列表中，那么我们将添加它。然后，我们将在帧级别创建一个对象并添加其内容，但是我们将保持<strong class="is hu">段</strong>的列表为空，因为它将被填充到下一级缩进中。最后，我们将把新的frame对象添加到我们的<strong class="is hu"> store </strong>列表中，该列表将被添加到我们的json文件中。</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="a063" class="ln jr ht mc b fv mg mh l mi mj"># Store frame names in a list<br/>for rx in range(1, sh1.nrows):<br/>   if sh1.row(rx)[8].value not in framenames:<br/>      framenames.append(sh1.row(rx)[8].value)<br/>      frame = {<br/>        "frameName": sh1.row(rx)[8].value,<br/>        "frameID": sh1.row(rx)[9].value,<br/>        "protocol": sh1.row(rx)[0].value,<br/>        "segments":[]<br/>      }<br/>      store.append(frame)</span></pre><p id="e0da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于第二级缩进，我们将创建一个segment对象，并添加值为<strong class="is hu"> "" </strong>的<strong class="is hu"> segment </strong> name属性。</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="320f" class="ln jr ht mc b fv mg mh l mi mj">segment = {"segmentName": "" }</span></pre><p id="7b3b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，我们将遍历存储在第一个缩进中的帧，在每一帧中，我们将重读电子表格以遍历行并找到帧中的下一段。</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="cb54" class="ln jr ht mc b fv mg mh l mi mj">for frame in store:<br/>   for rx in range(1, sh1.nrows):<br/>      if frame["frameName"] == sh1.row(rx)[8].value:</span></pre><p id="ce14" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，如果新的段名与对象的段名不匹配，我们将添加一个新的段对象及其所有属性</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="5b3d" class="ln jr ht mc b fv mg mh l mi mj">         if segment["segmentName"] != sh1.row(rx)[10].value:<br/>            segment = {<br/>            "segmentID":sh1.row(rx)[7].value,<br/>            "segmentName": sh1.row(rx)[10].value,<br/>            "srcPort":int(sh1.row(rx)[1].value),<br/>            "destPort":int(sh1.row(rx)[2].value),<br/>            "packets":[{<br/>               "packetID":sh1.row(rx)[11].value,<br/>               "Receivers":sh1.row(rx)[12].value,<br/>               "srcMAC": sh1.row(rx)[5].value,<br/>               "srcIP": sh1.row(rx)[3].value,<br/>               "destIP":sh1.row(rx)[4].value,<br/>               "destMAC":sh1.row(rx)[6].value<br/>               }]<br/>            }</span></pre><p id="aa0d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后将segment对象添加到frame对象，并完成第二级缩进。</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="313a" class="ln jr ht mc b fv mg mh l mi mj">            frame["segments"].append(segment)</span></pre><p id="b1cd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">否则，我们将创建一个数据包对象并填充其属性。之后，我们将把数据包对象添加到段对象中，这样我们就有了第三个缩进层次。</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="bca2" class="ln jr ht mc b fv mg mh l mi mj">        else:<br/>           packet = {<br/>           "packetID":sh1.row(rx)[11].value,<br/>           "Receivers":sh1.row(rx)[12].value,<br/>           "srcMAC": sh1.row(rx)[5].value,<br/>           "srcIP": sh1.row(rx)[3].value,<br/>           "destIP":sh1.row(rx)[4].value,<br/>           "destMAC":sh1.row(rx)[6].value<br/>        }<br/>        segment["packets"].append(packet)</span></pre><p id="5268" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，为了以JSON格式存储数据，我们将创建一个JSON文件</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="d8e8" class="ln jr ht mc b fv mg mh l mi mj"># Save the JSON</span><span id="5ae3" class="ln jr ht mc b fv mk mh l mi mj">f = open( 'data.json', 'w')</span></pre><p id="97ef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">并使用函数<strong class="is hu"> json.dumps </strong>将list store的内容写入其中</p><pre class="ku kv kw kx fq mb mc md me aw mf dt"><span id="1ce6" class="ln jr ht mc b fv mg mh l mi mj">#rewrite JSON<br/>out = json.dumps(store, indent=4)<br/>f.write(out)</span></pre><p id="2767" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">正如我们所看到的，解析过程是非常直接的，但是当您有大量的冗余数据时，您需要能够理解它们是如何连接的，以及您的代码可以在不中断的情况下处理到什么级别的缩进。</p><p id="52f7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要访问完整的Python脚本，请访问:<a class="ae ml" href="https://github.com/aiayoub/Spreadsheet-Parser.git" rel="noopener ugc nofollow" target="_blank">https://github.com/aiayoub/Spreadsheet-Parser.git</a></p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff mm"><img src="../Images/34f3e5a74cf23d20dd5934f338e6b146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmLz9qVSYubBz2jSbEJmrg.png"/></div></div></figure><blockquote class="mr"><p id="28dd" class="ms mt ht bd mu mv mw mx my mz na jn ek translated">加入Coinmonks <a class="ae ml" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ml" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae ml" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="ln jr ht bd js lo nb lq jw lr nc lt ka jb nd lv ke jf ne lx ki jj nf lz km ma dt translated">此外，请阅读</h2><ul class=""><li id="20fb" class="ng nh ht is b it ko ix kp jb ni jf nj jj nk jn nl nm nn no dt translated"><a class="ae ml" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">拷贝交易</a> | <a class="ae ml" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">密码税务软件</a></li><li id="723e" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae ml" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="f33b" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">印度最佳密码交易所</a> | <a class="ae ml" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳密码交易所</a></li><li id="47a8" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">开发者最佳加密API</a></li><li id="f1dd" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae ml" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="b359" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated">最佳<a class="ae ml" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借出平台</a></li><li id="9487" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li><li id="95d1" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" href="https://coincodecap.com/best-vpns-for-crypto-trading" rel="noopener ugc nofollow" target="_blank">密码交易的最佳虚拟专用网络</a></li><li id="918f" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" href="https://coincodecap.com/huobi-crypto-trading-signals" rel="noopener ugc nofollow" target="_blank">火笔密码交易信号</a> | <a class="ae ml" rel="noopener" href="/coinmonks/hitbtc-review-c5143c5d53c2">点击查看</a></li><li id="58f1" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" href="https://coincodecap.com/traderwagon-review" rel="noopener ugc nofollow" target="_blank">贸易战回顾</a> | <a class="ae ml" href="https://coincodecap.com/kraken-vs-gemini-vs-bityard" rel="noopener ugc nofollow" target="_blank">北海巨妖对双子座对比特场</a></li><li id="ad10" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" href="https://coincodecap.com/ftx-futures-trading" rel="noopener ugc nofollow" target="_blank">如何在FTX交易所交易期货</a></li><li id="71f4" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" href="https://coincodecap.com/okex-kucoin" rel="noopener ugc nofollow" target="_blank"> OKEx vs KuCoin </a> | <a class="ae ml" href="https://coincodecap.com/celsius-alternatives" rel="noopener ugc nofollow" target="_blank">摄氏替代度</a> | <a class="ae ml" href="https://coincodecap.com/buy-vechain" rel="noopener ugc nofollow" target="_blank">如何购买VeChain </a></li><li id="e6a8" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" href="https://coincodecap.com/3commas-vs-pionex-vs-cryptohopper" rel="noopener ugc nofollow" target="_blank">3 commas vs . Pionex vs . crypto hopper</a></li><li id="0539" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" href="https://coincodecap.com/cornix-trading-bot" rel="noopener ugc nofollow" target="_blank">如何使用Cornix交易机器人</a></li><li id="7ed0" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" href="https://coincodecap.com/bitget-review" rel="noopener ugc nofollow" target="_blank"> Bitget回顾</a>|<a class="ae ml" href="https://coincodecap.com/gemini-vs-blockfi" rel="noopener ugc nofollow" target="_blank">Gemini vs block fi</a>cmd |<a class="ae ml" href="https://coincodecap.com/okex-futures-trading" rel="noopener ugc nofollow" target="_blank">OKEx期货交易</a></li><li id="60b3" class="ng nh ht is b it np ix nq jb nr jf ns jj nt jn nl nm nn no dt translated"><a class="ae ml" href="https://coincodecap.com/buy-crypto-with-credit-card" rel="noopener ugc nofollow" target="_blank">用信用卡购买密码的10个最佳地点</a></li></ul></div></div>    
</body>
</html>