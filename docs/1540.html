<html>
<head>
<title>Smart Contract Exploits Part 1 — Featuring Capture the Ether (Lotteries)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合约利用第1部分—以捕获以太(彩票)为特色</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/smart-contract-exploits-part-1-featuring-capture-the-ether-lotteries-8a061ad491b?source=collection_archive---------1-----------------------#2018-09-23">https://medium.com/coinmonks/smart-contract-exploits-part-1-featuring-capture-the-ether-lotteries-8a061ad491b?source=collection_archive---------1-----------------------#2018-09-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="6081" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">几个月前，一系列与稳固性(以及区块链总体情况)相关的挑战以游戏形式发布，玩家需要破解智能合约，耗尽其中的能量才能获胜。总共有17个不同难度的挑战，有3个热身挑战是为那些不熟悉坚固性的人准备的。这一系列的文章将分享我解决这些挑战的方法，当然，如果你是一个Solidity开发人员并且还没有尝试过这些挑战，我强烈建议你在阅读其中包含的方法之前尝试一下。</p><p id="e23a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这些挑战可以在网站上找到:<a class="ae jo" href="https://capturetheether.com/challenges/" rel="noopener ugc nofollow" target="_blank">https://capturetheether.com/challenges/</a><br/>这些挑战的作者是非常聪明的smarx，抓住他的推特账号@smarx。</p><p id="45cd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这篇文章将直接跳到彩票部分，说明在一个公共的、确定性的分布式系统上保守秘密或创建随机值可能是一个挑战。本文还假设了一些关于可靠性和相关开发工具的知识。</p><p id="40db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">事不宜迟——前方有巨大的剧透！</p><h1 id="89b5" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">1.猜猜这个数字</h1><p id="32a9" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下:</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="85d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了获胜，我们将需要调用函数<code class="eh kz la lb lc b"><em class="ld">guess</em>()</code>，通过变量<code class="eh kz la lb lc b"><em class="ld">n</em></code>传递答案，并随事务一起发送1 ether。由于我们可以访问源代码，我们可以清楚地看到答案是42！用参数<code class="eh kz la lb lc b"><em class="ld">n = 42</em></code>调用函数<code class="eh kz la lb lc b"><em class="ld">guess</em>()</code>将解决这个问题。</p><p id="cf99" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">虽然这很简单，但我确实相信作者试图暗示一些更深层次的东西。注意<code class="eh kz la lb lc b"><em class="ld">uint8 answer = 42</em></code>没有访问修饰符，默认为private。如果源代码没有公开发布，那就不那么明显了，因为我们将只能访问字节码:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/502dc662126b3dc42cecf0be2c128be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oKMChmJFUpBYIoVc.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Code not published — We can only see bytecodes.</figcaption></figure><p id="dc41" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这可能会让一些人认为变量是完全不可访问的，不幸的是，这是错误的。即使声明为private，我们仍然可以通过运行下面的命令并查找相关的存储索引来访问契约的状态存储:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lp"><img src="../Images/b4624ddee00541f3484275411f71723d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vvLqk51Sivof5T03.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Accessing the storage index.</figcaption></figure><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lq"><img src="../Images/3d5e073ad6e0a24732da753fc4980a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YmmQbti-E6Lx0P-M.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">0x2a in hex, decimal equivalent of 42.</figcaption></figure><h1 id="a50e" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">2.猜测秘密数字</h1><p id="6fc4" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="b983" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">也许明文是个糟糕的主意。让我们散列答案。所以现在我们需要调用函数<code class="eh kz la lb lc b"><em class="ld">guess</em>()</code>，同样通过变量<code class="eh kz la lb lc b"><em class="ld">n</em></code>传递一个数字，这将使keccak256散列并与状态变量answerHash比较，即<code class="eh kz la lb lc b"><em class="ld">0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365</em></code>。</p><p id="5c0e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">除了变量<code class="eh kz la lb lc b"><em class="ld">n</em></code>声明为uint8。即8位，最小整数为0，最大整数为255，要测试的概率空间为256。实际上没有那么多要讲的，所以让我们快速地做些混音…</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lr"><img src="../Images/81c0859a48b2fd78352da64f9427acde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qnh3Ue4U2-wib_4Z.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Creating a contract in Remix which brute forces the 256 probability space.</figcaption></figure><p id="cd77" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们得到的答案是170！同样地，用以太发送答案，我们将完成这个挑战。</p><p id="c3ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意，只要您有一个可以访问的keccak256实现/库，任何其他编程语言都应该会给出相同的结果，尽管要记住数据类型，例如，大多数在线转换器将输入视为字符串，这将被不同地散列。例如，使用<code class="eh kz la lb lc b"><em class="ld">web3.sha3</em></code>:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff ls"><img src="../Images/f7a5ddb6e5d4c14f2b167b5214235763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WmcU6JJdVPfMIfrC.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Note that datatype influences the hex output for hashing.</figcaption></figure><h1 id="4f94" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">3.猜随机数</h1><p id="29f3" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="6f57" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，现在状态变量<code class="eh kz la lb lc b"><em class="ld">answer</em></code>使用之前的块hash和当前块时间戳初始化，其中块hash和当前块时间戳用keccak256散列，并向下转换为uint8。现在这有一些问题…</p><ol class=""><li id="3d8d" class="lt lu ht is b it iu ix iy jb lv jf lw jj lx jn ly lz ma mb dt translated">获得这里使用的blockhash和块的时间戳很简单。再者，一般不建议使用blockhash作为随机种子(见<a class="ae jo" href="http://hackingdistributed.com/2017/12/24/how-not-to-run-a-blockchain-lottery/" rel="noopener ugc nofollow" target="_blank">这个</a>，和<a class="ae jo" href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620" rel="noopener ugc nofollow" target="_blank">这个</a>)。</li><li id="d619" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn ly lz ma mb dt translated">状态变量<code class="eh kz la lb lc b"><em class="ld">answer</em></code>只有0到255的概率空间，最大需要256ETH以蛮力方式迭代(但我们不需要)。</li><li id="221a" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn ly lz ma mb dt translated">如<strong class="is hu">猜数字</strong>所述，私有变量仍然可以访问。</li></ol><p id="c1ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们可以很容易地获得blockhash，方法是找出合同部署的blocknumber减1，并从Etherscan检索该块的blockhash。Timestamp是部署合同的块号的Unix时间戳。Keccak256这两个值，并将其转换为uint8，我们就有了答案。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lr"><img src="../Images/8840c1225cfb6b39a8852a64124bc8c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AqQpdgQuh3QOg9i1.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Manually applying keccak256 on blockhash and timestamp to produce the result we want.</figcaption></figure><p id="de24" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">或者，更简单的方法是访问状态变量索引。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mh"><img src="../Images/ea16ba54b5dd77b3efaa6495e50871df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*95hsrlPp2jLz7g7Q.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Accessing the storage index, hex 0x8d = decimal 141</figcaption></figure><h1 id="69ea" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">4.猜猜新号码</h1><p id="5886" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="0a4d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这与“猜测随机数”非常相似，不同之处在于变量<code class="eh kz la lb lc b"><em class="ld">answer</em></code>在每次猜测时被初始化。从表面上看，似乎引入了某种程度的随机性，因为我们不太可能知道blockhash是什么；除了实际上我们甚至不需要知道blockhash是什么来利用这种情况。</p><p id="3fd7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">更详细地说，回想一下，可以使用一个智能协定调用另一个智能协定，发送的每个事务都在同一个块中完成执行，即使该事务涉及跨多个智能协定的执行。为了利用这个契约，我们应该构建一个单独的智能契约，使用相同的机制调用函数<code class="eh kz la lb lc b"><em class="ld">guess()</em></code>来初始化变量<code class="eh kz la lb lc b"><em class="ld">answer</em></code>，我们将使用完全相同的值，因为执行是在相同的块中完成的，使用相同的块哈希和时间戳。</p><p id="8198" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们知道了这一点，让我们开始混音吧。请记住，我们的解决方案需要将1个以太转移到我们希望利用的契约，因此我们的函数需要是可支付的，允许我们在执行期间发送1个以太。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lr"><img src="../Images/d5803726a626a4f4cdc6ec96f4fe8e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZPJjkLHFUDdGbUpU.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Our exploit contract code.</figcaption></figure><p id="7482" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">嗯。我们部署了合同，但为什么当我们试图执行漏洞时，Remix会抱怨交易可能会失败？</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mi"><img src="../Images/82b8d6fa02bc50fbd178f6f2ec500591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7A4Y_bVWeoZ8MSon.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">The transaction will always fail? Hmm.</figcaption></figure><p id="5933" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们后退一步，再次回顾这一点。当我们使用智能契约调用函数<code class="eh kz la lb lc b"><em class="ld">guess()</em></code>时，假设输入是正确的，<strong class="is hu">guess new number</strong>契约将返回ethers，在本例中是返回给<code class="eh kz la lb lc b"><em class="ld">msg.sender</em></code>。回想一下，<code class="eh kz la lb lc b"><em class="ld">msg.sender</em></code>指的是交易的发送者，在这种情况下，我们将使用合同地址来利用漏洞(相比之下，<code class="eh kz la lb lc b"><em class="ld">tx.origin</em></code>指的是原始发送者)。现在，我们看到了当前解决方案的两个问题:</p><ol class=""><li id="b4b1" class="lt lu ht is b it iu ix iy jb lv jf lw jj lx jn ly lz ma mb dt translated">不允许应付回退功能。</li><li id="552b" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn ly lz ma mb dt translated">即使指定了一个回退应付函数，我们也想收回乙醚，所以我们需要以某种方式告诉合同将它退回给我们。</li></ol><p id="c14e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">回退函数只是一个函数，如果没有其他函数与被调用的函数签名相匹配，则默认执行该函数。例如，当将乙醚作为正常交易发送给合同，从而触发可支付回退函数执行时，或者当调用函数但该函数在合同中不存在时。为了将醚返回给我们，我们可以指定一个函数将醚传递回来，或者使用<code class="eh kz la lb lc b"><em class="ld">selfdestruct(msg.sender)</em></code>。请注意，这并没有编码到回退功能中，因为没有足够的气体从传输操作中转送过来。</p><p id="32bb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，漏洞代码看起来应该是这样的:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mj"><img src="../Images/0f1f5047f0a10e6d1a9341ca00e82820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*05r0kKDddYjFSPfv.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Our updated exploit contract code.</figcaption></figure><p id="0db7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行<code class="eh kz la lb lc b"><em class="ld">exec()</em></code>和随后的<code class="eh kz la lb lc b"><em class="ld">destroy()</em></code>将让我们取回我们的醚。</p><h1 id="0c69" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">5.预测未来</h1><p id="6d55" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="c6c1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于这个挑战，我们需要事先提交我们的猜测。提交猜测将记录下<code class="eh kz la lb lc b"><em class="ld">guess</em></code>的值和<code class="eh kz la lb lc b"><em class="ld">guesser</em></code>的地址。有一个变量<code class="eh kz la lb lc b"><em class="ld">settlementBlockNumber</em></code>作为条件变量，所以<code class="eh kz la lb lc b"><em class="ld">settle()</em></code>只能在后续程序块中调用。当我们调用函数<code class="eh kz la lb lc b"><em class="ld">settle()</em></code>时，会运行一个评估来查看提交的猜测是否与使用之前的blockhash和当前块时间戳mod 10创建的keccak256哈希的uint8转换匹配。这意味着概率空间是0到9，在这个范围内的任何猜测都有10%的机会是正确的。</p><p id="ca01" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">利用我们从pass challenges中学到的知识，我们的利用序列应该看起来有点像这样:</p><ol class=""><li id="cd83" class="lt lu ht is b it iu ix iy jb lv jf lw jj lx jn ly lz ma mb dt translated">创建另一个契约，它主要应该有两个功能:提交对<strong class="is hu"> PredictTheFuture </strong>契约的猜测；评估我们的猜测是否正确</li><li id="8edf" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn ly lz ma mb dt translated">提交我们的猜测。</li><li id="a182" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn ly lz ma mb dt translated">提交后，开始评估我们的猜测是否正确。</li><li id="0da5" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn ly lz ma mb dt translated">如果我们的猜测是正确的，合约将继续调用<strong class="is hu">预测未来</strong>合约上的<code class="eh kz la lb lc b"><em class="ld">settle()</em></code>。</li></ol><p id="6259" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将部署一个漏洞利用契约，在这里我们可以锁定我们的猜测，并且使用像Web3JS这样的库(我将使用Nethereum ),我们可以每一个/几个块调用一次漏洞利用契约来执行漏洞利用。或者，我们也可以通过每隔几个块重新混合来手动调用漏洞利用合同函数。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mk"><img src="../Images/3c9d7963ca70b05055e6492101c6c14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ELjAgUSokXQG0MUa.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Create our exploit contract. Don’t forget to place payable on relevant functions.</figcaption></figure><p id="e8ae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们锁定7作为我们的猜测。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff ml"><img src="../Images/5e5e9b92afb934ba0111aeb19cc4f578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4ukE7yXsFCLSSEuv.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Committing 7 to be our guess.</figcaption></figure><p id="4a50" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">加载VS2017并创建一个函数来调用我们的漏洞利用合同。当我们浏览可爱的猫图片时，让它做它的事情。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lr"><img src="../Images/96e9671815fee4893e1a33354cbc4c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Lnkqu5cscUAA3NnM.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Letting our program do all the hard work for us.</figcaption></figure><p id="c646" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一旦我们的漏洞利用合同获得正确的猜测，该功能应该完成并停止。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mm"><img src="../Images/b5b661a0b5188971981c8000cfd61ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u41A-OLhPClkAE3F.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">And we are done!</figcaption></figure><p id="6b2b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们只需要调用我们的开发合同上的<code class="eh kz la lb lc b"><em class="ld">killcontract()</em></code>来自毁和取回乙醚，完成这个挑战，并继续进行彩票部分的最后一个挑战。</p><h1 id="1571" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">6.预测块哈希</h1><p id="c741" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="bf89" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个很有意思。像前面的挑战一样，我们需要提交我们的猜测，并在随后的块上调用函数<code class="eh kz la lb lc b"><em class="ld">settle()</em></code>来查看我们的猜测是否正确。主要的区别在于，当我们提交我们的猜测时，我们也指定了解决方案散列是下一个块的散列(<code class="eh kz la lb lc b"><em class="ld">block.number + 1</em></code>)，并且是256位空间，不可能进行暴力破解。</p><p id="2578" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，这个契约的撤销是因为它依赖于块哈希，并且块哈希的检索只适用于256个过去的块(出于客户端实现效率的目的)，超过256个块的检索只返回<code class="eh kz la lb lc b"><em class="ld">0x0000000000000000000000000000000000000000000000000000000000000000</em></code></p><p id="ec3d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以太坊黄皮书和Solidity文档中都提到了这一点:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mn"><img src="../Images/fb1520ca583389f5256f3f70ab681061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c1uWDYY-5Oy0-J96.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Reading the docs — Ethereum Yellow Paper and Solidity docs.</figcaption></figure><p id="d4f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">把这些放在一起，利用这个契约就足够简单了。提交一个<code class="eh kz la lb lc b"><em class="ld">0x0000000000000000000000000000000000000000000000000000000000000000</em></code>的猜测，等待256个方块通过(大约一个小时，或者一个半小时)，然后执行函数<code class="eh kz la lb lc b"><em class="ld">settle()</em></code>完成挑战。</p><h1 id="fd2d" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">结论</h1><p id="6265" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">这是这个多部分系列的第一部分。显然，在确定性分布式系统上保持数据的私密性和随机性是很困难的。一些关键要点:</p><ol class=""><li id="9037" class="lt lu ht is b it iu ix iy jb lv jf lw jj lx jn ly lz ma mb dt translated">请始终注意，公共区块链上的所有数据和交易都是公开的，所有人都可以看到。</li><li id="0b8a" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn ly lz ma mb dt translated">请始终注意，另一个智能合约可以调用您的智能合约以实现某种程度的自动化和状态共享，因此您的智能合约应该设计得足够安全，可以被外部拥有的帐户和合约帐户调用。</li><li id="465a" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn ly lz ma mb dt translated">避免使用blockhash作为随机计算的种子——它可能是你的随机熵方案的一部分，这取决于你的智能契约处理多少价值，但不要依赖它。在处理巨大值时，考虑结合额外的熵源，如参与者的地址、提交-揭示方案、防止共谋的博弈论方案、使用预言等。</li><li id="4f03" class="lt lu ht is b it mc ix md jb me jf mf jj mg jn ly lz ma mb dt translated">时刻注意EVM的行为和怪癖。</li></ol><p id="89a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该系列的其余部分将在未来几周内发布，可能会先发布会计和杂项部分，因为我怀疑我会让数学变得相当冗长。让我们看看。与此同时，我鼓励你尝试其余的挑战——祝你一切顺利！</p><blockquote class="mo"><p id="5f1a" class="mp mq ht bd mr ms mt mu mv mw mx jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mz na nb nc nd kw fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff my"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>