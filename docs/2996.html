<html>
<head>
<title>Solidity Unit Testing with Remix IDE — A Few Missing Pieces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Remix IDE进行可靠性单元测试——一些缺失的部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-unit-testing-with-remix-ide-a-few-missing-pieces-6677786735d4?source=collection_archive---------1-----------------------#2020-05-15">https://medium.com/coinmonks/solidity-unit-testing-with-remix-ide-a-few-missing-pieces-6677786735d4?source=collection_archive---------1-----------------------#2020-05-15</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="46ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">昨天，我嘲笑了自己，试图为我准备的实验室作业对Solidity smart control进行单元测试。经过几个小时的努力，我终于找到了。我的问题是由多种原因造成的，例如智能合同的编写方式，没有阅读Remix指南上的次要细节，以及缺乏关于如何将示例应用于更一般情况的解释。虽然我已经用几种语言编写并测试了适当大小的程序，但我还没有广泛使用测试套件。以下是我经验的反映，希望它能给你使用<a class="ae jo" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix IDE </a>的单元测试项目一点启示。</p><p id="d494" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我测试了一个投票智能契约，它具有以下属性:</p><ul class=""><li id="d75e" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx dt translated">没有getter函数——我依赖编译器为公共变量生成getter函数。这些在单元测试代码中是不可访问的，因为“remix-test”拒绝运行，说没有这样的功能</li><li id="95cb" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">自定义事务上下文——依靠<code class="eh kd ke kf kg b">msg.sender</code>和<code class="eh kd ke kf kg b">modifier</code>来确定谁可以做什么。没有马上意识到<code class="eh kd ke kf kg b">msg.sender</code>只能在继承契约中设定</li><li id="54d3" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">在我的契约中，并不是每个in函数都返回值，所以很难知道某个函数是否工作</li><li id="571a" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">我用相应的变量如<code class="eh kd ke kf kg b">acc1</code>曲解了账户标签如<code class="eh kd ke kf kg b">account-1</code></li><li id="d27d" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated"><code class="eh kd ke kf kg b">try-catch</code>在继承的测试契约中不起作用，如果你的调用函数依赖于<code class="eh kd ke kf kg b">msg.sender</code></li><li id="8800" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">没有办法知道在失败的情况下返回了什么。与其他一些测试套件相比，没有显示接收到的值</li></ul><p id="47ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以下是我的<a class="ae jo" href="https://blog.coincodecap.com/tag/smart-contact/" rel="noopener ugc nofollow" target="_blank">智能合约</a>的摘录，用来跟踪可以对某件事投票的账户列表:</p><pre class="kh ki kj kk fq kl kg km kn aw ko dt"><span id="e928" class="kp kq ht kg b fv kr ks l kt ku">pragma solidity ^0.6.0;</span><span id="58a3" class="kp kq ht kg b fv kv ks l kt ku">contract VotersList{<br/>    <br/>    struct Voter {<br/>        string name;<br/>        bool voted;<br/>    }<br/>    mapping(address =&gt; Voter) public voters;  //List of voters<br/>    uint public numVoters = 0;<br/>    address public manager; //Manager of voting contract</span><span id="5bc6" class="kp kq ht kg b fv kv ks l kt ku">    constructor () public {<br/>        manager = msg.sender;  //Set contract creator as manager<br/>    }</span><span id="19dd" class="kp kq ht kg b fv kv ks l kt ku">    //Add new voter<br/>    function addVoter(address voterAddress, string memory name) public restricted returns (uint){<br/>        Voter memory v;<br/>        v.name = name;<br/>        v.voted = false;<br/>        voters[voterAddress] = v;<br/>        numVoters++;<br/>        return numVoters;<br/>    }<br/>    <br/>    modifier restricted() { //Only manager can do<br/>        require (msg.sender == manager);<br/>        _;<br/>    }<br/>}</span></pre><p id="315b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因为我想测试只有经理可以调用<code class="eh kd ke kf kg b">addVoter</code>函数，所以我必须使用定制的事务上下文。然而，过了一段时间才意识到<code class="eh kd ke kf kg b">msg.sender</code>只能在继承契约中设置。或者，我不得不使用继承，因为没有明确定义的getter函数来测试行为。然而，这也意味着<code class="eh kd ke kf kg b">try-catch</code>不能用来获得关于失败的一点细节。以下是相应的测试合同:</p><pre class="kh ki kj kk fq kl kg km kn aw ko dt"><span id="9352" class="kp kq ht kg b fv kr ks l kt ku">pragma solidity &gt;=0.4.22 &lt;0.7.0;<br/>import "remix_tests.sol"; // this import is automatically injected by Remix.<br/>import "./VotersList.sol";<br/>import "remix_accounts.sol"; //Use accounts defined here for testing</span><span id="e309" class="kp kq ht kg b fv kv ks l kt ku">// File name has to end with '_test.sol', this file can contain more than one testSuite contracts<br/>contract VoterListTest is VotersList {<br/>    address acc0;   //Variables used to emulate different accounts  <br/>    address acc1;<br/>    address acc2;<br/>    address acc3;</span><span id="1939" class="kp kq ht kg b fv kv ks l kt ku">/// 'beforeAll' runs before all other tests<br/>    function beforeAll() public {<br/>        acc0 = TestsAccounts.getAccount(0); //Initiate acc variables<br/>        acc1 = TestsAccounts.getAccount(1);<br/>        acc2 = TestsAccounts.getAccount(2);<br/>        acc3 = TestsAccounts.getAccount(3);<br/>    }<br/>    <br/>    /// Account at index zero (account-0) is default account, so manager will be set to acc0<br/>    function managerTest() public {<br/>        Assert.equal(manager, acc0, 'Manager should be acc0');<br/>    }<br/>    <br/>    /// Add a voter as manager<br/>    /// When msg.sender isn't specified, default account (i.e., account-0) is considered as the sender<br/>    function addVoter() public {<br/>        Assert.equal(addVoter(acc1, 'Alice'), 1, 'Should be equal to 1');<br/>    }<br/>    <br/>    /// Try to add voter as a user other than manager. This should fail<br/>    /// #sender: account-1<br/>    function addVoterFailure() public {<br/>        Assert.equal(addVoter(acc2, 'Bob'), 2, 'Should be equal to 2');    <br/>    }<br/>    <br/>    /// Try to add voter as manager again<br/>    function addVoter2() public {<br/>        Assert.equal(addVoter(acc3, 'Charlie'), 2, 'Should be equal to 2');    <br/>    }<br/>    <br/>    /// Verify number of votes<br/>    function voteOpenTest() public {<br/>        Assert.equal(numVoters, 2, 'Should be equal to 2');<br/>    }<br/>}</span></pre><p id="0331" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">上述代码中需要注意的一些附加内容是:</p><ul class=""><li id="c3b9" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx dt translated"><code class="eh kd ke kf kg b">account-1</code>是用于设置<code class="eh kd ke kf kg b">msg.sender</code>的账户标签，<code class="eh kd ke kf kg b">acc0</code>是变量。<code class="eh kd ke kf kg b">TestsAccounts.getAccount(0)</code>也可以直接使用</li><li id="8768" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">指数为零的账户(即<code class="eh kd ke kf kg b">account-0</code>)为默认账户。如果没有设置<code class="eh kd ke kf kg b">#sender:</code>，则采用默认账户</li><li id="86bb" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated"><code class="eh kd ke kf kg b">addVoterFailure</code>测试用例将失败，因为我们不能使用<code class="eh kd ke kf kg b">try-catch</code>。然而，一点细节仍然会出现在Remix上。问题是我应该调用<code class="eh kd ke kf kg b">try this.addVoter(acc2, ‘Bob')</code>，因为<code class="eh kd ke kf kg b">try-catch</code>只对外部函数起作用。但是，这会将上下文更改为<code class="eh kd ke kf kg b">this</code>合同，而忽略<code class="eh kd ke kf kg b">#sender: account-1</code>。这种情况可以用非继承单元测试来测试</li></ul><p id="efc6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以下是单元测试的结果，代码可以从我的<a class="ae jo" href="https://github.com/dilumb/smart_contracts" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中找到:</p><figure class="kh ki kj kk fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff kw"><img src="../Images/0de701129d58428bd37a0553b11c0050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WqNDvP5EqPaSH7K85JbgQ.png"/></div></div></figure><figure class="kh ki kj kk fq kx fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff le"><img src="../Images/e9dbce386c4f90837b5db529a4c87766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fZu_SfnNF6m_BGbXlsl-A@2x.png"/></div></a></figure><blockquote class="lf"><p id="9270" class="lg lh ht bd li lj lk ll lm ln lo jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="lq lr ls lt lu kx fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lp"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>