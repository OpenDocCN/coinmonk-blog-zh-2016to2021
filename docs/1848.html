<html>
<head>
<title>Advanced EOS Series — Part 1 — Cryptographic Hashes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级EOS系列—第1部分—加密哈希</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/advanced-eos-series-part-1-cryptographic-hashes-a251a8d371b8?source=collection_archive---------3-----------------------#2018-12-02">https://medium.com/coinmonks/advanced-eos-series-part-1-cryptographic-hashes-a251a8d371b8?source=collection_archive---------3-----------------------#2018-12-02</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/a1f6d3c7053ad71dfcfa25748d5a7afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9O9awZFyxQjLzA_PFlj6lQ.jpeg"/></div></div></figure><p id="93af" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎来到高级EOS开发系列，在这里我将涉及到教程和课程很少涉及的技术和功能。本系列的目的是将您作为应用程序开发人员在EOS网络上完成技能所需的缺失部分汇集在一起。每篇文章都是按照难度排序的，所以如果你想要一个大概的了解，我建议你从这里开始，一步步往上。这些例子的完整代码可以在GitHub 上找到<a class="ae jz" href="https://github.com/MitchPierias/Advanced-EOS-Examples" rel="noopener ugc nofollow" target="_blank">。</a></p><div class="ka kb fm fo kc kd"><a href="https://github.com/MitchPierias/Advanced-EOS-Examples/tree/master/01_Hashes" rel="noopener  ugc nofollow" target="_blank"><div class="ke ab ej"><div class="kf ab kg cl cj kh"><h2 class="bd hu fv z el ki eo ep kj er et hs dt translated">MitchPierias/高级-EOS-示例</h2><div class="kk l"><h3 class="bd b fv z el ki eo ep kj er et ek translated">一系列EOS合同开发实例。通过创建…为MitchPierias/Advanced-EOS-Examples开发做出贡献</h3></div><div class="kl l"><p class="bd b gc z el ki eo ep kj er et ek translated">github.com</p></div></div><div class="km l"><div class="kn l ko kp kq km kr iz kd"/></div></div></a></div><blockquote class="ks kt ku"><p id="16c4" class="jb jc kv jd b je jf jg jh ji jj jk jl kw jn jo jp kx jr js jt ky jv jw jx jy hm dt translated">由于这些是高级或扩展的主题，我很危险地假设你已经知道了基础知识，并且正在寻求进一步的知识。因此，这些文章中共享的代码将针对所讨论的主题进行精简。</p></blockquote></div><div class="ab cl kz la hb lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hm hn ho hp hq"><h1 id="b60d" class="lg lh ht bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md dt translated">加密哈希函数</h1><p id="aa5a" class="pw-post-body-paragraph jb jc ht jd b je me jg jh ji mf jk jl jm mg jo jp jq mh js jt ju mi jw jx jy hm dt translated">让我们从哈希开始，这个例子的所有资源都可以在GitHub 的<a class="ae jz" href="https://github.com/MitchPierias/Advanced-EOS-Examples/tree/master/01_Hashes" rel="noopener ugc nofollow" target="_blank">这里找到。在密码术中，散列算法接受输入并生成固定大小的混杂信息，称为输出摘要。摘要是确定的和不可逆的，这意味着相同的输入将总是生成相同的输出，并且输出不能被反转以获得原始输入。一个好的哈希算法通过在最短的计算时间内使用“高难度”来最小化输出冲突。两个不同的输入产生相同输出的可能性。</a></p><h2 id="5ed7" class="mj lh ht bd li mk ml mm lm mn mo mp lq jm mq mr lu jq ms mt ly ju mu mv mc mw dt translated">哈希的应用</h2><p id="7e1c" class="pw-post-body-paragraph jb jc ht jd b je me jg jh ji mf jk jl jm mg jo jp jq mh js jt ju mi jw jx jy hm dt translated">通常我们会使用哈希函数来认证和索引数据，我喜欢把它看作是一种压缩唯一性的方法。例如，比较两个任意大小的文件或用户电子邮件会非常耗时，并且会暴露易受攻击的用户数据。我们可以通过散列文件内容或用户电子邮件来生成指纹，并使用散列结果更有效地索引和比较数据。</p><p id="4a8e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这大概是我们目前需要知道的，但是如果你想满足你的好奇心，那么我会鼓励你主动谷歌一下或者看看Blockgeeks关于<a class="ae jz" href="https://blockgeeks.com/guides/cryptographic-hash-functions/" rel="noopener ugc nofollow" target="_blank">加密散列函数</a>的文章。</p></div><div class="ab cl kz la hb lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hm hn ho hp hq"><h1 id="3f19" class="lg lh ht bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md dt translated">编写我们的哈希函数</h1><p id="4812" class="pw-post-body-paragraph jb jc ht jd b je me jg jh ji mf jk jl jm mg jo jp jq mh js jt ju mi jw jx jy hm dt translated">现在，我们对哈希有了非常基本的了解，我们可以看看如何在我们的EOS智能合约中生成我们自己的哈希。我们将创建一个动作，它接受一个输入<code class="eh mx my mz na b">string</code>并输出一个<code class="eh mx my mz na b">checksum256</code>散列摘要，然后为了这个例子的目的，打印结果。</p><p id="94c9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们从包含来自EOS框架的<code class="eh mx my mz na b">crypto.h</code>库和EOS <code class="eh mx my mz na b">print.h </code>包装器开始。</p><pre class="nb nc nd ne fq nf na ng nh aw ni dt"><span id="4299" class="mj lh ht na b fv nj nk l nl nm">include <!-- -->&lt;eosiolib/crypto.h&gt;</span></pre><blockquote class="ks kt ku"><p id="c2d1" class="jb jc kv jd b je jf jg jh ji jj jk jl kw jn jo jp kx jr js jt ky jv jw jx jy hm dt translated">注意<em class="ht">。我们的<code class="eh mx my mz na b">crypto.h</code>文件名上的h </em>扩展名？这意味着我们使用的是一个<em class="ht"> C </em>库，而不是<em class="ht"> C++ </em>，所以我们的方法需要<em class="ht"> C </em>类型的输入。</p></blockquote><p id="74c2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们可以像这样定义我们的动作并为我们的<code class="eh mx my mz na b">checksum256</code>输出分配一个引用。</p><pre class="nb nc nd ne fq nf na ng nh aw ni dt"><span id="c8b4" class="mj lh ht na b fv nj nk l nl nm">checksum256 sum{};</span></pre><p id="f5bd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">EOS框架为各种散列算法提供了一套方法。在这个例子中，我们将使用<code class="eh mx my mz na b">sha256</code>,因为它快速、安全，是大多数情况下使用的典型。</p><pre class="nb nc nd ne fq nf na ng nh aw ni dt"><span id="2a6d" class="mj lh ht na b fv nj nk l nl nm">sha256(const_cast&lt;char*&gt;(str.c_str()), str.size(), &amp;sum);</span></pre><p id="1612" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们的<code class="eh mx my mz na b">sha256</code>方法需要<em class="kv"> C </em>类型的输入，所以我们首先需要将我们的<code class="eh mx my mz na b">string</code>转换成一个<code class="eh mx my mz na b">char</code>集合，然后传递<code class="eh mx my mz na b">string</code>的大小和一个<code class="eh mx my mz na b">checksum256</code>引用，这将使用输出摘要进行更新。现在剩下的就是打印散列的输出结果。</p><pre class="nb nc nd ne fq nf na ng nh aw ni dt"><span id="2211" class="mj lh ht na b fv nj nk l nl nm">printhex(&amp;sum, sizeof(sum));</span></pre><p id="853d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们也可以在这里返回<code class="eh mx my mz na b">checksum256</code>,并将其用作私有的内部操作。</p></div><div class="ab cl kz la hb lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hm hn ho hp hq"><h1 id="f2c2" class="lg lh ht bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md dt translated">更进一步— <strong class="ak">字符串校验和</strong></h1><blockquote class="ks kt ku"><p id="9c5a" class="jb jc kv jd b je jf jg jh ji jj jk jl kw jn jo jp kx jr js jt ky jv jw jx jy hm dt translated">这个实现归功于<a class="ae jz" href="https://github.com/miguelmota" rel="noopener ugc nofollow" target="_blank"> Miguel Mota </a>开发了一个将checksum256转换为十六进制字符串的解决方案。</p></blockquote><p id="46e6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">那么，如果我们想把摘要转换回字符串，会发生什么呢？为此，我们需要一种新的方法。首先，让我们为输入参数定义一个模板，并定义方法本身。这个模板是在我们的方法定义之外定义的，通常在我们文件的顶部。模板只是允许我们在调用函数时定义变量类型，然后编译器会负责替换并使其正常工作。</p><pre class="nb nc nd ne fq nf na ng nh aw ni dt"><span id="4d11" class="mj lh ht na b fv nj nk l nl nm">template &lt;typename CharT&gt;</span><span id="dcf9" class="mj lh ht na b fv nn nk l nl nm">string to_hex(const CharT* data, uint32_t length) {<br/>  // Method Body<br/>}</span></pre><p id="f2fc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们可以开始处理我们方法的主体了。首先，我们将为我们的结果创建一个<code class="eh mx my mz na b">string</code>，一个<code class="eh mx my mz na b">char</code>集合，用于稍后绘制字符，并将我们的数据强制到一个<code class="eh mx my mz na b">uint8_t</code>。</p><pre class="nb nc nd ne fq nf na ng nh aw ni dt"><span id="7935" class="mj lh ht na b fv nj nk l nl nm">string result;<br/>const char* hex_chars = "0123456789abcdef";<br/>uint8_t* c = (uint8_t*)data;</span></pre><p id="23ee" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，我们将迭代输入数据中的每个<code class="eh mx my mz na b">char</code>，匹配相应的十六进制字符，并将其添加到结果<code class="eh mx my mz na b">string</code>中。</p><pre class="nb nc nd ne fq nf na ng nh aw ni dt"><span id="b861" class="mj lh ht na b fv nj nk l nl nm">for (uint32_t i = 0; i &lt; length; ++i) {<br/>  (result += hex_chars[(c[i] &gt;&gt; 4)]) += hex_chars[(c[i] &amp; 0x0f)];<br/>}</span><span id="269a" class="mj lh ht na b fv nn nk l nl nm">return result;</span></pre><p id="0a7d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">就是这样！我们现在有了一个从<code class="eh mx my mz na b">char</code>集合创建<code class="eh mx my mz na b">checksum256</code>的方法，以及一个将<code class="eh mx my mz na b">checksum256</code>转换成<code class="eh mx my mz na b">string</code>的方法。在下一篇文章中，我们将关注单体，以及如何利用它们来存储应用程序状态和配置。</p><figure class="nb nc nd ne fq iu"><div class="bz el l di"><div class="no np l"/></div></figure><h2 id="d9a0" class="mj lh ht bd li mk ml mm lm mn mo mp lq jm mq mr lu jq ms mt ly ju mu mv mc mw dt translated">下一步是什么？</h2><p id="245b" class="pw-post-body-paragraph jb jc ht jd b je me jg jh ji mf jk jl jm mg jo jp jq mh js jt ju mi jw jx jy hm dt translated">如果您想在我分享本系列中的更多示例时得到通知，请务必点击<em class="kv">跟随</em>按钮。第2部分将介绍我们如何利用EOS中的单例来存储契约状态和配置。</p><figure class="nb nc nd ne fq iu fe ff paragraph-image"><a href="http://bit.ly/2G71Sp7"><div class="fe ff nq"><img src="../Images/449450761cd76f44f9ae574333f9e9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKX2mtg7p1lOs7JmosPLsA.png"/></div></a><figcaption class="nr ns fg fe ff nt nu bd b be z ek"><a class="ae jz" href="http://bit.ly/2G71Sp7" rel="noopener ugc nofollow" target="_blank"><strong class="bd nv">Click to read today’s top story</strong></a></figcaption></figure></div></div>    
</body>
</html>