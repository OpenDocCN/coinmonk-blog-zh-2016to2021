<html>
<head>
<title>Guide to Ownership and Access Control in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity中的所有权和访问控制指南</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/guide-to-ownership-and-access-control-in-solidity-f2d99f63c6d4?source=collection_archive---------0-----------------------#2019-12-18">https://medium.com/coinmonks/guide-to-ownership-and-access-control-in-solidity-f2d99f63c6d4?source=collection_archive---------0-----------------------#2019-12-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="ea74" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">从简单到复杂，代码可以重用。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/2c344078a13a9d720a330840c5ad930e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUgGWUx_ehfDBgU1x9MqKw.jpeg"/></div></div></figure><p id="f785" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">【2020年5月更新:智能合约开发进展非常快，本文描述的情况已经发生了变化。我与OpenZeppelin合作开发了他们3.0版本的访问控制库，在这里描述的智能契约中，只有<a class="ae kq" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/ownership/Ownable.sol" rel="noopener ugc nofollow" target="_blank"> Ownable.sol </a>还在使用。请阅读<a class="ae kq" rel="noopener" href="/coinmonks/how-to-use-accesscontrol-sol-9ea3a57f4b15">的另一篇文章</a>，了解在智能合同中使用访问控制的最新指南。</p><h1 id="393e" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">介绍</h1><p id="e1d3" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">当撰写智能合同时，我倾向于采取教育的方法。即使它们是为生产环境设计的，我也尽可能让它们易于理解。我编写的<a class="ae kq" href="https://github.com/HQ20/contracts" rel="noopener ugc nofollow" target="_blank">契约</a>是可重用的，但通常它们会针对每个特定的业务案例进行重写。</p><p id="d8d2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在这篇文章中，我将讨论solidity智能合同中的三种许可方法。这些方法按照复杂程度的递增顺序进行讨论，这也是您在项目中应该考虑的顺序。我包含了您可以为每种方法重用的代码。</p><p id="338c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">本文假设您习惯于在solidity中编写智能契约，并使用继承和将契约地址作为参数传递等特性。如果你正在寻找一篇关于智能合同开发的更简单的文章，你可以试试这篇文章。</p><blockquote class="lo"><p id="ffde" class="lp lq ht bd lr ls lt lu lv lw lx kp ek translated">不熟悉加密？尝试<a class="ae kq" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae kq" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><h1 id="3f47" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz ly ja ld jc lz jd lf jf ma jg lh li dt translated">简单方法— Ownable.sol</h1><p id="bbf4" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">OpenZeppelin的Ownable.sol合同肯定是重用率最高的合同之一。在77行中，它实现了:</p><ol class=""><li id="7813" class="mb mc ht jw b jx jy ka kb kd md kh me kl mf kp mg mh mi mj dt translated">断言某人是合同所有者的逻辑。</li><li id="0608" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp mg mh mi mj dt translated">将函数调用限制为合同所有者以继承合同的逻辑。</li><li id="890e" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp mg mh mi mj dt translated">将所有权转移到不同地址的逻辑。</li></ol><p id="044b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在编写智能合约的代码时，经常会用到“继承”。让我们用一个例子来看看如何使用<code class="eh mp mq mr ms b">Ownable</code>。想象一下，你想在合同中保留一个地址列表，但你想成为唯一一个可以添加更多地址的人。你可以把它想象成一个你信任的人的注册表。你可以这样做:</p><pre class="jj jk jl jm fq mt ms mu mv aw mw dt"><span id="3e34" class="mx ks ht ms b fv my mz l na nb">contract Whitelist is Ownable {<br/>   mapping (address =&gt; bool) members;<br/> <br/>   constructor() public Ownable() {<br/>   }<br/> <br/>   function addMember(address _member)<br/>       public<br/>       onlyOwner<br/>   {<br/>       members[_member] = true;<br/>   }<br/>}</span></pre><p id="36e9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">继承自<code class="eh mp mq mr ms b">Ownable</code>并在您的上呼叫其建构函式，可确保部署合约的位址已注册为拥有者。<code class="eh mp mq mr ms b">onlyOwner</code>修饰词如果不被注册为所有者的地址调用，则使功能回复。</p><p id="09a4" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">部署此合约后，只有您或您指定的某个人可以向中的列表添加新成员。</p><p id="a987" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">简单地说，就是这样。还有几个功能，不过如果你查看一下<a class="ae kq" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/ownership/Ownable.sol" rel="noopener ugc nofollow" target="_blank">源代码</a>，你就会明白了。试着用<a class="ae kq" href="https://github.com/HQ20/contracts/blob/v0.0.2/contracts/access/Whitelist.sol" rel="noopener ugc nofollow" target="_blank">实现一些简单的东西</a>，这很容易理解。</p><p id="9b3a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">尽管它有用，也会有很多时候<code class="eh mp mq mr ms b">Ownable</code>是不够的。在给定的时间内，只有一个地址可以是所有者，只有所有者才能决定谁可以是新所有者，您只能检查您是否是所有者，而不是别人是否是。</p><h1 id="19aa" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">中间方法—白名单. sol</h1><p id="8592" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated"><a class="ae kq" href="https://github.com/HQ20/contracts/blob/v0.0.2/contracts/access/Whitelist.sol" rel="noopener ugc nofollow" target="_blank">白名单。sol </a>保存一个地址列表，该列表可用于限制功能或任何其他目的。它在功能上与OpenZeppelin的<a class="ae kq" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/access/Roles.sol" rel="noopener ugc nofollow" target="_blank"> Roles.sol </a>非常相似，只是有一些关键的区别(请查看我们的<a class="ae kq" href="https://github.com/HQ20/contracts/tree/dev/contracts/access#whitelistsol-vs-openzeppelins-rolessol-and-whitelistedrolesol" rel="noopener ugc nofollow" target="_blank"> README </a>)。</p><p id="1d82" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><a class="ae kq" href="https://github.com/HQ20/contracts/blob/v0.0.2/contracts/access/Whitelist.sol" rel="noopener ugc nofollow" target="_blank">白名单. sol </a>只有三个功能:</p><pre class="jj jk jl jm fq mt ms mu mv aw mw dt"><span id="dfcf" class="mx ks ht ms b fv my mz l na nb">function isMember(address _member) public view returns(bool);<br/>function addMember(address _member) public onlyOwner;<br/>function removeMember(address _member) public onlyOwner;</span></pre><p id="81ec" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">例如，使用这个合约，您可以保留一个已批准的涉众列表，这些涉众可以是令牌转移的唯一接受者。你可以这样做:</p><pre class="jj jk jl jm fq mt ms mu mv aw mw dt"><span id="e699" class="mx ks ht ms b fv my mz l na nb">pragma solidity ^0.5.0;<br/> <br/>import "@openzeppelin/contracts/token/ERC20/ERC20.sol";<br/>import "../access/Whitelist.sol";<br/> <br/> <br/>contract ERC20Whitelisted is ERC20 {<br/> <br/>   Whitelist whitelist;<br/> <br/>   constructor(address _whitelistAddress) public {<br/>       whitelist = Whitelist(_whitelistAddress);<br/>   }<br/> <br/>   function transfer(address account, uint256 amount) public {<br/>       require(whitelist.isMember(account), "Account not whitelisted.");<br/>       super._transfer(account, amount);<br/>   }<br/>}</span></pre><p id="5002" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在上面的例子中，你也可以让<code class="eh mp mq mr ms b">ERC20Whitelisted</code>继承<code class="eh mp mq mr ms b">ERC20</code>和<code class="eh mp mq mr ms b">Whitelist</code>。我很乐意讨论一些权衡<a class="ae kq" href="www.albertocuesta.es" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="63b2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">简单的白名单可能非常强大。OpenZeppelin使用它们实现了许多<a class="ae kq" href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/release-v2.5.0/contracts/token/ERC20" rel="noopener ugc nofollow" target="_blank"> ERC20 </a>和<a class="ae kq" href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/release-v2.5.0/contracts/token/ERC721" rel="noopener ugc nofollow" target="_blank"> ERC721 </a>变种，并设法提供了比我们大多数人所需更多的功能。在<a class="ae kq" href="www.techhq.io" rel="noopener ugc nofollow" target="_blank"> TechHQ </a>我们也只使用白名单实现了<a class="ae kq" href="https://www.cementdao.com/" rel="noopener ugc nofollow" target="_blank"> CementDAO </a>。</p><p id="08cd" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">然而，有时白名单也会有所欠缺。一个白名单可能需要多个所有者。或者您可能需要管理许多重叠的白名单。对于这些情况，我们有一个等级角色契约。</p><h1 id="1a3d" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">复杂RBAC.sol</h1><p id="9a5d" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">我们开发了<a class="ae kq" href="https://github.com/HQ20/contracts/blob/v0.0.2/contracts/access/RBAC.sol" rel="noopener ugc nofollow" target="_blank"> RBAC.sol </a>旨在提供多用户功能，就像现代共享系统一样。</p><ol class=""><li id="f376" class="mb mc ht jw b jx jy ka kb kd md kh me kl mf kp mg mh mi mj dt translated">有些角色只不过是一组地址。</li><li id="31b1" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp mg mh mi mj dt translated">组成员资格只能由某些管理员角色的成员修改。</li><li id="5db1" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp mg mh mi mj dt translated">新角色可以在运行时创建。</li><li id="5aaf" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp mg mh mi mj dt translated">可以验证角色成员资格。</li></ol><p id="b54a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在低层次上，我们使用用户选择的<code class="eh mp mq mr ms b">bytes32</code>参数来识别角色。通常这些是可识别的短字符串，但是您也可以使用加密值或地址。</p><p id="9077" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">角色本身是一组成员地址和管理角色的标识符。有趣的是，我们不需要将角色的标识符存储在它自己的结构中。</p><pre class="jj jk jl jm fq mt ms mu mv aw mw dt"><span id="f9d7" class="mx ks ht ms b fv my mz l na nb">struct Role {<br/>    bytes32 adminRoleId;<br/>    mapping (address =&gt; bool) members;<br/>}</span></pre><p id="de8b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在有两种方法可以添加新角色并验证角色是否存在:</p><pre class="jj jk jl jm fq mt ms mu mv aw mw dt"><span id="378a" class="mx ks ht ms b fv my mz l na nb">function roleExists(bytes32 _roleId) public view returns(bool);<br/>function addRole(bytes32 _roleId, bytes32 _adminRoleId) public;</span></pre><p id="2533" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">管理成员的功能是相同的，只是现在必须指定相关的角色:</p><pre class="jj jk jl jm fq mt ms mu mv aw mw dt"><span id="0d13" class="mx ks ht ms b fv my mz l na nb">function isMember(address _member, bytes32 _roleId) public view returns(bool);<br/>function addMember(address _member, bytes32 _roleId) public;<br/>function removeMember(address _member, bytes32 _roleId) public;</span></pre><p id="5517" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">只有当调用者属于我们正在添加成员的角色的管理员角色时，<code class="eh mp mq mr ms b">addMember</code>和<code class="eh mp mq mr ms b">removeMember</code>才会成功。</p><p id="13f3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh mp mq mr ms b">addRole</code>只有当调用方属于将管理正在创建的角色的角色时，才会成功。</p><p id="c2a1" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这些简单的规则将允许创建一个角色层次结构，然后可以用它来实现具有不同许可级别或区域的复杂多用户平台。</p><h1 id="442a" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">进一步学习</h1><p id="7e1c" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">为了更深入地探究兔子洞，我建议从《T4》杂志的本期<a class="ae kq" href="https://github.com/OpenZeppelin/openzeppelin-contracts/issues/1772" rel="noopener ugc nofollow" target="_blank">开始。他们的代码库和我们的没什么不同，你会发现大多数设计决策都有一个完整的推理，即使我们选择了另一条路。他们对像<code class="eh mp mq mr ms b">ERC20Mintable</code>这样的合同使用<code class="eh mp mq mr ms b">Roles</code>是替代<code class="eh mp mq mr ms b">Whitelist</code>的一个很好的例子。</a></p><p id="21cc" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">勇敢者的另一个资源是<a class="ae kq" href="https://github.com/aragon/aragonOS/tree/next/contracts/acl" rel="noopener ugc nofollow" target="_blank">阿拉贡诺斯ACL合同</a>。只需浏览一下界面，就能看出他们已经决定比其他人走得更远:</p><pre class="jj jk jl jm fq mt ms mu mv aw mw dt"><span id="68cb" class="mx ks ht ms b fv my mz l na nb">function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);</span></pre><p id="331d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">对于我们自己的<a class="ae kq" href="https://github.com/HQ20/contracts" rel="noopener ugc nofollow" target="_blank"> @hq20/contracts </a>包中的例子，我们使用了本文中描述的三个访问控制级别，因此您也应该密切关注。</p><h1 id="696b" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">结论</h1><p id="a4f1" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">当谈到智能契约实现时，最好只实现所需的复杂性，不要再多了。就许可而言，有三个不同层次的复杂性:</p><ol class=""><li id="b51d" class="mb mc ht jw b jx jy ka kb kd md kh me kl mf kp mg mh mi mj dt translated">单一用户</li><li id="0004" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp mg mh mi mj dt translated">用户组</li><li id="f8a4" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp mg mh mi mj dt translated">用户组的层次结构</li></ol><p id="da2e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">您可以将<a class="ae kq" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/ownership/Ownable.sol" rel="noopener ugc nofollow" target="_blank"> Ownable.sol </a>用于允许单个用户使用的系统。对于需要在一个组中授权用户的系统，可以使用<a class="ae kq" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/access/Roles.sol" rel="noopener ugc nofollow" target="_blank">@ open zeppelin/roles . sol</a>或者<a class="ae kq" href="https://github.com/HQ20/contracts/blob/v0.0.2/contracts/access/Whitelist.sol" rel="noopener ugc nofollow" target="_blank"> @hq20/Whitelist.sol </a>。对于需要组层次结构的系统，我们过去已经成功地使用了<a class="ae kq" href="https://github.com/HQ20/contracts/blob/v0.0.2/contracts/access/RBAC.sol" rel="noopener ugc nofollow" target="_blank"> @hq20/RBAC.sol </a>。</p><p id="e660" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">你会有自己的要求，需要自己做出权衡取舍的决定。了解每个实现背后的设计决策将允许您使用现有的契约或者修改一个供自己使用的契约。</p><p id="4a88" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">请确保<a class="ae kq" href="https://www.techhq.io/#GetinTouch" rel="noopener ugc nofollow" target="_blank">让我们知道</a>任何反馈。我们正在开发<a class="ae kq" href="https://github.com/HQ20/contracts" rel="noopener ugc nofollow" target="_blank"> @hq20/contracts </a>包来支持真实世界区块链应用程序的编码。我们的目标是让我们的代码被重用和滥用，我们很乐意知道你们是如何做到的。</p><blockquote class="lo"><p id="f573" class="lp lq ht bd lr ls lt lu lv lw lx kp ek translated">加入Coinmonks <a class="ae kq" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae kq" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae kq" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="mx ks ht bd kt nc nd ne kx nf ng nh lb kd ni nj ld kh nk nl lf kl nm nn lh no dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="mb mc ht jw b jx lj ka lk kd np kh nq kl nr kp ns mh mi mj dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae kq" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp ns mh mi mj dt translated"><a class="ae kq" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae kq" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp ns mh mi mj dt translated"><a class="ae kq" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae kq" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp ns mh mi mj dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae kq" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp ns mh mi mj dt translated">开发人员的最佳加密API</li><li id="b359" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp ns mh mi mj dt translated">最佳<a class="ae kq" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp ns mh mi mj dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae kq" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="mb mc ht jw b jx mk ka ml kd mm kh mn kl mo kp ns mh mi mj dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币的终极指南</a></li></ul></div></div>    
</body>
</html>