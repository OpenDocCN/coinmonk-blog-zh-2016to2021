<html>
<head>
<title>Solidity Fundamentals: Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚固性基础:类型</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-fundamentals-ca824a3ac023?source=collection_archive---------3-----------------------#2020-11-26">https://medium.com/coinmonks/solidity-fundamentals-ca824a3ac023?source=collection_archive---------3-----------------------#2020-11-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><h2 id="9ea2" class="hr hs ht bd b gc hu hv hw hx hy hz ek ia translated" aria-label="kicker paragraph">以太坊智能合约开发</h2><div class=""/><div class=""><h2 id="24ce" class="pw-subtitle-paragraph iz ic ht bd b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ek translated">值类型:第一部分</h2></div><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/9f80214e8f84a8115be619cac3838d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lnKIgQ06rCBhW1DFLKWvxg.jpeg"/></div></div></figure></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="da19" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">让我们简单看一下这一部分将包括什么。我们将检查通过值传递的<strong class="km id">值类型</strong>，此外，如果值存储它自己的数据而不是指向特定内存位置的指针，它被称为值类型，也被称为原始数据类型。下面是我们将要讨论的值类型；</p><ul class=""><li id="1bc0" class="lg lh ht km b kn ko kq kr kt li kx lj lb lk lf ll lm ln lo dt translated">布尔运算</li><li id="6aed" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated">整数</li><li id="27f9" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated">地址</li><li id="c58f" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated">地址文字</li><li id="b802" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated">固定大小的字节数组</li><li id="f389" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated">动态大小的字节数组(字节，字符串)</li><li id="567d" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated">枚举</li></ul></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="85fe" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">Solidity是一种静态类型语言，这意味着每个变量都必须在编译时指定。以这种方式，类似于<strong class="km id"> Java </strong>、<strong class="km id"> C </strong>、<strong class="km id"> C++ </strong>、<strong class="km id"> Scala </strong>等。此外，类型可以在包含运算符的表达式中相互交互。接下来我们将在Solidity中有一个关于<em class="lu">操作符</em>的部分，这样事情将一部分一部分地变得清晰。</p><p id="efd8" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">与<strong class="km id"> Javascript </strong>、<strong class="km id"> C# </strong>或<strong class="km id"> Perl </strong>、<em class="lu"> null </em>或<em class="lu"> undefined </em>值不存在于<strong class="km id"> Solidity </strong>中，但是默认值取决于类型。例如，如果我们声明了一个boolean类型并且没有指定任何值，那么这个变量的默认值将是false。</p></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="4d5f" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><strong class="km id">布尔型</strong></p><p id="a54f" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">可能的值有<em class="lu">真</em>和<em class="lu">假</em>。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="lv lw l"/></div></figure><p id="3d44" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">我知道在下面的合同中有新的关键字，但请仔细阅读评论，只关注<code class="eh lx ly lz ma b">boolean</code>值类型。稍后我们将在它们自己的部分解释这些新的关键字。</p></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="6420" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><strong class="km id">整数</strong></p><p id="96dc" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">Solidity可以管理各种大小(最大为256位)的有符号/无符号整数<em class="lu">以及开发用定点数(以un <em class="lu"> fixed/fixed </em>的形式)，该语言还不完全支持，可以声明，但不能赋值给或从。</em></p><p id="09f6" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">朋友们，请注意，我们将要谈论一个非常可怕的场景，它会造成巨大的伤害。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="mb lw l"/></div></figure><p id="73e5" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">当<code class="eh lx ly lz ma b">uint</code>(无符号整数)达到其<strong class="km id">字节大小</strong>时，添加的下一个值将返回第一个变量元素。</p><blockquote class="mc md me"><p id="2301" class="kk kl lu km b kn ko jd kp kq kr jg ks mf ku kv kw mg ky kz la mh lc ld le lf hm dt translated"><strong class="km id">注</strong> : <code class="eh lx ly lz ma b">1 byte = 8 bits</code></p></blockquote><p id="ca46" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">假设我们有一个<code class="eh lx ly lz ma b">uint8</code>，也就是<code class="eh lx ly lz ma b">8</code>位。这意味着我们可以存储的最大数是等于T3的T2。看下面的例子。如果我们执行<code class="eh lx ly lz ma b">increment</code>功能会发生什么？这叫做<strong class="km id">溢出— </strong>意思是我们新的<code class="eh lx ly lz ma b">num_one</code>是0。</p><p id="c5cb" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><strong class="km id">下溢</strong>类似，如果我们从<code class="eh lx ly lz ma b">0</code>中减去<code class="eh lx ly lz ma b">1</code>，新的结果将是<code class="eh lx ly lz ma b">255</code>。我们将在后面的章节中讨论如何避免这种情况。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="lv lw l"/></div></figure></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="af51" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><strong class="km id">地址</strong></p><p id="5b0c" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">每个帐户和智能合同都有一个存储为20字节的地址。地址用于跨帐户发送和接收以太网。这可以认为是区块链上的公共身份或者账号。</p><p id="acbc" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">地址类型有两种类型，<code class="eh lx ly lz ma b">address</code>和<code class="eh lx ly lz ma b">address payable</code>—<code class="eh lx ly lz ma b">address payable</code>可以接收以太网，而<code class="eh lx ly lz ma b">address</code>不能。</p><p id="15aa" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><code class="eh lx ly lz ma b">msg.sender</code>是Solidity中的内置函数，表示当前与合同连接的地址。更其类型是<code class="eh lx ly lz ma b">address payable</code>。</p><p id="b6e9" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><code class="eh lx ly lz ma b">balance</code>返回卫中的地址余额。</p><blockquote class="mc md me"><p id="fb9c" class="kk kl lu km b kn ko jd kp kq kr jg ks mf ku kv kw mg ky kz la mh lc ld le lf hm dt translated"><strong class="km id">注:</strong> 1乙醚= 1^18魏= 10亿魏</p></blockquote><p id="a183" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><code class="eh lx ly lz ma b">transfer</code>将卫中的乙醚量转到一个应付地址。如果平衡。该函数在失败时恢复，停止当前契约，并在任何错误时抛出异常。</p><blockquote class="mc md me"><p id="d2ce" class="kk kl lu km b kn ko jd kp kq kr jg ks mf ku kv kw mg ky kz la mh lc ld le lf hm dt translated"><strong class="km id">注</strong>:在后台，<code class="eh lx ly lz ma b">transfer</code>函数在发送以太网之前，通过应用属性<code class="eh lx ly lz ma b">balance</code>查询一个地址的余额。</p></blockquote><p id="bfa9" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><code class="eh lx ly lz ma b">send</code>是<code class="eh lx ly lz ma b">transfer</code>的低级对应。如果执行失败，当前合同不会异常停止，但是<code class="eh lx ly lz ma b">send</code>会返回<code class="eh lx ly lz ma b">false</code>。</p><p id="5eec" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">还有<code class="eh lx ly lz ma b">call</code>、<code class="eh lx ly lz ma b">delegatecall</code>、<code class="eh lx ly lz ma b">staticcall</code>都是地址类型的成员。我们将在后面详细讨论这三个重要功能。</p><p id="3a02" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">从<code class="eh lx ly lz ma b">address payable</code>到<code class="eh lx ly lz ma b">address</code>的隐式转换是允许的，而从<code class="eh lx ly lz ma b">address</code>到<code class="eh lx ly lz ma b">address payable</code>的转换必须通过<code class="eh lx ly lz ma b">payable(&lt;address&gt;)</code>显式进行。</p><p id="30ed" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><strong class="km id">地址文字</strong></p><p id="6d04" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">地址文字是以太坊地址的十六进制表示，包含40个字符(20个字节)，前缀为<code class="eh lx ly lz ma b">0x</code>。</p><p id="fdfd" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">十六进制文字必须通过地址校验和测试，否则校验和测试会产生错误。</p><blockquote class="mc md me"><p id="6f27" class="kk kl lu km b kn ko jd kp kq kr jg ks mf ku kv kw mg ky kz la mh lc ld le lf hm dt translated"><strong class="km id"> <em class="ht">注</em> </strong> <em class="ht"> : </em>混合地址校验和格式在<a class="ae mi" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md" rel="noopener ugc nofollow" target="_blank"> EIP-55 </a>中定义</p></blockquote></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="0b59" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">让我们用一些例子来消化上面所有的信息。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="lv lw l"/></div></figure><p id="73ab" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">接下来，我们将继续并完成<strong class="km id">值类型</strong>。感谢阅读。</p></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="6c47" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><strong class="km id">参考文献</strong></p><div class="mj mk fm fo ml mm"><a href="https://docs.soliditylang.org/en/v0.7.5/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab ej"><div class="mo ab mp cl cj mq"><h2 class="bd id fv z el mr eo ep ms er et ic dt translated">坚固性-坚固性0.7.5文件</h2><div class="mt l"><h3 class="bd b fv z el mr eo ep ms er et ek translated">Solidity是一种面向对象的高级语言，用于实现智能合约。智能合同是程序…</h3></div><div class="mu l"><p class="bd b gc z el mr eo ep ms er et ek translated">docs.soliditylang.org</p></div></div></div></a></div><div class="mj mk fm fo ml mm"><a href="https://ethereum.stackexchange.com/questions/3542/how-are-ethereum-addresses-generated" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab ej"><div class="mo ab mp cl cj mq"><h2 class="bd id fv z el mr eo ep ms er et ic dt translated">以太坊地址是如何产生的？</h2><div class="mt l"><h3 class="bd b fv z el mr eo ep ms er et ek translated">私钥空间:这里是一些代码示例，基于以太坊使用的椭圆曲线secp256k1，正如其他人已经…</h3></div><div class="mu l"><p class="bd b gc z el mr eo ep ms er et ek translated">ethereum.stackexchange.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na kb mm"/></div></div></a></div></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><h1 id="bd09" class="nb nc ht bd nd ne nf ng nh ni nj nk nl ji nm jj nn jl no jm np jo nq jp nr ns dt translated">所有部件正常</h1><ul class=""><li id="633f" class="lg lh ht km b kn nt kq nu kt nv kx nw lb nx lf ll lm ln lo dt translated">合同的格式</li><li id="6bb5" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated"><a class="ae mi" href="https://ferdikurt.medium.com/solidity-fundamentals-ca824a3ac023" rel="noopener">值类型:第一部分</a></li><li id="d6f5" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated"><a class="ae mi" href="https://ferdikurt.medium.com/solidity-fundamentals-c94460e3be3d" rel="noopener">值类型:第二部分</a></li><li id="505a" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated"><a class="ae mi" rel="noopener" href="/coinmonks/solidity-fundamentals-1fb0e6b3b607">操作员</a></li><li id="623d" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated"><a class="ae mi" rel="noopener" href="/coinmonks/solidity-fundamentals-e4e4660e16c8">参考类型</a></li><li id="fc35" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated"><a class="ae mi" rel="noopener" href="/coinmonks/solidity-fundamentals-a71bf54c0b98">数据位置和赋值行为</a></li><li id="9410" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated"><a class="ae mi" rel="noopener" href="/coinmonks/solidity-fundamentals-1dc2af4b453b">控制结构</a></li><li id="a3fd" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated"><a class="ae mi" rel="noopener" href="/coinmonks/solidity-fundamentals-a95bb6c8ba2a">错误处理:断言、要求、恢复和异常</a></li><li id="7468" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated"><a class="ae mi" rel="noopener" href="/coinmonks/solidity-fundamentals-d2216be1c2c3">功能:第一部分</a></li><li id="67cf" class="lg lh ht km b kn lp kq lq kt lr kx ls lb lt lf ll lm ln lo dt translated"><a class="ae mi" href="https://ferdikurt.medium.com/solidity-fundamentals-functions-a7e3d38c1fe5" rel="noopener">功能:第二部分</a></li></ul></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="6e25" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">随便问任何问题。</p><p id="95d1" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated">注意安全，做好工作，保持联系！</p><p id="137c" class="pw-post-body-paragraph kk kl ht km b kn ko jd kp kq kr jg ks kt ku kv kw kx ky kz la lb lc ld le lf hm dt translated"><a class="ae mi" href="https://www.linkedin.com/in/ferdi-kurt-8b910b164/" rel="noopener ugc nofollow" target="_blank">费尔迪科特</a></p></div></div>    
</body>
</html>