<html>
<head>
<title>Writing Ethereum Transactions to SQL Database Using Nethereum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nethereum将以太坊事务写入SQL数据库</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/writing-ethereum-transactions-to-sql-database-using-nethereum-fd94e0e4fa36?source=collection_archive---------2-----------------------#2018-06-01">https://medium.com/coinmonks/writing-ethereum-transactions-to-sql-database-using-nethereum-fd94e0e4fa36?source=collection_archive---------2-----------------------#2018-06-01</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="fb0e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以太坊是一个在区块链网络上创建和运行去中心化应用的简单平台。当你运行一个基于以太坊的应用程序时，你会纠结于作为区块链信息主要来源的事务。</p><p id="598b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用Web3和Nethereum很容易从以太坊获取交易信息。Web3是一个库的集合，它允许你通过HTTP或IPC与以太网进行交互。尼瑟姆是开源的。以太坊. Net集成库。你可以找到以太坊需要的所有方法。</p><figure class="jo jp jq jr fq js fe ff paragraph-image"><div class="ab fr cl jt"><img src="../Images/2dedffca1d1a5e9d747a202af81e0ff4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hH66P6auPXyVNP3d244YDA.png"/></div></figure><p id="9e1e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是当涉及到获取属于自定义地址的所有事务时，就不容易处理了。第一个解决方案是使用以太坊库，遍历所有块，过滤你需要的事务。但正如你可能猜到的，这可能是一个漫长而复杂的过程。其次；您可以找到一个合适的API来获取您需要的旧事务。但是这些API可以是付费服务，或者可以具有有限的访问权限。最终的解决方案是将以太坊数据存储在SQL上。</p><p id="b1d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本文中，我将尝试解释如何从区块链获取块和事务细节，以及如何从事务日志中获取令牌传输细节并将它们存储到SQL中。你可以从<a class="ae jw" href="https://github.com/mrceylan/Nethereum.BlockchainStorage" rel="noopener ugc nofollow" target="_blank"> GitHub </a>找到项目解决方案。这个项目存储关于网络的三个主要信息；块、交易和令牌传输。如果你需要更多，你可以改善这个项目，或者你可以通过GitHub创建问题。</p><figure class="jo jp jq jr fq js fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff jx"><img src="../Images/63f085cacec53ba18f584bf058aab453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LJSDr2CSG-vC4OkB."/></div></div></figure><p id="550c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">存储处理器负责通过块进行迭代，并将这些信息发送给处理器来处理所需的信息。首先收集的信息是块信息。Project通过Nethereum从网络获取块详细信息，并将其写入SQL上的NodeBlock表。该表包含诸如块散列、块编号、块时间等信息。当您反复运行应用程序时，它从表中获取最后处理的块的编号，并从这个块编号开始。</p><pre class="jo jp jq jr fq kc kd ke kf aw kg dt"><span id="1d7f" class="kh ki ht kd b fv kj kk l kl km">var blocks = repositoryBase.GetRepository&lt;NodeBlock&gt;().GetAll();<br/> int startBlock = 5623328;<br/> if (blocks.Count() &gt; 0)<br/>   startBlock = blocks.Max(x =&gt; x.BlockNumber);<br/> var latestblock = await web3.Eth.Blocks.GetBlockNumber.SendRequestAsync();<br/> new Helpers().AddLog(LogType.Info, $"Last Block in DB : {startBlock} , Last Block in Network : {latestblock.Value}");<br/> var endBlock = (int)latestblock.Value;<br/><br/> while (startBlock &lt;= endBlock)<br/> {<br/>   try<br/>   {<br/>     new Helpers().AddLog(LogType.Process, $"Block-{startBlock} Processing");<br/>     var block = await blockProcessor.ProcessBlockAsync(startBlock);<br/>     new Helpers().AddLog(LogType.Success, $"Block-{startBlock} Processed");<br/><br/>     new Helpers().AddLog(LogType.Info, $"Block-{startBlock} Transactions Processing, Tx Count : {block.TransactionHashes.Length} ..");<br/>     await transactionsProcessor.ProcessTransactionAsync(block);<br/>     new Helpers().AddLog(LogType.Success, $"Block-{startBlock} Transactions Processed");<br/>   }<br/>   catch (Exception e)<br/>   {<br/>	 }<br/>   startBlock++;<br/> }</span></pre><p id="1642" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">块处理器从存储处理器获取块信息，并将它们转换为节点块实体。</p><pre class="jo jp jq jr fq kc kd ke kf aw kg dt"><span id="ba8b" class="kh ki ht kd b fv kj kk l kl km">var _nodeBlock = new NodeBlock()<br/>{<br/>    BlockNumber = (int)block.Number.Value,<br/>    BlockTime = new Helpers().UnixTimeStampToDateTime((double)block.Timestamp.Value),<br/>    BlockHash = block.BlockHash,<br/>    ParentHash = block.ParentHash,<br/>    TransactionCount = block.TransactionHashes.Length,<br/>    Nonce = block.Nonce,<br/>};</span><span id="7362" class="kh ki ht kd b fv kn kk l kl km">blockRepository.Add(_nodeBlock);</span></pre><p id="a1da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">数据块处理后，存储处理器将数据块事务发送到事务处理器，并将其写入数据库。</p><pre class="jo jp jq jr fq kc kd ke kf aw kg dt"><span id="6fb8" class="kh ki ht kd b fv kj kk l kl km">var transaction = new NodeTransaction();<br/>try<br/>{</span><span id="b174" class="kh ki ht kd b fv kn kk l kl km">transaction = new NodeTransaction<br/>  {<br/>    NodeTokenTransfers = new List&lt;NodeTokenTransfer&gt;(),<br/>    From = transactionSource.From,<br/>    To = transactionSource.To,<br/>    Status = (OpsICO.Core.Enums.TransactionStatus)((int)transactionReceipt.Status.Value),<br/>    TxHash = transactionSource.TransactionHash,<br/>    Value = new UnitConversion().FromWei(transactionSource.Value.Value)<br/>};</span></pre><p id="c247" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了从交易细节中获得令牌转移，它在交易日志中搜索“转移事件”。我们应该使用使用sha3散列算法的“转移”事件的签名。</p><pre class="jo jp jq jr fq kc kd ke kf aw kg dt"><span id="95db" class="kh ki ht kd b fv kj kk l kl km">"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"</span></pre><p id="c2ee" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">获得令牌传输日志详细信息后，它将日志详细信息转换为令牌传输类型并存储到数据库中。</p><pre class="jo jp jq jr fq kc kd ke kf aw kg dt"><span id="7942" class="kh ki ht kd b fv kj kk l kl km">transaction.NodeTokenTransfers.Add(new NodeTokenTransfer()<br/>{<br/>  Amount = new Helpers().HextoString(_log.data),<br/>  From = new AddressType().Decode&lt;string&gt;(_log.topics[1]),<br/>  To = new AddressType().Decode&lt;string&gt;(_log.topics[2]),<br/>  TokenContractAddress = transactionSource.To<br/>});</span></pre><p id="f906" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">完成所有这些工作后，您现在可以轻松地从您自己的区块链存储中过滤和选择所有交易数据。等待你的反馈和掌声！</p><div class="ko kp fm fo kq kr"><a href="https://github.com/mrceylan/Nethereum.BlockchainStorage" rel="noopener  ugc nofollow" target="_blank"><div class="ks ab ej"><div class="kt ab ku cl cj kv"><h2 class="bd hu fv z el kw eo ep kx er et hs dt translated">西兰先生/尼瑟姆。区块链存储</h2><div class="ky l"><h3 class="bd b fv z el kw eo ep kx er et ek translated">尼瑟姆。这个库用于处理以太坊区块链在SQL表中的存储</h3></div><div class="kz l"><p class="bd b gc z el kw eo ep kx er et ek translated">github.com</p></div></div><div class="la l"><div class="lb l lc ld le la lf ju kr"/></div></div></a></div></div></div>    
</body>
</html>