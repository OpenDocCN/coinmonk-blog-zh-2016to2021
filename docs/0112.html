<html>
<head>
<title>Data structure in Ethereum | Episode 3: Patricia trie.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊中的数据结构|第3集:Patricia trie。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/data-structure-in-ethereum-episode-3-patricia-trie-b7b0ccddd32f?source=collection_archive---------0-----------------------#2018-02-22">https://medium.com/coinmonks/data-structure-in-ethereum-episode-3-patricia-trie-b7b0ccddd32f?source=collection_archive---------0-----------------------#2018-02-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/fc35c38c4302572f0e64075633fd31c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUYKbKBioMe0N8T42CIZTg.png"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Image source: <a class="ae ig" href="https://www.reddit.com/r/ethereum/comments/67sds9/ethereum_background_wallpaper_image_in_hd/" rel="noopener ugc nofollow" target="_blank"><strong class="bd ih">/r/ethereum</strong></a> by <a class="ae ig" href="https://www.reddit.com/user/BitcoinIsTehFuture" rel="noopener ugc nofollow" target="_blank"><strong class="bd ih">BitcoinIsTehFuture</strong></a></figcaption></figure><div class=""/><p id="45d6" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">Patricia trie是以太坊中用来存储数据的主要trie。它是由<a class="ae ig" rel="noopener" href="/@phansnt/data-structure-in-ethereum-episode-2-radix-trie-and-merkle-trie-d941d0bfd69a"> Radix trie和Merkle trie </a>混合而成。</p><blockquote class="kf kg kh"><p id="14b5" class="jh ji ki jj b jk jl jm jn jo jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd ke hm dt translated">为了使它容易理解，我将首先带我们去一个低效的帕特丽夏·特里，然后去“改进的”帕特丽夏·特里，最后是“真正的”帕特丽夏·特里。这种方法有助于我们了解某些结构产生的原因。</p><p id="8af5" class="jh ji ki jj b jk jl jm jn jo jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd ke hm dt translated">这意味着关于动机和直觉<em class="ik">🏃。</em></p></blockquote><blockquote class="km"><p id="55b5" class="kn ko ik bd kp kq kr ks kt ku kv ke ek translated"><a class="ae ig" href="https://coincodecap.com/category/blockchain-node-and-api" rel="noopener ugc nofollow" target="_blank">发现并评估最佳区块链api和节点产品</a></p></blockquote><p id="9359" class="pw-post-body-paragraph jh ji ik jj b jk kw jm jn jo kx jq jr js ky ju jv jw kz jy jz ka la kc kd ke hm dt translated"><strong class="jj il"> <em class="ki">数据集</em> </strong></p><figure class="lb lc ld le fq hv"><div class="bz el l di"><div class="lf lg l"/></div></figure></div><div class="ab cl lh li hb lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hm hn ho hp hq"><p id="3e71" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il"> <em class="ki">术语</em> </strong></p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lo"><img src="../Images/a6aad55a095d3dcb701ce2589e8acc6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-MV3jf9kIvIJuzP-rv_aQ.png"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">A node.</figcaption></figure><p id="088a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">以太坊中的节点存储为键值，键值是节点的散列。值是一个包含17个元素的数组。在17个元素中，前16个元素由从<code class="eh lp lq lr ls b">0</code>到<code class="eh lp lq lr ls b">f</code>的十六进制数索引，最后一个是该节点包含的数据。</p><blockquote class="kf kg kh"><p id="d003" class="jh ji ki jj b jk jl jm jn jo jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd ke hm dt translated">键与路径</p></blockquote><p id="8ffe" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">请注意，<code class="eh lp lq lr ls b">key</code>用于“数据库查找”(意为通过数据库机制找到一个节点)，而<code class="eh lp lq lr ls b">path</code>用于“trie查找”(意为通过路径降序查找数据，如<a class="ae ig" rel="noopener" href="/@phansnt/data-structure-in-ethereum-episode-2-radix-trie-and-merkle-trie-d941d0bfd69a"> Radix trie </a>)。</p><blockquote class="kf kg kh"><p id="1787" class="jh ji ki jj b jk jl jm jn jo jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd ke hm dt translated">如果仍然不明确，下面的例子会更简单。</p></blockquote></div><div class="ab cl lh li hb lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hm hn ho hp hq"><p id="bebf" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il"> <em class="ki">效率低下的帕特丽夏·特里</em> </strong></p><p id="af26" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">我们构建一个trie来表示我们的数据集。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lt"><img src="../Images/36e18a093a87cf5fa896ddda5443befd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Qoib0Ap4LJsBEBtcGB95w.png"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Building trie by dataset.</figcaption></figure><p id="d057" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">为了再次测试，让我们尝试一步一步地搜索<code class="eh lp lq lr ls b">395</code>路径的值。</p><blockquote class="kf kg kh"><p id="d513" class="jh ji ki jj b jk jl jm jn jo jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd ke hm dt translated">符号:“这是数据库查找”——<strong class="jj il">tdl</strong>，“这是trie查找”——<strong class="jj il">TTL</strong>；</p></blockquote><ol class=""><li id="e80a" class="lu lv ik jj b jk jl jo jp js lw jw lx ka ly ke lz ma mb mc dt translated">我们将<code class="eh lp lq lr ls b">395</code>下降到3个部分<code class="eh lp lq lr ls b">3</code>、<code class="eh lp lq lr ls b">9</code>、<code class="eh lp lq lr ls b">5</code>，依次使用。</li><li id="e2bb" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">从<code class="eh lp lq lr ls b">rootHash</code>开始，我们要找到与<code class="eh lp lq lr ls b">rootHash</code>对应的<code class="eh lp lq lr ls b">rootNode</code>(<strong class="jj il">tdl</strong>)。</li><li id="403c" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">路径的第一部分是<code class="eh lp lq lr ls b">3</code>，所以我们得到由<code class="eh lp lq lr ls b">rootNode</code>的<code class="eh lp lq lr ls b">3</code>索引的元素，那就是<code class="eh lp lq lr ls b">hashA</code> ( <strong class="jj il"> ttl </strong>)。</li><li id="f916" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">查找<code class="eh lp lq lr ls b">hashA</code> ( <strong class="jj il"> tdl </strong>)，获取由<code class="eh lp lq lr ls b">9</code> ( <strong class="jj il"> ttl </strong>)索引的元素，元素的值为<code class="eh lp lq lr ls b">hashC</code>。</li><li id="d5a6" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">寻找<code class="eh lp lq lr ls b">hashC</code> ( <strong class="jj il"> tdl </strong>)，获取由<code class="eh lp lq lr ls b">5</code> ( <strong class="jj il"> ttl </strong>)索引的元素，元素的值为<code class="eh lp lq lr ls b">hashD</code>。</li><li id="78e5" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">此时，我们沿着整个路径向下，这样我们将获得与<code class="eh lp lq lr ls b">hashD</code> ( <strong class="jj il"> ttl </strong>)对应的节点的数据元素(最后一个元素)中包含的值，结果是<code class="eh lp lq lr ls b">duck</code>。</li></ol><p id="1b61" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">您可以看到，我们使用path来查找值(Radix trie的一个属性),如果trie中的一个值被更改，它将导致trie的<code class="eh lp lq lr ls b">rootHash</code>被更改(Merkle trie的一个属性)。</p><p id="d866" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">此外，trie的数据元素中有太多的空值节点，我们必须改进它以提高效率。</p></div><div class="ab cl lh li hb lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hm hn ho hp hq"><p id="9c5b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il"> <em class="ki">【改良版】帕特丽夏·特里</em> </strong></p><blockquote class="kf kg kh"><p id="5a01" class="jh ji ki jj b jk jl jm jn jo jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd ke hm dt translated">我们如何改进它？最好的答案在以太坊维基里，我不会解释的更好，下面就引用一下<em class="ik">💅💅💅。</em></p></blockquote><p id="3cfc" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><a class="ae ig" href="https://github.com/ethereum/wiki/wiki/Patricia-Tree#optimization" rel="noopener ugc nofollow" target="_blank">圣答</a>。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/ebf739b95badbcce9a387446174ead30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*dzng7I9WnbHyAYyKc2-CPw.jpeg"/></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Finally, chose one 💆💆💆.</figcaption></figure><p id="ecbe" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">在<a class="ae ig" rel="noopener" href="/@phansnt/data-structure-in-ethereum-episode-1-compact-hex-prefix-encoding-12558ae02791">第一集+ </a>中我已经提到过<code class="eh lp lq lr ls b">leaf</code>节点和<code class="eh lp lq lr ls b">extension</code>节点，但是我们不知道它们是什么。我们遇到了一些使我们的树退化的情况，那些是没有分支的长路径(没有分叉的路径)。</p><p id="22aa" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">比如:<code class="eh lp lq lr ls b">56f0</code>，要获取<code class="eh lp lq lr ls b">horse</code>值，需要下行太多空值节点。</p><p id="093f" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">但是，这导致了两个子问题。</p><ol class=""><li id="af4c" class="lu lv ik jj b jk jl jo jp js lw jw lx ka ly ke lz ma mb mc dt translated">没有分叉的路径指向数据的末端。比如:<code class="eh lp lq lr ls b">56f0</code>。</li><li id="6959" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">中间没有分叉的路径。比如:<code class="eh lp lq lr ls b">{cabe, cab8}</code>的<code class="eh lp lq lr ls b">cab</code>。</li></ol><p id="f2eb" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">为了解决第一个问题，他们引入了<code class="eh lp lq lr ls b">leaf</code>节点，为了解决第二个问题，他们引入了<code class="eh lp lq lr ls b">extension</code>节点。它们是具有2个元素的数组形式的节点，第一个元素是<code class="eh lp lq lr ls b">partialPath</code>，帮助减少空值节点，第二个元素包含值，如果是<code class="eh lp lq lr ls b">leaf</code>则为<code class="eh lp lq lr ls b">data</code>，如果是<code class="eh lp lq lr ls b">extension</code>则为<code class="eh lp lq lr ls b">merkleHash</code>。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lt"><img src="../Images/a51026a8f3c7d2b917c97b7c4171b77a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kskPFQhhUAarGNoJa6lbnQ.png"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Using leaf node.</figcaption></figure><p id="19e5" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><code class="eh lp lq lr ls b">hashE</code>现在变成了一个<code class="eh lp lq lr ls b">leaf</code>节点，要得到<code class="eh lp lq lr ls b">56f0</code>路径的值我们可以这样做:</p><ol class=""><li id="5bb4" class="lu lv ik jj b jk jl jo jp js lw jw lx ka ly ke lz ma mb mc dt translated">获取索引为<code class="eh lp lq lr ls b">5</code>的元素<code class="eh lp lq lr ls b">rootHash</code>，值为<code class="eh lp lq lr ls b">hashE</code>。</li><li id="bc93" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">因为<code class="eh lp lq lr ls b">hashE</code>可能是一个<code class="eh lp lq lr ls b">leaf</code>或<code class="eh lp lq lr ls b">extension</code>节点，我们必须将路径的剩余部分(remainder)与<code class="eh lp lq lr ls b">hashE</code>的<code class="eh lp lq lr ls b">partialPath</code>进行比较。余数是<code class="eh lp lq lr ls b">6f0</code>，<code class="eh lp lq lr ls b">partialPath</code>是<code class="eh lp lq lr ls b">6f0</code>(二者相同)，所以这个节点是<code class="eh lp lq lr ls b">leaf</code>节点。我们返回<code class="eh lp lq lr ls b">data</code>字段，结果是<code class="eh lp lq lr ls b">horse</code>。</li></ol><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lt"><img src="../Images/87a97e0084134204c5f54fd44d4b4b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8g1I5iaOZWG9K5Ys8cyNDg.png"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Using leaf node and extension node.</figcaption></figure><p id="bfbd" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><code class="eh lp lq lr ls b">hashB</code>现在变成了<code class="eh lp lq lr ls b">extension</code>节点。例如，获取<code class="eh lp lq lr ls b">cab8</code>路径的<code class="eh lp lq lr ls b">data</code>:</p><ol class=""><li id="8959" class="lu lv ik jj b jk jl jo jp js lw jw lx ka ly ke lz ma mb mc dt translated">获取由<code class="eh lp lq lr ls b">rootHash</code>的<code class="eh lp lq lr ls b">c</code>索引的元素，值为<code class="eh lp lq lr ls b">hashB</code>。</li><li id="f1bb" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">我们可以看到<code class="eh lp lq lr ls b">hashB</code>是一个有2个值的数组，所以我们不断比较余数和<code class="eh lp lq lr ls b">partialPath</code>来知道哪个是节点。余数为<code class="eh lp lq lr ls b">ab8</code>且<code class="eh lp lq lr ls b">partialPath</code>为<code class="eh lp lq lr ls b">ab</code>，表示节点为<code class="eh lp lq lr ls b">extension</code>节点。我们从路径的当前剩余部分移除<code class="eh lp lq lr ls b">partialPath</code>，我们得到路径的新剩余部分是<code class="eh lp lq lr ls b">8</code>，下一个散列是<code class="eh lp lq lr ls b">hashJ</code>。</li><li id="6a6f" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">找到<code class="eh lp lq lr ls b">hashJ</code>对应的节点，获取<code class="eh lp lq lr ls b">8</code>索引的元素，值为<code class="eh lp lq lr ls b">hashK</code>。余数现在是空的。</li><li id="228c" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">寻找<code class="eh lp lq lr ls b">hashK</code>并且我们收到一个空的节点<code class="eh lp lq lr ls b">partialPath</code>(叶节点，因为余数等于<code class="eh lp lq lr ls b">partialPath</code>)，返回<code class="eh lp lq lr ls b">dog</code>。</li></ol><p id="e65f" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">另外，我们可以看到<code class="eh lp lq lr ls b">hashD</code>、<code class="eh lp lq lr ls b">hashK</code>和<code class="eh lp lq lr ls b">hashL</code>也是<code class="eh lp lq lr ls b">leaf</code>节点。实际上，我们的trie仍然没有完全优化。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lt"><img src="../Images/bfb932dc2f486645bbbaacd4d5405342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FIDqoxjONF9VzZ6rcFOurQ.png"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Optimized trie.</figcaption></figure><p id="35cf" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">现在，这个trie似乎被<code class="eh lp lq lr ls b">leaf</code>节点和<code class="eh lp lq lr ls b">extension</code>节点充分优化了。</p><blockquote class="kf kg kh"><p id="3c40" class="jh ji ki jj b jk jl jm jn jo jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd ke hm dt translated">以上两个例子有助于我们理解为什么以及如何建立和改进帕特里夏特里。现在我们将完成它，并得到以太坊使用的最终帕特里夏特里。<em class="ik">🚀🚀🚀</em></p></blockquote><p id="d2ab" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il"> <em class="ki">帕特丽夏·特里</em> </strong></p><p id="e491" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">一些附加规则:</p><ol class=""><li id="f513" class="lu lv ik jj b jk jl jo jp js lw jw lx ka ly ke lz ma mb mc dt translated">每一次<code class="eh lp lq lr ls b">partialPath</code>出手前都会被<a class="ae ig" rel="noopener" href="/@phansnt/data-structure-in-ethereum-episode-1-compact-hex-prefix-encoding-12558ae02791"> HP编码</a>。</li><li id="5237" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">节点中的每个元素都将被<a class="ae ig" rel="noopener" href="/@phansnt/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919"> RLP编码</a>。</li><li id="09f9" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">值(节点)将在存储下来之前进行RLP编码。</li></ol><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mj"><img src="../Images/f709de4573000f1121e6e0b8a3de86eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQ3O6h0fOIfWbdPYC1qYvg.png"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Patricia trie.</figcaption></figure></div><div class="ab cl lh li hb lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hm hn ho hp hq"><p id="a7f4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il"> <em class="ki">以太坊数据结构</em> </strong></p><p id="f810" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">在以太坊中，Patricia trie用于4 trie:</p><ol class=""><li id="f37f" class="lu lv ik jj b jk jl jo jp js lw jw lx ka ly ke lz ma mb mc dt translated">stateRoot</li><li id="0c86" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">storageRoot</li><li id="25bc" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">transactionRoot</li><li id="81a0" class="lu lv ik jj b jk md jo me js mf jw mg ka mh ke lz ma mb mc dt translated">收据根</li></ol><p id="fe04" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">其中，<code class="eh lp lq lr ls b">stateRoot</code>、<code class="eh lp lq lr ls b">transactionRoot</code>和<code class="eh lp lq lr ls b">receiptRoot</code>包含在块头中。特别地，<code class="eh lp lq lr ls b">storageRoot</code>是子trie并且包含在状态trie的数据中。</p><p id="a9e0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">下面的链接是对它们的完美解释。</p><div class="hs ht fm fo hu mk"><a href="https://github.com/ethereum/wiki/wiki/Patricia-Tree#tries-in-ethereum" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd il fv z el mp eo ep mq er et ij dt translated">以太坊/维基</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">维基-以太坊维基-</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">github.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my ia mk"/></div></div></a></div></div><div class="ab cl lh li hb lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hm hn ho hp hq"><p id="70d4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il"> <em class="ki">结论</em> </strong></p><p id="c482" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">我从第1集到第3集展示的一切都是一些理论上的东西，似乎不足以理解Patricia trie在实践中是如何工作的。在下一集，我们将做一个连接数据库的例子，并展示trie是如何组织的。那真的很酷。</p><blockquote class="kf kg kh"><p id="404e" class="jh ji ki jj b jk jl jm jn jo jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd ke hm dt translated">你需要先了解一些关于geth、web3和levelDB的知识，以便在阅读第四集时更加流畅。</p></blockquote><blockquote class="km"><p id="e9eb" class="kn ko ik bd kp kq kr ks kt ku kv ke ek translated"><a class="ae ig" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="na nb nc nd ne hv fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mz"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><p id="6763" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jj il"> <em class="ki">参考文献</em> </strong></p><p id="f1f0" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">来自维基以太坊的文档:</p><div class="hs ht fm fo hu mk"><a href="https://github.com/ethereum/wiki/wiki/Patricia-Tree#optimization" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd il fv z el mp eo ep mq er et ij dt translated">以太坊/维基</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">维基-以太坊维基-</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">github.com</p></div></div><div class="mt l"><div class="nf l mv mw mx mt my ia mk"/></div></div></a></div></div></div>    
</body>
</html>