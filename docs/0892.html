<html>
<head>
<title>Neural Networks for beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者的神经网络</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/neural-networks-for-beginners-bd2beb748ca?source=collection_archive---------6-----------------------#2018-06-28">https://medium.com/coinmonks/neural-networks-for-beginners-bd2beb748ca?source=collection_archive---------6-----------------------#2018-06-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="d431" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好吧，如果你已经开始机器学习，你应该听说过神经网络！那么什么是神经网络呢？基本上，它只是目前机器学习中最有效和最流行的算法之一。它的结构就像我们大脑中的神经元一样！有趣吧？</p><p id="ae63" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以，我们写一个短代码来预测一个人会不会献血。这段代码使用了Tensorflow(谷歌的一个机器学习和深度学习的库)。我强烈建议您使用在其中使用张量流估计器的代码，除非您使用keras和sci-kit learn的内置模型。这是因为这样可以节省大量时间，而且有预先写好的代码。在神经网络中编写正向传播和反向传播算法变得非常忙乱！所以继续使用这些代码。好了，够了！开始吧！</p><p id="bddb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以让我们从导入一些库开始。Numpy用于数值计算，pd用于处理数据集！</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="5b75" class="jx jy ht jt b fv jz ka l kb kc"><strong class="jt hu">import</strong> <strong class="jt hu">tensorflow</strong> <strong class="jt hu">as</strong> <strong class="jt hu">tf</strong> <br/><strong class="jt hu">import</strong> <strong class="jt hu">pandas</strong> <strong class="jt hu">as</strong> <strong class="jt hu">pd</strong> <br/><strong class="jt hu">import</strong> <strong class="jt hu">numpy</strong> <strong class="jt hu">as</strong> <strong class="jt hu">np<br/></strong></span></pre><p id="03e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">那么，现在让我们定义我们的参数。training_size比例是拆分训练和测试数据(记住！从不在相同的训练和测试数据上训练)。然后我们洗牌，因为如果我们不这样做，模型就有可能对所有倾向于献血的人进行训练，所以它永远不会知道那些永远不会献血的人。只需将准确度分数重置为0，以确保没有垃圾值。隐藏单元表示有3个隐藏层，分别有10、20、10个节点。Steps_spec给出了训练模型的步骤数。将tmp_dir_spec配置到您想要保存模型的所有检查点的目录。确保数据在您的文件夹中。ipynb文件是。你可以从下面的我的GitHub下载笔记本和数据集。根据您的需要配置输入和输出功能。https://github.com/kaiwalya4850/Transfusio</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="71d4" class="jx jy ht jt b fv jz ka l kb kc">training_set_size_portion = 0.8 <br/>do_shuffle = <strong class="jt hu">True</strong> <br/>accuracy_score = 0 <br/>hidden_units_spec = [10,20,10] <br/>n_classes_spec = 2 <br/>steps_spec = 200000 <br/>epochs_spec = 15 <br/>tmp_dir_spec = “C:/Users/XYZ/Desktop/ML/Sourcecodes/NN/ckpt_tranfusion” <br/>file_name = “transfusion.csv” <br/>features = [‘recency’,’tinv’,’monetary’,’t’] <br/><em class="ke"># Here’s the label that we want to predict — it’s also a column in # the CSV</em> labels = [‘op’]</span></pre><p id="705a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好了，现在让我们来玩数据集吧！使用下面的代码，您应该能够可视化您的数据。尝试类似my_data.head(10)的方法来获取前10列。我们将数据集的名称保留为my_data，而不是transfusion。</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="78ed" class="jx jy ht jt b fv jz ka l kb kc">my_data = pd.read_csv("transfusion.csv",dtype=float) <br/>my_data.head()</span></pre><p id="bae1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，让我们只是随机数据，以避免任何问题，在去皮重！</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="3a2e" class="jx jy ht jt b fv jz ka l kb kc"><strong class="jt hu">if</strong> do_shuffle:<br/> randomized_data = my_data.reindex(np.random.permutation(my_data.index))<br/><strong class="jt hu">else</strong>:<br/> randomized_data = my_data</span></pre><p id="501e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您可以通过编写my_data.head()来再次可视化您的数据，以确保一切都是正确随机化的！</p><p id="63ef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们将训练和测试数据分离出来，以便进一步计算。并且为训练特征和标签而构建。</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="d2b3" class="jx jy ht jt b fv jz ka l kb kc">total_records = len(randomized_data) <br/>training_set_size = int(total_records * training_set_size_portion) test_set_size = total_records = training_set_size</span><span id="35db" class="jx jy ht jt b fv kf ka l kb kc"><em class="ke"># Build the training features and labels</em></span><span id="1c12" class="jx jy ht jt b fv kf ka l kb kc">training_features = randomized_data.head(training_set_size[features].copy()<br/>training_labels = randomized_data.head(training_set_size[labels].copy()<br/>print(training_features.head())<br/>print(training_labels.head())</span></pre><p id="eab4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们做同样的测试。如果出现“缩进”错误，只需清除空格。他们会被解决的！</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="db00" class="jx jy ht jt b fv jz ka l kb kc"><em class="ke">#Build the testing features and labels</em><br/>testing_features = randomized_data.tail(test_set_size)[features].copy()<br/>testing_labels = randomized_data.tail(test_set_size)[labels].copy()</span></pre><p id="5137" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为功能栏编写:</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="6453" class="jx jy ht jt b fv jz ka l kb kc">feature_columns = [tf.feature_column.numeric_column(key) <strong class="jt hu">for</strong> key <strong class="jt hu">in</strong> features]</span></pre><p id="052d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，来看主要的东西，tf.estimator。这是原因，也是代码的一部分，它为我们做一切事情，就像神经网络中的反向传播算法。DNNClassifier用于神经网络，你会发现线性回归和逻辑回归的LinearRegressor。我将把我的GitHub链接放在这篇文章的末尾，在那里我使用不同的tf估算器进行了训练。</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="1ab6" class="jx jy ht jt b fv jz ka l kb kc">classifier = tf.estimator.DNNClassifier(<br/>    feature_columns=feature_columns, <br/>    hidden_units=hidden_units_spec, <br/>    n_classes=n_classes_spec,<br/>    model_dir=tmp_dir_spec)</span></pre><p id="9f15" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">定义训练输入函数，这将被其他函数调用以开始训练。</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="1586" class="jx jy ht jt b fv jz ka l kb kc">train_input_fn = tf.estimator.inputs.pandas_input_fn(x=training_features,<br/>                                    y=training_labels,<br/>                                    num_epochs=epochs_spec,<br/>                                    shuffle=<strong class="jt hu">True</strong>)</span></pre><p id="f8ab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在开始实际训练。它没有完成我之前在电脑中定义的所有步骤，所以尝试运行多次，这样你会损失更少。</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="256f" class="jx jy ht jt b fv jz ka l kb kc"><em class="ke"># Train the model using the classifer.</em> classifier.train(input_fn=train_input_fn, steps=steps_spec)</span></pre><p id="d6c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好吧！训练到此结束。现在是时候用之前定义的测试数据来测试和评估模型了。</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="fefb" class="jx jy ht jt b fv jz ka l kb kc"><em class="ke"># Define the test input function</em><br/>test_input_fn = tf.estimator.inputs.pandas_input_fn(<br/>                    x=testing_features, <br/>                    y=testing_labels, <br/>                    num_epochs=epochs_spec, <br/>                    shuffle=<strong class="jt hu">False</strong>)</span></pre><p id="61b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">混淆矩阵中的值对于查看您的模型有多好非常方便和有用。下面的代码是混乱矩阵。这将打印AUC(曲线下面积)、精度、召回、损失、训练准确度、测试准确度。</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="5882" class="jx jy ht jt b fv jz ka l kb kc"><em class="ke"># Evaluate accuracy.</em><br/>accuracy_score = classifier.evaluate(input_fn=test_input_fn)["accuracy"]<br/>print("Accuracy = <strong class="jt hu">{}</strong>".format(accuracy_score))</span></pre><p id="987c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，让我们创建预测集。仔细看看，我是如何编写输入特性和输出特性的。相应地改变。</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="8101" class="jx jy ht jt b fv jz ka l kb kc"><em class="ke"># Create a prediction set -- this is a list of input features that you want to classify</em><br/>prediction_set = pd.DataFrame({'recency':[2, 1], 'monetary':[4,3],'tinv':[3,2],'t':[5,4],'op':[4,5]})</span></pre><p id="7262" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，让我们预测输入函数。</p><pre class="jo jp jq jr fq js jt ju jv aw jw dt"><span id="1b2a" class="jx jy ht jt b fv jz ka l kb kc">predict_input_fn = tf.estimator.inputs.pandas_input_fn(<br/>                      x=prediction_set, <br/>                      num_epochs=1, <br/>                      shuffle=<strong class="jt hu">False</strong>)</span></pre><p id="6be4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在让我们得到一个预测函数的列表。当您想要在android或任何其他平台上实际服务您的模型时，这些步骤变得非常重要。因为要把它们转换成。tflite格式，你需要。这些代码行可以生成pbtxt文件。</p><p id="846d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好吧！就是这样！这是你的第一个神经网络！改变数据集，调整参数，享受！如果你想要更多的带有tf估算器的代码或者从头开始，GitHub链接在下面。我会确保用不同的算法更新所有的模型。<a class="ae kd" href="https://github.com/kaiwalya4850" rel="noopener ugc nofollow" target="_blank">https://github.com/kaiwalya4850</a>。</p><p id="fc2b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">感谢阅读！</p></div></div>    
</body>
</html>