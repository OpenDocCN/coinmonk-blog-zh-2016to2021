<html>
<head>
<title>Smart Contract Exploits Part 3 — Featuring Capture the Ether (Accounts)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合同利用第3部分—以捕获以太(客户)为特色</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/smart-contract-exploits-part-3-featuring-capture-the-ether-accounts-c86d7e9a1400?source=collection_archive---------3-----------------------#2018-09-23">https://medium.com/coinmonks/smart-contract-exploits-part-3-featuring-capture-the-ether-accounts-c86d7e9a1400?source=collection_archive---------3-----------------------#2018-09-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="e142" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们已经到了第3部分！帐户和杂项挑战最初都写在第3部分中；然而，看起来确实很长，我正在处理的文档超过了20页，因此将有第4部分作为杂项挑战部分。帐户部分集中在围绕以太坊地址的挑战和椭圆曲线加密的区块链使用。</p><p id="640d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于错过第一部分的人:<a class="ae jo" rel="noopener" href="/@Enigmatic1256/smart-contract-exploits-part-1-featuring-capture-the-ether-lotteries-8a061ad491b?source=your_stories_page---------------------------">https://medium . com/@ enigmatic 1256/smart-contract-exploits-part-1-featured-capture-the-ether-lotteries-8a 061 ad 491 b</a></p><p id="a600" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">而第二部分在这里找到:<a class="ae jo" rel="noopener" href="/@Enigmatic1256/smart-contract-exploits-part-2-featuring-capture-the-ether-math-31a289da0427">https://medium . com/@ enigmatic 1256/smart-contract-exploits-part-2-featured-capture-the-ether-math-31a 289 da 0427</a></p><p id="da02" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">可以找到这些挑战的网站:<a class="ae jo" href="https://capturetheether.com/challenges/" rel="noopener ugc nofollow" target="_blank">https://capturetheether.com/challenges/</a><br/>这些挑战的作者是非常聪明的smarx，抓住他的推特账号@smarx。</p><p id="9228" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">和以前一样，这篇文章需要一些关于Solidity及其相关开发工具的知识。</p><p id="f622" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">事不宜迟——前方有巨大的剧透！</p><h1 id="3ee7" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">13.模糊同一性</h1><p id="5399" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="ecc9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这里，我们需要通过传递<code class="eh kz la lb lc b"><em class="ld">isSmarx()</em></code>和<code class="eh kz la lb lc b"><em class="ld">isBadCode()</em></code>条件将<code class="eh kz la lb lc b"><em class="ld">isComplete</em></code>设置为真。<code class="eh kz la lb lc b"><em class="ld">isSmarx()</em></code>调用一个接口，该接口要求调用地址在函数<code class="eh kz la lb lc b"><em class="ld">name()</em></code>的上下文中以某种方式返回值“smarx ”,因此需要一个智能合约来调用身份验证函数。<code class="eh kz la lb lc b"><em class="ld">isBadCode()</em></code>另一方面，获取调用地址并检查该地址是否包含字节“badc0de”。</p><p id="c0b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们需要做两件事:创建一个由返回“smarx”的函数<code class="eh kz la lb lc b"><em class="ld">name()</em></code>组成的智能契约，并确保契约将“badc0de”作为其地址十六进制的一部分。</p><p id="1db4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">第一个很简单——准备一个实现了函数<code class="eh kz la lb lc b"><em class="ld">name()</em></code>的契约。不要忘记还实现对模糊标识符利用契约的函数<code class="eh kz la lb lc b"><em class="ld">authenticate()</em></code>的调用，因为契约需要是msg.sender。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/8b76a3be96a8446d086e431e13133e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-TQWFl0e0YvH5sHC.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Implementing our exploit contract.</figcaption></figure><p id="3724" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">第二个需要一点蛮力和以太坊如何生成合同地址的知识。正如前面在第2部分中提到的，契约地址是在以太坊中确定性地生成的，使用RLP编码中发送方地址和随机数的keccak256结果的最右边160位。我们可以很快地编写一段Solidity代码来完成这项工作，使用Nethereum和Ganache进行部署，以随机生成一组地址，并测试几个nonce来查看哪个地址+ nonce满足我们的要求。不要忘记保存地址的私钥，并跟踪随机数！</p><p id="dd10" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这段可靠性代码基本上使用RLP编码的地址和随机数运行keccak256:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lp"><img src="../Images/a21d71957fbb2b3b9343fd891efabdeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fpqJps_yAr88Q9XZ.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Generating contract address using Solidity.</figcaption></figure><p id="b5fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">部署契约的VB.NET代码开始生成随机地址和递增nonce，将它们传递给契约并检查返回的结果:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lq"><img src="../Images/8531edc05b4a51b13bebd0d9a0b4c234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pAgADPL_C8YgVmY8.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">The code — increments nonce 10 times then moves to another address, repeating the same.</figcaption></figure><p id="cedc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">跑一段…没错，就是蛮力。可能需要一段时间。以每秒25个合同地址的速度花了我几个小时:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lr"><img src="../Images/f66189c2025be5f3cdd6bd6d78bffc98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VyDK5UvhVAE_z5Yr.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">And we found our address!</figcaption></figure><p id="3e14" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们已经准备好了一切，使用我们知道最终将创建一个十六进制“badc0de”的契约地址的帐户的私钥，我们将使用一些ETH加载帐户地址，在Ropsten testnet上递增帐户的nonce，直到它最终达到我们想要的nonce，然后我们将在那里部署我们首先准备好的契约。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff ls"><img src="../Images/8f56d8a27ce6d9d25b2aee313b4ca4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mVFXLWVgKloEFHFm.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Notice the “badc0de”?</figcaption></figure><p id="133b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从那里，使用我们的利用合同，我们在模糊标识符挑战合同上调用<code class="eh kz la lb lc b"><em class="ld">authenticate()</em></code>，满足所有条件并完成这个挑战。</p><h1 id="765f" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">14.公开密钥</h1><p id="3874" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="33db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这不是一个聪明的合同利用，而是测试一个人对区块链如何工作的理解，以及如何在区块链上签署交易。当事务被签名时，生成签名的事务，产生两个ECDSA签名输出(r，s)和恢复id (v)。所有这些都可以用来恢复一个地址的公钥，如果有一个事务是从我们想要恢复的地址发送的。</p><p id="7c07" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">幸运的是，ethereumjs-tx库使我们可以轻松地做到这一点，而不必担心底层的复杂性。我们只需要获得原始的事务hex，这也可以很容易地从Etherscan中获得，因此我们不需要尝试从头开始重建事务。</p><p id="4aa8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">检查地址0x92b 28647 ae1f 3264661 f 72 FB 2 EB 9625 a 89d 88 a 31，我们确实看到之前发送了一个事务:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lt"><img src="../Images/96f0bf43a43a14f43ca85d0d20159333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rFwjsnHsLniGREwR.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">A previous sent transaction from 0x92b28647ae1f3264661f72fb2eb9625a89d88a31</figcaption></figure><p id="e1ec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">转到交易信息部分的右上角，单击工具和实用程序，然后单击“获取原始交易十六进制”。然后我们看到了:</p><p id="245d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">0 xf 87080843 b 9 ACA 0083015 f 90946 b 4777781 b 0 e 68031109 f 21887 E6 b 5 afeaaeb 002 b 808 c 5468616 E6 b 732 c 206d 616 e 2129 a 0a 5522718 c 0 f 95 DDE 27 f 0827 f 55 de 836342 ced 594d 20458523 DD 71 a 5333</p><p id="db2b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">剩下的事情很简单，使用ethereumjs-tx的<code class="eh kz la lb lc b"><em class="ld">getSenderPublicKey</em></code>函数，我们可以很容易地检索公钥:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lu"><img src="../Images/f829cc6acf822bd8521af8c5d328fed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XblAv3UX-Llg-QEM.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Using ethereumjs-tx library to obtain the public key.</figcaption></figure><p id="1c5a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用公钥作为authenticate函数的输入参数，我们就完成了！</p><p id="4ed5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">还是我们？这个挑战是750分，我想我应该多写一点。如果以太网扫描暂时关闭，我们迫切需要原始事务hex怎么办？:P</p><p id="615d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">其中一种方法是使用与Ropsten同步的Geth，它公开了一个我们可以调用的方法— eth.getRawTransaction —将事务哈希作为输入参数，我们可以获得原始事务hex:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lv"><img src="../Images/e58d04d490c1a5c75a386991c0b0ee3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*llYTTW7PJIIIJMaf.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">An example done through Geth console, not the actual hash — I don’t usually sync Ropsten.</figcaption></figure><p id="058d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是如果我们不想同步Geth，当然，另一种方法是获取事务细节:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lw"><img src="../Images/c1f292ed5578565e920132b8179071e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sahZj1BRgYy82iv6.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Using eth.getTransaction.</figcaption></figure><p id="87cc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">重建原始事务，并以十六进制序列化输出:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lx"><img src="../Images/17ff5400c6c0de2a7f9031e82371b4eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*02xy8l1uPlqeqq9d.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Or if you’re real hard to please, you could concatenate the transaction data together yourself. :)</figcaption></figure><p id="0a67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从那里开始，同样的事情发生了——获取原始的事务十六进制字符串并通过<code class="eh kz la lb lc b"><em class="ld">getSenderPublicKey()</em></code>传递它，我们将获得相同的公钥。</p><h1 id="ea6b" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">账户接管</h1><p id="0e4e" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">源代码如下。</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><p id="812c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">喜欢这个。同样，这个挑战并不完全是智能合同利用挑战，我可以想象一些人会发现这个挑战比五十年挑战更难，尽管提供的分数少了500分。在契约中可以看到的一切确实都很好，地址及其对应的私钥都是正确生成的，因此我们需要进一步扩大我们的范围，在其他地方搜索线索。</p><p id="49a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们转向从发送的交易中寻找线索:【https://ropsten.etherscan.io/txs? T2】a = 0x6b 477781 b 0 e 68031109 f 21887 e6b 5 afeaaeb 002 b&amp;p = 2</p><p id="07f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">同样，从表面上看，没有任何问题。但是，如果我们开始深入研究事务是如何构建的:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff ly"><img src="../Images/4ef9a194487db516770417e4ce2e6fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-ldslPwzFt4ZM9Ss.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Getting the transaction details with eth.getTransaction</figcaption></figure><p id="8fab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">等等。为什么值<em class="ld">r</em>(ECD sa签名输出)在这里被重用时应该是唯一的？这将是我们的利用向量，事实上早在2013年(<a class="ae jo" href="https://bitcointalk.to/index.php?topic=271486.0" rel="noopener ugc nofollow" target="_blank">https://bitcointalk.to/index.php?topic=271486.0</a>)在区块链空间就被注意到了。基本上，<em class="ld">r</em>-值将使用随机随机数<em class="ld"> k </em>生成；然而，使用Android加密库的移动钱包最终会重用k值，进而在不同的交易中生成相同的r值。这允许从签名输出中导出地址的私钥，从而导致资金被盗。</p><p id="7d5f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一个小细节——重复使用nonce <em class="ld"> k </em>让索尼在2010年陷入困境:【https://www.bbc.co.uk/news/technology-12116051】T2。RFC6979后来在2013年引入，以允许确定性地生成随机数<em class="ld"> k </em>(因此有助于测试和具有潜在不可靠PRNG的环境)。</p><p id="59f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">反正题外话先不说了，让我们试着弄清楚如何获取我们的地址0x6b 477781 b 0 e 68031109 f 21887 e 6b 5 afeaaeb 002 b的私钥。</p><p id="ebc3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们有以下值:</p><p id="4af5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于txid 1:0x 061 BF 0 B4 b 5 fdb 64 AC 475795 e 9 BC 5a 3978 f 985919 ce 6747 ce 2 CFB bcaccaf 51009<br/>S1 = 0 x2 bbd 9 C2 a 6285 C2 b43 e 728 b 17 BDA 36 a 81653 D5 f 4612 a 2 E0 AEF db 48043 c 5108 de<br/>Z1 = 0 x4 F6 a 8370 a 435 a 27724 BBB</p><p id="affb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于txid 2:0 xd 79 fc 80 e 7 b 787802602 f 3317 b 7 Fe 67765 c 14 a 7d 40 c 3 e 0 dcb 266 e 63657 f 881396<br/>S2 = 0x 7724 cedeb 923 f 374 be F4 e 05 c 97426 a 918123 C4 FEC 7 b 07903839 f 12517 E1 B3 c 8<br/>z2 = 0x 350 F3 ee 8007d 8</p><p id="92ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">常用<em class="ld"> r </em>值:0x 69 a 726 EDF B4 b 802 CBF 267 D5 FD 1 dabcea 39d 3d 7 B4 BF 62 b 9 eeaeba 387606167166</p><p id="7a9e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有一种方法可以导出私钥，其中nonce <em class="ld"> k </em>与上面的值一起重用，使用此处上传的Python脚本:</p><figure class="ks kt ku kv fq kw"><div class="bz el l di"><div class="kx ky l"/></div></figure><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lz"><img src="../Images/eb7411b6dc737e16f94fcb82144003ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e281vU-FcMIrMDqL.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Script output.</figcaption></figure><p id="0248" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">测试私钥，我们会发现其中一个允许我们访问地址0x6b 477781 b 0 e 68031109 f 21887 e6b 5 afeaaeb 002 b。从那里，我们使用前述地址的私钥调用函数<em class="ld"> authenticate() </em>，将<em class="ld"> isComplete </em>设置为true，并完成质询。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff ma"><img src="../Images/b8cc64bab665ab1a73e5a1ad28ae61f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZLh51N-ZFxW9BQl9.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Confirming the private key to the address using MyCrypto’s desktop app</figcaption></figure><p id="4410" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但既然这是1500分，那我多写一点才是对的。也许对Python脚本是如何实现的有一点了解。StackExchange上有一个非常好的主题也涉及到了这一点:<a class="ae jo" href="https://bitcoin.stackexchange.com/questions/37760/converting-ruby-script-into-python-recovering-private-key-when-someone-uses-th/37762#37762" rel="noopener ugc nofollow" target="_blank">https://bit coin . stack exchange . com/questions/37760/converting-ruby-script-into-python-recovering-private-key-when-someone-uses-th/37762 # 37762</a></p><p id="a023" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用以下等式计算ECDSA特征信号<em class="ld"> s </em>:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/c2568f5d2f907519b97e70014dd50cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/0*KmZeAc667B1FbEw0.png"/></div></figure><p id="9d0d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">其中<em class="ld"> k </em>为nonce，<em class="ld"> z </em>为消息摘要，<em class="ld"> r </em>为ECSDA签名，<em class="ld"> privKey </em>为私钥，<em class="ld"> p </em>为secp256k1曲线的质数阶(为0x fffffffffffffffffffffffffffffffffffffffffffebaaedce 6 af 48 a 03 bbfd 25 E8 CD 0364141)。</p><p id="4947" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从这里我们可以推导出对于<em class="ld"> s1 </em>和<em class="ld"> s2 </em>:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/4498eff7940699d4fbf149c170deeb06.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/0*92H1DTRLYO1hnSzq.png"/></div></figure><p id="28a6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请记住，这里的所有运算都是对素数<em class="ld"> p </em>取模，因此<em class="ld"> (s1-s2)^(-1) </em>是素数<em class="ld"> p </em>的模乘逆运算，我们可以使用费马小定理的实现来计算，因为在这种情况下<em class="ld"> p </em>是素数，或者使用扩展的欧几里德算法。</p><p id="7fa9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一旦我们有了<em class="ld"> k </em>，我们就可以尝试找到<em class="ld"> privKey </em>:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff md"><img src="../Images/602ed980b48dbeffdc2e30c8d8ac6f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/0*lBTW9ApwQQa3sDS8.png"/></div></figure><p id="4281" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">并且私钥privKey在从<em class="ld"> s2 </em>和<em class="ld"> z2 </em>导出时也应该相同。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff me"><img src="../Images/e8b0c216babf1d01df68a8ecadb2eb6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/0*zBAzV4bfSCxJk5JO.png"/></div></figure><p id="3106" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">针对<em class="ld"> s1-s2 </em>的情况进行计算是不够的(尽管对于这个挑战，我们很幸运没有翻转的签名)，因为我们还可以使用翻转的<em class="ld"> s </em>签名<em class="ld"> -s (mod p) </em>，这仍然是有效的签名输出。因此，我们将先发制人地评估多个<em class="ld"> k </em>候选者(每一对都存在一个对自身的否定)，因此我们可以看到:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mf"><img src="../Images/0e0dc664efb46fc35fbe21eb8c267e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:306/format:webp/0*OB6C822U00i0EOPX.png"/></div></div></figure><p id="75a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">其中<em class="ld"> -s1-s2 </em>和<em class="ld"> -s1+s2 </em>我们可以使用<em class="ld"> -k (mod p) </em>来推导。</p><p id="e768" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们有了所有这些，我们可以在代码中实现它们，插入我们拥有的值，看看会出现什么。下面的一切都将在Python中实现，因为我很懒，所以让我们用费马的模乘逆(def inverse_mod)小定理:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mg"><img src="../Images/2abd0930f8cd42cccc97fbbf0f5c4ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lW1f9kwjAadd3qQ1.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Defining the r, s and z values, and the modulo inverse</figcaption></figure><p id="8d4f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">寻找<em class="ld"> k </em>:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mh"><img src="../Images/72d0c17bbd64a325f3905f7602d0656a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DISL6kYxXb4l-FNI.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Getting our k.</figcaption></figure><p id="6607" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为<em class="ld"> k </em>和<em class="ld"> -k (mod p) </em>导出私钥。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mi"><img src="../Images/f287d35d5d5d1591124c29b46b85954c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sfgVAFz4Xa_jBXys.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Getting our private key.</figcaption></figure><p id="32a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">打印所有<em class="ld"> k </em>候选项并确保私钥匹配:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mj"><img src="../Images/c964b7b551303243cec2419410c08c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qukZl9av9QrMJP81.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Printing our private key.</figcaption></figure><p id="d92b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还将对<em class="ld"> s1+s2 </em>做同样的事情，替换用于计算<em class="ld"> k </em>候选者的<em class="ld"> s1-s2 </em>，并以类似的方式导出私钥。因此，整个代码块将是:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff mk"><img src="../Images/f96676fc980f896893720b73852e1db8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OMX3u9gGFSgnl6L9.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Full Python code implementation.</figcaption></figure><p id="939a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行脚本，测试哪个私钥是地址0x6b 477781 b 0e 68031109 f 21887 e6b 5 afeaaeb 002 b的私钥，现在我们可以解决这个问题了。</p><p id="9f23" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于这一部分，我将直接链接到第4部分，在那里我们将完成最后两个捕获以太挑战并结束:<a class="ae jo" rel="noopener" href="/@Enigmatic1256/smart-contract-exploits-part-3-featuring-capture-the-ether-miscellaneous-d11bae6cb01b">https://medium . com/@ enigmatic 1256/smart-contract-exploits-part-3-featured-Capture-the-Ether-miscellaneous-d 11 ba E6 CB 01 b</a></p><blockquote class="ml"><p id="219c" class="mm mn ht bd mo mp mq mr ms mt mu jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mw mx my mz na kw fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mv"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>