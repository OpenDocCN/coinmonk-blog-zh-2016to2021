<html>
<head>
<title>IOTA: MAM Eloquently Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">妈妈雄辩地解释道</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/iota-mam-eloquently-explained-d7505863b413?source=collection_archive---------0-----------------------#2018-02-24">https://medium.com/coinmonks/iota-mam-eloquently-explained-d7505863b413?source=collection_archive---------0-----------------------#2018-02-24</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="1233" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">屏蔽认证消息是IOTA最显著的特征之一。让我们推测这个充满小型物联网设备的世界，它们的小型工作、微观数据流动和纳米支付在全球各地来来去去。</p><p id="8c15" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">IOTA的目标是成为这样一个社会的最基本的一层，它是这个时代最有远见的项目，挑战即将到来的范式转变。MAM是其核心驱动力，通过使数据流和交易更便宜、更安全和无处不在，使IOTA区别于其他分布式分类账。</p><p id="2c04" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，尽管MAM对IOTA及其未来非常重要，但由于它仍处于开发阶段，因此公众可获得的关于其技术实现的信息非常有限。</p><p id="1e49" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">本文以尽可能易懂的方式揭示了这一点，以便更多的人能够理解这一新技术。</p><blockquote class="jo"><p id="0d3a" class="jp jq ht bd jr js jt ju jv jw jx jn ek translated"><a class="ae jy" href="https://coincodecap.com" rel="noopener ugc nofollow" target="_blank">发现并回顾最佳区块链软件</a></p></blockquote><h1 id="01ab" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">主频道</h1><p id="e79c" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">像Youtube和其他媒体一样，MAM也有<strong class="is hu">频道</strong>，发布者和订阅者可以在这里见面。观众订阅频道以获取可用数据。频道所有者在他们自己频道上发布新数据。这种所有权由<strong class="is hu"> Seed </strong>在IOTA中实现和保护。如果你告诉别人你的种子，他们可以在你的频道上发表他们的任何消息。同样，Seed拥有其81%的隐私权和财产权。千万不要暴露，安全存放。</p><h1 id="4767" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">通道方式</h1><p id="a427" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">发布者在渠道上发布新消息时，有三个选项可供选择。<strong class="is hu">公开:</strong>所有人都可以查看，<strong class="is hu">私人:</strong>只有您(即种子所有者)可以查看，<strong class="is hu">受限:</strong>您可以通过告诉他们一个密钥来指定您的查看者。这个键在源代码中被命名为<strong class="is hu"> sideKey </strong>。所以，在这篇文章里，我也要把这个键叫做<code class="eh lf lg lh li b"><strong class="is hu"><em class="lj">sideKey</em></strong></code>。并且，对于任何模式，将作为消息标识符的<code class="eh lf lg lh li b"><strong class="is hu"><em class="lj">root</em></strong></code>给予观看者，以便从tangle中找到消息。</p><blockquote class="lk ll lm"><p id="b442" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hm dt translated"><strong class="is hu"> <em class="ht">公开:</em> </strong> <em class="ht">屏蔽——消息使用</em> <code class="eh lf lg lh li b"><em class="ht">root</em></code> <em class="ht">解密。</em></p><p id="ea43" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hm dt translated"><strong class="is hu"> <em class="ht">私:</em> </strong> <code class="eh lf lg lh li b"><em class="ht">address＝hash(root)</em></code> <em class="ht">。使用</em> <code class="eh lf lg lh li b"><em class="ht">root</em></code> <strong class="is hu"> <em class="ht">解密被屏蔽的消息。</em> </strong></p><p id="0ce0" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hm dt translated"><strong class="is hu"> <em class="ht">受限:</em> </strong> <code class="eh lf lg lh li b"><em class="ht">address＝hash(root)</em></code> <em class="ht">。使用</em> <code class="eh lf lg lh li b"><em class="ht">sideKey</em></code> <em class="ht">解密屏蔽的消息。</em></p></blockquote><h1 id="502b" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">消息链</h1><p id="bc76" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">在IOTA协议中，像许多其他密码一样，人们可以在交易中附加任意消息。但是，一点感觉都没有！然而，它限制了发送者一次只能附加一条消息，并且不能发布具有任意上下文的连续相关消息。</p><p id="7970" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">例如，如果你想每15分钟发布一次当前温度数据，没有MAM，你必须将每条消息都发布到同一个地址。因为包括tangle在内的任何分布式分类帐都是公开可访问的，所以附加者很容易识别这样一个每15分钟更新一次的地址，并干扰它进行垃圾邮件交易。即使您决定在每次发布新数据时更改地址，您也必须跟踪所有地址。仅在网上存储信息而言，监控它们的成本相对较高。</p><p id="5d45" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，由于MAM的<strong class="is hu">消息链</strong>设计，我们可以保护我们的频道免受任何令人不安的垃圾邮件，并让我们从管理累积地址中解脱出来。</p><p id="7327" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">MAM将每一条消息发送到不同的地址，但是用详细的信息将它们连接起来。在这条消息链上，一代<strong class="is hu">到下一代</strong>的<strong class="is hu">到</strong>，旧的消息总是导致新的。它的流动是单向的。</p><h1 id="8a7a" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">MAM束的基本结构</h1><p id="9a28" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">MAM包大致有两个部分，<strong class="is hu">签名部分</strong>和<strong class="is hu"> MAM部分</strong>，每个细节将在本文后面解释。他们的数据被存储为捆绑包中交易的<code class="eh lf lg lh li b">signatureFragment</code>。签名用于MAM的所有权，并因此检查其有效性。MAM部分存储实际的屏蔽消息。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff lq"><img src="../Images/3bb69fcf9a51b77483b785012da5ee98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iFUH_trJhHIfjPjC5NYXzg.png"/></div></div></figure><h1 id="759e" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">地址:存放MAM的地方</h1><p id="ab56" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">存储屏蔽消息的地址从<code class="eh lf lg lh li b">root</code>开始散列。哈希是一种复杂的计算，在这种计算中，人们无法通过知道输出来猜测输入是什么。</p><pre class="lr ls lt lu fq mc li md me aw mf dt"><span id="aad9" class="mg ka ht li b fv mh mi l mj mk">if (channel.mode !== 'public') {<br/>    // private, restricted mode<br/>    address = Crypto.converter.trytes(Encryption.hash(81, Crypto.converter.trits(mam.root.slice())));<br/>} else {<br/>    address = mam.root;<br/>}</span></pre><blockquote class="lk ll lm"><p id="04f3" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hm dt translated"><strong class="is hu"> <em class="ht">注意:</em> </strong></p><p id="9c98" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hm dt translated"><em class="ht">保罗·汉迪的</em> <a class="ae jy" href="https://blog.iota.org/introducing-masked-authenticated-messaging-e55c1822d50e" rel="noopener ugc nofollow" target="_blank"> <em class="ht">文章</em> </a> <em class="ht">显示受限模式地址= </em> <code class="eh lf lg lh li b"><em class="ht">hash(root+sideKey)</em></code> <em class="ht">。但是，从上面的源代码可以看出，地址= </em> <code class="eh lf lg lh li b"><em class="ht">hash(root)</em></code> <em class="ht">。所以，在本文中，我将解释为地址= </em> <code class="eh lf lg lh li b"><em class="ht">hash(root)</em></code> <em class="ht">为受限模式。这可能与事实有出入，所以如果任何对此有详细了解的人。请评论或联系我。我很感激。</em></p></blockquote><h1 id="034a" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">公共模式</h1><blockquote class="lk ll lm"><p id="9d17" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hm dt translated"><code class="eh lf lg lh li b"><em class="ht">root</em></code> <em class="ht">是称呼。</em> <code class="eh lf lg lh li b"><em class="ht">root</em></code> <em class="ht">是加密&amp;的解密密钥。</em></p></blockquote><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff ml"><img src="../Images/d0281f5247f2554ce5f0b06a33b451f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hARVQLiMnkWH-84hnwNxGw.png"/></div></div></figure><p id="236e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh lf lg lh li b">nextRoot</code>是指向下一条消息的连接指针。当一代被屏蔽的消息被解密时，未被屏蔽的消息包含<code class="eh lf lg lh li b">nextRoot</code>,用于查看者找到该频道的下一代消息。简单来说，就像你在第一个宝箱里找到了打开第二个宝箱的钥匙。重复地，人们可以从渠道起源开始追踪链条上的所有信息。如果你是中产阶级，你可以从这一点开始阅读链。不能回溯看到过去的消息。</p><h1 id="3008" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">受限模式</h1><blockquote class="lk ll lm"><p id="4fd7" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hm dt translated"><code class="eh lf lg lh li b"><em class="ht">hash(root)</em></code> <em class="ht">是称呼。</em> <code class="eh lf lg lh li b"><em class="ht">sideKey</em></code> <em class="ht">是加密&amp;的解密密钥。</em></p></blockquote><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff ml"><img src="../Images/843562f30c2b3c081fda041e5fdb25d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j-ZzlBHpY2dBFz9oHjSd8Q.png"/></div></div></figure><p id="5bb0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">主要思想与公共模式相同。唯一的区别是<code class="eh lf lg lh li b">sideKey</code>被用来解密被屏蔽的消息。没有<code class="eh lf lg lh li b">sideKey</code>的人可以用<code class="eh lf lg lh li b">root</code>找到消息的位置，但是不知道那里装了什么。</p><h1 id="4629" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">渠道所有权</h1><p id="6f01" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">考虑以下情况:</p><p id="e264" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Alice刚刚在她的频道上发布了她的第一条消息，并希望Bob阅读她的帖子。于是，爱丽丝给了他她的<code class="eh lf lg lh li b">root</code>和<code class="eh lf lg lh li b">sideKey</code>。鲍勃通过生成地址(= <code class="eh lf lg lh li b">hash(root)</code>)并用<code class="eh lf lg lh li b">sideKey</code>解密来访问她的消息。鲍勃很喜欢她的帖子，心想“下一篇想看吗！”。并且他在解密的当前消息中有<code class="eh lf lg lh li b">nextRoot</code>，并且可以从中生成下一个地址。但是，他意识到爱丽丝还没有在下一个地址发布下一条消息。鲍勃突然变得邪恶。他有<code class="eh lf lg lh li b">nextRoot</code>和<code class="eh lf lg lh li b">sideKey</code>。他可以将他用<code class="eh lf lg lh li b">sideKey</code>加密的消息投递到地址<code class="eh lf lg lh li b">hash(nextRoot)</code>。他可以劫持爱丽丝的频道。</p><p id="f147" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你认为这行得通吗？从目前解释的信息来看，没有矛盾。...然而，这是妈妈的失败。别担心，MAM是为像Bob这样的人设计的，所以他们不会搞乱频道。下一个主题是爱丽丝如何防止她的信息链被其他人编辑。</p><p id="0013" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里我们需要妈妈的签名。</p><h1 id="a29f" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">基于Merkle树的签名方案</h1><p id="4254" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">基于Merkle树的签名方案是在MAM中使用的技术。更多感兴趣的可以去链接。</p><h1 id="0d3f" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">MAM发布101: <code class="eh lf lg lh li b">root</code></h1><p id="848a" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated"><code class="eh lf lg lh li b">root</code>是Merkle树的根。要得到<code class="eh lf lg lh li b">root</code>，首先要创建<strong class="is hu"> <em class="lj"> Merkle树</em> </strong>。而<strong class="is hu"> <em class="lj">种子</em> </strong>是用来创建Merkle树的。</p><p id="4b31" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Merkle树有整数参数<code class="eh lf lg lh li b">start</code>和<code class="eh lf lg lh li b">size</code>。这些表示从种子生成的地址的索引。回想一下，当生成地址时，我们将<code class="eh lf lg lh li b">index</code>作为参数之一(<code class="eh lf lg lh li b">seed,index,security</code>)。最近解释的<a class="ae jy" rel="noopener" href="/@abmushi/iota-signature-and-validation-b95b3f9ec534">这里的</a>。</p><p id="7df6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">A、B、C、D后面分别是用<code class="eh lf lg lh li b">index = 0,1,2,3</code>生成的私钥。和A’、B’、C’、D’是对应地址。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff mm"><img src="../Images/a6abdad837a321ff61301bf621f21d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3mGzFDpTeZi2wi6r5ZrGA.png"/></div></div></figure><p id="4e9e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">那么A”、B”、C”、D”都是<code class="eh lf lg lh li b">hash(address)</code>。直到<code class="eh lf lg lh li b">root</code>，通过散列每一对的组合来缩小范围。请注意，您无法从<code class="eh lf lg lh li b">root</code>中获取上一个。</p><p id="974f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们有了<code class="eh lf lg lh li b">root</code>。在公共模式下，这个<code class="eh lf lg lh li b">root</code>直接作为MAM地址，在其他模式下，address = <code class="eh lf lg lh li b">hash(root)</code>。</p><h1 id="6d97" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">MAM发布102: MAM部分</h1><p id="a02e" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated"><strong class="is hu"> <em class="lj"> MAM部分</em> </strong>包含发布者将要发布的屏蔽消息、他/她的原始消息、任意长度的ascii码串。但是，在附加之前，它应该被转换为tryte(使用库函数<code class="eh lf lg lh li b">toTrytes(ascii); // from asciiToTrytes.js</code>，并存储为<code class="eh lf lg lh li b">message</code>。</p><h1 id="76f8" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">MAM发布102: MAM部分— <code class="eh lf lg lh li b">nextRoot</code></h1><p id="9de3" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">为了张贴一代的屏蔽消息，必须生成两个merkle树。第一棵树是现在这一代，另一棵树是下一代。</p><p id="f553" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于Genesis代(即第0代)，merkle树<code class="eh lf lg lh li b">tree0</code>有参数<code class="eh lf lg lh li b">start0</code>和<code class="eh lf lg lh li b">count(= number of leaves)</code>。对于下一代(即第一代)，用<code class="eh lf lg lh li b">start1 = start0+count</code>和<code class="eh lf lg lh li b">count</code>生成merkle树<code class="eh lf lg lh li b">tree1</code>。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/51bf001a32e90d1ba455534ede1f14b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*V-yf9zCXfHYIEIg6rtyZlA.png"/></div></figure><p id="76db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">顺便说一下，每个merkle树可以有不同的大小。</p><h1 id="6a40" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">MAM发布102: MAM部分— <code class="eh lf lg lh li b">Branch Index</code></h1><p id="6ad9" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">分支索引<code class="eh lf lg lh li b">branch_index</code>选自当前代merkle树的任意一片叶子<code class="eh lf lg lh li b">index</code>。在下面的例子中，merkle树是用<code class="eh lf lg lh li b">start=0</code>和<code class="eh lf lg lh li b">count=4</code>制作的，所以<code class="eh lf lg lh li b">branch_index</code>应该是<code class="eh lf lg lh li b">0,1,2 and 3</code>中的一个。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff mo"><img src="../Images/1fa6eb6b1745682a5b26468ef5eac6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQ7RZbddPhVq2NUNBHxH0Q.png"/></div></div></figure><h1 id="066c" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">MAM发布102: MAM部分-兄弟姐妹</h1><p id="305e" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">比方说，给定了叶子<code class="eh lf lg lh li b">A'</code>，要获得<code class="eh lf lg lh li b">root</code>，你需要拥有其他所有叶子<code class="eh lf lg lh li b">B'C'D'</code>。但是，如果你不能访问这些，你怎么得到<code class="eh lf lg lh li b">root</code>？<strong class="is hu">同辈</strong>是互补哈希的集合，通过与给定的叶子组合，可以生成<code class="eh lf lg lh li b">root</code>。看下图。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff mp"><img src="../Images/af9d2ee7b0e995c5f95115e885e255ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3pFPAk5BGTkNJixnRBaIrQ.png"/></div></div></figure><p id="a0d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该图举例说明了<code class="eh lf lg lh li b">branch_index=0</code>的情况，其中仅给出了<code class="eh lf lg lh li b">A'</code>。在这种情况下，<code class="eh lf lg lh li b">B"</code>和<code class="eh lf lg lh li b">Hash(C"D")</code>都是获得<code class="eh lf lg lh li b"><strong class="is hu">root</strong></code>的必要条件。你不必有其他的叶子。</p><p id="fe8c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这个例子中，<code class="eh lf lg lh li b">B"</code>和<code class="eh lf lg lh li b">Hash(C"D")</code>被称为 <code class="eh lf lg lh li b"><strong class="is hu">A'</strong></code>的<strong class="is hu">兄弟。在MAM中，它被称为</strong> <code class="eh lf lg lh li b"><strong class="is hu">branch_index=0</strong></code>的<strong class="is hu">兄弟姐妹。不同的<code class="eh lf lg lh li b">branch_index</code>有不同的同胞。</strong></p><h1 id="dfa6" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">MAM发布102: MAM部分-已完成</h1><p id="a74c" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">在MAM段中，<code class="eh lf lg lh li b">message</code>、<code class="eh lf lg lh li b">nextRoot</code>、<code class="eh lf lg lh li b">branch_index</code>和<code class="eh lf lg lh li b">Siblings</code>的组合，称为<code class="eh lf lg lh li b"><strong class="is hu">messageTrytes</strong></code>，用<code class="eh lf lg lh li b">root(Public mode)</code>或<code class="eh lf lg lh li b">sideKey(Restricted mode)</code>加密。下图是MAM部分的受限模式加密示例。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/82c1b5e70db823129482155e3b1be895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*pqMOCNnv1fAaRf_ZIXi-Iw.png"/></div></figure><h1 id="3aaa" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">MAM发布103:签名部分</h1><p id="8bcc" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">正如我提到的，为了检查MAM部分的有效性，发布者在包中添加了<strong class="is hu">签名</strong>。签名存储在事务的<code class="eh lf lg lh li b">signatureFragment</code>中，这些事务在MAM bundle中称为<strong class="is hu"> <em class="lj">签名段</em> </strong>。</p><h1 id="e448" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">MAM发布103:签名部分-签名</h1><p id="abbe" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">屏蔽消息的签名由私钥<code class="eh lf lg lh li b">=key(seed,<strong class="is hu"><em class="lj">branch_index</em></strong>,security)</code>创建。签名数据是MAM段的<code class="eh lf lg lh li b">messageTrytes</code>。这里解释<a class="ae jy" rel="noopener" href="/@abmushi/iota-signature-and-validation-b95b3f9ec534">签名方案。</a></p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/fcaa1c6348cc16e80daf4b8ea3f36f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*-AA72W4lXdj19sLRhGu4gQ.png"/></div></figure><h1 id="6fbe" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">MAM获取</h1><p id="b1d5" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">要获取屏蔽消息，在受限模式下需要<code class="eh lf lg lh li b">root</code>和<code class="eh lf lg lh li b">sideKey</code>。</p><p id="419e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，根据给定的<code class="eh lf lg lh li b">root</code>计算地址。和地址的搜索包。然后解密找到的包的<em class="lj"> MAM段</em>的<code class="eh lf lg lh li b">messageTryte</code>。公开模式的解密密钥为<code class="eh lf lg lh li b">root</code>，受限模式的解密密钥为<code class="eh lf lg lh li b">sideKey</code>。现在，从解密的数据来看，我们有<code class="eh lf lg lh li b">message</code>、<code class="eh lf lg lh li b">nextRoot</code>、<code class="eh lf lg lh li b">branch_index</code>、<code class="eh lf lg lh li b">Siblings</code>。</p><p id="b576" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下一步是检查未屏蔽消息的有效性。现在，看看<em class="lj">签名部分</em>。签名段中的签名用于将bundle的<em class="lj"> MAM段</em> 的<code class="eh lf lg lh li b"><strong class="is hu">messageTryte</strong></code> <strong class="is hu">验证为签名数据<strong class="is hu">。</strong>此处解释<a class="ae jy" rel="noopener" href="/@abmushi/iota-signature-and-validation-b95b3f9ec534">验证过程。</a></strong></p><p id="a357" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">经过验证过程，得到的是address，作为merkle树index= <code class="eh lf lg lh li b">branch_index</code>的一个叶子地址，结合<code class="eh lf lg lh li b">Siblings</code>计算树的根，命名为<code class="eh lf lg lh li b">temp_root</code>。</p><p id="6a4f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">如果</strong> <code class="eh lf lg lh li b"><strong class="is hu">temp_root</strong></code> <strong class="is hu">等于给定的</strong> <code class="eh lf lg lh li b"><strong class="is hu">root</strong></code> <strong class="is hu">，则该非屏蔽消息为该通道的有效消息。</strong>如果不是，则不是渠道所有者(=种子所有者)发布的。</p><blockquote class="jo"><p id="65ef" class="jp jq ht bd jr js jt ju jv jw jx jn ek translated"><a class="ae jy" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mt mu mv mw mx lv fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ms"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><h1 id="f128" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">链条叉</h1><p id="8517" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">MAM的消息链可以分叉。而且很容易分叉。对于您选择分叉的生成，您只需发布带有不同<code class="eh lf lg lh li b">branch_index</code>的消息。但是，一代中可以分叉的分枝的极限是一代的merkle树的大小。如果你分叉超过这个数，新的分支索引会溢出到下一代的<code class="eh lf lg lh li b">branch_index</code>中。您可以在子链之间设置不同的<code class="eh lf lg lh li b">sideKey</code>和通道模式。</p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff my"><img src="../Images/7d583902dc6bb3389f117267cf219bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZppShLX694_Bdms16AioIQ.png"/></div></div></figure><h1 id="1ac9" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">快照</h1><p id="5334" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">屏蔽消息存储在事务的<code class="eh lf lg lh li b">signatureFragment</code>中。因此，在消除所有事务和零余额地址的快照之后，在快照之前的所有MAM都被删除。</p><p id="69c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了防止这种清除发生，MAM存储在<strong class="is hu"> <em class="lj"> Permanode </em> </strong>中，不做快照。尽管permanode需要大容量存储、高带宽和高速度，但目前它的运行没有任何经济刺激。我们的社区必须讨论如何维护IOTA的基础设施，并对其进行奖励以保持其稳定性。</p><h1 id="a4ee" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw dt translated">参考</h1><blockquote class="lk ll lm"><p id="602f" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hm dt translated"><strong class="is hu"> MAM JS库</strong><em class="ht">:</em><a class="ae jy" href="https://github.com/iotaledger/mam.client.js" rel="noopener ugc nofollow" target="_blank"><em class="ht">https://github.com/iotaledger/mam.client.js</em></a></p><p id="b367" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hm dt translated"><strong class="is hu">IOTA github</strong>T3:T5<em class="ht">https://github.com/iotaledger/iota.lib.js</em>T8】</p><p id="4dd3" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hm dt translated"><strong class="is hu">介绍MAM</strong><em class="ht">:</em><a class="ae jy" href="https://blog.iota.org/introducing-masked-authenticated-messaging-e55c1822d50e" rel="noopener ugc nofollow" target="_blank"><em class="ht">https://blog . iota . org/Introducing-masked-authenticated-messaging-e55c 1822d 50e</em></a></p></blockquote></div><div class="ab cl mz na hb nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hm hn ho hp hq"><h1 id="9f6f" class="jz ka ht bd kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks nk ku kv kw dt translated">关于作者</h1><p id="7f2d" class="pw-post-body-paragraph iq ir ht is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hm dt translated">@abmushi在<a class="ae jy" href="https://twitter.com/abmushi" rel="noopener ugc nofollow" target="_blank">推特</a>上，不和谐</p><p id="8b81" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">翻译自我用日语写的原文<a class="ae jy" href="https://qiita.com/ABmushi/items/f49a431c5c4a94abf33c" rel="noopener ugc nofollow" target="_blank">这里</a></p><p id="62b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">捐赠总是受欢迎和赞赏的！</p><p id="4855" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">BTC: <code class="eh lf lg lh li b">1ACGpgpAMgaAKbGpPq2sDa467MnRNdW4wX</code></p><p id="d8b9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">IOTA:g 9 xncnyyhrknpklxfkusinz 9 oiaqgsngjvodc 9 tnwqmilxzh 9 pnhxdgneufleqnnvjuciwwkzbtjldxayozhzesn 9</p></div><div class="ab cl mz na hb nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hm hn ho hp hq"><p id="baea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">【gist.github.com】原载于<a class="ae jy" href="https://gist.github.com/abmushi/61d65059689f10d4ac4e5571b4573cda" rel="noopener ugc nofollow" target="_blank"><em class="lj"/></a><em class="lj">。</em></p><figure class="lr ls lt lu fq lv fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff nl"><img src="../Images/e7b1dbc6a532a697c6844fdf0f0bbd30.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*HrFLDXz92JavTZXjhmvU7g.png"/></div></a></figure></div></div>    
</body>
</html>