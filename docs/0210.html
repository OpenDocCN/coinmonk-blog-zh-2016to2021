<html>
<head>
<title>Solidity and Web3.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity和Web3.js</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-and-web3-js-141115b0f8c5?source=collection_archive---------0-----------------------#2018-04-04">https://medium.com/coinmonks/solidity-and-web3-js-141115b0f8c5?source=collection_archive---------0-----------------------#2018-04-04</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="543c" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">参考:cryptozombies.io</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/0fb62edac19a67285656f39e7859982d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cd40_7ZQ_rfX-6cmCKXzcA.png"/></div></div></figure><p id="55e6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">然而，使用web3.js的另一种方式与此大相径庭，也请阅读此文:<a class="ae kq" rel="noopener" href="/@yangnana11/interacting-with-a-smart-contract-through-web3-js-tutorial-56a7ff2ff153">https://medium . com/@ yang nana 11/interactive-with-a-smart-contract-through-web 3-js-tutorial-56 a7 ff 2ff 153</a></p><h1 id="6aad" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">Web3.js是什么？</h1><p id="29ea" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">记住，以太坊网络是由节点组成的，每个节点都包含一份区块链。当您想要调用智能合约上的函数时，您需要查询其中一个节点并告诉它:</p><ol class=""><li id="eb8a" class="lo lp ht jw b jx jy ka kb kd lq kh lr kl ls kp lt lu lv lw dt translated">智能合同的地址</li><li id="abb9" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">您想要调用的函数，以及</li><li id="7851" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">要传递给该函数的变量。</li></ol><blockquote class="mc"><p id="b535" class="md me ht bd mf mg mh mi mj mk ml kp ek translated">新手交易试试<a class="ae kq" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或者<a class="ae kq" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><p id="981d" class="pw-post-body-paragraph ju jv ht jw b jx mm iu jz ka mn ix kc kd mo kf kg kh mp kj kk kl mq kn ko kp hm dt translated">以太坊节点只说一种叫做<strong class="jw hu"> JSON-RPC </strong>的语言，这种语言不太容易被人读懂。告诉节点您想要调用契约上的函数的查询如下所示:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="bcbd" class="mw ks ht ms b fv mx my l mz na">// Yeah... Good luck writing all your function calls this way!<br/>{"jsonrpc":"2.0","method":"eth_sendTransaction","params":[{"from":"0xb60e8dd61c5d32be8058bb8eb970870f07233155","to":"0xd46e8dd67c5d32be8058bb8eb970870f07244567","gas":"0x76c0","gasPrice":"0x9184e72a000","value":"0x9184e72a","data":"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"}],"id":1}</span></pre><p id="856b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">幸运的是，Web3.js将这些讨厌的查询隐藏在表面之下，所以您只需要与一个方便且易读的JavaScript接口进行交互。</p><p id="2223" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">不需要构造上面的查询，在您的代码中调用一个函数将看起来像这样:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="7ad3" class="mw ks ht ms b fv mx my l mz na">CryptoZombies.methods.createRandomZombie("Vitalik Nakamoto 🤔")<br/>  .send({ from: "0xb60e8dd61c5d32be8058bb8eb970870f07233155", gas: "3000000" })</span></pre><h1 id="8df1" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">1.入门指南</h1><p id="d07a" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">根据项目的工作流程，您可以使用大多数包工具将Web3.js添加到项目中:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="388f" class="mw ks ht ms b fv mx my l mz na"><em class="nb">// Using NPM</em><br/>npm install web3</span><span id="c0c4" class="mw ks ht ms b fv nc my l mz na"><em class="nb">// Using Yarn</em><br/>yarn add web3</span><span id="c60f" class="mw ks ht ms b fv nc my l mz na"><em class="nb">// Using Bower</em><br/>bower install web3</span><span id="ad45" class="mw ks ht ms b fv nc my l mz na"><em class="nb">// ...etc.</em></span></pre><p id="435e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">或者您可以从<a class="ae kq" href="https://github.com/ethereum/web3.js/blob/1.0/dist/web3.min.js" rel="noopener ugc nofollow" target="_blank"> github </a>下载缩小的<code class="eh nd ne nf ms b">.js</code>文件，并将其包含在您的项目中:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="5343" class="mw ks ht ms b fv mx my l mz na">&lt;script language="javascript" type="text/javascript" src="web3.min.js"&gt;&lt;/script&gt;</span></pre><h1 id="8db3" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated"><strong class="ak"> Web3提供商</strong></h1><p id="3671" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">记住，以太坊是由<strong class="jw hu">节点</strong>组成的，它们共享相同数据的副本。在Web3.js中设置Web3 Provider告诉我们的代码<strong class="jw hu">我们应该与哪个节点</strong>对话来处理我们的读写。这有点像在传统的web应用程序中为API调用设置远程web服务器的URL。</p><p id="f6e7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">您可以作为提供者托管自己的以太坊节点。然而，有一个第三方服务让你的生活更轻松，这样你就不需要为了给你的用户提供DApp而维护自己的以太坊节点了。</p><h1 id="5322" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">Infura</h1><p id="433c" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">Infura 是一个维护一组以太坊节点的服务，这些节点有一个用于快速读取的缓存层，你可以通过他们的API免费访问。使用Infura作为提供者，您可以可靠地向/从以太坊区块链发送和接收消息，而不需要设置和维护您自己的节点。</p><p id="20e4" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">您可以设置Web3使用Infura作为您的web3提供商，如下所示:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="08af" class="mw ks ht ms b fv mx my l mz na">var web3 = new Web3(new Web3.providers.WebsocketProvider("wss://mainnet.infura.io/ws"));</span></pre><p id="29f1" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">然而，由于我们的DApp将被许多用户使用——这些用户将写区块链，而不仅仅是读它——我们需要一种方法让这些用户用他们的私钥签署交易。</p><blockquote class="ng nh ni"><p id="29c6" class="ju jv nb jw b jx jy iu jz ka kb ix kc nj ke kf kg nk ki kj kk nl km kn ko kp hm dt translated">注意:以太坊(以及一般的区块链)使用公钥/私钥对对交易进行数字签名。可以把它想象成一个非常安全的数字签名密码。这样，如果我更改了区块链上的一些数据，我可以通过我的公钥向T4证明我是签名者——但是因为没有人知道我的私钥，所以没有人能为我伪造交易。</p></blockquote><p id="cadc" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">密码学很复杂，所以除非你是一个安全专家，你真的知道你在做什么，否则尝试在我们的应用前端自己管理用户的私钥可能不是一个好主意。</p><p id="0e32" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">但幸运的是，你不需要这样做——已经有服务为你处理这些了。其中最受欢迎的是<strong class="jw hu"> Metamask </strong>。</p><h1 id="751f" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">元掩码</h1><p id="3e62" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated"><a class="ae kq" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> Metamask </a>是Chrome和Firefox的浏览器扩展，允许用户安全地管理他们的以太坊账户和私钥，并使用这些账户与使用Web3.js的网站进行交互。(如果你以前没有使用过它，你肯定会想去安装它——那么你的浏览器是Web3启用的，现在你可以与任何与以太坊区块链通信的网站进行交互！).</p><p id="4ab9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">作为一名开发人员，如果你想让用户在他们的网络浏览器中通过一个网站与你的DApp进行交互(就像我们对CryptoZombies游戏所做的那样)，你肯定会想让它兼容Metamask。</p><blockquote class="ng nh ni"><p id="55a6" class="ju jv nb jw b jx jy iu jz ka kb ix kc nj ke kf kg nk ki kj kk nl km kn ko kp hm dt translated"><strong class="jw hu">注意</strong> : Metamask使用Infura的服务器作为web3提供商，就像我们上面做的一样——但是它也给用户选择他们自己的web3提供商的选项。所以通过使用Metamask的web3 provider，你给了用户一个选择的机会，你在应用程序中就少了一件需要担心的事情。</p></blockquote><h1 id="a242" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">使用Metamask的web3提供程序</h1><p id="5287" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">Metamask将他们的web3提供者注入到浏览器的全局JavaScript对象<code class="eh nd ne nf ms b">web3</code>中。所以你的应用程序可以检查<code class="eh nd ne nf ms b">web3</code>是否存在，以及它是否使用<code class="eh nd ne nf ms b">web3.currentProvider</code>作为它的提供者。</p><p id="14ff" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">以下是Metamask提供的一些模板代码，说明我们如何检测用户是否安装了Metamask，如果没有，告诉他们需要安装它才能使用我们的应用程序:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="eff5" class="mw ks ht ms b fv mx my l mz na">window.addEventListener('load', function() {</span><span id="d382" class="mw ks ht ms b fv nc my l mz na"><em class="nb">// Checking if Web3 has been injected by the browser (Mist/MetaMask)</em><br/>  if (typeof web3 !== 'undefined') {<br/>    <em class="nb">// Use Mist/MetaMask's provider</em><br/>    web3js = new Web3(web3.currentProvider);<br/>  } else {<br/>    <em class="nb">// Handle the case where the user doesn't have web3. Probably </em><br/>    <em class="nb">// show them a message telling them to install Metamask in </em><br/>    <em class="nb">// order to use our app.</em><br/>    // For example<br/>    // web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));<br/>  }</span><span id="60f8" class="mw ks ht ms b fv nc my l mz na">  <em class="nb">// Now you can start your app &amp; access web3js freely:</em><br/>  startApp()</span><span id="0aae" class="mw ks ht ms b fv nc my l mz na">})</span></pre><p id="5642" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">您可以在您创建的所有应用程序中使用此样本代码，以要求用户拥有元掩码才能使用您的DApp。</p><blockquote class="ng nh ni"><p id="0100" class="ju jv nb jw b jx jy iu jz ka kb ix kc nj ke kf kg nk ki kj kk nl km kn ko kp hm dt translated">注意:除了元掩码之外，您的用户可能还会使用其他私钥管理程序，例如web浏览器<strong class="jw hu"> Mist </strong>。然而，它们都实现了注入变量<code class="eh nd ne nf ms b">web3</code>的通用模式，所以我们在这里描述的用于检测用户的web3提供者的方法也适用于这些。</p></blockquote><h1 id="7798" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">2.与合同对话</h1><p id="3a38" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">现在我们已经用MetaMask的Web3 provider初始化了Web3.js，让我们设置它与我们的智能契约对话。</p><p id="e39f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">Web3.js需要两件东西来和你的合同对话:它的<strong class="jw hu">地址</strong>和它的<strong class="jw hu"> ABI </strong>。</p><h1 id="13e5" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">合同地址</h1><p id="7732" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">在您完成编写您的智能契约之后，您将编译它并将其部署到以太坊。我们将在下一课的<strong class="jw hu">中讲述<strong class="jw hu">部署</strong>，但是由于这是一个与编写代码完全不同的过程，我们决定打破顺序，先讲述Web3.js。</strong></p><p id="7948" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在你部署你的合同后，它会在以太坊上获得一个固定的地址，在那里它将永远存在。以太坊主网上CryptoKitties合约的地址是<code class="eh nd ne nf ms b">YOUR_CONTRACT_ADDRESS</code>。</p><p id="7112" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">您需要在部署后复制此地址，以便与您的smart contract对话。</p><h1 id="e857" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">合同ABI</h1><p id="9527" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">Web3.js需要和你的合同讨论的另一件事是它的ABI。</p><p id="6061" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">ABI代表应用程序二进制接口。基本上，它是JSON格式的契约方法的表示，告诉Web3.js如何以契约可以理解的方式格式化函数调用。</p><p id="92a0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">当您编译您的合同以部署到以太坊时，Solidity编译器将给您ABI，所以除了合同地址之外，您还需要复制并保存它。</p><h1 id="00e8" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">实例化Web3.js协定</h1><p id="90e0" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">一旦有了合同的地址和ABI，就可以在Web3中实例化它，如下所示:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="fa08" class="mw ks ht ms b fv mx my l mz na"><em class="nb">// Instantiate myContract</em><br/>var myContract = new web3js.eth.Contract(myABI, myContractAddress);</span></pre><h1 id="30a7" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">3.调用合同功能</h1><p id="d60d" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">我们的合同都准备好了！现在我们可以用Web3.js和它对话了。</p><p id="441d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">Web3.js有两个方法，我们将使用它们来调用契约中的函数:<code class="eh nd ne nf ms b">call</code>和<code class="eh nd ne nf ms b">send</code>。</p><h1 id="5dff" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">打电话</h1><p id="48bd" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated"><code class="eh nd ne nf ms b">call</code>用于<code class="eh nd ne nf ms b">view</code>和<code class="eh nd ne nf ms b">pure</code>功能。它只在本地节点上运行，不会在区块链上创建事务。</p><blockquote class="ng nh ni"><p id="53bd" class="ju jv nb jw b jx jy iu jz ka kb ix kc nj ke kf kg nk ki kj kk nl km kn ko kp hm dt translated"><strong class="jw hu">回顾:</strong> <code class="eh nd ne nf ms b">view</code>和<code class="eh nd ne nf ms b">pure</code>功能是只读的，不改变区块链的状态。它们也不消耗任何汽油，用户不会被提示与MetaMask签署交易。</p></blockquote><p id="7585" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">使用Web3.js，您将使用参数<code class="eh nd ne nf ms b">123</code>来<code class="eh nd ne nf ms b">call</code>一个名为<code class="eh nd ne nf ms b">myMethod</code>的函数，如下所示:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="19b4" class="mw ks ht ms b fv mx my l mz na">myContract.methods.myMethod(123).call()</span></pre><h1 id="e0d5" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">发送</h1><p id="c688" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated"><code class="eh nd ne nf ms b">send</code>将创建交易并更改区块链上的数据。对于任何不是<code class="eh nd ne nf ms b">view</code>或<code class="eh nd ne nf ms b">pure</code>的函数，你都需要使用<code class="eh nd ne nf ms b">send</code>。</p><blockquote class="ng nh ni"><p id="d7e2" class="ju jv nb jw b jx jy iu jz ka kb ix kc nj ke kf kg nk ki kj kk nl km kn ko kp hm dt translated"><strong class="jw hu">注:</strong> <code class="eh nd ne nf ms b">send</code> ing一笔交易会要求用户支付油费，并会弹出他们的Metamask提示他们签订交易。当我们使用Metamask作为我们的web3提供者时，这一切都在我们调用<code class="eh nd ne nf ms b">send()</code>时自动发生，我们不需要在代码中做任何特殊的事情。相当酷！</p></blockquote><p id="3c15" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">使用Web3.js，您将使用参数<code class="eh nd ne nf ms b">123</code>调用名为<code class="eh nd ne nf ms b">myMethod</code>的函数的<code class="eh nd ne nf ms b">send</code>事务如下:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="8f46" class="mw ks ht ms b fv mx my l mz na">myContract.methods.myMethod(123).send()</span></pre><p id="2790" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">语法与<code class="eh nd ne nf ms b">call()</code>几乎相同。</p><h1 id="7d6c" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">获取僵尸数据</h1><p id="12b2" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">现在让我们看一个使用<code class="eh nd ne nf ms b">call</code>访问合同数据的真实例子。</p><p id="b403" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们制作了僵尸阵列<code class="eh nd ne nf ms b">public</code>:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="7ad9" class="mw ks ht ms b fv mx my l mz na">Zombie[] public zombies<em class="nb">;</em></span></pre><p id="b8c6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在Solidity中，当你声明一个变量<code class="eh nd ne nf ms b">public</code>时，它会自动创建一个同名的公共“getter”函数。所以如果你想查找id为<code class="eh nd ne nf ms b">15</code>的僵尸，你会像调用函数一样调用它:<code class="eh nd ne nf ms b">zombies(15)</code>。</p><p id="d58c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">下面是我们如何在前端编写一个JavaScript函数，该函数接受一个僵尸id，在我们的契约中查询该僵尸，并返回结果:</p><blockquote class="ng nh ni"><p id="aa74" class="ju jv nb jw b jx jy iu jz ka kb ix kc nj ke kf kg nk ki kj kk nl km kn ko kp hm dt translated">注意:我们在本课中使用的代码使用的是Web3.js的<strong class="jw hu">1.0版</strong>，它使用承诺而不是回调。你将在网上看到的许多其他教程使用的是旧版本的web 3 . js。1.0版本的语法发生了很大变化，所以如果你从其他教程复制代码，请确保他们使用的是和你相同的版本！</p></blockquote><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="be01" class="mw ks ht ms b fv mx my l mz na">function getZombieDetails(id) {<br/>  return cryptoZombies.methods.zombies(id).call()<br/>}</span><span id="1173" class="mw ks ht ms b fv nc my l mz na"><em class="nb">// Call the function and do something with the result:</em><br/>getZombieDetails(15)<br/>.then(function(result) {<br/>  console.log("Zombie 15: " + JSON.stringify(result));<br/>});</span></pre><p id="0d20" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">让我们看看这里发生了什么。</p><p id="51c6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh nd ne nf ms b">cryptoZombies.methods.zombies(id).call()</code>将与Web3提供者节点通信，并告诉它从我们的契约上的<code class="eh nd ne nf ms b">Zombie[] public zombies</code>返回索引为<code class="eh nd ne nf ms b">id</code>的僵尸。</p><p id="b070" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">注意，这是<strong class="jw hu">异步</strong>，就像对外部服务器的API调用。所以Web3在这里返回一个承诺。(如果您不熟悉JavaScript promises……在继续之前，是时候做一些额外的功课了！)</p><p id="5b7a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">一旦承诺完成(这意味着我们从web3提供者那里得到了一个回答)，我们的示例代码继续执行<code class="eh nd ne nf ms b">then</code>语句，该语句将<code class="eh nd ne nf ms b">result</code>记录到控制台。</p><p id="3313" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh nd ne nf ms b">result</code>将会是一个如下所示的javascript对象:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="ddf3" class="mw ks ht ms b fv mx my l mz na">{<br/>  "name": "H4XF13LD MORRIS'S COOLER OLDER BROTHER",<br/>  "dna": "1337133713371337",<br/>  "level": "9999",<br/>  "readyTime": "1522498671",<br/>  "winCount": "999999999",<br/>  "lossCount": "0" // Obviously.<br/>}</span></pre><p id="1678" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">然后，我们可以用一些前端逻辑来解析这个对象，并以一种有意义的方式在前端显示它。</p><h1 id="7516" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">获取元掩码中的用户帐户</h1><p id="42e0" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">元掩码允许用户在其扩展中管理多个帐户。</p><p id="0f7d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们可以通过以下方式查看注入的<code class="eh nd ne nf ms b">web3</code>变量中哪个账户当前处于活动状态:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="fe58" class="mw ks ht ms b fv mx my l mz na">var userAccount = web3.eth.accounts[0]</span></pre><h1 id="e8b8" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt">…</h1><p id="3eea" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">现在让我们看看如何使用<code class="eh nd ne nf ms b">send</code>函数来更改智能合约上的数据。</p><p id="59ab" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">与<code class="eh nd ne nf ms b">call</code>功能有几个主要区别:</p><ol class=""><li id="406b" class="lo lp ht jw b jx jy ka kb kd lq kh lr kl ls kp lt lu lv lw dt translated"><code class="eh nd ne nf ms b">send</code>处理一个事务需要一个调用函数的<code class="eh nd ne nf ms b">from</code>地址(在你的安全代码中变成<code class="eh nd ne nf ms b">msg.sender</code>)。我们希望这是我们的DApp的用户，所以MetaMask将弹出提示他们签署交易。</li><li id="cd6a" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated"><code class="eh nd ne nf ms b">send</code> ing交易费气</li><li id="474c" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">从用户开始处理事务到该事务在区块链上实际生效会有很大的延迟。这是因为我们必须等待事务被包含在一个块中，而以太坊的块时间平均为15秒。如果以太坊上有很多未完成的交易，或者如果用户发送的天然气价格太低，我们的交易可能需要等待几个街区才能被包括在内，这可能需要几分钟。</li></ol><h1 id="16a9" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">4.调用应付款函数</h1><p id="14f0" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">在<code class="eh nd ne nf ms b">ZombieHelper</code>合同中，我们增加了一个付费功能，用户可以升级:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="9bbf" class="mw ks ht ms b fv mx my l mz na">function levelUp(uint _zombieId) external payable {<br/>  require(msg.value == levelUpFee);<br/>  zombies[_zombieId].level++;<br/>}</span></pre><p id="872a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">将以太和函数一起发送的方法很简单，但有一点需要注意:我们需要在<code class="eh nd ne nf ms b">wei</code>中指定发送多少，而不是以太。</p><h1 id="0fb6" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">魏是什么？</h1><p id="f93d" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">A <code class="eh nd ne nf ms b">wei</code>是以太的最小子单位——一个<code class="eh nd ne nf ms b">ether</code>中有10^18 <code class="eh nd ne nf ms b">wei</code>。</p><p id="ed42" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这需要数很多个零——但幸运的是，Web3.js有一个转换实用程序可以帮我们做到这一点。</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="c1b2" class="mw ks ht ms b fv mx my l mz na"><em class="nb">// This will convert 1 ETH to Wei</em><br/>web3js.utils.toWei("1", "ether");</span></pre><p id="2690" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在我们的DApp中，我们设置了<code class="eh nd ne nf ms b">levelUpFee = 0.001 ether</code>，所以当我们调用我们的<code class="eh nd ne nf ms b">levelUp</code>函数时，我们可以使用下面的代码让用户发送<code class="eh nd ne nf ms b">0.001</code>乙醚:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="7b65" class="mw ks ht ms b fv mx my l mz na">CryptoZombies.methods.levelUp(zombieId)<br/>.send({ from: userAccount, value: web3js.utils.toWei("0.001", "ether") })</span></pre><h1 id="3ab9" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">5.订阅事件</h1><p id="29f5" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">正如你所看到的，通过Web3.js与你的合同交互是非常简单的——一旦你设置好了你的环境，函数和事务与普通的web API并没有什么不同。</p><p id="badc" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们还想介绍一个方面——从您的合同中订阅事件。</p><h1 id="9be9" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">监听新的僵尸</h1><p id="e482" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">从<code class="eh nd ne nf ms b">zombiefactory.sol</code>开始，我们有一个名为<code class="eh nd ne nf ms b">NewZombie</code>的事件，每当一个新的僵尸被创造出来，我们就触发这个事件:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="3849" class="mw ks ht ms b fv mx my l mz na">event NewZombie(uint zombieId, string name, uint dna);</span></pre><p id="8095" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在Web3.js中，您可以<strong class="jw hu">订阅</strong>一个事件，这样您的web3 provider每次触发时都会在您的代码中触发一些逻辑:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="66ff" class="mw ks ht ms b fv mx my l mz na">cryptoZombies.events.NewZombie()<br/>.on("data", function(event) {<br/>  let zombie = event.returnValues;<br/>  <em class="nb">// We can access this event's 3 return values on the `event.returnValues` object:</em><br/>  console.log("A new zombie was born!", zombie.zombieId, zombie.name, zombie.dna);<br/>}).on("error", console.error);</span></pre><p id="28ba" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">请注意，这将在我们的DApp中每次创建任何僵尸时触发警报——不仅仅是针对当前用户。如果我们只想要当前用户的警报会怎么样？</p><h1 id="268d" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">使用<code class="eh nd ne nf ms b">indexed</code></h1><p id="6a02" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">为了过滤事件并只监听与当前用户相关的变化，我们的Solidity契约必须使用<code class="eh nd ne nf ms b">indexed</code>关键字，就像我们在ERC721实现的<code class="eh nd ne nf ms b">Transfer</code>事件中所做的那样:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="9e97" class="mw ks ht ms b fv mx my l mz na">event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span></pre><p id="ea1d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在这种情况下，因为<code class="eh nd ne nf ms b">_from</code>和<code class="eh nd ne nf ms b">_to</code>是<code class="eh nd ne nf ms b">indexed</code>，这意味着我们可以在前端的事件监听器中过滤它们:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="7266" class="mw ks ht ms b fv mx my l mz na"><em class="nb">// Use `filter` to only fire this code when `_to` equals `userAccount`</em><br/>cryptoZombies.events.Transfer({ <strong class="ms hu">filter: { _to: userAccount</strong> } })<br/>.on("data", function(event) {<br/>  let data = event.returnValues;<br/>  <em class="nb">// The current user just received a zombie!</em><br/>  <em class="nb">// Do something here to update the UI to show it</em><br/>}).on("error", console.error);</span></pre><p id="4d81" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">正如你所看到的，使用<code class="eh nd ne nf ms b">event</code> s和<code class="eh nd ne nf ms b">indexed</code>字段是一种非常有用的做法，可以监听你的合同的变化，并在你的应用程序的前端反映出来。</p><h1 id="1c79" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">查询过去的事件</h1><p id="4661" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">我们甚至可以使用<code class="eh nd ne nf ms b">getPastEvents</code>查询过去的事件，并使用过滤器<code class="eh nd ne nf ms b">fromBlock</code>和<code class="eh nd ne nf ms b">toBlock</code>给Solidity一个事件日志的时间范围(本例中的“块”指以太坊块号):</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="352b" class="mw ks ht ms b fv mx my l mz na">cryptoZombies.<strong class="ms hu">getPastEvents("NewZombie", { fromBlock: 0, toBlock: "latest" })</strong><br/>.then(function(events) {<br/>  <em class="nb">// `events` is an array of `event` objects that we can iterate, like we did above</em><br/>  <em class="nb">// This code will get us a list of every zombie that was ever created</em><br/>});</span></pre><p id="c930" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">因为您可以使用这种方法来查询事件日志，这提供了一个有趣的用例:<strong class="jw hu">使用事件作为一种更便宜的存储形式</strong>。</p><p id="c275" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果您还记得，将数据保存到区块链是Solidity中最昂贵的操作之一。但是使用事件在汽油方面要便宜得多。</p><p id="ab8b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这里的权衡是事件不能从智能协定本身内部读取。但是，如果您想要将一些数据历史记录在区块链上，以便可以从应用程序的前端读取，那么这是一个需要记住的重要用例。</p><p id="c2ae" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">例如，我们可以将此作为僵尸战斗的历史记录——我们可以为每次一个僵尸攻击另一个僵尸以及谁赢了创建一个事件。智能合约不需要这些数据来计算任何未来的结果，但它是用户能够从应用程序的前端浏览的有用数据。</p><h1 id="088e" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">Web3.js事件和元掩码</h1><p id="5d6f" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">我们上面刚刚描述的语法来自Web3.js的最新1.0版本，它使用<strong class="jw hu"> WebSockets </strong>来订阅事件。</p><p id="9c50" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">然而，MetaMask还不支持最新的事件API(尽管他们正在积极地工作——检查这个<a class="ae kq" href="https://github.com/MetaMask/metamask-extension/issues/3642" rel="noopener ugc nofollow" target="_blank"> github问题</a>的更新)(MetaMask版本4.5.1)</p><p id="39e3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">所以现在我们必须使用一个单独的Web3 provider，它专门为事件支持WebSockets。我们可以使用Infura实例化第二个副本，如下所示:</p><pre class="jj jk jl jm fq mr ms mt mu aw mv dt"><span id="95f5" class="mw ks ht ms b fv mx my l mz na">var web3Infura = new Web3(new Web3.providers.WebsocketProvider("wss://mainnet.infura.io/ws"));<br/>var czEvents = new web3Infura.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);</span></pre><p id="760b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">然后我们将使用<code class="eh nd ne nf ms b">czEvents.events.Transfer</code>而不是<code class="eh nd ne nf ms b">cryptoZombies.events.Transfer</code>来监听事件。我们仍将使用<code class="eh nd ne nf ms b">cryptoZombies.methods</code>来表示我们在本课中涉及的所有内容。</p><p id="a71b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">将来，当MetaMask更新他们的API以支持Web3.js 1.0时，这将是不必要的——但现在，如果我们想开始使用更好的Web3.js 1.0语法来订阅事件，这是一个必要的权宜之计。</p><blockquote class="mc"><p id="52ba" class="md me ht bd mf mg nm nn no np nq kp ek translated">加入Coinmonks <a class="ae kq" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae kq" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae kq" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="mw ks ht bd kt nr ns nt kx nu nv nw lb kd nx ny ld kh nz oa lf kl ob oc lh od dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="lo lp ht jw b jx lj ka lk kd oe kh of kl og kp oh lu lv lw dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae kq" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp oh lu lv lw dt translated"><a class="ae kq" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae kq" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp oh lu lv lw dt translated"><a class="ae kq" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae kq" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp oh lu lv lw dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae kq" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp oh lu lv lw dt translated">开发人员的最佳加密API</li><li id="b359" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp oh lu lv lw dt translated">最佳<a class="ae kq" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp oh lu lv lw dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li></ul></div></div>    
</body>
</html>