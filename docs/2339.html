<html>
<head>
<title>Implementing PBFT in Blockchain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在区块链中实现PBFT</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/implementing-pbft-in-blockchain-12368c6c9548?source=collection_archive---------0-----------------------#2019-08-05">https://medium.com/coinmonks/implementing-pbft-in-blockchain-12368c6c9548?source=collection_archive---------0-----------------------#2019-08-05</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="562e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本文中，我们将了解区块链系统中实用拜占庭容错的工作原理、该算法背后的数学原理及其意义，编写其伪代码，然后在node.js中实现它</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/f157ab6e1d552e56cc58731ee50d4a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-Ctq47XiGRajDJ5UKTeyQ.jpeg"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Source: <a class="ae ke" href="https://unsplash.com/photos/_d0zgyMmYT8" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c2e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">声明者:这篇文章不是关于区块链的教程。假设读者对区块链/比特币有足够的了解。</p><p id="fba2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="kf">在谈论PBFT之前，让我们先了解一些围绕它的术语。</em> </strong></p><h1 id="3938" class="kg kh ht bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">容错和容错系统</h1><p id="1fe5" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated">想象一下，你的汽车的发动机发生了故障，但它仍然工作，然而，汽车的速度大大降低了，我们称之为容错汽车，它表现出容错特性。</p><blockquote class="lj"><p id="2882" class="lk ll ht bd lm ln lo lp lq lr ls jn ek translated">任何系统在未知或已知故障的影响下继续运行，导致系统容量降低，可以称为容错系统，它表现出容错特性。</p></blockquote><p id="ff74" class="pw-post-body-paragraph iq ir ht is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hm dt translated">与其他系统不同，容错系统在故障发生时不会崩溃，相反，即使存在故障，系统也能运行，但吞吐量降低或等待时间延长。</p><h1 id="794b" class="kg kh ht bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">拜占庭容错</h1><p id="e2c8" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated">拜占庭故障尤其存在于分布式系统中。这些故障是系统节点间错误信息的结果。分布式系统的成员大多不知道这些故障/错误信息的原因。因此，在这种情况下，节点可能行为异常，并向网络中的不同节点发送不同的响应，结果，很难将该节点分类为恶意或有故障的。因此，为了做出关于故障节点的决定，系统的诚实节点达成共识，并且可以得出不受恶意/故障节点影响的结论的系统可以被认为是拜占庭容错系统。</p><blockquote class="lj"><p id="a31a" class="lk ll ht bd lm ln lo lp lq lr ls jn ek translated">展现拜占庭容错的系统解决了<a class="ae ke" rel="noopener" href="/all-things-ledger/the-byzantine-generals-problem-168553f31480">拜占庭将军问题</a>中提出的问题。</p></blockquote><p id="4eff" class="pw-post-body-paragraph iq ir ht is b it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn hm dt translated">拜占庭容错不是识别有故障的/恶意的并找出问题，而是继续等同于当系统中没有成员有故障时的情况运行。(<em class="kf">吞吐量和效率会因此降低)</em></p><p id="7568" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们潜入PBFT。T13】</p></div><div class="ab cl ly lz hb ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hm hn ho hp hq"><h1 id="cb83" class="kg kh ht bd ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld dt translated">实用拜占庭容错</h1><p id="f655" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated"><a class="ae ke" href="http://pmg.csail.mit.edu/papers/osdi99.pdf" rel="noopener ugc nofollow" target="_blank"> Castro和Liskov </a>开发了一种在分布式系统中实现一致性的新方法，该方法可以通过复制节点/状态机来容忍故障/恶意节点。但是PBFT只能容忍这样的节点，直到故障节点的数量少于所有节点的三分之一。网络中的节点通过在彼此之间传递关于决策的消息来达成关于决策的共识。诚实节点越多，系统越安全。由于同意正确决策的诚实节点的数量多于同意错误决策的错误/恶意节点的数量，所以错误信息将被大多数拒绝。</p><blockquote class="lj"><p id="2fad" class="lk ll ht bd lm ln lo lp lq lr ls jn ek translated">为了保持系统安全，pbft需要系统中有3f+1个节点，其中f是系统可以容忍的故障节点的最大数量。因此，对于要做出任何决定的节点组，需要来自2f+1节点的批准。</p></blockquote><figure class="ml mm mn mo mp jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mk"><img src="../Images/65156d9f70a96634821a993acf423098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OM0KOzQHMErLVCSLG2OM4g.jpeg"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Photo by Adam Kool</figcaption></figure><h1 id="5643" class="kg kh ht bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">区块链中的PBFT</h1><p id="1386" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated">区块链的实用拜占庭容错算法继承了分布式系统中的许多概念。在这种情况下，达成共识以决定块的有效性。</p><p id="96e6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">系统中的节点在彼此之间共享消息，以将块提交给链。在这种情况下，恶意节点可能会广播被篡改的块，因此，被最大数量的节点视为有效的块被整个网络视为整体有效。</p><h2 id="f1ba" class="mq kh ht bd ki mr ms mt km mu mv mw kq jb mx my ku jf mz na ky jj nb nc lc nd dt translated">PBFT的意义</h2><p id="869e" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated">在比特币(工作证明)中，大宗提议者是最快的矿工，而在股权证明中，大宗提议者是最富有的矿工。在PBFT，区块创建者可能不是任何特殊的采矿者，但提交给链的提议区块将是最同意的区块。从而达到与PoW和PoS相同的目的，即将一个新的块添加到链中。</p><h2 id="7dbd" class="mq kh ht bd ki mr ms mt km mu mv mw kq jb mx my ku jf mz na ky jj nb nc lc nd dt translated">状态和消息</h2><p id="4c7c" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated">本节描述了不同会话中每个节点的各种状态，以及在任何一轮数据块建议期间节点之间传递的不同消息:</p><ul class=""><li id="482e" class="ne nf ht is b it iu ix iy jb ng jf nh jj ni jn nj nk nl nm dt translated"><code class="eh nn no np nq b">NEW ROUND</code>:提议人发送新的整体提议。验证器等待<code class="eh nn no np nq b">PRE-PREPARE</code>消息。</li><li id="9212" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><code class="eh nn no np nq b">PRE-PREPARED</code>:验证器收到<code class="eh nn no np nq b">PRE-PREPARE</code>消息，广播<code class="eh nn no np nq b">PREPARE</code>消息。然后等待<code class="eh nn no np nq b">PREPARE</code>或<code class="eh nn no np nq b">COMMIT</code>消息中的<code class="eh nn no np nq b">2F + 1</code>。</li><li id="88c0" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><code class="eh nn no np nq b">PREPARED</code>:验证器接收到<code class="eh nn no np nq b">PREPARE</code>条消息中的<code class="eh nn no np nq b">2F + 1</code>条，并广播<code class="eh nn no np nq b">COMMIT</code>条消息。然后等待<code class="eh nn no np nq b">COMMIT</code>消息中的<code class="eh nn no np nq b">2F + 1</code>。</li><li id="ce89" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><code class="eh nn no np nq b">COMMITTED</code>:验证器已经接收到<code class="eh nn no np nq b">COMMIT</code>消息的<code class="eh nn no np nq b">2F + 1</code>，并且能够将建议的块插入到区块链中。</li><li id="778e" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><code class="eh nn no np nq b">FINAL COMMITTED</code>:新块成功插入区块链，验证机准备好下一轮。</li><li id="f4e5" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><code class="eh nn no np nq b">ROUND CHANGE</code>:验证器正在等待同一个建议轮数上的<code class="eh nn no np nq b">ROUND CHANGE</code>条消息中的<code class="eh nn no np nq b">2F + 1</code></li></ul><p id="3762" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kf">注:这些状态已从GitHub上的本</em> <a class="ae ke" href="https://github.com/ethereum/EIPs/issues/650" rel="noopener ugc nofollow" target="_blank"> <em class="kf">期</em> </a> <em class="kf">中引用。</em></p><h2 id="397d" class="mq kh ht bd ki mr ms mt km mu mv mw kq jb mx my ku jf mz na ky jj nb nc lc nd dt translated">算法</h2><p id="da8b" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated"><code class="eh nn no np nq b">NEW ROUND</code></p><ul class=""><li id="6b2b" class="ne nf ht is b it iu ix iy jb ng jf nh jj ni jn nj nk nl nm dt translated">提名者以循环方式选出。</li><li id="57bc" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated">提议者从事务池中收集事务。</li><li id="d681" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated">提议者创建一个块提议并将其广播到网络。提议者的状态现在变为<code class="eh nn no np nq b">PRE-PERPARED</code>状态。</li><li id="46ae" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated">验证器接收到<code class="eh nn no np nq b">PRE-PREPARE</code>消息并进入<code class="eh nn no np nq b">PRE-PREPARED</code>状态。</li><li id="5372" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated">验证器现在验证提议，然后向其他验证器广播一条<code class="eh nn no np nq b">PREPARE</code>消息。</li></ul><p id="b0e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh nn no np nq b">PRE-PREPARED</code></p><ul class=""><li id="4bef" class="ne nf ht is b it iu ix iy jb ng jf nh jj ni jn nj nk nl nm dt translated">验证器等待<code class="eh nn no np nq b">2F+1</code>有效的<code class="eh nn no np nq b">PREPARE</code>消息，然后进入<code class="eh nn no np nq b">PREPARED</code>状态。</li><li id="5577" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated">验证器现在在进入<code class="eh nn no np nq b">PREPAPRED</code>状态时广播<code class="eh nn no np nq b">COMMIT</code>消息。</li></ul><p id="edea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh nn no np nq b">PREPARED</code></p><ul class=""><li id="461e" class="ne nf ht is b it iu ix iy jb ng jf nh jj ni jn nj nk nl nm dt translated">验证器等待<code class="eh nn no np nq b">2F+1</code>提交消息，然后进入<code class="eh nn no np nq b">COMMITTED</code>状态。</li></ul><p id="696f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh nn no np nq b">COMMITTED</code></p><ul class=""><li id="af35" class="ne nf ht is b it iu ix iy jb ng jf nh jj ni jn nj nk nl nm dt translated">验证器将收到的<code class="eh nn no np nq b">2F+1</code>提交消息添加到块中，并将该块添加到区块链中。</li><li id="ca73" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated">当块被插入到链中时，验证器现在移动一个<code class="eh nn no np nq b">FINAL COMMITED</code>状态</li></ul><p id="43a7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh nn no np nq b">FINAL COMMITTED</code></p><ul class=""><li id="3cb9" class="ne nf ht is b it iu ix iy jb ng jf nh jj ni jn nj nk nl nm dt translated">新的一轮开始了新的提议者选举。</li></ul><h2 id="df10" class="mq kh ht bd ki mr ms mt km mu mv mw kq jb mx my ku jf mz na ky jj nb nc lc nd dt translated">伪代码</h2><p id="cea1" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated">本节介绍上述算法的伪代码:</p><pre class="jp jq jr js fq nw nq nx ny aw nz dt"><span id="00e7" class="mq kh ht nq b fv oa ob l oc od">// NEW_ROUND:</span><span id="afae" class="mq kh ht nq b fv oe ob l oc od">State = NEW_ROUND<br/>proposer = get_proposers_address( blockchain )<br/>if ( current_validator == proposer )<br/>    block = create_block( transaction_pool )<br/>    broadcast_block( block )<br/>    State = PRE_PREPARED</span><span id="3edd" class="mq kh ht nq b fv oe ob l oc od">// PRE_PREPARED:</span><span id="39f0" class="mq kh ht nq b fv oe ob l oc od">ON message.type == PRE_PREPARE<br/>    verify_block( message.block )<br/>    verify_validator( message.block )<br/>    broadcast_prepare( message.block )<br/>    State = PREPARED</span><span id="b462" class="mq kh ht nq b fv oe ob l oc od">// PREPARED:</span><span id="d4c0" class="mq kh ht nq b fv oe ob l oc od">ON message.type == PREPARE<br/>    verify_prepare( message.prepare )<br/>    verify_validator( message.prepare )<br/>    prepare_pool.add( message.prepare )</span><span id="0f49" class="mq kh ht nq b fv oe ob l oc od">if ( prepare_pool.length &gt; 2F+1 )<br/>        broadcast_commit( message.prepare )<br/>    <br/>    State = COMMITTED</span><span id="7e1e" class="mq kh ht nq b fv oe ob l oc od">// COMMITTED:</span><span id="545c" class="mq kh ht nq b fv oe ob l oc od">ON message.type == COMMIT<br/>    verify_commit( message.commit )<br/>    verify_validator( message.commit )<br/>    commit_pool.add( message.commit )</span><span id="5f46" class="mq kh ht nq b fv oe ob l oc od">if ( commit_pool.length &gt; 2F+1 )<br/>        commit_list = commit_pool.get_commits()<br/>        block.append( commit_list )<br/>        blockchain.append( block )<br/>    <br/>    State = FINAL_COMMITTED</span><span id="7dfd" class="mq kh ht nq b fv oe ob l oc od">// FINAL_COMMITTED:</span><span id="0c14" class="mq kh ht nq b fv oe ob l oc od">new_round()</span></pre><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff of"><img src="../Images/ea25527c9edac71361634790d78199b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyddDf41B0RBwrkNiIeUaA.jpeg"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Photo by Luca Bravo</figcaption></figure><h2 id="0ae3" class="mq kh ht bd ki mr ms mt km mu mv mw kq jb mx my ku jf mz na ky jj nb nc lc nd dt translated">图解说明</h2><p id="d5b0" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated">为了更好地理解，本节将图解说明该算法:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff og"><img src="../Images/b9ea91738671a13564092a2db4b9dcde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*7S3-x4YDPdLeGXKlS5Ql2g.jpeg"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Before a new round begins, transactions are broadcasted among nodes so that all the nodes have the same transactions in their pool. After a sufficient number of transactions in their pool, these nodes start a new round.</figcaption></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff oh"><img src="../Images/cc091c1aad15e8211f3c1ba3eab58343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*11uZVWGtIdhf5CYN-7CL-A.jpeg"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">A proposer is chosen in a round-robin fashion. Node 8 becomes the proposer and rest of the nodes agree upon on it. The proposer sends a PRE-PREPARE message and each node enters PRE-PREPARED state.</figcaption></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff og"><img src="../Images/2afde711cef2efdddad861eedb2d0b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*oxQQyuq4Q3SsyMkq1b4-6w.jpeg"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">The proposer broadcasted a PRE-PREPARE message, which contains a proposed block. The rest of the nodes broadcast this message to other nodes.</figcaption></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff og"><img src="../Images/5cbd3564b12df0cb047b9adbde17c9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*EvnTOhz18j7Ph2zqzbSIoQ.jpeg"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Each node sends a PREPARE message if they agree upon the proposed block. After 2F+1 such messages, nodes change state to PREPARED.</figcaption></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff og"><img src="../Images/75bf89f235d81a5caa5c7cdbc068b8c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*tbDIgp827aUb8o58FwrPUg.jpeg"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Prepared nodes send COMMIT messages to each other, upon 2F+1 commits, nodes move to COMMIT state and add the block to the chain. After adding the block they move to the FINAL COMMITTED state.</figcaption></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff og"><img src="../Images/37689e8d3ffc5d7b9753644ad3069813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*JdMbNjMj8sijx1AbEU37ug.jpeg"/></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">After FINAL COMMITTED, nodes calculate a new proposer.</figcaption></figure></div><div class="ab cl ly lz hb ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hm hn ho hp hq"><h1 id="3074" class="kg kh ht bd ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld dt translated">PBFT的数学证明</h1><blockquote class="lj"><p id="383f" class="lk ll ht bd lm ln lo lp lq lr ls jn ek translated">在实际的拜占庭容错中，如果N=3F+1，一个N节点系统可以容忍F个故障节点。</p><p id="4387" class="lk ll ht bd lm ln lo lp lq lr ls jn ek translated">在一个实际的拜占庭容错系统中，每个决策都需要2F+1批准，其中包括故障节点。</p></blockquote><figure class="ml mm mn mo mp jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff oi"><img src="../Images/1142a6e25fa911db51ab2f5d8a9bb446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gOfSzYSTwLOGTQNDndsqTw.jpeg"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Photo by Aaron Burden</figcaption></figure><p id="cab5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们现在将从数学上证明上述两个定义，它们是互为因果的。下面的计算是斯坦福大学<a class="ae ke" href="http://www.scs.stanford.edu/14au-cs244b/notes/pbft.txt" rel="noopener ugc nofollow" target="_blank">笔记</a>中的数学简化。</p><blockquote class="oj ok ol"><p id="1b5e" class="iq ir kf is b it iu iv iw ix iy iz ja om jc jd je on jg jh ji oo jk jl jm jn hm dt translated">分布式系统的两个重要特性是活性和安全性。</p></blockquote><h2 id="29d2" class="mq kh ht bd ki mr ms mt km mu mv mw kq jb mx my ku jf mz na ky jj nb nc lc nd dt translated">活性</h2><p id="efc8" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated">当系统继续运行时，活跃度是在分布式系统的上下文中使用的术语。这意味着即使出现一些错误，系统也不会停止运行，并且会正常工作。在区块链的情况下，活性意味着系统将继续向链中添加新的数据块，并且系统在任何时间点都不会停止工作。</p><h2 id="604b" class="mq kh ht bd ki mr ms mt km mu mv mw kq jb mx my ku jf mz na ky jj nb nc lc nd dt translated">安全</h2><p id="0906" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated">当系统收敛于单个决策时，安全是在分布式系统的上下文中使用的术语。在分布式系统中，节点可能会分成两个决策或进一步分裂，分布式系统的安全性确保了即使存在故障节点，网络也会以跨所有诚实节点的单个决策结束。</p><h2 id="8815" class="mq kh ht bd ki mr ms mt km mu mv mw kq jb mx my ku jf mz na ky jj nb nc lc nd dt translated">证明</h2><p id="f992" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated"><strong class="is hu">非拜占庭式的失败</strong></p><p id="cd5c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kf">给定网络中的</em> <strong class="is hu"> <em class="kf"> N </em> </strong> <em class="kf">个节点，有</em> <strong class="is hu"> <em class="kf"> f </em> </strong> <em class="kf">个故障节点，保证活跃度和安全性所需的法定人数</em> <strong class="is hu"> <em class="kf"> Q </em> </strong> <em class="kf">是多少？</em></p><blockquote class="oj ok ol"><p id="e0b1" class="iq ir kf is b it iu iv iw ix iy iz ja om jc jd je on jg jh ji oo jk jl jm jn hm dt translated">法定人数是指网络正常运行和做出有效决策所需的最少节点数。仲裁由诚实节点组成。</p></blockquote><p id="4d00" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="kf">活跃度</em> </strong></p><p id="ca56" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了避免网络停止，必须存在至少一个非故障节点。</p><p id="291a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kf">因此，对于活性:</em></p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff op"><img src="../Images/043d55239afe3ca95e8a0568c2517b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*jJ1Yv0zFPsgkXVsXmhlSxA.png"/></div></figure><p id="e33c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="kf">安全</em> </strong></p><p id="0296" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了避免网络分裂成多个决策，多数人应该出席。因为我们需要一个诚实的多数，法定人数应该大于节点总数的一半，以使决策对我们有利。</p><p id="603f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kf">因此为了安全起见:</em></p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff oq"><img src="../Images/2b67cec5d7e0fd9ff816382befeeb662.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*z7ZcjU1LUQYWN-hUay9-Dw.png"/></div></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff or"><img src="../Images/7649a13c9481fe7443c67d70273a84a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*CKfe2vCLiwacaWuVe3cuCw.png"/></div></figure><p id="0749" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通过结合我们得到的两个条件，</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff os"><img src="../Images/e9c4ad9026eade4d3ca7fc747b7c5ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*mBC235IOsDXQOKqAiXh7rg.png"/></div></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff ot"><img src="../Images/d0f687c8c45ec2d4857e1dfea725d272.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*qjQkuDACs_yMKhc6-MEHFA.png"/></div></figure><p id="202d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kf">因此</em>，<em class="kf">为非拜占庭故障</em></p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff ou"><img src="../Images/dee7ee1e199c8344ccfe55cce298ffef.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*va8lSCe8nTI8bJt3uJDEUA.png"/></div></figure><p id="3808" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">拜占庭失败</strong></p><p id="0b8f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kf">给定网络中的N个节点，其中f个故障节点可能经历拜占庭式的故障，保证活性和安全性所需的法定人数Q是多少？</em></p><blockquote class="oj ok ol"><p id="9aed" class="iq ir kf is b it iu iv iw ix iy iz ja om jc jd je on jg jh ji oo jk jl jm jn hm dt translated">经历拜占庭失败节点可以投票支持无效的块或决策，导致决策的分裂，结果是分叉。</p></blockquote><p id="6b5f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">活性<em class="kf">活性</em>活性</strong></p><p id="7a0c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了避免网络停止，必须存在至少一个非故障节点或仲裁。因为拜占庭节点可能不会回复。</p><p id="ff25" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kf">因此，对于活性:</em></p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff op"><img src="../Images/043d55239afe3ca95e8a0568c2517b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*jJ1Yv0zFPsgkXVsXmhlSxA.png"/></div></figure><p id="b384" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="kf">安全</em> </strong></p><p id="c7a5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了避免网络分裂成多个决策，多数人应该出席。然而，与非拜占庭故障不同，拜占庭故障中的节点也可以投票，因此我们也需要在投票过程中考虑故障节点。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff oq"><img src="../Images/2b67cec5d7e0fd9ff816382befeeb662.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*z7ZcjU1LUQYWN-hUay9-Dw.png"/></div></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff or"><img src="../Images/7649a13c9481fe7443c67d70273a84a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*CKfe2vCLiwacaWuVe3cuCw.png"/></div></figure><p id="0276" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该等式提供了网络中可能出现的故障节点的最大数量。</p><p id="0943" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kf">因此为了安全起见，也可以写成:</em></p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff ov"><img src="../Images/784e866b2887b6cdf9f2c7a8ecba6cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*2IVPQlKAXma8M0WihLR_QA.png"/></div></figure><p id="69eb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kf">其中f是可容忍故障节点的最大数量。</em></p><p id="d71d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通过结合这两个条件，我们得到</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff ow"><img src="../Images/c9f6e9b633e7fab334e4bf963c154a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*J1-R66bBrTiuXayUXyzXwA.png"/></div></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff ox"><img src="../Images/4ffcab695892ac999a6d1c6f66e12a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*ZnhyWUcbbbaoznmnBRLgJw.png"/></div></figure><p id="c798" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kf">因此，对于拜占庭式的失败</em></p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff oy"><img src="../Images/0013ffa716b3aee6709d3969b838227e.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*uJlYz0sB0LxyI4zxzn9ylg.png"/></div></figure></div><div class="ab cl ly lz hb ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hm hn ho hp hq"><h1 id="095d" class="kg kh ht bd ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld dt translated">PBFT在Node.js中的实现</h1><p id="e774" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated">在本节中，我们将实现一个以PBFT为共识算法的区块链。可能需要注意的是，这个区块链不会使用加密货币，但如果我们使用帐户模型，就可以使用。此外，PBFT只能在许可的环境下运行，因为它容易受到Sybil攻击，网络的成员必须是已知的。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff oz"><img src="../Images/2da260426c22189e2a44cf61fb4f3af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HItcyUcWWnuqDzKgNCoprw.jpeg"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Photo by Jeremy Bishop</figcaption></figure><h2 id="5815" class="mq kh ht bd ki mr ms mt km mu mv mw kq jb mx my ku jf mz na ky jj nb nc lc nd dt translated">先决条件</h2><ol class=""><li id="52b4" class="ne nf ht is b it le ix lf jb pa jf pb jj pc jn pd nk nl nm dt translated">节点. js</li><li id="a986" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">邮递员</li><li id="0bc5" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">VS代码</li><li id="0be2" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">关于区块链概念的知识</li></ol><h2 id="8892" class="mq kh ht bd ki mr ms mt km mu mv mw kq jb mx my ku jf mz na ky jj nb nc lc nd dt translated">建筑和设计</h2><p id="ec23" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated">为了实施PBFT，我们将开发以下组件:</p><ol class=""><li id="d531" class="ne nf ht is b it iu ix iy jb ng jf nh jj ni jn pd nk nl nm dt translated">钱包类—用于公钥和签名数据。</li><li id="4bd1" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">事务处理类-创建事务处理并验证它们。</li><li id="66e5" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">块类-创建块、验证块和验证块的提议者。</li><li id="d870" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">区块链类——创建链、添加区块、计算提议者、验证区块、更新区块。</li><li id="a1fe" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">P2p服务器类——在对等点之间广播和接收数据。</li><li id="600a" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">验证器—生成并验证验证器</li><li id="9bad" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">事务池、阻塞池、提交池、准备池和消息池—分别存储事务、阻塞、提交、准备和新一轮消息。</li><li id="2f6e" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">App用于与区块链交互的Express API</li><li id="a88d" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">配置—存储全局变量</li><li id="5056" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">链实用程序—存储常见的功能，如散列和验证签名。</li></ol><h2 id="fa41" class="mq kh ht bd ki mr ms mt km mu mv mw kq jb mx my ku jf mz na ky jj nb nc lc nd dt translated">密码</h2><p id="f7b4" class="pw-post-body-paragraph iq ir ht is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hm dt translated">创建一个根目录<code class="eh nn no np nq b"><strong class="is hu">pbft</strong></code>并放入cd。这个项目中的所有文件都在根目录中。</p><pre class="jp jq jr js fq nw nq nx ny aw nz dt"><span id="7d35" class="mq kh ht nq b fv oa ob l oc od">mkdir pbft &amp;&amp; cd pbft</span></pre><p id="bc2f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">chain util类</strong></p><p id="cd68" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将从创建一个将在这个项目中多次使用的<code class="eh nn no np nq b">chain-util.js</code>文件开始。该文件将用于创建密钥对，以便对数据进行签名，为交易生成id，对数据进行哈希处理以及验证签名。</p><p id="e0ec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们需要三个模块来执行这些功能。因此，我们需要安装它们。</p><pre class="jp jq jr js fq nw nq nx ny aw nz dt"><span id="437a" class="mq kh ht nq b fv oa ob l oc od">npm i --save elliptic uuid crypto-js</span></pre><p id="6045" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">创建一个类<code class="eh nn no np nq b">ChainUtil</code>并导出它。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="595b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">交易类别</strong></p><p id="dc7d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，我们将创建一个事务类。在项目文件夹中创建文件<code class="eh nn no np nq b">transaction.js</code>。本项目中的交易将包含以下属性:</p><ol class=""><li id="d4b4" class="ne nf ht is b it iu ix iy jb ng jf nh jj ni jn pd nk nl nm dt translated">id —用于识别</li><li id="a51d" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">发件人—发件人地址</li><li id="a8f8" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">输入—进一步包含要存储的数据和时间戳的对象</li><li id="57d5" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">哈希-输入的SHA256</li><li id="2bf4" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">签名—由发件人签名的哈希</li></ol><p id="d0f7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在文件中创建一个类<code class="eh nn no np nq b">Transaction</code>并将其导出。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="9b0d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">钱包类</strong></p><p id="b358" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来是钱包。钱包保存公钥和密钥对。它还负责签名数据散列和创建签名的事务。</p><p id="f302" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在项目目录中创建一个文件<code class="eh nn no np nq b">wallet.js</code>。添加一个类<code class="eh nn no np nq b">Wallet</code>并导出它。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="54cd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">验证器类</strong></p><p id="7970" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于PBFT是一个许可的区块链共识算法，我们需要存储每个节点系统中所有节点的地址。我们可以手动选择一个秘密，创建一个钱包，获取它的公钥，并将这个密钥存储到一个文件中，当我们运行我们的项目时，它会读取这个文件中的密钥。</p><p id="7bd9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是我们可以通过创建一个类并添加一个可以返回N个节点的公钥列表的函数来实现自动化，而不是手动完成。</p><p id="0cf4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将创建一个<code class="eh nn no np nq b">Validator</code>类，它将生成一个每个节点都知道的公钥列表。在这个项目中，我们将每个节点的秘密短语用作</p><p id="000e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh nn no np nq b">NODE1, NODE2, NODE3......</code></p><p id="a950" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这样，我们可以更容易地创建一个公钥列表，并使用相同的公钥从命令行创建节点。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="ee1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kf">注意:机密短语不应公开。只是为了演示，我们才使用这样的秘密短语。在现实世界的项目中，发送注册请求以使节点成为验证器。如果整个网络都批准了这个请求，那么该节点就成为一个验证器，并且公钥被添加到列表中。</em></p><p id="b336" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">config . js文件</strong></p><p id="4e72" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">网络中验证器的数量可以通过命令行传递，但更容易的是将它存储在文件中，并在需要时导入。</p><p id="7cc0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">创建一个文件<code class="eh nn no np nq b">config.js</code>并创建三个变量<code class="eh nn no np nq b">NUMBER_OF_NODES</code>、<code class="eh nn no np nq b">MIN_APPROVALS</code>和<code class="eh nn no np nq b">TRANSACTION_THRESHOLD</code></p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="bde4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">闭塞等级</strong></p><p id="1e1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，我们将创建block类。在项目目录中，创建一个文件<code class="eh nn no np nq b">block.js</code>并在其中创建一个类<code class="eh nn no np nq b">Block</code>。块将具有以下属性:</p><ol class=""><li id="23f9" class="ne nf ht is b it iu ix iy jb ng jf nh jj ni jn pd nk nl nm dt translated">时间戳—创建块的时间</li><li id="2c68" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">lastHash —最后一个块的哈希值</li><li id="75c9" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">哈希-当前块的哈希值</li><li id="7b4b" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">数据—块保存的事务</li><li id="618c" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">提议者—块创建者的公钥</li><li id="973f" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">签名—块的签名哈希</li><li id="4810" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">sequenceNo —块的序列号</li></ol><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="abd5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">事务池类</strong></p><p id="daae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们需要一个地方来存储从其他节点接收的事务。因此，我们将创建一个<code class="eh nn no np nq b">TransactionPool</code>类来存储所有事务。创建一个名为<code class="eh nn no np nq b">transaction-pool.js</code>的文件</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="b07c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">块池类</strong></p><p id="5f89" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了临时存储块，我们还将创建块池。创建一个文件<code class="eh nn no np nq b">block-pool.js</code>，BlockPool类在这个文件中保存块，直到它被添加到链中。当接收到<code class="eh nn no np nq b">PRE-PREPARE</code>消息时，一个块被添加到块池。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="fe66" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有许多从节点接收的其他数据对象需要存储。<code class="eh nn no np nq b">PREPARE</code>、<code class="eh nn no np nq b">COMMIT</code>和<code class="eh nn no np nq b">NEW_ROUND</code>消息</p><p id="f1eb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此将再创建三个池，即<code class="eh nn no np nq b">PreparePool</code>、<code class="eh nn no np nq b">CommitPool</code>和<code class="eh nn no np nq b">MessagePool</code>。消息池将保存<code class="eh nn no np nq b">NEW_ROUND</code>消息。</p><p id="52b9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">prepare pool类</strong></p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="15bd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">提交池类</strong></p><p id="235b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">提交消息是在收到2f+1条准备消息后添加的，因此我们使用准备消息来获取块散列，而不是传递整个块。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="76a1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">消息池类</strong></p><p id="7e12" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">MessagePool的工作方式与其他两个池类似。唯一的区别是它所携带的额外信息。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="eaeb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">区块链类</strong></p><p id="cae2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们拥有创建区块链班级所需的所有班级。我们现在可以创建一个文件<code class="eh nn no np nq b">blockchain.js</code>。<code class="eh nn no np nq b">Blockchain</code>类将具有以下属性:</p><ol class=""><li id="1690" class="ne nf ht is b it iu ix iy jb ng jf nh jj ni jn pd nk nl nm dt translated">链-已确认的块列表</li><li id="86bd" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">验证者列表—给定网络的验证者列表</li></ol><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="a508" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">P2P server类</strong></p><p id="00b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们如何向其他节点发送消息？我们将制作一个P2p服务器。在文件<code class="eh nn no np nq b">p2p-server.js</code>中创建一个类<code class="eh nn no np nq b">P2pserver</code></p><p id="5964" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了创建一个p2p服务器，我们将使用套接字。为了使用套接字，我们将安装一个“ws”模块。这个模块使得使用套接字变得非常容易。</p><pre class="jp jq jr js fq nw nq nx ny aw nz dt"><span id="2e24" class="mq kh ht nq b fv oa ob l oc od">npm i --save ws</span></pre><p id="01b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">P2pserver类是实现一致性算法的地方。这是项目的核心。这个类负责处理消息并广播它们。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="f618" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">应用程序</strong></p><p id="fdbd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们将使用快速模块创建的应用程序连接所有文件。使用npm安装快速模块。</p><pre class="jp jq jr js fq nw nq nx ny aw nz dt"><span id="555d" class="mq kh ht nq b fv oa ob l oc od">npm i express --save</span></pre><p id="31d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的应用程序将实例化池、钱包、区块链、p2pserver，并声明一些端点来与我们的区块链交互。</p><p id="52df" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以下是所需的最少端点(您可以添加更多):</p><ol class=""><li id="5361" class="ne nf ht is b it iu ix iy jb ng jf nh jj ni jn pd nk nl nm dt translated">POST: '/transact' —创建事务，请求对象由要存储在事务中的数据组成</li><li id="0520" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">GET: '/transactions' —发送事务池中的事务作为响应</li><li id="f24b" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">GET: '/blocks' —发送区块链的链作为响应</li></ol><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="pe pf l"/></div></figure><p id="98aa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">这就完成了我们的编码。</strong>您可以通过在单独的终端中运行以下程序来测试这个应用程序:</p><p id="2880" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">第一个节点:</strong></p><pre class="jp jq jr js fq nw nq nx ny aw nz dt"><span id="9ddd" class="mq kh ht nq b fv oa ob l oc od">SECRET="NODE0" P2P_PORT=5000 HTTP_PORT=3000 node app</span></pre><p id="be7a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">第二个节点:</strong></p><pre class="jp jq jr js fq nw nq nx ny aw nz dt"><span id="ccd8" class="mq kh ht nq b fv oa ob l oc od">SECRET="NODE1" P2P_PORT=5001 HTTP_PORT=3001 PEERS=ws://localhost:5000 node app</span></pre><p id="7ccb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">第三节点:</strong></p><pre class="jp jq jr js fq nw nq nx ny aw nz dt"><span id="706e" class="mq kh ht nq b fv oa ob l oc od">SECRET="NODE2" P2P_PORT=5002 HTTP_PORT=3002 PEERS=ws://localhost:5001,ws://localhost:5000 node app</span></pre><p id="319f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你想做多少就做多少。<strong class="is hu"> <em class="kf">在创建更多节点之前，更新配置文件中的节点总数。</em>T13】</strong></p><p id="71d5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">点击任意节点的端点，直到池填满，并通过点击<code class="eh nn no np nq b">/blocks</code>端点来检查链。</p><p id="5b27" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">同样，点击端点<code class="eh nn no np nq b">/transactions</code>来检查事务池是否为空。</p><p id="a65b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您还可以为提交、准备和消息池创建更多这样的端点。</p></div><div class="ab cl ly lz hb ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hm hn ho hp hq"><h1 id="10cc" class="kg kh ht bd ki kj mf kl km kn mg kp kq kr mh kt ku kv mi kx ky kz mj lb lc ld dt translated">进一步的想法</h1><ol class=""><li id="8b80" class="ne nf ht is b it le ix lf jb pa jf pb jj pc jn pd nk nl nm dt translated">创建适当的文件夹结构</li><li id="5d86" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">将所有池合并成一个池。</li><li id="2937" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">在项目中添加状态变量，并在达到新状态时更新它。</li><li id="d486" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">新一轮后清除提交、准备和消息池。</li><li id="cc61" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">在区块链创建一个注册方法来动态添加新的验证器。</li><li id="3b92" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">以此项目为基础创建加密货币。</li><li id="11a3" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn pd nk nl nm dt translated">使用多线程使这个项目并行和更快。</li></ol></div><div class="ab cl ly lz hb ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hm hn ho hp hq"><p id="0228" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">非常感谢您的阅读。如果你觉得有用，就鼓掌。如果你有任何问题，请在下面评论。</p><p id="7fc6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">这个项目的完整代码可以在我的</strong><a class="ae ke" href="https://github.com/kashishkhullar/pbft" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">GitHub Repo</strong></a><strong class="is hu">上找到。如果你发现任何bug，请随意创建一个PR。</strong></p><blockquote class="lj"><p id="6db1" class="lk ll ht bd lm ln lo lp lq lr ls jn ek translated">加入Coinmonks <a class="ae ke" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ke" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae ke" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="mq kh ht bd ki mr pg mt km mu ph mw kq jb pi my ku jf pj na ky jj pk nc lc nd dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="ne nf ht is b it le ix lf jb pa jf pb jj pc jn nj nk nl nm dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><a class="ae ke" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae ke" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/top-3-telegram-channels-for-crypto-traders-in-2021-8385f4411ff4">密码电报信号</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f566" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/binance-trading-bots-d0d57bb62c4c">币安交易机器人</a> | <a class="ae ke" rel="noopener" href="/coinmonks/okex-review-6b369304110f"> OKEx审查</a> | <a class="ae ke" href="https://coincodecap.com/atani-review" rel="noopener ugc nofollow" target="_blank">阿塔尼审查</a></li><li id="3b1f" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/best-crypto-signals-telegram-5785cdbc4b2b">最佳加密交易信号电报</a> | <a class="ae ke" rel="noopener" href="/coinmonks/moonxbt-review-6e4ab26d037"> MoonXBT评论</a></li><li id="c44c" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><a class="ae ke" href="https://coincodecap.com/buy-shiba-bitbns" rel="noopener ugc nofollow" target="_blank">如何在Bitbns上购买柴犬(SHIB)币？</a> | <a class="ae ke" href="https://coincodecap.com/buy-floki-inu-token" rel="noopener ugc nofollow" target="_blank">购买Floki </a></li><li id="af80" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><a class="ae ke" href="https://coincodecap.com/coinflex-review" rel="noopener ugc nofollow" target="_blank"> CoinFLEX评论</a> | <a class="ae ke" href="https://coincodecap.com/aex-exchange-review" rel="noopener ugc nofollow" target="_blank"> AEX交易所评论</a> | <a class="ae ke" href="https://coincodecap.com/upbit-review" rel="noopener ugc nofollow" target="_blank"> UPbit评论</a></li><li id="29b5" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><a class="ae ke" href="https://coincodecap.com/best-cryptocurrency-blogs" rel="noopener ugc nofollow" target="_blank">十大最佳加密货币博客</a> | <a class="ae ke" href="https://coincodecap.com/youhodler-review" rel="noopener ugc nofollow" target="_blank"> YouHodler评论</a></li><li id="f196" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><a class="ae ke" href="https://coincodecap.com/ascendex-margin-trading" rel="noopener ugc nofollow" target="_blank"> AscendEx保证金交易</a> | <a class="ae ke" href="https://coincodecap.com/bitfinex-staking" rel="noopener ugc nofollow" target="_blank"> Bitfinex赌注</a></li><li id="3cd8" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><a class="ae ke" href="https://coincodecap.com/best-cardano-wallets" rel="noopener ugc nofollow" target="_blank">最好的卡达诺钱包</a> | <a class="ae ke" href="https://coincodecap.com/bingbon-copy-trading" rel="noopener ugc nofollow" target="_blank"> Bingbon副本交易</a></li><li id="f33b" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae ke" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">面向开发人员的最佳加密API</a></li><li id="b359" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated">最佳<a class="ae ke" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="ne nf ht is b it nr ix ns jb nt jf nu jj nv jn nj nk nl nm dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li></ul></div></div>    
</body>
</html>