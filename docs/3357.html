<html>
<head>
<title>Oracles on Tezos with Ligo: a simple use case</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tezos上的Tezos with Ligo:一个简单的用例</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/oracles-on-tezos-with-ligo-a-simple-use-case-b9e5605f0064?source=collection_archive---------3-----------------------#2020-09-13">https://medium.com/coinmonks/oracles-on-tezos-with-ligo-a-simple-use-case-b9e5605f0064?source=collection_archive---------3-----------------------#2020-09-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="5c43" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">用Ligo连接到Harbinger oracle以获得连锁汇率</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/255a6b2cdcfdb5e0e999d899138f50a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3gCtccRQ5DCHRV-h3W5l-w.jpeg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek"><a class="ae jy" href="https://pixabay.com/users/twalmedia-2586533/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2975066&quot;" rel="noopener ugc nofollow" target="_blank">Image by Christian Hardi from Pixabay</a></figcaption></figure><p id="9e00" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">看到Tezos区块链在短短6个月内走了多远令人难以置信:在2020年初，<a class="ae jy" href="https://docs.tezbridge.com/" rel="noopener ugc nofollow" target="_blank"> TezBridge </a>是唯一的钱包，在Tezos上dapps的可能性非常有限。现在，在2020年秋天，我们有了<a class="ae jy" href="https://thanoswallet.com/" rel="noopener ugc nofollow" target="_blank">灭霸</a>，一个更好更优雅的钱包来与<a class="ae jy" href="https://blog.coincodecap.com/what-are-dapps-an-ultimate-guide" rel="noopener ugc nofollow" target="_blank"> dapps </a>互动，我们还有神谕！Oracles是游戏规则的改变者，因为它们允许智能合约访问实时数据。它们为合同增加了一层安全，因为它们允许开发人员更少地依赖用户提供的数据，而更多地依赖可靠的信息来源。</p><p id="3543" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">然而，从特佐斯区块链的神谕中获取信息似乎不像在其他区块链，例如以太坊，那么简单。增加的复杂性是Tezos区块链增加了一层安全的结果:迈克尔逊禁止在合同执行期间进行任何外部干预。在像以太坊这样的区块链中，当一个事务遇到一个需要来自oracle的数据的入口点时，契约的执行会短暂地暂停，同时等待来自oracle的数据返回。例如，这可能允许重入攻击。重入攻击在Tezos上实际上是不可能的，但这意味着您需要一个变通方法来使用oracles。这是本文的主题。</p><p id="98dd" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">本教程将向您展示如何在用Ligo编写的契约中实现oracle调用，以及如何从oracle接收数据。我们将使用<a class="ae jy" href="https://better-call.dev/carthagenet/KT1GcGnKfx8MP3m6axQkkfUiaBM4orYxL5MQ/" rel="noopener ugc nofollow" target="_blank">比特币基地Pro normalizer契约</a>作为数据源，并使用<a class="ae jy" href="https://ligolang.org/docs/intro/introduction" rel="noopener ugc nofollow" target="_blank"> LigoLang </a>的CameLigo语法。我们将涵盖这个合同的<a class="ae jy" href="https://github.com/claudebarde/hodlers-lifesaver/blob/master/contracts/Hodlers.mligo" rel="noopener ugc nofollow" target="_blank">2个入口点，我用它来创建</a><a class="ae jy" href="https://hodlers-lifesaver.netlify.app/" rel="noopener ugc nofollow" target="_blank">霍德勒斯救生器dapp </a>。dapp允许用户锁定他们的技术开发区，只有当XTZ和美元之间的当前汇率高于他们锁定技术开发区时，才会让他们提取资金。</p></div><div class="ab cl kv kw hb kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hm hn ho hp hq"><h1 id="8c8b" class="lc ld ht bd le lf lg lh li lj lk ll lm iz ln ja lo jc lp jd lq jf lr jg ls lt dt translated">建立合同</h1><p id="6f1e" class="pw-post-body-paragraph jz ka ht kb b kc lu iu ke kf lv ix kh ki lw kk kl km lx ko kp kq ly ks kt ku hm dt translated">从Tezos上的oracle获取数据总是意味着两个入口点:一个发送数据请求，另一个接收数据。oracle到target的入口点将总是接受至少一个类型为<code class="eh lz ma mb mc b">contract type_of_returned_value</code>的值，因为oracle需要被告知将数据发送回哪里。让我们从建立合同开始。</p><p id="af26" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">对于我们当前的用例，我们需要一个入口点来接受用户发送的tez，并在合同中记录发送的金额和发送tez时的汇率。我们将实现一个简单的分类帐和一个大地图，其中的键将是用户的地址，值将是他们在合同中锁定的汇率和金额的记录:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff md"><img src="../Images/c69bece42acb9917bb497230a10ca7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dE2mZt5yP0M9ckfY1WNoSg.png"/></div></div></figure><p id="6a58" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">如上所述，存储将包含一个分类账来记录交易，但也包括oracle地址和管理地址(以防我们需要更改oracle地址)。</p><p id="aea5" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">我们还将为oracle所期望的参数创建额外的类型:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff me"><img src="../Images/1056677fd77774a6759dd6a301436ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeEmer36VyrWX94tqDcsOQ.png"/></div></div></figure><p id="c3a6" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">Harbinger契约期望一个代表货币对的<code class="eh lz ma mb mc b">string</code>和一个返回货币对、上次更新的时间戳和货币对的当前汇率的<code class="eh lz ma mb mc b">(string (timestamp * nat)) contract</code>。返回的类型类似于迈克尔逊中的类型:<code class="eh lz ma mb mc b">(pair string (pair timestamp nat))</code>。它被称为<code class="eh lz ma mb mc b">right-combed pair</code>，这意味着它是一个嵌套对，所有嵌套对都在父对的右侧。相反的是一个<code class="eh lz ma mb mc b">left-combed pair</code>，它的嵌套对在左边，就像这样:<code class="eh lz ma mb mc b">(pair (pair timestamp nat) string))</code>。尊重迈克尔逊中的对的结构是最重要的:一个入口点接收一个左梳对，而期望一个右梳对，将拒绝它，即使内部类型是正确的。</p><p id="d769" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这就把我们带到了为将从oracle返回的值设置我们的类型:首先，我们创建一个记录，因为它对我们来说可读性更好，也更容易操作。然后我们使用一个名为<code class="eh lz ma mb mc b">michelson_pair_right_comb</code>的转换器将Ligo记录转换成迈克尔逊右梳对。最后，我们创建一个tuple，它将用<code class="eh lz ma mb mc b">string</code>和<code class="eh lz ma mb mc b">right-combed pair</code>发送给oracle。</p><p id="a73c" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">现在，我们要写入口点。对于本教程，我们将只编写示例契约包含的5个入口点中的2个。第一个将向oracle发送请求，第二个将接收oracle返回的值:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mf"><img src="../Images/4cd7a2be6d8038beca1c158150c3d47b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4etPOKsVbWisU76OFcbxg.png"/></div></div></figure><p id="c373" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><code class="eh lz ma mb mc b">Hodl</code> entrypoint不接受任何参数(在Ligo中转化为一个<code class="eh lz ma mb mc b">unit</code>，它将从<code class="eh lz ma mb mc b">Tezos.amount</code>和<code class="eh lz ma mb mc b">Tezos.sender</code>中获得它需要的所有值。<code class="eh lz ma mb mc b">Hodl_callback</code>将从oracle接收数据，数据类型为<code class="eh lz ma mb mc b">returned_val_michelson</code>。我们可以使用<code class="eh lz ma mb mc b">entrypoint</code>类型来编写<code class="eh lz ma mb mc b">main</code>入口点:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mg"><img src="../Images/9063458f3060c06b38f2e3ac437c5bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3TJX24TpJEBFXJadfuXUFw.png"/></div></div></figure><p id="6a08" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><code class="eh lz ma mb mc b">Hodl</code>入口点将指向一个函数，该函数必须返回一个包含一个事务(调用oracle)和存储的事务列表。<code class="eh lz ma mb mc b">Hodl_callback</code>将指向一个不返回任何事务的函数，因此我们可以让该函数单独返回新的存储。</p><p id="f10f" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">设置现在完成了，我们可以看看不同的入口点。</p></div><div class="ab cl kv kw hb kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hm hn ho hp hq"><h1 id="16a0" class="lc ld ht bd le lf lg lh li lj lk ll lm iz ln ja lo jc lp jd lq jf lr jg ls lt dt translated">设置对oracle的请求</h1><p id="49a8" class="pw-post-body-paragraph jz ka ht kb b kc lu iu ke kf lv ix kh ki lw kk kl km lx ko kp kq ly ks kt ku hm dt translated"><code class="eh lz ma mb mc b">hodl</code>函数不需要任何值作为参数，所以我们将使用类型为<code class="eh lz ma mb mc b">unit</code>的参数。首先，让我们写出函数的结构、名称、参数、类型和返回值:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mh"><img src="../Images/96ce9a93f376cd20f3f40b75ea14bdbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*txsiNqL-8aVCoU_-oAvuGw.png"/></div></div></figure><p id="18fb" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">如声明所示，该函数将返回操作和存储的列表。我们的操作列表将包含要发送到oracle的事务，并且存储将随着我们跟踪用户的请求而更新。</p><p id="6d0f" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">由于合同的要点是让我们的用户锁定他们的技术开发区，我们将首先确保有技术开发区附加到交易:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mi"><img src="../Images/dbc2bfb398c916e095c668c571509a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JbElOhSR6JC3Y2wBXMEJ7w.png"/></div></div></figure><p id="fd85" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><code class="eh lz ma mb mc b">if Tezos.amount = 0tez</code>验证发送给合同的金额，如果等于零，则合同失败。如果不是，则继续执行。</p><blockquote class="mj mk ml"><p id="4202" class="jz ka mm kb b kc kd iu ke kf kg ix kh mn kj kk kl mo kn ko kp mp kr ks kt ku hm dt translated">注意:当在Ligo中使用<code class="eh lz ma mb mc b">failwith</code>时，您必须指出如果入口点将在此刻返回时所期望的类型。</p></blockquote><p id="31c1" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">现在，我们想检查发送事务的用户是否已经锁定了一些tez。由于这是一份简单的合同，我们不允许用户添加更多的技术开发区，他们可以存入或提取技术开发区:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mq"><img src="../Images/d24be2cc334e3fb094c671e7d57fe8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7N8lYkmMxIhF7KztKIR9w.png"/></div></div></figure><p id="bcae" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">在这一步中，我们在分类帐中查找<code class="eh lz ma mb mc b">Tezos.source</code>地址，如果找到，我们使合同失效，如果没有找到，我们将在分类帐中添加一个新条目。<code class="eh lz ma mb mc b">deposit</code>与发送给合同的<code class="eh lz ma mb mc b">Tezos.amount</code>相匹配，我们将<code class="eh lz ma mb mc b">price</code>初始化为<code class="eh lz ma mb mc b">0n</code>，因为该值稍后将使用oracle中的值进行更新。此时，<code class="eh lz ma mb mc b">s</code>变量(包含存储)已经被修改，其值将成为我们的新存储。</p><p id="342a" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">接下来，我们准备对oracle的请求。让我们看看它是什么样子的:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mr"><img src="../Images/ec6bfa7c8495a15bba2607f4540a0580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rl9xj6a2yWUyCzgYKOD0WQ.png"/></div></div></figure><p id="5821" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">第一次使用时，这可能看起来有点令人生畏，但当您理解每个部分的作用时，它会变得很容易:</p><ul class=""><li id="e313" class="ms mt ht kb b kc kd kf kg ki mu km mv kq mw ku mx my mz na dt translated"><code class="eh lz ma mb mc b">let call_to_oracle: oracle_param contract</code>:这个变量将接收对oracle入口点的引用，我们稍后将使用它来构建事务。变量的类型必须是<code class="eh lz ma mb mc b">contract</code>，带有一个镜像oracle所需参数的参数(<code class="eh lz ma mb mc b">string * (string * (timestamp * nat)) contract</code>)。</li><li id="8c15" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><code class="eh lz ma mb mc b">Tezos.get_entrypoint_opt</code>:该函数返回一个可选值，其参数类型为<code class="eh lz ma mb mc b">contract</code>，参数类型与oracle参数类型相同。它有两个参数:格式<code class="eh lz ma mb mc b">"%name_of_parameter"</code>下的目标入口点的名称和目标契约的地址(这里是oracle地址)。</li><li id="29e1" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><code class="eh lz ma mb mc b">match ... with ...</code>:这是对<code class="eh lz ma mb mc b">Tezos.get_entrypoint_opt</code>的结果进行模式匹配，如果没有找到定义入口点的合同，则返回<code class="eh lz ma mb mc b">None</code>，否则返回<code class="eh lz ma mb mc b">Some</code>以及我们要找的合同的引用。</li><li id="1bac" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><code class="eh lz ma mb mc b">(failwith "NO_ORACLE_FOUND": oracle_param contract)</code>:如果<code class="eh lz ma mb mc b">get_entrypoint_opt</code>函数找不到定义了入口点的契约，契约失败，错误代码如上。<code class="eh lz ma mb mc b">failwith</code>必须是类型化的，并且与<code class="eh lz ma mb mc b">call_to_oracle</code>变量所期望的类型相同。</li><li id="21ec" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><code class="eh lz ma mb mc b">Some contract -&gt; contract</code>:如果一切按预期运行，您将收到一个对oracle契约及其入口点的引用，该引用将存储在<code class="eh lz ma mb mc b">call_to_oracle</code>变量中。</li></ul><p id="6bc3" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">现在让我们看看我们的<code class="eh lz ma mb mc b">hodl</code>入口点:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ng"><img src="../Images/95dcf28ed772b9abce509f57a7d6f57e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmABJnFXkcHZHZjacI3lKw.png"/></div></div></figure><p id="e317" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">最后，我们构建将在合同执行结束时发送给oracle的事务:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff nh"><img src="../Images/96a82f26d839eefe2fba633fbd7333ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f72h8SQaxVawcNfEC2lDiQ.png"/></div></div></figure><p id="dcef" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">我们使用接受3个参数的<code class="eh lz ma mb mc b">Tezos.transaction</code>函数:</p><ul class=""><li id="8f79" class="ms mt ht kb b kc kd kf kg ki mu km mv kq mw ku mx my mz na dt translated">发送给契约的参数，在本例中，表示我们想要的货币对的字符串(<code class="eh lz ma mb mc b">XTZ-USD</code>)和回调入口点，我们可以在Ligo中用<code class="eh lz ma mb mc b">Tezos.self("%name_of_entrypoint")</code> +包装在<code class="eh lz ma mb mc b">contract</code>类型中的这个入口点的类型轻松获得</li><li id="1c5d" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated">额送来的神谕(<code class="eh lz ma mb mc b">0 tez</code>，是免费使用的！)</li><li id="a0ea" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated">对交易将发送到的合同的引用</li></ul><p id="4daa" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">就是这样！确保将此事务包含在函数结束时返回的操作列表中:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ni"><img src="../Images/80d13d3b71968ca36455e469b1ee2221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VO4R9_cBkYCIBiOIbl4eEQ.png"/></div></div></figure><p id="f709" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这个新事务将被发送到oracle来收集我们想要的数据。但是，我们要怎么做才能把这些数据拿回来呢？</p></div><div class="ab cl kv kw hb kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hm hn ho hp hq"><h1 id="8516" class="lc ld ht bd le lf lg lh li lj lk ll lm iz ln ja lo jc lp jd lq jf lr jg ls lt dt translated">设置回调入口点</h1><p id="f881" class="pw-post-body-paragraph jz ka ht kb b kc lu iu ke kf lv ix kh ki lw kk kl km lx ko kp kq ly ks kt ku hm dt translated">回调入口点是所有危险的地方！当您构建将从oracle接收所需数据的入口点时，必须牢记这种体系结构的一些固有风险。问自己以下问题:</p><ul class=""><li id="bab6" class="ms mt ht kb b kc kd kf kg ki mu km mv kq mw ku mx my mz na dt translated"><strong class="kb hu">我如何知道事务实际上来自oracle？</strong>毕竟，你的合约的入口点是开放的，任何人都可以向它们发送交易，即使它们被设计为从oracle接收数据。</li><li id="9d28" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated">如何整理传入的数据？即使您确实知道当前事务来自oracle，这并不意味着数据就是您所期望的(正如我们将在下面看到的)。</li><li id="d799" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><strong class="kb hu">我如何安全地追求我在第一个事务中开始的变更？</strong>您请求这些数据是因为您需要它们来更新存储，然而，现在很多事情都不同了，例如，<code class="eh lz ma mb mc b">Tezos.sender</code>不再一样了。</li></ul><p id="7a92" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">最容易回答的问题将是第一个:您可以在契约的存储中保留oracle的地址(并实现一个入口点来更新它，以防您想要更改数据源)，以便在需要时可以很容易地找到它:<code class="eh lz ma mb mc b">if Tezos.sender &lt;&gt; storage.oracle_address</code>。这是我们在合同中做的:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff nj"><img src="../Images/a991ca80155e096acda664abecb1b607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dMFSkUFH_-qKfGb2Q5PK9Q.png"/></div></div></figure><p id="a2f7" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">首先，我们必须将从神谕中获得的值转换成我们之前声明的记录，以使我们的生活更轻松。您只需使用助手函数<code class="eh lz ma mb mc b">Layout.convert_from_right_comb</code>，后跟参数，并对保存记录的变量使用<code class="eh lz ma mb mc b">returned_val</code>类型。接下来，我们将<code class="eh lz ma mb mc b">Tezos.sender</code>的地址与神谕的地址进行比较。</p><blockquote class="mj mk ml"><p id="ea17" class="jz ka mm kb b kc kd iu ke kf kg ix kh mn kj kk kl mo kn ko kp mp kr ks kt ku hm dt translated">这里使用<code class="eh lz ma mb mc b">Tezos.sender</code>而不是<code class="eh lz ma mb mc b">Tezos.source</code>,因为您想要检查是谁发送了当前事务，而不是谁发送了第一个事务。</p></blockquote><p id="8cc0" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">现在，第二个问题。先知预言通过发送货币对和汇率使我们的生活变得更容易。我们希望确保收到正确的货币对，因此我们可以:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff nk"><img src="../Images/d648f3a13a562cee636af21c7b6b51ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6cjnOX6hLU6aYYU4ZBN_Q.png"/></div></div></figure><p id="ef08" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">如果我们使用不同的货币对，这将是根据它接收的货币对将入口点的逻辑划分到不同分支的一个很好的方法。</p><blockquote class="mj mk ml"><p id="4cae" class="jz ka mm kb b kc kd iu ke kf kg ix kh mn kj kk kl mo kn ko kp mp kr ks kt ku hm dt translated">这里我们不使用oracle返回的时间戳，但是您可以自由使用它，例如，如果您想要验证您收到的汇率是否足够新。</p></blockquote><p id="b8e1" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">现在，是时候更新存储了。在前面的entrypoint中，我们用一个<code class="eh lz ma mb mc b">0n</code>作为价格来设置用户的帐户，以表示初始化没有完成。我们将取回帐户并完成它的设置！</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff nl"><img src="../Images/32f92803f7b6e0e91b24b6ef116ff936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0r5DFY3gkWsSUxSXcy4Cw.png"/></div></div></figure><p id="cfb1" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">我们试图找到在<code class="eh lz ma mb mc b">ledger</code>中创建的账户，该账户的密钥与第一笔交易的地址(<code class="eh lz ma mb mc b">Tezos.source</code>)相匹配，如果我们找不到，则合同失败(这肯定是一种意外行为！)如果我们找到它，我们希望确保将<code class="eh lz ma mb mc b">price</code>字段设置为<code class="eh lz ma mb mc b">0n</code>(这意味着帐户正在等待用汇率更新)。如果不是这样，合同就失效了。</p><p id="0504" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">现在，我们可以更新帐户并返还新存储:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff nm"><img src="../Images/4fedbd3c5db6017ae179426fe0f37d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Md8crGTU6oive5pUfrkp8w.png"/></div></div></figure><p id="9baa" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">我们只需将汇率输入用户的账户，并更新存储。当用户稍后回来提取他们的资金时，我们可以再次调用oracle，将当前汇率与存储在存储器中的汇率进行比较，如果当前汇率高于先前汇率，我们可以释放他们的资金！</p></div><div class="ab cl kv kw hb kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hm hn ho hp hq"><h1 id="647d" class="lc ld ht bd le lf lg lh li lj lk ll lm iz ln ja lo jc lp jd lq jf lr jg ls lt dt translated">在Tezos上使用神谕的风险</h1><p id="a0c1" class="pw-post-body-paragraph jz ka ht kb b kc lu iu ke kf lv ix kh ki lw kk kl km lx ko kp kq ly ks kt ku hm dt translated">每次你需要来自先知的数据时，你都要离开温暖舒适的契约，去面对危险而可怕的外部世界！这是一个充满不怀好意的人的地方，他们潜伏在合同后面，等待机会潜入您的代码并窃取您的资金！</p><p id="ef16" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">但是不要害怕，通过遵循非常简单的方法，你可以打败他们中的大多数！验证数据来自正确的oracle，您正在获得您期望的数据，注意<code class="eh lz ma mb mc b">Tezos.sender</code>和<code class="eh lz ma mb mc b">Tezos.source</code>之间的差异，并在收到来自oracle的数据后尽可能少地更新存储。永远不要认为只有oracle会使用回调入口点。</p><p id="7143" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这里有一个攻击者可以做什么的具体例子:就在撰写本文之前，本教程中使用的Harbinger契约只返回了一个<code class="eh lz ma mb mc b">nat</code>值(所请求的货币对的当前汇率)。在本文中使用的契约发布之后，人们发现这个设计中有一个缺陷:一个恶意的参与者可以伪造一个交易，并将当前的契约作为回调，然后用错误的货币对将其发送给oracle。结果，当前的契约将接收到错误的值，而无法知道该值不是正确的对。在这个简单的用例中，这不是一个大问题，但在一个使用返回的汇率来决定向给定地址转移多少技术开发区的合同中，这可能是灾难性的！</p></div><div class="ab cl kv kw hb kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hm hn ho hp hq"><p id="1664" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">我希望这篇文章为您提供了更多关于Tezos上的神谕和契约的信息。Tezos上oracles的使用不同于您在其他区块链中可以找到的，了解交易交换如何工作以及恶意合同如何影响交易和您自己的合同至关重要。</p><p id="a965" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">通过几个简单的额外步骤，您就可以开始安全地使用Harbinger oracles并创建惊人的dapps！</p><h2 id="0aed" class="nn ld ht bd le no np nq li nr ns nt lm ki nu nv lo km nw nx lq kq ny nz ls oa dt translated">另外，阅读</h2><ul class=""><li id="02dc" class="ms mt ht kb b kc lu kf lv ki ob km oc kq od ku mx my mz na dt translated">最好的<a class="ae jy" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="b851" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">密码本交易平台</a></li><li id="ae2d" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated">最好的<a class="ae jy" rel="noopener" href="/coinmonks/best-crypto-tax-tool-for-my-money-72d4b430816b">加密税务软件</a></li><li id="92e4" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/the-best-crypto-trading-platforms-in-2020-the-definitive-guide-updated-c72f8b874555">最佳加密交易平台</a></li><li id="d8fc" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated">最佳<a class="ae jy" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">加密贷款平台</a></li><li id="4f10" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" href="https://bitquery.io/blog/best-blockchain-analysis-tools-and-software" rel="noopener ugc nofollow" target="_blank">最佳区块链分析工具</a></li><li id="d432" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/crypto-arbitrage-guide-how-to-make-money-as-a-beginner-62bfe5c868f6">加密套利</a>指南:新手如何赚钱</li><li id="aa54" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated">最佳<a class="ae jy" rel="noopener" href="/coinmonks/what-are-the-best-charting-platforms-for-cryptocurrency-trading-85aade584d80">加密制图工具</a></li><li id="15e1" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/ledger-vs-trezor-best-hardware-wallet-to-secure-cryptocurrency-22c7a3fd391e">莱杰vs特雷佐</a></li><li id="56fd" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated">了解比特币最好的<a class="ae jy" rel="noopener" href="/coinmonks/what-are-the-best-books-to-learn-bitcoin-409aeb9aff4b">书籍有哪些？</a></li><li id="170f" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/3commas-review-an-excellent-crypto-trading-bot-2020-1313a58bec92">3商业评论</a></li><li id="d145" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/aax-exchange-review-2021-67c5ea09330c"> AAX交易所评论</a> |推荐代码、交易费用、利弊</li><li id="54f9" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/deribit-review-options-fees-apis-and-testnet-2ca16c4bbdb2"> Deribit审查</a> |选项、费用、API和Testnet</li><li id="e34b" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/ftx-crypto-exchange-review-53664ac1198f"> FTX密码交易所评论</a></li><li id="d0c3" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/ngrave-zero-review-c465cf8307fc">n零审核</a></li><li id="1310" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/bybit-exchange-review-dbd570019b71"> Bybit交换审查</a></li><li id="8b1e" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/cryptohopper-vs-3commas-vs-shrimpy-a2c16095b8fe"> 3Commas vs Cryptohopper </a></li><li id="b18b" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated">最好的比特币<a class="ae jy" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069?source=friends_link&amp;sk=324dd9ff8556ab578d71e7ad7658ad7c">硬件钱包</a></li><li id="e7b1" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated">最佳<a class="ae jy" href="https://blog.coincodecap.com/best-monero-wallets" rel="noopener ugc nofollow" target="_blank"> monero钱包</a></li><li id="747f" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" href="https://blog.coincodecap.com/ledger-nano-s-vs-x" rel="noopener ugc nofollow" target="_blank">莱杰nano s vs x </a></li><li id="ace6" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" href="https://blog.coincodecap.com/bitsgap-3commas-quadency" rel="noopener ugc nofollow" target="_blank">Bitsgap vs 3 commas vs quad ency</a></li><li id="a274" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" href="https://blog.coincodecap.com/ledger-nano-s-vs-trezor-one-ledger-nano-x-trezor-t" rel="noopener ugc nofollow" target="_blank">莱杰Nano S vs特雷佐one vs特雷佐T vs莱杰Nano X </a></li><li id="44f0" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/blockfi-vs-celsius-vs-hodlnaut-8a1cc8c26630">block fi vs Celsius</a>vs Hodlnaut</li><li id="52d0" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/bitsgap-review-a-crypto-trading-bot-that-makes-easy-money-a5d88a336df2">bits gap review</a>——一个轻松赚钱的加密交易机器人</li><li id="92c0" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated">为专业人士设计的加密交易机器人</li><li id="22eb" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/primexbt-review-88e0815be858"> PrimeXBT审查</a> |杠杆交易、费用和交易</li><li id="62d2" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/ellipal-titan-review-85e9071dd029">埃利帕尔泰坦评论</a></li><li id="1a26" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" href="https://blog.coincodecap.com/secux-stone-hardware-wallet-review" rel="noopener ugc nofollow" target="_blank">赛克斯·斯通评论</a></li><li id="31ff" class="ms mt ht kb b kc nb kf nc ki nd km ne kq nf ku mx my mz na dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/blockfi-review-53096053c097"> BlockFi评论</a> |赚取高达8.6%的加密利息</li></ul></div></div>    
</body>
</html>