# EOS 合同—部署和使用没有链上 ABI 的合同

> 原文：<https://medium.com/coinmonks/eos-contracts-deploying-and-using-contracts-without-on-chain-abi-1bf48f145838?source=collection_archive---------5----------------------->

![](img/761cf122f9e525fb9f3bc37d9a0d4fc3.png)

如果你是一个聪明的合同开发者，那么你至少应该听说过 ABI。 **ABI** 代表*应用二进制接口*，用于将人类可读的数据格式(即 JSON)转换为普通的二进制格式，以获得最大效率。

回到以太坊，ABI 是离线出版发行的。例如， [Etherscan](https://etherscan.io) 为经过验证的合同提供 ABIs，这样用户就可以很容易地与它们进行交互。

认识到 ABI 的重要性，EOS 决定把它放在链上。例如，以下是系统合同`eosio.token`的 ABI 摘录:

从 ABI 中我们可以了解到，动作`transfer`使用的参数类型为`transfer`，包含 4 个字段:`from`、`to`、`quantity`和`memo`。这样，当用户调用契约接口时，前端软件可以根据 ABI 中包含的信息序列化用户提供的参数。

事实上，每当您使用`eosjs`进行契约交互时，它总是首先发出一个`get_abi`请求，然后是实际的`push_transaction`请求。

然而，虽然在链上使用 ABI 很方便，但是这种机制也带来了不希望的副作用。对于私人合同，我们希望发布的信息越少越好，发布 ABI 绝对不是最好的方式。

*注意，你仍然可以不使用 ABI(即反编译)来破译一个编译好的契约，但是 ABI 的发布使这变得容易多了。*

因此，我将介绍一种只发布契约代码，并且仍然能够与之交互的方法。

# 部署合同

默认情况下，使用命令`cleos set contract`发布合同会将 ABI 文件与合同一起发布。没有办法改变这种行为，如`cleos`源代码所示:

这就是为什么我们使用官方 JS 库用于 EOS 的原因。

关于使用该库的基本说明，请参考 GitHub 官方文档以获得帮助。我假设你已经成功地创建了一个工作的`eos`对象。

首先，阅读已编译的合同文件:

然后，在部署代码时只调用`setcode`:

正如您将看到的，该合同在没有上传 ABI 的情况下成功部署。

# 援引合同

但是，该合同不能立即使用。当我们使用`eos.transaction`与合同交互时，会抛出一个错误，因为没有可用的 ABI 信息。我们可以使用以下命令在本地加载 ABI:

然而交易还是会失败！这是因为在进行交易之前，`eos`会自动触发一个`get_abi`请求并覆盖本地版本。为了有效地缓存 ABI，我们需要一个不能访问区块链的`eos`对象。

但是另一个问题来了。每个 EOS 交易都有一个标题，只能从区块链自动获取。如果我们只是创建一个断开的`eos`对象，它甚至不能构造事务。

幸运的是，我们可以首先从普通的`eos`对象中获取头，将其传递给新的对象`coldEos`，在`coldEos`中缓存 ABI，使用`coldEos`进行事务生成和签名，最后，再次使用`eos`将签名的事务推送到网络上。

我们首先需要定义一个获取事务头的函数:

然后，我们可以创建一个`coldEos`对象，并用它来签署事务。我们将调用一个名为`myaction`的契约接口，并将一个字符串作为参数:

最后，我们用`eos`对象广播签名的事务:

整个过程有点复杂，但我们最终设法部署了一个没有 ABI 的合同，并成功地与它进行了交互。

请在 Medium 上关注我，了解更多关于区块链和智能合约的信息！

> [直接在您的收件箱中获得最佳软件交易](https://coincodecap.com/?utm_source=coinmonks)

[![](img/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png)](https://coincodecap.com/?utm_source=coinmonks)