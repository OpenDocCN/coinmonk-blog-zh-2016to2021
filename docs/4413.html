<html>
<head>
<title>ZK-Rollup development experience sharing, Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ZK-Rollup开发经验分享，第一部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/zk-rollup-development-experience-sharing-part-i-6c233640b541?source=collection_archive---------2-----------------------#2021-04-18">https://medium.com/coinmonks/zk-rollup-development-experience-sharing-part-i-6c233640b541?source=collection_archive---------2-----------------------#2021-04-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="b341" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">鸣谢:我们要感谢barryWhiteHat、Jordi Baylina和Koh韦杰(按字母顺序排列)提供的深刻反馈。</p><p id="f0fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">先决条件:基本的编程和区块链知识，不需要密码学背景。</p><p id="e68d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">目前，对区块链技术的主要期望是进一步扩大规模，更高的性能和更低的成本。在本帖中，我们将深入探讨ZK-Rollup，它是<a class="ae jp" href="https://ethereum.org/nl/developers/docs/layer-2-scaling/" rel="noopener ugc nofollow" target="_blank">以太坊第二层扩展解决方案</a>之一。它巧妙地应用了一种零知识证明技术(称为ZK-斯纳克)来降低链上成本，因此能够大大提高以太坊TPS(大约10-100倍)。包括以太坊创始人维塔利克在内的许多人都认为ZK-罗博是以太坊第二层长期最重要的扩展解决方案。</p><blockquote class="jq jr js"><p id="fb79" class="iq ir jo is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hm dt translated">总的来说，我自己的观点是，在短期内，乐观的汇总可能会在通用EVM计算中胜出，ZK汇总可能会在简单的支付、交换和其他特定于应用程序的用例中胜出，但在中长期内，随着ZK-斯纳克技术的改进，ZK汇总将在所有用例中胜出。—维塔利克</p></blockquote><p id="bb02" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这一系列的文章中，我们将分享我们开发ZK系统的经验。这些帖子的动机是，目前有许多高质量的资源介绍ZK-斯纳克背后的密码学，有很多数学细节。与此同时，也有许多非技术博客在研究ZK-罗博的影响和前景。很少有人会去探究这样的问题，ZK汇总到底是如何提升性能的？或者说，一个完整的ZK卷系统是什么样子的？或者，在ZK汇总系统中有什么重要但通常被忽略的细节吗？</p><p id="99a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jp" href="https://github.com/Fluidex/" rel="noopener ugc nofollow" target="_blank"> Fluidex </a>，作为极少数从零开始独立开发ZK-罗博系统的团队之一，很高兴分享一些从ZK-罗博系统开发中获得的经验。我们希望这能让该领域的其他开发者受益。我们将讨论一些重要但很少被提及的话题，比如ZK系统的性能瓶颈在哪里，经济成本在哪里，等等。</p><h1 id="9c5d" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">ZK-斯纳克和ZK公司概述-汇总</h1><p id="f5c2" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">同样，我们不会关注ZK-斯纳克证明的加密细节，因为如上所述，有足够多的高质量资源来解释它。在这一章中，我们将简要回答以下问题:ZK-斯纳克能做什么？为什么它成为ZK-Rollup的核心，和“Rollup”一起帮助提升以太坊的性能？“rollup”到底是什么意思？</p><h1 id="6575" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">ZK-斯纳克的本质</h1><p id="a7fe" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">一般来说，在区块链生态系统中，每个节点将为块中的每个事务执行相同的计算，然后验证它们的结果与其他节点的结果相同。换句话说，对于链上的每个事务，它将由每个节点执行。这是区块链表现相对较差的一个主要原因。</p><p id="140a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，“重新计算”是验证交易的唯一方法吗？换个说法:验证的成本有必要和计算的成本一样多吗？</p><p id="f8cc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">答案是否定的。验证可能比计算更便宜。就拿数独来说吧。解决数独的复杂性与验证数独解决方案的复杂性截然不同。“重新计算”是效率最低的验证方法。如果你碰巧有计算机科学背景，就考虑一下计算复杂性理论中的P vs NP问题。</p><p id="1f40" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，在区块链，有一个可以降低验证成本的技术解决方案是值得的，即使是通过增加计算成本。原因是，对于每个事务，计算将只发生一次，而验证将在每个节点上发生。ZK-斯纳克本质上就是这样一种大大降低验证成本的技术。一般来说，ZK-斯纳克可以使验证成本比计算成本低几个数量级。准确地说，将验证复杂度从线性降低到常数(或对数)，这就是“简洁”，即“SNARK”中的“S”所代表的意思。</p><p id="0bea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们看看ZK-斯纳克是如何工作的。</p><p id="1008" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于一个特定的程序，它将首先被预处理。在一次性预处理之后，对于每个输入，证明者将需要计算对应于该输入的结果，并且以相对较大的成本生成“证明”(通常以大整数的形式)。任何验证者都可以使用这个“证据”和输入来快速验证结果的正确性，而无需实际运行程序。</p><p id="1d70" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">伪代码中更详细的描述:</p><pre class="kz la lb lc fq ld le lf lg aw lh dt"><span id="5555" class="li jx ht le b fv lj lk l ll lm">// here is the the application code<br/>// it is usually called 'circuit code'<br/>function some_function(inputs):<br/>   // no global vars allowed here<br/>   outputs = some_calculation(inputs)<br/>   return outputs<br/></span><span id="4a41" class="li jx ht le b fv ln lk l ll lm">// preprocessing only runs once for every 'some_function'<br/>// we deliberately ignore 'setup' here to make it easier for understanding<br/>// for a more precise and detailed description, you can have a look at the references at the end of this article<br/>const preprocess_result = zksnark_preprocess(some_function)<br/>const verification_key = preprocess_result.verification_key;<br/>const proving_key = preprocess_result.proving_key;</span><span id="6368" class="li jx ht le b fv ln lk l ll lm">// for every 'inputs', generate 'proof'. The following codes run off chain<br/>// we deliberately ignore 'witness' here to make it easier for understanding<br/>// we will make more explanation on what consists of inputs/outputs of a realworld ZK-Rollup system in the following sections<br/>const outputs = some_function(inputs);<br/>// the 'prove' will need a lot of computing resource to finish<br/>const proof = zksnark_prove(proving_key, input, output);</span><span id="d7dc" class="li jx ht le b fv ln lk l ll lm">// verify the input/output is correct<br/>// The following codes usually run on chain<br/>const is_correct = zksnark_verify(verification_key, input, output, proof);<br/>assert(is_correct == true);</span></pre><h1 id="6d07" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">卷起系统的真实世界设计</h1><p id="f5e8" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">在正常的汇总系统中，我们将维护一个全局merkle树。汇总系统中的所有状态(包括账户的每个令牌的余额、账户的现时等。)会成为树上的一个叶节点。</p><p id="2a1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ZK-斯纳克将从数学上保证对merkle树的每次更新都满足一些“预定规则”。这些规则由ZK汇总开发者的设置决定。例如，对于ZK汇总传输系统，开发人员可以要求:</p><ol class=""><li id="1537" class="lo lp ht is b it iu ix iy jb lq jf lr jj ls jn lt lu lv lw dt translated">转账金额小于汇款人账户余额；</li><li id="f9b6" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw dt translated">发送方帐户的签名有效，nonce正确；</li><li id="447c" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw dt translated">发送方帐户中减少的金额等于接收方帐户中增加的金额。</li></ol><p id="a994" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">此外，merkle根的散列将从新叶计算。</p><p id="c770" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了保证最坏情况下的安全性(即，即使Rollup系统的操作者退出，用户仍然可以完整地撤回他们的资产)，系统应该确保用户能够从头开始重建树(称为“数据可用性”)，并且能够通过merkle proof做出类似“Alice实际上在该树中具有3个ETH”的断言。为了实现这一点，系统应该将每笔交易的数据公开，并存储在chain上。</p><p id="e37a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于一批数百或数千个事务，在我们按照特定的顺序执行它们并更新merkle树之后，我们将使用ZK-斯纳克来证明结果的正确性(即merkle树的新根)。请注意，这里的事务数量由预定义的配置决定，该配置在运行时是固定的。这批交易将被证明和验证在一起，被称为“L2区块”。</p><p id="dd6a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">再一次，让我们使用伪代码来演示真实世界的ZK卷积系统中的数据流:</p><pre class="kz la lb lc fq ld le lf lg aw lh dt"><span id="c93d" class="li jx ht le b fv lj lk l ll lm">// the following code runs as smart contract<br/>// 'global_merkle_tree_root' is the only state needed to be stored inside smart contract<br/>let global_merkle_tree_root = ...;<br/>const verification_key = ...;<br/>function init() {<br/>  // set global_merkle_tree_root and verification_key<br/>}</span><span id="cb35" class="li jx ht le b fv ln lk l ll lm">function verify_txs(proof, txs, old_merkle_root, new_merkle_root) {<br/>   assert(old_merkle_root == global_merkle_tree_root);<br/>   // in fact we will hash of txs/old_merkle_root/new_merkle_root as a single input to 'zksnark_verify' for performance. We will not discuss this detail here as it does not block understanding<br/>   assert(zksnark_verify(proof, txs, old_merkle_root, new_merkle_root);<br/>   global_merkle_tree_root = new_merkle_root;<br/>}</span></pre><p id="44ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们可以看到，除了merkle根，契约不会存储任何状态。对于每个状态更新，它需要离线模块准备完整的事务输入和证明。对于那些熟悉无状态以太坊的人来说，ZK-Rollup实际上在这方面与无状态以太坊非常相似。</p><h1 id="6ec7" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">ZK-罗博的系统架构</h1><p id="d78d" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">一个ZK汇总系统至少需要以下模块:</p><ol class=""><li id="d511" class="lo lp ht is b it iu ix iy jb lq jf lr jj ls jn lt lu lv lw dt translated">智能合同链:</li></ol><ul class=""><li id="fc74" class="lo lp ht is b it iu ix iy jb lq jf lr jj ls jn mc lu lv lw dt translated">验证每个merkle树更新的有效性，并维护正确的merkle树根；</li><li id="0be1" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn mc lu lv lw dt translated">在汇总系统停机的情况下，确保用户能够通过直接调用合同来提取他们的合法资产；</li><li id="8e35" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn mc lu lv lw dt translated">在L1和L2之间进行协调，确保用户的存款能够得到及时处理并更新到merkle树中。</li></ul><ol class=""><li id="2d33" class="lo lp ht is b it iu ix iy jb lq jf lr jj ls jn lt lu lv lw dt translated">证明者集群:进行大量的加密计算，为每个L2块生成ZK-斯纳克证明。通常需要大规模集群，消耗系统中99%以上的计算资源。</li><li id="a782" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw dt translated">状态管理器:维护完整的merkle树。对于每个事务，它更新merkle树并为证明者群集提供必要的数据(例如，merkle proof)。</li><li id="ccf0" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw dt translated">其他业务模块:像L2浏览器。此外，每个汇总系统都有自己的专业业务模块。例如，Fluidex有一个<a class="ae jp" href="https://github.com/Fluidex/dingir-exchange" rel="noopener ugc nofollow" target="_blank">订单匹配引擎</a>，它从用户的订单中生成匹配的交易，然后将它们发送给状态管理器。</li></ol><h1 id="d2e7" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">ZK的TPS限制-累计</h1><p id="4330" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">ZK卷积系统的TPS的主要约束是什么？</p><h1 id="70a7" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">证明速度</h1><p id="772f" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">证明是ZK系统中最消耗资源的部分。那些不熟悉ZK汇总的人通常错误地认为证明速度是TPS的主要限制。实际上，由于每个L2块的证明可以完全并行进行，所以使用数百个规模的证明者集群是一种常见的做法。因此，虽然ZK-斯纳克证明需要很长时间，但它将主要导致从L2撤回到L1的更长延迟，以及运营商更高的服务器成本，而不是对TPS的限制。</p><h1 id="00fb" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">记录链上数据和ETH气体限制</h1><p id="f98a" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">这是对TPS的真正限制。让我们回过头来看看整个ZK汇总设计。为确保安全性/数据可用性，每个第2层交易都应记录在交易链上。这部分数据将作为CALLDATA记录在ETH交易历史中，平均开销为16 gas/byte(EIP-2028:<a class="ae jp" href="https://eips.ethereum.org/EIPS/eip-2028" rel="noopener ugc nofollow" target="_blank">【1】</a>，<a class="ae jp" href="https://blog.iden3.io/istanbul-zkrollup-ethereum-throughput-limits-analysis.html" rel="noopener ugc nofollow" target="_blank">【2】</a>)。对于正常的转账/撮合订单，每笔交易预计为40字节(<a class="ae jp" href="https://vitalik.ca/general/2021/01/05/rollup.html" rel="noopener ugc nofollow" target="_blank">【1】</a>、<a class="ae jp" href="https://github.com/Loopring/protocols/blob/master/packages/loopring_v3/DESIGN.md#data-availability" rel="noopener ugc nofollow" target="_blank">【2】</a>)。</p><p id="1de8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们尝试通过气体限制来估计TPS限制。</p><p id="62b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每开采一个ETH区块需要约13秒，最大瓦斯量为1250万。假设groth 16/Plonk ZK-斯纳克验证花费30-50万gas(<a class="ae jp" href="https://github.com/matter-labs/awesome-zero-knowledge-proofs" rel="noopener ugc nofollow" target="_blank">【1】</a><a class="ae jp" rel="noopener" href="/matter-labs/zksync-v1-1-reddit-edition-recursion-up-to-3-000-tps-subscriptions-and-more-fea668b5b0ff">【2】</a><a class="ae jp" href="https://blog.kyber.network/research-trade-offs-in-rollup-solutions-a1084d2b444" rel="noopener ugc nofollow" target="_blank">【3】</a><a class="ae jp" href="https://zksync.io/" rel="noopener ugc nofollow" target="_blank">【4】</a><a class="ae jp" href="https://ethresear.ch/t/on-chain-scaling-to-potentially-500-tx-sec-through-mass-tx-validation/3477" rel="noopener ugc nofollow" target="_blank">【5】</a><a class="ae jp" href="https://ethresear.ch/t/roll-up-roll-back-snark-side-chain-17000-tps/3675/12" rel="noopener ugc nofollow" target="_blank">【6】</a>)，那么每个ETH块最多可以包含12，000，000/(40 * 16)～= 20，000这样，ZK汇总的TPS极限将是1500–2000。这也是白皮书中许多汇总系统声称的性能上限。</p><h1 id="6f80" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">Merkle树上的全局状态更新</h1><p id="a781" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">这是一个很少被讨论但至关重要的观点。真实世界的ZK-罗卷系统的TPS实际上更多地受到该模块的限制，而不是证明上面讨论的速度或气体限制。</p><p id="2081" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了支持大量的用户和资产，我们需要Merkle树具有一定的深度。假设我们使用如下的二叉密集account_balance merkle树，并且我们打算支持100万个用户和1000种类型的资产，那么要求merkle树的深度为30。假设每个事务将导致5-10次对merkle证明的验证，那么总共将有大约200次散列计算。</p><figure class="kz la lb lc fq me fe ff paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="fe ff md"><img src="../Images/0a5e34293d080e07e063e7e4ad662301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sr36zzx_-zrvDqiN.png"/></div></div></figure><p id="290f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">出于性能考虑，我们不会在ZK-Rollup merkle树中使用SHA3这样的普通散列。取而代之的是，我们将使用一个更兼容ZK-斯纳克的游戏，比如《海神号》或《营救》。根据Fluidex 的<a class="ae jp" href="https://github.com/Fluidex/state_keeper/blob/a80c40015984886b68a295a810c64a682ba13135/src/types/merkle_tree.rs#L326" rel="noopener ugc nofollow" target="_blank">测试结果，每个poseidon hash大约需要30us(每个测试的树深度为20，因此，每个hash将为57ms / 100 / 20 ~= 30us)。因此，从merkle树的角度来估计，ZK-Rollup系统的极限将是1 / 0.00003 / 200 = 160 TPS。</a></p><p id="e4c8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，merkle树上的<a class="ae jp" href="https://github.com/Fluidex/state_keeper/blob/a255043cbe7c899c6a8d9cc46b170a40f20623c9/src/types/merkle_tree.rs#L127" rel="noopener ugc nofollow" target="_blank">并行更新</a>对于突破100–300 TPS水平至关重要。与可以完全并行化的计算ZK-斯纳克证明不同，并行化merkle树更新需要更多的判断力，并且很难在其上应用分布式计算。这也是一个技术挑战。</p><p id="3247" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">上面计算的100-300 TPS接近许多真实世界的ZK系统的实际性能上限。</p><h1 id="9aff" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">经济成本分析</h1><h1 id="f055" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">ZK汇总通常需要数千个CPU核心来证明</h1><p id="3531" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">我们还是以Fluidex使用的<a class="ae jp" href="https://github.com/fluidex/awesome-plonk" rel="noopener ugc nofollow" target="_blank">PLONK</a>T6】电路作为典型的ZK-罗勃案例。在我们最新的测试中，对于每个有100个事务的L2块，在24核服务器上运行一个证明需要大约20分钟。为了达到100 TPS的性能，我们将需要大约300个ec2c 5.12 x大型实例，其成本大约为500美元/小时。这意味着在链外计算中，每个第2层事务将花费0.001美元。请注意，我们还没有在性能优化上投入太多，我们预计未来会有很多改进。</p><h1 id="db1c" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">链上气体成本远远高于链外服务器成本</h1><p id="06e5" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">上面提到的链外计算成本，和链上气成本相比，其实是杯水车薪。假设每个第2层交易需要40字节的链上数据，ETH约为2000美元，天然气价格为200 Gwei，则每个链上交易的成本约为2.6美元。这远远高于0.001美元的链外交易。然而，这也比复杂的第1层交易低得多，在第1层交易中，天然气成本通常至少为几十美元。这就是为什么我们经常说ZK汇总可以带来至少两个数量级的成本节约。</p><h1 id="1a6c" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">低成本效益的云GPU服务</h1><p id="7ea0" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">许多开发人员可能想知道GPU会给计算能力带来什么。在ZK-斯纳克证明中，GPU可以将计算速度提高约3-5倍。但另一方面，由于虚拟化的不成熟，来自云服务的GPU相对于CPU的成本来说过于昂贵。以至于在深度学习模型训练中甚至出现了<a class="ae jp" href="https://minimaxir.com/2017/07/cpu-or-gpu/" rel="noopener ugc nofollow" target="_blank"> CPU比GPU </a>便宜的情况。因此，如果您不构建自己的数据中心，而是使用云服务，使用GPU进行ZK验证将是一个低边际效用的选择。</p><p id="535c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当然，上述所有分析数据都会受到系统效率和ETH气价的影响，但在可预见的未来不太可能出现数量级的偏离。</p><h1 id="dd19" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">各种开发经验</h1><h2 id="0c14" class="li jx ht bd jy ml mm mn kc mo mp mq kg jb mr ms kk jf mt mu ko jj mv mw ks mx dt translated">为什么ZK-斯纳克逻辑描述被称为“电路”？</h2><p id="5a99" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">对于任何有软件工程师经验的人来说，在下面的代码中，只执行if- branch和else- branch中的一个，而不是两个都执行并且只选择一个。</p><pre class="kz la lb lc fq ld le lf lg aw lh dt"><span id="463f" class="li jx ht le b fv lj lk l ll lm">function binaryOp(op, arg1, arg2) {<br/>  if (op == "add") {<br/>    return arg1 + arg2;<br/>  } else {<br/>    // assert(op == 'mul');<br/>    return arg1 * arg2;<br/>  }<br/>}</span></pre><p id="511b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这种“只执行一个条件分支”的概念对于软件开发来说似乎很自然，但对于硬件芯片电路的设计来说却并非如此。在硬件时序逻辑电路的开发中，所有“分支”(如果仍称为“分支”)的逻辑将在序列被触发时执行。开发人员需要从不同的“分支”中选择和维护正确的全局状态。</p><p id="70e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在ZKP系统中，程序逻辑最终会转化为一些巨大的多项式(可能有上亿项)，这被称为算术化，这样程序的证明就转化为多项式的证明。然后多项式被限制在门电路的形式中。这也是我们称ZKP程序为回路的原因之一。因此，代码具有与硬件电路相同的属性:来自所有分支的代码将一起执行。这就是为什么ZK证明代码被称为“电路”。另外，与硬件电路类似，ZK证明电路中不存在递归和复杂循环，循环数只能是常数(实际上循环会被展开为句法糖，即循环展开)。</p><p id="e5d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，在开发ZK验证电路时，开发人员需要从软件开发的角度重新考虑他们的习惯。例如，当优化软件时，我们可以把注意力集中在最频繁执行的分支上，把不频繁执行的分支降低优先级。但是在ZK验证电路中，由于所有分支都将被执行，所以非频繁分支也需要被考虑。</p><h1 id="2f66" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">对DSL的看法</h1><p id="ac6f" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">ZK验证电路开发有几种选择，比如像<a class="ae jp" href="https://github.com/HarryR/ethsnarks" rel="noopener ugc nofollow" target="_blank">ethsnarks</a>/<a class="ae jp" href="https://github.com/zkcrypto/bellman" rel="noopener ugc nofollow" target="_blank">bellman</a>这样的低级计算库，或者像<a class="ae jp" href="https://github.com/Zokrates/ZoKrates" rel="noopener ugc nofollow" target="_blank">ZoKrates</a>/<a class="ae jp" href="https://github.com/iden3/circom" rel="noopener ugc nofollow" target="_blank">Circom</a>/<a class="ae jp" href="https://github.com/matter-labs/zinc" rel="noopener ugc nofollow" target="_blank">Zinc</a>这样的DSL。</p><p id="5e7f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们选择了Circom，它提供了恰到好处的抽象层次。一方面提高了读/写代码的效率，另一方面不扭曲底层电路的细节。</p><p id="49a2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">相比之下，用ethsnarks和bellman开发效率较低。此外，当审查代码时，无论是内部还是外部，太多的“语法噪音”会阻止审查者专注于核心逻辑。此外，ZoKrates和Zinc提供了过高的抽象级别。例如，ZoKrates中python风格的控制流语法隐藏了底层电路，不利于更低级别的优化(如C/Rust的内联汇编)。</p><p id="aef7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">打个比方，ethsnarks / bellman就像传统开发中的汇编语言，cirom就像C，ZoKrates就像Python。但是ZoKrates工具链还没有Python解释器成熟。这就是为什么我们宁愿使用“C”(本例中为cirom)作为我们的开发语言，而不是同时维护“Python”(本例中为ZoKrates)代码和“CPython interpreter”(本例中为ZoKrates interpreter)代码。</p><p id="b04f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，Circom本质上仍然是R1CS DSL。Fluidex实际上使用了PLONK proof系统。我们可能会对Circom进行重大修改，以更好地利用PLONK，包括支持自定义门、plookup、聚合和递归等。</p><h1 id="5ef3" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">办理存取款不容易</h1><p id="de24" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">正确处理存款/取款根本不容易:例如，我们需要考虑块恢复、具有不同优先级的操作、契约迁移等等。</p><p id="5cce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们应该始终小心处理存款和取款，因为它实际上会影响用户在以太坊第1层的资产。</p><p id="6b66" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以下是我们需要考虑的事项的非详尽列表:</p><ul class=""><li id="1ad7" class="lo lp ht is b it iu ix iy jb lq jf lr jj ls jn mc lu lv lw dt translated">如果未及时验证已提交的L2数据块，则应恢复状态。</li><li id="72e8" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn mc lu lv lw dt translated">如果汇总未能及时提交L2块或提交证明，或者长时间未处理优先级操作，则需要暂停汇总，我们应该为用户提供一种提取资金的方法。</li><li id="a713" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn mc lu lv lw dt translated">Loopring还描述了一个有趣的<a class="ae jp" href="https://github.com/Loopring/protocols/blob/master/packages/loopring_v3/DESIGN.md#withdrawal-fee-griefing" rel="noopener ugc nofollow" target="_blank">取款费攻击</a>，以及它的解决方案。</li></ul><p id="466f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Hermez使用<em class="jo">取款延迟器</em>来管理取款，为处理意外情况留出时间。</p><h1 id="d4cc" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">进一步阅读</h1><h1 id="568f" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">技术博客</h1><ul class=""><li id="50c3" class="lo lp ht is b it ku ix kv jb my jf mz jj na jn mc lu lv lw dt translated"><a class="ae jp" href="https://vitalik.ca/general/2021/01/05/rollup.html" rel="noopener ugc nofollow" target="_blank">维塔利科博客汇总</a></li><li id="95b6" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn mc lu lv lw dt translated">ZK-斯纳克的维塔利科博客</li><li id="c5a9" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn mc lu lv lw dt translated"><a class="ae jp" href="https://docs.ethhub.io/ethereum-roadmap/ethereum-2.0/stateless-clients/" rel="noopener ugc nofollow" target="_blank">无状态以太坊</a></li></ul><h1 id="cebf" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">项目</h1><p id="2f7f" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">启动的ZK累计项目:</p><ul class=""><li id="380b" class="lo lp ht is b it iu ix iy jb lq jf lr jj ls jn mc lu lv lw dt translated">zksync:ZK-Rollup最完整的开源代码，包含了ZK-roll up系统的所有模块。它使用PLONK协议，bellman用于电路，Rust用于外链代码。</li><li id="48e0" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn mc lu lv lw dt translated"><a class="ae jp" href="https://github.com/hermeznetwork/" rel="noopener ugc nofollow" target="_blank"> hermez </a>:类似zksync。它使用Groth16协议，Circom用于电路，Go用于链外代码。</li><li id="6758" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn mc lu lv lw dt translated"><a class="ae jp" href="https://github.com/Loopring/protocols/tree/master/packages/loopring_v3" rel="noopener ugc nofollow" target="_blank"> loopring </a>:开源中只有电路代码和契约。它使用Groth16协议，ethsnark用于电路。外链代码还没有开源。</li></ul><p id="29e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">正在开发的ZK汇总项目:</p><ul class=""><li id="63ef" class="lo lp ht is b it iu ix iy jb lq jf lr jj ls jn mc lu lv lw dt translated"><a class="ae jp" href="https://github.com/Fluidex" rel="noopener ugc nofollow" target="_blank"> fluidex </a>:开源的电路、状态管理器、匹配引擎。它使用PLONK协议，circom用于电路，Rust用于链外代码。</li></ul><p id="8ca9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用ZK-斯纳克的非ZK汇总项目:</p><ul class=""><li id="60de" class="lo lp ht is b it iu ix iy jb lq jf lr jj ls jn mc lu lv lw dt translated"><a class="ae jp" href="https://github.com/appliedzkp/maci/" rel="noopener ugc nofollow" target="_blank"> MACI </a></li><li id="55af" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn mc lu lv lw dt translated"><a class="ae jp" href="https://github.com/tornadocash" rel="noopener ugc nofollow" target="_blank">龙卷风现金</a></li></ul><h1 id="97cb" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">关于我们</h1><p id="c513" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">我们是<a class="ae jp" href="https://www.fluidex.io/posts/2020-11-30-fluidex-a-zkrollup-layer2-dex/" rel="noopener ugc nofollow" target="_blank"> Fluidex的开发团队:以太坊</a>上的第二层ZK-Rollup DEX。</p></div></div>    
</body>
</html>