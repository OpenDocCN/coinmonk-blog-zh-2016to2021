<html>
<head>
<title>Drizzle DAPP with Meteor backend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">毛毛雨DAPP与流星后端</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/drizzle-dapp-with-meteor-backend-b16ff0a8dd11?source=collection_archive---------7-----------------------#2018-06-22">https://medium.com/coinmonks/drizzle-dapp-with-meteor-backend-b16ff0a8dd11?source=collection_archive---------7-----------------------#2018-06-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="4104" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于一些区块链项目，我们需要使用应用服务器以旧的方式存储信息。它可以是一个私人客户信息，也可以是一个BLOB，由于燃气成本，我们无法将它存储在以太坊中。在这种情况下，我们可以使用分布式数据协议(DDP ),它解决了所有开发人员都面临的许多问题:查询服务器端数据库，将结果发送到客户端，然后每当数据库发生任何变化时，就将变化推送到客户端。</p><p id="5485" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本文中，我们将展示如何在Truffle/毛毛雨分布式应用程序中使用支持DDP的Meteor后端。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/e5437f55a72b800d73131f70baef87db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MCoVM6sNl5M4d0ulVGzbnA.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Truffle/Drizzle/Meteor Application Map</figcaption></figure><p id="c35d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">先从DAPP这边说起吧。只需打开<a class="ae ke" href="https://truffleframework.com/boxes/drizzle" rel="noopener ugc nofollow" target="_blank">毛毛雨盒</a>，我们就可以在几个步骤中运行DAPP。现在我们需要向我们的毛毛雨/松露应用程序添加一个支持DDP协议的库。在我们的例子中，我们使用了<a class="ae ke" href="https://github.com/mondora/asteroid" rel="noopener ugc nofollow" target="_blank"> Asteroid </a>，这是一个同构/通用的javascript库，它允许从几乎任何JS环境连接到Meteor后端。为了监听我们的服务器，我们需要提供一个端点并创建新的小行星对象。</p><pre class="jp jq jr js fq kf kg kh ki aw kj dt"><span id="c36b" class="kk kl ht kg b fv km kn l ko kp">const Asteroid = createClass();</span><span id="98ca" class="kk kl ht kg b fv kq kn l ko kp">// Connect to a Meteor backend<br/>const asteroid = new Asteroid({<br/>  endpoint: 'ws://localhost:9000/websocket',<br/>});</span></pre><p id="0679" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后我们可以使用<em class="kr"> asteroid.subscribe </em>功能订阅我们的收藏。</p><p id="47c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于我们的DAPP已经在使用一个Redux商店，我们可以用它来记录状态变化，并在需要时更新用户界面。例如，如果一个新的记录被添加到我们的服务器集合中，我们将分派一个新的操作来保存这些更改。</p><pre class="jp jq jr js fq kf kg kh ki aw kj dt"><span id="b86f" class="kk kl ht kg b fv km kn l ko kp">asteroid.ddp.on('added', (doc) =&gt; {<br/>  if (doc.collection === 'tasks') {<br/>    const docObj = Object.assign({}, doc.fields, { _id: doc.id });<br/>    store.dispatch(addTodo(docObj));<br/>  }<br/>  if (doc.collection === 'users') {<br/>    store.dispatch(setLoggedUser(doc.fields));<br/>  }<br/>});</span></pre><p id="bdf5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了遵循Redux store规则，我们还需要为我们的分布式集合创建一个<a class="ae ke" href="https://redux.js.org/basics/reducers" rel="noopener ugc nofollow" target="_blank"> Reducer </a>。</p><pre class="jp jq jr js fq kf kg kh ki aw kj dt"><span id="d043" class="kk kl ht kg b fv km kn l ko kp">const todos = (state = [], action) =&gt; {<br/>  switch (action.type) {<br/>    case ADD_TODO:<br/>      return add(state, action);<br/>    case REMOVE_TODO:<br/>      return remove(state, action);<br/>    case EDIT_TODO:<br/>      return edit(state, action);<br/>    case GET_ALL_TODO:<br/>      return action.data;<br/>    default:<br/>      return state;<br/>  }<br/>};</span></pre><p id="f447" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后将其添加到我们的毛毛雨框中定义的组合减速器中。</p><pre class="jp jq jr js fq kf kg kh ki aw kj dt"><span id="44c5" class="kk kl ht kg b fv km kn l ko kp">const reducer = combineReducers({<br/>  routing: routerReducer,<br/>  todos,<br/>  user,<br/>  ...drizzleReducers<br/>})<br/>export default reducer</span></pre><p id="79dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我们的例子中，我们有<em class="kr"> HomeContainer </em>，它包装了我们的<em class="kr"> Home </em>组件，并提供了组件<em class="kr"> props的状态转换。</em>现在我们需要将分布式集合添加到映射中，以便在React中访问我们的服务器数据。</p><pre class="jp jq jr js fq kf kg kh ki aw kj dt"><span id="8fbe" class="kk kl ht kg b fv km kn l ko kp">const mapStateToProps = state =&gt; {<br/>  return {<br/>    accounts: state.accounts,<br/>    SimpleStorage: state.contracts.SimpleStorage,<br/>    TutorialToken: state.contracts.TutorialToken,<br/>    drizzleStatus: state.drizzleStatus,<br/>    todos: state.todos,<br/>    user: state.user,<br/>  }<br/>}</span><span id="c58b" class="kk kl ht kg b fv kq kn l ko kp">const mapDispatchToProps = dispatch =&gt; ({<br/>  dispatchCallAddTodo: data =&gt; dispatch(callAddTodo(data)),<br/>});</span><span id="6d39" class="kk kl ht kg b fv kq kn l ko kp">Home.contextTypes = {<br/>  drizzle: PropTypes.object<br/>}</span><span id="7e71" class="kk kl ht kg b fv kq kn l ko kp">const HomeContainer = drizzleConnect(Home, mapStateToProps, mapDispatchToProps);</span></pre><p id="29c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意，我们还添加了<em class="kr"> mapDispatchToProps </em>来为<em class="kr"> Home </em>组件提供向集合添加数据的能力。然后使用<em class="kr">trissleconnect将两个映射连接到React组件。</em></p><p id="8c29" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以，现在我们准备更新<em class="kr"> Home </em>组件，并添加一个逻辑来显示我们的服务器数据。</p><pre class="jp jq jr js fq kf kg kh ki aw kj dt"><span id="105c" class="kk kl ht kg b fv km kn l ko kp">&lt;h3&gt;Todos&lt;/h3&gt;<br/>&lt;div&gt;<br/>  &lt;input<br/>    type="text"<br/>    placeholder="Add todo item ..."<br/>    onKeyPress={this.handleAddTodo}<br/>  /&gt;<br/>&lt;/div&gt;<br/>&lt;ul&gt;<br/>  {this.props.todos.map((t, i) =&gt;<br/>    &lt;li key={i}&gt;<br/>      &lt;span className="text"&gt;<br/>        &lt;strong&gt;{t.data !== undefined ? t.data :'n/a'}&lt;/strong&gt;:      <br/>        {t.text}<br/>      &lt;/span&gt;<br/>    &lt;/li&gt;<br/>  )}<br/>&lt;/ul&gt;</span></pre><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff ks"><img src="../Images/9b38bfca6aa7088fc85547497e4d27f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85ubC_u9Vx3ydjiA95sHaw.png"/></div></div></figure><p id="6377" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意，由于DDP，我们可以作为<em class="kr">props</em>parameter<em class="kr"/>访问React组件中的服务器集合，如果服务器集合被更新，那么我们的React组件将被重新呈现以向用户提供刷新的数据。</p><p id="6640" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们已经使用Asteroid javascript libraly将毛毛雨/松露DAPP与流星后端连接起来，但这只是我们需要解决的一个任务。我们的下一个目标是根据智能合同状态更新DAPP订阅。为此，我们将使用“开箱即用”的毛毛雨<em class="kr">简单存储</em>智能联系。</p><pre class="jp jq jr js fq kf kg kh ki aw kj dt"><span id="d527" class="kk kl ht kg b fv km kn l ko kp">pragma solidity ^0.4.18;</span><span id="24a9" class="kk kl ht kg b fv kq kn l ko kp">contract SimpleStorage {</span><span id="6824" class="kk kl ht kg b fv kq kn l ko kp">  event StorageSet( string _message );</span><span id="36fe" class="kk kl ht kg b fv kq kn l ko kp">  uint public storedData;</span><span id="7b66" class="kk kl ht kg b fv kq kn l ko kp">  function set(uint x) public { <br/>    storedData = x;<br/>    StorageSet("Data stored successfully!");<br/>  }<br/>}</span></pre><p id="5d2c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在让我们看看我们的后端，并在那里集成智能合同逻辑。多亏了Truffle框架，我们可以使用我们已经在DAPP中使用的相同的人工制品。需要说明的是，后端也有在Meteor/React控制下运行的客户端部分。我们不打算在服务器端进行事务处理，我们将在这里使用没有任何密钥存储的<em class="kr"> web3 </em>库。后端客户端部分可以使用带有元掩码的Truffle库。为了更新React组件，我们使用<em class="kr"> withTracker </em>函数<em class="kr"> </em>和<em class="kr"> </em> with <em class="kr"> Tracker。依赖关系</em>对象<em class="kr">。</em>在智能契约包装类中，我们有简单的getters和setters，它们具有<em class="kr"> depend </em>和<em class="kr"> changed </em>函数。</p><pre class="jp jq jr js fq kf kg kh ki aw kj dt"><span id="05c5" class="kk kl ht kg b fv km kn l ko kp">const contractDep = new Tracker.Dependency;</span><span id="ef07" class="kk kl ht kg b fv kq kn l ko kp">class SimpleStorage {<br/>  //...<br/>  getData() {<br/>    contractDep.depend();<br/>    return this.data;<br/>  }</span><span id="a63a" class="kk kl ht kg b fv kq kn l ko kp">  _setData(data) {<br/>    if(this.data !== data) {<br/>      this.data = data;<br/>      contractDep.changed();<br/>    }<br/>  }<br/>  // ...<br/>}</span></pre><p id="53eb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在在<em class="kr">带跟踪器</em>的循环中，如果合同数据改变，那么组件<em class="kr">道具</em>将被更新，然后React组件将被重新渲染。</p><pre class="jp jq jr js fq kf kg kh ki aw kj dt"><span id="51de" class="kk kl ht kg b fv km kn l ko kp">class App extends Component {<br/>  // ...<br/>  export default withTracker(() =&gt; {<br/>    const update = simpleStorage.getData();<br/>    Meteor.subscribe('tasks');</span><span id="ee9b" class="kk kl ht kg b fv kq kn l ko kp">    return {<br/>      tasks: Tasks.find({}, { sort: { createdAt: -1 } }).fetch(),<br/>      incompleteCount: Tasks.find({ <br/>          checked: { $ne: true } }).count(),<br/>      currentUser: Meteor.user(),<br/>      currentData: simpleStorage.getData(),<br/>    };<br/>})(App);</span></pre><p id="0ae6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们将更新后端服务器部分，并根据智能合同的当前状态进行发布。在服务器上，我们使用<em class="kr"> web3 </em>库来监听<em class="kr">简单存储</em>事件。</p><pre class="jp jq jr js fq kf kg kh ki aw kj dt"><span id="083f" class="kk kl ht kg b fv km kn l ko kp">let listener = null;</span><span id="736c" class="kk kl ht kg b fv kq kn l ko kp">function setListener(cb) {<br/>  listener = cb;<br/>}</span><span id="9329" class="kk kl ht kg b fv kq kn l ko kp">if (Meteor.isServer) {<br/>  if (typeof web3 !== 'undefined') {<br/>    web3 = new Web3(web3.currentProvider);<br/>  } else {<br/>    web3 = new Web3(new<br/>    Web3.providers.WebsocketProvider("ws://localhost:8545"));<br/>  }<br/>  const sc = new web3.eth.Contract(SimpleStorageArtifact.abi);<br/>  sc.options.address = SimpleStorageArtifact.networks[5777].address;</span><span id="705a" class="kk kl ht kg b fv kq kn l ko kp">  sc.events.StorageSet({fromBlock:0}, <br/>    (error, event) =&gt; { if(error)console.error(event) })<br/>     .on('data', function(event) {<br/>       sc.methods.storedData().call().then(result =&gt; {<br/>         if(listener) {<br/>           listener(result)<br/>         });<br/>   })<br/>}<br/>export default setListener</span></pre><p id="26aa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们可以调整集合的发布</p><pre class="jp jq jr js fq kf kg kh ki aw kj dt"><span id="59b4" class="kk kl ht kg b fv km kn l ko kp">let collectionFilter</span><span id="d2f6" class="kk kl ht kg b fv kq kn l ko kp">function setFilter(filter) {<br/>  if(filter === undefined) return;<br/>  collectionFilter = filter;<br/>}<br/>setListener(setFilter)</span><span id="aab4" class="kk kl ht kg b fv kq kn l ko kp">if (Meteor.isServer) {<br/>  Meteor.publish('tasks', function tasksPublication(data) {<br/>    return Tasks.find({<br/>      $or: [<br/>        { private: { $ne: true } },<br/>        { data: collectionFilter },<br/>      ],<br/>    });<br/>  });<br/>}</span></pre><p id="f3e1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以我们只发布数据等于<em class="kr"> </em>到<em class="kr">集合过滤器</em>的项目，即<em class="kr">简单存储</em>数据。这里的问题是<em class="kr"> Meteor.publish </em>不重新发布集合，如果<em class="kr"> collectionFilter </em>改变的话。只有客户端可以推送服务器发布并使<em class="kr">任务. find </em>重新运行以提供新数据。由于跟踪流星重新运行订阅和推重新发布，如果订阅参数被改变。因此，我们可以通过以下方式更新后端客户端订阅以获得重新发布的作品:</p><pre class="jp jq jr js fq kf kg kh ki aw kj dt"><span id="cf7c" class="kk kl ht kg b fv km kn l ko kp">export default withTracker(() =&gt; {</span><span id="9245" class="kk kl ht kg b fv kq kn l ko kp">  const update = simpleStorage.getData();<br/>  Meteor.subscribe('tasks', <br/>    update !== undefined ? update.toString(10) : 'loading');<br/>  // ..</span><span id="295b" class="kk kl ht kg b fv kq kn l ko kp">}</span></pre><p id="1a46" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们需要回到我们的DAPP，使订阅工作也在这里。首先，如果商店状态由于智能合约事务而改变，我们将获得更新，然后如果我们有新的状态，则取消订阅集合，并使用更新的<em class="kr"> SimpleStorage </em>数据值再次订阅。</p><pre class="jp jq jr js fq kf kg kh ki aw kj dt"><span id="af97" class="kk kl ht kg b fv km kn l ko kp">function _select(state) {<br/>  return state.contracts.SimpleStorage.storedData['0x0'] !==   undefined ? state.contracts.SimpleStorage.storedData['0x0'].value : undefined;<br/>}<br/>let currentValue = 0;<br/>let subscription = asteroid.subscribe('tasks', currentValue);</span><span id="9694" class="kk kl ht kg b fv kq kn l ko kp">function _refresh() {<br/>  let previousValue = currentValue<br/>  currentValue = _select(store.getState())<br/>  if (previousValue !== currentValue) {<br/>    asteroid.unsubscribe(subscription.id);<br/>    subscription = asteroid.subscribe('tasks', currentValue);<br/>  }<br/>}<br/>store.subscribe(_refresh);</span></pre><p id="9d12" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们的DAPP使用<em class="kr"> SimpleStorage </em>作为一个键，为客户端“打开”离线数据。我们的后端部分正在监听区块链事件，一旦有新的事务到达，就向客户端开放对新内容的访问。当客户端使用Asteroid <em class="kr">更新订阅/subscribe </em>时，新的内容将在React界面中可用。</p><p id="80d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的<a class="ae ke" href="https://github.com/REGA-RS/meteor-drizzle" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中的完整代码</p></div></div>    
</body>
</html>