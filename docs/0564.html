<html>
<head>
<title>Practicing Safemath for Smart Contracts with Solidity and Openzeppelin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Solidity和Openzeppelin实践智能合约的安全数学</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/practicing-safemath-with-solidity-and-openzeppelin-cde4cba9ce39?source=collection_archive---------0-----------------------#2018-05-18">https://medium.com/coinmonks/practicing-safemath-with-solidity-and-openzeppelin-cde4cba9ce39?source=collection_archive---------0-----------------------#2018-05-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/48591cf424a2fda170763eb853159552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJTTWxoDqrP1PeShGp5zgQ@2x.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">View of Navy Pier from the Distributed Confrence</figcaption></figure></div><div class="ab cl jf jg hb jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hm hn ho hp hq"><p id="5a9d" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">在我开始学习更多关于分布式账本技术的时候，我遇到了Solidity，但后来我试图查找其他智能契约语言，如Viper或LLL。我对这个断言大错特错，因为这个领域的真正领导者是Solidity，它与Javascript紧密结合。所有的EVM语言要么是原型，要么是废弃的原型。LLL作为编译目标会很有用，因为它非常接近机器码(在这方面它实际上让我想起了prescheme)。</p><p id="cbb6" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">这是我第二个真正的Solidity程序，我没有使用inherits。我在做下面的教程(我推荐的)来自<a class="ae kk" href="http://truffleframework.com/tutorials/debugger-variable-inspection" rel="noopener ugc nofollow" target="_blank">http://truffle framework . com/tutorials/debugger-variable-inspection</a>。在本教程中，他们回顾了斐波那契数列。我想我也会尝试尝试类似的项目。在不知道如何在Solidity中编写阶乘函数之后，我决定尝试编写一个计算Lucas数的程序。</p><p id="c5d4" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">首先回忆一下斐波那契数列(1，1，2，3，5…)。这个数列是如何产生的，你把最后两个数相加，得到下一个数。一个区别是前两个数字都是1。卢卡斯数字是一个类似于斐波那契数字的整数序列，除了起始数字是$L_1 = 2$和L_2+1。这就给出了卢卡斯数(2，1，3，4，7…)。</p><pre class="kl km kn ko fq kp kq kr ks aw kt dt"><span id="2229" class="ku kv ht kq b fv kw kx l ky kz">pragma solidity ^0.4.22;</span><span id="1454" class="ku kv ht kq b fv la kx l ky kz">contract Lucas {</span><span id="65cb" class="ku kv ht kq b fv la kx l ky kz">uint[] lucseries;</span><span id="1ace" class="ku kv ht kq b fv la kx l ky kz">  // n = how many in the series to return<br/>  function generateLuc(uint n) public {</span><span id="4355" class="ku kv ht kq b fv la kx l ky kz">    // set 1st and 2nd entries<br/>    lucseries.push(2);<br/>    lucseries.push(1);</span><span id="290e" class="ku kv ht kq b fv la kx l ky kz">    // generate subsequent entries<br/>    for (uint i=2; i &lt; n ; i++) {<br/>      lucseries.push(lucseries[i-1] + lucseries[i-2]);<br/>    }</span><span id="5d89" class="ku kv ht kq b fv la kx l ky kz">   }</span><span id="ea6a" class="ku kv ht kq b fv la kx l ky kz">}</span></pre><p id="ed15" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">这实际上是一个玩具实现。如果我们想正确地练习safemath，我们真的需要分析程序并在需要的地方应用它。现在，既然我们知道卢卡斯数列类似于斐波那契数列，它会增加(除了我们忽略的第一个数字)，我们必须使用Safemath将智能合约中的加法替换为加法。下面是相同的程序，但使用的是safemath库。</p><pre class="kl km kn ko fq kp kq kr ks aw kt dt"><span id="52e1" class="ku kv ht kq b fv kw kx l ky kz">pragma solidity ^0.4.22;<br/>import "github.com/OpenZeppelin/zeppelin-solidity/contracts/math/SafeMath.sol";</span><span id="1ac6" class="ku kv ht kq b fv la kx l ky kz">contract Lucas {<br/>   <br/>   using SafeMath for uint; // <br/>   uint[] lucseries;<br/>   // n = how many in the series to return<br/>   function generateLuc(uint n) public {<br/>    // set 1st and 2nd entries<br/>    lucseries.push(2);<br/>    lucseries.push(1);<br/>    // generate subsequent entries<br/>    for (uint i=2; i &lt; n ; i++) {<br/>      lucseries.push(lucseries[i-1].add( lucseries[i-2]));<br/>    }<br/>   }<br/>}</span></pre><p id="b651" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">现在，当我们想要计算一大串卢卡斯数时，我们得到了一个异常。注意，我在这里没有用add来做减法，因为这不会触发下溢，但是由于程序设计的原因，我们可以触发上溢。读者可以做一个练习，看看运行上面的程序会发生什么，以及它是如何抛出异常的？我知道人们实际上讨厌锻炼，所以实际上发生的是它不会溢出。这真的让我大吃一惊，但它似乎在Javascript模拟器中给出了一个错误“无效操作码”。所以程序在第111次迭代时失败。</p><figure class="kl km kn ko fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lb"><img src="../Images/d51c12cf393842963bdbabb54e6de748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUFDxWQMLdNPxUE1Vwbuyw.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Computation of the Lucas Number in Solidity fails at the 111th iteration</figcaption></figure><p id="78f8" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">为了查看safemath触发异常时实际发生了什么，让我们在一个简单的智能合约中添加两次2 ⁵⁶-1。</p><pre class="kl km kn ko fq kp kq kr ks aw kt dt"><span id="cf97" class="ku kv ht kq b fv kw kx l ky kz">pragma solidity ^0.4.22;<br/>import "github.com/OpenZeppelin/zeppelin-solidity/contracts/math/SafeMath.sol";</span><span id="2c08" class="ku kv ht kq b fv la kx l ky kz">contract Exception {<br/>   <br/>   using SafeMath for uint; // <br/>   uint two_to_the_256_power_minus_one = 115792089237316195423570985008687907853269984665640564039457584007913129639935; //2 to the 256 power minus 1<br/>   uint more = two_to_the_256_power_minus_one + two_to_the_256_power_minus_one;<br/>    <br/>}</span></pre><p id="a45c" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">在这里，我们得到了我们所希望的例外！</p><figure class="kl km kn ko fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lc"><img src="../Images/b256de74674673b471374b3fa5112c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kxVVTemGLqq8hWwgoTsEPw.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Practicing Safemath and getting the exception you desire.</figcaption></figure><p id="be18" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">我们希望触发这个异常，而不是整数下溢，因为这可能会导致真正的安全缺陷，并花费您大量的金钱。</p><p id="3f58" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">请注意，我使用的语法只有在Remix中才能找到。当在一个非混合的智能合同中使用它时，你需要通过一个相对包含来包含文件，它不接受URL。</p><p id="3f7d" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">无论如何，我希望你发现这篇博文非同寻常。想看更多就跟我来！我接下来的博文将围绕开发ICO原型展开，敬请关注！</p><p id="bc58" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">如果你想把ETH捐给我，你可以通过以下地址:</p><p id="98a3" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated"><strong class="jo hu">0x 3d krzvdjxaanbmnjidvr 5 ronjt 9 hkplxn</strong></p></div></div>    
</body>
</html>