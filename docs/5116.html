<html>
<head>
<title>How to use low level call for contract function calls and payments in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Solidity中使用合同函数调用和支付的低级调用</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-use-low-level-call-for-contract-function-calls-and-payments-in-solidity-dbd4e7146c14?source=collection_archive---------5-----------------------#2021-08-05">https://medium.com/coinmonks/how-to-use-low-level-call-for-contract-function-calls-and-payments-in-solidity-dbd4e7146c14?source=collection_archive---------5-----------------------#2021-08-05</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/cfbc4d4ca3e7c62ad89ad8c0c1eeed15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vm7FYL5t4vGFf4frQoXsGQ.jpeg"/></div></div></figure><p id="4a48" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity在<code class="eh jz ka kb kc b">address</code>数据类型上有<code class="eh jz ka kb kc b">call</code>函数，可用于调用契约上的公共和外部函数。它也可以用来传输以太网地址。</p><p id="0b2d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh jz ka kb kc b">call</code>在大多数情况下不推荐用于契约函数调用，因为它绕过了类型检查、函数存在检查和参数打包。最好是导入契约的接口，在上面调用函数。</p><p id="de2b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh jz ka kb kc b">call</code>用于调用合同的<code class="eh jz ka kb kc b">fallback</code>和<code class="eh jz ka kb kc b">receive</code>功能。当在函数调用中没有发送数据并且发送了以太网时，调用Receive。当没有与调用匹配的函数签名时，调用回退函数。</p><p id="7d50" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh jz ka kb kc b">call</code>比调用契约实例上的函数消耗更少的气体。因此在某些情况下<code class="eh jz ka kb kc b">call</code>是气体优化的首选。</p><p id="42c4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">坚固度还有2个低级功能<code class="eh jz ka kb kc b">delegatecall</code>和<code class="eh jz ka kb kc b">staticcall</code>。<code class="eh jz ka kb kc b">staticcall</code>与<code class="eh jz ka kb kc b">call</code>完全相同，唯一不同的是它不能修改被调用合同的状态。<code class="eh jz ka kb kc b">delegatecall</code>下面讨论。</p><h1 id="98bf" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">如何使用调用方法？</h1><p id="be5c" class="pw-post-body-paragraph jb jc ht jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy hm dt translated">要使用<code class="eh jz ka kb kc b">call</code>，您需要将编码数据作为参数发送。数据将函数签名和参数一起编码。</p><pre class="lg lh li lj fq lk kc ll lm aw ln dt"><span id="28c3" class="lo ke ht kc b fv lp lq l lr ls"><strong class="kc hu">function</strong> myFunction(<strong class="kc hu">uint</strong> _x, <strong class="kc hu">address</strong> _addr) <strong class="kc hu">public</strong> <strong class="kc hu">returns</strong>(<strong class="kc hu">uint</strong>, <strong class="kc hu">uint</strong>) {<br/>    <em class="lt">// do something<br/>    </em><strong class="kc hu">return</strong> (a, b);<br/>}</span><span id="6cd2" class="lo ke ht kc b fv lu lq l lr ls"><em class="lt">// function signature string should not have any spaces<br/></em>(<strong class="kc hu">bool</strong> success, <strong class="kc hu">bytes</strong> <strong class="kc hu">memory</strong> result) <strong class="kc hu">=</strong> addr.call(abi.encodeWithSignature("myFunction(uint,address)", 10, msg.sender);</span></pre><p id="6a29" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh jz ka kb kc b">call</code>函数的返回值是一个布尔和字节数组的元组。boolean表示调用的成功或失败状态，bytes数组包含需要解码的被调用契约函数的返回值。</p><p id="fc30" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要获得实际数据类型的结果值，您必须使用<code class="eh jz ka kb kc b">abi.decode</code></p><pre class="lg lh li lj fq lk kc ll lm aw ln dt"><span id="3a5d" class="lo ke ht kc b fv lp lq l lr ls">(<strong class="kc hu">uint</strong> a, <strong class="kc hu">uint</strong> b) <strong class="kc hu">=</strong> abi.decode(result, (<strong class="kc hu">uint</strong>, <strong class="kc hu">uint</strong>));</span></pre><p id="7e5d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">decode方法接受从函数调用返回的字节数组和数据类型元组。返回值的顺序与数据类型元组的顺序相同。</p><p id="a5a2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh jz ka kb kc b">call</code>方法不抛出任何错误，代码继续执行。你必须亲自检查成功状态，并根据成功或失败完成必要的任务。</p><p id="2782" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果传递给<code class="eh jz ka kb kc b">call</code>方法的函数不存在，则调用契约的<code class="eh jz ka kb kc b">fallback</code>函数。如果合同中没有实现<code class="eh jz ka kb kc b">fallback</code>函数，则<code class="eh jz ka kb kc b">call</code>方法将返回成功状态为假。</p><h1 id="154b" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">如何指定气体和转移量</h1><p id="6283" class="pw-post-body-paragraph jb jc ht jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy hm dt translated">可以向<code class="eh jz ka kb kc b">call</code>方法提供一定量的气体和乙醚。</p><pre class="lg lh li lj fq lk kc ll lm aw ln dt"><span id="2646" class="lo ke ht kc b fv lp lq l lr ls">addr.call{value<strong class="kc hu">:</strong> 1 <strong class="kc hu">ether</strong>, gas<strong class="kc hu">:</strong> 1000000}("myFunction(uint,address)");</span></pre><p id="299f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">调用合同上的<code class="eh jz ka kb kc b">myFunction</code>方法，将只供应指定数量的气体。供应给执行<code class="eh jz ka kb kc b">call</code>的外部功能的气体量必须大于或等于供应给<code class="eh jz ka kb kc b">call</code>的气体量。</p><p id="9e10" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果没有提到<code class="eh jz ka kb kc b">gas</code>，则呼叫前剩余的所有气体都被供应给<code class="eh jz ka kb kc b">myFunction</code>呼叫。最好不要对提供给函数调用的gas进行硬编码。</p><p id="d9d9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果您正在向<code class="eh jz ka kb kc b">call</code>方法发送ether，<code class="eh jz ka kb kc b">myFunction</code>应该是一个<code class="eh jz ka kb kc b">payable</code>函数。否则调用将失败。</p><p id="0def" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果供应给<code class="eh jz ka kb kc b">call</code>的气体量少于<code class="eh jz ka kb kc b">myFunction</code>完全执行所需的量，调用将失败。</p><h1 id="6224" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">如何使用通话发送以太网</h1><p id="2c7b" class="pw-post-body-paragraph jb jc ht jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy hm dt translated">在伊斯坦布尔硬分叉<code class="eh jz ka kb kc b">send</code>和<code class="eh jz ka kb kc b">transfer</code>方法被弃用之后。伊斯坦布尔硬盘增加了用于从区块链读取一个字的<code class="eh jz ka kb kc b">SLOAD</code>操作码的开销。Consensys在<a class="ae lv" href="https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/" rel="noopener ugc nofollow" target="_blank">这篇</a>帖子中对此进行了解释。</p><p id="5233" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果在合同的函数调用中使用了<code class="eh jz ka kb kc b">transfer</code>,固定气体2300将被提供给<code class="eh jz ka kb kc b">transfer</code>方法。由于气体成本会发生变化，因此固定的气体成本可能不足以成功转移乙醚，并且整个函数调用可能会失败。</p><p id="14fa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用<code class="eh jz ka kb kc b">call</code>传输以太网打开了可重入攻击的可能性，因为供应的气体可以通过在接收合同的接收或回退功能中再次调用它来重新进入该功能。可重入可以通过使用可重入防护来解决。</p><p id="1380" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如何使用<code class="eh jz ka kb kc b">call</code>和<a class="ae lv" href="https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard" rel="noopener ugc nofollow" target="_blank">重入保护</a>的示例</p><pre class="lg lh li lj fq lk kc ll lm aw ln dt"><span id="b377" class="lo ke ht kc b fv lp lq l lr ls"><strong class="kc hu">function</strong> paySomeone(<strong class="kc hu">address</strong> _addr) <strong class="kc hu">public</strong> <strong class="kc hu">payable</strong> nonReentrant {<br/>    (<strong class="kc hu">bool</strong> success, ) <strong class="kc hu">=</strong> _addr.call{value<strong class="kc hu">:</strong> msg.value}("");<br/>    <em class="lt">// do something<br/></em>}</span></pre><h1 id="051b" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">通话与委托通话</h1><p id="046d" class="pw-post-body-paragraph jb jc ht jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy hm dt translated"><code class="eh jz ka kb kc b">delegatecall</code>用于从合同A中调用合同B的一个函数，合同A的存储、余额和地址提供给该函数。这样做是为了将契约B中的函数用作库代码。因为该函数将表现为它是合同A本身的函数。查看<a class="ae lv" href="https://solidity-by-example.org/delegatecall/" rel="noopener ugc nofollow" target="_blank">这篇</a>文章中的代码示例。</p><p id="4b9e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh jz ka kb kc b">delegatecall</code>语法与<code class="eh jz ka kb kc b">call</code>语法完全相同，只是它不接受<code class="eh jz ka kb kc b">value</code>选项，只接受<code class="eh jz ka kb kc b">gas</code>。</p></div></div>    
</body>
</html>