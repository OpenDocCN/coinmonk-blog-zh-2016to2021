<html>
<head>
<title>On Efficient Ethereum Addresses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于高效以太坊地址</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/on-efficient-ethereum-addresses-3fef0596e263?source=collection_archive---------0-----------------------#2018-09-20">https://medium.com/coinmonks/on-efficient-ethereum-addresses-3fef0596e263?source=collection_archive---------0-----------------------#2018-09-20</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/d400d7de703bc88ebd028e42c56fa1d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ggCNRjF2vB-WA4jYdDJdiQ.gif"/></div></figure><p id="c6ec" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在与区块链打交道时，没有什么是免费的。这就是为什么效率的增加会导致成本的大幅降低，尤其是从长远来看。在以太坊和其他使用EVM的区块链上，这通常意味着找到节省天然气成本的方法，要么尽可能完全避免区块链<em class="jv">(例如，反事实实例化和广义状态通道，</em><a class="ae jw" rel="noopener" href="/spankchain/a-state-channels-adventure-with-counterfactual-rick-part-1-ce68e16252ea"><em class="jv">Rick Sanchez在此雄辩地解释了</em></a><em class="jv"/>)，要么在必要时仔细优化链上交易。</p><p id="d4ad" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">有一种相对晦涩的技术可以实现这样的增量增益:<strong class="iz hu">根据具体情况，找到一个使用成本更低的地址</strong>。通过使用具有比通常的<em class="jv"><em class="jv">多的<strong class="iz hu">零字节</strong>(即，低的</em> <a class="ae jw" href="https://en.wikipedia.org/wiki/Hamming_weight" rel="noopener ugc nofollow" target="_blank"> <em class="jv">汉明权重</em> </a> <em class="jv"> ) </em>的地址，并且在某些情况下，在地址的开始处具有更多的零字节，我们可以在许多类型的事务上节省汽油。</em></p><p id="1ea1" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我已经能猜到你在想什么了:</p><blockquote class="jx jy jz"><p id="cde3" class="ix iy jv iz b ja jb jc jd je jf jg jh ka jj jk jl kb jn jo jp kc jr js jt ju hm dt translated">等等——每笔普通交易都要花费21，000美元，不管交易的地址是哪里。此外，我甜蜜的虚荣地址花了很长时间才找到。我需要一些证据来支持你好斗的主张，即我们选择的地址有所不同。</p></blockquote><p id="52e9" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">按照惯例，答案可以在<a class="ae jw" href="http://yellowpaper.io/" rel="noopener ugc nofollow" target="_blank">黄皮书</a>中找到。<em class="jv">(哇，大胆的用那个开…) </em></p><figure class="ki kj kk kl fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff kh"><img src="../Images/7954cbaf78566ce785066e78cf10e447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NWAk7TbZJTDGy52CiHiDyQ.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Try not to get <strong class="bd ku"><em class="kv">too</em></strong> worked up by all these salacious details.</figcaption></figure><p id="a5cb" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们对其中的几个操作<em class="jv">(以及它们的对应操作)</em>特别感兴趣:<code class="eh kd ke kf kg b"><strong class="iz hu">G</strong>txdatazero</code> <em class="jv">(与</em> <code class="eh kd ke kf kg b"><strong class="iz hu">G</strong>txdatanonzero</code> <em class="jv"> ) </em>和<code class="eh kd ke kf kg b"><strong class="iz hu">G</strong>sload</code> + <code class="eh kd ke kf kg b"><strong class="iz hu">G</strong>sset</code> <em class="jv">(与</em> <strong class="iz hu"> <em class="jv">而不是</em> </strong> <em class="jv">使用</em><code class="eh kd ke kf kg b"><strong class="iz hu">G</strong>sset</code><em class="jv">——这整个</em> <code class="eh kd ke kf kg b">SSTORE</code> <em class="jv">听起来相当昂贵)</em>。</p><h1 id="44ce" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">呼叫数据、小数据</h1><p id="85f6" class="pw-post-body-paragraph ix iy ht iz b ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ly js jt ju hm dt translated">先来看<code class="eh kd ke kf kg b"><strong class="iz hu">G</strong>txdatazero</code>:交易数据每零字节花费4 gas。相比之下，<code class="eh kd ke kf kg b"><strong class="iz hu">G</strong>txdatanonzero</code>的价格是68美元，或者说<strong class="iz hu">的价格是</strong>的17倍。因此，每次在<code class="eh kd ke kf kg b">msg.data</code>中用零字节代替非零字节，就节省了<strong class="iz hu"> 64 gas </strong>。关于这一观察，需要记住几件事:</p><ul class=""><li id="def4" class="lz ma ht iz b ja jb je jf ji mb jm mc jq md ju me mf mg mh dt translated">当查看十六进制形式的字节串时，每对数字<em class="jv"><em class="jv"/>(其中每个字符代表16个可能的数字之一)</em>构成一个字节<em class="jv"> (16 = 2⁸ = 256 </em> <em class="jv">位)</em>。单个十六进制零或分布在两个不同字节上的相邻零不会降低字节串的汉明权重。</li><li id="759a" class="lz ma ht iz b ja mi je mj ji mk jm ml jq mm ju me mf mg mh dt translated">零字节的排序与从这个<em class="jv">特定的</em>优化中获得的利益无关，至少与用于替换相应非零字节的零字节总数无关。</li></ul><p id="3558" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">地址是该属性可以派上用场的一个方面。考虑ERC20 <code class="eh kd ke kf kg b">transfer()</code>的情况。<code class="eh kd ke kf kg b">msg.sender</code>的汉明权重在这里没有什么不同，但是事实证明，作为<code class="eh kd ke kf kg b">transfer</code>函数的一部分传递给<code class="eh kd ke kf kg b">msg.data</code>的<code class="eh kd ke kf kg b">_to</code>参数做了<em class="jv">(顺便说一下，函数选择器也做了)</em>。</p><p id="99bf" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">使用<a class="ae jw" href="https://openzeppelin.org/api/docs/token_ERC20_StandardToken.html" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin的StandardToken </a>作为参考实现，一个没有零字节的地址的标准<code class="eh kd ke kf kg b">transfer</code>花费51,486 gas。然而，传输到八个零字节的地址只需要50，974 gas，相差<code class="eh kd ke kf kg b">51486 — 50974 = 512</code> gas。这也可以表示为<code class="eh kd ke kf kg b">64 * 8</code>:这正是我们从上面的计算中所期望的。这就像有一张“买一百送一”的卡，所有的代币都转移到这个地址。如果你想知道<code class="eh kd ke kf kg b">transferFrom</code>(你当然想知道，你这个狡猾的家伙)，猜猜看:如果两个地址都有八个零字节，<strong class="iz hu">每笔交易节省的汽油将是两倍</strong>！</p><p id="7ef3" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">有很多其他方法可以依靠这个方法，但是它基本上归结为是否可以使用零字节来代替它们的次等的非零对等物。这个技巧的另一个好处是它是<strong class="iz hu">完全向后兼容的</strong>——你可以用它来节省汽油，即使在调用没有利用它的合同时。</p><p id="0697" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><em class="jv">(作为题外话，在使用这种方法时你要格外小心，以防受到</em> <strong class="iz hu"> <em class="jv">短地址攻击</em></strong><em class="jv"/><a class="ae jw" href="https://vessenes.com/the-erc20-short-address-attack-explained/" rel="noopener ugc nofollow" target="_blank"><em class="jv">这里更深入地解释了</em> </a> <em class="jv">。简而言之，如果一个地址有尾随的零字节，您可以在请求第三方为您构建一些令牌传输时截断它们，如果他们没有正确验证输入，它将从下一个参数</em> <code class="eh kd ke kf kg b">amount</code> <em class="jv">中“窃取”额外的字节。然后，你知道吗:我们现在拿回了256倍的代币！)</em></p><p id="00fe" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">接下来考虑<code class="eh kd ke kf kg b"><strong class="iz hu">G</strong>sset</code> : this和<code class="eh kd ke kf kg b"><strong class="iz hu">G</strong>sreset</code>都是处理<code class="eh kd ke kf kg b">SSTORE</code>操作码，将32字节字置为状态，第一次存储任何非零数据都要耗费2万gas<em class="jv">(是啊……如果能避免调用</em><code class="eh kd ke kf kg b">SSTORE</code><em class="jv"/><code class="eh kd ke kf kg b">That_Would_Be_Great.gif</code><em class="jv">)</em>。一旦这个字被存储，每次通过<code class="eh kd ke kf kg b">SLOAD</code>检索它都要花费另外200个气体<em class="jv">，这也不酷。</em></p><p id="aa9a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">当涉及到具体的地址时，我们可以如下节省一些汽油:如果地址至少有<strong class="iz hu">四个前导零字节</strong> <em class="jv">(或者十六进制编码格式的八个前导零)</em>，那么每个地址只需要占用16个字节。如果你计算一下，在对偏微分方程积分时考虑协方差，并记住携带7位，我们发现两个地址可以打包成一个32字节的包。<em class="jv">(字。)</em></p><p id="90e8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这种优化的有趣之处在于，你不仅从<code class="eh kd ke kf kg b"><strong class="iz hu">G</strong>txdatazero</code>的改进中获得了节省，而且由于不必从呼叫数据中读取和写入同样多的字，你甚至节省了<em class="jv">更多的</em>汽油。关于这种优化的另一个有趣的事情是，利用它的概念验证令牌已经存在——稍后会有更多细节，但它的要点是<em class="jv">(取决于传输方法)</em>我们可以削减令牌传输总成本的<strong class="iz hu">多达<em class="jv"> 5% </em>。</strong></p><p id="c7c2" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">您还可以通过查看臭名昭著的<a class="ae jw" rel="noopener" href="/@0age/tpl-architecture-private-draft-1-a64f168a2f88"> GasToken </a>，特别是它处理GST2的方式，看到这种优化的相关好处。GST2的地址<code class="eh kd ke kf kg b">0x0000000000b3F879cb30FE243b4Dfee438691c04</code>仅使用15个字节的存储。这样，部署的垃圾合同可以缩短5个字节，并且仍然检查<code class="eh kd ke kf kg b">msg.sender</code>是否与GST2合同匹配，以便<code class="eh kd ke kf kg b">selfdestruct</code>获得汽油回扣，当部署它们时，以每字节200汽油节省额外的5个字节。如果你打算玩弄天然气系统，用垃圾合同填满存储空间，你最好用正确的方式来做！<em class="jv">(这种围绕工厂合同的优化也在</em><a class="ae jw" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md" rel="noopener ugc nofollow" target="_blank"><em class="jv">EIP-1167</em></a><em class="jv">末尾讨论过)。)</em></p><h1 id="9d05" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">W0000000ah啊…帮我报名！</h1><p id="937a" class="pw-post-body-paragraph ix iy ht iz b ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ly js jt ju hm dt translated">现在，你可能会说:</p><blockquote class="jx jy jz"><p id="6f5c" class="ix iy jv iz b ja jb jc jd je jf jg jh ka jj jk jl kb jn jo jp kc jr js jt ju hm dt translated">好吧，0岁——你这个零爱怪人——我想我被说服了。但是我怎样才能得到这样一个地址呢？</p></blockquote><p id="5f91" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">嗯，有几种方法。最直接的选择:基本上，你“挖掘”一个。</p><p id="6f5d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">地址是确定性生成的，或者来自私钥<em class="jv">(参见</em> <a class="ae jw" href="https://kobl.one/blog/create-full-ethereum-keypair-and-address/" rel="noopener ugc nofollow" target="_blank"> <em class="jv">此处</em> </a> <em class="jv">了解详细内容的精彩文章)</em>对于外部拥有的帐户，或者来自调用者的地址和随机数<em class="jv">(调用</em> <code class="eh kd ke kf kg b">CREATE</code> <em class="jv">时的计数器，或者调用</em> <code class="eh kd ke kf kg b">CREATE2</code> <em class="jv">时任意提供的随机数，君士坦丁堡包含的操作码之一)</em>无论哪种方式，它都被输入到一个<code class="eh kd ke kf kg b">keccak256</code>散列中，这意味着，给定输入的变化，每个字节的结果输出几乎是随机的。</p><p id="ab0e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">零字节以由<a class="ae jw" href="https://en.wikipedia.org/wiki/Binomial_distribution" rel="noopener ugc nofollow" target="_blank">二项式分布</a>描述的频率出现在随机地址中:</p><figure class="ki kj kk kl fq iu fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/6c49b263a9ee8d215ca36e8353cc78ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*0pRLZGyY5bd7BRtdelt-tw.png"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">The probability mass function for a generalized binomial distribution (blah, blah, blah).</figcaption></figure><p id="7e33" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">用<a class="ae jw" href="https://en.wikipedia.org/wiki/Binomial_coefficient" rel="noopener ugc nofollow" target="_blank">二项式系数</a>表示为:</p><figure class="ki kj kk kl fq iu fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/776c6ecc36b888a1936a1b9c84278be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*3WooQfQE_j57YGYVVZH_zA.png"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">The binomial coefficient. The factorial is strong with this one, Obi-wan.</figcaption></figure><p id="a803" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在我们的例子中，一个地址中有1/256的机会出现0字节和20字节。利用<strong class="iz hu"> <em class="jv"> p </em> </strong> = (1/256)和<strong class="iz hu"> <em class="jv"> k </em> </strong> = 20:</p><figure class="ki kj kk kl fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff mp"><img src="../Images/b61fffbec3b7733a1ee157f8e1eeaeac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*VGIA5b_QX7AQ0FiRo7U4NQ.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">The same binomial distribution, applied to an address with twenty bytes.</figcaption></figure><p id="92f0" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">看一下分布<em class="jv">(每条线都是三个数量级——百分之一、千分之一、百万分之一等等。)</em>:</p><figure class="ki kj kk kl fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff mq"><img src="../Images/9ba95b0f206ab936660b03349fa1510b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pX_6un5m53W9QtS1Qp0Ifw.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Note the logarithmic scale of the y-axis here.</figcaption></figure><p id="543f" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">你现在看到的是:</p><ul class=""><li id="01b4" class="lz ma ht iz b ja jb je jf ji mb jm mc jq md ju me mf mg mh dt translated">在地址上找到<strong class="iz hu"> <em class="jv">零</em> </strong>零字节的几率为92.47%。</li><li id="893d" class="lz ma ht iz b ja mi je mj ji mk jm ml jq mm ju me mf mg mh dt translated">找到一个零字节的概率是7.25%。</li><li id="4132" class="lz ma ht iz b ja mi je mj ji mk jm ml jq mm ju me mf mg mh dt translated">0.27%的几率找到两个零字节。</li><li id="f909" class="lz ma ht iz b ja mi je mj ji mk jm ml jq mm ju me mf mg mh dt translated">0.00635%的几率找到三个零字节。</li><li id="d248" class="lz ma ht iz b ja mi je mj ji mk jm ml jq mm ju me mf mg mh dt translated">0.000000106%的几率找到四个，大概是百万分之一。</li></ul><p id="788c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这种地址很容易获得，不需要太多的努力。然而，找到一个有七个零字节<strong class="iz hu"><em class="jv"/></strong>的地址平均需要978，054，817，444次尝试——仅次于一万亿次哈希——有0.000000000010224%的几率在一个地方找到所有七个零字节。</p><p id="c5b0" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">只要看一眼这个分布，就能看出从那里开始会变得多么困难。如果你能找到一个十个零字节的，改天我请你喝啤酒；如果你能找到一个有14个的，国家安全局会给你买一个。</p><p id="6c01" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们再来看看<strong class="iz hu"> <em class="jv">前导</em> </strong>零字节的地址。用<strong class="iz hu"> <em class="jv"> n </em> </strong>前导零字节查找地址的公式要简单得多:</p><figure class="ki kj kk kl fq iu fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/2d3ed04e6a3fe9a61402551cd8bfe585.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*1vgCJ5AJeJCaJV1g0UwUGA.png"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Now that’s more like it — math with that ELI5 swagger.</figcaption></figure><p id="265b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这些坏男孩的概率质量分布如下:</p><figure class="ki kj kk kl fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff ms"><img src="../Images/253b85e6b3caf2a3f14176101c085236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3xUJNK2z1_9_IBaYP4zrg.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Pretty brutal by comparison, eh?</figcaption></figure><p id="eba3" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在一次尝试中找到有四个前导零字节的地址的几率是4294967296分之一。然而，这并不意味着我们可以处理43亿次散列，然后就此收工。在特定数量的<strong class="iz hu"> <em class="jv"> </em> </strong>散列中找到具有四个前导零字节的地址的几率可以从<a class="ae jw" href="https://en.wikipedia.org/wiki/Geometric_distribution" rel="noopener ugc nofollow" target="_blank">几何分布</a>中导出，其中<strong class="iz hu"> <em class="jv"> H </em> </strong>表示散列的数量:</p><figure class="ki kj kk kl fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff mt"><img src="../Images/230e631f5b006f5eeecd567b16f7b666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wQQSgSKxEPspeenc4Y3FHg.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">I thought we agreed that we were done with long formulas…</figcaption></figure><p id="acfd" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这种分布的问题在于它的<a class="ae jw" href="https://en.wikipedia.org/wiki/Skewness" rel="noopener ugc nofollow" target="_blank">正偏斜</a>，尤其是当你有足够的哈希能力找到它的时候。如果运气不好，你可能要等很长时间才能找到一个有足够多零的地址。为工作证明共识机制挖掘池是对这种现象的常见响应，并且服务于“平滑”分布的长尾的主要目的。</p><h1 id="453c" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">“另一条路”</h1><p id="45e8" class="pw-post-body-paragraph ix iy ht iz b ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ly js jt ju hm dt translated">如果你一直在关注<em class="jv">(如果是这样，你正式成为一个书呆子)</em>，你可能记得我提到过有几种方法可以获得这些地址之一。如果你的智能家居设备僵尸网络不能提供你需要的散列能量，你可以让别人为你挖掘一个。这种方法的另一个好处是，他们还将代表您管理您发送到该地址的任何资金，因为他们知道用于生成该地址的私钥。</p><p id="a6e8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">然而，还有另一种方式——这种方式没有分享你的私人钥匙的好处——君士坦丁堡的hardfork使之成为可能。<code class="eh kd ke kf kg b"><a class="ae jw" href="https://eips.ethereum.org/EIPS/eip-1014" rel="noopener ugc nofollow" target="_blank">CREATE2</a></code> <a class="ae jw" href="https://eips.ethereum.org/EIPS/eip-1014" rel="noopener ugc nofollow" target="_blank">操作码</a>让我们部署从<code class="eh kd ke kf kg b">sha3(msg.sender ++ salt ++ init_code)[12:]</code>派生的契约地址，而不是我们已经知道并喜爱的<code class="eh kd ke kf kg b">CREATE</code>操作码所使用的通常的<code class="eh kd ke kf kg b">sha3(rlp.encode([msg.sender, nonce]))</code>。现在，再加上创建<strong class="iz hu">可升级代理</strong>的合同工厂，例如来自ZeppelinOS 的<a class="ae jw" href="https://docs.zeppelinos.org/docs/upgradeability_AdminUpgradeabilityProxy.html" rel="noopener ugc nofollow" target="_blank">adminupgradabilityproxy，我们突然创建了一种机制，通过这种机制，高效的地址可以被大量生成。我说，几十个！</a></p><p id="f9c2" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">(值得记住的是，使用代理的开销大约是1600 gas。也就是说，如果你需要一个可升级的代理，为什么不选择更高效的呢？)</p><h1 id="bf63" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">任何东西——甚至任何东西——都有价格</h1><p id="968a" class="pw-post-body-paragraph ix iy ht iz b ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ly js jt ju hm dt translated">让我们沿着这条思路走下去。我们创建了一个名为<code class="eh kd ke kf kg b">Pr000xy</code>的智能契约，它允许用户在有效的地址创建或声明透明的代理契约。为了让人们真正开始向智能合同提交散列，他们将不得不为麻烦得到一些东西。这意味着<strong class="iz hu">每个地址</strong>都需要有一个合理的价格——理想的价格应该与找到该地址的实际可能性非常接近。我们还想同时考虑零字节的总数和<em class="jv">前导</em>零字节的总数<em class="jv">(但让我们暂时把前导零放在一边)</em>。</p><p id="09dd" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">事实证明，公平价格并不是由找到一个特定的零的概率来决定的。最好根据至少有<strong class="iz hu"><em class="jv"/></strong>个特定数量的零的概率来给地址定价。为了找到这一点，首先计算累积分布函数<em class="jv">(或者sum，对于那些喜欢谈论这类事情而不显得浮夸的人来说)</em>，所有找到特定数量的零的概率最多为<strong class="iz hu"> <em class="jv">比我们想要的</em> </strong>少1。然后，你只需从1中减去这个数，就有了。这也被称为给定二项分布的<a class="ae jw" href="https://en.wikipedia.org/wiki/Survival_function" rel="noopener ugc nofollow" target="_blank">生存函数</a>。</p><p id="b2fe" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">此外，奖励函数应该反映在给定零字节总数的情况下，获得<em class="jv">前导</em>零字节数的几率。这里有一个方法:给定一些前导零，从零字节总数中减去这个总数，以及从地址中的字节总数中减去这个总数。接下来，使用新的、更小的输入将它输入到生存函数中。最后，将乘以<em class="jv">找到前导零字节的几率，得到零字节和前导零字节的特定“组合”的概率。</em></p><p id="783e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">以这种方式组合两个分布产生在给定随机地址上找到<strong class="iz hu"><em class="jv"/></strong>或更多零字节和<strong class="iz hu"> <em class="jv"> s </em> </strong>起始字节的概率，如下所述:</p><figure class="ki kj kk kl fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff mu"><img src="../Images/74210f1ade0183ab81876edb57ea2db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uNuUMAaSveuZVfTIABLXwQ.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Now this is just getting ridiculous.</figcaption></figure><p id="62cc" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">将这一数字转换成代理工厂在创建代理时应该铸造并在申请代理时烧掉的令牌的适当值，只需要两个步骤:找到组合赔率的<strong class="iz hu"><em class="jv"/></strong>的倒数，并通过适当的<strong class="iz hu">比例因子</strong> <em class="jv">(因为大多数地址太普通而不值得支付)</em>进行调整，将奖励四舍五入为整数值。一个很好的缩放因子是256 <em class="jv">(或者对于那些有点怪癖的人来说是2⁴)</em>，这使得最小的回报大体上可以达到——生成一个有三个前导零字节(即六个前导零)的虚位地址平均需要16，777，216次尝试，但是在大多数商用硬件上是完全可行的，假设你有一点耐心。说真的，<a class="ae jw" href="https://vanity-eth.tk/" rel="noopener ugc nofollow" target="_blank">不信你自己试试</a>。</p><p id="6a2d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这给我们留下了一个奖励函数<strong class="iz hu"> <em class="jv"> R </em> </strong>，它给出了创建一个代理的精确值，该代理的地址包含<strong class="iz hu"> <em class="jv"> z </em> </strong>零字节和<strong class="iz hu"> <em class="jv"> s </em> </strong>起始字节，计算如下:</p><figure class="ki kj kk kl fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff mv"><img src="../Images/4d771b4d1335ba8e8e0fab81575c36cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fuV1q-GLu1NiIDdEDKMjqw.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">It’s beautiful… if you squint at it just right…</figcaption></figure><p id="2a86" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我现在就打断你，免得你说:</p><blockquote class="jx jy jz"><p id="7744" class="ix iy jv iz b ja jb jc jd je jf jg jh ka jj jk jl kb jn jo jp kc jr js jt ju hm dt translated">这个表达式产生了一些巨大的数字！到底是什么让我每次想使用代理工厂来节省我的汽油时都要计算这个巨大的链条呢？</p></blockquote><p id="6801" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">你知道为什么吗？这是因为<strong class="iz hu">你不需要在链上计算它</strong>。幸运的是，有一个查找表就可以了，因为这个函数只有200个有效输入。在处理万亿分之一万亿分之一万亿分之一的概率时，我已经为您解决了不得不排除浮点精度错误的头痛问题。不客气<em class="jv">(其实也没那么差——不客气来</em> <a class="ae jw" href="https://gist.github.com/0age/d55d8315c2119adfba3cc90b3f5c15df" rel="noopener ugc nofollow" target="_blank"> <em class="jv">查我的作品</em> </a> <em class="jv">。)</em></p><p id="ed19" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在您寻找由<code class="eh kd ke kf kg b">Pr000xy</code>创建的将产生非零回报的代理地址时，您可以使用这个方便的正则表达式，它将让您知道该地址是否值得任何令牌:</p><pre class="ki kj kk kl fq mw kg mx my aw mz dt"><span id="a77f" class="na kx ht kg b fv nb nc l nd ne">^0{6}|^0{4}((.{2})*(00)){2}|^((.{2})*(00)){5}</span></pre><p id="8577" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">说完这些，让我们来看一些没有任何公式的奖励函数的图表，供所有视觉学习者参考。</p><figure class="ki kj kk kl fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff nf"><img src="../Images/287921f7466555e3ead87b6a7cb1d15a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zBeqPNUo-YZl8Erfiu91Yg.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Blue cells are in play for mere mortals. White cells are either: a) not worth anything, or b) literally impossible. Cells deep in the Lime Green are both: a) worth an insane amount, and b) figuratively impossible.</figcaption></figure><figure class="ki kj kk kl fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff ng"><img src="../Images/74e09904de85e64273dac49521ba0df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-ieS4dDm8EUKX7_8Nl6gg.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Zoomed in to the blue area above, plus a new color gradient called “plasma” which is fun.</figcaption></figure><figure class="ki kj kk kl fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff nh"><img src="../Images/5bd374a59771e2e8bdcabe3e1e5feab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7mnZm6Wu3mlYL-jgxvBlQ.png"/></div></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">A relative comparison of initial reward sizes.</figcaption></figure><h1 id="a347" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">但是等等，还有呢！</h1><p id="dc03" class="pw-post-body-paragraph ix iy ht iz b ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ly js jt ju hm dt translated">与简单地以老式方式强行获取地址相比，使用工厂合同为具有高效地址的可升级代理提供了额外的好处。如果我们设计代理，使得提供给<code class="eh kd ke kf kg b">CREATE2</code>的salt来自提交者 的地址<strong class="iz hu"> <em class="jv">和他们提交的随机数，那么可靠的随机性来源不再是生成安全虚名地址的先决条件。简单地逐步通过nonces将会起作用，因为只有预期的提交者将能够交付预期的salt，该salt将生成到工厂契约的契约。结合不需要为每次尝试生成密钥对的事实<em class="jv">(更确切地说，对连接的字节串执行</em> <code class="eh kd ke kf kg b">keccak256</code> <em class="jv">散列以验证契约地址)</em>，应该<strong class="iz hu">增加可以用给定量的计算能力检查的地址的数量</strong>。</em></strong></p><p id="a4f8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">此外，使用工厂模式还有另一个有趣的好处:<strong class="iz hu">虚地址可以在不可信的环境中安全地挖掘出来</strong>。没有可窃取的私钥，因为将提交nonce的地址是作为参数提供的，并且相关的私钥永远不会提供给挖掘虚荣地址的机器。恭喜你——你的可疑网站现在有了一个在后台秘密挖掘密码的新方法！<em class="jv">(开个玩笑——别做那种人。)</em></p><h1 id="a772" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">如果你建造了它(并放了一个滑水道)，它们就会来了</h1><p id="205b" class="pw-post-body-paragraph ix iy ht iz b ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ly js jt ju hm dt translated">假设存在对具有高效地址的代理的需求，为它们制定工厂合同的诀窍在于激励足够多的矿工进行哈希运算。一个准确的奖励功能有很长的路要走，在不可信的环境中更快地挖掘地址的能力也有所帮助。然而，已经有很多高度优化的工具可以使用传统方式找到虚荣心地址，并且通过工厂合同将需要支付一些额外的费用——考虑到最终目的，这有点讽刺。但是还有一张王牌——即使他们只是在为自己寻找一个虚假地址，他们也可以通过利用他们找到的所有地址来分摊寻找的成本，甚至赚钱。</p><p id="1f1b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">举例来说，假设热门的new <code class="eh kd ke kf kg b">blockchainBuzzwordSoup</code>项目想要一个地址至少有八个零字节的代理契约。他们也有自己开采的手段，而且对于他们的口味来说，代币现在有点太贵了，尤其是因为需要900万代币来声明他们想要的地址。凭借他们所掌握的散列能力，他们将需要大约两周的时间来找到它——这意味着可能需要<strong class="iz hu">永远</strong>——但是，谢天谢地，他们喝了Kool-aid并决定使用<code class="eh kd ke kf kg b">Pr000xy</code>。</p><p id="8eac" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">一旦他们开始挖掘，他们将开始寻找有效但不太有效的代理地址，他们可以创建代理地址，直到出现符合他们规格的地址，或者直到他们赢得足够的令牌来彻底购买它。前一种情况允许他们<strong class="iz hu">卖掉额外的令牌</strong>并补偿他们的一些额外的电费和相应的对处理器造成的热损害。后一种情况有效地“平滑”了我们上面提到的分布的长尾，保护它们免受显著延迟正匹配的坏运气的打击。</p><p id="8858" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">为了真正放大这种效果，<code class="eh kd ke kf kg b">Pr000xy</code>可以让用户<strong class="iz hu">出价购买定制的虚荣心地址</strong>。为此，他们在工厂合同上押了赌注。然后，一旦工厂创建了与请求匹配的代理，任何人都可以调用一个方法来将有效的报价与代理匹配，将赌注资金转移给代理的创建者<em class="jv">(请求者提供寻找匹配的费用)</em>并将代理的所有权转移给设置报价的用户<em class="jv">(如果地址有足够的零字节，则在该过程中烧掉任何所需的令牌)</em>。寻找定制虚荣心地址的用户越多，矿工使用代理的动机就越强，定制地址就会越快被找到——这是一个良性的、但大多是虚荣心的循环。</p><h1 id="df86" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">t000基因组学</h1><p id="e535" class="pw-post-body-paragraph ix iy ht iz b ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ly js jt ju hm dt translated">既然我们已经建立了获取有效地址的方法，让我们来看看如何使用它们。对于ERC20令牌的用例，特别是那些愿意稍微“变通一下规则”的令牌，我们可以说，<strong class="iz hu">扩展了</strong>接口。</p><p id="dffe" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">想象一个令牌——姑且称之为lulz的<code class="eh kd ke kf kg b">T000ken</code>——其中只允许带有四个前导零的地址携带余额。假设你有一个满足这些要求的地址，你可以通过锁定Dai或类似的东西来制造<code class="eh kd ke kf kg b">T000ken</code> s，然后你可以使用它们，将它们发送给所有具有零字节地址的好友，如果你愿意，最终可以刻录它们并取回你的Dai。为了获得大部分的回报，你稍微偏离了标准的ERC20方法，在可能的地方打包参数，并使用带有大量零字节的函数选择器。<em class="jv">(哈！你</em> <strong class="iz hu"> <em class="jv">早就知道</em> </strong> <em class="jv">早先的那个小花絮又要冒出来了。)</em>提供几个具体的例子:</p><ul class=""><li id="100b" class="lz ma ht iz b ja jb je jf ji mb jm mc jq md ju me mf mg mh dt translated">在<code class="eh kd ke kf kg b">from</code>地址中有四个零字节可以节省<code class="eh kd ke kf kg b">64 * 4 = 256</code>的汽油，如果有额外的零，会节省更多</li><li id="0197" class="lz ma ht iz b ja mi je mj ji mk jm ml jq mm ju me mf mg mh dt translated">将<code class="eh kd ke kf kg b">to</code>和<code class="eh kd ke kf kg b">from</code>打包成一个字可以去掉32个空字节的通话数据，从而又节省了一笔<code class="eh kd ke kf kg b">32 * 4 = 128</code>汽油费</li><li id="7305" class="lz ma ht iz b ja mi je mj ji mk jm ml jq mm ju me mf mg mh dt translated">用更高效的<code class="eh kd ke kf kg b">mapping(&lt;packed addresses&gt; =&gt; uint256)</code>替换默认的<code class="eh kd ke kf kg b">allowed</code>(采用<code class="eh kd ke kf kg b">mapping (address =&gt; mapping (address =&gt; uint256))</code>的形式)节省了高达66的气体<em class="jv">(其中7/11来自从嵌套哈希表中获取值所需的额外的</em><code class="eh kd ke kf kg b">sha3</code><em class="jv">)</em></li><li id="d829" class="lz ma ht iz b ja mi je mj ji mk jm ml jq mm ju me mf mg mh dt translated">使用带三个零字节的功能选择器<em class="jv">(你甚至可以用一个带四个！)</em>保存<code class="eh kd ke kf kg b">64 * 3 = 192</code>气体</li><li id="349d" class="lz ma ht iz b ja mi je mj ji mk jm ml jq mm ju me mf mg mh dt translated">仔细排列功能选择器——它们是按字母数字顺序排列的——一次可以节省12加仑汽油</li></ul><p id="880f" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">与全新的<a class="ae jw" href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/release-v2.0.0/contracts/token/ERC20/ERC20.sol" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin ERC20实现</a>相比，<code class="eh kd ke kf kg b">T000ken</code>概念验证实现实际上进展不错:在<code class="eh kd ke kf kg b">transfer</code>上节省了3%以上的汽油，<strong class="iz hu"> <em class="jv">在<code class="eh kd ke kf kg b">transferFrom</code>上节省了5% </em> </strong>。即使参考实现使用相同的地址，<code class="eh kd ke kf kg b">T000ken</code> <em class="jv">仍然为<code class="eh kd ke kf kg b">transfer</code>提供2.5%的折扣，为<code class="eh kd ke kf kg b">transferFrom</code>提供4%的折扣。</em></p><pre class="ki kj kk kl fq mw kg mx my aw mz dt"><span id="1d87" class="na kx ht kg b fv nb nc l nd ne">----------------------- Gas Savings Analysis -----------------------<br/>cost to lock: 41499 (in-only: 56499)   free: 65260    total: 106759</span><span id="0292" class="na kx ht kg b fv ni nc l nd ne">1. T000ken using standard ERC20 methods<br/>                              Transfer    TransferFrom    Approve<br/>   Example (regular address)   36518          44113         30308<br/>   T000ken (ERC20 methods)     36027          42777         30045<br/>   Gas savings:                  491           1336           263<br/>   Percentage savings:         1.34%          3.03%         0.87%</span><span id="0900" class="na kx ht kg b fv ni nc l nd ne">Example (compact address)   36262          43601         30052<br/>   T000ken (ERC20 methods)     36027          42777         30045<br/>   Gas savings:                  235            824             7<br/>   Percentage savings:         0.65%          1.89%         0.02%<br/>   Breakeven txs: (in only)      241             69<br/>   Breakeven txs: (in and out)   455            130</span><span id="1a80" class="na kx ht kg b fv ni nc l nd ne">2. T000ken using extra-efficient "sort of like ERC20" methods<br/>                              Transfer     TransferFrom    Approve<br/>   Example (regular address)   36518          44113         30308<br/>   T000ken (efficient)         35308          41829         29566<br/>   Gas savings:                 1210           2284           742<br/>   Percentage savings:         3.31%          5.18%         2.45%</span><span id="e7f0" class="na kx ht kg b fv ni nc l nd ne">Example (compact address)      36262          43601         30052<br/>   T000ken (efficient)         35308          41829         29566<br/>   Gas savings:                  954           1772           486<br/>   Percentage savings:         2.63%          4.06%         1.62%<br/>   Breakeven txs: (in only)      241             32<br/>   Breakeven txs: (in and out)   455             60</span></pre><h1 id="3666" class="kw kx ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">给我看看代码！</h1><p id="95a2" class="pw-post-body-paragraph ix iy ht iz b ja lu jc jd je lv jg jh ji lw jk jl jm lx jo jp jq ly js jt ju hm dt translated">在这里查看<code class="eh kd ke kf kg b">Pr000xy</code> <a class="ae jw" href="https://github.com/0age/Pr000xy" rel="noopener ugc nofollow" target="_blank">的代码</a>或者在<a class="ae jw" href="https://ropsten.etherscan.io/address/0x000000009a9fc3ac5280ba0d3ea852e57dd2ac1b" rel="noopener ugc nofollow" target="_blank"> Ropsten </a> <em class="jv">上使用它(关于</em> <code class="eh kd ke kf kg b">T000ken</code> <em class="jv">的代码仍然非常粗略，但是如果您有兴趣看一看的话，请告诉我)</em>。甚至有一个<a class="ae jw" href="https://github.com/0age/Pr000xy/blob/master/scripts/mine/Pr000xy.js" rel="noopener ugc nofollow" target="_blank">节点脚本</a>可以用来挖掘你自己的地址——确保用你控制的地址替换它。如果你不想要一个透明的可升级代理，但仍然希望你的下一个合同有一个高能效的地址，你可以使用<code class="eh kd ke kf kg b">Create2Factory</code>(代码<a class="ae jw" href="https://github.com/0age/Pr000xy/blob/master/contracts/Create2Factory.sol" rel="noopener ugc nofollow" target="_blank">这里</a>，部署到Ropsten <a class="ae jw" href="https://ropsten.etherscan.io/address/0xa779284f095ef2eBb8ee26cd8384e49C57b26996" rel="noopener ugc nofollow" target="_blank">这里</a>)来指定你自己的合同初始化代码，并使用类似于<code class="eh kd ke kf kg b">Pr000xy</code>所使用的<a class="ae jw" href="https://github.com/0age/Pr000xy/blob/master/scripts/mine/create2factory.js" rel="noopener ugc nofollow" target="_blank">地址挖掘技术</a>——参见这篇<a class="ae jw" rel="noopener" href="/@0age/deploy-an-efficient-address-contract-a-walkthrough-cb4be4ffbc70">后续文章</a>来浏览这个过程。还有一个全新的<code class="eh kd ke kf kg b">Pr000xy</code> <a class="ae jw" href="https://t.me/joinchat/AAAAAEgfYEufIMuqEXFNQA" rel="noopener ugc nofollow" target="_blank">电报集团</a>也很希望有你。请记住,<code class="eh kd ke kf kg b">Pr000xy</code>仍然是高度实验性的,还没有被审计——参与进来并帮助解决这个问题！</p><p id="0845" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><em class="jv">大拜</em> <a class="ae jw" href="https://twitter.com/thegostep" rel="noopener ugc nofollow" target="_blank"> <em class="jv">夏羽·戈塞林</em></a><em class="jv"/><a class="ae jw" href="https://twitter.com/c_spelliscy" rel="noopener ugc nofollow" target="_blank"><em class="jv">康纳斯佩西</em></a><em class="jv"/><a class="ae jw" href="https://twitter.com/smpalladino" rel="noopener ugc nofollow" target="_blank"><em class="jv">圣地亚哥·帕拉迪诺</em></a><em class="jv"/><a class="ae jw" href="https://twitter.com/_ajsantander" rel="noopener ugc nofollow" target="_blank"><em class="jv">亚历杭德罗·桑坦德</em></a><em class="jv"/><a class="ae jw" href="https://twitter.com/bleznak" rel="noopener ugc nofollow" target="_blank"><em class="jv">大卫·布莱兹纳克</em> </a> <em class="jv">，<em class="jv"/></em></p></div></div>    
</body>
</html>