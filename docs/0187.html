<html>
<head>
<title>Gentle introduction to Hashing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">散列法简介</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/gentle-introduction-to-hashing-61295dbcc0c5?source=collection_archive---------1-----------------------#2018-03-26">https://medium.com/coinmonks/gentle-introduction-to-hashing-61295dbcc0c5?source=collection_archive---------1-----------------------#2018-03-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/1f157388436bfccad777aa97bcb6303c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*yysjPq-QMot9-nHiVd9n8A.png"/></div></figure><p id="7841" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">简介</strong></p><p id="da32" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">假设我们有一个雇员记录列表，我们需要搜索一个雇员。你想到的数据结构是什么？链表，树，数组？</p><p id="d460" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">让我们看看每一个的时间复杂度。</p><ol class=""><li id="b687" class="jv jw ht iz b ja jb je jf ji jx jm jy jq jz ju ka kb kc kd dt translated">链表:查找一个元素的时间是O(n)。</li></ol><p id="b47b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">2.二分搜索法树:O(log n)假设我们有一棵平衡的树。</p><p id="7a98" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">3.Arrays: O(1)假设我们知道每个记录的索引。</p><p id="901f" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">哈希利用了数组的这一特性。主要是在O(1)时间内获取元素。</p><p id="4a93" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">那么我们如何实现这一目标呢？</strong></p><p id="7bec" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">对于每个记录，我们在数组中计算一个相应的索引。为此，我们可以使用哈希函数。一个非常基本的哈希函数可以是H(k) = k mod 11，其中k是输入值。</p><p id="b71a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">示例—假设我们有以下要插入的员工Id列表{101，220，452，321，600}数组的大小为5，要使用的哈希函数为H(k) = k mod 5。让我们计算每个输入的哈希值。</p><p id="e466" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">H(101)= 101 mod 5 = 1<br/>H(220)= 220 mod 5 = 0<br/>H(304)= 304 mod 5 = 4<br/>H(303)= 303 mod 5 = 3<br/>H(202)= 202 mod 5 = 2</p><p id="ace8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">如你所见，我们得到了以下映射(101，1)，(220，0)，(304，4)，(303，3)，(202，2)。元素存储在数组中这些各自的索引处。</p><p id="90a4" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在检索时，我们再次使用散列函数。因此，如果我们想要id为304的用户，我们执行H(304) = 4，后跟雇员[4]。简单不是吗。</p><p id="ab34" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">哈希表往往是<strong class="iz hu">最好的数据结构</strong>来维护<strong class="iz hu">字典</strong>。还有其他的应用。</p><p id="e79c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">哈希问题</strong></p><p id="bfe1" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">你可能已经注意到，如果我们有多个元素得到相同的哈希值，那么我们该怎么办？比如，如果我们有一个数字600，那么它就是H(600) = 0，但是我们在索引0处已经有220了。现在怎么办？这个问题被称为碰撞。不管哈希函数有多好，冲突总是会发生的。</p><blockquote class="ke"><p id="37cb" class="kf kg ht bd kh ki kj kk kl km kn ju ek translated"><a class="ae ko" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="kq kr ks kt ku iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff kp"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><p id="011f" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">为了<strong class="iz hu">解决</strong>这个我们有几种方法:</p><p id="c750" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">1.<strong class="iz hu">链接</strong>是一个简单的解决方案。我们可以通过使用链表方法将元素存储在同一个桶中。于是哈希表就变成了链表的数组(让我想起了用来存储图的邻接表)。问题是空间被指针消耗了。<br/> 2。<strong class="iz hu">开放式寻址</strong>是另一种使用探测的流行方法。我们继续重新计算哈希值，直到找到一个空桶。也可以用类似的方式搜索元素。但是删除会有一些问题。就像当我们删除一个元素时，槽是空的。考虑尝试查找一个元素，该元素的位置应该在被删除元素的旁边。一个解决方案可以是用某个东西标记被删除的槽，并在下一次插入时使用它。</p><p id="491a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">探测可以分为线性探测、二次探测和双重散列。</p><p id="a5eb" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在本文中，我不会深入讨论这些方法的细节。</p><p id="66d9" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">总结</strong></p><p id="dc6c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">总之，我们看到了一种在检索元素时非常有效的数据结构。我们也看到了与散列相关的问题。</p></div></div>    
</body>
</html>