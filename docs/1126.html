<html>
<head>
<title>Exploring IOTA #ICT-2, Reverse engineering the code Part-1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索IOTA #ICT-2，逆向工程代码第1部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/exploring-iota-ict-2-reverse-engineering-the-code-1-ecda56d4908?source=collection_archive---------5-----------------------#2018-07-24">https://medium.com/coinmonks/exploring-iota-ict-2-reverse-engineering-the-code-1-ecda56d4908?source=collection_archive---------5-----------------------#2018-07-24</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="7d8b" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">我们探索如何在公开的基于web的java反编译程序的帮助下反编译java源代码。然后使用标准的java编译器重新编译它。更改代码以确认收到UDP数据包。由此开始理解ICT的代码😄</h2></div><p id="6c9b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">也许这对我来说有点太复杂了，试图通过查看代码来理解IOTA受控代理(ICT)的潜在目的。主要原因:</p><ul class=""><li id="76bb" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km dt translated">我的职业不是程序员</li><li id="e761" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated">我对群体逻辑没有经验</li><li id="7f2d" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated">我第一次接触Java可以追溯到学生时代，但那是在90年代初。</li><li id="9519" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt">…</li></ul><p id="98cb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">不管怎样——我们就这么做吧。</p><p id="2abc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="ks">我仍然在我的谷歌云实例(f1-micro)上测试这个。我的文本编辑器是vim(我已经对它有了一种又恨又爱的关系)——如果你想自己设置这个环境，请看看我的其他文章。</em></p><div class="kt ku fm fo kv kw"><a rel="noopener follow" target="_blank" href="/coinmonks/exploring-iota-1-getting-a-linux-terminal-on-cloud-google-com-and-sending-a-transaction-d7b9f1ce100a"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hu fv z el lb eo ep lc er et hs dt translated">探索IOTA # 1——在google cloud上获得一个linux终端并发送一个事务</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">这篇文章应该给你，不管你的工具和硬件，获得第一手的交易…</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">medium.com</p></div></div><div class="lf l"><div class="lg l lh li lj lf lk ll kw"/></div></div></a></div><div class="kt ku fm fo kv kw"><a rel="noopener follow" target="_blank" href="/coinmonks/exploring-iota-ict-1-running-ict-on-a-cloud-computer-bc3d96b246ea"><div class="kx ab ej"><div class="ky ab kz cl cj la"><h2 class="bd hu fv z el lb eo ep lc er et hs dt translated">探索IOTA #ICT-1，在云计算机上测试ICT</h2><div class="ld l"><h3 class="bd b fv z el lb eo ep lc er et ek translated">IOTA受控代理(ICT)已在官方discord渠道发布测试。我会告诉你如何运行…</h3></div><div class="le l"><p class="bd b gc z el lb eo ep lc er et ek translated">medium.com</p></div></div><div class="lf l"><div class="lm l lh li lj lf lk ll kw"/></div></div></a></div><p id="5720" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">本文无意伤害或干扰ICT的测试阶段。它记录了我通过查看代码库来理解ICT的底层机制的尝试(目前除此之外没有太多其他的东西——没有文档)。我已经要求discord #ICT频道的“来自更远的地方”发布这个小步骤。</p><p id="6f3f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">此外，我的发现可能完全错误😄</p></div><div class="ab cl ln lo hb lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hm hn ho hp hq"><h2 id="2ff6" class="lu lv ht bd lw lx ly lz ma mb mc md me jr mf mg mh jv mi mj mk jz ml mm mn mo dt translated"><em class="mp">反编译类文件</em></h2><p id="f528" class="pw-post-body-paragraph ji jj ht jk b jl mq iu jn jo mr ix jq jr ms jt ju jv mt jx jy jz mu kb kc kd hm dt translated">如果你是能够从ICT (0.1.1)下载第一个pre-alpha版本的幸运儿之一(在官方IOTA discord频道)，你可以跟进所有后续步骤。如果没有，那么也许在0.1.2版本上会有下一次机会。<strong class="jk hu">来自超越</strong>在discord上提到，他很快就会发布重构后的代码。</p><p id="b6b5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh mv mw mx my b">*.class</code>文件(编译的<code class="eh mv mw mx my b">*.java </code>代码)被压缩隐藏在那个小zip文件中。在你解压文件后，你可以使用可用的在线反编译程序，它试图通过使用不同的策略来反编译。我用了这个网站</p><p id="6bb2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><a class="ae mz" href="http://www.javadecompilers.com/" rel="noopener ugc nofollow" target="_blank">http://www.javadecompilers.com/</a></p><p id="1370" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在上传类文件时，可以选择这些不同的策略。我首先尝试了<strong class="jk hu"> CFR </strong>但是没有成功——代码不完全可读，更重要的是它不能被再次编译。我用<strong class="jk hu"> Procycon </strong>策略取得的最好成绩。</p><ul class=""><li id="9f2c" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km dt translated">用Procycon反编译zip文件夹中的所有类文件，并存储生成的java文件。</li></ul><p id="d331" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们可以使用任何文本编辑器来浏览代码。</p><p id="9aa7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">有五个文件需要查看</p><ul class=""><li id="cc55" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km dt translated"><strong class="jk hu">Ict.java</strong>—主类文件，保存完整的时间表和主要功能。</li><li id="4aeb" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated"><strong class="jk hu">Transaction.java</strong>—分析收到的IOTA事务并在无效时返回错误的类</li><li id="5b42" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated"><strong class="jk hu">Converter.java</strong>—将接收到的事务从字节转换为trits和trytes(这些转换传递函数是基于字符串的)</li><li id="d1cf" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated"><strong class="jk hu">Curl.java</strong>—臭名昭著的哈希函数，重新计算本次交易的哈希，并确认所谓nonce的有效性。</li><li id="578f" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated"><strong class="jk hu">Neighbor.java</strong>—仅将传入/传出交易记录到组中(所有、新、无效、已请求、共享)</li></ul></div><div class="ab cl ln lo hb lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hm hn ho hp hq"><h2 id="364a" class="lu lv ht bd lw lx ly lz ma mb mc md me jr mf mg mh jv mi mj mk jz ml mm mn mo dt translated">重新编译java文件</h2><p id="a279" class="pw-post-body-paragraph ji jj ht jk b jl mq iu jn jo mr ix jq jr ms jt ju jv mt jx jy jz mu kb kc kd hm dt translated">我的意思是，反编译类文件后，我对代码毫无头绪。但是我知道我需要以某种方式检查如何再次编译这些java文件，以便最终再次启动应用程序。</p><p id="f369" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">首先，您需要有可用的命令来编译这些类。这意味着您可能需要从Java运行时环境JRE转向开发儿童JDK，只需要比前者多50MB的内存。</p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="ea0a" class="lu lv ht my b fv ni nj l nk nl">~$ sudo apt-get update<br/>~$ sudo apt-get install default-jdk</span></pre><p id="a90a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">接下来，我们将编译所有的java文件，并将它们移动到java文件中指定的专用类路径中。假设我们已经创建了一个子文件夹IOTA</p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="34f2" class="lu lv ht my b fv ni nj l nk nl">~/IOTA$ javac *.java<br/>~/IOTA$ mkdir cfb &amp;&amp; cd cfb<br/>~/IOTA/cfb$ mkdir ict<br/>~/IOTA$ mv *.class cfb/ict/</span></pre><p id="e204" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">类文件需要放在相对于应用程序启动位置的路径中，否则我们需要在环境路径变量中添加它们的位置。查看我们反编译的<code class="eh mv mw mx my b">Ict.java</code> <strong class="jk hu"> </strong>文件的第一行，可以看出java期望在<code class="eh mv mw mx my b">cfb.ict</code> <em class="ks">中找到包和类。</em></p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="ff66" class="lu lv ht my b fv ni nj l nk nl">// <br/>// Decompiled by Procyon v0.5.30<br/>// <br/><br/><strong class="my hu">package cfb.ict</strong>;<br/><br/>import <strong class="my hu">cfb.ict.</strong>Converter;<br/>import cfb.ict.Neighbor;<br/>import cfb.ict.Transaction;<br/><br/>import java.util.HashMap;<br/>import java.net.SocketAddress;</span></pre><p id="16ca" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">其他类如HashMap和SocketAddress是从java中已知的库中导入的。</p><p id="900d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这样我们就可以开始重新编译的java程序了。我们只需要在我们的IOTA文件夹中放置一个文件<strong class="jk hu"> ict.properties </strong>(只有一行<strong class="jk hu"> port= <em class="ks"> 11111 </em> </strong>)。从这里，我们可以用下面的命令启动程序</p><p id="2d8d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">🔥请不要把重新编译的ICT用于主网上真正的IRI邻居。这就是我使用不同端口(11111)的原因。我们不知道程序是否正常运行，也不想打扰测试。此外，如果你的邻居添加了你，他们很可能是因为他们希望你有一个正常的ICT，如果你将他们用作自己的测试设备，他们可能会不太高兴👊</p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="d1cb" class="lu lv ht my b fv ni nj l nk nl">~/IOTA$ java cfb.ict.Ict ict.properties</span></pre><p id="9e2d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们已经指定了要在<code class="eh mv mw mx my b">cfb.ict</code>中调用的主类<code class="eh mv mw mx my b">ICT</code>，并提交了文件<code class="eh mv mw mx my b">ict.properties. </code>，输出并不是那么壮观，因为我们还没有输入流量。</p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="69af" class="lu lv ht my b fv ni nj l nk nl">[2018-07-22T11:28:30.883] Ict 0.1.1<br/>2018-07-22T11:28:31.049<br/>Number of transactions = 0<br/>Number of missing transactions = 0</span></pre></div><div class="ab cl ln lo hb lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hm hn ho hp hq"><p id="ff4b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">接下来，我们将从另一个f1-micro实例通过UDP向ICT发送消息。这意味着只需建立另一个云f1-micro实例或使用任何其他连接到互联网且未被您的ICT客户端阻止的linux发行版。</p><p id="472f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我发现向您的ICT客户端发送UDP数据包的最简单方法是这样的</p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="219d" class="lu lv ht my b fv ni nj l nk nl">$echo "Hello ICT" &gt; /dev/udp/YOUR_ICT_IP/11111</span></pre><p id="631a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这导致您的ICT端(一旦一分钟过去)立即得到令人厌烦的响应</p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="cbfb" class="lu lv ht my b fv ni nj l nk nl">[2018-07-22T11:28:30.883] Ict 0.1.1<br/>2018-07-22T11:28:31.049<br/>Number of transactions = 0<br/>Number of missing transactions = 0<br/><br/><strong class="my hu">2018-07-22T11:30:11.848<br/>Number of transactions = 0<br/>Number of missing transactions = 0</strong></span></pre><p id="c001" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了确保我们收到数据包，让我们重写打印我们传输的UDP消息的代码。在<code class="eh mv mw mx my b">byte[] data = datagramPacket.getData();</code>之后，我们添加以下内容，以便打印输入的数据包。</p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="6049" class="lu lv ht my b fv ni nj l nk nl">String string = new String(data, 0, datagramPacket.getLength());<br/>System.out.println(string);<br/>System.out.println("----");</span></pre><p id="a9b0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">此外，我们希望看到发件人的IP地址，我们在<code class="eh mv mw mx my b">final SocketAddress socketAddress = datagramPacket.getSocketAddress();</code>之后添加了以下代码来打印地址</p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="c578" class="lu lv ht my b fv ni nj l nk nl">System.out.println("SocketAddress =" + socketAddress);</span></pre><p id="6781" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在编译了<code class="eh mv mw mx my b">ICT.java</code>并将<code class="eh mv mw mx my b">*.class</code>文件移动到<code class="eh mv mw mx my b">cfb/ict/</code>之后，我们可以重新运行我们重新编译和更改的ICT。一旦我们再次发送四次相同的消息，我们得到这个结果(留出一分钟时间来得到最后几行):</p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="7d83" class="lu lv ht my b fv ni nj l nk nl">[2018-07-22T11:46:39.484] Ict 0.1.1<br/>2018-07-22T11:46:39.585<br/>Number of transactions = 0<br/>Number of missing transactions = 0<br/>Hello ICT<br/>----<br/>Hello ICT<br/>----<br/>Hello ICT<br/>----<br/>Hello ICT<br/>----<br/>2018-07-22T11:47:44.403<br/>Number of transactions = 0<br/>Number of missing transactions = 0</span></pre><p id="241d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们收到消息，但没有关于IP地址的信息。重温由于没有通过该语句而导致的代码:</p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="4e3c" class="lu lv ht my b fv ni nj l nk nl">if (datagramPacket.getLength() != 1650) {<br/>       datagramPacket.setLength(1650);<br/>}  else {</span></pre><p id="dc67" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">用linux构建一个1650个字符的消息应该很容易，我们甚至可以使用种子生成函数，并扩展到1650个字符，以便获得大写字母<code class="eh mv mw mx my b">A...Z9</code></p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="8a57" class="lu lv ht my b fv ni nj l nk nl">cat /dev/urandom |tr -dc A-Z9|head -c${1:-1650} &gt; <strong class="my hu">test.tx</strong></span></pre><p id="94ea" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们不能在这里使用我们的<code class="eh mv mw mx my b">echo</code>命令，因为它将我们的1650长度的消息分解成更小的消息。但是我们可以在我们的非ict实例上做以下事情</p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="9286" class="lu lv ht my b fv ni nj l nk nl">cat <strong class="my hu">test.tx</strong> &gt; /dev/udp/10.142.0.4/11111</span></pre><p id="7363" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">结果实际上不会打印完整的消息，但我们会得到更多</p><pre class="na nb nc nd fq ne my nf ng aw nh dt"><span id="b972" class="lu lv ht my b fv ni nj l nk nl">{deleted: content of test.tx 1650 chars long}<br/>----<br/>SocketAddress =/IP:39025<br/>2018-07-22T11:59:59.169<br/><strong class="my hu">/IP:39025: 2 / 0 / 1 / 0 / 0</strong><br/>Number of transactions = 0<br/>Number of missing transactions = 0</span></pre><p id="9c6b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">上面ICT报告中的粗体标记行是新的，需要理解——查看来自官方开发者Discord的代码Alex做了彻底的总结。我们刚刚证明了那些陈述中的哪一个</p><figure class="na nb nc nd fq nn fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/ab4a798d4f6d150e2fc1fa198a9abb6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*_7kwhqwViIMts8heyxlAnQ.png"/></div><figcaption class="np nq fg fe ff nr ns bd b be z ek">Description of ICT logs by Alex</figcaption></figure><ul class=""><li id="ef49" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km dt translated"><code class="eh mv mw mx my b">allTxs</code>= 1分钟内指定端口(默认为14265)接收的UDP数据包数量。</li><li id="f629" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated"><code class="eh mv mw mx my b">newTxs</code>= 1分钟内未收到的有效交易数量。</li><li id="9c57" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated"><code class="eh mv mw mx my b">invalidTxs</code> =不构成适当交易的UDP包的数量(无效值、无效地址、无效时间戳，即在2017年10月23日12:00:00 UTC之前，无效交易散列)。</li><li id="6714" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated"><code class="eh mv mw mx my b">requestedTxs</code>= ICT能够响应来自该邻居的特定交易请求的次数。</li><li id="4be7" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated"><code class="eh mv mw mx my b">sharedTxs</code> =在1分钟内中继到该邻居的新事务的数量。</li><li id="aa44" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated"><code class="eh mv mw mx my b">Number of transactions</code>= 1分钟内所有相邻节点的所有<code class="eh mv mw mx my b">newTxs</code>之和。</li><li id="b5e4" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated"><code class="eh mv mw mx my b">Number of missing transactions</code>= ICT在1分钟内无法响应的所有请求的数量。</li></ul><p id="e2b1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们可以通过观察来扩展这个陈述。<code class="eh mv mw mx my b">invalidTxs</code>的数量不会增加超过一个。正如你在上面看到的，我已经发送了两次<code class="eh mv mw mx my b">test.tx</code>无效交易，计数器停在了一次。这很可能是因为在该时期(1分钟)内没有再次输入交易验证代码。一旦发现无效交易。</p></div><div class="ab cl ln lo hb lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hm hn ho hp hq"><p id="16c9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">总结一下:我们使用在线反编译器来查看ICT java代码，然后使用标准java编译器重新编译，并让它再次运行。我们将UDP数据包发送到我们重新编译的ICT，并通过它分析代码的前几行。</p><p id="097d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="ks">在下一章中，我计划(尝试)更深入地探讨ICT的逻辑，并向您展示我们如何识别无效交易，以及理解为什么它们目前通过了IRI和ICT。</em></p><p id="cc0c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">我很乐意看到您的问题、疑问或更正</strong></p><p id="429b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">干杯，<br/>陈安</p></div></div>    
</body>
</html>