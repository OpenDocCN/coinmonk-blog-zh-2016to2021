<html>
<head>
<title>Learnings from building my first dapp on EOS blockchain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在EOS区块链上构建我的第一个dapp的经验</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learnings-from-building-my-first-dapp-on-eos-blockchain-4ae046c09b78?source=collection_archive---------4-----------------------#2018-08-08">https://medium.com/coinmonks/learnings-from-building-my-first-dapp-on-eos-blockchain-4ae046c09b78?source=collection_archive---------4-----------------------#2018-08-08</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="ae1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最近我在EOS区块链上发布了<a class="ae jo" href="https://cmichel.io/releasing-my-first-eos-dapp/introducing-king-of-eos" rel="noopener ugc nofollow" target="_blank">我的第一个去中心化应用</a>，EOS之王<a class="ae jo" href="https://kingofeos.com" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="b2f3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是一个游戏，玩家通过支付比前一个竞争者更多的钱来争夺王位，并通过这种方式获得EOS。👑</p><p id="02ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这篇文章将会谈到开发方面的事情，去<a class="ae jo" href="https://cmichel.io/releasing-my-first-eos-dapp/introducing-king-of-eos" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多关于游戏的信息。</p><p id="58da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它由一个简单的智能合约组成，约200行代码和一个用React(带next)编写的前端。</p><h2 id="ba2f" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">前端</h2><p id="6070" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">前端我就不多说了，因为这是一个用React写的标准静态站点，用<a class="ae jo" href="https://github.com/zeit/next.js/" rel="noopener ugc nofollow" target="_blank"> next </a>。想想看，它并不是那么标准——它使用WebGL和<strong class="is hu"> Three.js </strong>通过渲染带有自定义旗帜和随机生成的3D地形的城堡来真正可视化王国。</p><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="fe ff kp"><img src="../Images/b94226977886bee8e9401f8922685372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AOrHZ-Hf-47JmjRg.png"/></div></div></figure><h2 id="0afe" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">与区块链的沟通</h2><p id="9add" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">为了与区块链沟通，我使用了eosjs。我将状态保存在区块链上智能合约的数据库中，我的前端使用<code class="eh lb lc ld le b">eosjs</code>读取国王表和<em class="lf">名人堂</em>。</p><pre class="kq kr ks kt fq lg le lh li aw lj dt"><span id="ac7e" class="jp jq ht le b fv lk ll l lm ln">import Eos from 'eosjs'<br/><br/>const host = process.env.EOS_NETWORK_HOST<br/>const port = process.env.EOS_NETWORK_PORT<br/>const chainId = process.env.EOS_NETWORK_CHAINID<br/><br/>const network = {<br/>    blockchain: `eos`,<br/>    protocol: `https`,<br/>    host,<br/>    port,<br/>    chainId,<br/>}<br/><br/>const eos = Eos({ httpEndpoint: `${network.protocol}://${network.host}:${network.port}` })<br/><br/>const ROWS_LIMIT = 99999<br/><br/>const getKings = () =&gt; eos<br/>        .getTableRows({<br/>            json: true,<br/>            code: `kingofeos`,<br/>            scope: `kingofeos`,<br/>            table: `claims`,<br/>            table_key: `kingdomKingIndex`,<br/>            lower_bound: 0,<br/>            upper_bound: -1,<br/>            limit: ROWS_LIMIT,<br/>        })<br/>        .catch(console.err)<br/><br/>export { network, getKings }</span></pre><h2 id="2024" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">用户与区块链的交互</h2><p id="6541" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">更有趣的是如何让用户使用前端作为区块链的接口与我的智能合同进行交互。现在最好的方法是使用<a class="ae jo" href="https://get-scatter.com/" rel="noopener ugc nofollow" target="_blank">散布</a>。这是一个安全的Chrome扩展，可以充当钱包。用户导入他们的私钥，扩展注入一个API，允许从我的前端代码中请求事务签名。当然，Chrome扩展运行在自己的沙箱中，私钥永远不会泄露给网站。与Scatter通信的唯一方式是通过其注入的API。</p><p id="addc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">比方说，一个用户想成为EOS之王，并要求王位:他会点击<code class="eh lb lc ld le b">Claim</code>，在一个模态中填写他的信息，然后我的前端代码使用<code class="eh lb lc ld le b">eosjs</code>构建事务，然后请求Scatter签署事务。将向用户显示一个弹出窗口，用户可以在其中查看交易并接受交易。</p><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="fe ff lo"><img src="../Images/23be75f939b74eeadaa2fb11115387bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nIj560giilH3gtv1.gif"/></div></div></figure><p id="84e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面是这样做的<code class="eh lb lc ld le b">redux</code>动作:</p><pre class="kq kr ks kt fq lg le lh li aw lj dt"><span id="9339" class="jp jq ht le b fv lk ll l lm ln">export const scatterClaim = ({<br/>    displayName,<br/>    imageId,<br/>    claimPrice,<br/>}) =&gt; (dispatch, getState) =&gt; {<br/>    const { scatter, network, scateos } = getState().scatter<br/>    let accountName<br/>    const memo = `${displayName};${imageId};`<br/><br/>    // if there is no identity but forgetIdentity is called<br/>    // scatter will throw "There is no identity with an account set on your Scatter instance."<br/>    const clearIdentityPromise = scatter.identity<br/>        ? () =&gt; scatter.forgetIdentity()<br/>        : () =&gt; Promise.resolve()<br/>    return clearIdentityPromise()<br/>        .then(() =&gt; scatter.getIdentity({ accounts: [network] }))<br/>        .then(identity =&gt; {<br/>            if (!Array.isArray(identity.accounts) || identity.accounts.length &lt; 1)<br/>                throw new Error(`No identity`)<br/>            accountName = identity.accounts[0].name<br/>        })<br/>        // get the eosio.token contract and call its `transfer` action<br/>        .then(() =&gt; scateos.contract(`eosio.token`))<br/>        .then(contract =&gt;<br/>            contract.transfer(<br/>                accountName, `eoskingofeos`, `${claimPrice} EOS`, memo,<br/>            )<br/>        )<br/>        .then(resolve =&gt; {<br/>            console.log(`success`)<br/>            dispatch({ type: `CLOSE_MODAL` })<br/>            // wait 2 seconds to make block irreversible<br/>            setTimeout(resolve, 2000)<br/>        })<br/>        .then(() =&gt; {<br/>            // and then fetch new kings<br/>            fetchCurrentKingdom()(dispatch)<br/>        })<br/>        .catch(err =&gt;<br/>            // logout on error and re-throw the error to the UI<br/>            scatter.forgetIdentity().then(() =&gt; {<br/>                throw err<br/>            }),<br/>        )<br/>}</span></pre><h2 id="36c1" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">后端</h2><h2 id="69dd" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">工作流程</h2><p id="5700" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">后端是用<code class="eh lb lc ld le b">C++</code>编写的智能合约，编译成WebAssembly，然后部署到EOS区块链。与任何EOS代码交互的通常方式是使用nodeos 运行您自己的本地<strong class="is hu">节点，该节点生成包含区块链事务的块，并使用<code class="eh lb lc ld le b">cleos</code> CLI对您的节点运行所有命令。这包括在区块链上创建帐户、解锁钱包、编译合同、部署合同、调用已部署合同上的操作等。</strong></p><p id="fa7f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我在开发时通过Windows的Linux子系统在Windows上运行节点(<code class="eh lb lc ld le b">nodeos</code>)，有时它变得没有响应，我必须杀死它，然后重新做整个过程。</p><p id="796a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，我为我的工作流程构建了许多工具。我建立了一个NPM项目，并使用Node with <a class="ae jo" href="https://github.com/EOSIO/eosjs" rel="noopener ugc nofollow" target="_blank"> eosjs </a>代替了所有的<code class="eh lb lc ld le b">cleos</code> CLI。最后，我只是再次运行NPM脚本，我和大多数web开发人员都觉得这非常方便。</p><p id="43bb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我只需运行<code class="eh lb lc ld le b">npm run deploy</code>将我的智能合约部署到我的本地节点，然后运行<code class="eh lb lc ld le b">npm run @transfer</code>对我部署的智能合约执行转移操作。如果有兴趣，我可以创建一个脚手架工具<code class="eh lb lc ld le b">create-eos-app</code>，它已经建立了一个这样的EOS项目，类似于<code class="eh lb lc ld le b">create-react-app</code>。</p><h2 id="bef1" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">智能合同</h2><p id="c6a5" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">智能合约只有大约200行C++代码。关于EOS开发的教程并不多，但是一旦你弄清楚它是如何工作的，并且阅读了其他契约的代码，编写起来就相当容易了。我正在写一本关于EOS全栈开发的书，让人们更容易入门。</p><p id="a63c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">智能合约的代码<a class="ae jo" href="https://github.com/MrToph/KingOfEos/blob/master/contract/contract/KingOfEOS.cpp" rel="noopener ugc nofollow" target="_blank">可以在GitHub </a>上找到，如果你想看看的话。</p><h2 id="261c" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">优化RAM的使用</h2><p id="a8aa" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">每个智能合同都与部署智能合同的相应EOS帐户相关联。该EOS帐户需要特定数量的RAM来保存智能合约(webassembly)代码和存储数据库条目。只有有限的内存可用(64GB ),这是一个自由市场。也就是说，价格是由供求关系决定的，最近投机者对价格上涨很感兴趣。</p><p id="4c62" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">那时候买1 KB内存要0.32 EOS。最新价格可以在eos.feexplorer.io 上查询<a class="ae jo" href="https://eos.feexplorer.io/" rel="noopener ugc nofollow" target="_blank">。这意味着<strong class="is hu">契约及其数据库</strong>的大小将直接决定开发者需要为智能契约支付多少费用。</a></p><p id="f124" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">一个EOS智能合约需要多少RAM？</strong></p><p id="196c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">估计数据库所需的<strong class="is hu">内存量非常简单。它与序列化数据条目的字节数成比例，这很容易计算。在我的例子中，这是我为每个新的王座声明存储的C++结构:</strong></p><pre class="kq kr ks kt fq lg le lh li aw lj dt"><span id="ee67" class="jp jq ht le b fv lk ll l lm ln">struct claim_record<br/>{<br/>    // upper 56 bits contain kingdom order, lower 8 bits contain kingOrder<br/>    uint64_t kingdomKingIndex; // this also acts as key of the table<br/>    time claimTime; // is 64 bit<br/>    account_name name; // typedef for uint64_t<br/>    std::string displayName; // restricted in my code to max 100 chars<br/>    std::string image; // restricted in my code to 32 chars<br/><br/>    uint64_t primary_key() const { return kingdomKingIndex; }<br/>    EOSLIB_SERIALIZE(claim_record, ...)<br/>};</span></pre><p id="4699" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们只需合计每个字段所需的字节数:</p><pre class="kq kr ks kt fq lg le lh li aw lj dt"><span id="7217" class="jp jq ht le b fv lk ll l lm ln">8bytes + 8bytes + 8bytes + 100bytes + 32bytes (+114 bytes unknown overhead) = 270bytes</span></pre><p id="8ee7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">优化<code class="eh lb lc ld le b">struct</code> s很难，但我做的一件事是在单个<code class="eh lb lc ld le b">uint64_t</code>的高位和低位编码游戏的当前回合和国王指数。</p><p id="05ae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">估计EOS smart合同需要的内存数量要困难得多，我只能在将它部署到区块链后检查它。</p><p id="b112" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以下是我注意到的一些情况，它们将帮助您减少EOS合同所需的内存数量:</p><ul class=""><li id="1b0e" class="lp lq ht is b it iu ix iy jb lr jf ls jj lt jn lu lv lw lx dt translated">web程序集编译器足够智能，可以排除您在合同中不使用的头文件和函数定义。于是就有了<a class="ae jo" href="https://en.wikipedia.org/wiki/Dead_code_elimination" rel="noopener ugc nofollow" target="_blank">死码消除</a>。没有必要注释掉未使用的头文件。</li><li id="810b" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated"><strong class="is hu">不使用</strong> <code class="eh lb lc ld le b"><strong class="is hu">std::to_string</strong></code> <strong class="is hu">为你节省188.3 KiB </strong>(当时71 EOS / 500美元)。最初，我用它在一条<code class="eh lb lc ld le b">assert</code>消息中打印一个数字。删除它节省了我很多内存。</li><li id="176e" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">将函数标记为<code class="eh lb lc ld le b">inline</code>通常也会减少你的契约的大小。</li><li id="7b4a" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">我检查了其他一些我可以优化的第三方函数，最终用我自己的实现替换了<code class="eh lb lc ld le b">boost::split</code>的字符串分割函数。它将RAM需求又降低了20 KiB。</li></ul><p id="93c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">导致<strong class="is hu">智能契约需要部署200个KiB </strong>(不包括存储条目所需的动态RAM量)。使用<a class="ae jo" href="https://www.eosrp.io/#calc" rel="noopener ugc nofollow" target="_blank"> EOS资源规划器</a>我计算出我需要为220 KiB的内存支付70 EOS。对于一份真正简单、优化的智能合同来说，这大约是500美元。如果我不做优化，我会付双倍的钱。</p><blockquote class="md me mf"><p id="c5d7" class="iq ir lf is b it iu iv iw ix iy iz ja mg jc jd je mh jg jh ji mi jk jl jm jn hm dt translated">更新:上个月内存价格减半。所以现在大约是250美元——但是RAM价格的高波动性使它很难计划。</p></blockquote><p id="7a55" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">与以太坊相比，开发者需要支付很多费用，这可能会阻碍新开发者在EOS上开发。对于独立开发者来说，制作有趣的小项目来开始，这太多了。</p><h2 id="f2ab" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">结论</h2><p id="98aa" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">我希望这篇文章能让你对我如何开发我的第一个EOS dapp有所了解，并提供一些简单的技巧来减少你的EOS智能合约所需的内存量。</p><p id="b8f6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从开发人员的角度来看，很高兴看到RAM已经下降到0.17 EOS / KB，尽管这对非营利项目来说仍然太多。肯定需要更多的工具，运行<code class="eh lb lc ld le b">cleos</code>变得很烦人。但是EOS只有2个月大，所以我期待更多。</p></div><div class="ab cl mj mk hb ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hm hn ho hp hq"><p id="3660" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最初发布于<a class="ae jo" href="https://cmichel.io/releasing-my-first-eos-dapp/" rel="noopener ugc nofollow" target="_blank"> cmichel.io </a></p><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="fe ff mq"><img src="../Images/9272604a558a6998fb16fa67859515da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J-HdCMGJ7sHhvwCx.png"/></div></div></figure></div></div>    
</body>
</html>