<html>
<head>
<title>Schnorr Signatures in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的Schnorr签名</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/schnorr-signatures-in-go-80a7fbfe0fe4?source=collection_archive---------1-----------------------#2018-04-05">https://medium.com/coinmonks/schnorr-signatures-in-go-80a7fbfe0fe4?source=collection_archive---------1-----------------------#2018-04-05</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="c79d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我认为，当我进入密码学和一些时髦的素数曲线循环数论的混乱状态，并为我正在工作的一家新公司学习Golang时，我还不如尝试在Go中介绍Schnorr签名方案。</p><p id="63f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们使用基于离散对数问题的非对称密码系统(任何处理椭圆曲线的ole系统都可以)。</p><p id="b655" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了简化处理椭圆曲线的操作，我们将利用一个方便的库<a class="ae jo" href="https://github.com/dedis/kyber" rel="noopener ugc nofollow" target="_blank"> dedis/kyber </a>。</p><p id="e097" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以下是我们一如既往的进口商品:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="4775" class="jy jz ht ju b fv ka kb l kc kd"><strong class="ju hu">import </strong>(<br/>   <strong class="ju hu">"gopkg.in/dedis/kyber.v2"<br/>   "gopkg.in/dedis/kyber.v2/group/edwards25519"<br/>   "fmt"<br/></strong>)</span></pre><p id="be2c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了表明<code class="eh ke kf kg ju b">kyber</code>作为一个库有多好，我们将椭圆曲线的基点定义为生成器<code class="eh ke kf kg ju b">G</code>。通过选择一个随机标量作为我们的私钥<code class="eh ke kf kg ju b">x</code>，我们可以得到我们的公钥<code class="eh ke kf kg ju b">y</code>，也就是<code class="eh ke kf kg ju b">y = x * G</code>。</p><p id="56e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">换句话说，我们在我们的椭圆曲线的加法群中执行运算<code class="eh ke kf kg ju b">x</code>次。</p><p id="6d0a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以上所有内容都可以用下面的代码来表示:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="a2ea" class="jy jz ht ju b fv ka kb l kc kd">privateKey := curve.Scalar().Pick(curve.RandomStream())<br/>publicKey := curve.Point().Mul(privateKey, curve.Point().Base())<br/><br/>fmt.Printf(<strong class="ju hu">"Generated private key: %s\n"</strong>, privateKey)<br/>fmt.Printf(<strong class="ju hu">"Derived public key: %s\n\n"</strong>, publicKey)</span></pre><p id="1863" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">正如您可能已经从曲线中猜到的，我们将使用椭圆曲线组Edwards 25519，这是另一个签名方案变体EdDSA广泛使用的。</p><p id="04b5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将使用SHA256作为散列函数，它将对要签名的消息进行指纹识别。</p><p id="0a71" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还将定义一个漂亮的<code class="eh ke kf kg ju b">struct</code>来保存一些数据集，这些数据集将代表我们的消息签名和我们的纯文本散列函数</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="7b3d" class="jy jz ht ju b fv ka kb l kc kd"><strong class="ju hu">var </strong>curve = edwards25519.NewBlakeSHA256Ed25519()<br/><strong class="ju hu">var </strong>sha256 = curve.Hash()<br/><br/><strong class="ju hu">type </strong>Signature <strong class="ju hu">struct </strong>{<br/>   r kyber.Point<br/>   s kyber.Scalar<br/>}</span><span id="eb3d" class="jy jz ht ju b fv kh kb l kc kd"><strong class="ju hu">func </strong>Hash(s string) kyber.Scalar {<br/>   sha256.Reset()<br/>   sha256.Write([]byte(s))<br/><br/>   <strong class="ju hu">return </strong>curve.Scalar().SetBytes(sha256.Sum(nil))<br/>}</span></pre><p id="b5cd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以，让我们深入研究一下这个方案。</p><p id="462b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">围绕离散对数方案，我们将利用陷门函数，它基本上代表一个反函数极难计算的函数。</p><p id="4c4b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">值得庆幸的是，由于我们选择的hash(sha 256)具有非常好的抗碰撞攻击的特性，它非常适合如下的Schnorr方案。</p><p id="631c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们定义一个签名验证函数，其中:</p><p id="2b34" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh ke kf kg ju b">H'(m, s, e) = H(m || s * G + e * y)</code> <br/> …定义为在<code class="eh ke kf kg ju b">H'(m, s, e) = e</code>时已经验证了某组数据。</p><p id="18a1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh ke kf kg ju b">m</code>是被签名的消息，<code class="eh ke kf kg ju b">s</code>是我们签名的第1部分，<code class="eh ke kf kg ju b">e</code>是我们的消息与变量<code class="eh ke kf kg ju b">r</code>连接的散列，变量<code class="eh ke kf kg ju b">r</code>是我们签名的第2部分。</p><p id="a01c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh ke kf kg ju b">m, r, s, e, G, y</code>被公开分发，以供用户验证由<code class="eh ke kf kg ju b">x, y</code>定义的非对称密钥对下的某个用户确实签署了给定的消息<code class="eh ke kf kg ju b">m</code>。</p><p id="31a4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了证明只有拥有这样一个密钥对的用户(或受到攻击的用户)才有可能为消息<code class="eh ke kf kg ju b">m</code>创建签名部分<code class="eh ke kf kg ju b">r, s</code>使得<code class="eh ke kf kg ju b">H’(m, s, e) = e</code>，回想一下<code class="eh ke kf kg ju b">y = x * G</code>:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="ad0c" class="jy jz ht ju b fv ka kb l kc kd">H'(m, s, e) = e = H(m || s * G + e * y)<br/>e = H(m || s * G + e * y)<br/>e = H(m || s * G + e * x * G)<br/>e = H(m || G(s + e * x))</span></pre><p id="fcd0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于<code class="eh ke kf kg ju b">s, e</code>和<code class="eh ke kf kg ju b">m</code>是已知的，使条件语句<code class="eh ke kf kg ju b">e == e</code>为真的唯一方法是用户知道私钥<code class="eh ke kf kg ju b">x</code>。Q.E.D…？</p><p id="1a83" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了对消息<code class="eh ke kf kg ju b">m</code>进行签名并导出签名部分<code class="eh ke kf kg ju b">r</code>和<code class="eh ke kf kg ju b">s</code>，我们选择一个随机标量<code class="eh ke kf kg ju b">k</code>作为我们签名方案的种子。</p><p id="70aa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们在曲线的乘法群中围绕我们的生成点<code class="eh ke kf kg ju b">G</code>运算<code class="eh ke kf kg ju b">k</code>次以导出<code class="eh ke kf kg ju b">r = k * G</code>。<code class="eh ke kf kg ju b">k</code>是我们定义的使整个方案成功/失败的剩余和，我们定义为:</p><p id="3d10" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh ke kf kg ju b">k = s + e * x</code>；于是<code class="eh ke kf kg ju b">H'(m, s, e) = H(m || k * G) = H(m || r) = e</code>。</p><p id="cd4b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，在导出<code class="eh ke kf kg ju b">r</code>之后，得到<code class="eh ke kf kg ju b">e = H(m || r)</code>并导出:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="4640" class="jy jz ht ju b fv ka kb l kc kd">s = k - e * x</span></pre><p id="c996" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你已经准备好你的签名了！</p><p id="b099" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在围棋中，你应该这样表达它:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="6898" class="jy jz ht ju b fv ka kb l kc kd"><em class="ki">// m: Message<br/>// x: Private key<br/></em><strong class="ju hu">func </strong>Sign(m string, x kyber.Scalar) Signature {<br/>   <em class="ki">// Get the base of the curve.<br/>   </em>g := curve.Point().Base()<br/><br/>   <em class="ki">// Pick a random k from allowed set.<br/>   </em>k := curve.Scalar().Pick(curve.RandomStream())<br/><br/>   <em class="ki">// r = k * G (a.k.a the same operation as r = g^k)<br/>   </em>r := curve.Point().Mul(k, g)<br/><br/>   <em class="ki">// Hash(m || r)<br/>   </em>e := Hash(m + r.String())<br/><br/>   <em class="ki">// s = k - e * x<br/>   </em>s := curve.Scalar().Sub(k, curve.Scalar().Mul(e, x))<br/><br/>   <strong class="ju hu">return </strong>Signature{r: r, s: s}<br/>}</span></pre><p id="644e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，请注意，每次我们签署消息时，我们都应该选择一个全新的真正随机信息源的<code class="eh ke kf kg ju b">k</code>(考虑到<code class="eh ke kf kg ju b">H(x)</code>独特的前图像属性，你甚至可以用<code class="eh ke kf kg ju b">H(m || x)</code>来播种它！).</p><p id="5c30" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有了<code class="eh ke kf kg ju b">k = s + e * x</code>，让我们为两个不同的消息<code class="eh ke kf kg ju b">(r0, s0, e0)</code>和<code class="eh ke kf kg ju b">(r1, s1, e1)</code>获得一组签名。</p><p id="edd3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">**注意第<code class="eh ke kf kg ju b">i</code>个索引上的<code class="eh ke kf kg ju b">r</code>是从第<code class="eh ke kf kg ju b">i</code>个索引上的<code class="eh ke kf kg ju b">e</code>和<code class="eh ke kf kg ju b">s</code>通过<code class="eh ke kf kg ju b">r = s * G + e * y</code>派生出来的。</p><p id="fb86" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果两条消息的<code class="eh ke kf kg ju b">k</code>相同，表示:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="9536" class="jy jz ht ju b fv ka kb l kc kd">k = s0 + e0 * x = s1 + e1 * x<br/>s0 + e0 * x = s1 + e1 * x<br/>(s0 - s1) = (e1 - e0) * x<br/>(s0 - s1) / (e1 - e) = x</span></pre><p id="36c2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">…因此，如果您不小心，使用固定的<code class="eh ke kf kg ju b">k</code>，您可能会泄露用户的私钥<code class="eh ke kf kg ju b">x</code>！</p><p id="2b4c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">给定签名组件，您可以从这个等式中得出一个很酷的东西，消息也是用户的公钥。</p><p id="197e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这可能是通过从签名中导出公钥来验证签名的一种方法。</p><p id="1259" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">简单回忆一下<code class="eh ke kf kg ju b">r = s * G + e * y</code>，我们可以通过下式导出<code class="eh ke kf kg ju b">y</code>:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="ed6b" class="jy jz ht ju b fv ka kb l kc kd">y = (r - s * G) * (1 / e)</span></pre><p id="5f50" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">…在围棋中可以很容易地表示为:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="e5e3" class="jy jz ht ju b fv ka kb l kc kd"><em class="ki">// m: Message<br/>// S: Signature<br/></em><strong class="ju hu">func </strong>PublicKey(m string, S Signature) kyber.Point {<br/>   <em class="ki">// Create a generator.<br/>   </em>g := curve.Point().Base()<br/><br/>   <em class="ki">// e = Hash(m || r)<br/>   </em>e := Hash(m + S.r.String())<br/><br/>   <em class="ki">// y = (r - s * G) * (1 / e)<br/>   </em>y := curve.Point().Sub(S.r, curve.Point().Mul(S.s, g))<br/>   y = curve.Point().Mul(curve.Scalar().Div(curve.Scalar().One(), e), y)<br/><br/>   <strong class="ju hu">return </strong>y<br/>}</span></pre><p id="8b03" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，一个更好的验证签名的方法是看看我们的椭圆曲线群上的乘法和加法运算是否产生与<code class="eh ke kf kg ju b">s * G</code>相同的点。</p><p id="ba9c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，这不需要我们在每轮验证中使用昂贵的散列函数计算两次。</p><p id="dcb9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">利用某人发送给我们的签名组件<code class="eh ke kf kg ju b">(r, s)</code>，以及他们的公钥和纯文本消息，我们首先获得<code class="eh ke kf kg ju b">e = H(m || r)</code>，并得到:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="2162" class="jy jz ht ju b fv ka kb l kc kd">r = s * G + e * y<br/>s * G = r - e * y</span></pre><p id="35eb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">…并检查从<code class="eh ke kf kg ju b">r</code>导出的<code class="eh ke kf kg ju b">s * G</code>是否等同于纯计算<code class="eh ke kf kg ju b">s * G</code>。请记住，<code class="eh ke kf kg ju b">s * G</code>匹配的唯一方式是使用非对称密钥对<code class="eh ke kf kg ju b">(x, y)</code>派生的组件<code class="eh ke kf kg ju b">(r, s)</code>是否真正属于并且只有特定的人知道。</p><p id="52e1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">否则，陷门功能将无法实现，因此该方案仍然是安全的。</p><p id="2717" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，在围棋中…</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="694a" class="jy jz ht ju b fv ka kb l kc kd"><em class="ki">// m: Message<br/>// s: Signature<br/>// y: Public key<br/></em><strong class="ju hu">func </strong>Verify(m string, S Signature, y kyber.Point) bool {<br/>   <em class="ki">// Create a generator.<br/>   </em>g := curve.Point().Base()<br/><br/>   <em class="ki">// e = Hash(m || r)<br/>   </em>e := Hash(m + S.r.String())<br/><br/>   <em class="ki">// Attempt to reconstruct 's * G' with a provided signature; s * G = r - e * y<br/>   </em>sGv := curve.Point().Sub(S.r, curve.Point().Mul(e, y))<br/><br/>   <em class="ki">// Construct the actual 's * G'<br/>   </em>sG := curve.Point().Mul(S.s, g)<br/><br/>   <em class="ki">// Equality check; ensure signature and public key outputs to s * G.<br/>   </em><strong class="ju hu">return </strong>sG.Equal(sGv)<br/>}</span></pre><p id="347f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">…现在我们的Schnorr计划已经准备好了！也许更好的分布式DAG修剪操作。</p><p id="b06f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">令人惊叹的是，这完全是通过一些高中代数实现的(这受到椭圆曲线组运算的一点阻碍)。</p><p id="fcd9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是我用一个很好的助手打印函数做的一个小测试案例:</p><pre class="jp jq jr js fq jt ju jv jw aw jx dt"><span id="75d9" class="jy jz ht ju b fv ka kb l kc kd"><strong class="ju hu">func </strong>(S Signature) String() string {<br/>   <strong class="ju hu">return </strong>fmt.Sprintf(<strong class="ju hu">"(r=%s, s=%s)"</strong>, S.r, S.s)<br/>}</span><span id="2148" class="jy jz ht ju b fv kh kb l kc kd"><strong class="ju hu">func </strong>main() {<br/>   privateKey := curve.Scalar().Pick(curve.RandomStream())<br/>   publicKey := curve.Point().Mul(privateKey, curve.Point().Base())<br/><br/>   fmt.Printf(<strong class="ju hu">"Generated private key: %s\n"</strong>, privateKey)<br/>   fmt.Printf(<strong class="ju hu">"Derived public key: %s\n\n"</strong>, publicKey)<br/><br/>   message := <strong class="ju hu">"We're gonna be signing this!"<br/><br/>   </strong>signature := Sign(message, privateKey)<br/>   fmt.Printf(<strong class="ju hu">"Signature %s\n\n"</strong>, signature)<br/><br/>   derivedPublicKey := PublicKey(message, signature)<br/>   fmt.Printf(<strong class="ju hu">"Derived public key: %s\n"</strong>, derivedPublicKey)<br/>   fmt.Printf(<strong class="ju hu">"Are the original and derived public keys the same? %t\n"</strong>, publicKey.Equal(derivedPublicKey))<br/>   fmt.Printf(<strong class="ju hu">"Is the signature legit w.r.t the original public key? %t\n\n"</strong>, Verify(message, signature, publicKey))<br/><br/>   fakePublicKey := curve.Point().Mul(curve.Scalar().Neg(curve.Scalar().One()), publicKey)<br/>   fmt.Printf(<strong class="ju hu">"Fake public key: %s\n"</strong>, fakePublicKey)<br/>   fmt.Printf(<strong class="ju hu">"Is the signature legit w.r.t a fake public key? %t\n"</strong>, Verify(message, signature, fakePublicKey))<br/>}</span></pre><p id="6f54" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，当涉及到在各种有趣的分散应用中利用Schnorr作为部分群/门限签名(环签名)的形式的应用时，它是相对容易实现的。</p><p id="b0ed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">不过，我想把这个练习留给你。</p><p id="cf5c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请随意阅读这里的更多数学知识:<a class="ae jo" href="https://www.deadalnix.me/2017/02/17/schnorr-signatures-for-not-so-dummies/" rel="noopener ugc nofollow" target="_blank">https://www . dead alnix . me/2017/02/17/schn orr-signatures-for-not-so-dummies/</a></p><p id="f249" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">享受:)。如果你想在Github上发布源代码，请告诉我。</p><h2 id="c2af" class="jy jz ht bd kj kk kl km kn ko kp kq kr jb ks kt ku jf kv kw kx jj ky kz la lb dt translated">另外，阅读</h2><ul class=""><li id="0bc7" class="lc ld ht is b it le ix lf jb lg jf lh jj li jn lj lk ll lm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/whats-the-best-crypto-trading-bot-in-2020-top-8-bitcoin-trading-bot-c16adeb13317">最佳加密交易机器人</a></li><li id="51e2" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated">最好的比特币<a class="ae jo" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069?source=friends_link&amp;sk=324dd9ff8556ab578d71e7ad7658ad7c">硬件钱包</a></li><li id="69bb" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated">最好的<a class="ae jo" rel="noopener" href="/coinmonks/best-crypto-tax-tool-for-my-money-72d4b430816b">加密税务软件</a></li><li id="7c4f" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/the-best-crypto-trading-platforms-in-2020-the-definitive-guide-updated-c72f8b874555">最佳加密交易平台</a></li><li id="3524" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/best-wallets-to-use-uniswap-e91a6385d9e8">unis WAP最佳钱包</a></li><li id="97a4" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated">最佳<a class="ae jo" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="cfcc" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/defi-future-10-promising-projects-in-the-defi-world-ff2b697ab006">顶级DeFi项目</a></li><li id="a1cf" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated">bits gap review——一个轻松赚钱的加密交易机器人</li><li id="2401" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated">为专业人士设计的加密交易机器人</li><li id="2791" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated"><a class="ae jo" href="https://blog.coincodecap.com/3commas-review-an-excellent-crypto-trading-bot" rel="noopener ugc nofollow" target="_blank"> 3commas Review </a> |一款优秀的密码交易机器人</li><li id="4582" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/cryptohopper-vs-3commas-vs-shrimpy-a2c16095b8fe"> 3Commas vs Cryptohopper </a></li><li id="eb27" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated">Bitmex上的<a class="ae jo" rel="noopener" href="/coinmonks/the-idiots-guide-to-margin-trading-on-bitmex-dbbd7742c6fc?source=friends_link&amp;sk=7bfa99d2a181142510c8442c8ddb0786">保证金交易的白痴指南</a></li><li id="aaab" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/the-definitive-guide-to-crypto-swing-trading-7e4af6496d4d?source=friends_link&amp;sk=70448050bd9323b42f63bfc0bb1e60d1">加密摇摆交易权威指南</a></li><li id="cfc6" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/bitmex-advanced-margin-trading-guide-2270c195ce25?source=friends_link&amp;sk=1d986cca731f5084b9a2db4a4bc4a7ad"> Bitmex高级保证金交易指南</a></li><li id="6e2e" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated">开发人员的最佳加密API</li><li id="b037" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/crypto-arbitrage-guide-how-to-make-money-as-a-beginner-62bfe5c868f6">加密套利</a>指南:新手如何赚钱</li><li id="b46f" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated">顶级<a class="ae jo" href="https://blog.coincodecap.com/bitcoin-node-solutions" rel="noopener ugc nofollow" target="_blank">比特币节点</a>提供商</li><li id="0966" class="lc ld ht is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm dt translated">最佳<a class="ae jo" rel="noopener" href="/coinmonks/what-are-the-best-charting-platforms-for-cryptocurrency-trading-85aade584d80">加密制图工具</a></li></ul><blockquote class="ls"><p id="b751" class="lt lu ht bd lv lw lx ly lz ma mb jn ek translated"><a class="ae jo" href="https://coincodecap.com?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="md me mf mg mh mi fe ff paragraph-image"><a href="https://coincodecap.com?utm_source=coinmonks"><div class="fe ff mc"><img src="../Images/160ce73bd06d46c2250251e7d5969f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*BoDnKUyK8p4hitHAJZ5Pdw.png"/></div></a></figure></div></div>    
</body>
</html>