<html>
<head>
<title>Testing Solidity Dapp. SoTP — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试可靠性。SoTP —第2部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/testing-solidity-dapp-sotp-part-2-9685b3375aaf?source=collection_archive---------1-----------------------#2018-04-23">https://medium.com/coinmonks/testing-solidity-dapp-sotp-part-2-9685b3375aaf?source=collection_archive---------1-----------------------#2018-04-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/75c67b3ab17a5c6393c22b77b19c6ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDplo6knoXopzabAFpqEfw.jpeg"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Photo by <a class="ae ig" href="https://unsplash.com/photos/40k6ZqbsXuo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">freestocks.org</a> on <a class="ae ig" href="https://unsplash.com/search/photos/testing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="4f49" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们将在这里做一些真正的Dapp测试，并看到这样做的一些很酷的功能。在《鲨鱼池》系列的前一部分中，我们已经创建了一个全功能的Solidity smart contracts Dapp。或者我们是这样认为的。在我们把它投入生产之前，必须对它进行测试。</p><p id="9f44" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji ik">Dapp</strong>的试玩版在<a class="ae ig" href="http://34.210.217.34/" rel="noopener ugc nofollow" target="_blank">这个地址</a>有。</p><p id="1b2f" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">所有的<strong class="ji ik">源代码</strong>都可以在<a class="ae ig" href="https://github.com/joze144/pool-shark" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中免费获得。</p><p id="1305" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">加入我们:<a class="ae ig" href="https://solidity_devs.select.id/bjxx" rel="noopener ugc nofollow" target="_blank"> Solidity开发社区，了解更多信息</a></p><h1 id="c8c1" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">测试环境</h1><p id="7aa8" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">对于编码部分，我们将使用带有async/await库的<a class="ae ig" href="http://truffleframework.com/docs/getting_started/javascript-tests" rel="noopener ugc nofollow" target="_blank"> Truffle框架。松露提供</a><a class="ae ig" href="http://web3js.readthedocs.io/en/1.0/" rel="noopener ugc nofollow" target="_blank"><strong class="ji ik">web 3</strong></a><a class="ae ig" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ji ik">摩卡</strong> </a>和<a class="ae ig" href="http://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ji ik">柴</strong> </a>库开箱。这正是我们所需要的。</p><p id="b4aa" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们还需要一个可以安全做事的区块链。为此，我们将使用<a class="ae ig" href="http://truffleframework.com/ganache/" rel="noopener ugc nofollow" target="_blank"> Ganache ("testrpc") </a>。它所做的，是在你的机器上运行一个测试区块链，并设置10个帐户，每个帐户有100ETH余额。</p><h1 id="bdb3" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">测试</h1><p id="2f2b" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">松露让你在这里的生活超级轻松。在truffle init上，它创建了一个测试目录，你应该把你的测试放在那里。当你将运行<strong class="ji ik"> truffle test </strong>命令时，它将自动经历编译、迁移和部署阶段，然后运行你目录中的所有测试。</p><p id="8544" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">从你的根目录运行<strong class="ji ik">块菌测试</strong>命令来运行测试</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="f719" class="lq kf ij lm b fv lr ls l lt lu">$ truffle test</span></pre><p id="9de7" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">您不必担心您是否正在测试最新的构建。松露确保了这一点。如果你想运行一个特定的测试文件，你可以把它作为test命令的一个参数。</p><p id="63a6" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">运行单个测试</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="9da3" class="lq kf ij lm b fv lr ls l lt lu">$ truffle test ./test/fishToken.js</span></pre><h2 id="0adf" class="lq kf ij bd kg lv lw lx kk ly lz ma ko jr mb mc ks jv md me kw jz mf mg la mh dt translated">测试基础</h2><p id="295c" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">首先，我们创建一个测试文件。这是一个极简测试的样子。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="eda3" class="lq kf ij lm b fv lr ls l lt lu"><strong class="lm ik">const <em class="mi">FishToken </em></strong>= artifacts.require(<strong class="lm ik">"./FishToken.sol"</strong>)<br/><br/><strong class="lm ik">const <em class="mi">timePeriodInSeconds </em></strong>= 3600<br/><strong class="lm ik">const <em class="mi">from </em></strong>= <strong class="lm ik"><em class="mi">Math</em></strong>.floor(<strong class="lm ik">new </strong>Date() / 1000)<br/><strong class="lm ik">const <em class="mi">to </em></strong>= <strong class="lm ik"><em class="mi">from </em></strong>+ <strong class="lm ik"><em class="mi">timePeriodInSeconds<br/><br/></em></strong>contract(<strong class="lm ik">'FishToken'</strong>, <strong class="lm ik">async </strong>(accounts) =&gt; {<br/>  <strong class="lm ik">const </strong>owner = accounts[0]<br/><br/>  <strong class="lm ik">let </strong>instance<br/>  beforeEach(<strong class="lm ik">'setup contract for each test'</strong>, <strong class="lm ik">async </strong>() =&gt; {<br/>    instance = <strong class="lm ik">await <em class="mi">FishToken</em></strong>.new(<strong class="lm ik"><em class="mi">to</em></strong>)<br/>  })<br/><br/>  it(<strong class="lm ik">'Owner is shark'</strong>, <strong class="lm ik">async </strong>() =&gt; {<br/>    <strong class="lm ik">const </strong>currentShark = <strong class="lm ik">await </strong>instance.currentShark()<br/>    assert.equal(currentShark, owner)<br/>  })<br/>})</span></pre><p id="205c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">松露在这里变了变戏法，默认为你提供了<a class="ae ig" href="http://web3js.readthedocs.io/en/1.0/" rel="noopener ugc nofollow" target="_blank"><strong class="ji ik">【web 3】</strong></a><a class="ae ig" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ji ik">摩卡</strong> </a>和<a class="ae ig" href="http://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ji ik">柴</strong> </a>库。让我们看看我们还用过什么:</p><ul class=""><li id="c55a" class="mj mk ij ji b jj jk jn jo jr ml jv mm jz mn kd mo mp mq mr dt translated"><strong class="ji ik"> artifacts.require() </strong>获取您的契约抽象。这样就不需要契约ABI或字节码。</li><li id="0ace" class="mj mk ij ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated"><strong class="ji ik"> contract() </strong>类似于摩卡里的<strong class="ji ik"> describe() </strong>。唯一的区别是它给了你<strong class="ji ik">账户</strong>参数，从<strong class="ji ik"> web3 </strong>获取你的账户，让你的生活更轻松。</li><li id="88a8" class="mj mk ij ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated"><strong class="ji ik"> beforeEach() </strong>和摩卡里一样。它在每个<strong class="ji ik"> it() </strong>之前被调用。这样，您可以为每个测试获得一个新的契约实例。</li><li id="d7f8" class="mj mk ij ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated"><strong class="ji ik"> Contract.now() </strong>部署契约的新实例。只需要提供构造函数参数。</li></ul><p id="c472" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">协定上的每个函数和变量都可以从实例中调用。让我们看看如何在我们的FishToken契约上调用<strong class="ji ik"> transfer() </strong>函数。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="6fde" class="lq kf ij lm b fv lr ls l lt lu"><strong class="lm ik">await </strong>instance.transfer(to, amount, {<strong class="lm ik">from</strong>: from, gas: 5000000, gasPrice: '20000000000000'})</span></pre><p id="8644" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji ik"> transfer() </strong>是一个函数实例。我们需要用我们在合同中定义的参数和一些特定于交易的参数来填充它:</p><ul class=""><li id="48ca" class="mj mk ij ji b jj jk jn jo jr ml jv mm jz mn kd mo mp mq mr dt translated"><strong class="ji ik">到</strong>是我们要发送令牌的地址。</li><li id="2ed7" class="mj mk ij ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated"><strong class="ji ik">金额</strong>是我们要发送的代币金额。</li><li id="b2eb" class="mj mk ij ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated">来自的<strong class="ji ik">是可选的。默认情况下，它是您的<strong class="ji ik">帐户</strong>变量中的第一个帐户。这是在合同代码中显示为msg.sender的帐户。</strong></li><li id="80d3" class="mj mk ij ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated"><strong class="ji ik">气</strong>和<strong class="ji ik">气价</strong>都是可选的。不需要真的为testnet设置它们，但是它们设置了你想要为事务花费的以太量。</li></ul><p id="966d" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">更多代码请查看存储库中的测试。在这里，我将描述更多的一般情况下，什么样的测试，我们必须为我们的Dapp。我们的Dapp可能看起来很简单，但是它实际上包含了相当多要测试的不那么琐碎和普通的东西。</p><h2 id="cfc0" class="lq kf ij bd kg lv lw lx kk ly lz ma ko jr mb mc ks jv md me kw jz mf mg la mh dt translated">能见度</h2><p id="f3c6" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">我们必须确保内部函数不能被执行。通过使用async/await，您可以将<strong class="ji ik"> try/catch </strong>放在应该失败的语句周围，并断言<strong class="ji ik"> catch() </strong>得到执行。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="05c0" class="lq kf ij lm b fv lr ls l lt lu">it(<strong class="lm ik">"Add to participants should be restricted"</strong>, <strong class="lm ik">async </strong>() =&gt; {<br/>  <strong class="lm ik">try </strong>{<br/>    <strong class="lm ik">await </strong>instance.addToParticipants(user1)<br/>    assert.equal(<strong class="lm ik">true</strong>, <strong class="lm ik">false</strong>)<br/>  } <strong class="lm ik">catch </strong>(err) {<br/>    assert.equal(<strong class="lm ik">true</strong>, <strong class="lm ik">true</strong>)<br/>  }<br/>})</span></pre><p id="4139" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们还必须确保我们的<strong class="ji ik"> issueToken() </strong>函数，只能由创建者执行，这是一个<strong class="ji ik">池</strong>契约。</p><h2 id="cdb7" class="lq kf ij bd kg lv lw lx kk ly lz ma ko jr mb mc ks jv md me kw jz mf mg la mh dt translated">溢出和下溢</h2><p id="bd6f" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated"><strong class="ji ik"> uint256 </strong>最大值为2ˇ256–1。这是一个巨大的数字，但是上溢和下溢仍然是可能的。如果您注意了本系列前一部分中的代码，您会发现我们已经在处理事务和发布新令牌时检查了溢出和下溢。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="22c1" class="lq kf ij lm b fv lr ls l lt lu"><strong class="lm ik">function </strong>transfer(<strong class="lm ik">address </strong>_to, <strong class="lm ik">uint256 </strong>_value) <strong class="lm ik">public </strong>onlyWhileOpen <strong class="lm ik">returns </strong>(<strong class="lm ik">bool </strong>success) {<br/>    <strong class="lm ik">if </strong>(balances[msg.sender] &lt; _value || balances[_to] + _value &lt;= balances[_to]) {<br/>        <strong class="lm ik">return false</strong>;<br/>    }</span></pre><p id="92b0" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在if语句中，我们检查发送方的余额是否足够进行该交易。这本身就防止了下溢。但是我们还必须检查接收方和添加金额的余额是否高于当前余额。可能发生的情况是，在添加数量后，我们得到一个溢出。这意味着我们越过了最大可能的数字，余额又开始从0开始计数。这肯定会破坏我们的数据，这种检查可以防止这种情况。</p><p id="7658" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们需要小心修改平衡状态的每一个函数。在我们的例子中，这意味着FishToken契约上的函数<strong class="ji ik"> transfer() </strong>和<strong class="ji ik"> issueToken() </strong>。而且在池合同上处理存款的功能，如果由于任何原因我们不能发行代币，必须拒绝存款。</p><p id="eb15" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">果然，在测试中我发现了一个问题。在溢出的情况下，我在<strong class="ji ik"> FishToken </strong>合约上拒绝了令牌的发行，但在<strong class="ji ik"> Pool </strong>合约上没有正确处理拒绝。</p><p id="7909" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们看看代码。这是有bug的旧版本。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="08b9" class="lq kf ij lm b fv lr ls l lt lu"><strong class="lm ik">function </strong>() <strong class="lm ik">public payable </strong>onlyWhileOpen {<br/>    require(msg.value &gt; 0);<br/>    <strong class="lm ik">uint256 </strong>rewardTokens = rate.mul(msg.value);<br/>    iFishToken(token).issueTokens(msg.sender, rewardTokens);<br/>}</span></pre><p id="28a0" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们只是称<strong class="ji ik"> issueTokens() </strong>不在乎结果。我们应该做的是要求<strong class="ji ik"> issueTokens() </strong>调用成功，否则恢复事务。固定代码看起来像这样</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="0494" class="lq kf ij lm b fv lr ls l lt lu"><strong class="lm ik">function </strong>() <strong class="lm ik">public payable </strong>onlyWhileOpen {<br/>    require(msg.value &gt; 0);<br/>    <strong class="lm ik">uint256 </strong>rewardTokens = rate.mul(msg.value);<br/>    require(iFishToken(token).issueTokens(msg.sender, rewardTokens));<br/>}</span></pre><p id="5f48" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我现在也修复了我以前帖子中的代码。</p><h2 id="6452" class="lq kf ij bd kg lv lw lx kk ly lz ma ko jr mb mc ks jv md me kw jz mf mg la mh dt translated">时间约束函数</h2><p id="0399" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">测试时间受限的函数有点棘手。有两种方法可以做到。一个你可以在区块链上操纵时间的街区。Zeppelin library已经有了一个<a class="ae ig" href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/test/helpers/increaseTime.js" rel="noopener ugc nofollow" target="_blank">助手来做这件事</a>，并且可以免费使用。当然，这只适用于测试网。</p><p id="cb82" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">但是我更喜欢做的是创建一个模拟契约，它让我可以操纵变量<strong class="ji ik">的值。这是我们将在这里使用的。您要做的是创建一个子契约，并添加测试所需的函数。</strong></p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="3fcb" class="lq kf ij lm b fv lr ls l lt lu"><strong class="lm ik">pragma </strong>solidity ^0.4.21;<br/><br/><strong class="lm ik">import "./SafeMath.sol"</strong>;<br/><strong class="lm ik">import "./FishToken.sol"</strong>;<br/><br/><strong class="lm ik">contract </strong>TimeMockedFishToken <strong class="lm ik">is </strong>FishToken {<br/>    <strong class="lm ik">using </strong>SafeMath <strong class="lm ik">for uint256</strong>;<br/><br/>    <strong class="lm ik">function </strong>leapForwardInTime(<strong class="lm ik">uint256 </strong>_seconds) <strong class="lm ik">public returns </strong>(<strong class="lm ik">bool </strong>success) {<br/>        <strong class="lm ik">if</strong>(deadline.sub(_seconds) &gt; deadline){<br/>            <strong class="lm ik">return false</strong>;<br/>        }<br/>        deadline = deadline.sub(_seconds);<br/>        <strong class="lm ik">return true</strong>;<br/>    }<br/><br/>    <strong class="lm ik">function </strong>leapBackInTime(<strong class="lm ik">uint256 </strong>_seconds) <strong class="lm ik">public returns </strong>(<strong class="lm ik">bool </strong>success) {<br/>        <strong class="lm ik">if</strong>(deadline.add(_seconds) &lt; deadline) {<br/>            <strong class="lm ik">return false</strong>;<br/>        }<br/>        deadline = deadline.add(_seconds);<br/>        <strong class="lm ik">return true</strong>;<br/>    }<br/><br/>    <strong class="lm ik">function </strong>TimeMockedFishToken(<strong class="lm ik">uint256 </strong>_deadline)  FishToken(_deadline) <strong class="lm ik">public </strong>{ }<br/>}</span></pre><p id="face" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">您可能会发现构造函数的定义有点奇怪(我就是这样)。它所做的只是将参数传递给FishToken构造函数。</p><p id="a178" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji ik"> TimeMockedFishToken </strong>拥有父<strong class="ji ik"> FishToken </strong>的所有方法和变量，但是让我们用这两个额外的方法来更改<strong class="ji ik"> deadline </strong>的值。看看我是如何在这个模拟契约中检查下溢和溢出的。只是为了让它进入肌肉记忆！</p><h1 id="32ef" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">排除故障</h1><p id="e963" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">每个人都会犯错，迟早你会不知道为什么有些交易没有通过。这就是松露再次帮助你的地方。它<a class="ae ig" href="http://truffleframework.com/docs/getting_started/debugging" rel="noopener ugc nofollow" target="_blank">提供了一个调试器</a>，帮助你调试事务执行。你只需要一个事务id，用它调用truffle debug命令。</p><p id="39a7" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">失败交易的示例。</p><figure class="lh li lj lk fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mx"><img src="../Images/318a42a2c652ec4f82f900253f9c22ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zOYCvc9Atg7TUkVUFSw68A.png"/></div></div></figure><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="4307" class="lq kf ij lm b fv lr ls l lt lu">$ truffle debug 0x1005b31598df0079cb09a591c93246458576298d995d97dd5bf0b7af3cf43804</span></pre><p id="8101" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">它将再次运行事务，并让您一步一步地通过它。您还可以看到变量的值，并轻松地找出导致事务被拒绝的确切原因。</p><h1 id="7286" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">结论</h1><p id="4fef" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">我们已经完成了智能合约的测试。我发现了一些可能的问题，并解决了它们。我想提一下，我只涉及了适用于我们Dapp的测试。要了解更多信息，我强烈推荐浏览Consensys 的<a class="ae ig" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/" rel="noopener ugc nofollow" target="_blank">已知攻击列表。现在，我们可以相当自信地认为，我们的智能合约会按计划运行。</a></p><p id="054c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你在我的代码中发现错误了吗？你能找到优化它的方法吗？请让我知道，我很想听到你的反馈！</p><p id="6797" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji ik">Dapp</strong>的演示可在<a class="ae ig" href="http://34.210.217.34/" rel="noopener ugc nofollow" target="_blank">这个地址</a>获得。</p><p id="f47a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">所有的<strong class="ji ik">源代码</strong>都可以在<a class="ae ig" href="https://github.com/joze144/pool-shark" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>中免费获得。</p><h2 id="c54e" class="lq kf ij bd kg lv lw lx kk ly lz ma ko jr mb mc ks jv md me kw jz mf mg la mh dt translated">该系列的部分内容:</h2><ul class=""><li id="f0c2" class="mj mk ij ji b jj lc jn ld jr my jv mz jz na kd mo mp mq mr dt translated"><a class="ae ig" rel="noopener" href="/@jozhe/learn-solidity-shark-of-the-pool-part-1-ac0f733eecdd">第1部分——可靠性智能合同</a></li><li id="6351" class="mj mk ij ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated"><strong class="ji ik">第2部分—测试坚固性Dapp </strong></li><li id="af72" class="mj mk ij ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated"><a class="ae ig" rel="noopener" href="/@jozhe/node-js-backend-service-for-ethereum-dapp-sotp-part-3-2d3aa5ec50e9">第3部分—节点。Solidity Dapp的JS后端服务</a></li><li id="d83f" class="mj mk ij ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated"><a class="ae ig" rel="noopener" href="/@jozhe/react-web-dapp-with-metamask-web3-sotp-part-4-f252ebe8d07f">第4部分—使用MetaMask Web3反应Web应用程序</a></li></ul></div></div>    
</body>
</html>