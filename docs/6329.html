<html>
<head>
<title>Blockchain Ep04: Unhashing the Hash Functions — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">区块链Ep04:解除哈希函数杂凑—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/blockchain-unhashing-the-hash-functions-part-2-a343ea00ec7d?source=collection_archive---------2-----------------------#2021-12-04">https://medium.com/coinmonks/blockchain-unhashing-the-hash-functions-part-2-a343ea00ec7d?source=collection_archive---------2-----------------------#2021-12-04</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="6c48" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本系列的第二篇<a class="ae jo" rel="noopener" href="/coinmonks/blockchain-unboxing-the-block-598b633741b3">帖子</a>中，我们看到了第一次提到的<strong class="is hu">散列函数</strong>，在之前的<a class="ae jo" rel="noopener" href="/@lbhy.mshr/blockchain-unhashing-the-hash-functions-part-1-3ac047148211">帖子</a>中，我们深入探讨了这些函数是如何获得这些特性的。到目前为止，我们看到的特征是—</p><ul class=""><li id="3ba2" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx dt translated">由于<em class="jy">模运算</em>而不可逆</li><li id="3955" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated">固定长度输出部分归因于<em class="jy">模运算</em></li><li id="a1f7" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated">伪随机性，意味着由于<em class="jy">散列</em>(剪切、切割、混合、混合等)，输出看起来一点也不像输入。)</li><li id="904f" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated">由于<em class="jy">哈希</em>导致的极端输入灵敏度</li></ul><p id="2f7f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这篇文章中，我们将看看<strong class="is hu">散列函数的第四个特性</strong>如何确保两个不同的输入不会产生相同的输出——碰撞阻力<strong class="is hu">。与上一篇文章不同，我建议你阅读这篇文章。它并不复杂，我们将在下一篇文章中对此进行阐述。但首先，一个新概念…</strong></p><h1 id="9653" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated"><strong class="ak">鸽子洞原理(PHP) </strong></h1><p id="e97d" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">如果你的鸽子数量超过了墙上可以容纳鸽子的洞的数量，至少有一个洞要容纳不止一只鸽子</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff lh"><img src="../Images/007bcb3d5091250b14f67cc044daf8d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*3eEVHqNH-JUG41h4.jpg"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Where am I supposed to go?</figcaption></figure><p id="ccc8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从<a class="ae jo" rel="noopener" href="/@lbhy.mshr/blockchain-unhashing-the-hash-functions-part-1-3ac047148211">上一篇文章</a>的特征2中，我们知道<strong class="is hu">哈希输出</strong>是一个固定长度的数字。这意味着我们可以生成的不同散列输出的总数有一个固有的限制。例如，如果散列输出被限制为4位数，那么我们只有10000个可能的散列输出(<em class="jy">0000–9999</em>)。然而，对可能的输入数量没有这样的限制，输入比输出多。因此，通过PHP ，一些输入将不得不映射到相同的散列输出。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff lt"><img src="../Images/9585c0539bbb62930289ada6c9bdb336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DgXtFW1INb6CMcgPKqC3Ig.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">How Collision happens when mapping an infinite set of inputs to a limited set of outputs</figcaption></figure><p id="ac83" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这叫做<strong class="is hu">碰撞</strong>，两个输入<em class="jy">在同一个输出上碰撞</em>。我们不希望在我们的<strong class="is hu">散列函数</strong>中出现冲突。</p><h1 id="a51d" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">特点4:抗碰撞</h1><p id="8e27" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated"><em class="jy">两个不同的输入产生相同输出的概率几乎为零，每个输入产生一个独特的输出，就像指纹</em></p><p id="c0f6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们真的无法避开PHP，这是事实，这个世界不可避免的事实。但是我们可以设计一些东西来尽可能长时间地避免它。具体来说有两种方式—</p><h2 id="a48b" class="ly kf ht bd kg lz ma mb kk mc md me ko jb mf mg ks jf mh mi kw jj mj mk la ml dt translated">方法1:增加所有可能输出的数量</h2><p id="e3bc" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">我们发现，如果我们把自己限制在4位<strong class="is hu">哈希输出</strong>上，我们就有10000或10⁴可能的输出可用。如果我们使用一个78位长的输出，我们会得到10⁷⁸可能的散列输出,<em class="jy">,它大于已知宇宙中的原子总数</em>。这是非常可行的，也是<strong class="is hu"> SHA-256 </strong>所做的。</p><p id="74d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://en.wikipedia.org/wiki/SHA-2" rel="noopener ugc nofollow" target="_blank"> SHA-256或安全哈希算法-256 </a>是比特币块链使用的哈希函数。<em class="jy">砰！</em>我们刚刚将我们的《区块链》与现实世界中的积木链连接起来！</p><h2 id="b680" class="ly kf ht bd kg lz ma mb kk mc md me ko jb mf mg ks jf mh mi kw jj mj mk la ml dt translated">方法2:探查</h2><p id="e10d" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">仅仅因为有很多可能的<strong class="is hu">哈希输出</strong>，并不意味着我们已经避免了<strong class="is hu">冲突</strong>。两个随机输入仍然可以生成相同的哈希输出。但这是有可能的。让我们将所有生成的哈希输出存储在<strong class="is hu">哈希存储表</strong>、<strong class="is hu"> HST </strong>中。然后，我们对每个新输入执行以下操作——</p><ul class=""><li id="1e5d" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx dt translated">如果新的输入产生了一个新的&amp;看不见的哈希输出，我们将其添加到<strong class="is hu"> HST </strong>的底部</li><li id="853a" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated">如果新输入生成的哈希输出已经在<strong class="is hu"> HST </strong>中了(<em class="jy">啊碰撞发生了！</em>)，我们稍微改变一下输入，生成一个新的哈希输出，希望是(<em class="jy">！</em>)避免碰撞</li><li id="56b8" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated">我们一直对输入稍加修改，直到找到无冲突的哈希输出</li></ul><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff mm"><img src="../Images/7034cd025196ccf0f3d90af7360b6473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ovDlFIbk9eXcJXc65hOUw.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Probing in action</figcaption></figure><p id="680a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="jy">修饰语</em> </strong>是附加在原始输入末尾的一个数字。我们通常从0开始，不断重复增加修改器1，直到我们能够找到避免冲突的<strong class="is hu">哈希输出</strong>。这个<em class="jy">修改器</em>为每个输入单独存储，因为我们想保持原始输入完整。这有助于<em class="jy">的再现性</em>——如果再次提供相同的输入，我们知道需要应用什么<em class="jy">修改器</em>来再现输出。</p><h1 id="77e9" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated"><strong class="ak"> <em class="mn">将改性剂分块储存</em> </strong></h1><p id="985a" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">正如我们在<a class="ae jo" rel="noopener" href="/coinmonks/blockchain-unboxing-the-block-598b633741b3">先前的帖子</a>中已经看到的，连锁店中的每个区块存储3个不同的哈希输出。<em class="jy">数据标识</em>、<em class="jy">先前块标识</em>和<em class="jy">当前块标识</em>。这意味着，对于链中的每个新块，我们将添加2个新的哈希输出-<em class="jy">数据ID </em>和<em class="jy">当前块ID </em>。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff mo"><img src="../Images/36070daed2bda88d06dfc0d11712c0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YFL--DHeeDcuI4gEru8Dw.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Two possible Collision points. Reminder that these Hash Outputs are written in the Hexadecimal System</figcaption></figure><p id="91c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们其实并不太在意<em class="jy">数据ID </em>中的碰撞。如果两个块有完全相同的数据，这是完全可能和允许的，那么它们将有相同的<em class="jy">数据ID </em>。很好！</p><p id="6d55" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是我们不能在当前块ID为的<em class="jy">中发生冲突，因为两个块不能有相同的<em class="jy">当前块ID </em>。所以我们需要执行<strong class="is hu"> <em class="jy">探测</em> </strong>，并且我们需要在某个地方存储<strong class="is hu"> <em class="jy">修饰符</em> </strong>。当前的块结构没有空间来存储它！</em></p><blockquote class="mp mq mr"><p id="1646" class="iq ir jy is b it iu iv iw ix iy iz ja ms jc jd je mt jg jh ji mu jk jl jm jn hm dt translated">作者注:为什么两个不同的块不能有相同的当前块ID？</p></blockquote><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff mv"><img src="../Images/20dd116748f728b580c7394e8446041e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UR8wmGd9_8QSsPonnAR5rQ.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">A modified block structure to store the probing modifier!</figcaption></figure><p id="b242" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，<strong class="is hu"> <em class="jy">修饰符</em> </strong>对于新块总是空的。如果发生冲突，我们将0放入<em class="jy">修改器</em>中，并使用<em class="jy">数据ID </em>、<em class="jy">先前块ID </em>和<em class="jy">修改器</em>作为<strong class="is hu">散列函数</strong>的输入，重新计算<em class="jy">当前块ID </em>。通过包含<em class="jy">修饰符</em>，我们有了一个不同的输入来改变<strong class="is hu">散列输出</strong>，希望这能解决冲突。然而，如果碰撞仍然存在，我们将把<em class="jy">修改器</em>的值增加到1。我们将继续增加<em class="jy">修改器</em>的值，每次增加1，直到碰撞被解决。因此<em class="jy">修改器</em>增加1，直到在块的<em class="jy">当前块ID </em>中没有<strong class="is hu">碰撞</strong>。链条现在是<strong class="is hu">防撞的</strong>！</p><h1 id="4317" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">最后</h1><p id="40b1" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">老实说，我们不需要<strong class="is hu">探测</strong>真实世界的区块链。鉴于大量可能的散列输出(~10⁷⁸可能输出)和内置于<strong class="is hu">散列函数</strong>中的智能和复杂随机性，冲突永远不会发生。我没有空间也没有数学能力来证明给你看，但这是真的！我们并不真的需要<strong class="is hu"> <em class="jy">修改器</em> </strong>来防止现实世界中的碰撞。那我为什么要提起它呢？</p><p id="e7fc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">区块链中的块还为<em class="jy">修饰符</em>留有空间，称为<strong class="is hu"><em class="jy"/></strong>，代表<strong class="is hu"> <em class="jy">数一次</em> </strong> <em class="jy"> — </em>，因为每个数都试一次！每个块都有一个<em class="jy"> Nonce </em>，大量的时间、金钱和精力都花在寻找<em class="jy"> Nonce </em>的正确值上。在下一篇文章中，为什么<em class="jy"> Nonce </em>存在，它真正服务于什么目的。到时见…</p><h1 id="7a7d" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">扣人心弦</h1><p id="c3ec" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hm dt translated">什么是<strong class="is hu">工作证明</strong>？为什么说比特币和以太坊很耗电？</p><blockquote class="mw"><p id="1cd5" class="mx my ht bd mz na nb nc nd ne nf jn ek translated">加入Coinmonks <a class="ae jo" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jo" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h2 id="d197" class="ly kf ht bd kg lz ng mb kk mc nh me ko jb ni mg ks jf nj mi kw jj nk mk la ml dt translated">另外，阅读</h2><ul class=""><li id="18c5" class="jp jq ht is b it lc ix ld jb nl jf nm jj nn jn ju jv jw jx dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/mxc-exchange-review-3af0ec1cba8c"> MXC交易所评论</a> | <a class="ae jo" href="https://blog.coincodecap.com/pionex-vs-binance" rel="noopener ugc nofollow" target="_blank"> Pionex vs币安</a> | <a class="ae jo" href="https://blog.coincodecap.com/pionex-arbitrage-bot" rel="noopener ugc nofollow" target="_blank"> Pionex套利机器人</a></li><li id="5c79" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/my-experience-with-crypto-copy-trading-d6feb2ce3ac5">我的密码交易经验</a> | <a class="ae jo" rel="noopener" href="/coinmonks/coinbase-review-6ef4e0f56064">比特币基地评论</a></li><li id="f430" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated"><a class="ae jo" href="https://blog.coincodecap.com/coinflex-review" rel="noopener ugc nofollow" target="_blank"> CoinFLEX评论</a> | <a class="ae jo" href="https://blog.coincodecap.com/aex-exchange-review" rel="noopener ugc nofollow" target="_blank"> AEX交易所评论</a> | <a class="ae jo" href="https://blog.coincodecap.com/upbit-review" rel="noopener ugc nofollow" target="_blank"> UPbit评论</a></li><li id="5641" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated"><a class="ae jo" href="https://blog.coincodecap.com/ascendex-margin-trading" rel="noopener ugc nofollow" target="_blank"> AscendEx保证金交易</a> | <a class="ae jo" href="https://blog.coincodecap.com/bitfinex-staking" rel="noopener ugc nofollow" target="_blank"> Bitfinex赌注</a> | <a class="ae jo" href="https://blog.coincodecap.com/bitflyer-review" rel="noopener ugc nofollow" target="_blank"> bitFlyer点评</a></li><li id="a6cc" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated"><a class="ae jo" href="https://blog.coincodecap.com/sparrow-exchange-review" rel="noopener ugc nofollow" target="_blank">麻雀交换评论</a> | <a class="ae jo" href="https://blog.coincodecap.com/nash-exchange-review" rel="noopener ugc nofollow" target="_blank">纳什交换评论</a></li><li id="3b8a" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated"><a class="ae jo" href="https://blog.coincodecap.com/uphold-card-review" rel="noopener ugc nofollow" target="_blank">支持卡审核</a> | <a class="ae jo" href="https://blog.coincodecap.com/trust-wallet-vs-metamask" rel="noopener ugc nofollow" target="_blank">信任钱包vs元掩码</a></li><li id="872c" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated"><a class="ae jo" href="https://blog.coincodecap.com/exness-review" rel="noopener ugc nofollow" target="_blank"> Exness评测</a>|<a class="ae jo" href="https://blog.coincodecap.com/bingbon-vs-bitget-vs-moonxbt" rel="noopener ugc nofollow" target="_blank">moon xbt Vs bit get Vs Bingbon</a></li><li id="0419" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated"><a class="ae jo" href="https://blog.coincodecap.com/passive-income-crypto-lending" rel="noopener ugc nofollow" target="_blank">如何开始通过加密贷款赚取被动收入</a></li><li id="11c6" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/cryptocurrency-savings-accounts-be3bc0feffbf">加密货币储蓄账户</a> | <a class="ae jo" href="https://blog.coincodecap.com/best-crypto-trading-bots" rel="noopener ugc nofollow" target="_blank">加密交易机器人</a></li><li id="1d5d" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/bigone-exchange-review-64705d85a1d4"> BigONE交易所评论</a> | <a class="ae jo" href="https://blog.coincodecap.com/cex-io-review" rel="noopener ugc nofollow" target="_blank"> CEX。IO审查</a> | <a class="ae jo" rel="noopener" href="/coinmonks/swapzone-review-crypto-exchange-data-aggregator-e0ad78e55ed7"> Swapzone审查</a></li><li id="ac39" class="jp jq ht is b it jz ix ka jb kb jf kc jj kd jn ju jv jw jx dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/bitcoin-margin-trading-exchange-bcbfcbf7b8e3">最佳比特币保证金交易</a> | <a class="ae jo" href="https://blog.coincodecap.com/bityard-margin-trading" rel="noopener ugc nofollow" target="_blank">比特币保证金交易</a></li></ul></div></div>    
</body>
</html>