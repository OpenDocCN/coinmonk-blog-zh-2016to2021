<html>
<head>
<title>How smart contracts enable best security for game scores</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合同如何为游戏分数提供最佳安全性</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/blockscores-45e0c062de5e?source=collection_archive---------3-----------------------#2018-05-26">https://medium.com/coinmonks/blockscores-45e0c062de5e?source=collection_archive---------3-----------------------#2018-05-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="4348" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最近的技术趋势是区块链。自从第一次接触智能合约以来，一直有一个问题:“很好，但现在，为了什么？”一方面，区块链的好处，如防篡改和透明，非常有用。但是数据库会更便宜，现有的知识更先进。</p><p id="9d3a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">抛开金融科技的明显用例(如贷款、土地登记、身份识别),未来还有哪些应用可以享受这些好处？虚拟现实等最新创新首次出现在游戏领域。现在，这部分人也能从区块链中获利。</p><h1 id="0bc9" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">想法</h1><p id="339c" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">标准区块链不适合交互式游戏，因为它的延迟和游戏物品或虚拟商品的交易已经在许多分布式应用程序中存在(DApp)。所以我关注的是游戏链的末端:结果或排行榜。</p><blockquote class="kr"><p id="19f9" class="ks kt ht bd ku kv kw kx ky kz la jn ek translated">使用以太坊区块链上的智能合约来托管分散式排行榜，以跟踪分数、排名和多签名安全性</p></blockquote><figure class="lc ld le lf lg lh fe ff paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="fe ff lb"><img src="../Images/191917daf971f885ac33e3f7768909d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n3DB86-Msb4mw4ZVUPVshw.png"/></div></div></figure></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><h1 id="30c7" class="jo jp ht bd jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl dt translated">挑战</h1><h2 id="37af" class="ma jp ht bd jq mb mc md ju me mf mg jy jb mh mi kc jf mj mk kg jj ml mm kk mn dt translated"><strong class="ak">可用性</strong></h2><p id="f20d" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">采用区块链的缺点是可用性不足。它的互动并不那么直接。像钱包、私人钥匙和DApp浏览器这样的术语吓跑了那些拥有简单用户界面和单点登录等简单功能的用户。<br/>block scores的第一个原型始于<a class="ae mo" href="https://github.com/Rello/BlockScores/blob/master/nonWallet/blockscores.sol" rel="noopener ugc nofollow" target="_blank">的非钱包版本</a>。所有交易都是从一个有硬编码密码的地址签署的。但这肯定只能在本地测试网上使用。<br/>真实条件下，web3注入器如<a class="ae mo" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> Metamask </a>、<a class="ae mo" href="https://www.toshi.org/" rel="noopener ugc nofollow" target="_blank"> Toshi </a>、<a class="ae mo" href="https://github.com/ethereum/mist" rel="noopener ugc nofollow" target="_blank"> MIST </a>或<a class="ae mo" href="https://www.cipherbrowser.com/" rel="noopener ugc nofollow" target="_blank">Cipher</a>(iOS；包括testnet)是唯一的出路。除非您想运行自己的区块链节点，包括web3 node.js实现。</p><h2 id="5e0d" class="ma jp ht bd jq mb mc md ju me mf mg jy jb mh mi kc jf mj mk kg jj ml mm kk mn dt translated"><strong class="ak">令牌或以太(ETH) </strong></h2><p id="357a" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">ico和tokens是目前的流行词汇。但我们的目标是通过使用基于ETH的标准交易，使排行榜尽可能简单。</p><h2 id="98cd" class="ma jp ht bd jq mb mc md ju me mf mg jy jb mh mi kc jf mj mk kg jj ml mm kk mn dt translated"><strong class="ak">成本</strong></h2><p id="4fe3" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">在mainnet上部署智能合同并不是免费的。举个例子:BlockScores契约的第一个版本仅为其部署的0.1 ETH。<br/>但交易成本也需要尽可能低。因此，合同存储器及其功能必须以节约成本的方式设计。一个例子:存储字符串在设计上可能很简单。但是相比byte32(需要用<em class="mp"> web3.fromAscii() </em>和<em class="mp">转换)。(T4)它更贵。最终用户在使用您的应用程序时，会注意到气体使用量的差异。</em></p><h2 id="a911" class="ma jp ht bd jq mb mc md ju me mf mg jy jb mh mi kc jf mj mk kg jj ml mm kk mn dt translated"><strong class="ak">特色vs简单</strong></h2><p id="e072" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">DApp的功能应该丰富到什么程度？排行榜的一次性创建？还是应该让用户接受复杂的用户界面？包括像自定义CSS样式这样的个性化？玩家可以改名甚至添加头像吗？<br/>我的目标是减少用户界面，使其适合移动设备上的单页页面。另一个选择是在分布式存储上发布DApp，比如IPFS。在这种情况下，您还需要质疑使用jQuery这样的库来减少内存占用。</p></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><h1 id="55ec" class="jo jp ht bd jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl dt translated">智能合同</h1><p id="f36e" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">在下面的部分中，我想描述我的智能合同的基本结构。这可以托管许多独立排行榜。<br/>代码可以在这里找到:<a class="ae mo" href="https://github.com/Rello/BlockScores/blob/master/solidity/BlockScores_v0.1.sol" rel="noopener ugc nofollow" target="_blank">https://github . com/Rello/block scores/blob/master/solidity/block scores _ v 0.1 . sol</a></p><h2 id="d18f" class="ma jp ht bd jq mb mc md ju me mf mg jy jb mh mi kc jf mj mk kg jj ml mm kk mn dt translated"><strong class="ak">表头</strong></h2><p id="8cda" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">BlockScores的智能合约建立在两种数据结构之上。一个映射将不同的玩家分配到一个游戏中，并通过玩家的公共地址来识别每个玩家。它有两个计分器。一个<strong class="is hu"> <em class="mp">未确认</em> </strong>和最终(确认)分数。另外，每个玩家需要有一个<strong class="is hu"> <em class="mp"> isActive </em> </strong>指示器。原因是，不可能删除协定存储中的映射。因此，应用程序逻辑必须确定记录是否是活动的。</p><pre class="mq mr ms mt fq mu mv mw mx aw my dt"><span id="0ef2" class="ma jp ht mv b fv mz na l nb nc"><strong class="mv hu">struct </strong>Player {<br/>    <strong class="mv hu">bytes32  </strong>playerName;<br/>    <strong class="mv hu">address </strong>playerAddress;<br/>    <strong class="mv hu">uint  </strong>score;<br/>    <strong class="mv hu">uint  </strong>score_unconfirmed;<br/>    <strong class="mv hu">uint   </strong>isActive;<br/>}<br/><strong class="mv hu">struct </strong>Game {<br/>    <strong class="mv hu">bytes32  </strong>gameName;<br/>    <strong class="mv hu">string  </strong>gameDescription;<br/>    <strong class="mv hu">uint   </strong>numPlayers;<br/>    <strong class="mv hu">address </strong>gameOwner;<br/>    <strong class="mv hu">mapping </strong>(<strong class="mv hu">uint </strong>=&gt; Player) players;<br/>}<br/><strong class="mv hu">mapping </strong>(<strong class="mv hu">bytes32 </strong>=&gt; Game) games;</span></pre><h2 id="5146" class="ma jp ht bd jq mb mc md ju me mf mg jy jb mh mi kc jf mj mk kg jj ml mm kk mn dt translated"><strong class="ak">板卡功能</strong></h2><p id="7ef8" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">通过根据电路板的标题和创建者的地址计算的散列来识别电路板。电路板散列是前端访问其数据的URL参数。此URL只有创建者知道。为了以后的维护目的，板的创建者也是板的唯一所有者。</p><pre class="mq mr ms mt fq mu mv mw mx aw my dt"><span id="20ca" class="ma jp ht mv b fv mz na l nb nc"><strong class="mv hu">function </strong>addNewGame(<strong class="mv hu">bytes32 </strong>name, <strong class="mv hu">string </strong>gameDescription) <strong class="mv hu">public returns</strong>(<strong class="mv hu">bytes32 </strong>gameHash){<br/>    gameHash = keccak256(name, msg.sender);<br/>    numGames++;<br/>    games[gameHash] = Game(name, gameDescription, 0, msg.sender);<br/>    emit newGameCreated(gameHash, name);<br/>}</span></pre><p id="9669" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">基于板卡哈希，可以通过<strong class="is hu"> <em class="mp">常量</em> </strong>函数调用来检索元数据。<strong class="is hu"> <em class="mp">常量</em> </strong>在坚固性上意味着它是非事务性的，不消耗任何气体。</p><pre class="mq mr ms mt fq mu mv mw mx aw my dt"><span id="9a9a" class="ma jp ht mv b fv mz na l nb nc"><strong class="mv hu">function </strong>getGameByHash(<strong class="mv hu">bytes32 </strong>gameHash) <strong class="mv hu">constant public returns</strong>(<strong class="mv hu">bytes32</strong>,<strong class="mv hu">string</strong>,<strong class="mv hu">uint</strong>){<br/>    <strong class="mv hu">return </strong>(games[gameHash].gameName, games[gameHash].gameDescription, games[gameHash].numPlayers);<br/>}</span></pre><p id="df6f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有更多的功能来提供最低程度的灵活性。他们可用游戏维护作为例子。</p><h2 id="c921" class="ma jp ht bd jq mb mc md ju me mf mg jy jb mh mi kc jf mj mk kg jj ml mm kk mn dt translated">播放器功能</h2><p id="0042" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">玩家自己添加，合同将这些链接到他们的地址。在这种情况下，通过存储分配来访问board对象。此外，该功能每次都会增加玩家数量。这是强制性的，因为存储映射在创建期间保存所有可能的组合。因此，该函数需要知道哪些已经被使用。</p><pre class="mq mr ms mt fq mu mv mw mx aw my dt"><span id="58d1" class="ma jp ht mv b fv mz na l nb nc"><strong class="mv hu">function </strong>addPlayerToGame(<strong class="mv hu">bytes32 </strong>gameHash, <strong class="mv hu">bytes32 </strong>playerName) <strong class="mv hu">public returns </strong>(<strong class="mv hu">bool</strong>) {<br/>    Game <strong class="mv hu">storage </strong>g = games[gameHash];<br/>    <strong class="mv hu">uint </strong>newPlayerID = g.numPlayers++;<br/>    g.players[newPlayerID] = Player(playerName, msg.sender,0,0,1);<br/>    <strong class="mv hu">return true</strong>;<br/>}</span></pre><p id="b35a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在以后的UI中，玩家的数量需要循环递增。然后每个<strong class="is hu"> <em class="mp">活跃的</em> </strong>玩家一次返回一个。由于solidity不能返回数组，web3必须调用这个函数<strong class="is hu"><em class="mp">num players</em></strong>-次。</p><pre class="mq mr ms mt fq mu mv mw mx aw my dt"><span id="f161" class="ma jp ht mv b fv mz na l nb nc"><strong class="mv hu">function </strong>getPlayerByGame(<strong class="mv hu">bytes32 </strong>gameHash, <strong class="mv hu">uint8 </strong>playerID) <strong class="mv hu">constant public returns </strong>(<strong class="mv hu">bytes32</strong>, <strong class="mv hu">uint</strong>, <strong class="mv hu">uint</strong>){<br/>    Player <strong class="mv hu">storage </strong>p = games[gameHash].players[playerID];<br/>    require(p.isActive == 1);<br/>    <strong class="mv hu">return </strong>(p.playerName, p.score, p.score_unconfirmed);<br/>}</span></pre><h2 id="89c6" class="ma jp ht bd jq mb mc md ju me mf mg jy jb mh mi kc jf mj mk kg jj ml mm kk mn dt translated">得分函数</h2><p id="6044" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">任何知道排行榜哈希的用户都可以添加分数。这个函数必须接收一个有效的玩家名字。出于安全原因，玩家的地址不可用。<br/>当玩家处于活动状态<strong class="is hu"> <em class="mp"> </em> </strong>并且是棋盘的一部分时，该功能存储一个未确认的分数。</p><pre class="mq mr ms mt fq mu mv mw mx aw my dt"><span id="0d7e" class="ma jp ht mv b fv mz na l nb nc"><strong class="mv hu">function </strong>addGameScore(<strong class="mv hu">bytes32 </strong>gameHash, <strong class="mv hu">bytes32 </strong>playerName, <strong class="mv hu">uint </strong>score) <strong class="mv hu">public returns </strong>(<strong class="mv hu">bool</strong>){<br/>    <strong class="mv hu">uint8 </strong>playerID = getPlayerId (gameHash, playerName, 0);<br/>    <strong class="mv hu">if </strong>(playerID &lt; 255 ) {<br/>        games[gameHash].players[playerID].score_unconfirmed = score;<br/>        <strong class="mv hu">return true</strong>;<br/>    } <strong class="mv hu">else </strong>{<br/>        <strong class="mv hu">return false</strong>;<br/>    }<br/>}</span></pre><p id="254c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">此功能将未确认的分数添加到决赛分数存储中。要添加4眼层，玩家不能确认自己的分数。确认只能由同一个棋盘的另一个<strong class="is hu"> <em class="mp">有效</em> </strong>玩家执行。</p><pre class="mq mr ms mt fq mu mv mw mx aw my dt"><span id="3dfd" class="ma jp ht mv b fv mz na l nb nc"><strong class="mv hu">function </strong>confirmGameScore(<strong class="mv hu">bytes32 </strong>gameHash, <strong class="mv hu">bytes32 </strong>playerName) <strong class="mv hu">public returns </strong>(<strong class="mv hu">bool</strong>){<br/>    <strong class="mv hu">uint8 </strong>playerID = getPlayerId (gameHash, playerName, 0);<br/>    <strong class="mv hu">uint8 </strong>confirmerID = getPlayerId (gameHash, <strong class="mv hu">""</strong>, msg.sender);<br/>    require(playerID &lt; 255); <em class="mp">// player needs to be active<br/>    </em>require(confirmerID &lt; 255); <em class="mp">// confirmer needs to be active<br/>    </em>require(games[gameHash].players[playerID].playerAddress != msg.sender); <em class="mp">//confirm only other players<br/>    </em>games[gameHash].players[playerID].score += games[gameHash].players[playerID].score_unconfirmed;<br/>    games[gameHash].players[playerID].score_unconfirmed = 0;<br/>    <strong class="mv hu">return true</strong>;<br/>}</span></pre><p id="6cf6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">完整的可靠性合同可在GitHub上获得。</p></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><h1 id="6a75" class="jo jp ht bd jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl dt translated">概念证明</h1><p id="0fa3" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">基本的UI/UX实现使用纯HTML/JS来创建响应性布局。它使用一个简单的表格显示球员，总数和未决分数。对于每个玩家的一排，可以通过按钮进行交互。</p><p id="22ed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您想测试工作PoC，请查看此处的<a class="ae mo" href="http://blockscores.com/services/demo" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="d30f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我将在以后的文章中分享我在web3实现方面学到的经验。</p><figure class="mq mr ms mt fq lh fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/bd5c8099d16de9c9d6a32ac40ca4bcc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*6othk4gTfiEn0XzfIN7lqA.png"/></div></figure><h1 id="8a3e" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">观点</h1><p id="5268" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated"><a class="ae mo" href="http://blockscores.com/" rel="noopener ugc nofollow" target="_blank"> BlockScores </a>托管智能合约和各种设备和平台的用户界面。这些合同允许任何用户创建和管理排行榜。<br/>目前，Rospen上已经有了<a class="ae mo" href="http://blockscores.com/services/demo" rel="noopener ugc nofollow" target="_blank">概念验证</a>。最终版本将很快发布，届时UI设计完成。下一个开发sprints计划交付公共API或BlockScores集成。例如，私有服务器中的集成应用程序，如<a class="ae mo" href="https://nextcloud.com/" rel="noopener ugc nofollow" target="_blank"> Nextcloud </a>或<a class="ae mo" href="https://owncloud.org/" rel="noopener ugc nofollow" target="_blank"> ownCloud </a>可以提供集成的排行榜管理。</p></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><p id="7aac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你喜欢这个主意吗？如果是的话，下面鼓掌或者在 <a class="ae mo" href="https://twitter.com/BlockScores" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu">推特</strong> </a> <strong class="is hu">上连线。<br/>这是我基于我的第一个DApp实现的第一篇文章。任何反馈都会帮助我提高。谢谢你。</strong></p></div></div>    
</body>
</html>