<html>
<head>
<title>7 Security Vulnerabilities in Ethereum Smart Contracts that can now be easily avoided!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊智能合约中现在可以轻松避免的7个安全漏洞！</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/8-security-vulnerabilities-in-ethereum-smart-contracts-that-can-now-be-easily-avoided-dcb7de37a64?source=collection_archive---------1-----------------------#2020-07-07">https://medium.com/coinmonks/8-security-vulnerabilities-in-ethereum-smart-contracts-that-can-now-be-easily-avoided-dcb7de37a64?source=collection_archive---------1-----------------------#2020-07-07</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="4fe0" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">可通过可靠性更新避免的应用级安全漏洞</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/cac5bddcf9bab94e7191bc7ab06bd4a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jiA0wP3eehdJcSFoBrgmWA.jpeg"/></div></div></figure><p id="1621" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">由于以太坊智能合约主要应用于电子商务应用，我们认为这些应用更容易受到攻击。在这些智能合约中，我们主要关注于识别智能合约的程序员和用户必须避免的漏洞。这篇文章旨在解释这七个应用程序级安全漏洞及其早期采用的预防方法。我们主要关注的是最新的Solidity v0.6.0版本，它修复了一些漏洞。</p><h2 id="bf30" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">1.可重入</h2><p id="f7b6" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">可重入攻击可以耗尽智能协定的以太，可以帮助入侵协定代码。当对另一个不受信任的协定执行外部调用函数，并且攻击者获得了对该不受信任的协定的控制时，他们可以对原始函数进行递归调用，意外地重复本来不会运行的事务，并最终耗尽所有gas。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff lq"><img src="../Images/b1166e7938c3ba5a59c8af721d1605de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJKLkAzodkFZr2qLgGPC2Q.png"/></div></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Figure 1. Reentrancy example — Simple DAO Attack</figcaption></figure><p id="660d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">DAO攻击中的可重入性漏洞利用(如图1所示)分四步完成，</p><ul class=""><li id="3b03" class="lv lw ht jw b jx jy ka kb kd lx kh ly kl lz kp ma mb mc md dt translated"><strong class="jw hu">第一步:</strong><code class="eh me mf mg mh b">Attacker</code>通过调用<code class="eh me mf mg mh b">Victim</code>的<code class="eh me mf mg mh b">Withdraw </code>函数发起交易；</li><li id="13a6" class="lv lw ht jw b jx mi ka mj kd mk kh ml kl mm kp ma mb mc md dt translated"><strong class="jw hu">第二步:</strong><code class="eh me mf mg mh b">Victim</code>转账并调用<code class="eh me mf mg mh b">Attacker</code>的<code class="eh me mf mg mh b">fallback</code>函数；</li><li id="eec7" class="lv lw ht jw b jx mi ka mj kd mk kh ml kl mm kp ma mb mc md dt translated"><strong class="jw hu">第三步:</strong><code class="eh me mf mg mh b">fallback</code>函数再次递归调用<code class="eh me mf mg mh b">withdraw</code>函数，即重入；</li><li id="c163" class="lv lw ht jw b jx mi ka mj kd mk kh ml kl mm kp ma mb mc md dt translated"><strong class="jw hu">步骤4: </strong>在一个迭代范围内，额外的以太网将被多次传输到<code class="eh me mf mg mh b">Attacker</code>。</li></ul><h2 id="e3cd" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">1.1早先建议的避免此漏洞的最佳实践</h2><p id="b48e" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">通过确保在通过外部调用将以太送出契约之前提交状态改变逻辑，可以防止重入漏洞。将对未知地址执行外部调用的任何逻辑放在程序执行的最后一个操作中也是一个很好的编码实践。这就是所谓的检查-效果-交互模式。另一种技术是通过添加一个在代码执行期间锁定契约的状态变量来使用互斥体，从而防止可重入的函数调用。</p><h2 id="cf93" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">2.呼唤未知</h2><p id="3ac9" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">当函数调用或以太网传输意外调用被呼叫者/接收者的回退函数时。导致这种情况的一些基本的可靠性语言是:</p><ul class=""><li id="4c8d" class="lv lw ht jw b jx jy ka kb kd lx kh ly kl lz kp ma mb mc md dt translated"><code class="eh me mf mg mh b">call</code>用于调用一个函数或传送以太</li><li id="a720" class="lv lw ht jw b jx mi ka mj kd mk kh ml kl mm kp ma mb mc md dt translated"><code class="eh me mf mg mh b">send</code>，用于将乙醚从正在运行的合约转移到其他合约</li><li id="9695" class="lv lw ht jw b jx mi ka mj kd mk kh ml kl mm kp ma mb mc md dt translated"><code class="eh me mf mg mh b">delegatecall</code>，用于调用一个函数或调用方环境中的以太</li><li id="8433" class="lv lw ht jw b jx mi ka mj kd mk kh ml kl mm kp ma mb mc md dt translated">直接调用(参见清单1)</li></ul><p id="ec1b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果被调用函数的签名与任何现有函数都不匹配，那么这个调用将导致调用接收方的<code class="eh me mf mg mh b">fallback</code>函数。</p><h2 id="dc26" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">2.1早先建议的避免此漏洞的最佳实践</h2><p id="c155" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">Solidity提供了通过使用关键字library来实现库契约。这些库契约是无状态的，非自毁的。强制库成为无状态减少了攻击者直接修改库的状态以影响依赖于库代码的契约的攻击。因此，当使用call、DelegateCall时，可以通过构建无状态库来防止可能改变受害者协定状态的未知调用攻击。</p><h2 id="3379" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">减少可重入性和调用未知漏洞的可靠性版本更新</h2><p id="1b6c" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">Solidity V0.6.0将早期<code class="eh me mf mg mh b">fallback</code>函数背后的逻辑分成两个不同的函数，一个使用<code class="eh me mf mg mh b">fallback</code>关键字，另一个使用<code class="eh me mf mg mh b">receive</code>关键字定义接收以太函数。receive ether函数是隐式的<code class="eh me mf mg mh b">payable</code>，只要调用数据为空就会被调用。然而，新的fallback函数，现在带有关键字<code class="eh me mf mg mh b">fallback</code>，在没有其他函数匹配时被调用。这个<code class="eh me mf mg mh b">fallback</code>功能可能是也可能不是<code class="eh me mf mg mh b">payable</code>。如果不是<code class="eh me mf mg mh b">payable</code>，则不匹配任何其他发送值的函数的事务将恢复。</p><p id="4376" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">因此，这个可靠性更新将解决当调用外部智能契约的<code class="eh me mf mg mh b">fallback</code>函数时意外代码被执行的问题。</p></div><div class="ab cl mn mo hb mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hm hn ho hp hq"><h2 id="2cfd" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">3.错误处理的异常</h2><p id="6d2e" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">在许多情况下，Solidity会出现异常，但处理这些异常的方式并不总是相同的。异常处理基于契约之间的交互。这使得契约容易受到攻击，因为如果这些异常没有被正确处理并且事务被恢复，程序员将不会意识到任何以太丢失。</p><pre class="jj jk jl jm fq mu mh mv mw aw mx dt"><span id="fbfd" class="kq kr ht mh b fv my mz l na nb">contract Alice { <br/>    function ping(uint) {<br/>        returns (uint)}}<br/>contract Bob { <br/>    uint x=0;<br/>    function pong(Alice c){<br/>        x=1; <br/>        c.ping(42); <br/>        x=2; <br/>        } }</span></pre><p id="8505" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在上面的代码中，契约<code class="eh me mf mg mh b">Bob</code>执行后变量<code class="eh me mf mg mh b">x</code>的值根据函数调用的方法而变化。如果使用直接调用来调用合同<code class="eh me mf mg mh b">Alice</code>的ping函数，那么<code class="eh me mf mg mh b">x </code>的值将为0。然而，如果使用Solidity的内置函数调用来调用同一个函数，那么<code class="eh me mf mg mh b">x</code>的值将是2。此外，在例外情况下，如果没有指定边界，那么所有可用的气体都将丢失。</p><h2 id="2880" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">3.1早先建议的避免此漏洞的最佳实践</h2><p id="9880" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">避免这种漏洞的一种技术是始终使用一种外部调用方法。然而，这不是理想的预防技术，因为外部呼叫的不同变化可能是必要的。因此，该漏洞需要更新Solidity语言，以使抛出异常的后果一致。</p><h2 id="26e5" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">4.外部调用漏洞造成拒绝服务</h2><p id="291f" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">当控制流转移到外部协定时，调用方协定的执行可能会意外或故意失败，这可能会导致调用方协定中出现DoS状态。当事务由于外部调用失败而被还原时，调用方协定可能处于DoS状态，或者被调用方协定故意使事务被还原以中断调用方协定的执行。</p><pre class="jj jk jl jm fq mu mh mv mw aw mx dt"><span id="30fc" class="kq kr ht mh b fv my mz l na nb">contract HYIP {<br/>    Lenders[] private lender;<br/>    function sendPayment() {<br/>        for(uint i = lender.length; i−− &gt; 0; ) {<br/>            uint payment=(lenders[i].amount*/1000;</span><span id="a9dc" class="kq kr ht mh b fv nc mz l na nb">if(!lenders[i].addr.send(payment)) throw;<br/>            }<br/>    }<br/>}<br/> contract AttackerContract {<br/>    bool private attack = true;<br/>    function() payable {<br/>        if (attack) throw; // callee fails the caller execution deliberately<br/>    }<br/>    function stopAttack() {<br/>        if(msg.sender == owner) attack = false;<br/>    }<br/> }</span></pre><h2 id="1f2c" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">4.1早先建议的避免此漏洞的最佳实践</h2><p id="0f99" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">此漏洞的存在是因为对条件语句和迭代语句的异常处理不足。将由被调用方协定发起的任何外部调用放入单独的事务中，有助于减少此漏洞造成的损害。使用以下模式隔离语句有助于避免此漏洞:</p><ul class=""><li id="c601" class="lv lw ht jw b jx jy ka kb kd lx kh ly kl lz kp ma mb mc md dt translated">条件中有外部函数调用的<code class="eh me mf mg mh b">if </code>语句，语句体中有<code class="eh me mf mg mh b">throw</code>或<code class="eh me mf mg mh b">revert</code>；</li><li id="c4a0" class="lv lw ht jw b jx mi ka mj kd mk kh ml kl mm kp ma mb mc md dt translated">条件中带有外部函数调用的<code class="eh me mf mg mh b">for</code>或<code class="eh me mf mg mh b">if</code>语句。</li></ul><h2 id="7d07" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">Solidity版本更新，可缓解处理不当的异常和拒绝服务漏洞</h2><p id="ea65" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">Solidity V0.5.3支持使用<code class="eh me mf mg mh b">try</code> / <code class="eh me mf mg mh b">catch</code>语句和以下便利函数捕获异常:</p><ul class=""><li id="5d95" class="lv lw ht jw b jx jy ka kb kd lx kh ly kl lz kp ma mb mc md dt translated"><code class="eh me mf mg mh b">assert</code>函数应该只用于测试内部错误，以及检查不变量，因为<code class="eh me mf mg mh b">assert</code>风格的异常消耗了所有可用于调用的gas。</li><li id="2f1a" class="lv lw ht jw b jx mi ka mj kd mk kh ml kl mm kp ma mb mc md dt translated"><code class="eh me mf mg mh b">require</code>函数应用于确保在执行前无法检测到的有效条件。</li><li id="8659" class="lv lw ht jw b jx mi ka mj kd mk kh ml kl mm kp ma mb mc md dt translated"><code class="eh me mf mg mh b">revert</code>函数是从其他代码块中触发异常的另一种方式，以标记错误并恢复当前调用。</li></ul></div><div class="ab cl mn mo hb mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hm hn ho hp hq"><h2 id="afdd" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">5.气体耗尽异常</h2><p id="95fb" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">在合同之间转移乙醚时，基元函数send可能会导致意外的缺气异常。有一个预先固定的gas单元可用于允许执行一组有限的字节码指令，如果没有足够的gas单元可用，调用函数将会以gas-out异常结束。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff nd"><img src="../Images/9e1b476b9aff1dd6d1c12672fda7823a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BEcc-tSNQveeuBBfw6iO1Q.png"/></div></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Figure 2. Out-of-Gas Exception example— King of Ether Attack</figcaption></figure><h2 id="12a9" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">5.1早先建议的避免此漏洞的最佳实践</h2><p id="9594" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">可以通过使用<code class="eh me mf mg mh b">Transfer</code>函数而不是<code class="eh me mf mg mh b">Send</code>来防止此漏洞，因为如果外部事务恢复，前者将恢复本地事务。但是，如果需要使用<code class="eh me mf mg mh b">Send</code>函数，则需要监控该函数的返回值。另一种技术是采用撤销模式，其中要求每个用户调用一个独立的函数来管理其他事务，并且不影响合同执行的其余部分。因此，使得事务管理独立于失败的<code class="eh me mf mg mh b">Send</code>事务的后果。</p><h2 id="7361" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">Solidity版本更新缓解了缺气漏洞</h2><p id="777f" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">在Solidity V0.5.0之前，如果一个契约收到Ether，则执行<code class="eh me mf mg mh b">fallback</code>函数，如果它没有<code class="eh me mf mg mh b">fallback</code>函数，则Ether将被拒绝并抛出异常。但是，在执行<code class="eh me mf mg mh b">fallback</code>功能期间，合同当时只能使用2300气。这个气限不足以修改<code class="eh me mf mg mh b">storage</code>。这种“汽油津贴”限制解决了汽油耗尽的问题，但效率不高。</p><p id="4a55" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">随着V0.6.0的新Solidity更新，<code class="eh me mf mg mh b">fallback</code>函数和<code class="eh me mf mg mh b">recieve</code>函数的划分在更大程度上解决了缺气漏洞，因为在<code class="eh me mf mg mh b">recieve</code>函数中不能执行任何昂贵的代码，因此，使程序员能够分析他们在交易期间将花费的气体量。</p></div><div class="ab cl mn mo hb mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hm hn ho hp hq"><h2 id="3f2b" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">6.类型转换</h2><p id="1276" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">Solidity编译器可以检测一些类型错误的事实可能会使程序员认为它也检查被调用的契约的地址，并且由调用者函数声明的接口与被调用者的实际接口相匹配。在存在这种类型不匹配错误的情况下执行协定不会在运行时引发异常，并且调用方不知道在运行时导致三种不同情况的错误:</p><ul class=""><li id="b288" class="lv lw ht jw b jx jy ka kb kd lx kh ly kl lz kp ma mb mc md dt translated">被调用方函数的协定地址不正确，调用返回时不执行任何代码，</li><li id="0ee6" class="lv lw ht jw b jx mi ka mj kd mk kh ml kl mm kp ma mb mc md dt translated">被调用函数的联系地址与任何其他函数的签名匹配，则执行该函数</li><li id="33b7" class="lv lw ht jw b jx mi ka mj kd mk kh ml kl mm kp ma mb mc md dt translated">被调用函数的联系地址与任何函数的签名都不匹配，则执行其回退。</li></ul><h2 id="f0dd" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">6.1早先建议的避免此漏洞的最佳实践</h2><p id="009e" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">为了防止恶意契约的类型转换，可以使用关键字<code class="eh me mf mg mh b">new</code>。这样，如果不修改协定，就无法更改被引用协定的实例，因为它是在部署时创建的。另一种技术是在契约中硬编码任何外部契约<code class="eh me mf mg mh b">address</code>,以避免恶意契约被引用。</p><h2 id="5635" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">缓解类型转换漏洞的可靠性版本更新</h2><p id="700d" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">从<a class="ae ne" href="https://solidity.readthedocs.io/en/v0.5.3/050-breaking-changes.html?highlight=field%20modifiers" rel="noopener ugc nofollow" target="_blank"> Solidity V0.5.3 </a>开始，合同类型不包括<code class="eh me mf mg mh b">address</code>成员。因此，在使用<code class="eh me mf mg mh b">address</code>成员之前，有必要显式地将契约类型的值转换为地址。例如:如果<code class="eh me mf mg mh b">c</code>是合同，将<code class="eh me mf mg mh b">c.transfer(...)</code>改为<code class="eh me mf mg mh b">address(c).transfer(...)</code>，将<code class="eh me mf mg mh b">c.balance</code>改为<code class="eh me mf mg mh b">address(c).balance</code>。</p><p id="bed9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">此外，Solidity V0.5.3不允许不相关的合同类型之间的显式转换。合同现在只能转换到其基础。</p><p id="2d8e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh me mf mg mh b">address</code>型分为<code class="eh me mf mg mh b">address</code>和<code class="eh me mf mg mh b">address payable</code>，其中只有<code class="eh me mf mg mh b">address payable</code>提供<code class="eh me mf mg mh b">transfer</code>功能。一个<code class="eh me mf mg mh b">address payable</code>可以直接转换成一个<code class="eh me mf mg mh b">address</code>，但是不允许反过来。</p></div><div class="ab cl mn mo hb mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hm hn ho hp hq"><h2 id="2994" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">7.弱场修改器</h2><p id="c2f6" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">智能合约中的字段可以标记为公共或私有。但是，这些属性不足以保护字段的值。这是因为Solidity中的默认访问修饰符afield是public。每当一个字段的值被改变时，该改变被发布在BT链上，并且攻击者有可能通过先前的散列和新的事务散列来推断改变的值。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff nf"><img src="../Images/95b47c736cb91a994d999c035bb8fd20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IACiFLxj0kaBCZyppD6TRg.png"/></div></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Figure 4. Weak Field Modifiers example — Odd/Even Game</figcaption></figure><h2 id="ee0f" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">7.1早先建议的避免此漏洞的最佳实践</h2><p id="4cc8" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">为了避免这个智能契约的漏洞，对函数使用<code class="eh me mf mg mh b"> internal </code>修饰符，而不是使用<code class="eh me mf mg mh b">public</code>修饰符。</p><h2 id="9312" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">缓解弱场修改器漏洞的可靠性版本更新</h2><p id="0b83" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">该漏洞仍然对智能合约中包含的敏感数据构成威胁。但是，0.5.3的solidity版本更新使得对函数可见性的处理比以前好了很多。从这个版本开始，显式函数可见性是强制性的，这可以通过将<code class="eh me mf mg mh b">public</code>添加到每个函数和构造函数中，将<code class="eh me mf mg mh b">external</code>添加到每个尚未指定其可见性的<code class="eh me mf mg mh b"> fallback</code>或接口函数中来实现。</p><p id="e8ea" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">从此次更新开始，struct、array或mapping类型的所有变量的显式数据位置也是强制性的，这适用于函数参数和返回变量。例如，将<code class="eh me mf mg mh b">uint[] x = m_x</code>更改为<code class="eh me mf mg mh b">uint[] storage x = m_x</code>，将<code class="eh me mf mg mh b">function f(uint[][] x)</code>更改为<code class="eh me mf mg mh b">function f(uint[][] memory x)</code>，其中<code class="eh me mf mg mh b">memory</code>是数据位置，可以相应地替换为<code class="eh me mf mg mh b">storage</code>或<code class="eh me mf mg mh b">calldata</code>。注意<code class="eh me mf mg mh b">external</code>函数需要数据位置为<code class="eh me mf mg mh b">calldata</code>的参数。</p></div><div class="ab cl mn mo hb mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hm hn ho hp hq"><h2 id="c3ee" class="kq kr ht bd ks kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk dt translated">结论</h2><p id="b0f7" class="pw-post-body-paragraph ju jv ht jw b jx ll iu jz ka lm ix kc kd ln kf kg kh lo kj kk kl lp kn ko kp hm dt translated">这篇文章简要分析了以太坊智能合约的安全漏洞，并给出了一些利用这些漏洞的真实案例，以及之前提出的防范技术。我针对以太坊智能合约中应用层的七个安全漏洞。因此需要在编程级别以改变形式的预防技术。这突出了Solidity版本更新，在开发DApps和智能合约时，必须注意这些更新以避免这些漏洞。</p><blockquote class="ng"><p id="3ce7" class="nh ni ht bd nj nk nl nm nn no np kp ek translated"><a class="ae ne" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nr ns nt nu nv jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nq"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>