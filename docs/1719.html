<html>
<head>
<title>Design patterns in Typescript made easy — part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让打字稿中的设计模式变得简单——第二部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/design-patterns-in-javascript-made-easy-part-ii-c32f7b22ef54?source=collection_archive---------4-----------------------#2018-10-28">https://medium.com/coinmonks/design-patterns-in-javascript-made-easy-part-ii-c32f7b22ef54?source=collection_archive---------4-----------------------#2018-10-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/08bb1777f0649974c9f8e6fb90f6c83c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GS0f15F7feWe1YL8qH4Dgg.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Moroccan pattern (Zellij)</figcaption></figure></div><div class="ab cl jf jg hb jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hm hn ho hp hq"><p id="b9a2" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt kk translated">今天我们将讨论结构化设计模式，它被认为是在不同的类之间建立简单/可能的关系的设计模式。</p><p id="35c5" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">但首先，我必须谈谈一个重要的设计模式，它属于我们上一篇文章的设计模式类别(创建)，工厂设计模式被定义为创建一个类的对象的解决方案，而无需向客户端公开创建逻辑，并使用公共接口引用新创建的对象。</p><p id="303f" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated"><strong class="jo hu">问题:</strong></p><p id="bb99" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">想象一个场景，在客户端类中有多个案例，我们调用多个新的关键字来创建新的对象。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="2386" class="lc ld ht ky b fv le lf l lg lh"><br/>if(value == 'Ferari'){</span><span id="8a1b" class="lc ld ht ky b fv li lf l lg lh">    let car = new Ferari();</span><span id="916a" class="lc ld ht ky b fv li lf l lg lh">}<br/>else if(value == 'Bugati'){</span><span id="cbe3" class="lc ld ht ky b fv li lf l lg lh">    let car = new Bugati();</span><span id="3f6f" class="lc ld ht ky b fv li lf l lg lh">}</span></pre><p id="46ec" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated"><strong class="jo hu">解决方案:</strong></p><p id="4b37" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">工厂方法模式是为创建对象定义一个接口，但是将对象创建委托给子类。</p><figure class="kt ku kv kw fq iu"><div class="bz el l di"><div class="lj lk l"/></div></figure><h1 id="b396" class="ll ld ht bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">1.适配器设计模式</h1><figure class="kt ku kv kw fq iu fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/99f6cd20791895c49974f6dafce7f62e.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/0*cXCec3AXy8R3cqlz.png"/></div></figure><p id="9b22" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">适配器是一种结构设计模式，它允许接口不兼容的对象进行协作，就像HDMI  DVI适配器一样</p><p id="1749" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated"><strong class="jo hu">问题:</strong></p><p id="b057" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">假设您有一个处理XML格式数据的应用程序，但是在某些时候，您需要使用一个只能处理JSON的库。</p><p id="9a81" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">例如，我们的应用程序使用soap API (XML输出)从提供商那里获取该国北部的天气数据，并将其显示在LCD显示器上。代码工作正常，但您决定使用另一个API来获取该国南部的数据，这里您必须使用Rest API (JSON输出)。您有两种解决方案来处理新的情况:1-创建一个新的类来处理Rest API，或者2-使用适配器设计模式。</p><p id="5a36" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated"><strong class="jo hu">解决方案:</strong></p><figure class="kt ku kv kw fq iu"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="abb8" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">我们这里有一个适配器，可以与客户端通信。这个适配器可以理解两种类型的返回(XML和JSON)，并为我们的LCD显示器(客户端)提供数据</p><h1 id="283c" class="ll ld ht bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">2.立面设计模式</h1><figure class="kt ku kv kw fq iu fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/d5ac0d19522e14607aa3015ffa36bbe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/0*MbRd9Br5rRuIMlvt.png"/></div></figure><p id="7e75" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">Facade模式隐藏了系统的复杂性，并提供了一个客户端可以访问系统的接口。这种类型的设计模式向现有系统添加了一个接口，以隐藏其复杂性。</p><p id="9f59" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated"><strong class="jo hu">问题:</strong></p><p id="bfd6" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">例如，我们有一个被客户调用的类来上传图片到亚马逊S3，但是在上传之前，我们必须检查、转换、重命名文件。这里的每个操作都与一个特定的类相关，我们有一个类来检查文件，另一个类使用特定的命名策略来重命名文件，并使用机器学习预测库来检查文件，以防止色情内容。</p><p id="5f5c" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">正如我们在这里看到的，我们有一个复杂的系统来上传文件，我们将使用一个Facade来降低所有这些复杂性，只需一个方法(一个调用)</p><p id="c60e" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated"><strong class="jo hu">解决方案:</strong></p><figure class="kt ku kv kw fq iu"><div class="bz el l di"><div class="lj lk l"/></div></figure><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="b59f" class="lc ld ht ky b fv le lf l lg lh">// call example</span><span id="1b79" class="lc ld ht ky b fv li lf l lg lh"><strong class="ky hu">import</strong> Uploader = Facade.Upload;<br/>// checking , renaming , convert and  upload the file </span><span id="a960" class="lc ld ht ky b fv li lf l lg lh">let file = new File('./pixel.png');<br/>Uploader.upload(file);</span></pre><p id="df0b" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">这里，facade方法“upload”为客户端提供了一种简单的方法，只需调用一个静态方法就可以简化整个过程</p><h1 id="0eb9" class="ll ld ht bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">3.代理设计模式</h1><figure class="kt ku kv kw fq iu fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/2c3a731545ceb2303265115b907f2208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/0*ahKhoqRQSx9OdZ4s.png"/></div></figure><p id="b492" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">代理是一种结构设计模式，它作为另一个类的接口工作，而不是从一个真正的类调用一个函数，我们通过代理</p><p id="dbb5" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated"><strong class="jo hu">问题:</strong></p><p id="31d7" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">例如，我们有一个强大的对象来记录数据库中的操作，但要登录数据库，您应该有一个角色(权限)，这个问题有多种解决方案，但最好的方法是使用代理。</p><p id="6b4c" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">在理想的情况下，我们会将这些代码直接放入对象的类中，但这并不总是可能的。例如，类可能驻留在封闭的第三方库中。</p><p id="237a" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated"><strong class="jo hu">解决方案:</strong></p><figure class="kt ku kv kw fq iu"><div class="bz el l di"><div class="lj lk l"/></div></figure><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="050e" class="lc ld ht ky b fv le lf l lg lh">// call example <br/>let logger = new LoggerProxy(); // here we check for permissions</span><span id="52d0" class="lc ld ht ky b fv li lf l lg lh">// later we log</span><span id="831f" class="lc ld ht ky b fv li lf l lg lh">logger.log('Delete payment resource ID 123');</span></pre><p id="8510" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">首先，我们创建一个接口，使类和代理可以互换，我们将原始的类函数调用到代理函数中，在代理实例化之前，我们检查连接用户的权限。</p><p id="c759" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated">第一部分:<a class="ae ml" rel="noopener" href="/coinmonks/design-patterns-in-javascript-made-easy-part-i-10334decb204">https://medium . com/coin monks/design-patterns-in-JavaScript-made-easy-part-I-10334 decb 204</a></p><p id="9820" class="pw-post-body-paragraph jm jn ht jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hm dt translated"><strong class="jo hu">参考文献:</strong></p><div class="mm mn fm fo mo mp"><a href="https://www.tutorialspoint.com/design_pattern/adapter_pattern.htm" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hu fv z el mu eo ep mv er et hs dt translated">设计模式适配器模式</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">设计模式适配器模式——以简单易行的步骤学习java设计模式:初学者教程…</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">www.tutorialspoint.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd iz mp"/></div></div></a></div><div class="mm mn fm fo mo mp"><a href="https://en.wikipedia.org/wiki/Adapter_pattern" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hu fv z el mu eo ep mv er et hs dt translated">适配器模式-维基百科</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">适配器允许两个不兼容的接口一起工作。这是适配器的真实定义…</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">en.wikipedia.org</p></div></div><div class="my l"><div class="ne l na nb nc my nd iz mp"/></div></div></a></div><div class="mm mn fm fo mo mp"><a href="https://refactoring.guru/design-patterns/facade" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hu fv z el mu eo ep mv er et hs dt translated">外表</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">我们正在对整个设计模式部分进行实质性的更新，应该会在年底完成…</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">重构大师</p></div></div><div class="my l"><div class="nf l na nb nc my nd iz mp"/></div></div></a></div><div class="mm mn fm fo mo mp"><a href="https://www.tutorialspoint.com/design_pattern/facade_pattern.htm" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hu fv z el mu eo ep mv er et hs dt translated">设计模式门面模式</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">设计模式门面模式——用简单易行的步骤学习java设计模式:初学者教程…</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">www.tutorialspoint.com</p></div></div><div class="my l"><div class="ng l na nb nc my nd iz mp"/></div></div></a></div><div class="mm mn fm fo mo mp"><a href="https://refactoring.guru/design-patterns/proxy/php/example" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hu fv z el mu eo ep mv er et hs dt translated">PHP中的代理</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">PHP中的代理模式。带有详细注释和解释的代码示例。代理是一种结构设计模式…</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">重构大师</p></div></div><div class="my l"><div class="nh l na nb nc my nd iz mp"/></div></div></a></div><div class="mm mn fm fo mo mp"><a href="https://en.wikipedia.org/wiki/Proxy_pattern#Remote_Proxy" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hu fv z el mu eo ep mv er et hs dt translated">代理模式-维基百科</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">最常见的代理是一个类，作为其他东西的接口。代理可以连接…</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">en.wikipedia.org</p></div></div><div class="my l"><div class="ni l na nb nc my nd iz mp"/></div></div></a></div><blockquote class="nj"><p id="b2c7" class="nk nl ht bd nm nn no np nq nr ns kj ek translated"><a class="ae ml" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nu nv nw nx ny iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nt"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>