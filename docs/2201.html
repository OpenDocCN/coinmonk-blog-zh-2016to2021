<html>
<head>
<title>Gas Optimization in Solidity Part I: Variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">固体中的气体优化第一部分:变量</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/gas-optimization-in-solidity-part-i-variables-9d5775e43dde?source=collection_archive---------1-----------------------#2019-05-08">https://medium.com/coinmonks/gas-optimization-in-solidity-part-i-variables-9d5775e43dde?source=collection_archive---------1-----------------------#2019-05-08</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/5fe3ef68e1028c2ff0943a039b75c7d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JuqkRf3X7CWTXGogeE5DOQ.jpeg"/></div></div></figure><p id="6924" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="jz">本文是为Solidity 0.5.8 </em>编写的</p><p id="eee3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Gas优化是开发以太坊智能合约所特有的挑战。为了成功，我们需要学习Solidity如何处理我们的变量和函数。</p><p id="b34c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，我们将气体优化分为两部分。</p><p id="95a8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在第一部分中，我们通过学习变量打包和数据类型权衡来讨论变量。</p><p id="b1a7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在第二部分中，我们通过学习可见性、减少执行和减少字节码来讨论函数。</p><p id="ed4d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们讨论的一些技术会违反众所周知的代码模式。在优化之前，我们应该始终考虑我们可能产生的技术债务和维护成本。</p><h1 id="e868" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">优化变量</h1><h2 id="2783" class="ky kb ht bd kc kz la lb kg lc ld le kk jm lf lg ko jq lh li ks ju lj lk kw ll dt translated">可变包装</h2><p id="074a" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">可靠性契约具有用于存储的连续32字节(256位)槽。当我们把变量排列成多个放在一个槽中时，我们称之为变量打包。</p><p id="102f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可变包装就像一个俄罗斯方块游戏。如果我们试图打包的变量超过了当前槽的32字节限制，它将被存储在一个新的槽中。我们必须找出哪些变量最适合组合在一起，以尽量减少浪费的空间。</p><p id="4356" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因为每个储气槽都要消耗汽油，可变包装通过减少合同要求的储气槽数量，帮助我们优化汽油使用。</p><p id="dd97" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看一个例子:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="7bc3" class="ky kb ht lw b fv ma mb l mc md">uint128 a;<br/>uint256 b;<br/>uint128 c;</span></pre><p id="0c73" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这些变量没有打包。如果<code class="eh me mf mg lw b">b</code>与<code class="eh me mf mg lw b">a</code>打包在一起，它将超过32字节的限制，因此它将被放入一个新的存储槽中。同样的事情也发生在<code class="eh me mf mg lw b">c</code>和<code class="eh me mf mg lw b">b</code>身上。</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="9a9e" class="ky kb ht lw b fv ma mb l mc md">uint128 a;<br/>uint128 c;<br/>uint256 b;</span></pre><p id="a22e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这些变量是打包的。因为用<code class="eh me mf mg lw b">a</code>打包<code class="eh me mf mg lw b">c</code>没有超过32字节的限制，所以它们被存储在同一个槽中。</p><p id="2044" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">选择数据类型时要记住变量打包——数据类型的较小版本只有在有助于将变量打包到存储槽中时才有用。如果a <code class="eh me mf mg lw b">uint128</code>装不下，我们还不如用一个<code class="eh me mf mg lw b">uint256</code>。</p><p id="1998" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">数据位置</strong>试图打包函数参数或局部变量不会节省空间。</p><p id="444d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">引用数据类型</strong> <br/>结构和数组总是从一个新的存储槽开始——但是它们的内容可以正常打包。一个<code class="eh me mf mg lw b">uint8</code>数组将比一个等长的<code class="eh me mf mg lw b">uint256</code>数组占用更少的空间。</p><p id="9a0a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">用单独的赋值来初始化紧密封装的结构比用单个赋值更有效。单独的赋值使得优化器更容易一次更新所有的变量。</p><p id="e5ec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">像这样初始化结构:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="c600" class="ky kb ht lw b fv ma mb l mc md">Point storage p = Point()<br/>p.x = 0;<br/>p.y = 0;</span></pre><p id="f47b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">而不是:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="8e8e" class="ky kb ht lw b fv ma mb l mc md">Point storage p = Point(0, 0);</span></pre><p id="5952" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">继承</strong></p><p id="f628" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">变量的顺序由<a class="ae mh" href="https://en.wikipedia.org/wiki/C3_linearization" rel="noopener ugc nofollow" target="_blank"> C3线性化</a>决定。对于大多数应用程序，你只需要知道子变量在父变量之后。</p><h2 id="f4ec" class="ky kb ht bd kc kz la lb kg lc ld le kk jm lf lg ko jq lh li ks ju lj lk kw ll dt translated">数据类型</h2><p id="b4a4" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">当选择数据类型来优化gas时，我们必须管理权衡。不同的情况会使相同的数据类型变得便宜或昂贵。</p><p id="6a7e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">内存与存储</strong> <br/>在内存上执行操作——或者调用数据，类似于内存——总是比存储便宜。</p><p id="3574" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">减少存储操作数量的一种常见方法是在将局部内存变量分配给存储变量之前对其进行操作。</p><p id="7cce" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们经常在循环中看到这种情况:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="becf" class="ky kb ht lw b fv ma mb l mc md">uint256 return = 5; // assume 2 decimal places<br/>uint256 totalReturn;</span><span id="0234" class="ky kb ht lw b fv mi mb l mc md">function updateTotalReturn(uint256 timesteps) external {<br/>    uint256 r = totalReturn || 1;</span><span id="1046" class="ky kb ht lw b fv mi mb l mc md">    for (uint256 i = 0; i &lt; timesteps; i++) {<br/>        r = r * return;<br/>    }</span><span id="2e0f" class="ky kb ht lw b fv mi mb l mc md">    totalReturn = r;<br/>}</span></pre><p id="59d7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<code class="eh me mf mg lw b">calculateReturn</code>中，我们使用本地内存变量<code class="eh me mf mg lw b">r</code>来存储中间值，并将最终值赋给我们的存储变量<code class="eh me mf mg lw b">totalReturn</code>。</p><p id="f175" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">固定与动态</strong> <br/>固定大小的变量总是比动态的便宜。</p><p id="f158" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果我们知道数组应该有多长，我们指定一个固定的大小:</p><pre class="lr ls lt lu fq lv lw lx ly aw lz dt"><span id="c72b" class="ky kb ht lw b fv ma mb l mc md">uint256[12] monthlyTransfers;</span></pre><p id="1aec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">同样的规则也适用于字符串。一个<code class="eh me mf mg lw b">string</code>或<code class="eh me mf mg lw b">bytes</code>变量被动态调整大小；如果我们的字符串足够短，我们应该使用一个<code class="eh me mf mg lw b">byte32</code>。</p><p id="10c7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果我们绝对需要一个动态数组，那么最好将我们的函数构造成可加的而不是次活跃的。扩展数组消耗的是常量气体，而截断数组消耗的是线性气体。</p><p id="5317" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">映射vs数组</strong> <br/>大多数时候使用<code class="eh me mf mg lw b">mapping</code>比使用数组更好，因为它的操作成本更低。</p><p id="67cc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">但是，当使用较小的数据类型时，数组可能是正确的选择。数组元素像其他存储变量一样被打包，减少的存储空间可能会超过数组更昂贵的操作的成本。这在处理大型数组时非常有用。</p><h2 id="6fb3" class="ky kb ht bd kc kz la lb kg lc ld le kk jm lf lg ko jq lh li ks ju lj lk kw ll dt translated">其他技术</h2><p id="8f53" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">在处理变量时，还有其他一些技巧可以帮助我们优化天然气成本。</p><p id="4135" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">初始化</strong><br/>Solidity中的每个变量赋值都要耗费gas。在初始化变量时，我们经常浪费时间去指定永远不会用到的默认值。</p><p id="bdc7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh me mf mg lw b">uint256 value;</code>比<code class="eh me mf mg lw b">uint256 value = 0;</code>便宜。</p><p id="6fb8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> Require strings </strong> <br/>如果我们要给Require语句添加消息字符串，我们可以通过将字符串长度限制为32个字节来降低成本。</p><p id="9f3c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">解包变量</strong><br/>EVM一次处理32个字节，小于32个字节的变量被转换。如果我们不通过打包变量来节省能源，那么使用32字节的数据类型会更便宜，比如<code class="eh me mf mg lw b">uint256</code>。</p><p id="dc9f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">删除</strong> <br/>以太坊在我们删除变量的时候给我们退气。其目的是鼓励节省区块链的空间，我们用它来降低交易的汽油成本。</p><p id="1565" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">删除一个变量可退还15，000美元的汽油费，最高可达交易汽油费的一半。用<code class="eh me mf mg lw b">delete</code>关键字删除相当于给数据类型赋初始值，比如用<code class="eh me mf mg lw b">0</code>给整数。</p><p id="33d7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">将数据存储在事件中</strong> <br/>不需要链上访问的数据可以存储在事件中以节省气体。</p><p id="9230" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">虽然这种技术可行，但不推荐使用——事件并不意味着数据存储。如果我们需要的数据存储在很久以前发出的事件中，由于我们需要搜索的块的数量，检索它会非常耗时。</p><h1 id="13c5" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">优化功能</h1><p id="5706" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated"><em class="jz">固体中的气体优化第二部分:功能</em>即将推出…</p></div><div class="ab cl mj mk hb ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hm hn ho hp hq"><p id="61a2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="jz">如果这篇文章对您有帮助，请点击</em> <strong class="jd hu"> <em class="jz">或点击</em></strong><em class="jz"/><strong class="jd hu">❤</strong><em class="jz">按钮，以便其他人可以找到它。</em></p><h2 id="2984" class="ky kb ht bd kc kz la lb kg lc ld le kk jm lf lg ko jq lh li ks ju lj lk kw ll dt translated">在<a class="ae mh" href="https://www.linkedin.com/in/willshahda" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae mh" href="https://twitter.com/ethdapp" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我联系。</h2><blockquote class="mq"><p id="2381" class="mr ms ht bd mt mu mv mw mx my mz jy ek translated">加入Coinmonks <a class="ae mh" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae mh" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae mh" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="ky kb ht bd kc kz na lb kg lc nb le kk jm nc lg ko jq nd li ks ju ne lk kw ll dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="nf ng ht jd b je lm ji ln jm nh jq ni ju nj jy nk nl nm nn dt translated"><a class="ae mh" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae mh" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="nf ng ht jd b je no ji np jm nq jq nr ju ns jy nk nl nm nn dt translated"><a class="ae mh" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae mh" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="nf ng ht jd b je no ji np jm nq jq nr ju ns jy nk nl nm nn dt translated"><a class="ae mh" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae mh" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="nf ng ht jd b je no ji np jm nq jq nr ju ns jy nk nl nm nn dt translated"><a class="ae mh" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae mh" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="nf ng ht jd b je no ji np jm nq jq nr ju ns jy nk nl nm nn dt translated"><a class="ae mh" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">开发者最佳加密API</a></li><li id="b359" class="nf ng ht jd b je no ji np jm nq jq nr ju ns jy nk nl nm nn dt translated">最佳<a class="ae mh" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="nf ng ht jd b je no ji np jm nq jq nr ju ns jy nk nl nm nn dt translated"><a class="ae mh" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li></ul></div></div>    
</body>
</html>