<html>
<head>
<title>Rock, Paper, Scissors in Solidity | Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">石头、剪子、布在坚固中|第1部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/rock-paper-scissors-in-solidity-part-1-9d7c5d8a316e?source=collection_archive---------0-----------------------#2021-09-27">https://medium.com/coinmonks/rock-paper-scissors-in-solidity-part-1-9d7c5d8a316e?source=collection_archive---------0-----------------------#2021-09-27</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/5ea983d4b4d0a572fc3fa126dac35ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KlhuU8HycOxRFyyl"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by <a class="ae jf" href="https://unsplash.com/@marcus_wallis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marcus Wallis</a> on <a class="ae jf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="017d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我们基于<a class="ae jf" href="https://github.com/nathan-websculpt/reactsolidity_frontend/blob/master/src/components/RPS.js" rel="noopener ugc nofollow" target="_blank"> React示例</a>的石头、剪子、布的实体版本，我们会有一些问题。</p><p id="24da" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">React代码</p><ul class=""><li id="b532" class="ke kf ht ji b jj jk jn jo jr kg jv kh jz ki kd kj kk kl km dt translated">有一个随机的对手选择(石头、布或剪刀)</li><li id="ab1a" class="ke kf ht ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">利用字符串连接来组合两个玩家的选择</li><li id="a678" class="ke kf ht ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">和字符串比较来确定获胜者</li></ul><p id="1e19" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这是过渡到可靠性的一个好方法，因为React代码中的逻辑根本不会过渡到可靠性。</p><p id="f0c0" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">制作一个真实世界的玩家对战电脑游戏比看起来要困难得多。</p><p id="b93c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">引入问题:</p><ul class=""><li id="f2b2" class="ke kf ht ji b jj jk jn jo jr kg jv kh jz ki kd kj kk kl km dt translated">坚固性的随机性</li><li id="8ba5" class="ke kf ht ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">串并置</li><li id="813f" class="ke kf ht ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">字符串比较</li></ul></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><h2 id="1289" class="la lb ht bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt lu dt translated"><strong class="ak">坚实度字符串比较</strong></h2><p id="08d8" class="pw-post-body-paragraph jg jh ht ji b jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">如果你从其他编码语言来到Solidity——你应该知道Solidity不提供你习惯使用<code class="eh ma mb mc md b">string</code>的功能。字符串与<code class="eh ma mb mc md b">==</code>的比较会抛出编译器错误。</p><figure class="mf mg mh mi fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff me"><img src="../Images/abb4f5bb5b5d56d53ab4ea24847f0244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pJHBxxxXAuIIGm4S69Bq7g.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Comparison does not work with string calldata</figcaption></figure><figure class="mf mg mh mi fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mj"><img src="../Images/64a49006a360ef4496f168a22e28eec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGPEl6CMHoW5wM8NtFRl6A.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Comparison isn’t working in an IF statement</figcaption></figure><figure class="mf mg mh mi fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mk"><img src="../Images/ab5ff3c31fa54c29adcb6eb5a94c881d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jkjeIE1PH0icVC-ba2ntPA.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Comparison isn’t working with string memory</figcaption></figure><p id="0244" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> <em class="ks">如何比较字符串</em> </strong></p><pre class="mf mg mh mi fq ml md mm mn aw mo dt"><span id="557d" class="la lb ht md b fv mp mq l mr ms">keccak256(abi.encodePacked(_inputOne)) == keccak256(abi.encodePacked(_inputTwo))</span></pre><p id="901e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">请注意，这将编译+工作，以及…</p><pre class="mf mg mh mi fq ml md mm mn aw mo dt"><span id="2bde" class="la lb ht md b fv mp mq l mr ms">keccak256(bytes(_inputOne)) == keccak256(bytes(_inputTwo))</span></pre><p id="67c7" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">看起来很复杂，其实不然。<code class="eh ma mb mc md b">keccak256</code>是一个哈希函数，它计算输入的<em class="ks">Keccak-256</em>T21哈希。这个<em class="ks">散列</em>有一些复杂的用例，但是现在——它允许我们使用<code class="eh ma mb mc md b">==</code>比较两个输入。</p><p id="764e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh ma mb mc md b">abi.encodePacked()</code>是Solidity对<strong class="ji hu">非标准打包模式</strong>的支持，在这种模式下，一切都就地编码，像<code class="eh ma mb mc md b">string</code>或<code class="eh ma mb mc md b">bytes</code>这样的动态大小类型编码时没有长度字段。</p></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><h2 id="35c6" class="la lb ht bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt lu dt translated"><strong class="ak">实度中的字符串串联</strong></h2><p id="2341" class="pw-post-body-paragraph jg jh ht ji b jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">所以，现在你知道字符串需要一些<em class="ks">自己动手</em>，让我们看看我们将如何连接字符串，就像我们在<a class="ae jf" href="https://github.com/nathan-websculpt/reactsolidity_frontend/blob/master/src/components/RPS.js" rel="noopener ugc nofollow" target="_blank"> React代码</a>中所做的那样。</p><p id="0ea8" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">以下是在Solidity中实现这一点的几种方法:</p><pre class="mf mg mh mi fq ml md mm mn aw mo dt"><span id="12ec" class="la lb ht md b fv mp mq l mr ms">abi.encodePacked(_inputOne, _inputTwo)</span></pre><p id="6451" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="ks">和:</em></p><pre class="mf mg mh mi fq ml md mm mn aw mo dt"><span id="d6b7" class="la lb ht md b fv mp mq l mr ms">bytes.concat(bytes(_inputOne), bytes(_inputTwo))</span></pre><ul class=""><li id="d8f0" class="ke kf ht ji b jj jk jn jo jr kg jv kh jz ki kd kj kk kl km dt translated"><strong class="ji hu">ABI . encode packed(<em class="ks">string</em>)</strong>正在复制内存</li><li id="81e0" class="ke kf ht ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated"><strong class="ji hu">字节(<em class="ks">字符串</em> ) </strong>只是对指针类型进行造型</li></ul><p id="56a7" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因此，为了实现这种级联，我们将两个输入从<code class="eh ma mb mc md b">string</code>变为<code class="eh ma mb mc md b">bytes</code>。</p><p id="5a52" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你可以在<a class="ae jf" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a>里玩玩这段代码，自己看看:</p><figure class="mf mg mh mi fq iu"><div class="bz el l di"><div class="mt mu l"/></div></figure></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><h2 id="1190" class="la lb ht bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt lu dt translated"><strong class="ak">坚固性的随机性</strong></h2><p id="2de9" class="pw-post-body-paragraph jg jh ht ji b jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">在像我们的石头、剪子、布这样的游戏中——为了和“<em class="ks">电脑</em>”对抗，你需要一些<em class="ks">随机</em>。好吧，因为几个不同的原因，坚固性不能提供这一点。</p><p id="07b9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在计算世界中，这是一个大得多的、近乎哲学的讨论，但算法不可能真的产生一个“随机”数。对我们来说没什么大不了的，因为我们的游戏只有3个选择(石头、布或剪刀)。为了学习一些简单的可靠性方面的知识，我们只是想要一些可以玩的代码。</p><p id="f3de" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">但是，你应该知道:</p><ul class=""><li id="a7fc" class="ke kf ht ji b jj jk jn jo jr kg jv kh jz ki kd kj kk kl km dt translated">产生随机性的复杂算法成本太高</li><li id="c1ca" class="ke kf ht ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">可靠性代码<em class="ks">应该是确定性的(因为它将在多个节点上运行)</em></li><li id="e0f7" class="ke kf ht ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">该算法将需要生成随机数<em class="ks">一次</em>，该随机数将在其他节点上使用</li><li id="41e8" class="ke kf ht ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">如果有人知道你是如何产生随机性的，他们就能预测结果</li></ul><p id="cc93" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要做到这一点，<strong class="ji hu"> <em class="ks">【正确的方式】</em></strong>(mainnet上的一个真实世界的dapp这可能会变得相当复杂。一种方法是提供链外的随机性，但是这里也有一些T21。</p><p id="fa30" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">出于我们的目的，我们将只测试逻辑的功能，所以我们将通过calldata发送两个值(玩家的选择和计算机的选择)。这将模拟一个已经产生随机性的场景，或者两个不同的玩家在玩游戏。</p></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><h1 id="cda4" class="mv lb ht bd lc mw mx my lg mz na nb lk nc nd ne ln nf ng nh lq ni nj nk lt nl dt translated"><strong class="ak">代码</strong></h1><p id="6a80" class="pw-post-body-paragraph jg jh ht ji b jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">我们希望测试和验证:</p><ul class=""><li id="f952" class="ke kf ht ji b jj jk jn jo jr kg jv kh jz ki kd kj kk kl km dt translated">游戏可以转移赌注的价值</li><li id="b233" class="ke kf ht ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated"><em class="ks">不是</em>进入<em class="ks">就是</em>脱离玩家的平衡</li><li id="4e9b" class="ke kf ht ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated"><strong class="ji hu">基于</strong>:结果</li></ul><p id="91b5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">游戏的结果将会:</p><ul class=""><li id="706f" class="ke kf ht ji b jj jk jn jo jr kg jv kh jz ki kd kj kk kl km dt translated">演示<em class="ks">字符串连接</em></li><li id="2fb0" class="ke kf ht ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">和，<em class="ks">字符串比较</em></li></ul><p id="f005" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">为了测试—我们将违反合同:</strong></p><ul class=""><li id="582d" class="ke kf ht ji b jj jk jn jo jr kg jv kh jz ki kd kj kk kl km dt translated">你需要为合约提供资金(这样它就有钱来做空你)</li><li id="64fb" class="ke kf ht ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">更改帐户</li><li id="78b0" class="ke kf ht ji b jj kn jn ko jr kp jv kq jz kr kd kj kk kl km dt translated">并存入资金(这样你就有钱下注了)</li></ul><figure class="mf mg mh mi fq iu"><div class="bz el l di"><div class="mt mu l"/></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Very basic representation of Rock, Paper Scissors logic on Solidity</figcaption></figure><p id="d844" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你可以通过用Ether资助合同，交换账户，进行<em class="ks">存款</em>来测试。将帐户地址复制到“<em class="ks"> playerBalances </em>中，查看您的资金。你用小写字符串玩这个游戏:<em class="ks">石头，布，剪刀</em></p><figure class="mf mg mh mi fq iu fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/b4bd8a33200a7f2027980081f113d2ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*w5kkr1Qg1-3Uc0OR3GYmRw.jpeg"/></div></figure><p id="afad" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">玩完后，再次检查余额—请注意，您的赢和输都会反映在您的余额中。</p><figure class="mf mg mh mi fq iu fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/78b49cc41cfa039badc2ce43be2ab772.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*fkqbADoOl3apBSh3FkyP4A.jpeg"/></div></figure><p id="dac6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因为<em class="ks">摇滚</em>击败<em class="ks">剪刀</em>，我们涨了1，但是现在让我们来测试一个损失……<em class="ks">纸</em>会输给<em class="ks">剪刀。</em></p><figure class="mf mg mh mi fq iu fe ff paragraph-image"><div class="fe ff no"><img src="../Images/49558a66700012f5581424a014dd6417.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*kI6yEqY9bVD8NuKFs4PKjA.jpeg"/></div></figure><p id="f54b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在点击“取款”按钮，你的资金将会回到你的账户。</p><figure class="mf mg mh mi fq iu fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/28f55280b23c794ea28934a478b51a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*YAj-87rFM1k0evGpdxLE5A.jpeg"/></div></figure></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><p id="0954" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我选择这个游戏(石头、剪子、布)作为向新手展示稳健的一种方式，因为它在反应上非常简单，但在变得稳健时提供了许多<em class="ks">可教的时刻</em>。这个小合同显示了区块链代码和开发人员习惯的代码之间的直接差异。它也建立在<a class="ae jf" rel="noopener" href="/@websculpt/sending-ether-without-getting-hacked-ca366a0678f5">关于发送以太和攻击契约的4部分系列</a>之上。</p><p id="5989" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在这个游戏的未来版本中，我们可以重新进入托管状态，让用户彼此对战…我们需要隐藏和显示玩家选择的方法，我们将能够推进逻辑，使之更接近真实世界的dapp。</p><p id="3b02" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">下一篇文章将是关于把这个游戏转移到<a class="ae jf" href="https://nervous-tereshkova-aa8032.netlify.app/" rel="noopener ugc nofollow" target="_blank">直播应用</a>上。</p></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><h1 id="ae0d" class="mv lb ht bd lc mw mx my lg mz na nb lk nc nd ne ln nf ng nh lq ni nj nk lt nl dt translated">如何支持更多这样的帖子</h1><p id="ecde" class="pw-post-body-paragraph jg jh ht ji b jj lv jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">如果你想看更多这方面的内容，请在这里捐赠ETH或ERC-20代币:0xd 6355 a6b 745985342 ebf 168 E1 EC 965 DC 612704 b 1</p></div></div>    
</body>
</html>