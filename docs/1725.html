<html>
<head>
<title>Part 7: Implementing Blockchain and Cryptocurrency with PoW consensus algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第7部分:用PoW共识算法实现区块链和加密货币</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/part-7-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-bf9a16063ec1?source=collection_archive---------1-----------------------#2018-10-30">https://medium.com/coinmonks/part-7-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-bf9a16063ec1?source=collection_archive---------1-----------------------#2018-10-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="3086" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在node.js中使用工作共识算法证明，小规模、易于理解、全面、逐步实施区块链和加密货币</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/ca1a2e2c4224dbbeb2b00eaca6e45a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*4tiX8RcB0DnrDZZ0l8yxGw.jpeg"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Source: <a class="ae ka" href="https://en.bitcoinwiki.org/wiki/Proof-of-work" rel="noopener ugc nofollow" target="_blank">Bitcoin Wiki</a></figcaption></figure><p id="f67e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<a class="ae ka" rel="noopener" href="/coinmonks/part-6-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-87b274e86ce4">之前的帖子</a>中，我们创建了事务。在现实生活中，区块链系统是不同步的，因此矿工将在不同的时间收到交易。我们需要一个地方来存储这些事务，直到我们创建一个块或者一个新的块被添加到链中。这就是为什么我们的系统中有事务池。</p><p id="a391" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于多个个人使用他们的钱包在加密货币上创建交易，因此需要一种方法来包含这些交易的组，我们现在将使用交易池的概念。事务池将是一个实时更新的对象，包含网络中所有挖掘者提交的所有新事务。</p><p id="483f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">用户将创建事务，然后将每个事务提交到池中。池中出现的这些新交易将被视为未确认交易。</p><p id="036c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">挖掘器从该池中取出一组事务，并创建块，使事务得到确认。</p><p id="42fd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了更新我们的事务池，我们将使用我们创建的p2p服务器，并向网络广播事务。当我们收到新的交易时，我们会将其添加到我们的池中。</p><p id="5739" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是首先，让我们在wallet目录中创建一个文件<code class="eh kb kc kd ke b">transaction-pool.js</code>并创建一个<code class="eh kb kc kd ke b">TransactionPool</code>类。</p><p id="945c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个类只有一个属性事务数组。</p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="9a32" class="kj kk ht ke b fv kl km l kn ko">this.transactions = [];</span></pre><p id="4e54" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们向池中添加一些方法。</p><p id="1311" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，让我们添加一个方法来添加事务。请注意，我们可能会收到池中已经存在的交易，因此我们也需要事先进行检查。我们收到的交易也可能被更新，即输出脚本被更改，因此我们也将处理这种情况。</p><p id="18d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">创建一个函数，<code class="eh kb kc kd ke b">updateOrAddTransaction(transaction)</code>这个方法将检查事务是否已经存在。如果是，它将在检查输入id并添加新的输出(如果有)后用新的事务替换该事务。如果事务不存在，它会简单地将事务添加到池中</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kp kq l"/></div></figure><p id="f5ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们现在结合几个概念。</p><p id="ebd8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们创建一个函数来创建一个新的交易，使用我们的wallet对其进行签名，并将其添加到我们的交易池中。我们将使用上面创建的所有函数。如果任何事务已经存在，该函数也应该更新事务。</p><p id="f1cc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们在wallet类中创建一个<code class="eh kb kc kd ke b">createTransaction()</code>函数来完成这项工作，因为我们需要更新事务池，我们需要在wallet构造函数中有一个事务池实例。</p><p id="236b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了使我们的代码简洁，创建一个函数<code class="eh kb kc kd ke b">existingTransaction(address)</code>,它将检查给定地址是否存在事务。</p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="f555" class="kj kk ht ke b fv kl km l kn ko">existingTransaction(address){</span><span id="e5b2" class="kj kk ht ke b fv kr km l kn ko">return this.transactions.find(t =&gt; t.input.address === address);</span><span id="6822" class="kj kk ht ke b fv kr km l kn ko">}</span></pre><p id="a2b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们制作<code class="eh kb kc kd ke b">createTransaction()</code>函数</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kp kq l"/></div></figure><p id="5358" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，让我们添加一些测试来确保一切正常。</p><p id="cdac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们测试我们的事务池</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kp kq l"/></div></figure><p id="f104" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在让我们测试一下我们的钱包</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kp kq l"/></div></figure><p id="35d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行测试，您将有24个测试通过。</p><p id="4b0f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">太棒了。</p><p id="f14e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将在主应用程序中使用我们的钱包和交易池。</p><p id="d8b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在app/index.js文件中，创建一个wallet实例和一个<code class="eh kb kc kd ke b">transactionPool</code>实例。</p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="be96" class="kj kk ht ke b fv kl km l kn ko">const Wallet = require('../wallet');</span><span id="142e" class="kj kk ht ke b fv kr km l kn ko">const TransactionPool = require('../wallet/transaction-pool');</span><span id="a301" class="kj kk ht ke b fv kr km l kn ko">// create a new wallet</span><span id="a2cd" class="kj kk ht ke b fv kr km l kn ko">const wallet = new Wallet();</span><span id="c0fc" class="kj kk ht ke b fv kr km l kn ko">// create a new transaction pool which will be later</span><span id="59fa" class="kj kk ht ke b fv kr km l kn ko">// decentralized and synchronized using the peer to peer server</span><span id="1dae" class="kj kk ht ke b fv kr km l kn ko">const transactionPool = new TransactionPool();</span></pre><p id="a448" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在创建一个get端点<code class="eh kb kc kd ke b"> ‘/transactions’</code></p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="5ee5" class="kj kk ht ke b fv kl km l kn ko">// api to view transaction in the transaction pool</span><span id="5cfa" class="kj kk ht ke b fv kr km l kn ko">app.get('/transactions',(req,res)=&gt;{</span><span id="eec6" class="kj kk ht ke b fv kr km l kn ko">res.json(transactionPool.transactions);</span><span id="0ff4" class="kj kk ht ke b fv kr km l kn ko">});</span></pre><p id="801b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行应用程序并打开postman</p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="ca78" class="kj kk ht ke b fv kl km l kn ko">npm run dev</span></pre><p id="571a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">点击API，您将得到一个空数组作为响应，这正是我们所期望的。</p><p id="0297" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们创建一个post请求<code class="eh kb kc kd ke b"> ‘/transact’ </code>来创建一个新的事务</p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="d523" class="kj kk ht ke b fv kl km l kn ko">// create transactions</span><span id="0a51" class="kj kk ht ke b fv kr km l kn ko">app.post('/transact',(req,res)=&gt;{</span><span id="775c" class="kj kk ht ke b fv kr km l kn ko">const { recipient, amount } = req.body;</span><span id="c4f7" class="kj kk ht ke b fv kr km l kn ko">const transaction = wallet.createTransaction(<br/>                                  recipient,<br/>                                  amount,<br/>                                  blockchain,<br/>                                  transactionPool);</span><span id="82d1" class="kj kk ht ke b fv kr km l kn ko">res.redirect('/transactions');</span><span id="3b46" class="kj kk ht ke b fv kr km l kn ko">});</span></pre><p id="71d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在postman中用收件人的地址和金额&lt; 500测试这个API，点击几次send，您将得到一个交易列表，作为一个非常令人满意的响应。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="fe ff ks"><img src="../Images/e58a0ba2ca40d4da20adb1064e6a5fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qP_q3QExIDmR_54MhEC1zA.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">The Transaction</figcaption></figure><p id="6f85" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">太棒了。</p><p id="b9a1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们可以创建事务了，让我们编写代码将事务广播到网络。我们将把事务池添加到p2p服务器中。</p><p id="e6a7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<code class="eh kb kc kd ke b">P2server</code>类中，我们将在其构造函数中添加另一个属性，即事务池实例。</p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="4061" class="kj kk ht ke b fv kl km l kn ko">constructor(blockchain,transactionPool){</span><span id="999a" class="kj kk ht ke b fv kr km l kn ko">     this.blockchain = blockchain;</span><span id="23f9" class="kj kk ht ke b fv kr km l kn ko">     this.sockets = [];</span><span id="1de1" class="kj kk ht ke b fv kr km l kn ko">     this.transactionPool = transactionPool;</span><span id="a7ec" class="kj kk ht ke b fv kr km l kn ko">}</span></pre><p id="35ed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还需要更新我们在app/index.js文件中创建的实例，并将<code class="eh kb kc kd ke b">transactioPool </code>实例传递给<code class="eh kb kc kd ke b">p2pserver </code>实例。</p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="420c" class="kj kk ht ke b fv kl km l kn ko">const p2pserver = new P2pserver(blockchain,transactionPool);</span></pre><p id="36ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在让我们创建一个方法来处理p2pserver类中的事务。该方法将非常类似于我们现在已经拥有的同步链功能，该功能同步连接到该应用程序套接字的每个人的链。</p><p id="f903" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了处理多种消息类型，我们将在p2pserver类中创建一个对象MESSAGE_TYPE。</p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="057b" class="kj kk ht ke b fv kl km l kn ko">const MESSAGE_TYPE = {</span><span id="776b" class="kj kk ht ke b fv kr km l kn ko">chain: 'CHAIN',</span><span id="0a29" class="kj kk ht ke b fv kr km l kn ko">transaction: 'TRANSACTION'</span><span id="1dd7" class="kj kk ht ke b fv kr km l kn ko">}</span></pre><p id="6a50" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每当创建新的事务时，该方法都会将事务发送到每个连接的套接字。</p><p id="2c02" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以，让我们在p2pserver类中创建一个函数<code class="eh kb kc kd ke b">broadcastTransaction(transaction)</code>。这个函数将把事务发送到每个套接字。为了保持代码的整洁，我们可以创建另一个名为<code class="eh kb kc kd ke b">sendTransaction(socket,transaction)</code>的函数，只向单个套接字发送一个事务，并为每个套接字调用这个函数。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kp kq l"/></div></figure><p id="e784" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">类似地，我们也将使用MESSAGE_TYPEs来发送链。所以也更新一下<code class="eh kb kc kd ke b">sendChain </code>功能。</p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="9446" class="kj kk ht ke b fv kl km l kn ko">sendChain(socket){</span><span id="7b1e" class="kj kk ht ke b fv kr km l kn ko">    socket.send(JSON.stringify({</span><span id="d429" class="kj kk ht ke b fv kr km l kn ko">    type: MESSAGE_TYPE.chain,</span><span id="1007" class="kj kk ht ke b fv kr km l kn ko">    chain: this.blockchain.chain</span><span id="8855" class="kj kk ht ke b fv kr km l kn ko">}));</span><span id="fe4d" class="kj kk ht ke b fv kr km l kn ko">}</span></pre><p id="cb90" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好了，现在我们可以广播新的交易了。让我们也编写代码来处理发送给我们的事务。</p><p id="977b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于我们有不同类型的消息，我们需要不同地处理它们，而不是创建多个函数，我们将使用switch语句来根据消息类型选择句柄。</p><p id="21fc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我们的消息处理程序中，对于作为数据的链，我们将调用<code class="eh kb kc kd ke b">replaceChain </code>函数，对于作为事务的数据，我们将调用<code class="eh kb kc kd ke b">updateOrAddTransaction </code>函数。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kp kq l"/></div></figure><p id="c0e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，我们将这个消息处理程序注册到每个套接字</p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="9fb8" class="kj kk ht ke b fv kl km l kn ko">connectSocket(socket){</span><span id="0f16" class="kj kk ht ke b fv kr km l kn ko">  this.sockets.push(socket);</span><span id="1682" class="kj kk ht ke b fv kr km l kn ko">  console.log("Socket connected");</span><span id="e85a" class="kj kk ht ke b fv kr km l kn ko">  this.messageHandler(socket);</span><span id="2dcf" class="kj kk ht ke b fv kr km l kn ko">  this.sendChain(socket);</span><span id="0ae9" class="kj kk ht ke b fv kr km l kn ko">}</span></pre><p id="e7ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，我们将在API中使用广播事务函数。当我们在API中创建新的事务时，我们将调用<code class="eh kb kc kd ke b">broadcastTransaction </code>函数。</p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="ab54" class="kj kk ht ke b fv kl km l kn ko">app.post('/transact',(req,res)=&gt;{</span><span id="b6e4" class="kj kk ht ke b fv kr km l kn ko">const { recipient, amount } = req.body;</span><span id="90ce" class="kj kk ht ke b fv kr km l kn ko">const transaction = wallet.createTransaction(recipient,<br/>            amount,blockchain,transactionPool);</span><span id="7bbd" class="kj kk ht ke b fv kr km l kn ko">p2pserver.broadcastTransaction(transaction);</span><span id="4199" class="kj kk ht ke b fv kr km l kn ko">res.redirect('/transactions');</span><span id="7193" class="kj kk ht ke b fv kr km l kn ko">});</span></pre><p id="f205" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，事务实际上将在网络上广播，我们的消息处理程序将把它们添加到事务池中。</p><p id="f0f2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您可以通过打开两个终端并运行两个应用程序实例来测试这一点。在其中一个终端中创建一组事务，然后我们将点击另一个应用程序实例的get transactions端点。</p><p id="c1d5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你会看到交易实际上正在向网络广播。</p><p id="4f52" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通过为第三个实例创建事务来测试功能，并使用第一个实例的端点来查看这些事务。</p><p id="fe48" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">太好了。现在，我们可以创建事务，将它们存储到事务池中，并向网络广播事务。</p><p id="5550" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在下一篇文章中，我们将创建miner类。此外，我们还将实现miner因创建块而获得的奖励。</p></div><div class="ab cl kx ky hb kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hm hn ho hp hq"><p id="327e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae ka" rel="noopener" href="/coinmonks/part-8-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-74e839158f1b">第八部分:用PoW共识算法实现区块链和加密货币</a></p><p id="dc6c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="le">感谢您的阅读。在下一部分中，我们将为矿工创建一个类，在这个类中，我们将使用到目前为止已经创建的所有功能，并且还将添加奖励的概念。</em>  <em class="le">希望你喜欢编码。如果你发现这很有帮助，请鼓掌。</em> </p><p id="4ed5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你对区块链、以太坊或整个世界有任何问题，请发表评论。:)</p><blockquote class="lf"><p id="f307" class="lg lh ht bd li lj lk ll lm ln lo jn ek translated"><a class="ae ka" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="lq lr ls lt lu jt fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lp"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>