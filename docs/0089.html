<html>
<head>
<title>Data structure in Ethereum | Episode 2: Radix trie and Merkle trie.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊中的数据结构|第2集:基数trie和Merkle trie。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/data-structure-in-ethereum-episode-2-radix-trie-and-merkle-trie-d941d0bfd69a?source=collection_archive---------1-----------------------#2018-02-08">https://medium.com/coinmonks/data-structure-in-ethereum-episode-2-radix-trie-and-merkle-trie-d941d0bfd69a?source=collection_archive---------1-----------------------#2018-02-08</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/ac8a1166286e9ed90939fbe19f773e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kkQm6IFTxIjf7xhl5V4cZg.jpeg"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Trie is a main data structure used in Ethereum.</figcaption></figure><div class=""/><p id="5352" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在<a class="ae kd" rel="noopener" href="/@phansnt/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919">第1集</a> <a class="ae kd" rel="noopener" href="/@phansnt/data-structure-in-ethereum-episode-1-compact-hex-prefix-encoding-12558ae02791">和1+ </a>中，我们熟悉了一些用于构建以太坊数据的编码/解码算法。现在，我们将继续讨论以太坊中的数据组织。我将介绍两种trie，它们是Radix trie和Merkle trie。实际上，它们并不用于raw，以太坊将它们混合在一起，创建了一个更加优化的新trie，并命名为Patricia trie。这一集为我们理解帕特丽夏·特里做了准备。</p><blockquote class="ke kf kg"><p id="190e" class="jf jg kh jh b ji jj jk jl jm jn jo jp ki jr js jt kj jv jw jx kk jz ka kb kc hm dt translated">如果你从未听说过trie或tries，不要担心<em class="ii">👌</em>。它们非常容易理解。</p></blockquote></div><div class="ab cl kl km hb kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hm hn ho hp hq"><p id="3e3a" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh ij"> <em class="kh">特里</em> </strong></p><p id="cc80" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">Trie是在科学计算机中表示数字树的单词或术语。有时，我们可以看到“树”被使用，这是可以的，因为同样的意思。</p><p id="3fc9" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">换句话说，trie是一个有序的数据结构，用于存储一个动态集合或关联数组，它是由键值组成的，其中的键通常是字符串。</p><figure class="kt ku kv kw fq hv fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/c8eb3686041244e4c893b172f11818b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*HfIjvZVmQDS3SLBSQQjUPw.png"/></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Trie.</figcaption></figure><p id="af40" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">通过上图，我们可以熟悉一些术语。此外，根、内部节点、叶的集合将被称为公共节点。</p><p id="84ae" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh ij"> <em class="kh">数据集</em> </strong></p><blockquote class="ke kf kg"><p id="5c95" class="jf jg kh jh b ji jj jk jl jm jn jo jp ki jr js jt kj jv jw jx kk jz ka kb kc hm dt translated">我们将在所有示例中使用这个数据样本。</p></blockquote><figure class="kt ku kv kw fq hv"><div class="bz el l di"><div class="kx ky l"/></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Dataset.</figcaption></figure><p id="ecd4" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在数据集中，键是字符串，值是整数。</p><p id="044a" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh ij"> <em class="kh">基数trie </em> </strong></p><blockquote class="ke kf kg"><p id="1748" class="jf jg kh jh b ji jj jk jl jm jn jo jp ki jr js jt kj jv jw jx kk jz ka kb kc hm dt translated">基数trie用于优化搜索🔭。</p></blockquote><p id="e327" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在radix trie中，数据集中的键将是到达值的路径。</p><figure class="kt ku kv kw fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff kz"><img src="../Images/e37925f30010ac9e35fe8e161d8b9214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*63j3Atxj8-BXva0gc1unPg.png"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Basic radix trie.</figcaption></figure><p id="052c" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">正如你所看到的，trie的每个路径代表一个ASCII字符，它用于搜索值。</p><p id="d9e3" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">例如，我们正在寻找key的值，即<code class="eh la lb lc ld b">dodo</code>。就从根开始，尝试先寻找<code class="eh la lb lc ld b">d</code>路径，并沿着整个路径继续下降。最终结果是红线和绿色节点，值为<code class="eh la lb lc ld b">4</code>。</p><figure class="kt ku kv kw fq hv fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/3561a201c7df95590b2bdbc8a70a6e52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*NHxr2WRTEnhnGSc3Ua-BfQ.png"/></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Radix trie.</figcaption></figure><p id="608c" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">但是，<code class="eh la lb lc ld b">house</code>和<code class="eh la lb lc ld b">houses</code>键的分支被降级，带有<code class="eh la lb lc ld b">null</code>值的内部节点太多。为了达到<code class="eh la lb lc ld b">houses</code>的值，我们必须沿着路径下降很多次。这会造成空间浪费。</p><p id="07f4" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">因此，可以通过组合降级路径来改进它。现在，路径不是由单个字符表示的，而是一个字符串。</p><p id="eddc" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们对基数trie进行了改进，如下图所示。</p><p id="6ec6" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">为了到达<code class="eh la lb lc ld b">houses</code>节点，我们只需要下降两次，这似乎对搜索很有好处。</p><p id="fc37" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh ij"> <em class="kh">默克尔特里</em> </strong></p><blockquote class="ke kf kg"><p id="26ba" class="jf jg kh jh b ji jj jk jl jm jn jo jp ki jr js jt kj jv jw jx kk jz ka kb kc hm dt translated">Merkle trie用于验证数据</p></blockquote><p id="0726" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在merkle trie中，它的数据被用来创建一个确定性的加密散列来帮助认证数据。</p><p id="5bb7" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">为了获得细节，我们举一个例子:</p><figure class="kt ku kv kw fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff le"><img src="../Images/d8226f2ba96f8569fb0f35bd9506449c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cs5Tz_KhujwZvbhiGYIPSw.png"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Merkle trie.</figcaption></figure><p id="c63c" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">全部数据将存储在树叶中。那些叶子的父值将等于<code class="eh la lb lc ld b">Hash(valueOfChild1, valueOfChild2, …)</code>。</p><figure class="kt ku kv kw fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff le"><img src="../Images/660506cadba3019889a7ff498b4533ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ek_kD6yb88-bLE5oqnHKyQ.png"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Deterministic cryptographic hash.</figcaption></figure><p id="fc12" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">如果我们尝试将第四个节点的值更改为44。因此，从第4个节点到根的路径上的父节点将完全改变，<code class="eh la lb lc ld b">H2 → H’2 | H5 → H’5 | Root → NewRoot</code>。</p><p id="428b" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">因此，如果我们持有根的值，我们可以通过重建trie来获得根并将其与我们的根进行比较，从而验证数据的一致性。实际上，不改变根的值是不可能伪造数据的。</p><p id="cb90" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh ij">T3】结论&amp;参考文献T5】</strong></p><p id="4558" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">通过理解这两种方法，我们就接近了最终目标。</p><figure class="kt ku kv kw fq hv fe ff paragraph-image"><div class="fe ff lf"><img src="../Images/cc8bb96ba2d5b3a84d241356551fbae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*GitHnEDKDHmKj7SSDvb9kA.jpeg"/></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Why did I write this series so long? Because it is a SERIES 😑</figcaption></figure><p id="ae2e" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">下一集，我将向你展示以太坊如何结合这些和一些改进来创建Patricia trie，它有更多优化的东西，并且还保留了主要的属性，即优化搜索和确定性加密。</p><div class="hs ht fm fo hu lg"><a href="https://en.wikipedia.org/wiki/Radix_tree" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab ej"><div class="li ab lj cl cj lk"><h2 class="bd ij fv z el ll eo ep lm er et ih dt translated">基数树-维基百科</h2><div class="ln l"><h3 class="bd b fv z el ll eo ep lm er et ek translated">在计算机科学中，基数树(也叫基数trie或紧凑前缀树)是一种数据结构，它表示一个…</h3></div><div class="lo l"><p class="bd b gc z el ll eo ep lm er et ek translated">en.wikipedia.org</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu ia lg"/></div></div></a></div><div class="hs ht fm fo hu lg"><a href="https://en.wikipedia.org/wiki/Merkle_tree" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab ej"><div class="li ab lj cl cj lk"><h2 class="bd ij fv z el ll eo ep lm er et ih dt translated">默克尔树-维基百科</h2><div class="ln l"><h3 class="bd b fv z el ll eo ep lm er et ek translated">在密码学和计算机科学中，散列树或Merkle树是这样一种树，其中每个叶节点都标有…</h3></div><div class="lo l"><p class="bd b gc z el ll eo ep lm er et ek translated">en.wikipedia.org</p></div></div><div class="lp l"><div class="lv l lr ls lt lp lu ia lg"/></div></div></a></div><div class="hs ht fm fo hu lg"><a href="https://github.com/ethereum/wiki/wiki/Patricia-Tree" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab ej"><div class="li ab lj cl cj lk"><h2 class="bd ij fv z el ll eo ep lm er et ih dt translated">以太坊/维基</h2><div class="ln l"><h3 class="bd b fv z el ll eo ep lm er et ek translated">维基-以太坊维基-</h3></div><div class="lo l"><p class="bd b gc z el ll eo ep lm er et ek translated">github.com</p></div></div><div class="lp l"><div class="lw l lr ls lt lp lu ia lg"/></div></div></a></div><blockquote class="lx"><p id="43ee" class="ly lz ii bd ma mb mc md me mf mg kc ek translated"><a class="ae kd" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mi mj mk ml mm hv fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mh"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>