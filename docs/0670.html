<html>
<head>
<title>Ethernaut —Naught Coin (ERC20) Exploitation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太币-零币(ERC20)开发</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethernaut-naught-coin-erc20-exploitation-218c86bb953b?source=collection_archive---------5-----------------------#2018-06-01">https://medium.com/coinmonks/ethernaut-naught-coin-erc20-exploitation-218c86bb953b?source=collection_archive---------5-----------------------#2018-06-01</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk iq ir is it fe ff paragraph-image"><div class="ab fr cl iu"><img src="../Images/d422c977f16a1ef9cfe5889f4d45c350.png" data-original-src="https://miro.medium.com/v2/format:webp/1*8ivGGKYvMP0Vn0aTWm6aAw.png"/></div></figure><h1 id="60bd" class="ix iy ht bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju dt translated">背景</h1><p id="018f" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">在过去的一周半时间里，我一直在努力熟悉以太坊智能合约及其使用Solidity的实现。考虑到这一点，到目前为止，我只是玩了玩开发、部署，然后与我在本地testnet上创建的基本Solidity契约进行交互。考虑到这一点，我没有根据Consensys在这里记录的一些已知攻击来创建自己的易受攻击的合同，我四处寻找以太坊合同的捕获旗帜风格挑战。就在那时，我无意中发现了<a class="ku kv gr" href="https://medium.com/u/4e5199c3ee0a?source=post_page-----218c86bb953b--------------------------------" rel="noopener" target="_blank">齐柏林飞船</a>的一系列以太挑战，并决定处理他们制造的问题。</p><h1 id="69fe" class="ix iy ht bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju dt translated">宝宝的第一个ERC20代币！</h1><p id="54d4" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">在深入研究了这些挑战之后，我决定开始着手零硬币挑战。这一挑战涉及识别ERC20令牌实施中的漏洞。这种实现使得玩家在合同创建时接收到全部代币供应。有一个问题是，玩家必须等待10年才能转让或使用任何代币——或者这至少是它应该要求的。为了完成这一挑战，玩家必须成功地将合同创建者的所有代币转移到另一个帐户，而无需等待10年。</p><h1 id="645f" class="ix iy ht bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju dt translated">入门指南</h1><h2 id="df8e" class="kw iy ht bd iz kx ky kz jd la lb lc jh kg ld le jl kk lf lg jp ko lh li jt lj dt translated">概念前提</h2><p id="6768" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">根据齐柏林飞船的难度等级，这个挑战的难度是5/6。在我看来，这是因为需要对可靠性契约继承和变量状态(特别是映射)有扎实的理解。除此之外，还需要理解一个基本的ERC20令牌是如何工作的(稍后会谈到)。</p><h2 id="e605" class="kw iy ht bd iz kx ky kz jd la lb lc jh kg ld le jl kk lf lg jp ko lh li jt lj dt translated">测试环境</h2><p id="a7f7" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">以太挑战集已经为玩家在Ropsten测试网络上的使用而设置，并且可以通过带有JavaScript界面的玩家浏览器控制台进行交互。</p><p id="50d2" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">尽管如此，我还是决定使用浏览器本地测试环境，以避免设置Ropsten帐户进行测试。为此，我使用了浏览器版本的Remix，可以在这里找到<a class="ae kt" href="https://remix.ethereum.org" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="e7b0" class="kw iy ht bd iz kx ky kz jd la lb lc jh kg ld le jl kk lf lg jp ko lh li jt lj dt translated">为混音准备NaughtCoin(浏览器版本)</h2><p id="669b" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">NaughtCoin挑战赛的原始源代码已粘贴在下面，但是，必须进行更改，以便在浏览器版本的Remix中正常工作。如果对Ethernaut提供的给定实例使用MetaMask和Ropsten，则可以安全地忽略这一点，并且可以按原样执行该质询的所有其他步骤。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="f994" class="kw iy ht lu b fv ly lz l ma mb">pragma solidity ^0.4.18;<br/><br/>import 'zeppelin-solidity/contracts/token/ERC20/StandardToken.sol';<br/><br/> contract NaughtCoin is StandardToken {<br/><br/>  string public constant name = 'NaughtCoin';<br/>  string public constant symbol = '0x0';<br/>  uint public constant decimals = 18;<br/>  uint public timeLock = now + 10 years;<br/>  uint public INITIAL_SUPPLY = 1000000 * (10 ** decimals);<br/>  address public player;<br/><br/>  function NaughtCoin(address _player) public {<br/>    player = _player;<br/>    totalSupply_ = INITIAL_SUPPLY;<br/>    balances[player] = INITIAL_SUPPLY;<br/>    Transfer(0x0, player, INITIAL_SUPPLY);<br/>  }<br/>  <br/>  function transfer(address _to, uint256 _value) lockTokens public returns(bool) {<br/>    super.transfer(_to, _value);<br/>  }<br/><br/>  // Prevent the initial owner from transferring tokens until the timelock has passed<br/>  modifier lockTokens() {<br/>    if (msg.sender == player) {<br/>      require(now &gt; timeLock);<br/>      if (now &lt; timeLock) {<br/>        _;<br/>      }<br/>    } else {<br/>     _;<br/>    }<br/>  } <br/>}</span></pre><p id="7a46" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">为了在基于浏览器的重新混合中进行测试，必须进行以下更改:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="cc3d" class="kw iy ht lu b fv ly lz l ma mb">import 'zeppelin-solidity/contracts/token/ERC20/StandardToken.sol';</span></pre><p id="2cb4" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">必须更改为:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="f990" class="kw iy ht lu b fv ly lz l ma mb">import '<a class="ae kt" href="https://github.com/OpenZeppelin/zeppelin-solidity/contracts/token/ERC20/StandardToken.sol'" rel="noopener ugc nofollow" target="_blank">https://github.com/OpenZeppelin/zeppelin-solidity/contracts/token/ERC20/StandardToken.sol'</a>;</span></pre><p id="0fd1" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">进行这一更改将允许导入在编译的依赖链上正确发生，然后Remix会将源代码导入Remix编辑器的侧面板:</p><figure class="lp lq lr ls fq it fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/4449b58a113d6eea8ce5a8cbef8d3e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*k4nCD0w8_TU9BprVSjHkbg.png"/></div></figure><h1 id="38c8" class="ix iy ht bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju dt translated">浅析诺顿硬币</h1><p id="2d84" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">为了开始分析这个挑战，我首先仔细列举了Ethernaut挑战中提供的<code class="eh md me mf lu b">NaughtCoin</code>实现。为了做到这一点，我将这种方法分解成逻辑进展，并在下面详细说明。</p><h2 id="f668" class="kw iy ht bd iz kx ky kz jd la lb lc jh kg ld le jl kk lf lg jp ko lh li jt lj dt translated">进口</h2><p id="42df" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">当我第一次开始挑战时，首先映入我眼帘的是这样一句话:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="7365" class="kw iy ht lu b fv ly lz l ma mb">contract NaughtCoin is StandardToken</span></pre><p id="6d5c" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">如果我想了解NaughtCoin是什么，我需要先确定什么是T1，因为<code class="eh md me mf lu b">NaughtCoin</code>是从它派生出来的。因此，看着<code class="eh md me mf lu b">import</code> ed契约，我决定开始沿着导入和实现的链条走下去。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="5ce2" class="kw iy ht lu b fv ly lz l ma mb">import 'zeppelin-solidity/contracts/token/ERC20/StandardToken.sol';</span></pre><p id="5901" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">从<code class="eh md me mf lu b">StandardToken</code>追踪，确定了以下进口和实施:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="fea7" class="kw iy ht lu b fv ly lz l ma mb">import "./BasicToken.sol";<br/>import "./ERC20.sol";</span><span id="6db1" class="kw iy ht lu b fv mg lz l ma mb">contract StandardToken is ERC20, BasicToken</span></pre><p id="c9c2" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">因此，<code class="eh md me mf lu b">BasicToken</code>和<code class="eh md me mf lu b">ERC20</code>被导入，然后在<code class="eh md me mf lu b">StandardToken</code>的实现中被继承。</p><p id="ada0" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">从<code class="eh md me mf lu b">BasicToken</code>继续，确定了以下导入和实施:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="d19e" class="kw iy ht lu b fv ly lz l ma mb">import "./ERC20Basic.sol";<br/>import "../../math/SafeMath.sol";</span><span id="a3fb" class="kw iy ht lu b fv mg lz l ma mb">contract BasicToken is ERC20Basic</span></pre><p id="c219" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">根据<code class="eh md me mf lu b">BasicToken</code>契约的定义，<code class="eh md me mf lu b">BasicToken</code>从导入的<code class="eh md me mf lu b">ERC20Basic</code>继承，并使用<code class="eh md me mf lu b">SafeMath</code>库。为了简洁起见，跳过了<code class="eh md me mf lu b">SafeMath</code>库，因为它与包含在该跟踪中无关。最后，<code class="eh md me mf lu b">ERC20Basic</code>不需要派生任何其他契约。</p><p id="4d2a" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">跳回到<code class="eh md me mf lu b">StandardToken</code>的实现，<code class="eh md me mf lu b">ERC20</code>也是从。通过跟踪该导入，确定了以下导入和实现:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="1cc3" class="kw iy ht lu b fv ly lz l ma mb">import "./ERC20Basic.sol";</span><span id="8c52" class="kw iy ht lu b fv mg lz l ma mb">contract ERC20 is ERC20Basic</span></pre><p id="ad56" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">与<code class="eh md me mf lu b">BasicToken</code>类似，<code class="eh md me mf lu b">ERC20</code>也是从<code class="eh md me mf lu b">ERC20Basic</code>继承而来，因为共享继承，所以不需要任何进一步的追踪。</p><p id="7324" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">为了方便参考，我在下面创建了一个基本的继承流程图。</p><figure class="lp lq lr ls fq it fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/1aed5c67686f4f034ba3664ebd966f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*M2kXSPd1_ZjPIqJcQHYcBw.png"/></div></figure><h2 id="5dc7" class="kw iy ht bd iz kx ky kz jd la lb lc jh kg ld le jl kk lf lg jp ko lh li jt lj dt translated">NaughtCoin合同变量</h2><p id="4f9a" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">跳过导入和继承，我的下一个重点是在<code class="eh md me mf lu b">NaughtCoin</code>中定义变量。<code class="eh md me mf lu b">NaughtCoin</code>中的定义(但不包括所有继承的定义)如下:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="4b9b" class="kw iy ht lu b fv ly lz l ma mb">string public constant name = 'NaughtCoin';<br/>string public constant symbol = '0x0';<br/>uint public constant decimals = 18;<br/>uint public timeLock = now + 10 years;<br/>uint public INITIAL_SUPPLY = 1000000 * (10 ** decimals);<br/>address public player;</span></pre><p id="80a5" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">对我们来说特别重要的是<code class="eh md me mf lu b">timeLock</code>和<code class="eh md me mf lu b">player</code>变量。<code class="eh md me mf lu b">timeLock</code>定义提供了10年期限，挑战描述为在进行代币交易之前需要的期限，而<code class="eh md me mf lu b">player</code>变量是收到所有<code class="eh md me mf lu b">INITIAL_SUPPLY</code>代币的玩家的地址。</p><h2 id="6cce" class="kw iy ht bd iz kx ky kz jd la lb lc jh kg ld le jl kk lf lg jp ko lh li jt lj dt translated">NaughtCoin构造函数</h2><p id="7159" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">相关的NaughtCoin构造函数代码已包含在下面，以供参考:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="4f4e" class="kw iy ht lu b fv ly lz l ma mb">function NaughtCoin(address _player) public {<br/>    player = _player;<br/>    totalSupply_ = INITIAL_SUPPLY;<br/>    balances[player] = INITIAL_SUPPLY;<br/>    Transfer(0x0, player, INITIAL_SUPPLY);<br/>}</span></pre><p id="4b91" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">当<code class="eh md me mf lu b">NaughtCoin</code>合同展开时，需要<code class="eh md me mf lu b">player</code>的地址并随后存储。这几乎等同于大多数合同中<code class="eh md me mf lu b">owner</code>的标准用法，并且对于涉及令牌传输的操作很重要(我们将在后面加以利用)。</p><p id="552c" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated"><code class="eh md me mf lu b">totalSupply</code>也被存储并初始化为<code class="eh md me mf lu b">INITIAL_SUPPLY</code>的值。尽管如此，初始化期间发生的更有趣的分配是<code class="eh md me mf lu b">balances[player]</code>。该分配在<code class="eh md me mf lu b">balances</code>映射中为<code class="eh md me mf lu b">player</code>的地址创建一个条目，值为<code class="eh md me mf lu b">INITIAL_SUPPLY</code>。初始化时，<code class="eh md me mf lu b">player</code>是唯一存在且有余额的条目。因此，要获得NaughtCoin，其他地址必须从初始化<code class="eh md me mf lu b">NaughtCoin</code>合同的<code class="eh md me mf lu b">player</code>接收到转移。但是，再一次，回到挑战描述，这应该是不可能的，直到自初始化以来的10年时间之后。</p><h2 id="56b3" class="kw iy ht bd iz kx ky kz jd la lb lc jh kg ld le jl kk lf lg jp ko lh li jt lj dt translated"><code class="eh md me mf lu b">lockTokens</code>修饰词</h2><p id="7ca6" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">相关<code class="eh md me mf lu b">lockTokens</code>修改器源代码已经收录如下，仅供参考:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="f0c6" class="kw iy ht lu b fv ly lz l ma mb">modifier lockTokens() {<br/>    if (msg.sender == player) {<br/>      require(now &gt; timeLock);<br/>      if (now &lt; timeLock) {<br/>        _;<br/>      }<br/>    } else {<br/>     _;<br/>    }<br/>}</span></pre><p id="4ec1" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">在这个挑战中，<code class="eh md me mf lu b">lockTokens</code>修饰语最初在我看来是最重要的，主要是因为它被应用于<code class="eh md me mf lu b">transfer</code>功能，允许特定的发送者在<code class="eh md me mf lu b">balances</code>的范围内将令牌从一个地址转移到另一个地址。</p><p id="0d45" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">对于分析的这一部分来说，重要的是要理解修饰语(这里的正式文件<a class="ae kt" href="http://solidity.readthedocs.io/en/v0.4.21/contracts.html#function-modifiers" rel="noopener ugc nofollow" target="_blank"/>)是封装对特定函数的调用的东西。如果您想在任意函数调用之前或之后执行操作，修饰符是调用这些操作的方法。阅读修饰语的一个简单方法是将<code class="eh md me mf lu b">_</code>视为函数体(想想函数的源代码:<code class="eh md me mf lu b">function lol() public { /* everything in here */ }</code>)。</p><p id="d7ef" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">当第一次分析<code class="eh md me mf lu b">lockTokens</code>时，如果您是<code class="eh md me mf lu b">msg.sender</code>(执行呼叫的人)，并且您也是发起<code class="eh md me mf lu b">NaughtCoin</code>的玩家，您将在if语句的第一个分支内继续执行:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="2a8e" class="kw iy ht lu b fv ly lz l ma mb">if (msg.sender == player) {<br/>    require(now &gt; timeLock);<br/>    if (now &lt; timeLock) {<br/>      _;<br/>    }<br/>}</span></pre><p id="ea44" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">这是<code class="eh md me mf lu b">require</code>街区检查的地方，以确保<code class="eh md me mf lu b">timeLock</code>已经过去了10年。如果没有，将发生<code class="eh md me mf lu b">revert</code>(重置合同的修改状态并产生错误)。if语句检查<code class="eh md me mf lu b">now</code>(当前日期/时间)是否小于<code class="eh md me mf lu b">timeLock</code>，如果是，将执行函数体。</p><p id="7a8f" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">根据我们的分析，我们已经确定，如果我们使用<code class="eh md me mf lu b">player</code>以外的账户进行呼叫，我们将无法通过<code class="eh md me mf lu b">msg.sender == player</code>检查。此外，我们永远无法通过这个块中的<code class="eh md me mf lu b">require</code>和<code class="eh md me mf lu b">if</code>语句实现函数执行，因为它们相互矛盾。正因为如此，<code class="eh md me mf lu b">transfer</code>函数变得非常无用，因为我们永远无法从<code class="eh md me mf lu b">player</code>调用范围实现执行。因此，我们无法使用<code class="eh md me mf lu b">transfer</code>功能成功将令牌移动到另一个地址余额。</p><h2 id="6080" class="kw iy ht bd iz kx ky kz jd la lb lc jh kg ld le jl kk lf lg jp ko lh li jt lj dt translated">n硬币传递函数</h2><p id="9d8d" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">相关<code class="eh md me mf lu b">transfer</code>修改器源代码已经收录如下，仅供参考:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="f268" class="kw iy ht lu b fv ly lz l ma mb">function transfer(address _to, uint256 _value) lockTokens public returns(bool) {<br/>    super.transfer(_to, _value);<br/>}</span></pre><p id="8cf5" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">最后但同样重要的是<code class="eh md me mf lu b">transfer</code>功能。该函数只调用<code class="eh md me mf lu b">StandardToken</code>使用<code class="eh md me mf lu b">super</code>实现<code class="eh md me mf lu b">transfer</code>函数，因为<code class="eh md me mf lu b">NaughtCoin</code>继承了<code class="eh md me mf lu b">StandardToken</code>。</p><p id="12ae" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">然而，更重要的是,<code class="eh md me mf lu b">lockTokens</code>修饰符被应用于<code class="eh md me mf lu b">transfer</code>函数。因此，基于我们之前对<code class="eh md me mf lu b">lockTokens</code>修改器的分析，我们已经确定我们将永远无法执行<code class="eh md me mf lu b">super.transfer(...)</code>，因为我们永远无法绕过<code class="eh md me mf lu b">timeLock</code>检查。</p><h2 id="4d3f" class="kw iy ht bd iz kx ky kz jd la lb lc jh kg ld le jl kk lf lg jp ko lh li jt lj dt translated">结论</h2><p id="de94" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">基于我们目前为止的发现，我们已经确定<code class="eh md me mf lu b">transfer</code>功能是完全禁止的！然而，这让我们没有什么习俗可以分析。相反，我们现在被迫研究<code class="eh md me mf lu b">StandardToken</code>的实现，以进一步了解如何耗尽<code class="eh md me mf lu b">player</code>的余额！</p><h1 id="be05" class="ix iy ht bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju dt translated">超越naught coin——Zeppelin ERC 20功能实现分析</h1><p id="9af7" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">之前在执行对<code class="eh md me mf lu b">NaughtCoin</code>的导入和继承的分析时，我们确定了导入和继承的链。这很重要，因为它实际上在<code class="eh md me mf lu b">NaughtCoin</code>中公开了大量额外的功能。特别是，我们正在寻找能够在10年时间锁定之前修改<code class="eh md me mf lu b">balances</code>的功能，并将<code class="eh md me mf lu b">balances[player]</code>中的内容分配给我们选择的<code class="eh md me mf lu b">balances[notPlayer]</code>。</p><h2 id="e46c" class="kw iy ht bd iz kx ky kz jd la lb lc jh kg ld le jl kk lf lg jp ko lh li jt lj dt translated">ERC20接口规范</h2><p id="b1cd" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">为了使令牌与ERC20规范兼容，它必须实现以下接口。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="396c" class="kw iy ht lu b fv ly lz l ma mb">// ERC Token Standard #20 Interface</span><span id="c148" class="kw iy ht lu b fv mg lz l ma mb">// <a class="ae kt" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md" rel="noopener ugc nofollow" target="_blank">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md</a></span><span id="1547" class="kw iy ht lu b fv mg lz l ma mb">contract ERC20Interface {</span><span id="0983" class="kw iy ht lu b fv mg lz l ma mb">function totalSupply() public constant returns (uint);</span><span id="998a" class="kw iy ht lu b fv mg lz l ma mb">function balanceOf(address tokenOwner) public constant returns (uint balance);</span><span id="031b" class="kw iy ht lu b fv mg lz l ma mb">function allowance(address tokenOwner, address spender) public constant returns (uint remaining);</span><span id="b530" class="kw iy ht lu b fv mg lz l ma mb">function transfer(address to, uint tokens) public returns (bool success);</span><span id="4a57" class="kw iy ht lu b fv mg lz l ma mb">function approve(address spender, uint tokens) public returns (bool success);</span><span id="ae51" class="kw iy ht lu b fv mg lz l ma mb">function transferFrom(address from, address to, uint tokens) public returns (bool success);</span><span id="5e4b" class="kw iy ht lu b fv mg lz l ma mb">event Transfer(address indexed from, address indexed to, uint tokens);</span><span id="4f08" class="kw iy ht lu b fv mg lz l ma mb">event Approval(address indexed tokenOwner, address indexed spender, uint tokens);</span><span id="869e" class="kw iy ht lu b fv mg lz l ma mb">}</span></pre><p id="6fcd" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">该规范是最流行的规范之一，这使得找到更多的文档变得非常容易。但是，我粘贴了规范接口，因为这在完成这个挑战解决方案时参考起来会非常有用。</p><h2 id="627d" class="kw iy ht bd iz kx ky kz jd la lb lc jh kg ld le jl kk lf lg jp ko lh li jt lj dt translated">识别有趣的功能</h2><p id="6566" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">为了开始确定我应该首先查看哪里，我发现仅仅查看ERC20接口就给了我一些我想要进一步查看的方法。特别是第一个跳出来给我看的函数是<code class="eh md me mf lu b">transferFrom</code>函数。我们已经发现<code class="eh md me mf lu b">NaughtCoin</code>的<code class="eh md me mf lu b">transfer</code>实现被<code class="eh md me mf lu b">lockTokens</code>修饰符变得无用，但是<code class="eh md me mf lu b">NaughtCoin</code>没有实现<code class="eh md me mf lu b">transferFrom</code>函数，这意味着<code class="eh md me mf lu b">transferFrom</code>的<code class="eh md me mf lu b">StandardToken</code>实现正在被调用。</p><p id="27a6" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">推断出这一点后，<code class="eh md me mf lu b">transferFrom</code>实际上做什么的问题是我们耗尽一些硬币的旅程中要解决的下一个问题。</p><h2 id="c728" class="kw iy ht bd iz kx ky kz jd la lb lc jh kg ld le jl kk lf lg jp ko lh li jt lj dt translated">分析transferFrom的实现</h2><p id="e0af" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">在<code class="eh md me mf lu b">StandardToken.sol</code>中找到的相关<code class="eh md me mf lu b">transferFrom</code>函数源代码已包含在下面以供参考:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="bca7" class="kw iy ht lu b fv ly lz l ma mb">function transferFrom(<br/>  address _from,<br/>  address _to,<br/>  uint256 _value<br/>)<br/>  public<br/>  returns (bool)<br/>{<br/>  require(_to != address(0));<br/>  require(_value &lt;= balances[_from]);<br/>  require(_value &lt;= allowed[_from][msg.sender]);<br/><br/>  balances[_from] = balances[_from].sub(_value);<br/>  balances[_to] = balances[_to].add(_value);<br/>  allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);<br/>  emit Transfer(_from, _to, _value);<br/>  return true;<br/>}</span></pre><p id="66f8" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">在阅读<code class="eh md me mf lu b">transferFrom</code>函数的源代码时，似乎它允许第三方将指定数量的令牌从一个帐户转移到另一个帐户。这是通过阅读转移要求(函数体的前三行)得出的。</p><p id="594c" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">在第一个<code class="eh md me mf lu b">require</code>中，<code class="eh md me mf lu b">_to</code>函数参数与<code class="eh md me mf lu b">address(0)</code>值进行比较。对<code class="eh md me mf lu b">address(0)</code>值做了一点研究，发现<code class="eh md me mf lu b">address(0)</code>有时被<a class="ae kt" href="https://ethereum.stackexchange.com/questions/42717/what-does-address0-mean/42718#42718" rel="noopener ugc nofollow" target="_blank">用作焚烧令牌</a>的地址。更重要的是，这是一个没有人能控制的地址。因此，这个<code class="eh md me mf lu b">require</code>检查以确保某人不能随意烧毁令牌(这对我们来说是可行的，因为我们只想从<code class="eh md me mf lu b">balances[player]</code>中耗尽令牌)。接下来，检查传递给该函数的<code class="eh md me mf lu b">_value</code>以确保<code class="eh md me mf lu b">_from</code>的余额更大。这可以防止任何人提取超过可用数量的代币。最后，最后一个<code class="eh md me mf lu b">require</code>正在检查以确保传递的<code class="eh md me mf lu b">_value</code>小于或等于允许<code class="eh md me mf lu b">msg.sender</code>代表<code class="eh md me mf lu b">_from</code>管理的<code class="eh md me mf lu b">allowed</code>令牌数量。这个函数体的其余部分只包含适当地将令牌从<code class="eh md me mf lu b">balances[_from]</code>传输到<code class="eh md me mf lu b">balances[_to]</code>的逻辑。</p><p id="57f8" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">从这个函数中得到的重要收获是，我们在这个契约中发现了一个新的重要变量:<code class="eh md me mf lu b">allowed</code>映射。似乎基于第三个<code class="eh md me mf lu b">require</code>，如果我们有一个<code class="eh md me mf lu b">player</code>的条目作为<code class="eh md me mf lu b">_from</code>(例如<code class="eh md me mf lu b">allowed[player]</code>),一个<code class="eh md me mf lu b">allowed</code><code class="eh md me mf lu b">_to</code>的子条目(例如<code class="eh md me mf lu b">allowed[player]</code>),以及除了<code class="eh md me mf lu b">address(0)</code>之外的任何其他地址作为<code class="eh md me mf lu b">_to</code>，我们就可以使用<code class="eh md me mf lu b">transferFrom</code>。</p><p id="611e" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">基于<code class="eh md me mf lu b">transferFrom</code>中的发现，我们现在知道，如果我们希望能够通过<code class="eh md me mf lu b">transferFrom</code>函数修改<code class="eh md me mf lu b">balances</code>，我们首先需要在<code class="eh md me mf lu b">allowed</code>中有一个用于<code class="eh md me mf lu b">player</code>的条目，它似乎定义了一个被管理的账户，以及在<code class="eh md me mf lu b">allowed</code>中该条目下的对应地址，它似乎是一个管理顶级账户的账户<code class="eh md me mf lu b">allowed</code>，直到由<code class="eh md me mf lu b">allowed[player][managerAccount]</code>的返回所定义的特定数量的令牌。</p><h2 id="7493" class="kw iy ht bd iz kx ky kz jd la lb lc jh kg ld le jl kk lf lg jp ko lh li jt lj dt translated">搜索津贴(批准)</h2><p id="24e7" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">在<code class="eh md me mf lu b">StandardToken.sol</code>中找到的相关<code class="eh md me mf lu b">approve</code>函数源代码已包含在下面以供参考:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="fd63" class="kw iy ht lu b fv ly lz l ma mb">function approve(address _spender, uint256 _value) public returns (bool) {<br/>  allowed[msg.sender][_spender] = _value;<br/>  emit Approval(msg.sender, _spender, _value);<br/>  return true;<br/>}</span></pre><p id="3654" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">现在，我们已经确定了使用<code class="eh md me mf lu b">transferFrom</code>执行转移所需的约束，我们需要将约束融入到<code class="eh md me mf lu b">allowed</code>映射中。回头参考ERC20接口规范，有一个名为<code class="eh md me mf lu b">approve</code>的函数，它接受<code class="eh md me mf lu b">spender</code>的地址和一个uint <code class="eh md me mf lu b">tokens</code>。</p><p id="b5fc" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">类似于<code class="eh md me mf lu b">transferFrom</code>函数，<code class="eh md me mf lu b">StandardToken</code>似乎也提供了<code class="eh md me mf lu b">approve</code>函数的实现。在这个函数中，它构建了精确的<code class="eh md me mf lu b">allowed</code>层次结构，只要<code class="eh md me mf lu b">msg.sender</code>是<code class="eh md me mf lu b">player</code>并且<code class="eh md me mf lu b">spender</code>是我们希望给予令牌的帐户，我们就需要拥有使用<code class="eh md me mf lu b">transferFrom</code>的权限。</p><h1 id="ae67" class="ix iy ht bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju dt translated">将所有这些放在一起——开发NaughtCoin</h1><p id="cebd" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">根据我们现在掌握的信息，我们应该拥有成功使用<code class="eh md me mf lu b">transferFrom</code>所需的所有调用。漏洞链详细描述如下。</p><figure class="lp lq lr ls fq it fe ff paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="fe ff mi"><img src="../Images/a53f6bf28fb9a114e0fb95fc4a01de03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbGe-16aor3DFgHOMEUV0g.png"/></div></div></figure><p id="9c84" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">最初，<code class="eh md me mf lu b">player</code>是代币/契约的<code class="eh md me mf lu b">owner</code>，契约用<code class="eh md me mf lu b">balances[owner]=INITIAL_SUPPLY</code>初始化。因此，我们面临的挑战是将资金注入一个我们可以控制的账户——T4。为了做到这一点，我们发现我们有能力调用<code class="eh md me mf lu b">transferFrom</code>函数来绕过<code class="eh md me mf lu b">lockTokens</code>修饰符，并将一定数量的令牌从一个帐户转移到另一个帐户。一个问题是要求执行转账的帐户是<code class="eh md me mf lu b">allowed</code>来执行操作，并带有特定数量的令牌。因此，我们继续调用<code class="eh md me mf lu b">approve</code>函数作为<code class="eh md me mf lu b">player</code> ( <code class="eh md me mf lu b">owner</code>)，将<code class="eh md me mf lu b">exfil_address</code>作为批准的支出者，将允许支出的代币总数作为<code class="eh md me mf lu b">INITIAL_SUPPLY</code>。一旦批准，这将允许<code class="eh md me mf lu b">exfil_address</code>将令牌的<code class="eh md me mf lu b">INITIAL_SUPPLY</code>从<code class="eh md me mf lu b">player</code> ( <code class="eh md me mf lu b">owner</code>)转移到<code class="eh md me mf lu b">exfil_address</code>。因此，我们已经成功地在10年的<code class="eh md me mf lu b">timeLock</code>期之前耗尽了<code class="eh md me mf lu b">player</code>的代币。</p><p id="1eae" class="pw-post-body-paragraph jv jw ht jx b jy lk ka kb kc ll ke kf kg lm ki kj kk ln km kn ko lo kq kr ks hm dt translated">漏洞中详细描述的调用可以通过使用内存执行和5个默认帐户，通过浏览器版本重新混合来轻松执行。只需要两个帐户——一个用于部署NaughtCoin契约和后续的<code class="eh md me mf lu b">approve</code>调用(这将填充侧栏中的现有契约),另一个用于将<code class="eh md me mf lu b">transferFrom</code>作为<code class="eh md me mf lu b">exfil_account</code>调用。一旦部署了契约，就可以在Remix中严格遵循上图中的调用图来成功执行漏洞。</p><h1 id="24ee" class="ix iy ht bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju dt translated">结论</h1><p id="1006" class="pw-post-body-paragraph jv jw ht jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks hm dt translated">这个挑战是学习如何调试Solidity契约，以及理解执行范围如何修改契约的底层逻辑的一次疯狂之旅。这也是学习ERC20规范和实施的一个非常彻底的方法，因为你必须理解每一个主要功能，以便利用<code class="eh md me mf lu b">NaughtCoin</code>。</p></div></div>    
</body>
</html>