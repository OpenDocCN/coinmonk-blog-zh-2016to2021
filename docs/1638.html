<html>
<head>
<title>Use ‘secp256r1’ to create JWT. Can not use 'secp256k1' which is famous for Bitcoin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用“secp256r1”创建JWT。不能用以比特币闻名的‘secp 256k 1’</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/can-not-use-secp256k1-which-is-common-on-crypto-currency-to-create-jwt-d6685be35a66?source=collection_archive---------1-----------------------#2018-10-11">https://medium.com/coinmonks/can-not-use-secp256k1-which-is-common-on-crypto-currency-to-create-jwt-d6685be35a66?source=collection_archive---------1-----------------------#2018-10-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="184e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我研究以太坊上以自我主权身份平台闻名的uPort时，我奋力创建了JWT(uPort通过JWT实现了链外身份认证)。所以，我把我的经验记录下来，供未来的学习者参考。</p><p id="bda8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Gist上的工作示例代码:<a class="ae jo" href="https://gist.github.com/tak1827/1c1aa56eaf0f6f77896df29aa8a8b7dc" rel="noopener ugc nofollow" target="_blank">jwt-secp 256k 1-secp 256 r 1 . js</a></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/b96768b13e4bf97fc517563d118c5b42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FK9_fjSFpmvObarRwFvpcg.png"/></div></div></figure></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h2 id="4785" class="ki kj ht bd kk kl km kn ko kp kq kr ks jb kt ku kv jf kw kx ky jj kz la lb lc dt translated">发生错误</h2><p id="d655" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hm dt translated">我们可以使用<strong class="is hu"> ECDSA </strong>公/私钥对将JWT作为<a class="ae jo" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank">官方站点</a>进行签名。所以我写了如下的脚本。请注意，我将“secp256k1”指定为ECDSA曲线。</p><pre class="jq jr js jt fq li lj lk ll aw lm dt"><span id="e7b7" class="ki kj ht lj b fv ln lo l lp lq">const JWT = require('jsonwebtoken');<br/>const Elliptic = require('elliptic').ec;<br/>const EC = new Elliptic('secp256k1');// Use 'secp256k1'</span><span id="6cf3" class="ki kj ht lj b fv lr lo l lp lq">// Payload<br/>const payload = {<br/>  sub: 'Subject',<br/>  iss: 'Issuer',<br/>  exp: 1639248876<br/>}</span><span id="7a87" class="ki kj ht lj b fv lr lo l lp lq">// Generate private key<br/>const privateKey = EC.genKeyPair().getPrivate().toString(16);</span><span id="7817" class="ki kj ht lj b fv lr lo l lp lq">// Create token<br/>const token = JWT.sign(payload, privateKey, { algorithm: 'ES256'});</span></pre><p id="cafd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">预期结果是以下错误。</p><pre class="jq jr js jt fq li lj lk ll aw lm dt"><span id="3732" class="ki kj ht lj b fv ln lo l lp lq">Error: error:0906D06C:PEM routines:PEM_read_bio:no start line<br/>    at Sign.sign (crypto.js:331:26)<br/>    at sign (/work/node_modules/jwa/index.js:76:45)<br/>    at Object.sign (/work/node_modules/jwa/index.js:96:27)<br/>    at Object.jwsSign [as sign] (/work/node_modules/jws/lib/sign-stream.js:32:24)<br/>    at Object.module.exports [as sign] (/work/node_modules/jsonwebtoken/sign.js:188:21)<br/>    at Object.&lt;anonymous&gt; (/work/jwt.js:24:13)<br/>    at Module._compile (module.js:653:30)<br/>    at Object.Module._extensions..js (module.js:664:10)<br/>    at Module.load (module.js:566:32)<br/>    at tryModuleLoad (module.js:506:12)</span></pre></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h2 id="3e49" class="ki kj ht bd kk kl km kn ko kp kq kr ks jb kt ku kv jf kw kx ky jj kz la lb lc dt translated">原因是“secp256k1”</h2><p id="6890" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hm dt translated">我在解决这个错误时遇到了麻烦，但是我被<a class="ae jo" href="https://github.com/auth0/node-jsonwebtoken/issues/97" rel="noopener ugc nofollow" target="_blank">这个发布的问题</a>救了。</p><blockquote class="ls lt lu"><p id="b6f7" class="iq ir lv is b it iu iv iw ix iy iz ja lw jc jd je lx jg jh ji ly jk jl jm jn hm dt translated"><a class="ae jo" href="https://tools.ietf.org/html/rfc7518#section-3.4" rel="noopener ugc nofollow" target="_blank"> JWA规范</a>使用P-256和SHA-256 将<em class="ht"> ES256 </em>定义为<em class="ht"> ECDSA，其中<em class="ht"> P-256 </em>是<em class="ht"> secp256r1 </em>的另一个名称</em></p></blockquote><p id="263e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我知道只有“secp256r1”适用于JWT。为了安全起见，我确认了<a class="ae jo" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> RFC </a>，发现了以下文字。</p><blockquote class="ls lt lu"><p id="5c23" class="iq ir lv is b it iu iv iw ix iy iz ja lw jc jd je lx jg jh ji ly jk jl jm jn hm dt translated">使用P-256曲线的ECDSA</p></blockquote><p id="5571" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">P-256被<a class="ae jo" href="https://www.ietf.org/rfc/rfc5480.txt" rel="noopener ugc nofollow" target="_blank">定义</a>为secp256r1。</p></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h2 id="32b9" class="ki kj ht bd kk kl km kn ko kp kq kr ks jb kt ku kv jf kw kx ky jj kz la lb lc dt translated">创建JWT的正确方法</h2><p id="ef12" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hm dt translated">我显示正确的工作样本，为您创建JWT信息。请将“secp256r1”指定为ECDSA曲线。</p><pre class="jq jr js jt fq li lj lk ll aw lm dt"><span id="a0ec" class="ki kj ht lj b fv ln lo l lp lq">const JWT = require('jsonwebtoken');<br/>const ECDSA = require('ecdsa-secp256r1');// Use 'secp256r1'</span><span id="a2c1" class="ki kj ht lj b fv lr lo l lp lq">// Payload<br/>const payload = {<br/>  sub: 'Subject',<br/>  iss: 'Issuer',<br/>  exp: 1639248876<br/>}</span><span id="87ed" class="ki kj ht lj b fv lr lo l lp lq">// Genarate private key<br/>const privateKey = ECDSA.generateKey();</span><span id="4d8e" class="ki kj ht lj b fv lr lo l lp lq">// Retrive public key<br/>const publicKey = privateKey.asPublic();</span><span id="d717" class="ki kj ht lj b fv lr lo l lp lq">// Create token<br/>const token = JWT.sign(payload, privateKey.toPEM(), { algorithm: 'ES256'});</span><span id="ee98" class="ki kj ht lj b fv lr lo l lp lq">// Verify token<br/>const decoded = JWT.verify(token, publicKey.toPEM());</span><span id="575f" class="ki kj ht lj b fv lr lo l lp lq">console.log({ <br/>  privateKey: privateKey.toPEM(), <br/>  publicKey: publicKey.toPEM(), <br/>  token, <br/>  decoded <br/>});</span></pre><blockquote class="lz"><p id="0ca9" class="ma mb ht bd mc md me mf mg mh mi jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mk ml mm mn mo ju fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mj"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>