<html>
<head>
<title>Common attacks in Solidity and how to defend against them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity中常见的攻击及其防御方法</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/common-attacks-in-solidity-and-how-to-defend-against-them-9bc3994c7c18?source=collection_archive---------0-----------------------#2018-09-07">https://medium.com/coinmonks/common-attacks-in-solidity-and-how-to-defend-against-them-9bc3994c7c18?source=collection_archive---------0-----------------------#2018-09-07</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/a89292c8f4c3573f2ba3af3aaaa25e75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uBqaotIqZ2hKbfgM"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">“black and gray laptop computer turned on” by <a class="ae jf" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4b9d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你的心沉了下去。你的呼吸变得如此缓慢，你似乎屏住了呼吸。当你面对眼前屏幕上闪烁的数字时，你睁大了眼睛，感到恶心:你的智能合同被黑了。不知何故。</p><p id="e822" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们不惜一切代价避免这种情况，好吗？让我们意识到所有已知的攻击类型，并教会自己如何避免它们，这样我们就可以在晚上睡得很香。</p><h1 id="c7f1" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">资源</h1><p id="2055" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">在我们深入研究之前，我<strong class="ji hu"> <em class="lh">高度，高度</em> </strong>建议通过浏览<a class="ae jf" href="https://ethernaut.zeppelin.solutions/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin的ether aut</a>来补充您在本文中所学的内容，这是一个“游戏”，您可以打开浏览器控制台，使用注入的web3对象对Ropsten测试网络进行RPC(远程过程调用)来攻击易受攻击的合同，以便在游戏中前进。它甚至让你去<a class="ae jf" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix IDE </a>编写并部署恶意契约给Ropsten，这样你就可以调用那些契约中的自定义函数来利用Ethernaut契约中的漏洞。</p><p id="44e5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这个产品非常出色，我认为它是任何有抱负的或当前的智能合约开发人员的强制实践。</p><h1 id="0bfd" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">竞争条件:可重入性</h1><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="ee9d" class="lr kf ht ln b fv ls lt l lu lv">mapping (address =&gt; uint) private userBalances;<br/><br/>function withdrawBalance() public {<br/>    uint amountToWithdraw = userBalances[msg.sender];<br/>    msg.sender.transfer(amountToWithdraw);<br/>    userBalances[msg.sender] = 0;<br/>}</span></pre><p id="abf2" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在上面的函数中，请注意乙醚发送给用户后<code class="eh lw lx ly ln b">userBalances[msg.sender]</code>是如何设置为0的。如果这个函数被快速调用多次(比如用一个脚本，或者通过创建和部署你自己的恶意契约来调用这个函数，然后递归地调用它自己)，在它被设置为0之前，有可能发送<code class="eh lw lx ly ln b">userBalances[msg.sender]</code>多次。这种类型的利用就是2016年<a class="ae jf" rel="noopener" href="/swlh/the-story-of-the-dao-its-history-and-consequences-71e6a8a551ee"> DAO被黑的原因</a>(导致ETH和ETC的社区分叉)。</p><p id="a81f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">避免这种情况的最好方法是简单地将<code class="eh lw lx ly ln b">msg.sender.transfer(amountToWithdraw)</code>线移动到<code class="eh lw lx ly ln b">userBalances[msg.sender] = 0</code>线以下，以便在余额归零后转移资金。“转账失败怎么办？”你问。那么，该功能将被还原，以便<code class="eh lw lx ly ln b">userBalances[msg.sender]</code>不会被错误地设置为<code class="eh lw lx ly ln b">0</code>。</p><h1 id="aa77" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">竞争条件:跨函数状态依赖</h1><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="4c81" class="lr kf ht ln b fv ls lt l lu lv">mapping (address =&gt; uint) private userBalances;<br/><br/>function transfer(address _recipient, uint _amount) {<br/>    require(userBalances[msg.sender] &gt;= _amount);<br/>    userBalances[_recipient] += _amount;<br/>    userBalances[msg.sender] -= _amount;<br/>}<br/><br/>function withdrawBalance() public {<br/>    uint amountToWithdraw = userBalances[msg.sender];<br/>    msg.sender.transfer(amountToWithdraw);<br/>    userBalances[msg.sender] = 0;<br/>}</span></pre><p id="0dc8" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">类似于第一个竞争条件漏洞，如果您有两个依赖于相同契约状态的函数，那么在另一个函数执行的中途调用一个函数并得到不希望的结果是可能的。以上，可以同时调用两个函数，导致<code class="eh lw lx ly ln b">userBalances[recipient] += amount</code>(第一个函数)关闭，然后在第二个函数中<code class="eh lw lx ly ln b">msg.sender.transfer(amountToWithdraw)</code>关闭，然后在第一个函数中<code class="eh lw lx ly ln b">userBalances[msg.sender] -= amount</code>关闭。这将导致用户能够将钱发送到另一个地址(他们可能也拥有这个地址)，然后为自己提取相同的金额(从合同余额中窃取)。</p><p id="fdcb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">同样，防御这种情况的方法与第一场比赛相同:<strong class="ji hu">在转移乙醚之前一定要改变你的状态</strong>。</p><h1 id="7675" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">整数溢出/下溢</h1><p id="dbd4" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">在上面的示例中，您是否看到了其他易受攻击的地方？如果黑客成功地将他们所有的钱转移到了一个二级账户，那么<code class="eh lw lx ly ln b">userBalances[msg.sender] -= amount</code>会在<code class="eh lw lx ly ln b">userBalances[msg.sender]</code>可能没有很多钱的时候被触发，然后<code class="eh lw lx ly ln b">userBalances[msg.sender]</code>会下溢。</p><p id="57cb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当<code class="eh lw lx ly ln b">uint</code>递增/递减超过极限时，发生上溢/下溢。<code class="eh lw lx ly ln b">uint</code>(是<code class="eh lw lx ly ln b">uint256</code>的别名)的最大值是2 ^ 256–1。如果一个整数的增量超过这个数字，它将溢出，并且该值将返回到0。所有的<code class="eh lw lx ly ln b">uint</code>尺寸都是如此，例如<code class="eh lw lx ly ln b">uint8</code>，它明显更小(最大尺寸= 2 ^ 8 - 1 = 255)。溢出的示例:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="9a45" class="lr kf ht ln b fv ls lt l lu lv">uint8 myNumber = 255;<br/>    <br/>function increment(uint _number) public returns (uint) {<br/>    _number += _number;<br/>    return _number;<br/>}<br/>    <br/>uint newNumber = increment(myNumber); // newNumber is now 0, not 256</span></pre><p id="6b87" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这也可能发生在流不足的情况下。任何降到零度以下的<code class="eh lw lx ly ln b">uint</code>都会跳到它的最大值。你能想象看到某个合同的用户<code class="eh lw lx ly ln b">uint balance = 0</code>跳到<code class="eh lw lx ly ln b">1.157920892E77 — 1</code>时的震惊吗？！？</p><p id="eaba" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了防止这种情况，使用<a class="ae jf" href="https://ethereumdev.io/safemath-protect-overflows/" rel="noopener ugc nofollow" target="_blank"> SafeMath </a>库(由OpenZeppelin的不可思议的人构建)，它可以恢复任何被调用的防止溢出的函数。迫不及待地想让这个功能成为实实在在的标准！</p><h1 id="1a69" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">合同余额相关性</h1><p id="1975" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">您知道吗，当第一次部署一个契约时，完全可以预先计算该契约的地址，然后在部署该契约之前将以太网发送到该地址。？<strong class="ji hu">永远不要假设您的合同部署时余额为零</strong>。</p><p id="d1bd" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你也可以强行发送以太到任何合同，影响它的总平衡。请注意，即使您有一个回退功能是<em class="lh">而不是</em> <code class="eh lw lx ly ln b">payable</code>:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="5c8c" class="lr kf ht ln b fv ls lt l lu lv">contract exampleContract {<br/>    function() { } // The fallback function<br/>}</span></pre><p id="4475" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">…您仍然可以向合同发送以太网！怎么会？！？你不能用<strong class="ji hu">钱包地址</strong>(即你的个人ETH账户)来做，但是你<em class="lh">可以用<strong class="ji hu">合同地址</strong>来做，就像这样:</em></p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="9e56" class="lr kf ht ln b fv ls lt l lu lv">contract etherBomb {<br/>    address recipient;</span><span id="9291" class="lr kf ht ln b fv lz lt l lu lv">    // First, send this contract some ether<br/>    // Then, call the below function to set a recipient address</span><span id="dc94" class="lr kf ht ln b fv lz lt l lu lv">    function setTarget(address _target) public {<br/>        recipient = _target;<br/>    }</span><span id="6b5d" class="lr kf ht ln b fv lz lt l lu lv">    // Then call this function to destroy this contract<br/>    // and forcibly send the funds anywhere</span><span id="1041" class="lr kf ht ln b fv lz lt l lu lv">    function kill() public { <br/>        selfdestruct(recipient);<br/>    }<br/>}</span></pre><p id="7e6e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因为所有这些事情，无论何时在你的应用程序逻辑中处理合同平衡，特别是在 <code class="eh lw lx ly ln b">if</code> <strong class="ji hu">或</strong> <code class="eh lw lx ly ln b">require</code> <strong class="ji hu">语句</strong>中，<strong class="ji hu">都要非常小心。</strong></p><h1 id="73c7" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">拒绝服务</h1><p id="0899" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">我在之前的漏洞中提到过这一点，但还是值得重复一下:<strong class="ji hu">并不是所有与你的契约交互的地址都会是钱包地址——其他契约也可以调用你的代码</strong>。正因为如此，它们可以用来破坏你的应用程序。请考虑以下情况:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="8e00" class="lr kf ht ln b fv ls lt l lu lv">contract Auction {<br/>    address highestBidder;<br/>    uint highestBid;</span><span id="d2c6" class="lr kf ht ln b fv lz lt l lu lv">    function bid() public {<br/>        require(msg.value &lt; highestBid); </span><span id="c83e" class="lr kf ht ln b fv lz lt l lu lv">        if (highestBidder != 0x0) { <br/>            highestBidder.transfer(highestBid); // Return old bid<br/>        }</span><span id="4a64" class="lr kf ht ln b fv lz lt l lu lv">        // Store new highest bid and bidder<br/>        highestBid = msg.value; <br/>        highestBidder = msg.sender;<br/>    }<br/>}</span></pre><p id="2ba5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果有这样的恶意合同:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="04bc" class="lr kf ht ln b fv ls lt l lu lv">contract AuctionAPI {<br/>    function bid(); // Exposes function after contract instantiation<br/>}</span><span id="0863" class="lr kf ht ln b fv lz lt l lu lv">contract Attacker {<br/>    address auctionAddress = 0x0123456789abcdef; // Put address here<br/>    AuctionAPI auctionContract = AuctionAPI(auctionAddress);</span><span id="8dd2" class="lr kf ht ln b fv lz lt l lu lv">    function placeBid(uint _amount) public {<br/>        auctionContract.bid.value(_amount); <br/>    }</span><span id="4648" class="lr kf ht ln b fv lz lt l lu lv">    function () payable {<br/>        throw; // Rejects the payment before the function completes<br/>    }<br/>}</span></pre><p id="48ff" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">假设其中有以太，那么<code class="eh lw lx ly ln b">Attacker</code>契约可以通过调用<code class="eh lw lx ly ln b">bid()</code>函数将其以太发送给<code class="eh lw lx ly ln b">Auction</code>契约，并成为<code class="eh lw lx ly ln b">highestBidder</code>。因为当一个新的最高出价进来时,<code class="eh lw lx ly ln b">Auction</code>合同将旧的最高出价返回给它的所有者，当一个新的最高出价进来时，它将试图把钱送回给<code class="eh lw lx ly ln b">Attacker</code>。但是由于<code class="eh lw lx ly ln b">Attacker</code>有一个抛出的回退功能，它拒绝支付并将其发送回<code class="eh lw lx ly ln b">Auction</code>，并且<code class="eh lw lx ly ln b">Auction</code>在设置新的最高出价/投标人之前停止<code class="eh lw lx ly ln b">bid</code>功能。实际上，这使合同瘫痪了。</p><p id="f894" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">防范这种情况的一个好方法是实现一个<strong class="ji hu">“平衡撤销”设计模式</strong>(下面将详细介绍)，这样任何以太网传输功能都独立于其他应用程序逻辑。</p><h1 id="dc86" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">时间戳/矿工篡改</h1><p id="5c24" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">矿工能够在一个区块内对交易进行排序。这是dEX领域中一个众所周知的问题，称为“前向运行”，在这种情况下，同一个块中的某些买入/卖出订单可能会被重新安排，以不同于预期的顺序执行。此外，矿工还能够调整块时间戳(在大约30秒的范围内)，因此<strong class="ji hu">使用</strong> <code class="eh lw lx ly ln b">block.timestamp</code> <strong class="ji hu">从来都不是好的做法——使用</strong> <code class="eh lw lx ly ln b">block.number</code> <strong class="ji hu">而不是</strong>。如果你必须使用一个时间戳，并且它的准确性对你的应用程序至关重要，考虑从一个有真实性证明的甲骨文中提取信息，或者考虑<a class="ae jf" href="https://www.ethereum-alarm-clock.com/" rel="noopener ugc nofollow" target="_blank">以太坊闹钟</a>。要了解为什么以太坊中的时间戳是一个问题，请查看(并投票支持)这个<a class="ae jf" href="https://ethereum.stackexchange.com/questions/15047/solidity-timestamp-dependency-is-it-possible-to-do-safely/15054#15054?newreg=2caa8a26114d4125984bdf83b854ef08" rel="noopener ugc nofollow" target="_blank">精彩的StackExchange答案</a>。</p><p id="b35f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">或者，如果情况需要，你可以实现一个<strong class="ji hu">“提交/揭示”设计模式</strong>(更多内容见下文)，如果让世界能够看到即将被挖掘的事务的数据是有问题的。</p><h1 id="58e5" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">委派电话</h1><p id="cbc4" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">根据<a class="ae jf" href="https://solidity.readthedocs.io/en/v0.4.21/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries" rel="noopener ugc nofollow" target="_blank">固化文件</a>:</p><blockquote class="ma mb mc"><p id="5b26" class="jg jh lh ji b jj jk jl jm jn jo jp jq md js jt ju me jw jx jy mf ka kb kc kd hm dt translated">消息调用有一个特殊的变体，名为<strong class="ji hu"> delegatecall </strong>，除了目标地址的代码在调用契约的上下文中执行以及<code class="eh lw lx ly ln b">msg.sender</code>和<code class="eh lw lx ly ln b">msg.value</code>不改变它们的值之外，它与消息调用相同。</p><p id="c0cf" class="jg jh lh ji b jj jk jl jm jn jo jp jq md js jt ju me jw jx jy mf ka kb kc kd hm dt translated">这意味着契约可以在运行时从不同的地址动态加载代码。存储、当前地址和余额仍然引用调用合同，只是代码取自被调用地址。</p><p id="69e6" class="jg jh lh ji b jj jk jl jm jn jo jp jq md js jt ju me jw jx jy mf ka kb kc kd hm dt translated">这使得在Solidity中实现“库”功能成为可能:可重复使用的库代码，可应用于合同的存储，例如，为了实现复杂的数据结构。</p></blockquote><p id="a143" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">围绕该功能使用的不当安全是2017年<a class="ae jf" href="https://blog.zeppelin.solutions/on-the-parity-wallet-multisig-hack-405a8c12e8f7" rel="noopener ugc nofollow" target="_blank">奇偶校验Multisig钱包黑客</a>的原因。TL；DR该函数对于授予您的合同调用其他合同的能力非常有用，就好像该代码是您自己的合同的一部分一样。然而，使用<code class="eh lw lx ly ln b">delegatecall()</code> <strong class="ji hu">会导致被调用契约中的所有公共函数都可以被任何人</strong>调用——在使用公共库时，这通常不是问题。但是因为这种行为在奇偶校验构建自己的定制库时没有被识别…</p><ol class=""><li id="7b54" class="mg mh ht ji b jj jk jn jo jr mi jv mj jz mk kd ml mm mn mo dt translated">在被调用的库中放置了不适当的安全措施。</li><li id="01d5" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd ml mm mn mo dt translated">这允许黑客通过将他/她自己的地址作为多重签名授权者来重新初始化钱包。</li><li id="574f" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd ml mm mn mo dt translated">现在拥有了所有的multisig授权者地址，黑客就能够取出所有的合同资金。</li></ol><p id="5134" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了更深入地了解这一场景，请查看<a class="ae jf" href="https://blog.zeppelin.solutions/on-the-parity-wallet-multisig-hack-405a8c12e8f7" rel="noopener ugc nofollow" target="_blank">这篇令人惊叹的文章</a>。</p><p id="5a30" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要点:当您将代码组织到多个契约、库和包中时，在依赖<code class="eh lw lx ly ln b">delegatecall()</code>时要非常小心——您必须有完整的端到端安全措施来防止不必要的存储修改。</p><figure class="li lj lk ll fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mu"><img src="../Images/be8b0c5820b3d0fc8063b67527481014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uW0_Yz0xEEhN4Nb3"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">“bald eagle door chain lock” by <a class="ae jf" href="https://unsplash.com/@milkovi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">MILKOVÍ</a> on <a class="ae jf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4abd" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">一般合同写作最佳实践</h1><p id="753e" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">如果您坚持编写可靠、干净的代码，引入漏洞的风险会更小。这些好习惯应该成为你的第二天性。</p><h2 id="dfd6" class="lr kf ht bd kg mv mw mx kk my mz na ko jr nb nc ks jv nd ne kw jz nf ng la nh dt translated">功能/数据结构暴露</h2><p id="2dd5" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">最佳实践是明确说明每个函数和数据结构的权限级别，以便完全了解钱包地址或其他协定地址可以看到或调用哪些函数和数据。如果你不熟悉<code class="eh lw lx ly ln b">external</code>、<code class="eh lw lx ly ln b">internal</code>、<code class="eh lw lx ly ln b">public</code>和<code class="eh lw lx ly ln b">private</code>之间的区别，请查阅<a class="ae jf" href="https://solidity.readthedocs.io/en/v0.4.24/types.html?highlight=public#function-types" rel="noopener ugc nofollow" target="_blank">可靠性文档</a>。</p><h2 id="7ccb" class="lr kf ht bd kg mv mw mx kk my mz na ko jr nb nc ks jv nd ne kw jz nf ng la nh dt translated">合同所有权</h2><p id="4b6b" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">明智的做法是使用<a class="ae jf" href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin的</a> <code class="eh lw lx ly ln b"><a class="ae jf" href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol" rel="noopener ugc nofollow" target="_blank">Ownable</a></code> <a class="ae jf" href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol" rel="noopener ugc nofollow" target="_blank">包</a>建立一个拥有管理权限并可以调用所有者特定函数的单一地址。这非常有用，尤其是下面的“断路器”功能。</p><h2 id="f7f8" class="lr kf ht bd kg mv mw mx kk my mz na ko jr nb nc ks jv nd ne kw jz nf ng la nh dt translated">断路器</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="733f" class="lr kf ht ln b fv ls lt l lu lv">bool public contractPaused = false;</span><span id="1110" class="lr kf ht ln b fv lz lt l lu lv">function circuitBreaker() public onlyOwner { // onlyOwner can call<br/>    if (contractPaused == false) { contractPaused = true; }<br/>    else { contractPaused = false; }<br/>}</span><span id="766b" class="lr kf ht ln b fv lz lt l lu lv">// If the contract is paused, stop the modified function<br/>// Attach this modifier to all public functions<br/>modifier checkIfPaused() {<br/>    require(contractPaused == false);<br/>    _;<br/>}</span></pre><p id="902c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">明智的做法是实现一个“断路器”功能修改器，在灾难性事件发生时阻止所有应用程序功能。此功能应与<code class="eh lw lx ly ln b">Ownable</code>配合使用，以便只有合同所有者可以暂停/取消暂停应用程序。这有助于在危急情况下争取时间，并分析出了什么问题以及如何解决。尽管一些用户可能会抗议这种方法缺乏分散性，但在部署后的某个时候，您可以简单地将契约所有权转移到<code class="eh lw lx ly ln b">0x0</code>地址，防止任何人调用<code class="eh lw lx ly ln b">Ownable</code>功能。</p><h2 id="6d6c" class="lr kf ht bd kg mv mw mx kk my mz na ko jr nb nc ks jv nd ne kw jz nf ng la nh dt translated">环</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="71e0" class="lr kf ht ln b fv ls lt l lu lv">struct Account {<br/>    address userAddress;<br/>    uint balance;<br/>}</span><span id="a46d" class="lr kf ht ln b fv lz lt l lu lv">Account[] private accounts;</span><span id="c0ec" class="lr kf ht ln b fv lz lt l lu lv">function withdrawAllBalances() public {<br/>    for (uint i = 0; i &lt; accounts.length; i++) {<br/>        Account storage user = accounts[i];<br/>        user.userAddress.transfer(user.balance);<br/>        user.balance = 0;<br/>    }<br/>}</span></pre><p id="8698" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">编写循环时要非常小心，因为它们会很快达到块气体限制，尤其是在动态大小的数据结构(如地址数组，可以向该数组添加更多地址)上的循环。</p><h2 id="872e" class="lr kf ht bd kg mv mw mx kk my mz na ko jr nb nc ks jv nd ne kw jz nf ng la nh dt translated">整理传入的数据/函数参数</h2><p id="fc94" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">您的DApp前端不是唯一可以发送您的合同RPC的地方，所以您必须在将任何传入的数据或函数参数插入存储之前对它们进行净化。永远不要相信合同之外的任何东西。</p><h2 id="304f" class="lr kf ht bd kg mv mw mx kk my mz na ko jr nb nc ks jv nd ne kw jz nf ng la nh dt translated">早点失败，大声失败</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="bc03" class="lr kf ht ln b fv ls lt l lu lv">function usesIfStatements() {<br/>    if (msg.sender == owner) { // Will fail silently<br/>        doSomething();<br/>    }<br/>}</span><span id="0611" class="lr kf ht ln b fv lz lt l lu lv">function usesRequire() {<br/>    require(msg.sender == owner); // Will fail loudly<br/>    doSomething();<br/>}</span></pre><p id="2f2f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">只要有可能，总是支持<code class="eh lw lx ly ln b">require()</code>语句而不是<code class="eh lw lx ly ln b">if</code>语句，因为如果不满足<code class="eh lw lx ly ln b">require()</code>语句，它将抛出一个<code class="eh lw lx ly ln b">revert</code>并发送给函数调用方(如前端)，并立即停止函数。<code class="eh lw lx ly ln b">if</code>语句往往会无声无息地失败，还会导致更难阅读的深层嵌套代码。</p><p id="d13c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">尽可能将这些语句放在函数的顶部，以便尽早检查这些条件，从而节省开销并确保不会执行不需要的功能。</p><figure class="li lj lk ll fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ni"><img src="../Images/14ca9c39e897260879d697b4c08a8c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UBbXcqXgqE4BDOHQ"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">“empty gray concrete pathway with roof” by <a class="ae jf" href="https://unsplash.com/@next_spideey21?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alex J. Reyes</a> on <a class="ae jf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="062d" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">有用的设计模式</h1><p id="2504" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">通过在您的代码中实现可靠的设计模式，可以减少上述许多漏洞。下面是几个有用的。</p><h2 id="2cd2" class="lr kf ht bd kg mv mw mx kk my mz na ko jr nb nc ks jv nd ne kw jz nf ng la nh dt translated">余额提取(又名“拉”与“推”支付)</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="38ef" class="lr kf ht ln b fv ls lt l lu lv">mapping (address =&gt; uint) private balances;</span><span id="cf16" class="lr kf ht ln b fv lz lt l lu lv">function depositFunds() public {<br/>    balances[msg.sender] += msg.value;<br/>}</span><span id="999a" class="lr kf ht ln b fv lz lt l lu lv">function checkBalance() public returns (uint) {<br/>    return balances[msg.sender];<br/>}</span><span id="c4d9" class="lr kf ht ln b fv lz lt l lu lv">function withdrawFunds(uint _amount) public {<br/>    require(balances[msg.sender] &gt;= _amount);<br/>    balances[msg.sender] -= _amount; // Reverts if transfer fails</span><span id="e5c7" class="lr kf ht ln b fv lz lt l lu lv">    // This is what we want separated from other app logic<br/>    msg.sender.transfer(_amount); <br/>}</span><span id="b66d" class="lr kf ht ln b fv lz lt l lu lv">function sendFunds(address _receiver, uint _amount) public {<br/>    require(balances[msg.sender] &gt;= _amount);<br/>    balances[msg.sender] -= _amount;<br/>    balances[_receiver] += _amount;<br/>}</span></pre><p id="e76d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这种设计模式将发送以太网的动作与所有其他应用程序功能分开。您可以跟踪所有用户的余额，允许他们在合同中存入/提取资金，允许他们用这些资金做合同中的事情(而不实际将以太送出合同)，只有当以太实际被送出合同时，您才应该使用<code class="eh lw lx ly ln b">.transfer()</code>，它应该在自己的功能中，以防传输失败。</p><h2 id="d76b" class="lr kf ht bd kg mv mw mx kk my mz na ko jr nb nc ks jv nd ne kw jz nf ng la nh dt translated">依赖国家的行动(又名<a class="ae jf" href="https://solidity.readthedocs.io/en/develop/common-patterns.html#state-machine" rel="noopener ugc nofollow" target="_blank">“国家机器”</a>)</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="5ea8" class="lr kf ht ln b fv ls lt l lu lv">struct Order internal {<br/>    string from;<br/>    string to;<br/>    uint price;<br/>    uint Status;<br/>}</span><span id="909a" class="lr kf ht ln b fv lz lt l lu lv">mapping (uint =&gt; Order) public orders; // orderId</span><span id="b523" class="lr kf ht ln b fv lz lt l lu lv">enum Status {<br/>    Open,<br/>    Cancelled,<br/>    AwaitingShipping,<br/>    InTransit,<br/>    Delivered,<br/>    Complete<br/>}</span><span id="4d6b" class="lr kf ht ln b fv lz lt l lu lv">function markAsDelivered(uint _orderId) public {<br/>    require(orders[_orderId].Status == Status.InTransit);<br/>    orders[_orderId].Status = Status.Delivered;<br/>}</span></pre><p id="0d0f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一个非常有用的设计模式是“状态机”，这是一种限制采取某些动作的方法，除非满足某个状态条件。在上面的运输示例中，订单不能被标记为已交付，除非其当前状态是<code class="eh lw lx ly ln b">InTransit</code>。设置这些条件可以确保步骤的逻辑性和可执行性。这种设计模式允许在你的应用程序中实现难以置信的复杂性——这是目前我最喜欢的！</p><h2 id="f467" class="lr kf ht bd kg mv mw mx kk my mz na ko jr nb nc ks jv nd ne kw jz nf ng la nh dt translated">提交/展示</h2><p id="3727" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">当一个用户的行为或选择可能会影响另一个用户的行为或选择时，例如投票，或者游戏中所有玩家的行为同时被显示的行为，或者甚至是一次秘密拍卖，最好使用提交/显示设计模式。基本上，你把DApp分成两个独立的阶段(用一个“状态机”！):提交阶段和揭示阶段。</p><ol class=""><li id="5967" class="mg mh ht ji b jj jk jn jo jr mi jv mj jz mk kd ml mm mn mo dt translated">在提交阶段，用户提交他们的move/vote/etc的加密散列，它存储在契约中。没有人通过查看合同存储知道实际的移动/投票/等等是什么，因为他们只看到一个散列。<strong class="ji hu"> <em class="lh">更新</em> </strong> <em class="lh">:感谢</em> <a class="nj nk gr" href="https://medium.com/u/6477e735faed?source=post_page-----9bc3994c7c18--------------------------------" rel="noopener" target="_blank"> <em class="lh">罗马风暴</em> </a> <em class="lh">指出您应该在前端使用</em> <code class="eh lw lx ly ln b"><em class="lh">web3.utils.soliditySha3()</em></code> <em class="lh">对值</em> <strong class="ji hu"> <em class="lh">进行加密，然后在</em> </strong> <em class="lh">将它们传输到区块链(而不是将原始的、未加密的、暴露的数据接收到合同中，然后合同对其进行加密)，因为那些交易中的数据是公开的！</em></li><li id="2878" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd ml mm mn mo dt translated">在所有用户提交之后，我们进入展示阶段。用户必须重新提交他们的原始移动/投票/等，以证明，通过散列它，它匹配他们最初提交的。这将验证该操作。</li></ol><p id="934b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要了解关于这种设计模式的更多信息，请查看这篇<a class="ae jf" href="https://karl.tech/learning-solidity-part-2-voting/" rel="noopener ugc nofollow" target="_blank">精彩文章</a>。如果你想看这个代码的例子，可以看看我的<a class="ae jf" href="https://github.com/joelsfoster/rock-paper-scissors" rel="noopener ugc nofollow" target="_blank">去中心化石头剪刀布游戏</a>。</p><h2 id="f1d3" class="lr kf ht bd kg mv mw mx kk my mz na ko jr nb nc ks jv nd ne kw jz nf ng la nh dt translated">减速带/动作节流</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="f08b" class="lr kf ht ln b fv ls lt l lu lv">mapping (address =&gt; uint) private userLastAction;<br/>uint throttleTime = 30 seconds; </span><span id="2037" class="lr kf ht ln b fv lz lt l lu lv">// Attach this to critical functions, such as balance withdrawals<br/>modifier speedBump() {      <br/>    if (!userLastAction[msg.sender]) {<br/>        userLastAction[msg.sender] = 0;<br/>    }</span><span id="d8b2" class="lr kf ht ln b fv lz lt l lu lv">    require(now - throttleTime &gt;= userLastAction[msg.sender]);<br/>    userLastAction[msg.sender] = now; // now == block.timestamp<br/>    _;<br/>}</span></pre><p id="c9f0" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这种设计模式可以用来限制用户操作。是的，因为储存成本，这要消耗很多汽油。但是在那些只采取一些非常关键的动作的应用程序中，这种设计模式是有益的。上面，出于说明的目的，我使用了<code class="eh lw lx ly ln b">now</code>又名<code class="eh lw lx ly ln b">block.timestamp</code>，尽管用<code class="eh lw lx ly ln b">block.number</code>代替<code class="eh lw lx ly ln b">uint throttleTime = 1; // 1 block</code>会更好。</p><h2 id="2869" class="lr kf ht bd kg mv mw mx kk my mz na ko jr nb nc ks jv nd ne kw jz nf ng la nh dt translated">自动折旧</h2><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="ae66" class="lr kf ht ln b fv ls lt l lu lv">uint public expirationBlock = 7654321;</span><span id="d09f" class="lr kf ht ln b fv lz lt l lu lv">// Attach this modifier to all public functions<br/>modifier preventIfDeprecated() {<br/>    require(expirationBlock &gt;= block.number);<br/>    _;<br/>}</span></pre><p id="6e16" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这种模式对于在特定时间(比如alpha/beta测试期间)关闭合同很有用，因为这样就不必使用<code class="eh lw lx ly ln b">selfdestruct()</code>，也不会丢失合同的所有存储数据。</p><h2 id="80ba" class="lr kf ht bd kg mv mw mx kk my mz na ko jr nb nc ks jv nd ne kw jz nf ng la nh dt translated">数据分离</h2><p id="4b0a" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">如果您希望建立可升级的合同，您应该将所有应用程序数据保存在一个单独的合同中，并建立允许哪些地址(您的DApp的最新版本)修改该合同状态的条件。这是相对高级的，我不会在这里深入探讨，但如果你想知道更多，请查看这个<a class="ae jf" href="https://github.com/cjgdev/smart-contract-patterns/blob/master/maintenance/data_segregation.sol" rel="noopener ugc nofollow" target="_blank">基本代码片段</a>和这个<a class="ae jf" rel="noopener" href="/aigang-network/upgradable-smart-contracts-what-weve-learned-at-aigang-b181d3d4b668">高级文章</a>和这个<a class="ae jf" href="https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88" rel="noopener ugc nofollow" target="_blank">无中生有的文章</a>。如果你真的想深入细节，可以看看这篇关于以太坊的文章。</p><h1 id="e0b9" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">信用</h1><p id="77f1" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">我从<a class="ae jf" href="https://consensys.net/academy/2018developer/" rel="noopener ugc nofollow" target="_blank"> Consensys学院开发者项目</a>中学到了很多这方面的信息。这篇文章中的一些代码片段直接受到了他们在课程中给我们展示的例子的启发(尽管<em class="lh">没有完全抄袭】。</em></p><p id="aaf7" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果你在这篇文章中发现了什么需要改正的地方，请给我留言并告诉我！如果您的项目正在寻找兼职或合同智能合同开发人员，请联系我！我为合适的项目提供开发和审计服务，以及产品管理服务。</p></div><div class="ab cl nl nm hb nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hm hn ho hp hq"><p id="1318" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="lh">我在OMGpool.org</em><a class="ae jf" href="http://omgpool.org" rel="noopener ugc nofollow" target="_blank"><em class="lh"/></a><em class="lh">管理产品/战略/业务开发，我们正在那里为OmiseGO建立第一个开源的、社区驱动的赌注池。我也写智能合同——看看我在github.com/joelsfoster.的表现</em></p><p id="e05d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="lh">请务必在我们的网站上查看我们的赌注奖励</em> <a class="ae jf" href="http://omgpool.org/staking-rewards-calculator" rel="noopener ugc nofollow" target="_blank"> <em class="lh">计算器</em> </a> <em class="lh">和</em> <a class="ae jf" href="http://omgpool.org/news" rel="noopener ugc nofollow" target="_blank"> <em class="lh">新闻提要</em> </a> <em class="lh">，并在等待赌注到来的同时关注我们正在添加的新功能。</em></p><p id="687c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="lh">如果您想在赌注池启动时第一个听到消息，请在下面注册接收电子邮件更新:</em></p><figure class="li lj lk ll fq iu"><div class="bz el l di"><div class="ns nt l"/></div></figure><p id="9e98" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="lh">关注我们上</em><a class="ae jf" href="https://twitter.com/omg_pool" rel="noopener ugc nofollow" target="_blank"><em class="lh">Twitter</em></a><em class="lh">|</em><a class="ae jf" href="https://medium.com/omgpool" rel="noopener"><em class="lh">Medium</em></a><em class="lh">|</em><a class="ae jf" href="https://t.me/joinchat/HNsNKU4uI9ZavKNgGr2HjQ" rel="noopener ugc nofollow" target="_blank"><em class="lh">Telegram</em></a><em class="lh">|</em><a class="ae jf" href="https://www.reddit.com/r/OMGPool/" rel="noopener ugc nofollow" target="_blank"><em class="lh">Reddit</em></a></p><p id="bd9a" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">给我们发电子邮件:contact@omgpool.org</p><blockquote class="nu"><p id="5734" class="nv nw ht bd nx ny nz oa ob oc od kd ek translated">加入Coinmonks <a class="ae jf" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jf" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae jf" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="lr kf ht bd kg mv oe mx kk my of na ko jr og nc ks jv oh ne kw jz oi ng la nh dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="mg mh ht ji b jj lc jn ld jr oj jv ok jz ol kd om mm mn mo dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae jf" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated"><a class="ae jf" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae jf" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/top-3-telegram-channels-for-crypto-traders-in-2021-8385f4411ff4">密码电报信号</a> | <a class="ae jf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f566" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/binance-trading-bots-d0d57bb62c4c">币安交易机器人</a> | <a class="ae jf" rel="noopener" href="/coinmonks/okex-review-6b369304110f"> OKEx评论</a> | <a class="ae jf" href="https://coincodecap.com/atani-review" rel="noopener ugc nofollow" target="_blank">阿塔尼评论</a></li><li id="3b1f" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/best-crypto-signals-telegram-5785cdbc4b2b">最佳加密交易信号电报</a> | <a class="ae jf" rel="noopener" href="/coinmonks/moonxbt-review-6e4ab26d037"> MoonXBT评论</a></li><li id="c44c" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated"><a class="ae jf" href="https://coincodecap.com/buy-shiba-bitbns" rel="noopener ugc nofollow" target="_blank">如何在Bitbns上购买柴犬(SHIB)币？</a> | <a class="ae jf" href="https://coincodecap.com/buy-floki-inu-token" rel="noopener ugc nofollow" target="_blank">购买弗洛基</a></li><li id="af80" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated"><a class="ae jf" href="https://coincodecap.com/coinflex-review" rel="noopener ugc nofollow" target="_blank"> CoinFLEX评论</a> | <a class="ae jf" href="https://coincodecap.com/aex-exchange-review" rel="noopener ugc nofollow" target="_blank"> AEX交易所评论</a> | <a class="ae jf" href="https://coincodecap.com/upbit-review" rel="noopener ugc nofollow" target="_blank"> UPbit评论</a></li><li id="29b5" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated"><a class="ae jf" href="https://coincodecap.com/best-cryptocurrency-blogs" rel="noopener ugc nofollow" target="_blank">十大最佳加密货币博客</a> | <a class="ae jf" href="https://coincodecap.com/youhodler-review" rel="noopener ugc nofollow" target="_blank"> YouHodler评论</a></li><li id="f196" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated"><a class="ae jf" href="https://coincodecap.com/ascendex-margin-trading" rel="noopener ugc nofollow" target="_blank"> AscendEx保证金交易</a> | <a class="ae jf" href="https://coincodecap.com/bitfinex-staking" rel="noopener ugc nofollow" target="_blank"> Bitfinex赌注</a></li><li id="3cd8" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated"><a class="ae jf" href="https://coincodecap.com/best-cardano-wallets" rel="noopener ugc nofollow" target="_blank">最好的卡达诺钱包</a> | <a class="ae jf" href="https://coincodecap.com/bingbon-copy-trading" rel="noopener ugc nofollow" target="_blank"> Bingbon副本交易</a></li><li id="f33b" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae jf" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">开发人员的最佳加密API</a></li><li id="b359" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated">最佳<a class="ae jf" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae jf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="mg mh ht ji b jj mp jn mq jr mr jv ms jz mt kd om mm mn mo dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币的终极指南</a></li></ul></div></div>    
</body>
</html>