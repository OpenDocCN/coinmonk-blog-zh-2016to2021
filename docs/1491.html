<html>
<head>
<title>The Workflows of Developing NEO Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发NEO智能合同的工作流程</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/the-workflows-of-developing-neo-smart-contracts-c65279ac165b?source=collection_archive---------2-----------------------#2018-09-11">https://medium.com/coinmonks/the-workflows-of-developing-neo-smart-contracts-c65279ac165b?source=collection_archive---------2-----------------------#2018-09-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="0ce9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">摘要</strong>:开发NEO智能合约的典型开发工作流程有两个实际阶段:编码(在IDE中编辑和编译到。avm)和测试(在测试网上部署、调用和检查结果)。此工作流需要编译和部署来调试任何代码更改。在NEO社区开发的一些最新工具集的帮助下，出现了一个4阶段工作流，以进一步提高开发效率。</p><p id="399d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本教程中，我们将首先简要讨论标准的两阶段工作流以及一些有用的参考资料，然后介绍四阶段工作流以及相关的新开发工具。除非另有说明，否则讨论采用C#作为智能合约语言。</p><p id="df59" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这当然有可能是我在本教程中犯了错误或错过了一些要点，非常感谢任何评论。</p><h1 id="7003" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">1.两阶段工作流程</h1><p id="468c" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">按照惯例，我们在NEO智能合约开发中有两个实际阶段:<strong class="is hu">编码</strong>和<strong class="is hu">测试</strong>。这个<a class="ae kr" href="http://docs.neo.org/en-us/sc/quickstart/overview.html" rel="noopener ugc nofollow" target="_blank">官方教程</a>提供了关于这个工作流程的更多细节。</p><p id="f2d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于编码阶段，NEO官方支持C#(例子<a class="ae kr" href="http://docs.neo.org/en-us/sc/tutorial/HelloWorld.html" rel="noopener ugc nofollow" target="_blank">此处</a>)。我们还可以用<a class="ae kr" href="http://docs.neo.org/en-us/sc/quickstart/getting-started-java.html" rel="noopener ugc nofollow" target="_blank"> Java </a>和<a class="ae kr" href="https://github.com/CityOfZion/neo-python/blob/master/README.rst" rel="noopener ugc nofollow" target="_blank"> Python </a>开发一个智能合约。因为我们可以很容易地在Google和Youtube上找到几页教程和示例代码来告诉我们如何编写NEO智能合同，所以我将在本教程中跳过这一部分。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff ks"><img src="../Images/a3a29deab3a1b0a5c87b0ed5a86c5e7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ApvnzPUnYPxvqPtliPzbxQ.jpeg"/></div></div><figcaption class="le lf fg fe ff lg lh bd b be z ek">NEO TestNet Solutions</figcaption></figure><p id="6682" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们依靠测试网络来完成测试阶段。如上图所示，我们有很多测试网的选择。</p><p id="4bca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">公测网</strong></p><p id="cc00" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最常见的方法是使用公共测试网。有三个主要的公共测试网络分别由NEO Smart Economy、CoZ和NEL维护。<a class="ae kr" rel="noopener" href="/@gubanotorious/test-networks-and-fund-requests-for-smart-contract-and-dapp-testing-on-the-neo-blockchain-583a1795412"> Alex Guba的教程</a>详细阐述了如何在NEO和CoZ测试网上测试之前同步块和请求GAS，而<a class="ae kr" href="https://scan.nel.group/#testnet" rel="noopener ugc nofollow" target="_blank"> NEL的测试网</a>对中国开发者更友好，支持本地化。</p><p id="66ae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在许多情况下，您可以通过NEO API ( <a class="ae kr" href="http://docs.neo.org/en-us/node/cli/apigen.html" rel="noopener ugc nofollow" target="_blank">完整引用</a>)为区块链交互运行RPC调用。某些API仅在您有一个正在运行的NEO-CLI节点并打开了wallet时才可用。但是，如果测试网络配备了Neo-Scan，您可以调用类似的服务，而无需运行此类节点。例如，API <a class="ae kr" href="http://docs.neo.org/en-us/node/cli/2.7.4/api/getbalance.html" rel="noopener ugc nofollow" target="_blank"> getBalance </a>需要一个正在运行的节点，但是您可以使用Neo-Scan的<a class="ae kr" href="https://neoscan.io/docs/index.html#api-v1-get-3" rel="noopener ugc nofollow" target="_blank"> get_balance </a>来获得类似的功能。我创建了一个<a class="ae kr" href="https://github.com/norchain/NEORPC_PostMan/tree/master" rel="noopener ugc nofollow" target="_blank"> Postman集合</a>来帮助测试这些远程过程。只需更改测试网络(或新扫描)域的值即可使用它。</p><p id="2301" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae kr" href="https://neocompiler.io/#/" rel="noopener ugc nofollow" target="_blank"> NeoCompiler Eco </a>有一个新的、特殊的公共测试网络，这启发了我们转向四阶段工作流程。我们将在下一章详细讨论它。</p><p id="adca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">专用测试网</strong></p><p id="9a10" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">另一个好方法是建立你自己的私人测试网。与公共测试网相比，私有测试网的优点是你可以完全控制。使用私人测试网的第一个原因是，它真的很有帮助，令人鼓舞，让人产生钱包里有数百万个NEO和GAS的错觉。同时，与公共测试网相比，我们不需要担心链再生，连接失败，或者其他开发者错误地阻塞网络。</p><p id="f042" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">NEO的官方网站提供了在云服务上建立私有网络的逐步指南。但在检查了我来自Azure的账单后，我不会推荐它，除非你必须与其他人共享链数据。Neo-privatenet-docker 非常适合在您的本地机器上构建私有测试网络，同时从大量的配置和指令中节省您的时间。如果你在笔记本电脑上运行它，嗯…它也有助于在冬天保持体温。</p><p id="f2cc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">两阶段工作流程的局限性</strong></p><p id="48ac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这种两阶段工作流已经成熟，被大多数现有项目所采用。然而，与传统的软件项目相比，它有一些局限性。最主要的一点是<strong class="is hu">调试非常昂贵</strong>。要监视变量的运行时值，最好的选择是使用如下运行时通知:</p><pre class="kt ku kv kw fq li lj lk ll aw lm dt"><span id="edc6" class="ln jp ht lj b fv lo lp l lq lr">byte[] ba0 = CallSomeFunction();<br/>byte[] ba1 = CallAnotherFunction();</span><span id="b37a" class="ln jp ht lj b fv ls lp l lq lr">//Print out the value of ba0 and ba1 to ApplicationhLog<br/>Runtime.Notify(ba0, ba1);</span></pre><p id="1acd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">即使在快乐的道路上，我们仍然需要用neon重新编译项目，然后确保有足够的GAS来进行重新部署，然后用正确的格式组成适当的参数，然后调用契约并等待20-30秒来生成下一个块，然后调用API <em class="lt"> getapplicationlog </em>来获取JSON中的日志，然后用pretty格式打印响应以找到记录的值(查看下面示例响应中的<strong class="is hu">粗体</strong>部分)。由于通常记录的值是用字节数组表示的，我们还需要将它们转换回字符串或大整数。嗯，一共7步。</p><pre class="kt ku kv kw fq li lj lk ll aw lm dt"><span id="aeab" class="ln jp ht lj b fv lo lp l lq lr">[<br/>  {<br/>    "jsonrpc": "2.0",<br/>    "id": 5,<br/>    "result": {<br/>      "txid": "0x7e3f08a8af4290693184b413ba1d58bede8462cb565baba8ffcc380bf947e317",<br/>      "executions": [<br/>        {<br/>          "trigger": "Application",<br/>          "contract": "0x32682404d4313ecf80b70e1323ccf908a80fdfc0",<br/>          "vmstate": "HALT, BREAK",<br/>          "gas_consumed": "0.039",<br/>          "stack": [],<br/>          <strong class="lj hu">"notifications": [<br/>            {<br/>              "contract": "0xaeccdcf6d7ecf827e7e6baec3c233eca08c27ee3",<br/>              "state": {<br/>                "type": "Array",<br/>                "value": [<br/>                  {<br/>                    "type": "ByteArray",<br/>                    "value": "010203"<br/>                  },<br/>                  {<br/>                    "type": "ByteArray",<br/>                    "value": "04090d"<br/>                  }<br/>                ]<br/>              }<br/>            }<br/>          ]</strong><br/>        }<br/>      ]<br/>    }<br/>  }<br/>]</span></pre><p id="6d8f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">官方文档中介绍了一章<a class="ae kr" href="http://docs.neo.org/en-us/sc/quickstart/test.html" rel="noopener ugc nofollow" target="_blank">单元测试</a>，但是其中的例子仍然需要编译和/或部署。提前avm。</p><p id="d76c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我们开发基于NEO的区块链游戏<a class="ae kr" href="https://github.com/norchain/NEOCarryBattle" rel="noopener ugc nofollow" target="_blank"> CarryBattle </a>时，我的团队<a class="ae kr" href="http://norchain.io/home/" rel="noopener ugc nofollow" target="_blank"> norchain.io </a>强烈感受到了这种局限性。在社区的帮助下，我们开始尝试4阶段工作流程，大大提高了开发效率。</p><h1 id="a3b2" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated"><strong class="ak"> 2。四阶段工作流程</strong></h1><p id="f2b3" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">这个工作流程的四个阶段是<strong class="is hu">编辑</strong>、<strong class="is hu">调试</strong>、<strong class="is hu">私有测试</strong>和<strong class="is hu"> Beta测试</strong>。主要想法是:</p><ol class=""><li id="7607" class="lu lv ht is b it iu ix iy jb lw jf lx jj ly jn lz ma mb mc dt translated">利用一些新工具将<strong class="is hu">编码</strong>阶段分成<strong class="is hu">编辑</strong>和<strong class="is hu">调试。在调试阶段，我们尽可能像常规软件项目一样，跳过或运行本地测试用例，而不与区块链交互。</strong></li><li id="26f9" class="lu lv ht is b it md ix me jb mf jf mg jj mh jn lz ma mb mc dt translated">将<strong class="is hu">测试</strong>阶段分为<strong class="is hu">私有测试</strong>和<strong class="is hu"> Beta测试</strong>，分别使用privateNet/NeoCompiler Eco进行私有测试，使用公共测试网进行Beta测试。使用这种方法，我们可以用最少的努力确保灵活性和兼容性。</li></ol><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff mi"><img src="../Images/dc145fe925c1bbecdec827125fd9c88a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3zy_GxL0HSyXKoOce1YoA.jpeg"/></div></div><figcaption class="le lf fg fe ff lg lh bd b be z ek">Four-Phase NEO Smart Contract Development (C#) Workflow</figcaption></figure><p id="759d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于编辑和调试阶段，我推荐两种方法:<a class="ae kr" href="https://github.com/CityOfZion/neo-debugger-tools" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu"> Neo-Debugger </strong> </a>和<a class="ae kr" href="https://github.com/norchain/Neunity" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu"> Neunity </strong> </a>。</p><p id="0a28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">新调试器</strong></p><p id="f802" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae kr" href="https://github.com/CityOfZion/neo-debugger-tools/releases" rel="noopener ugc nofollow" target="_blank"> Neo-Debugger </a>的项目由<a class="ae kr" href="https://github.com/Relfos" rel="noopener ugc nofollow" target="_blank"> Relfos </a>开发。使用Neon的特殊版本和debug json文件，您可以编写调用级测试用例，并在IDE中逐步运行源代码，跟踪GAS使用情况和应用程序日志，而无需与区块链交互。Neo-Debugger的另一个很好的特性是，它可以在检查堆栈时跳过操作码。Nikolaj-K有一个新调试器的<a class="ae kr" href="https://www.youtube.com/watch?v=KnPHIaEsgtA" rel="noopener ugc nofollow" target="_blank">视频教程</a>。</p><p id="8048" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae kr" href="https://github.com/FabioRick" rel="noopener ugc nofollow" target="_blank"> Fabio </a>也用类似的想法做了一个不错的项目<a class="ae kr" href="https://github.com/FabioRick/SCTracker" rel="noopener ugc nofollow" target="_blank"> SCTracker </a>，但是当他知道Neo-Debugger的存在时，他决定跳过。但还是感谢他的贡献。</p><p id="8081" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> Neunity。适配器</strong></p><p id="8396" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Neo-Debugger在NeoVM级调试方面做得很好，但是它仍然有一些局限性。例如，它还不支持变量监控、断点或函数级测试用例。</p><p id="f1ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Norchain.io创建的框架<a class="ae kr" href="https://github.com/norchain/Neunity" rel="noopener ugc nofollow" target="_blank"> Neunity </a>的<a class="ae kr" href="https://github.com/norchain/Neunity/blob/master/NeunityVisualStudioIntegration.md" rel="noopener ugc nofollow" target="_blank">适配器层</a>走的是一条不同的本地调试之路。Neunity的概念。适配器是:</p><ol class=""><li id="788b" class="lu lv ht is b it iu ix iy jb lw jf lx jj ly jn lz ma mb mc dt translated"><strong class="is hu">引入一个适配器层来隔离NeoVM和normal之间的差异。网络项目</strong>。我们有两个适配器。适配器. NEO 和<em class="lt"> Neunity。Adapter.Unity </em>具有相同的函数签名集，但名称空间和实现不同。它们用于NEO智能合同和Unity项目(实际上也适用于许多其他项目)。Net项目)。这些函数中的大部分都是关于类型转换、操作符或系统调用模拟的。</li><li id="987a" class="lu lv ht is b it md ix me jb mf jf mg jj mh jn lz ma mb mc dt translated">然后我们可以<strong class="is hu">在适配器层之上编写应用程序逻辑。显然，通过简单地改变名称空间，这个应用程序逻辑可以被智能合同或普通合同使用。Net项目。</strong></li><li id="0838" class="lu lv ht is b it md ix me jb mf jf mg jj mh jn lz ma mb mc dt translated">现在我们可以使用功能级测试驱动开发(TDD)，甚至可以与C# Dapp客户端共享逻辑。</li></ol><p id="4dde" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我有一个<a class="ae kr" href="https://www.youtube.com/watch?v=vTkNzx403p8" rel="noopener ugc nofollow" target="_blank">视频教程</a>演示如何使用Neunity。适配器来执行函数级TDD，使用变量监视器和调用堆栈来执行单步调试。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="a571" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">与下表相比，我们可以看到Neo-Debugger和Neunity的优势。适配器。根据我们的经验，Neo-Debugger更适合小规模的项目，因为它消耗的气体开销为零，而Neunity。Adapter更适合大规模或更复杂的项目，因为它更好地支持TDD、多类、断点、变量跟踪等。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff ml"><img src="../Images/f15b1c8215c8a8a96cc860f66fe978d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2YNTE4WmBgFnKPh9DATfPw.jpeg"/></div></div><figcaption class="le lf fg fe ff lg lh bd b be z ek">Comparison between Neo-Debugger and Neunity.Adapter</figcaption></figure><p id="fd76" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Neunity的设计实践大规模软件项目方法论(我指的是系统逻辑的规模。并不意味着单次调用必须复杂或昂贵)。这就是为什么要填补？Net开发人员和NEO开发人员迈出了重要的第一步。同时，Neunity也提供了一个<em class="lt"> Neunity。工具</em>层有灵活序列化(NuSD)、类HTTP通信协议(NuTP)、类URI存储管理(NuIO)等。我们希望帮助更多近地天体区块链Dapps着陆的努力变得切实可行。</p><p id="3ad3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">私人测试</strong></p><p id="47be" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在通过迭代编码和调试阶段完成逻辑之后，我们可以移动到私有测试阶段，并开始与区块链交互。我们建议使用private testNet或<a class="ae kr" href="https://neocompiler.io/#/" rel="noopener ugc nofollow" target="_blank"> NeoCompiler Eco </a>进行私有测试，因为它们的环境简单且易于交互和管理。</p><p id="1383" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">NeoResearch开发的<a class="ae kr" href="https://neocompiler.io/#/" rel="noopener ugc nofollow" target="_blank"> NeoCompiler Eco </a>的公共测试网是新的和特殊的。它不需要应用GAS，同时提供了一整套基于web的GUI工具，包括编译、导入操作码、部署、调用、事务、转换等。NeoResearch最近还集成了gitter.im进行即时聊天，以便更好地与开发者交流。Igor有一个很好的<a class="ae kr" rel="noopener" href="/neoresearch/30-seconds-to-build-and-test-an-ico-on-neo-70c00be6a32d">教程</a>来介绍它的基本功能。</p><p id="e9d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个测试网的另一个好处是每5-7秒生成一个块，几乎比正常情况下快5倍。它缩短了等待时间，并且您几乎不会与同一个块中的其他开发人员的调用发生冲突，这使得测试几乎与私有测试网一样简单。这就是为什么我们建议考虑它作为一个私人测试选项。</p><p id="30ab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> Beta测试</strong></p><p id="899b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果在私有测试阶段成功地测试了所有的功能，我们就可以进入Dapp上线前的最后一个阶段。公共测试网是beta测试的最佳场所，因为它离主网很近。另一个好处是，你也可以邀请你的朋友从他们那端帮助测试。对于来自并行调用和潜在的盲目或无效输入的挑战，您的智能契约应该保持不变。</p><h1 id="f2ca" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">摘要</h1><p id="6127" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">NEO与许多其他公共区块链项目相比有许多优势:如高交易速度、相对友好的开发语言(C#、Python)、国际化和活跃的社区氛围。</p><p id="5fa4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">改进开发工作流程将有助于增强NEO的语言优势，并在不花费太多时间解决琐碎问题的情况下，将闪光的想法整合到实际项目中。</p><p id="0394" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">希望这篇教程能从我有限的知识中提供两分钱。感谢<a class="ae kr" href="https://github.com/FabioRick" rel="noopener ugc nofollow" target="_blank">法比奥</a>和<a class="ae kr" href="https://github.com/Relfos" rel="noopener ugc nofollow" target="_blank">雷佛斯</a>对本教程的帮助。欢迎任何建议和意见。</p><blockquote class="mm"><p id="91e0" class="mn mo ht bd mp mq mr ms mt mu mv jn ek translated"><a class="ae kr" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="mx my mz na nb kx fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mw"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>