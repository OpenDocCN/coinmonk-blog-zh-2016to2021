<html>
<head>
<title>Brownie: Evaluating Solidity Code Coverage via Trace Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Brownie:通过跟踪分析评估可靠性代码覆盖率</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/brownie-evaluating-solidity-code-coverage-via-opcode-tracing-a7cf5a92d28c?source=collection_archive---------1-----------------------#2019-10-01">https://medium.com/coinmonks/brownie-evaluating-solidity-code-coverage-via-opcode-tracing-a7cf5a92d28c?source=collection_archive---------1-----------------------#2019-10-01</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="e01d" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">以太坊智能合约的Python开发和测试框架</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ji"><img src="../Images/629bc58fb10a0cb5680a62fba4c9ee97.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*a1ZzkhcLh9VBWgI5roudOA.png"/></div></figure><h1 id="b2f8" class="jq jr ht bd js jt ju jv jw jx jy jz ka iz kb ja kc jc kd jd ke jf kf jg kg kh dt translated">介绍</h1><p id="22bd" class="pw-post-body-paragraph ki kj ht kk b kl km iu kn ko kp ix kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">每个开发人员的武器库中的一个重要工具是评估他们测试的代码覆盖率的能力。覆盖率报告提供了一个高层次的概述，可以用来发现你的测试套件中的漏洞，虽然高覆盖率并不能保证高质量的测试，但是它确实提供了一个未被发现的bug可能潜伏在哪里的更好的感觉。考虑到智能合约的不可改变性和它们所保护的巨大价值，我们应该欢迎并利用开发过程中的每一个可用工具。</p><p id="3ed2" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">下面的文章讨论了<a class="ae lj" href="https://github.com/iamdefinitelyahuman/brownie" rel="noopener ugc nofollow" target="_blank"> Brownie </a>如何通过跟踪分析处理代码覆盖率。它探讨了动机，给出了实现的概要，讨论了好处和挑战，并讨论了我们下一步的方向。</p><h1 id="4aa1" class="jq jr ht bd js jt ju jv jw jx jy jz ka iz kb ja kc jc kd jd ke jf kf jg kg kh dt translated">这为什么有用？</h1><p id="6f4f" class="pw-post-body-paragraph ki kj ht kk b kl km iu kn ko kp ix kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">在我们探索技术细节之前……看，一个样本布朗尼分支覆盖报告！</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="ab fr cl lk"><img src="../Images/506a608ce95cb6d03f3fd88e404cbe58.png" data-original-src="https://miro.medium.com/v2/format:webp/1*pSl0UNgQKbrO3PfruLgfPQ.png"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Branch coverage report as displayed by the <a class="ae lj" href="https://eth-brownie.readthedocs.io/en/latest/gui.html" rel="noopener ugc nofollow" target="_blank">Brownie GUI</a></figcaption></figure><p id="f0a5" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">每个突出显示的颜色表示该分支在测试期间的评估情况:</p><ul class=""><li id="a666" class="lp lq ht kk b kl le ko lf kr lr kv ls kz lt ld lu lv lw lx dt translated"><strong class="kk hu">绿色</strong>树枝评估有真有假</li><li id="eb5a" class="lp lq ht kk b kl ly ko lz kr ma kv mb kz mc ld lu lv lw lx dt translated"><strong class="kk hu">黄</strong>枝只如实进行了评价</li><li id="6a9c" class="lp lq ht kk b kl ly ko lz kr ma kv mb kz mc ld lu lv lw lx dt translated"><strong class="kk hu">橙色</strong>分支仅被错误评估</li><li id="861d" class="lp lq ht kk b kl ly ko lz kr ma kv mb kz mc ld lu lv lw lx dt translated"><strong class="kk hu">红色</strong>分支未被评估</li></ul><p id="6238" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">有了这个报告，您可以快速地看到您的测试是如何与您的合同交互的。它可以帮助您确定项目中哪些区域需要更多的测试，以及定位不可及的代码部分。</p><h1 id="9ff7" class="jq jr ht bd js jt ju jv jw jx jy jz ka iz kb ja kc jc kd jd ke jf kf jg kg kh dt translated">覆盖评估技术</h1><p id="b1e5" class="pw-post-body-paragraph ki kj ht kk b kl km iu kn ko kp ix kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">概括地说，有两种评估覆盖率的方法:</p><ul class=""><li id="db83" class="lp lq ht kk b kl le ko lf kr lr kv ls kz lt ld lu lv lw lx dt translated"><strong class="kk hu">插装</strong>涉及在整个代码中注入数据收集器，这些收集器用于准确地监控执行了哪些行和分支。这就是流行工具<a class="ae lj" href="https://github.com/sc-forks/solidity-coverage" rel="noopener ugc nofollow" target="_blank">的工作原理。</a></li><li id="aa3d" class="lp lq ht kk b kl ly ko lz kr ma kv mb kz mc ld lu lv lw lx dt translated"><strong class="kk hu">跟踪</strong>包括在编译代码执行时监控其<a class="ae lj" href="https://en.wikipedia.org/wiki/Program_counter" rel="noopener ugc nofollow" target="_blank">程序计数器</a>，然后将执行的指令映射回特定的代码行。</li></ul><p id="084e" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">检测实现起来要简单得多，也是更常用的方法。与跟踪相比，它的主要缺点是<strong class="kk hu">侵入性的</strong>——为监控执行而添加的功能意味着被评估的代码与将在生产中使用的代码不同。</p><p id="b924" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">此外，EVM在天然气成本方面带来了一系列全新的挑战。每项作业都使用天然气，每个区块都有有限的天然气供应。检测契约意味着添加更多的操作，这又意味着增加部署和执行成本。为了保持在块气体限制内，这有时意味着运行修改的EVM规则集。因此，现在我们正在修改的虚拟机中测试一组修改后的代码！</p><p id="315f" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">由于这些原因，Brownie使用跟踪分析而不是检测来执行覆盖率分析。我觉得测试真实代码的好处证明了构建这样一个系统的挑战是值得的。那么，从哪里开始呢？</p><h1 id="af18" class="jq jr ht bd js jt ju jv jw jx jy jz ka iz kb ja kc jc kd jd ke jf kf jg kg kh dt translated">实施基础</h1><p id="e0ef" class="pw-post-body-paragraph ki kj ht kk b kl km iu kn ko kp ix kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">通过跟踪实现覆盖率的关键在于Solidity编译器返回的两个数据结构:</p><ul class=""><li id="cb9d" class="lp lq ht kk b kl le ko lf kr lr kv ls kz lt ld lu lv lw lx dt translated"><strong class="kk hu">抽象语法树</strong>，它是源代码语法的标准化表示。布朗尼使用<a class="ae lj" href="https://github.com/iamdefinitelyahuman/py-solc-ast" rel="noopener ugc nofollow" target="_blank"> py-solc-ast </a>来遍历ast。</li><li id="83e1" class="lp lq ht kk b kl ly ko lz kr ma kv mb kz mc ld lu lv lw lx dt translated"><strong class="kk hu">部署了源代码映射</strong>，其中编译后的操作码被映射到原始源代码。Brownie将其扩展到自己的<a class="ae lj" href="https://eth-brownie.readthedocs.io/en/latest/compile.html#program-counter-map" rel="noopener ugc nofollow" target="_blank">程序计数器图</a>中，并在覆盖率分析中广泛使用。</li></ul><p id="d5b7" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">通过分析AST，我们可以定位语句和分支，然后使用源映射将它们与操作码关联起来。然后，我们查询单元测试期间运行的每个事务上的<code class="eh md me mf mg b"><a class="ae lj" href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs#debug_tracetransaction" rel="noopener ugc nofollow" target="_blank">debug_traceTransaction</a></code> RPC端点，并分析返回的数据以找出哪个代码被命中。对于契约调用，我们将它们作为事务进行广播以获得跟踪，然后立即倒带以确保状态没有改变。很简单，对吧？</p><p id="2068" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">让我们进入螺母和螺栓！</p><h1 id="4a08" class="jq jr ht bd js jt ju jv jw jx jy jz ka iz kb ja kc jc kd jd ke jf kf jg kg kh dt translated">报表覆盖范围</h1><p id="dce8" class="pw-post-body-paragraph ki kj ht kk b kl km iu kn ko kp ix kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">语句是表达要执行的动作的语法单位。它们是独立的、线性的，在代码中只有一个入口和出口。</p><p id="86f8" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">在Solidity中映射语句覆盖相对简单。首先，我们在AST中搜索最深的语句节点(不是另一个语句的父节点)。然后，我们遍历程序计数器映射，寻找具有包含在语句源偏移量内的源偏移量的操作码。只要找到一个，该操作码就与该语句相关联。我们知道，跟踪中出现该操作码意味着该语句已被执行。</p><h1 id="6159" class="jq jr ht bd js jt ju jv jw jx jy jz ka iz kb ja kc jc kd jd ke jf kf jg kg kh dt translated">分支覆盖</h1><p id="c5fd" class="pw-post-body-paragraph ki kj ht kk b kl km iu kn ko kp ix kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">分支覆盖是事情变得有趣的地方。</p><p id="52e8" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">分支是可以使程序执行不同代码的指令。在EVM中，分支由<code class="eh md me mf mg b">JUMPI</code>操作码表示。在Solidity中，这些发生在if语句、require语句和三元运算中。</p><p id="a372" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">为了映射分支覆盖，我们必须首先在AST中搜索以下节点:</p><ul class=""><li id="2df9" class="lp lq ht kk b kl le ko lf kr lr kv ls kz lt ld lu lv lw lx dt translated"><code class="eh md me mf mg b">IfStatement</code> ( <code class="eh md me mf mg b">if (x) {} else {}</code>)</li><li id="cedb" class="lp lq ht kk b kl ly ko lz kr ma kv mb kz mc ld lu lv lw lx dt translated"><code class="eh md me mf mg b">Conditional</code> ( <code class="eh md me mf mg b">a = x &gt; y ? 1 : 2;</code>)</li><li id="c225" class="lp lq ht kk b kl ly ko lz kr ma kv mb kz mc ld lu lv lw lx dt translated"><code class="eh md me mf mg b">FunctionCall</code>包含一个<code class="eh md me mf mg b">require</code>表达式(<code class="eh md me mf mg b">require(x, "oopsie");</code>)</li></ul><p id="4809" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">接下来，我们在这些节点的子节点中搜索<code class="eh md me mf mg b">BinaryOperation</code>表达式(在分支中求值的操作，比如<code class="eh md me mf mg b">x &gt; y</code>或<code class="eh md me mf mg b">returnsBoolFn()</code>)。因为我们还必须考虑嵌套操作，例如<code class="eh md me mf mg b">((x &gt; y) || (x — 4 &lt; y))</code>，所以我们忽略任何包含也是<code class="eh md me mf mg b">BinaryOperation</code>的子节点的<code class="eh md me mf mg b">BinaryOperation</code>节点。</p><p id="628d" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">一旦生成了这个节点列表，我们接下来以类似于处理语句映射的方式关联操作码——寻找具有包含在节点偏移内的源偏移的操作码。我们还必须将这些操作码映射到<code class="eh md me mf mg b">JUMPI</code>指令，我们用它来决定如何评估分支。为此，我们找到包含在ast源偏移量内的具有源偏移量的<strong class="kk hu">最后一个</strong>操作码，并将其与下一个<code class="eh md me mf mg b">JUMPI</code>指令相关联。我们必须使用last操作码的原因与Solidity处理嵌套二进制操作中跳转指令的方式有关。</p><p id="3205" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">确定<code class="eh md me mf mg b">JUMPI</code>的结果与分支评估为真还是假之间的关系取决于节点的类型及其相对于AST中其他节点的位置。有许多规则，也有许多例外。如果你还和我在一起，并且对这是如何处理的感兴趣，我邀请你查看相关的源代码。</p><p id="56a5" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">所有这一切的最终结果是一个与源偏移量和跳转指令相关的操作码图，它可以用来确定一个分支是否已经执行，以及它的评估是真实的还是错误的！【feelsgoodman.jpg<em class="mh">T21</em>T24】</p><h1 id="5f83" class="jq jr ht bd js jt ju jv jw jx jy jz ka iz kb ja kc jc kd jd ke jf kf jg kg kh dt translated">执行时间</h1><p id="f8de" class="pw-post-body-paragraph ki kj ht kk b kl km iu kn ko kp ix kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">这种技术不是没有限制的，最大的限制是执行时间。对<code class="eh md me mf mg b">debug_traceTransaction</code>的查询很慢！Brownie试图通过几种方式来缓解这种情况:</p><ol class=""><li id="47bc" class="lp lq ht kk b kl le ko lf kr lr kv ls kz lt ld mi lv lw lx dt translated">覆盖率数据是按每笔交易跟踪的。每当广播与已经评估的事务相同的事务时，结果从缓存中取出，而不是再次评估。有了设计良好的测试套件，这可以显著提高执行速度。</li><li id="92b8" class="lp lq ht kk b kl ly ko lz kr ma kv mb kz mc ld mi lv lw lx dt translated">Brownie与<code class="eh md me mf mg b"><a class="ae lj" href="https://eth-brownie.readthedocs.io/en/stable/tests-pytest-intro.html#using-xdist-for-distributed-testing" rel="noopener ugc nofollow" target="_blank">pytest-xdist</a></code>插件兼容，允许并行执行测试。同样，适当的设计原则结合xdist的使用可以大大减少执行时间。</li><li id="75d2" class="lp lq ht kk b kl ly ko lz kr ma kv mb kz mc ld mi lv lw lx dt translated">Brownie pytest插件包括一个<code class="eh md me mf mg b"><a class="ae lj" href="https://eth-brownie.readthedocs.io/en/stable/tests-pytest-intro.html#only-running-updated-tests" rel="noopener ugc nofollow" target="_blank">--update</a></code>标志，它允许你只运行涉及到已经改变的源文件的测试。Brownie根据编译的字节码决定哪些文件发生了变化，因此调整注释或重命名变量不需要您重复测试。</li></ol><h1 id="8dcd" class="jq jr ht bd js jt ju jv jw jx jy jz ka iz kb ja kc jc kd jd ke jf kf jg kg kh dt translated">你自己试试！</h1><p id="d0d3" class="pw-post-body-paragraph ki kj ht kk b kl km iu kn ko kp ix kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">如果您想查看Brownie的覆盖率评估，您可以使用以下命令来安装Brownie，下载<a class="ae lj" href="https://github.com/brownie-mix" rel="noopener ugc nofollow" target="_blank"> Brownie Mix </a>令牌模板，运行测试，并打开GUI:</p><pre class="jj jk jl jm fq mj mg mk ml aw mm dt"><span id="3af8" class="mn jr ht mg b fv mo mp l mq mr">pip install eth-brownie<br/>brownie bake token<br/>cd token<br/>brownie test -C<br/>brownie gui</span></pre><p id="5adc" class="pw-post-body-paragraph ki kj ht kk b kl le iu kn ko lf ix kq kr lg kt ku kv lh kx ky kz li lb lc ld hm dt translated">如果你觉得这篇文章很有趣，或者你有任何想法、意见或批评，请联系我们！在下面留下评论，给我发一封<a class="ae lj" href="mailto:b.hauser@zerolaw.tech" rel="noopener ugc nofollow" target="_blank">电子邮件</a>或者在<a class="ae lj" href="https://gitter.im/eth-brownie/community" rel="noopener ugc nofollow" target="_blank"> Gitter </a>或<a class="ae lj" href="https://t.me/iamdefinitelyahuman" rel="noopener ugc nofollow" target="_blank"> Telegram </a>上找到我。我很想收到你的来信。</p><blockquote class="ms"><p id="6f46" class="mt mu ht bd mv mw mx my mz na nb ld ek translated"><a class="ae lj" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nd ne nf ng nh jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nc"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>