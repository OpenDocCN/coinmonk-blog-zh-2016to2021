<html>
<head>
<title>How to create an upgradeable smart contract using ZeppelinOS — example of fixing smart contract vulnerable to underflow/overflow attacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用ZeppelinOS创建可升级的智能合约—修复易受下溢/上溢攻击的智能合约的示例</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-create-an-upgradeable-smart-contract-using-zeppelinos-example-of-fixing-smart-contract-6f6612ed8df4?source=collection_archive---------0-----------------------#2019-04-23">https://medium.com/coinmonks/how-to-create-an-upgradeable-smart-contract-using-zeppelinos-example-of-fixing-smart-contract-6f6612ed8df4?source=collection_archive---------0-----------------------#2019-04-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="57ae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本教程中，我们将使用ZeppelinOS来修复易受下溢/溢出攻击的智能契约。首先，我们将准备我们的环境，创建带有一些错误的可升级智能合同，并对其进行测试。然后，我们将更新代码，升级智能合同，最后，我们将检查它是否安全。</p><p id="fda3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" rel="noopener" href="/@paulina.blaszk/how-to-create-an-upgradeable-smart-contract-using-openzeppelin-sdk-example-of-fixing-smart-260dfbfd5bae?sk=9d4785ea4f3db9d278df99eb1edc28f8">你可以访问这篇文章的更新版本——OpenZeppelin SDK v . 2 . 5 . 2</a></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/576088cf090daec01a03261405ac4227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sUif8A5X81bOpkLssOTbcg.jpeg"/></div></div></figure><h1 id="100a" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">智能合约中的可升级性</h1><p id="9be4" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">原则上，智能合约是不可变的。一旦部署到网络上，就无法更改。不幸的是，在智能合同中，就像在所有软件中一样，错误经常发生。有时它们可能会花费数百万美元…但是不要担心！现在我们有了ZeppelinOS——升级智能合同和修复错误的强大工具。正如ZeppelinOS的<a class="ae jo" href="https://docs.zeppelinos.org/docs/start.html" rel="noopener ugc nofollow" target="_blank">文档</a>所述，ZeppelinOS是一个在以太坊和其他所有EVM和eWASM驱动的区块链上开发、部署和运营智能合同项目的平台。其最重要的功能之一是智能合约的可升级性。</p><h1 id="66a2" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">环境准备</h1><p id="7282" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">您需要安装用于创建和升级智能合同的基本软件。你可以在我的<a class="ae jo" rel="noopener" href="/@paulina.blaszk/how-to-write-and-deploy-first-smart-contract-in-solidity-0-5-x-and-truffle-5-x-x-3054ec5328ad">上一篇</a>中找到安装Node.js和NPM、松露、Ganache的说明。</p><h1 id="e163" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">齐柏林诺斯装置</h1><p id="f95d" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">为了全局安装ZeppelinOS，我们运行一个命令:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="b6a8" class="lk kc ht lg b fv ll lm l ln lo">npm install -g zos</span></pre><p id="22a2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要检查您是否已经安装了ZeppelinOs或确保安装过程成功，您可以验证您的软件版本:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="e834" class="lk kc ht lg b fv ll lm l ln lo">zos --version</span></pre><p id="4f47" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我目前使用的是zos v2.2.3</p><h1 id="c2c2" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">项目设置</h1><p id="ffe6" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">我们必须为我们的项目创建一个新目录，然后导航到它:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="c942" class="lk kc ht lg b fv ll lm l ln lo">mkdir hello-zos<br/>cd hello-zos</span></pre><h1 id="88b4" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">项目启动</h1><p id="80e7" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">开始时，我们需要创建package.json文件:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="aaab" class="lk kc ht lg b fv ll lm l ln lo">npm init -y</span></pre><p id="242c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们运行这个带有<code class="eh lp lq lr lg b">-y</code>标志的命令来生成package.json，而不让它问任何问题——它将采用默认值。当然，如果你想个性化它，你可以只使用<code class="eh lp lq lr lg b">npm init</code>和回答给定的问题。</p><p id="8ee0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，我们终于可以开始我们的第一个ZeppelinOs项目了:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="b027" class="lk kc ht lg b fv ll lm l ln lo">npx zos init hello-zos</span></pre><p id="e780" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果它向我们询问版本，我们可以按enter键接受1.0.0。一个命令<code class="eh lp lq lr lg b">zos init</code>在我们的目录中创建文件<code class="eh lp lq lr lg b">zos.json</code>。它存储了我们的zos项目的一般配置(ZeppelinOS版本、初始化项目的名称、它的版本以及我们的项目包含的关于我们的合同的信息)。</p><p id="1bee" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">更重要的是，<code class="eh lp lq lr lg b">zos init</code>还初始化了松露。这意味着truffle项目的标准结构已经在我们的<code class="eh lp lq lr lg b">hello-zos</code>目录中创建了。现在有两个新的目录(<em class="le">契约</em>和<em class="le">迁移</em>)和<em class="le"> truffle-config.js </em>文件。记得检查<em class="le"> truffle-config.js </em>是否与你的Ganache配置兼容。</p><h1 id="f6b6" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">创建智能合同示例</h1><p id="1c43" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">当我们在代码中发现一个bug时，智能合约不变性的问题可能会特别突出。如果没有可升级性，我们对这样一个智能合同就无能为力，它可能成为黑客攻击的一个很大的目标。对于我们的例子，我们将创建易受下溢/上溢攻击的智能契约(你可以在这里阅读更多关于它的信息)</p><p id="3eef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<code class="eh lp lq lr lg b">zos.json</code>文件中，我们可以看到存储我们合同的对象是空的，所以是时候创建我们的智能合同了。首先，我们在<em class="le">合同</em>目录中添加新文件。我们可以称之为<code class="eh lp lq lr lg b">HelloZos.sol</code>。我们的智能合同将包含:</p><ul class=""><li id="93b0" class="ls lt ht is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma dt translated">字符串状态变量<em class="le">名称</em></li><li id="b623" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma dt translated">uint256状态变量<em class="le"> MaxNumber </em></li><li id="12d3" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma dt translated">uint256状态变量<em class="le"> inc </em></li><li id="d0ce" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma dt translated">uint256状态变量<em class="le"> dec </em></li><li id="c45c" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma dt translated">功能<em class="le">减量</em>(从所选数字中减去1)</li><li id="2fff" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma dt translated">功能<em class="le">增加</em>(将所选数字加1)</li></ul><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="842d" class="lk kc ht lg b fv ll lm l ln lo">pragma solidity ^0.5.0;</span><span id="64c2" class="lk kc ht lg b fv mg lm l ln lo">contract HelloZos {</span><span id="ae43" class="lk kc ht lg b fv mg lm l ln lo">    string public name;<br/>    uint256 public maxNumber;<br/>    uint256 public dec;<br/>    uint256 public inc;</span><span id="3d22" class="lk kc ht lg b fv mg lm l ln lo">    function decrement(uint256 x) public returns (uint256) {<br/>        return dec = x - 1;<br/>    }</span><span id="ad47" class="lk kc ht lg b fv mg lm l ln lo">    function increment(uint256 x) public returns (uint256) {<br/>        return inc = x + 1;<br/>    }</span><span id="fcd0" class="lk kc ht lg b fv mg lm l ln lo">}</span></pre><p id="226c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在可升级的智能合约中，我们使用<em class="le"> init </em>函数，而不是<em class="le">构造函数</em>。为什么？部署智能合约实例时，执行<em class="le">构造器</em>。在基于代理的可升级性系统中，这种情况永远不会发生。这就是为什么我们使用<em class="le">初始化器</em>。为此，在HelloZos.sol的开头，就在<code class="eh lp lq lr lg b">pragma</code>之后，我们必须从ZeppelinOS库导入契约<code class="eh lp lq lr lg b">Initializable.sol</code>:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="5056" class="lk kc ht lg b fv ll lm l ln lo">import "zos-lib/contracts/Initializable.sol"</span></pre><p id="2b01" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当然，要使用ZeppelinOS库，我们必须将它安装在我们的项目目录中，因此我们必须运行一个命令:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="7a1f" class="lk kc ht lg b fv ll lm l ln lo">npm install zos-lib --save</span></pre><p id="3d04" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们可以将我们的智能契约定义为<em class="le">可初始化的</em>并添加<em class="le"> init </em>函数。</p><p id="3e5f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="le">由于一个媒体问题github代码没有在Safari中显示。使用不同的浏览器查看所有内容</em></p><p id="8cb3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">整个合同代码是:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="0a88" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在是享受最大乐趣的时候了——让我们将智能合约部署到网络上，测试它并修复错误！</p><h1 id="610b" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">在zos项目中注册智能合同</h1><p id="9a15" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">首先，我们必须在我们的ZeppelinOS项目中注册智能合同。为此，我们运行一个命令:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="1c8c" class="lk kc ht lg b fv ll lm l ln lo">npx zos add HelloZos</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mj"><img src="../Images/9671bbedcf827dd1a87525c44d601b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*au1N6XZ0tLa1OStjtT35ZA.png"/></div></div></figure><p id="c7ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果我们有多个智能合同，我们可以一次添加它们的所有名称(用空格分隔)或使用<code class="eh lp lq lr lg b">--all</code>标志。</p><p id="4f61" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们的智能合约(两者:<em class="le"> HelloZos </em>和<em class="le"> Initializable </em>)被编译(它们的工件被写入<code class="eh lp lq lr lg b">build/contracts</code>目录)。并且我们可以在我们<code class="eh lp lq lr lg b">zos.json</code>的<em class="le">合同</em>下找到<em class="le"> HelloZos </em>合同</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="74e2" class="lk kc ht lg b fv ll lm l ln lo">{<br/>  “zosversion”: “2.2”,<br/>  “name”: “hello-zos”,<br/>  “version”: “1.0.0”,<br/>  “contracts”: { <br/>    “HelloZos”: “HelloZos” <br/>  }<br/>}</span></pre><h1 id="c2ad" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">将智能合同部署到网络</h1><p id="a42e" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">然后，我们将智能合约部署到指定的网络。在我们的例子中，它是<em class="le"> Ganache </em>本地网络(确保它正在运行),并使用一个命令:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="7915" class="lk kc ht lg b fv ll lm l ln lo">npx zos session --network local --from 0x9ea26a91A3eF090498827989d17FC0E7eEA0987f --expires 3600</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mk"><img src="../Images/7b49bef0fd5daeef6a4c3ff1c87b1c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dmKZbZwXSHS2B7y_bVXcmA.png"/></div></div></figure><p id="32bd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">记住用您的一个Ganache帐户替换<code class="eh lp lq lr lg b">--from</code>标志后的地址<strong class="is hu">，但不要使用第一个帐户(account[0])。我一般选择第二种(accounts[1])或者最后一种(accounts[9])。你也应该使用你的<em class="le"> truffle-config.js </em>中指定的网络(在我们的例子中是<em class="le"> local </em>)。</strong></p><p id="816f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">完成这些准备工作后，我们可以通过运行以下命令将<em class="le"> HelloZos </em>智能合同<em class="le"> </em>推送到我们的本地网络:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="15b4" class="lk kc ht lg b fv ll lm l ln lo">npx zos push</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mj"><img src="../Images/7f332619d228546c8e8d273f91131d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*du3WnuRGepP32NrW2JdKHA.png"/></div></div></figure><p id="2b90" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它创建文件<em class="le">zos . dev-&lt;your-network-number&gt;。json </em></p><h1 id="d042" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">创建智能合同的可升级实例</h1><p id="1cee" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">我们刚刚将<em class="le"> HelloZos </em> contract部署到网络中，但是它只实现了逻辑。如果我们希望与智能合约进行交互，我们必须通过以下方式创建其可升级实例:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="f8f9" class="lk kc ht lg b fv ll lm l ln lo">npx zos create HelloZos --init initialize --args 'Paulina'</span></pre><p id="2804" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在“create”之后，我们添加智能契约的名称，然后我们调用initialize函数，并在- args标志之后传递参数(如果有多个参数，应该用逗号分隔，不要用空格)</p><p id="a6f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">结果是:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff ml"><img src="../Images/f2bc3e5147a023152a60ecbb8900ee1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1oF4kFd6MLhRgg4ADrk3BQ.png"/></div></div></figure><p id="4148" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还可以在zos.dev- <number>的底部找到我们的智能合约。json</number></p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="ed5b" class="lk kc ht lg b fv ll lm l ln lo">"proxies": {<br/>    "hello-zos/HelloZos": [<br/>      {<br/>        "address": "0xfe3d58BdB14d44d1759c1Eb04c91Ac93567dA4Ba",     <br/>        "version": "1.0.0",<br/>        "implementation": "0xf1208D91287aCFBf7c1d7b9c886218a1761f4E20"<br/>      }<br/>    ]<br/>}</span></pre><p id="70e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你的HelloZos代理的地址是我们可以在控制台中看到的白色地址，我们稍后将与它进行交互。“实施”是当前智能合同版本的地址，当我们升级我们的智能合同时，它会发生变化。</p><h1 id="a463" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">与我们的智能合同互动</h1><p id="e095" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">现在我们可以测试我们的智能合约是如何工作的。为了与它交流，我们将使用松露控制台。我们用命令打开它:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="febb" class="lk kc ht lg b fv ll lm l ln lo">npx truffle console --network local</span></pre><p id="1865" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一开始，我们将把<em class="le"> HelloZos </em>契约的实例保存在<code class="eh lp lq lr lg b">myContract</code>变量中:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="d4f6" class="lk kc ht lg b fv ll lm l ln lo">let abi = require("./build/contracts/HelloZos.json").abi</span><span id="d134" class="lk kc ht lg b fv mg lm l ln lo">let myContract = new web3.eth.Contract(abi, "<!-- -->0xd6e0095002f3B287A468203B87D6408f172e1CbF<!-- -->")</span></pre><p id="75ee" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">记住<strong class="is hu">用你的<em class="le"> HelloZos </em>代理的地址替换上面的</strong>地址！</p><p id="62b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们可以检查状态变量的值:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="9a41" class="lk kc ht lg b fv ll lm l ln lo">myContract.methods.name().call()</span><span id="8271" class="lk kc ht lg b fv mg lm l ln lo">let max = await myContract.methods.maxNumber().call()</span><span id="f721" class="lk kc ht lg b fv mg lm l ln lo">max</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mk"><img src="../Images/d1e57bc747eb3bc3766daec398ca818e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VFuOR6YfV81pDDeR9N1Xw.png"/></div></div></figure><p id="fdba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们可以用一个简单的数字来检查我们的函数:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="dd2e" class="lk kc ht lg b fv ll lm l ln lo">myContract.methods.decrement(5).call()</span><span id="99fa" class="lk kc ht lg b fv mg lm l ln lo">myContract.methods.increment(5).call()</span></pre><p id="566d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从表面上看，一切都很好:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mm"><img src="../Images/741d2ff4ff79d1020cab6c7de06175c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okqDPHXN_CdvY-Gp11_5ww.png"/></div></div></figure><p id="10fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，我们用0和最大值调用我们的函数，并检查结果:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="2f99" class="lk kc ht lg b fv ll lm l ln lo">myContract.methods.decrement(0).call()</span><span id="89ce" class="lk kc ht lg b fv mg lm l ln lo">myContract.methods.increment(max).call()</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mn"><img src="../Images/7d29f02fba6ac5c66dbcf4c109043f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TQ10Kkod2MUkPFYl1dm6DQ.png"/></div></div></figure><p id="f089" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们知道我们的智能合约有一个缺陷，容易受到攻击。那怎么办呢？不要担心，我们使用ZeppelinOS，所以我们可以通过几个简单的步骤升级我们的代码。</p><h1 id="b931" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">升级合同</h1><p id="e42e" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">怎么才能修好？我们应该在所有算术运算的智能契约中使用SafeMath库。</p><p id="6551" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将使用OpenZeppelin合同:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="77cb" class="lk kc ht lg b fv ll lm l ln lo">import "openzeppelin-eth/contracts/math/SafeMath.sol";</span></pre><p id="8ca0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意，我们像往常一样导入<code class="eh lp lq lr lg b">openzeppelin-eth</code>而不是<code class="eh lp lq lr lg b">openzeppelin-solidity</code>。有什么区别？<code class="eh lp lq lr lg b">Openzeppelin-eth</code>是EVM包的库，已经被部署到区块链(你可以在<a class="ae jo" href="https://blog.zeppelin.solutions/getting-started-with-openzeppelin-eth-a-new-stable-and-upgradeable-evm-package-576fb37297d0" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中读到更多关于<code class="eh lp lq lr lg b">openzeppelin-eth</code>和<code class="eh lp lq lr lg b">openzeppelin-solidity</code>的区别)。</p><p id="54cf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要使用它，我们必须将EVM包链接到我们的项目:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="9483" class="lk kc ht lg b fv ll lm l ln lo">npx zos link openzeppelin-eth</span></pre><p id="b71f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的<code class="eh lp lq lr lg b">zos.json</code>文件被更新并包含一个具有依赖关系的新对象:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="fde7" class="lk kc ht lg b fv ll lm l ln lo">“dependencies”: {<br/>    “openzeppelin-eth”: “2.1.3”<br/>}</span></pre><p id="00bc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们必须更新我们的<em class="le"> HelloZos </em>智能契约的代码。我们需要更改SafeMath函数的加减字符。</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="3d6c" class="lk kc ht lg b fv ll lm l ln lo">function decrement(uint256 x) public returns (uint256) {     <br/>    return dec = x.sub(1);<br/>}</span><span id="502a" class="lk kc ht lg b fv mg lm l ln lo">function increment(uint256 x) public returns (uint256) {<br/>    return inc = x.add(1);   <br/>}</span></pre><p id="144b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还必须在状态变量下添加下面的语句:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="a8c4" class="lk kc ht lg b fv ll lm l ln lo">using SafeMath for uint256</span></pre><p id="5e5e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="le">由于介质问题，github代码无法在Safari中显示。使用不同的浏览器查看所有内容</em></p><p id="1a99" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的代码全更新了<em class="le"> HelloZos: </em></p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="a8eb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">重要！</strong></p><p id="efba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">升级智能合同时，我们<strong class="is hu">无法</strong>:</p><p id="167a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-改变现有变量的类型，</p><p id="4c5a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-更改变量声明的顺序，</p><p id="fc8c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-删除现有变量，</p><p id="8385" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-在现有变量之前引入一个新变量。</p><p id="198e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你可以在的ZeppelinOS文档中阅读更多关于升级模式的信息。</p><p id="457e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是让我们回到我们全新的<em class="le"> HelloZos </em>。现在我们可以运行命令:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="a929" class="lk kc ht lg b fv ll lm l ln lo">npx zos push --deploy-dependencies</span></pre><p id="380b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们使用<em class="le"> - deploy-dependencies </em>将EVM包部署到我们的本地网络(当我们使用mainnet、ropsten、rinkeby或kovan时，我们不必这样做，因为这些包已经部署好了)。</p><p id="ccbd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，我们可以使用以下命令更新我们的项目:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="22c1" class="lk kc ht lg b fv ll lm l ln lo">npx zos update HelloZos</span></pre><p id="b48a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们可以在truffle控制台中再次测试我们的智能合约。</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="b4ae" class="lk kc ht lg b fv ll lm l ln lo">npx truffle console --network local</span><span id="8ddc" class="lk kc ht lg b fv mg lm l ln lo">let abi = require("./build/contracts/HelloZos.json").abi</span><span id="05c9" class="lk kc ht lg b fv mg lm l ln lo">let myContract = new web3.eth.Contract(abi, "<!-- -->0xd6e0095002f3B287A468203B87D6408f172e1CbF<!-- -->")</span></pre><p id="da17" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">记得用你的代理人的地址替换上面的地址！</p><p id="8098" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们可以检查状态变量的值:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="ba3b" class="lk kc ht lg b fv ll lm l ln lo">let max = await myContract.methods.maxNumber().call()</span><span id="32d9" class="lk kc ht lg b fv mg lm l ln lo">myContract.methods.decrement(0).call()</span><span id="c0c3" class="lk kc ht lg b fv mg lm l ln lo">myContract.methods.increment(max).call()</span></pre><p id="ba08" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我们试图溢出/下溢时，我们会看到</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="8355" class="lk kc ht lg b fv ll lm l ln lo">Error: Returned error: VM Exception while processing transaction: revert</span></pre><p id="7477" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">多亏了ZeppelinOS，我们已经更新了智能合约的代码，并保护我们免受上溢/下溢攻击！</p><h2 id="626b" class="lk kc ht bd kd mo mp mq kh mr ms mt kl jb mu mv kp jf mw mx kt jj my mz kx na dt translated">你可以在我的<a class="ae jo" href="https://github.com/paulinablaszk/hello-zos" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到整个项目。</h2><blockquote class="nb"><p id="1b72" class="nc nd ht bd ne nf ng nh ni nj nk jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="nm nn no np nq ju fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nl"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>