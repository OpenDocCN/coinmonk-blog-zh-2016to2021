<html>
<head>
<title>Why create2?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么要创建2？</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/why-create2-e99b6afcc28c?source=collection_archive---------0-----------------------#2019-02-21">https://medium.com/coinmonks/why-create2-e99b6afcc28c?source=collection_archive---------0-----------------------#2019-02-21</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="0c86" class="pw-subtitle-paragraph iu hs ht bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl ek translated">用创造做“不可能的事”</h2></div><figure class="jn jo jp jq fq jr fe ff paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="fe ff jm"><img src="../Images/6b9d078f916dc07e5eeb991f90a01f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6deFpWSKykge8FgOscboQ.png"/></div></div></figure><p id="1a88" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">前几天，我深入以太坊reddit世界，注意到一些关于新操作码的潜在漏洞的讨论。被称为<code class="eh iq ir is it b">create2</code>的操作码提供了一种创建契约的新机制；但是，<code class="eh iq ir is it b">create2</code>不是在从创建者的地址和事务随机数派生的地址创建契约，而是在从契约的<code class="eh iq ir is it b">init_code</code>、<code class="eh iq ir is it b">address</code>和一些<code class="eh iq ir is it b">salt</code>(任意值)派生的位置创建契约。更正式的说法是这样的:</p><blockquote class="ku kv kw"><p id="577c" class="jy jz kx ka b kb kc iy kd ke kf jb kg ky ki kj kk kz km kn ko la kq kr ks kt hm dt translated"><code class="eh iq ir is it b">keccak256(0xff ++ address ++ salt ++ keccak256(init_code))[12:]</code></p></blockquote><p id="ab26" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">注意:从<a class="ae lb" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md" rel="noopener ugc nofollow" target="_blank">规范</a>中不清楚<code class="eh iq ir is it b">address</code>是发送演员的地址，还是某个任意的地址。我假设是前者(否则用<code class="eh iq ir is it b">salt</code>就多余了)，但我不能确定。</p><p id="a819" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">这背后所陈述的思想是能够在部署之前预先确定契约的地址，这样，如果契约最终是必要的，那么它可能永远不会被部署(我相信这被称为“反事实实例化”)。</p><p id="51c7" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">现在，这一切都很酷，但使用<code class="eh iq ir is it b">create</code>已经很有可能了。我在几个地方指出了这一点，并且<a class="ae lb" href="https://www.reddit.com/r/ethereum/comments/aosaly/create2_eip_vulnerability_questions/egf4f3b/?context=3" rel="noopener ugc nofollow" target="_blank">很快发现自己与该方法的最初提议者之一进行了讨论</a>。为了清楚起见，<code class="eh iq ir is it b">u/technocrypto</code>是一个来自<a class="ae lb" href="https://l4.ventures/" rel="noopener ugc nofollow" target="_blank"> L4 Ventures </a>的<a class="ae lb" href="https://twitter.com/technocrypto" rel="noopener ugc nofollow" target="_blank">杰夫·科尔曼</a>，但是直到后来的谈话中，我才发现他显然有点别有用心。</p><p id="4874" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">他接着声称，在部署之前，在特定的地址提交特定的代码是不可能的。由于对这是否真的可能产生了兴趣，我开始摆弄一个原型。事实证明，这不仅是可能的，而且做起来也很简单。</p></div><div class="ab cl lc ld hb le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hm hn ho hp hq"><p id="8639" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">在我们继续之前，我想稍微分解一下这个原型，从基本原理开始重新构建。他们的主要目标是证明在一个特定的地址提交特定的代码是可能的，而不需要实际部署那些代码。</p><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">The most minimal example</figcaption></figure><p id="9bc0" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">这是模式的核心。这基本上是我们都知道并且喜欢的工厂模式，但是它在到期前只能创建一个<code class="eh iq ir is it b">Machine</code>。</p><p id="387f" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">然而，由于<a class="ae lb" href="https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed" rel="noopener ugc nofollow" target="_blank">合同地址是如何用</a> <code class="eh iq ir is it b"><a class="ae lb" href="https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed" rel="noopener ugc nofollow" target="_blank">create</a></code>生成的，我们可以在调用<code class="eh iq ir is it b">commit</code>之前确定当<code class="eh iq ir is it b">Machine</code>被部署时它将具有什么地址。当我们的<code class="eh iq ir is it b">MachineCommitment</code>被创建时，我们现在确信<code class="eh iq ir is it b">Machine</code>只能存在于从<code class="eh iq ir is it b">MachineCommitment</code>的地址和<code class="eh iq ir is it b">1</code>的随机数计算出的地址中。</p><p id="c6fe" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">如果我们愿意，我们甚至可以在Solidity中这样做:</p><blockquote class="ku kv kw"><p id="aa28" class="jy jz kx ka b kb kc iy kd ke kf jb kg ky ki kj kk kz km kn ko la kq kr ks kt hm dt translated"><code class="eh iq ir is it b">address(keccak256(0xd6, 0x94, address(commitment), 0x01));</code></p></blockquote><p id="5065" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">然而，仅仅这种模式是不够的。这比天真地创建一个新的<code class="eh iq ir is it b">Machine</code>要花费更多的精力来部署，因为<code class="eh iq ir is it b">MachineCommitment</code>需要知道<code class="eh iq ir is it b">Machine</code>代码才能部署它。</p><p id="e9c1" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">我们可以通过借用工厂模式来解决这个问题，本质上是将这个问题分解成几个组成部分:提交部署<em class="kx">一些代码</em>，提交部署<em class="kx">一些地址</em>。</p><p id="5a3b" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">我们最终得到的非常接近上面提出的原型:</p><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">The prototype with some annotations</figcaption></figure><p id="c344" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">旁白:我留下了一些调试(即事件)，因为这种特殊的模式在ethfiddle中不能正常运行，但在Remix中可以正常运行。真不敢相信</p><p id="1952" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">通过部署工厂，我们现在创建了创建一些特定代码的承诺。通过部署承诺，并且只提供工厂的地址，我们已经创建了一个特定地址的承诺。总的来说，这仍然以可重用和可移植的形式在<em class="kx">特定地址</em>提供对<em class="kx">特定代码</em>的承诺。</p></div><div class="ab cl lc ld hb le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hm hn ho hp hq"><p id="c2de" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">这种模式要解决的确切问题如下:</p><blockquote class="ku kv kw"><p id="8145" class="jy jz kx ka b kb kc iy kd ke kf jb kg ky ki kj kk kz km kn ko la kq kr ks kt hm dt translated">如今，如果没有依靠无密钥签名的疯狂炮制的多交易黑客，就无法保证非受信任方在异步情况下将特定代码部署到特定地址，无密钥签名被迫预先承诺特定的天然气价格，根据您的使用情况，甚至可能提前几个月或几年，如果您猜错了，所有状态都可能被永久破坏。</p></blockquote><p id="9d4a" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">上面的模式正是这样做的:它承诺在需要代码本身之前将特定的代码部署到特定的地址。它不需要“多交易黑客”、“无钥匙签名”或“对特定天然气价格的预先承诺”。可以对模式进行简单的修改，以支持不可信或任意方作为部署者。除了最初的承诺之外，没有对涉及地址的交互的同步性做出任何假设。</p><p id="fc2c" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">当这种特殊的模式被作为一种解决方案提出时，人们的反应并不是注意到它确实是可能的，而是批评它的各个方面。</p><p id="2b53" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">第一个批评是任何人都可以调用<code class="eh iq ir is it b">commit</code>方法并自己消费承诺。这是真的，<code class="eh iq ir is it b">commit</code>是一个任何人都可以调用的公共函数。然而，这可以用任何身份验证方案来解决，但实际上可能是将来需要的属性。当我们用这种模式实际构建一些东西时，我们稍后会回到这一点。</p><p id="7f62" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">第二个批评是构造函数可能需要参数。然而，因为我们将我们的承诺与正在部署的代码紧密耦合，所以通过一些<a class="ae lb" href="https://gist.github.com/DeviateFish/eb992842c6d1a09f35ec93cf4fbb474d" rel="noopener ugc nofollow" target="_blank">细微的修改</a>这是可能的。</p><p id="c98d" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">第三个批评是，对于将来要部署的每个契约，都需要一个特定的工厂。这是有效的，但同样，这仅仅是一个原型。我们可以通过多种方式实现这一点，但最简单的方式是借用<a class="ae lb" href="https://blog.zeppelinos.org/proxy-patterns/" rel="noopener ugc nofollow" target="_blank">众所周知的代理模式</a>来创建一个通用承诺:</p><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">A more generic commitment</figcaption></figure><p id="7d79" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">正如您所看到的，这个承诺现在已经与正在部署的代码完全分离了。<code class="eh iq ir is it b">factory</code>是一个通用地址，回退函数将所有调用数据转发给工厂，允许工厂上的任意方法被调用。在这个特定的例子中，可以使用来自已部署的<code class="eh iq ir is it b">Factory</code>上的<code class="eh iq ir is it b">getSig</code>的返回值作为对<code class="eh iq ir is it b">Commitment</code>上的回退函数的调用的calldata。</p><p id="861b" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">但是如果我们想更进一步呢？如果我们只是想要一些任意代码的承诺呢？事实证明我们也能做到。事实上，在我研究的这一点上，我意识到我不是第一个想出这个模式的人。</p><p id="528a" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">为了实现我们对任意代码的承诺的目标，让我们把所有的部分放在一起:</p><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="lj lk l"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Ain’t that a sweet lil’ thang</figcaption></figure><p id="d7be" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">所以，现在我们的<code class="eh iq ir is it b">MachineCommitment</code>只是一个简单的承诺，在一个通用的<code class="eh iq ir is it b">Deployer</code>契约的帮助下部署一些特定的代码，这个契约可以为我们部署代码。我们还得到保证，被部署的代码(可以说是<code class="eh iq ir is it b">init_code</code>)是最初承诺的。我们仍然有两个必需的部分:对特定地址的承诺和对特定代码的承诺。</p><p id="14aa" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">但是我们可以做得更好。我们根本不需要部署者，真的。使用上面的delegatecall方法减少了一些麻烦，但这并不是必需的特性，而且增加了复杂性。</p><p id="ffb0" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">相反，我们可以制定一个本身就是<code class="eh iq ir is it b">create2</code>的契约。这真的很简单:</p><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="a092" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">如果你想在稍微干净一点的环境中尝试一下(无意冒犯ethfiddle，它只是缺少一些特性)，试着去<a class="ae lb" href="https://remix.ethereum.org/#optimize=false&amp;version=soljson-v0.4.22+commit.4cb486ee.js" rel="noopener ugc nofollow" target="_blank"> Remix IDE </a>把这段代码放在那里。您可以部署自己的<code class="eh iq ir is it b">Machine</code>来捕获init代码值，并尝试部署不同的<code class="eh iq ir is it b">Create2</code>承诺。这可能会稍微精简一些(例如，通过移除<code class="eh iq ir is it b">committedAddress</code>助手)。此外，如果你想使用不同于上面提供的<code class="eh iq ir is it b">init_code</code>，你需要自己计算<code class="eh iq ir is it b">codeHash</code>。</p><p id="5bb7" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">我还把这个最终的表单<a class="ae lb" href="https://gist.github.com/DeviateFish/6241c6ab0c8cfc9221d3a40f3e0cd9ba" rel="noopener ugc nofollow" target="_blank">放到了一个要点</a>中，以防它需要更新或修复。</p><p id="c216" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">到目前为止，我们已经缩小了<code class="eh iq ir is it b">create</code>能做的和<code class="eh iq ir is it b">create2</code>能提供的之间的差距。事实上，两者之间唯一的区别是需要在链上发布<code class="eh iq ir is it b">Create2</code>承诺。</p></div><div class="ab cl lc ld hb le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hm hn ho hp hq"><p id="72d6" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">既然我们已经提炼出一个模式，使我们能够在一个确定的地址提交任意代码…让我们使用它。在我的下一篇文章中，我会用这种模式创造一些东西。我不确定是什么。它可能是一个简单的国家频道，它可能是另一个彩票(lol)，或者可能是更奇特的东西，如混合器！本质上，混音器并不需要这种模式，但这可能还是很有趣的。</p><p id="9618" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">同样值得注意的是，这种模式的“最终形式”本身对这些应用程序并不十分有用。事实上，我认为我们会发现，在我们的实际实现中，我们最终会使用该模式的一些早期版本，因为我们实际上<em class="kx">希望</em>提交特定的、可验证的代码，因此不需要更通用的变体。</p></div><div class="ab cl lc ld hb le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hm hn ho hp hq"><p id="a3a0" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">我很想听到<em class="kx">连贯的</em>反馈，关于这个模式不能做什么，而<code class="eh iq ir is it b">create2</code>能做什么。如果您能够以编程的方式，或者至少以某种具体的方式来表述这些差异，那将是首选。我不感兴趣的是听到“我们为<code class="eh iq ir is it b">x</code>需要<code class="eh iq ir is it b">create2</code>”，而没有具体说明<code class="eh iq ir is it b">create2</code>的潜在功能需求实际上是什么。</p><p id="601c" class="pw-post-body-paragraph jy jz ht ka b kb kc iy kd ke kf jb kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">明显的区别是<code class="eh iq ir is it b">create2</code>允许在特定地址提交特定代码，而不需要链上事务——这很酷，但看起来更像是一种优化。如果有人能描述为什么这不仅仅是一个简单的优化，我也很乐意听到。</p><figure class="jn jo jp jq fq jr fe ff paragraph-image"><a href="https://cryptofi.co"><div class="fe ff lp"><img src="../Images/e7b1dbc6a532a697c6844fdf0f0bbd30.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*HrFLDXz92JavTZXjhmvU7g.png"/></div></a></figure><blockquote class="lq"><p id="2d59" class="lr ls ht bd lt lu lv lw lx ly lz kt ek translated"><a class="ae lb" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mb mc md me mf jr fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ma"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>