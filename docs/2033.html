<html>
<head>
<title>Implementing Proof of Stake Part — 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实施利害关系证明第4部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/implementing-proof-of-stake-part-4-2107bb07dfed?source=collection_archive---------1-----------------------#2019-02-01">https://medium.com/coinmonks/implementing-proof-of-stake-part-4-2107bb07dfed?source=collection_archive---------1-----------------------#2019-02-01</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="0fe8" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">本文给出了一个在node.js中实现利益一致性算法的简单方法</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ji"><img src="../Images/67a3c3a562cf394e00d1dc1fd2774c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*X1523S70lXzN1lyg8sm7mQ.jpeg"/></div></figure><p id="44a9" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在<a class="ae km" rel="noopener" href="/coinmonks/implementing-proof-of-stake-part-3-c68b953a50be">之前的文章</a>中，我们创建了一个基本的p2p服务器和一个API来与我们的区块链交互。在这一部分，我们将进一步扩展我们的项目，我们将实现一个钱包。</p><h1 id="b8b0" class="kn ko ht bd kp kq kr ks kt ku kv kw kx iz ky ja kz jc la jd lb jf lc jg ld le dt translated">钱包</h1><p id="21e8" class="pw-post-body-paragraph jq jr ht js b jt lf iu jv jw lg ix jy jz lh kb kc kd li kf kg kh lj kj kk kl hm dt translated">为了创造一种加密货币，我们需要一个钱包。钱包将有两个密钥，即公钥和一个对应的私钥。公钥/私钥对是不对称加密的一部分，我们将使用它来创建数字签名。</p><p id="be22" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">数字签名允许用户验证创建区块和交易的矿工。一旦使用私钥对数据进行了签名/加密，就只能使用公钥对其进行验证/解密。</p><p id="8f9b" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在根目录中创建一个单独的文件夹wallet，并在其中添加一个<code class="eh lk ll lm ln b">wallet.js</code>文件，我们将在其中创建我们的wallet类。</p><p id="104b" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们的钱包将有3个主要属性，余额、密钥对和公钥。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="e3f6" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">注意:我已经将变量<code class="eh lk ll lm ln b">secret</code>作为参数传递给了构造函数。我们将在创建钱包时传递一个。</p><p id="5f79" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">为了创建一个密钥对(公钥和私钥),我们将使用一个叫做椭圆的模块。让我们安装它。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="0563" class="lu ko ht ln b fv lv lw l lx ly">npm i elliptic --save</span></pre><p id="073d" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们在根目录下创建一个名为<code class="eh lk ll lm ln b">chain-util.js</code>的新文件，它将保存与加密货币相关的函数。我们将使用刚刚安装的这个模块，我们将在我们的应用程序中使用基于<code class="eh lk ll lm ln b">ec</code>曲线的算法。所以在chainUtil.js中要求从椭圆中得到<code class="eh lk ll lm ln b">eddsa</code>算法并使用<code class="eh lk ll lm ln b">ed25519</code>创建一个实例</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="b7b4" class="lu ko ht ln b fv lv lw l lx ly">const EDDSA = require("elliptic").eddsa;<br/>const eddsa = new EDDSA("ed25519");</span></pre><p id="0215" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们在<code class="eh lk ll lm ln b">chainUtil </code>类中创建一个函数，我们将在应用程序中使用它来生成一个密钥对。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="958e" class="lu ko ht ln b fv lv lw l lx ly">class ChainUtil {</span><span id="1f17" class="lu ko ht ln b fv lz lw l lx ly">  static genKeyPair(secret) {</span><span id="b9a4" class="lu ko ht ln b fv lz lw l lx ly">    return eddsa.keyFromSecret(secret);</span><span id="a0d5" class="lu ko ht ln b fv lz lw l lx ly">  }</span><span id="9dc5" class="lu ko ht ln b fv lz lw l lx ly">}</span><span id="ca7a" class="lu ko ht ln b fv lz lw l lx ly">module.exports = ChainUtil;</span></pre><p id="e13c" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在我们可以在我们的wallet类中使用这个函数，并使用<code class="eh lk ll lm ln b">getPublic()</code>函数来获取public an并将其编码为十六进制格式。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="a380" class="lu ko ht ln b fv lv lw l lx ly">this.keyPair = ChainUtil.genKeyPair();</span><span id="a751" class="lu ko ht ln b fv lz lw l lx ly">this.publicKey = this.keyPair.getPublic('hex');</span></pre><p id="6cb0" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们的基本钱包准备好了。交易时间到了。</p><h1 id="7477" class="kn ko ht bd kp kq kr ks kt ku kv kw kx iz ky ja kz jc la jd lb jf lc jg ld le dt translated">处理</h1><p id="b1b6" class="pw-post-body-paragraph jq jr ht js b jt lf iu jv jw lg ix jy jz lh kb kc kd li kf kg kh lj kj kk kl hm dt translated">我们的交易将具有以下结构—</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="2979" class="lu ko ht ln b fv lv lw l lx ly">{<br/>  id: &lt;here goes some identifier&gt;<br/>  type: &lt;transactions type: stake,validator,transaction&gt;<br/>  input: {<br/>          timestamp: &lt;time of creation&gt;,<br/>          from: &lt;senders address&gt;,<br/>          signature: &lt;signature of the transaction&gt;<br/>         }<br/>  output: {<br/>           to: &lt;recievers address&gt;<br/>           amount: &lt;amount transfered&gt;<br/>           fee: &lt;transactions fee&gt;<br/>          }<br/>}</span></pre><p id="03c1" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">每笔交易都需要一个唯一的id。为了生成这些唯一的数字，我们将使用一个名为uuid的模块。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="8119" class="lu ko ht ln b fv lv lw l lx ly">npm i uuid --save</span></pre><p id="05e1" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们在<code class="eh lk ll lm ln b">chain-util.js</code>文件中创建这个模块的一个实例。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="c290" class="lu ko ht ln b fv lv lw l lx ly">const uuidV1 = require('uuid/v1');</span><span id="7359" class="lu ko ht ln b fv lz lw l lx ly">// version 1 use timestamp to generate unique ids, although in production one shouldn't use this</span></pre><p id="d111" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们创建一个函数来生成id。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="0be8" class="lu ko ht ln b fv lv lw l lx ly">static id(){<br/>        return uuidV1();<br/>}</span></pre><p id="b899" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">既然我们可以唯一地识别交易。我们可以创建我们的事务类。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="287e" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">输入和输出将是如上所述的对象。</p><p id="a31e" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在输出对象中也有一个字段<code class="eh lk ll lm ln b">fee</code>用来添加交易费，我们将创建一个常量并在<code class="eh lk ll lm ln b">generateTransaction()</code>函数中添加使用它。因为我们以后可能要改变费用，所以我们将把这个内容保存在一个单独的文件中。</p><p id="a283" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在根文件夹中创建一个<code class="eh lk ll lm ln b">config.js</code>，并在其中添加一个常量变量<code class="eh lk ll lm ln b">TRANSACTION_FEE</code>。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lo lp l"/></div><figcaption class="ma mb fg fe ff mc md bd b be z ek">config.js file</figcaption></figure><p id="7d24" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们创建一个函数来创建一个事务。这个函数将接收发送者的钱包实例、发送的金额和接收者的地址。</p><p id="b955" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">它将检查发送方是否有足够的余额，然后创建一个事务对象，将所有属性传递给该函数。为了保持代码的模块化，我们将把函数分成两部分。<code class="eh lk ll lm ln b">generateTransaction</code>实际上会起到同样的作用，但看起来会整洁得多。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="92ae" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们的事务现在需要一个输入对象。我们将使用wallets密钥对对交易进行签名，并将签名和其他相关信息一起添加到输入对象中。</p><p id="759b" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们在<code class="eh lk ll lm ln b">wallet/index.js</code>文件中添加一个符号函数</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="8214" class="lu ko ht ln b fv lv lw l lx ly">sign(dataHash){</span><span id="7ac5" class="lu ko ht ln b fv lz lw l lx ly">   return this.keyPair.sign(dataHash);</span><span id="3316" class="lu ko ht ln b fv lz lw l lx ly">}</span></pre><p id="d347" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">当我们创建新的交易时，我们将在<code class="eh lk ll lm ln b">transaction.js</code>文件中使用这个函数。让我们在transaction类中添加一个名为<code class="eh lk ll lm ln b">signTransaction()</code>的函数。该函数将获取transaction和senders wallet的实例，并在transaction中创建一个签名输入。</p><p id="eebc" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">请注意，我们多次使用散列函数。我们可以把它抽象成chain-util.js，使代码更加可重用。让我们在<code class="eh lk ll lm ln b">chainUtil</code>中创建一个<code class="eh lk ll lm ln b">hash(data)</code>函数并使用它，而不是直接使用<code class="eh lk ll lm ln b">SHA256</code></p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="a2af" class="lu ko ht ln b fv lv lw l lx ly">static hash(data){</span><span id="c63f" class="lu ko ht ln b fv lz lw l lx ly">   return SHA256(JSON.stringify(data)).toString();</span><span id="2077" class="lu ko ht ln b fv lz lw l lx ly">}</span></pre><p id="73b3" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">也在block.js文件中进行这些更改。</p><p id="2ceb" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">好的，接下来我们将在transaction.js中创建<code class="eh lk ll lm ln b">signTransaction()</code>函数</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="fd56" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在在<code class="eh lk ll lm ln b">generateTransaction()</code>函数中，我们可以调用带参数的<code class="eh lk ll lm ln b">signTransaction()</code>作为当前交易和发送者的钱包，然后返回交易对象。</p><p id="bc20" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们还需要验证交易真实性的功能。</p><p id="f251" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们创建一个<code class="eh lk ll lm ln b">verifyTransaction()</code>函数来验证事务的散列和数字签名。</p><p id="c96a" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">为了验证一个签名，我们需要使用公钥解密它。椭圆模块提供了这种内置的功能。让我们在<code class="eh lk ll lm ln b">ChainUtil</code>类中创建一个函数verifySignature()，我们稍后会用到它。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="f5d7" class="lu ko ht ln b fv lv lw l lx ly">static verifySignature(publicKey,signature,dataHash){</span><span id="8546" class="lu ko ht ln b fv lz lw l lx ly">return ec.keyFromPublic(publicKey).verify(dataHash,signature);</span><span id="b3f4" class="lu ko ht ln b fv lz lw l lx ly">}</span></pre><p id="e65e" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在，在Transaction类中，让我们创建一个名为<code class="eh lk ll lm ln b">verifyTransaction()</code>的函数，其中我们将使用刚刚创建的verifySignature函数。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="af08" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们的事务类终于完成了。这是它的样子。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lo lp l"/></div></figure><h1 id="4603" class="kn ko ht bd kp kq kr ks kt ku kv kw kx iz ky ja kz jc la jd lb jf lc jg ld le dt translated">游泳池</h1><p id="c025" class="pw-post-body-paragraph jq jr ht js b jt lf iu jv jw lg ix jy jz lh kb kc kd li kf kg kh lj kj kk kl hm dt translated">由于多个个人使用他们的钱包在加密货币上创建交易，因此需要一种方法来包含这些交易的组，我们现在将使用交易池的概念。事务池将是一个实时更新的对象，包含网络中所有挖掘者提交的所有新事务。</p><p id="0a01" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">用户将创建事务，然后将每个事务提交到池中。池中出现的这些新交易将被视为未确认交易。</p><p id="036c" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">挖掘器从该池中取出一组事务，并创建块，使事务得到确认。</p><p id="5ba3" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">为了更新我们的事务池，我们将使用我们创建的p2p服务器，并向网络广播事务。当我们收到新的交易时，我们会将其添加到我们的池中。</p><p id="5739" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">但是首先，让我们在wallet目录中创建<code class="eh lk ll lm ln b"> transaction-pool.js</code>文件，并创建一个<code class="eh lk ll lm ln b">TransactionPool </code>类。</p><p id="4f90" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">这个类只有一个属性事务数组。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="5fb1" class="lu ko ht ln b fv lv lw l lx ly">this.transactions = [];</span></pre><p id="a083" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们向池中添加一些方法。</p><p id="da20" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在列表中添加推送交易的方法。请注意，我们可能会收到已经收到的交易，因此也需要事先检查。</p><p id="18d6" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">创建一个函数<code class="eh lk ll lm ln b">addTransaction(transaction)</code>，这个方法将简单地把事务添加到池中。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="57bc" class="lu ko ht ln b fv lv lw l lx ly">const Transaction = require("./transaction");<br/>class TransactionPool {<br/>  constructor() {<br/>    this.transactions = [];<br/>  }</span><span id="8b75" class="lu ko ht ln b fv lz lw l lx ly">  addTransaction(transaction) {<br/>    this.transactions.push(transaction);<br/>  }<br/>}<br/>module.exports = TransactionPool;</span></pre><p id="18f8" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">这是我们游泳池的样子:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="2ffe" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">因为我们的钱包负责创建交易，所以我们需要一个函数来完成这项工作。创建一个函数来创建一个新的交易，使用我们的钱包签名，并将其添加到我们的交易池。我们将使用上面创建的所有函数。</p><p id="f1cc" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们在wallet类中创建一个<code class="eh lk ll lm ln b">createTransction()</code>函数来完成这项工作，因为我们需要将事务添加到事务池中，我们需要一个事务池实例作为参数。</p><p id="0c13" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">为了创建事务，我们需要一个端点。让所有我们已经创建到我们的主应用程序。</p><p id="50b2" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们制作<code class="eh lk ll lm ln b">createTransaction()</code>函数</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="3159" class="lu ko ht ln b fv lv lw l lx ly">createTransaction(to, amount, type, blockchain, transactionPool) {<br/>    let transaction = Transaction.newTransaction(this, to, amount,                                                                                                    type);<br/>    transactionPool.addTransaction(transaction);<br/>    return transaction;<br/>  }</span></pre><p id="79b8" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在app/index.js文件中，创建一个wallet实例和一个transactionPool实例。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="4058" class="lu ko ht ln b fv lv lw l lx ly">const Wallet = require('../wallet');</span><span id="142e" class="lu ko ht ln b fv lz lw l lx ly">const TransactionPool = require('../wallet/transaction-pool');</span><span id="a301" class="lu ko ht ln b fv lz lw l lx ly">// create a new wallet</span><span id="a2cd" class="lu ko ht ln b fv lz lw l lx ly">const wallet = new Wallet(Date.now().toString());</span><span id="0a50" class="lu ko ht ln b fv lz lw l lx ly">// Date.now() is used create a random string for secret</span><span id="c0fc" class="lu ko ht ln b fv lz lw l lx ly">// create a new transaction pool which will be later</span><span id="59fa" class="lu ko ht ln b fv lz lw l lx ly">// decentralized and synchronized using the peer to peer server</span><span id="1dae" class="lu ko ht ln b fv lz lw l lx ly">const transactionPool = new TransactionPool();</span></pre><p id="dcc3" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们做一个get端点<code class="eh lk ll lm ln b"> ‘/transactions’</code></p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="e550" class="lu ko ht ln b fv lv lw l lx ly">// api to view transaction in the transaction pool</span><span id="5cfa" class="lu ko ht ln b fv lz lw l lx ly">app.get('/transactions',(req,res)=&gt;{</span><span id="eec6" class="lu ko ht ln b fv lz lw l lx ly">  res.json(transactionPool.transactions);</span><span id="0ff4" class="lu ko ht ln b fv lz lw l lx ly">});</span></pre><p id="c8b3" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在运行应用程序并打开postman</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="2991" class="lu ko ht ln b fv lv lw l lx ly">npm run dev</span></pre><p id="111d" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">点击api，您将得到一个空数组作为我们期望的响应。</p><p id="52a2" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们创建post <code class="eh lk ll lm ln b"> ‘/transact’ </code>来创建新的事务</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="d4ce" class="lu ko ht ln b fv lv lw l lx ly">// create transactions</span><span id="0a51" class="lu ko ht ln b fv lz lw l lx ly">app.post("/transact", (req, res) =&gt; {</span><span id="a98a" class="lu ko ht ln b fv lz lw l lx ly">  const { to, amount, type } = req.body;</span><span id="629a" class="lu ko ht ln b fv lz lw l lx ly">  const transaction = wallet.createTransaction(</span><span id="09e7" class="lu ko ht ln b fv lz lw l lx ly">     to, amount, type, blockchain, transactionPool</span><span id="d91f" class="lu ko ht ln b fv lz lw l lx ly">  );</span><span id="d0ba" class="lu ko ht ln b fv lz lw l lx ly">res.redirect("/transactions");</span><span id="1962" class="lu ko ht ln b fv lz lw l lx ly">});</span></pre><p id="f225" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">用收件人的地址和金额在postman中测试这个api，您会发现您不能创建交易，因为您的初始余额是零。</p><p id="8c2f" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><em class="me">出于测试目的，我们可以创建一个常量</em> <code class="eh lk ll lm ln b"><em class="me">INITIAL_BALANCE</em></code> <em class="me">来检查一切是否正常。在</em> <code class="eh lk ll lm ln b"><em class="me">config.js</em></code> <em class="me">中添加一个常量</em> <code class="eh lk ll lm ln b"><em class="me">INITIAL_BALANCE</em></code> <em class="me">并在wallet类构造函数中使用。将余额设置为该变量，在config.js中将</em> <code class="eh lk ll lm ln b"><em class="me">INITIAL_BALANCE</em></code> <em class="me">设置为100。</em></p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="bac0" class="lu ko ht ln b fv lv lw l lx ly">// wallet.js<br/>const {INITAL_BALANCE} = require('../config');</span><span id="4354" class="lu ko ht ln b fv lz lw l lx ly"><br/>this.balance = INITIAL_BALANCE</span><span id="cdb6" class="lu ko ht ln b fv lz lw l lx ly">// config.js<br/>INITAL_BALANCE = 100</span></pre><p id="decf" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在，用JSON数据创建一个post请求，其中包含to、amount和type字段:</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="61b2" class="lu ko ht ln b fv lv lw l lx ly">{<br/> “to”:”rand-address”,<br/> “amount”:10,<br/> “type”: “TRANSACTION”<br/>}</span></pre><p id="59ac" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">点击几次发送，你会得到一个令人满意的交易列表。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mf"><img src="../Images/4ababa546eb8085eb3c0e123f9de8807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMG5oXkcjYnXEbRqGxCcMw.png"/></div></div><figcaption class="ma mb fg fe ff mc md bd b be z ek">Transaction present in the pool</figcaption></figure><p id="8541" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">太好了！！</p><h1 id="eafa" class="kn ko ht bd kp kq kr ks kt ku kv kw kx iz ky ja kz jc la jd lb jf lc jg ld le dt translated">广播交易</h1><p id="a9be" class="pw-post-body-paragraph jq jr ht js b jt lf iu jv jw lg ix jy jz lh kb kc kd li kf kg kh lj kj kk kl hm dt translated">尽管我们可以在应用程序中创建事务，但我们还必须实现一些功能，将这些事务发送到网络中的其他节点。为了实现这一点，我们将利用我们的p2p服务器类。</p><p id="79f1" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们可以在p2p服务器中添加一个事务池实例。这样，我们的服务器可以直接访问事务。</p><p id="9aea" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在P2server类中，我们将在其构造函数中添加另一个属性，即事务池实例。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="1555" class="lu ko ht ln b fv lv lw l lx ly">constructor(blockchain,transactionPool){</span><span id="999a" class="lu ko ht ln b fv lz lw l lx ly">this.blockchain = blockchain;</span><span id="23f9" class="lu ko ht ln b fv lz lw l lx ly">this.sockets = [];</span><span id="1de1" class="lu ko ht ln b fv lz lw l lx ly">this.transactionPool = transactionPool;</span><span id="a7ec" class="lu ko ht ln b fv lz lw l lx ly">}</span></pre><p id="9d5e" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们还需要更新我们在app/index.js文件中创建的实例，并将<code class="eh lk ll lm ln b">transactioPool</code>实例传递给<code class="eh lk ll lm ln b">p2pserver</code>实例。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="27ce" class="lu ko ht ln b fv lv lw l lx ly">const p2pserver = new P2pserver(blockchain,transactionPool);</span></pre><p id="40f5" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在让我们创建一个方法来处理p2pserver类中的事务。该方法将非常类似于我们现在已经拥有的同步链功能，该功能同步连接到该应用程序套接字的每个个体的链。</p><p id="f903" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">为了处理多种消息类型，我们将在p2pserver类中创建一个对象MESSAGE_TYPE。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="aa3d" class="lu ko ht ln b fv lv lw l lx ly">const MESSAGE_TYPE = {</span><span id="776b" class="lu ko ht ln b fv lz lw l lx ly">chain: 'CHAIN',</span><span id="0a29" class="lu ko ht ln b fv lz lw l lx ly">transaction: 'TRANSACTION'</span><span id="1dd7" class="lu ko ht ln b fv lz lw l lx ly">}</span></pre><p id="e0b2" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">每当创建新的事务时，该方法都会将事务发送到每个连接的套接字。</p><p id="2c02" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">所以，让我们在p2pserver类中创建一个函数<code class="eh lk ll lm ln b">broadcastTransaction(transaction)</code>。这个函数将把事务发送到每个套接字。为了模块化代码，我们可以创建另一个名为<code class="eh lk ll lm ln b">sendTransaction(socket,transaction)</code>的函数，只是将一个事务发送到一个套接字，并为每个套接字调用这个函数。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="8a87" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">类似地，我们也将使用MESSAGE_TYPEs来发送链。所以也更新一下<code class="eh lk ll lm ln b">sendChain </code>功能。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="a427" class="lu ko ht ln b fv lv lw l lx ly">sendChain(socket){</span><span id="7b1e" class="lu ko ht ln b fv lz lw l lx ly">  socket.send(JSON.stringify({</span><span id="d429" class="lu ko ht ln b fv lz lw l lx ly">  type: MESSAGE_TYPE.chain,</span><span id="1007" class="lu ko ht ln b fv lz lw l lx ly">  chain: this.blockchain.chain </span><span id="8855" class="lu ko ht ln b fv lz lw l lx ly"> }));</span><span id="fe4d" class="lu ko ht ln b fv lz lw l lx ly">}</span></pre><p id="e2d4" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们也编写代码来处理发送给我们的事务。</p><p id="977b" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">由于我们有不同类型的消息，我们需要不同地处理它们，而不是创建多个函数，我们将使用switch语句来根据消息类型选择句柄。</p><p id="cad8" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在我们的消息处理程序中，对于作为数据的链，我们将调用<code class="eh lk ll lm ln b">replaceChain </code>函数，对于作为事务的数据，我们将调用<code class="eh lk ll lm ln b">addTransaction </code>函数。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="2402" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">如果接收到的事务不在池中，上面的代码片段会将它添加到池中。注意，我们需要在<code class="eh lk ll lm ln b">transactionPool </code>类中编写函数<code class="eh lk ll lm ln b">transactionExists()</code>。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="0f45" class="lu ko ht ln b fv lv lw l lx ly">// transaction-pool.js<br/>transactionExists(transaction) {</span><span id="33fd" class="lu ko ht ln b fv lz lw l lx ly">let exists = this.transactions.find(t =&gt; t.id === transaction.id);</span><span id="f7d4" class="lu ko ht ln b fv lz lw l lx ly">return exists;</span><span id="c435" class="lu ko ht ln b fv lz lw l lx ly">}</span></pre><p id="07f1" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在将事务添加到我们的池中之后，我们进一步广播它，以便当前节点的所有邻居也接收到该事务。</p><p id="6b61" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">向每个套接字注册这个消息处理程序</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="b4de" class="lu ko ht ln b fv lv lw l lx ly">// p2p-server.js</span><span id="f208" class="lu ko ht ln b fv lz lw l lx ly">connectSocket(socket){<br/>  this.sockets.push(socket);<br/>  console.log("Socket connected");<br/>  this.messageHandler(socket);<br/>  this.sendChain(socket);<br/>}</span></pre><p id="3c9f" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">最后，我们将在API中使用广播事务函数。当我们在API中创建新的事务时，我们将调用<code class="eh lk ll lm ln b">broadcastTransaction </code>函数。</p><pre class="jj jk jl jm fq lq ln lr ls aw lt dt"><span id="d708" class="lu ko ht ln b fv lv lw l lx ly">// index.js</span><span id="7193" class="lu ko ht ln b fv lz lw l lx ly">app.post("/transact", (req, res) =&gt; {<br/>  const { to, amount, type } = req.body;<br/>  const transaction = wallet.createTransaction(<br/>    to,<br/>    amount,<br/>    type,<br/>    blockchain,<br/>    transactionPool<br/>  );<br/>  p2pserver.broadcastTransaction(transaction);<br/>  res.redirect("/transactions");<br/>});</span></pre><p id="2bbd" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在，事务实际上将在网络上广播，我们的消息处理程序将把它们添加到事务池中。</p><p id="f0f2" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们可以通过打开两个终端并运行两个应用程序实例来测试这一点。我们将在其中一个终端中创建一组事务，然后我们将点击另一个应用程序实例的get transactions端点。</p><p id="c1d5" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">你会看到交易实际上正在向网络广播。</p><p id="4f52" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">通过为第二个实例创建事务来测试功能，并使用第一个实例的端点来查看这些事务。</p></div><div class="ab cl mk ml hb mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hm hn ho hp hq"><p id="509d" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><em class="me">感谢您的阅读。</em> <strong class="js hu"> <em class="me">在下一部分中，我们将创建一个账户模型、赌注和验证者列表。</em> </strong> <em class="me">希望你喜欢编码。如果你发现这很有帮助，请鼓掌。</em> </p><p id="4ed5" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">如果你对区块链、以太坊或整个世界有任何疑问，请发表评论。:)</p></div></div>    
</body>
</html>