<html>
<head>
<title>Navigating Ethereum — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">导航以太坊—第三部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/navigating-ethereum-part-3-e057f07d1c66?source=collection_archive---------9-----------------------#2018-07-09">https://medium.com/coinmonks/navigating-ethereum-part-3-e057f07d1c66?source=collection_archive---------9-----------------------#2018-07-09</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="ecc4" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">对松露有反应</h2></div><p id="1d01" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在<a class="ae ke" rel="noopener" href="/@soni.shashikant/navigating-ethereum-part-1-efc23e6e495a">第一部分</a>中设置以太坊和配置一个私有区块链，并在<a class="ae ke" rel="noopener" href="/@soni.shashikant/navigating-ethereum-part-2-b0e00bce0c85">第二部分</a>中学习如何编写一些基本的智能契约之后。现在，我们在区块链上部署之前创建的合同，并构建一个web应用程序来与合同进行交互。app部分需要一些React和JS函数式编程的工作知识。</p><p id="ce8a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">应用程序和合同的完整代码可从github <a class="ae ke" href="https://github.com/shashiks/eth-tutorial" rel="noopener ugc nofollow" target="_blank">这里</a>获得。Truffle框架帮助你以一种优雅的方式管理以太坊智能合约的生命周期。它为你编译、部署和版本管理你的东西。仅使用配置即可轻松部署到不同的网络(生产、测试、私有)。最好的部分是dApp(分布式应用)开发的简易性。当然，如果你知道如何在没有块菌的情况下做事情，这并没有什么坏处，但这是建立dApps最简单快捷的方法。因此，让我们下载一个可重用的React包并开始吧。</p><p id="c539" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">创建一个名为“mydApp”的目录。从目录内部运行以下命令</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="438d" class="ko kp ht kk b fv kq kr l ks kt">&gt; npm install -g truffle</span><span id="4d63" class="ko kp ht kk b fv ku kr l ks kt">&gt; truffle unbox react</span></pre><p id="043a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">它下载了一个“松露盒子”，里面包含了与智能合约交互和启动React应用程序所需的所有样板代码。在松露地点还有许多其他的“盒子”。</p><p id="8f81" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们需要让这个应用程序工作的下一个重要工具是<a class="ae ke" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> MetaMask </a>。继续将插件安装到您的浏览器上。这是一个钱包软件，它为你安全地存储你的帐户。安装完成后，我们只需做一些配置更改，就可以连接到我们的本地区块链，并使用我们之前创建的帐户。点击左上角的“主网络”并选择“自定义RPC”。在文本字段中输入“<a class="ae ke" href="http://localhost:9090" rel="noopener ugc nofollow" target="_blank"> http://localhost:9090 </a>”并保存。现在，在右上角单击并选择“导入帐户”。对于类型选择“JSON文件”,并选择我们在区块链上创建的用户的帐户id文件。该文件应该位于“&lt;chain-data-dir&gt;/keystore”中。您可以导入任意数量的帐户。</p><p id="7efe" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们试着启动应用程序。转到你的松露应用程序的主目录。在文本编辑器<em class="kv">中打开名为<em class="kv"> truffle.js </em>的文件。</em>并修改如下:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="ad07" class="ko kp ht kk b fv kq kr l ks kt">module.exports = {<br/>   networks: {<br/>     development: {<br/>       host: “localhost”, <br/>       port: 9090,<br/>       network_id: “15”, // Match our chain’s network id<br/>       from: ‘&lt;MINER_ACCOUNT_ID&gt;’<br/>     }<br/>   }<br/>};</span></pre><p id="d695" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这个配置告诉Truffle应该在哪个网络上部署智能合约。在'<em class="kv"> networks </em>'下可以有多个部分来表示测试、生产等。将miner地址更新为您的第一个帐户的地址。它可以是您要部署到的链上的任何帐户，但现在我们将使用我们的矿工帐户。使用以下代码编译代码:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="ac8a" class="ko kp ht kk b fv kq kr l ks kt">&gt; truffle compile</span></pre><p id="36e0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">接下来解锁我们在truffle.js中指定的帐户，以部署合同。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="ac6f" class="ko kp ht kk b fv kq kr l ks kt">&gt; personal.unlockAccount(‘&lt;MINER_ACCOUNT_ID&gt;’);</span></pre><p id="1ce6" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">确保您的区块链节点正在运行，同时启动矿工。现在部署来自松露的合同:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="204a" class="ko kp ht kk b fv kq kr l ks kt">&gt; truffle migrate</span></pre><p id="53ba" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们看看我们刚刚做了什么。我们编译了样本合同，它是下载包的一部分。然后解锁帐户，因为我们将在区块链部署合同。代码的部署也是一个交易，它花费汽油/金钱，所以我们需要解锁我们用于部署的帐户。如果一切顺利，几秒钟后你会看到每个合同的一些地址和散列。</p><figure class="kf kg kh ki fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff kw"><img src="../Images/64db72a84a012b6605cf4b577b7e57c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i4ByHaiREv6Jx6qb"/></div></div></figure><p id="81bf" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">接下来，我们启动应用程序。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="4b8a" class="ko kp ht kk b fv kq kr l ks kt">&gt; npm run start</span></pre><p id="a4a5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这将自动在localhost:3000为您打开一个新的浏览器窗口。将会有一个新的弹出窗口等待您批准交易。如下图所示:</p><figure class="kf kg kh ki fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff le"><img src="../Images/f4162d2f027c452e0ad0cc313125cc0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J-DuaURHU-Ojagu0"/></div></div></figure><p id="7000" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这就是我们之前安装的MetaMask的神奇之处。</p><p id="ae50" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">幕后发生的事情是，我们启动的web应用程序已经使用我们导入的帐户连接到我们的区块链。它试图向我们刚刚安装在区块链上的示例合同发送一个事务。如你所知，现在任何交易都要花费汽油/金钱，而你作为钱包的主人需要批准交易。</p><p id="f600" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你需要明白，仅仅是运行这个简单的应用程序就涉及到许多复杂和困难的概念。所以如果你现在觉得很奇怪，没关系。坚持下去，我们将很快部署我们自己的合同，我们早些时候创建的，也许这将清除许多事情。</p><p id="8b17" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一旦你点击MetaMask上的“提交”按钮。页面末尾的值应该更新为‘5’而不是0，如上面的消息所示。最终屏幕应该如下所示:</p><figure class="kf kg kh ki fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff lf"><img src="../Images/9bbce74b59fe73e41599cf2df253933b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AbuVu281Ft_QZ1XI"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">The output from sample code</figcaption></figure><p id="2305" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要开始部署我们的代码，请将我们之前在Remix IDE中编写的合同复制到应用程序的<em class="kv">‘合同</em>’文件夹下，命名为<em class="kv"> BallotData.sol </em>和<em class="kv"> Voting.sol </em>。使用<em class="kv">块菌编译</em>来编译它们。我们要做的下一件事是使用Truffle提供的部署和合同管理特性。转到应用程序根目录下名为'<em class="kv"> migrations </em>'的目录。您将在那里找到2个文件，分别以1_xxx和2_xxx开头。创建一个名为"<em class="kv"> 3_deploy_contract.js" </em>的新文件，并对其进行编辑，使其包含以下内容:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="4b59" class="ko kp ht kk b fv kq kr l ks kt">var Voting = artifacts.require(“./Voting.sol”);<br/>module.exports = function(deployer) {<br/>   deployer.deploy(Voting);<br/>};</span></pre><p id="aee6" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">注意，我们只提到了一个合同<em class="kv">投票</em>。由于这扩展/导入了<em class="kv"> BallotData </em>，我们不需要单独部署它。我们也可以将它们一起写入一个文件。但是将它们分开只是一个好的编码实践——与可靠性无关！好了现在运行“<em class="kv">块菌迁移</em>”。您会注意到它只部署了投票契约，而没有再次重新部署旧的契约。这就是松露合约管理的优势。要查看所有合同部署在何处，您可以使用</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="fe18" class="ko kp ht kk b fv kq kr l ks kt">&gt; truffle networks</span></pre><p id="152b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">或者强制重新部署所有合同</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="07ce" class="ko kp ht kk b fv kq kr l ks kt">&gt; truffle migrate --reset</span></pre><p id="a6a3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">既然我们的投票契约已经部署好了，我们就可以开始编写与之交互的代码了。将'<em class="kv"> src' </em>文件夹下的现有App.js重命名为其他名称，并创建一个新的App.js文件。从下面的代码框架开始编辑它</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="c68e" class="ko kp ht kk b fv kq kr l ks kt">import React, { Component } from ‘react’;<br/>import contract from ‘truffle-contract’;<br/>import votingContract from ‘../build/contracts/Voting.json’;<br/>import VoteOption from ‘./VoteOption.js’;<br/>import Web3 from ‘web3’;<br/>import ‘./css/pure-min.css’<br/>import ‘./App.css’</span><span id="d811" class="ko kp ht kk b fv ku kr l ks kt">var voting = contract(votingContract);<br/>var me = null;</span><span id="ece9" class="ko kp ht kk b fv ku kr l ks kt">var web3 = window.web3;</span><span id="a522" class="ko kp ht kk b fv ku kr l ks kt">class App extends Component {</span><span id="6908" class="ko kp ht kk b fv ku kr l ks kt">}</span><span id="06a6" class="ko kp ht kk b fv ku kr l ks kt">export default App;</span></pre><p id="9ec4" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Web3是以太坊提供的客户端JS库，用于与部署的智能合约进行交互。我们将json格式的已编译合同(实际上是一个ABI-应用程序二进制接口)作为'<em class="kv"> votingContract' </em>导入，并使用“truffle-contract”库对其进行初始化。从这里开始事情变得棘手，因为您将在这个组件的最终版本中看到许多React代码。因此，为了简单起见，我将描述与区块链交互相关的部分，并将React代码的其余部分留给您来解决:)开始吧:</p><p id="482c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">正如我提到的，web3库帮助我们连接到我们的区块链。但仅此而已(至少在本教程的范围内)。为了调用契约方法，我们将使用刚刚创建的契约二进制文件的实例。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="50b3" class="ko kp ht kk b fv kq kr l ks kt">....<br/>class App extends Component {<br/>   componentDidMount() {<br/>     web3 = new Web3(web3.currentProvider)<br/>     voting.setProvider(web3.currentProvider);<br/>   }<br/>}<br/>...</span></pre><p id="42dc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这是一个标准的React方法，在这里我们初始化我们的对象。我们使用当前的web3提供者来完成这项工作——或者简单地说，使用由MetaMask作为全局变量提供的web3实例连接到我们的区块链。还记得我们已经配置了元掩码来指向我们的节点。是的小菜一碟！！！</p><p id="d34d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们编写了一个方法来从我们的契约中获取选项列表。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="275d" class="ko kp ht kk b fv kq kr l ks kt">initOptionList = () =&gt; {<br/>   var tmpNames = [];<br/>   voting.deployed().then(function(instance) {<br/>     <br/>   });<br/>}</span></pre><p id="1c1d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">该方法查找该协定的已部署实例。记住这些是truffle contract为我们提供的默认方法和API。接下来，我们使用'<em class="kv"> optionsCount </em>'从我们的契约中获得可供投票的选项数量，这是为我们的变量自动生成的方法，因为它是公共的。因为契约中的方法是“read”并且不修改状态，所以我们将使用“<em class="kv"> call() </em>”来调用它。让我们更新上面的代码</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="580d" class="ko kp ht kk b fv kq kr l ks kt">...<br/>  voting.deployed().then(function(instance) {<br/>   instance.optionsCount.call().then( function(optCount) {<br/>  });<br/>});<br/>...</span></pre><p id="2931" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">返回值是一个"<em class="kv"> uintXX </em>"返回一个JS中的BigDecimal对象，该对象有多个属性。我们可以使用“<em class="kv">toString”</em>来获得字符串形式的实际值。当我们查找每个选项并将其存储在本地数组中时，事情变得有趣了:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="4e3a" class="ko kp ht kk b fv kq kr l ks kt">...</span><span id="a004" class="ko kp ht kk b fv ku kr l ks kt">instance.optionsCount.call().then( function(optCount) {<br/>  for(let i = 0 ; i &lt; optCount; i++) {    <br/>     <strong class="kk hu">instance.getOptionAt.call(i).then(function(optInfo) { <br/>        </strong>tmpNames.push( i+ “,” + optInfo);<br/>        if(i == (optCount-1)){<br/>           me.setState({isOptData: true});<br/>           me.setState({optNames: tmpNames});<br/>        }<br/>     });<br/>   }<br/>});</span><span id="0e79" class="ko kp ht kk b fv ku kr l ks kt">...</span></pre><p id="4fe8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">方法"<em class="kv"> getOptionAt" </em>返回两个值，选项的名称和分数。所以返回值是一个数组，我们将它存储为字符串，以便以后显示。</p><p id="26cc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在任何其他语言中，这都是一种糟糕的方法。为数组中的每一项调用服务器。Well Solidity不返回字符串数组，因为字符串也是一个字节数组。尽管如此，还是有解决办法的。你可以用不同的方法来优化它，但是现在我们将使用这个简单的方法。值得庆幸的是，因为这是一个读取交易，所以你不需要用汽油来支付。</p><p id="e2be" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="kv">注意:</em>在生产中使用这种方法不是一个好主意</p><p id="d9c9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们现在将创建另一个方法来添加一个新的选项到列表中。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="b26f" class="ko kp ht kk b fv kq kr l ks kt">addOption = () =&gt; {<br/>    <strong class="kk hu">let currUser = window.web3.eth.defaultAccount;</strong><br/>    let option = this.refs.optName.value;<br/>      try {<br/>        voting.deployed().then(function(instance) {<br/>          <strong class="kk hu">instance.addOption.sendTransaction(option, {gas:3000000,from: currUser})</strong>.<strong class="kk hu">then(function(txnHash)</strong> {<br/>           me.setState({txnId : “Transaction Id : “ + txnHash});<br/>         });<br/>        });<br/>      } catch (err) {<br/>        console.error(“Err loading options count “+ err);<br/>        //indicate this to user too<br/>         return;<br/>      }<br/>}</span></pre><p id="a03a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这类似于另一种禁止高亮显示行的方法。为了从元掩码中获取当前选择的帐户id，我们使用'<em class="kv"> web.eth.defaultAccount </em>'。添加一个新选项会导致新数据被存储在区块链上，因此是一个被挖掘的交易，并且对发送者来说是要花钱的。因此，我们需要使用'<em class="kv">send transaction</em>，而不是'<em class="kv">call()</em>，来表示我们准备在存储的数据上花费的气体量。返回值是一个事务散列，我们可以从我们的块浏览器中查找。散列并不表示交易被接受或被挖掘。这只是一个身份证。<br/> <em class="kv">注意:</em>在提交事务之前，记得从控制台启动miner。<br/>送气太少会导致交易永远不被开采。但是，如果您通过超过所需的气体，未使用的气体余额将被退还。理解天然气及其对交易的影响非常重要。这里给出了很好的解释<a class="ae ke" href="https://ethereum.stackexchange.com/questions/3/what-is-meant-by-the-term-gas" rel="noopener ugc nofollow" target="_blank"/></p><p id="2f80" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">另一种方法是让用户为其中一个选项投票。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="7865" class="ko kp ht kk b fv kq kr l ks kt">vote = () =&gt; {<br/>    let optId = this.state.selectedOpt;<br/>    let currUser = window.web3.eth.defaultAccount;<br/>    voting.deployed().then(function(instance) {<br/>      try {<br/>        instance.vote.sendTransaction(optId, {gas:3000000, from: <br/>        currUser}).then( function(txnHash) {<br/>          me.setState({txnId : “Transaction Id : “ + txnHash});<br/>        });<br/>      } catch (err) {<br/>        console.error(“Err voting “+ err);<br/>        return;<br/>      }<br/>     });<br/>}</span></pre><p id="eb45" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们做的最后一个实现是让dApp对用户更加友好。你不能期望一个终端用户运行一个块浏览器，并使用我们抛出的事务散列来检查她的事务状态。😊所以让我们解决这个问题。</p><p id="f2d5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为此，我们创建了一个实用方法，该方法根据事务的散列id查找事务的状态。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="7540" class="ko kp ht kk b fv kq kr l ks kt">getReceipt = () =&gt; {</span><span id="2a42" class="ko kp ht kk b fv ku kr l ks kt">   var v = this.refs.txnRefId.value;<br/>   <strong class="kk hu">web3.eth.getTransactionReceipt(v, function(err, receipt){<br/>   </strong>var txnMsg = "Status : ";<br/>   if(receipt.status === "0x1") { //success<br/>     txnMsg = "Sucess &lt;/br&gt;";<br/>   }</span><span id="c644" class="ko kp ht kk b fv ku kr l ks kt">   if(receipt.status === "0x0") { //failure<br/>     txnMsg = "Failure &lt;/br&gt;";<br/>   }<br/>   if(!receipt.status) { //unknown<br/>      txnMsg = "Unknown Failure &lt;/br&gt;";<br/>   }<br/>   <br/>   txnMsg += "Block Id : " + receipt.blockHash + "&lt;/br&gt;";<br/>   txnMsg += "Total gas used : " + receipt.cumulativeGasUsed;</span><span id="0790" class="ko kp ht kk b fv ku kr l ks kt">   me.setState({resultMsg: txnMsg});<br/>   <br/>  });</span><span id="9b85" class="ko kp ht kk b fv ku kr l ks kt">}</span></pre><p id="5253" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">eth提供的方法<em class="kv"> getTransactionReceipt </em>返回一个名为“<em class="kv"> receipt </em>的对象，该对象包含交易被挖掘时的所有信息。收据包含许多字段，但“状态”是最重要的，它指示交易是否成功。其中1 =成功，0 =失败。即使交易在契约层失败，它也将被挖掘。</p><p id="2e44" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果在调用该方法时没有挖掘出交易，收据将为空。</p><p id="855e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">任何区块链交易都需要时间来挖掘(从几分钟到几小时甚至更长)。因此，用户需要在一段时间后检查自己的交易状态。一旦生产dApp能够检索收据或任何对最终用户来说更简单的替代方法，它就可以通过应用程序的推送消息来实现这一点。</p><p id="9dea" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">该应用和合同的完整代码可从github <a class="ae ke" href="https://github.com/shashiks/eth-tutorial" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><blockquote class="lk"><p id="92a3" class="ll lm ht bd ln lo lp lq lr ls lt kd ek translated">那都是乡亲们！！！</p></blockquote><p id="8520" class="pw-post-body-paragraph ji jj ht jk b jl lu iu jn jo lv ix jq jr lw jt ju jv lx jx jy jz ly kb kc kd hm dt translated">希望你对所有的部分都很感兴趣。一定要让我知道你的观点！</p><p id="5155" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><a class="ae ke" rel="noopener" href="/@soni.shashikant/navigating-ethereum-part-1-efc23e6e495a">第一部</a>和<a class="ae ke" rel="noopener" href="/@soni.shashikant/navigating-ethereum-part-2-b0e00bce0c85">第二部</a></p></div></div>    
</body>
</html>