<html>
<head>
<title>Revealing The All Mysterious zk-STARKs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭示所有神秘的ZK-stark</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/reveal-mysterious-zk-starks-42d00679c05b?source=collection_archive---------1-----------------------#2019-12-23">https://medium.com/coinmonks/reveal-mysterious-zk-starks-42d00679c05b?source=collection_archive---------1-----------------------#2019-12-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="8e7f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这篇文章中，我会尽量减少数学公式，让它尽可能容易理解</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/e3b4dc3ce32b93a917817c607d012b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ou--z4VHV-y-OL5iWx-iyg.jpeg"/></div></div></figure><p id="6680" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">人们说S <strong class="is hu"> T </strong> ARKs是新一代S <strong class="is hu"> N </strong> ARKs。不仅仅是因为它更快，最重要的是因为这两个品质。STARKs和<br/> 2不需要可信设置。它们是量子抗性的</p><p id="06ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，斯塔克斯并不完美，这是有代价的:证据的大小。STARK的验证大小约为40-50KB，而SNARKs的大小仅为288字节。此外，STARKs相对较新——从最初的概念发表到现在才两年左右。我们可能还需要一些时间来验证他们的贪婪。</p><p id="6f78" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在STARKs中，S代表“可伸缩”。T代表透明性，STARKs解决了S <strong class="is hu"> N </strong> ARKs的主要弱点之一，“可信设置”。</p><p id="e6ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ARKs不依赖于椭圆曲线加密和配对，它们使用更简单的加密假设，比如散列。这意味着STARKs不需要一个可信的设置，可以抵抗量子计算机的攻击者。</p><p id="fc22" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">SNARKs和STARKs都基于多项式验证。区别在于如何<em class="jo">隐藏秘密</em>，如何<em class="jo">简洁验证</em>，如何<em class="jo">实现不交互</em>。</p><p id="e7fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们快速回顾一下SNARKs是如何工作的。</p><p id="2207" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">爱丽丝有一个多项式P(x)，鲍勃有秘密s。目标是，<br/>爱丽丝不知道s，鲍勃不知道P(x)，但是鲍勃可以验证P(s)。通过‘同态Hindins’隐藏秘密s，s → H(s)，QAP/匹诺曹简洁验证，将H(s)放入CRS(公共引用串)实现不交互。更多详情看<a class="ae kb" rel="noopener" href="/taipei-ethereum-meetup/深入瞭解-zk-snarks-7a0187f399f1">我之前的帖子</a>(抱歉…是中文)。</p><h1 id="9490" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">转换</h1><p id="9bea" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">零知识证明的第一步是将假设的“问题”转化为多项式。本节只讲解如何将问题转化为多项式。至于如何转换的细节，这里就不做过多解释了。</p><h2 id="8e9e" class="lf kd ht bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls dt translated">问题→约束→多项式</h2><p id="6f53" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">SNRAK和STARK都是基于高维多项式的。如果多项式为:x + 3x + 3 = 0，那么多项式的解就很容易猜到。如果多项式是x ^ 2000000 + x ^ 1999999 +…，难度会高很多。</p><p id="f8a2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">第一步是将问题转化为多项式。在这里，我将使用一个Collatz猜想作为例子。什么是柯拉兹猜想？<br/> 1。如果数字是偶数，除以2 <br/> 2。如果数字是奇数，乘以3再加1。(3n+1)</p><p id="f8e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">任何正整数，遵循上面两条规则，最后都是1。以52为例，<br/>52-&gt;26-&gt;13-&gt;40-&gt;20-&gt;10-&gt;5-&gt;16-&gt;8-&gt;4-&gt;2-&gt;1。</p><p id="bc23" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">记录每个操作的结果。这称为执行跟踪，如上面的52-&gt; 26-&gt; 1。然后我们把执行轨迹转换成多项式如下(执行轨迹到多项式的转换不是这里的重点。详情请参考StarkWare 的<a class="ae kb" rel="noopener" href="/starkware/arithmetization-i-15c046390862">这篇文章</a></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/cd9778bf30de21253bac3e986ccf565c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*INAMBYQQi_IFCkBY"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek"><a class="ae kb" rel="noopener" href="/starkware/arithmetization-i-15c046390862">https://medium.com/starkware/arithmetization-i-15c046390862</a></figcaption></figure><h2 id="7447" class="lf kd ht bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls dt translated">合成多项式</h2><p id="9600" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">然后把上面四个带极限条件的多项式合二为一，最后一个叫做“合成多项式”，这个多项式就是后面要验证的多项式。</p><p id="28c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如开头所述，SNARKs和STARKs都使用高维多项式。然后，我们将介绍STARK实现零知识信息交换、透明性和可伸缩性的方法。</p><h2 id="3f81" class="lf kd ht bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls dt translated">度数调整</h2><p id="078a" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">这一步是为以后的验证准备的。如果最高次数不是2的幂，我们将最高次数的约束多项式调整到2^n.，直到比最高次数大的最接近的2的幂。</p><p id="6240" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">假设每个约束多项式(不是合成多项式)为Cj (x)，次数为Dj，D &gt;= Dj且d等于2 ^ n .为了达到d次，将这些多项式乘以次数(D-Dj)</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/7c0db763b6aa8116d5b32c457861d7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/0*1OEfW98U5as1jjYO"/></div></figure><p id="e2b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">合成多项式的结果将是</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/ba83c26ca6ece05797e6a1200f79dae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/0*pZU9Uo-Mu0pIP_Yc"/></div></figure><p id="f700" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">aj、βj由验证者提供。因此，合成多项式是由证明者和验证者共同完成的。</p><p id="a07d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"><em class="jo">*本节的要点是将多项式调整到D(2的幂)次。不懂可以跳过流程……</em>T5】</strong></p><h1 id="532b" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">星期五</h1><p id="ebbb" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">FRI是“快速RS IOPP”(RS = " Reed-Solomon "，IOPP = "交互式Oracle Proofs of Proximity ")的简称。FRI使验证变得简洁。在介绍FRI之前，我们先讨论一下如何证明自己知道多项式f(x)？</p><h2 id="4042" class="lf kd ht bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls dt translated">RS擦除代码:</h2><p id="b7f3" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">擦除编码是对原始数据的扩展，使数据具有容错性。实现这一点的方法是将所有数据编码为一个多项式，并验证该多项式。例如，如果你有两个点，你可以做一条线，然后在这条线上挑出3个点。这三个点中的任何两个都可以重建原始点。假设有d个点我们可以构造一个d-1次多项式y = f (x)。通过验证f (z1)来验证z1是正确的数据？= Y。</p><p id="8b70" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">回到上面的问题，如何证明自己知道多项式？最直接的方法是计算所有的根。通过擦除编码，假设d + 1个点，根据拉格朗日插值，可以构造一个d次多项式h (x)。如果两个多项式在任一点d(在一个区间内)相同(f (z) = h (z)，z = z1，z2 … zd)，那么意味着我知道f (x)。但是我们面对的是一个高维多项式，d是1-2百万，这样的测试效率低下，不可行。FRI解决了这个问题，将验证的次数从几百万到几十次。</p><h2 id="f907" class="lf kd ht bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls dt translated">降低复杂性</h2><p id="3fa5" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">假设合成多项式为f (x)，通过找一个二元多项式来表示原多项式，降低多项式的次数。假设f (x) = 1744 * x ^ {185423}，我们求出y，这样y = x ^ {1000}。多项式可以改写为g (x，y) = 1744 * x ^ {423} * y ^ {185}。这样，从10万次降到了1000次，多项式的次数也通过这种方式大大降低了。StarkWare目前的实现是2的幂，所以y = x (f (x) = g (x，x))。</p><p id="76fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们在这里使用的另一个策略是将一个多项式分成两个较小次数的多项式。我们分成多项式的奇数和偶数系数，</p><blockquote class="ma"><p id="f22c" class="mb mc ht bd md me mf mg mh mi mj jn ek translated">f(x)= g(x ) + xh(x)</p></blockquote><p id="9b65" class="pw-post-body-paragraph iq ir ht is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm jn hm dt translated">举个例子，</p><blockquote class="ma"><p id="591c" class="mb mc ht bd md me mf mg mh mi mj jn ek translated">f(x)= A0+a1x+a2x+a3x+a4x⁴+a5x⁵<br/>g(x)= A0+a2x+a4x⁴，(g(x)= A0+a2x+a4x)<br/>h(x)= a1x+a3x+a5x⁴，(h(x) = a1 + a3x + a5x)</p></blockquote><p id="c35a" class="pw-post-body-paragraph iq ir ht is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm jn hm dt translated">有了这两个技能，复杂度每次降低2倍。FRI协议由两个阶段组成，提交阶段和查询阶段。</p><p id="5a95" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">提交阶段:<br/> </strong>提交阶段与前面的描述相同。每次分解多项式时，验证者提供一个随机数，然后形成新的多项式。一遍又一遍地重复这个过程。</p><p id="4f97" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">f(x)= F0(x)= G0(x)+x * h0(x)<br/>= =&gt;f1(x)= G0(x)+α0 * h0(x)，← α0(验证者提供)<br/> == &gt; f2(x) = g1(x) + α1*h1(x)，← α1(验证者提供)<br/>=&gt;。。。</p><p id="37e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">查询阶段:<br/> </strong>该阶段是对证明者提供的多项式f0(x)，f1(x)，f2(x)，…，进行验证。验证者采样z并查询f(z)和f(-z)(该域需要满足L = {x :x ∊ L}。这里不解释了。).所以，我们可以，</p><blockquote class="ma"><p id="12ad" class="mb mc ht bd md me mf mg mh mi mj jn ek translated">F0(z)= G0(z)+z * h0(z)<br/>F0(-z)= G0(z)-z * h0(z)</p></blockquote><p id="f2e0" class="pw-post-body-paragraph iq ir ht is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm jn hm dt translated">验证者可以通过解方程知道g0(z)、h0(z)，并计算f1(z)，然后f1(x)等等。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/621a8483d60d90d750c29a93a96fabb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*mbO76OzcqOEI62Ln"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Interactive Oracle Proofs (IOPs)</figcaption></figure><p id="7843" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">借助FRI (RS擦除代码，IOPs)，验证次数从数百万次减少到20–30次(log2 (d))，从而使验证更加简洁。我们解决了复杂性问题，但是我们仍然有交互问题！</p><p id="0f1f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="jo"> *相对于SNARKs:SNARKs中QAP和匹诺曹用于验证。</em>T15】</strong></p><h1 id="a624" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">非相互作用</h1><p id="4640" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">我们使用Micali构造来说明如何实现非交互式验证。Micali构造由两部分组成，PCPs(概率可检验证明)和hash函数。PCPs是一种带有随机本地检查的证明系统。换句话说，证明者产生一个长证明(这是大量的数据)，验证者通过随机抽样进行检查。过程是这样的:证明者产生证明𝚿，验证者随机检查n个点。</p><p id="22c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们在这里的目标是拥有:<br/> 1。一个小小的证明，<br/> 2。不互动。</p><p id="2dc7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">随机抽样有助于实现一个小的证明，但是交互作用呢？思路很简单，就是预采样。我们从𝚿预抽样一个短证明，这个短证明代表原始证明，𝚿，发送给验证者。显然，校准者不是预采样的候选人。为了解决这个问题，我们使用<a class="ae kb" href="https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic" rel="noopener ugc nofollow" target="_blank"> Fiat-Shamir启发式</a>进行预采样。</p><p id="ee23" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先用证明𝚿构造一棵merkle树，然后散列merkle根得到一个随机数𝛒，其中𝛒是预采样的索引。把𝛒选择的小块和大块的merkle路径和merkle根放在一起，我们称这个组合为𝛑，这是一个明显的证明。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/624c9329cb00f8bdfbfe374c6a50bab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*s3v1bH7UYWWzsYGl"/></div></figure><p id="0c7f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">到目前为止，只有哈希算法(一种加密轻量级算法)被使用。hash函数的选取是这个证明系统唯一的全局参数(每个人都需要知道)，不像SNARK有KCA使用的(α，β，𝛾)等全局秘密参数，使用HH(同态隐藏)隐藏这些秘密，然后生成CRS。因为这个证明系统是基于公共散列函数的，所以它不需要预先生成的秘密。因此，STARK可以实现透明性，并且不需要可信的设置。</p><p id="8174" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后用PCPs和Fiat-Shamir启发式代替FRI的交互部分(验证者提供的值α)。我们可以实现无互动。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/9c803250c2837a459db68f8b998bf8bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*zaeqZKkFJsEkldiY"/></div></figure><p id="d348" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"><em class="jo">*与SNARKs相比:SANRK的非交互是将全局参数放入CRS。因为CRS中的值是公开的，所以HH需要隐藏秘密。</em> </strong></p><h1 id="d3e7" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">MIMC</h1><p id="e6cc" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">无论是SNRAKs还是STARKs，都需要将多项式转换为算术电路。因此，电路的复杂性至关重要，它与证据生成和验证的时间有关。STARKs采用MiMC作为哈希函数，电路复杂度较低。这就是它的工作原理，</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/ae1a275002c72695110e52b6df450149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*kz8ibvyNQZJ57chT"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek"><a class="ae kb" href="https://vitalik.ca/general/2018/07/21/starks_part_3.html" rel="noopener ugc nofollow" target="_blank">https://vitalik.ca/general/2018/07/21/starks_part_3.html</a></figcaption></figure><p id="20f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">MiMC有一些非常有用的特性:难以计算、易于验证、计算不可并行化。这些实现了VDFs(可验证延迟功能)的主要目标。这是Vitalik提出的一个<a class="ae kb" href="https://ethresear.ch/t/hash-based-vdfs-mimc-and-starks/2337" rel="noopener ugc nofollow" target="_blank">建议</a>使用MiMC作为VDF候选。</p><h2 id="c75a" class="lf kd ht bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls dt translated"><strong class="ak">最终想法:</strong></h2><p id="e8a4" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hm dt translated">向后计算MiMC电路比向前计算要多花100倍的时间。</p><p id="e81b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从上面的解释，我们可以理解为什么STARK不需要可信设置，但是为什么它是抗量子的？在SNARK中使用HH来隐藏秘密，HH依赖于椭圆曲线，但是椭圆曲线并不具有抗量子性(这意味着私钥可以从公钥中导出)。</p><p id="0935" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">stark在他们的整个过程中只使用哈希函数，目前没有有效的算法来破解哈希函数——因此，stark被理解为可以抵抗量子攻击。</p><p id="df5d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">欢迎任何需要纠正的反馈或错误。</p></div><div class="ab cl mp mq hb mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hm hn ho hp hq"><p id="219c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">参考资料:<br/></strong><a class="ae kb" rel="noopener" href="/starkware/starkdex-deep-dive-the-stark-core-engine-497942d0f0ab">STARK Deep Dive:STARK Core Engine<strong class="is hu"><br/></strong></a><strong class="is hu">STARK ware的系列:<br/></strong>-<a class="ae kb" rel="noopener" href="/starkware/stark-math-the-journey-begins-51bd2b063c71">STARK Math:The Journey Begins<br/></a>-<a class="ae kb" rel="noopener" href="/starkware/arithmetization-i-15c046390862">算术化I </a> <br/> - <a class="ae kb" rel="noopener" href="/starkware/arithmetization-ii-403c3b3f4355">算术化II<br/>-</a><a class="ae kb" rel="noopener" href="/starkware/low-degree-testing-f7614f5172db">低度测试<br/> </a> - <a class="ae kb" rel="noopener" href="/starkware/a-framework-for-efficient-starks-19608ba06fbe">一个高效STARKs的框架 第二部分:谢天谢地今天是周五<br/> </a> - <a class="ae kb" href="https://vitalik.ca/general/2018/07/21/starks_part_3.html" rel="noopener ugc nofollow" target="_blank">斯塔克斯，第三部分:进入杂草中<br/></a><a class="ae kb" rel="noopener" href="/coinmonks/zk-starks-create-verifiable-trust-even-against-quantum-computers-dd9c6a2bb13d">ZK-斯塔克斯——创建可验证的信任，甚至对抗量子计算机<br/></a><a class="ae kb" href="https://ethereum.stackexchange.com/questions/59145/zk-snarks-vs-zk-starks-vs-bulletproofs-updated" rel="noopener ugc nofollow" target="_blank">https://ether eum . stack exchange . com/questions/59145/ZK-snarks-vs-ZK-STARKs-vs-bullet proofs-updated</a></p><blockquote class="ma"><p id="9c68" class="mb mc ht bd md me mf mg mh mi mj jn ek translated">加入Coinmonks <a class="ae kb" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae kb" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="9922" class="kc kd ht bd ke kf kg kh ki kj kk kl km kn mw kp kq kr mx kt ku kv my kx ky kz dt translated">另外，阅读</h1><ul class=""><li id="a2b8" class="mz na ht is b it la ix lb jb nb jf nc jj nd jn ne nf ng nh dt translated"><a class="ae kb" href="https://coincodecap.com/bookmap-review-2021-best-trading-software" rel="noopener ugc nofollow" target="_blank"> Bookmap评论</a> | <a class="ae kb" href="https://coincodecap.com/crypto-exchange-usa" rel="noopener ugc nofollow" target="_blank">美国5大最佳加密交易所</a></li><li id="83d5" class="mz na ht is b it ni ix nj jb nk jf nl jj nm jn ne nf ng nh dt translated">最佳加密<a class="ae kb" rel="noopener" href="/coinmonks/hardware-wallets-dfa1211730c6">硬件钱包</a> | <a class="ae kb" rel="noopener" href="/coinmonks/bitbns-review-38256a07e161"> Bitbns评论</a></li><li id="36d0" class="mz na ht is b it ni ix nj jb nk jf nl jj nm jn ne nf ng nh dt translated"><a class="ae kb" href="https://coincodecap.com/crypto-exchange-in-singapore" rel="noopener ugc nofollow" target="_blank">新加坡十大最佳密码交易所</a> | <a class="ae kb" href="https://coincodecap.com/buy-axs-token" rel="noopener ugc nofollow" target="_blank">收购AXS </a></li><li id="8978" class="mz na ht is b it ni ix nj jb nk jf nl jj nm jn ne nf ng nh dt translated"><a class="ae kb" href="https://coincodecap.com/red-dog-casino-review" rel="noopener ugc nofollow" target="_blank">红狗赌场评论</a> | <a class="ae kb" href="https://coincodecap.com/swyftx-review" rel="noopener ugc nofollow" target="_blank"> Swyftx评论</a> | <a class="ae kb" href="https://coincodecap.com/coingate-review" rel="noopener ugc nofollow" target="_blank"> CoinGate评论</a></li><li id="be09" class="mz na ht is b it ni ix nj jb nk jf nl jj nm jn ne nf ng nh dt translated"><a class="ae kb" href="https://coincodecap.com/best-crypto-to-invest-in-india-in-2021" rel="noopener ugc nofollow" target="_blank">投资印度的最佳加密软件</a>|<a class="ae kb" href="https://coincodecap.com/wazirx-p2p" rel="noopener ugc nofollow" target="_blank">WazirX P2P</a>|<a class="ae kb" href="https://coincodecap.com/hi-dollar-review" rel="noopener ugc nofollow" target="_blank">Hi Dollar Review</a></li><li id="b697" class="mz na ht is b it ni ix nj jb nk jf nl jj nm jn ne nf ng nh dt translated"><a class="ae kb" href="https://coincodecap.com/5-best-crypto-trading-bots-in-canada" rel="noopener ugc nofollow" target="_blank">加拿大最好的加密交易机器人</a> | <a class="ae kb" href="https://coincodecap.com/kucoin-review" rel="noopener ugc nofollow" target="_blank">库币评论</a></li></ul></div></div>    
</body>
</html>