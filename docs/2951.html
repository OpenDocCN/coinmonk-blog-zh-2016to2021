<html>
<head>
<title>Blockchain And JavaScript: How To Offer Your Smart Contracts As A Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">区块链和JavaScript:如何提供智能合约服务</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/blockchain-and-javascript-how-to-offer-your-smart-contracts-as-a-service-dee7a84290f8?source=collection_archive---------2-----------------------#2020-04-26">https://medium.com/coinmonks/blockchain-and-javascript-how-to-offer-your-smart-contracts-as-a-service-dee7a84290f8?source=collection_archive---------2-----------------------#2020-04-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="c656" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最近，我开始和一个大型的前端和后端开发团队一起工作。这个项目很简单，我开发的唯一一个智能合同需要几个小时就可以使用。但是我不得不面对一个严峻的挑战，因为我团队中的大多数人对区块链一无所知。让情况变得更复杂的是，由于项目的预期用户不熟悉区块链，因此要求永远不要使用元掩码或任何钱包。为了解决这个问题，我们的团队创建了一个javascript <strong class="is hu">类</strong>来与部署在我们的私有网络上的任何智能合同进行交互，作为<a class="ae jo" href="https://blog.coincodecap.com/what-is-blockchain-a-simple-guide-for-dummies/" rel="noopener ugc nofollow" target="_blank">区块链服务</a>。</p><h1 id="059b" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">到底什么是区块链服务类</h1><p id="36dc" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">作为一个没有区块链背景的开发人员，更简单的解决方案是创建一个与区块链交互的类。服务类将由前端和后端开发人员使用。每个开发人员可以根据自己的需要以不同的方式使用这个类。这个类会是这样的</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="fe ff ks"><img src="../Images/3c23cec338623cc1b18342187bae55de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGXD0FnqU65-G1n2Yi9hjQ.png"/></div></div></figure><p id="686c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于本文，我尽可能灵活地创建了这个类。区块链服务类对于后端来说很简单，但是对于前端来说，有点难。让我们从简单的开始。</p><h2 id="e0f3" class="le jq ht bd jr lf lg lh jv li lj lk jz jb ll lm kd jf ln lo kh jj lp lq kl lr dt translated">对于后端开发人员</h2><p id="0af6" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">大多数后端开发人员将只在两个方面需要区块链类首先从区块链读取数据并将其解析到前端，或者最重要的是进行管理任务，如添加地址或授予权限。</p><p id="4e08" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">例如，我们可能需要作为智能合约的所有者提交交易，给予许可或将资产发送到某些地址。只有管理员可以做到这一点。</p><h2 id="0ae6" class="le jq ht bd jr lf lg lh jv li lj lk jz jb ll lm kd jf ln lo kh jj lp lq kl lr dt translated">对于前端开发人员</h2><p id="2f88" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">最重要的任务是初始化用户帐户。请记住，作为区块链开发者，你需要让用户自己进行交易。但是如果你不使用钱包，你怎么能做到呢？为此，我们需要初始化一个用户类。有时我们需要他私钥来提交交易或检查权限。其他用户只需要读取一些数据公共数据，所以在这种情况下我们不需要他们的私钥。我们确信在任何情况下<strong class="is hu">用户必须为自己保留地址</strong>并且不要发送给我们的服务。</p><p id="052a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们该怎么做呢？</p><h1 id="e0fc" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">让我们开始编码吧</h1><p id="ed7d" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">最重要的一步是找到一种不使用元掩码来签署交易的方法，然后我们需要找到一种为用户生成私钥并保证私钥安全的方法。最后一步是为前端开发人员提供一种灵活的方式来管理用户帐户或只提交交易。我们走吧。</p><h2 id="e340" class="le jq ht bd jr lf lg lh jv li lj lk jz jb ll lm kd jf ln lo kh jj lp lq kl lr dt translated">meta mask/wallet替代品</h2><p id="d1dc" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">我发现最好的选择是使用钱包提供商。我们用来迁移松露契约的同一个npm包模块。</p><pre class="kt ku kv kw fq ls lt lu lv aw lw dt"><span id="cc46" class="le jq ht lt b fv lx ly l lz ma">npm install @truffle/hdwallet-provider</span></pre><p id="d58f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它是如何工作的？我们将只需要私钥来签署交易，然后我们将使用<code class="eh mb mc md lt b">path</code>和<code class="eh mb mc md lt b">fs</code> npm包来加载合同的构建文件(合同工具)，如下所示:</p><pre class="kt ku kv kw fq ls lt lu lv aw lw dt"><span id="6e46" class="le jq ht lt b fv lx ly l lz ma">const contract = require('<a class="ae jo" href="http://twitter.com/truffle/contract" rel="noopener ugc nofollow" target="_blank">@truffle/contract</a>');<br/>const WalletProvider = require('<a class="ae jo" href="http://twitter.com/truffle/hdwallet-provider" rel="noopener ugc nofollow" target="_blank">@truffle/hdwallet-provider</a>');<br/>// assume for now you already have the contract artificaits <br/>const contractArtificaits;<br/>const contract = contract(contractArtificaits);<br/>const instance = await this.contract.deployed(); <br/>// instance could be used to interact with the smart contract</span></pre><p id="3cb2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要使用<code class="eh mb mc md lt b">const instance</code>,你需要写类似这样的东西</p><pre class="kt ku kv kw fq ls lt lu lv aw lw dt"><span id="91a5" class="le jq ht lt b fv lx ly l lz ma">await this.instance[&lt;the method name&gt;](&lt;method argument&gt;,{from:&lt;your account public address&gt;});<br/>/* 'from' keyword may not be useful to read data from blockchain. Unless you try to read from function that use modifier*/</span></pre><p id="3464" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们准备创建我们的类并与我们的契约交互。在开始创建我们的类之前，我们必须添加一些npm模块。我们将需要<code class="eh mb mc md lt b">path</code> &amp; <code class="eh mb mc md lt b">fs</code>来加载契约的构建文件，并需要<code class="eh mb mc md lt b">web3</code> &amp; <code class="eh mb mc md lt b">hdWalletProvider</code>来与solidity契约交互，我们将在后面详细讨论。最后<code class="eh mb mc md lt b">crypto-js</code>加密私钥。我们将在文章的最后谈到这一点。</p><pre class="kt ku kv kw fq ls lt lu lv aw lw dt"><span id="ce88" class="le jq ht lt b fv lx ly l lz ma">'use strict';<br/>const contract = require('<a class="ae jo" href="http://twitter.com/truffle/contract" rel="noopener ugc nofollow" target="_blank">@truffle/contract</a>');<br/>const WalletProvider = require('<a class="ae jo" href="http://twitter.com/truffle/hdwallet-provider" rel="noopener ugc nofollow" target="_blank">@truffle/hdwallet-provider</a>');<br/>const CryptoJS = require("crypto-js");<br/>const path= require('path');<br/>const fs = require('fs');<br/>const Web3 = require('web3');<br/>const web3 = new Web3(new Web3.providers.HttpProvider('<a class="ae jo" href="http://127.0.0.1:8545/'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8545/'</a>)); <br/>const web3Provider = new Web3.providers.HttpProvider('<a class="ae jo" href="http://127.0.0.1:8545/'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8545/'</a>);</span></pre><h2 id="d9ca" class="le jq ht bd jr lf lg lh jv li lj lk jz jb ll lm kd jf ln lo kh jj lp lq kl lr dt translated">创建一个类</h2><p id="fd92" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">我们将这个类命名为<code class="eh mb mc md lt b">Contract</code>，然后创建一个带有可选私钥作为参数的构造函数。</p><pre class="kt ku kv kw fq ls lt lu lv aw lw dt"><span id="8158" class="le jq ht lt b fv lx ly l lz ma">class Contract{</span><span id="9c57" class="le jq ht lt b fv me ly l lz ma">constructor(privateKey = ''){<br/>      this.privateKey = privateKey;<br/>   }<br/> <br/>}</span></pre><p id="cd93" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">初始化与我们的智能合约交互的实例。如果我们有或没有私钥，我们有两种可能性。如果我们已经有了私钥，我们将如上所述使用wallet provider创建实例。否则我们将使用默认方式使用<code class="eh mb mc md lt b">web3</code>。Web3js是最著名的与Solidity交互的库之一。这两个类在初始化方面的主要区别在于提供程序。</p><p id="22db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">创建接受合同名称的<code class="eh mb mc md lt b">initContract()</code>,然后获取合同的技巧并检查私钥是否存在。我们用<code class="eh mb mc md lt b">HDWalletProvider</code>初始化合同以签署事务，否则我们使用<code class="eh mb mc md lt b">Web3</code>读取事务。</p><pre class="kt ku kv kw fq ls lt lu lv aw lw dt"><span id="0c94" class="le jq ht lt b fv lx ly l lz ma">/*Inside Contract Class*/<br/>  async initContract(contractName){<br/>  /*Get Contract Articicates*/<br/>    const filePath =   path.resolve('build/contracts/'+contractName+'.json');<br/>    let rawdata = fs.readFileSync(filePath);<br/>    this.contractArtificaits = JSON.parse(rawdata);<br/>    this.contract = contract(this.contractArtificaits);<br/>    /*Check private key*/<br/>    if (this.privateKey) {<br/>      await this.WalletProviderInitContract();<br/>    }<br/>    else{<br/>      await this.web3ProviderInitContract();<br/>    }<br/>    this.instance = await this.contract.deployed();<br/>    return this.instance;<br/>  }</span><span id="5a31" class="le jq ht lt b fv me ly l lz ma">/*Create contract instance using WalletProvider*/<br/>   async WalletProviderInitContract(){<br/>    this.provider = new   WalletProvider(this.privateKey,"<a class="ae jo" href="http://127.0.0.1:8545/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8545/</a>");<br/>    this.contract.setProvider(this.provider);<br/>    }</span><span id="f557" class="le jq ht lt b fv me ly l lz ma">/*Create contract instance using Web3*/<br/>async web3ProviderInitContract(){<br/>    this.contract.setProvider(web3Provider);<br/>    }</span></pre><p id="7d63" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们可以使用<code class="eh mb mc md lt b">this.instance</code>来执行契约方法。</p><h2 id="8f89" class="le jq ht bd jr lf lg lh jv li lj lk jz jb ll lm kd jf ln lo kh jj lp lq kl lr dt translated">创建Getter和Setter方法</h2><p id="9bac" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">是一个私有函数，只有当我们需要从任何契约中调用函数时，我们才能在内部使用它。对于getter和setter方法，我们可以自由地签署一个事务，或者读取我们的私有密钥，或者如果我们需要使用另一个。(这是可选的，我添加这个特性是为了让我的代码对我的团队来说更加灵活)</p><pre class="kt ku kv kw fq ls lt lu lv aw lw dt"><span id="d1fe" class="le jq ht lt b fv lx ly l lz ma">/*Read Transactions*/<br/>  async getter(contractName,methodName,args,_privateKey ='') {<br/>    if (_privateKey !== '') {<br/>         this.privateKey = _privateKey;<br/>    }  <br/>    await this.initContract(contractName)<br/>    if (this.privateKey) {<br/>      return await this.instance[methodName](...args,{from:web3.eth.accounts.privateKeyToAccount(this.privateKey).address});        <br/>    }<br/>    else{<br/>      return await this.instance[methodName](...args);        <br/>    }<br/>  }</span><span id="87df" class="le jq ht lt b fv me ly l lz ma">/*Submit Transactions*/<br/>async setter(contractName,methodName,args,_privateKey ='') {<br/>    if (_privateKey !== '') {<br/>        this.privateKey = _privateKey;<br/>    } <br/>    await this.initContract(contractName);<br/>    const value = await this.instance[methodName](...args,{from:web3.eth.accounts.privateKeyToAccount(this.privateKey).address});<br/>    return value;<br/>    }</span></pre><p id="cd8b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后要做的是添加一个静态函数来与契约<strong class="is hu">交互，而不需要</strong>初始化契约类对象。如果他们需要进行交易，这个函数是为后端创建的。并且不需要使用类。</p><pre class="kt ku kv kw fq ls lt lu lv aw lw dt"><span id="c65b" class="le jq ht lt b fv lx ly l lz ma">static async useContract(method,contractName,methodName,args,_privateKey ='') {<br/>    const contract = new Contract()<br/>    if (method === 'get') {<br/>        return await contract.getter(contractName,methodName,args,_privateKey);<br/>    } <br/>    else if(method === 'set'){<br/>           return await contract.setter(contractName,methodName,args,_privateKey);<br/>          }<br/>    else{<br/>        throw Error('Invalid Option');<br/>        }     <br/>    }</span></pre><p id="3178" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">完成后，我们应该有类似的东西。</p><pre class="kt ku kv kw fq ls lt lu lv aw lw dt"><span id="f38b" class="le jq ht lt b fv lx ly l lz ma">'use strict';<br/>const contract = require('<a class="ae jo" href="http://twitter.com/truffle/contract" rel="noopener ugc nofollow" target="_blank">@truffle/contract</a>');<br/>const WalletProvider = require('<a class="ae jo" href="http://twitter.com/truffle/hdwallet-provider" rel="noopener ugc nofollow" target="_blank">@truffle/hdwallet-provider</a>');<br/>const path= require('path');<br/>const fs = require('fs');<br/>const CryptoJS = require("crypto-js");<br/>const Web3 = require('web3');<br/>const web3 = new Web3(new Web3.providers.HttpProvider('<a class="ae jo" href="http://127.0.0.1:8545/'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8545/'</a>)); <br/>const web3Provider = new Web3.providers.HttpProvider('<a class="ae jo" href="http://127.0.0.1:8545/'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8545/'</a>);<br/>class Contract {<br/>    <br/>  constructor(privateKey='') {<br/>    this.privateKey = privateKey;<br/>    }<br/>    <br/>    <br/>    /*Contract Initialization */<br/>  async initContract(contractName){<br/>    const filePath = path.resolve('build/contracts/'+contractName+'.json');<br/>    let rawdata = fs.readFileSync(filePath);<br/>    this.contractArtificaits = JSON.parse(rawdata);<br/>    this.contract = contract(this.contractArtificaits);<br/>    if (this.privateKey) {<br/>      await this.WalletProviderInitContract();<br/>    }<br/>    else{<br/>      await this.web3ProviderInitContract();<br/>    }<br/>    this.instance = await this.contract.deployed();<br/>    return this.instance;<br/>  }<br/>    <br/>  async WalletProviderInitContract(){<br/>    this.provider = new WalletProvider(this.privateKey,"<a class="ae jo" href="http://127.0.0.1:8545/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8545/</a>");<br/>    this.contract.setProvider(this.provider);<br/>    }<br/>    <br/>  async web3ProviderInitContract(){<br/>    this.contract.setProvider(web3Provider);<br/>    }<br/>    <br/>    /*Account creation */<br/>  static async getAccount(privateKey) {<br/>    return web3.eth.accounts.privateKeyToAccount(privateKey);<br/>    }</span><span id="5924" class="le jq ht lt b fv me ly l lz ma">static async createAccount() {<br/>    const newAccout = await web3.eth.accounts.create();<br/>    return newAccout;<br/>    }</span><span id="f4f7" class="le jq ht lt b fv me ly l lz ma">/*Transactions submmitions */<br/>  async getter(contractName,methodName,args,_privateKey ='') {<br/>    if (_privateKey !== '') {<br/>         this.privateKey = _privateKey;<br/>    }  <br/>    await this.initContract(contractName)<br/>    if (this.privateKey) {<br/>      return await this.instance[methodName](...args,{from:web3.eth.accounts.privateKeyToAccount(this.privateKey).address});        <br/>    }<br/>    else{<br/>      return await this.instance[methodName](...args);        <br/>    }<br/>  }</span><span id="c0fb" class="le jq ht lt b fv me ly l lz ma">async setter(contractName,methodName,args,_privateKey ='') {<br/>    if (_privateKey !== '') {<br/>        this.privateKey = _privateKey;<br/>    } <br/>    await this.initContract(contractName);<br/>    const value = await this.instance[methodName](...args,{from:web3.eth.accounts.privateKeyToAccount(this.privateKey).address});<br/>    return value;<br/>    }<br/>    <br/>  static async useContract(method,contractName,methodName,args,_privateKey ='') {<br/>    const contract = new Contract()<br/>    if (method === 'get') {<br/>        return await contract.getter(contractName,methodName,args,_privateKey);<br/>    } <br/>    else if(method === 'set'){<br/>           return await contract.setter(contractName,methodName,args,_privateKey);<br/>          }<br/>    else{<br/>        throw Error('Invalid Option');<br/>        }     <br/>    }</span><span id="23dd" class="le jq ht lt b fv me ly l lz ma">}  <br/>module.exports = Contract</span></pre><p id="f638" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是接下来我们需要为用户生成私有公钥的困难部分，然后找到一种安全提交密钥的方法。</p><h1 id="19f5" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">创建区块链账户</h1><p id="2c24" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">Web3提供了一个简单方法来创建区块链帐户，就像这样使用<code class="eh mb mc md lt b"> create()</code></p><pre class="kt ku kv kw fq ls lt lu lv aw lw dt"><span id="709b" class="le jq ht lt b fv lx ly l lz ma">static async createAccount() {<br/>    const newAccount = await web3.eth.accounts.create();<br/>    return newAccount;<br/>}</span></pre><p id="3360" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh mb mc md lt b">newAccount</code>将返回一个带有地址和私钥的JSON对象。现在用户应该保管好他的密钥来使用他的帐户。但是如果我们需要他在服务器上提交一个事务，而我们不想保存他的私钥，该怎么办呢？</p><p id="4fdd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我找到的最佳答案是使用用户密码加密我的私钥用户有密码，而我只有加密的文本</p><pre class="kt ku kv kw fq ls lt lu lv aw lw dt"><span id="a3bb" class="le jq ht lt b fv lx ly l lz ma">/* Private Key Management */<br/>  static async createRandomEncryptedPrivateKey(password) {<br/>    const newAccount = web3.eth.accounts.create();<br/>    const privateKey = newAccount.privateKey;<br/>    const encryptedPrivateKey = CryptoJS.AES.encrypt(privateKey, password).toString();<br/>    return encryptedPrivateKey;<br/>  }</span><span id="b66f" class="le jq ht lt b fv me ly l lz ma">static async accountFromEncryptedPrivateKey(encryptedPrivateKey, password) {<br/>    const decryptedObject = CryptoJS.AES.decrypt(encryptedPrivateKey, password);<br/>    const decryptedPrivateKey = decryptedObject.toString(CryptoJS.enc.Utf8);<br/>    return web3.eth.accounts.privateKeyToAccount(decryptedPrivateKey);<br/>  }</span></pre><p id="2fd2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，我们的类应该是这样的</p><pre class="kt ku kv kw fq ls lt lu lv aw lw dt"><span id="1d36" class="le jq ht lt b fv lx ly l lz ma">'use strict';<br/>const contract = require('<a class="ae jo" href="http://twitter.com/truffle/contract" rel="noopener ugc nofollow" target="_blank">@truffle/contract</a>');<br/>const WalletProvider = require('<a class="ae jo" href="http://twitter.com/truffle/hdwallet-provider" rel="noopener ugc nofollow" target="_blank">@truffle/hdwallet-provider</a>');<br/>const path= require('path');<br/>const fs = require('fs');<br/>const CryptoJS = require("crypto-js");<br/>const Web3 = require('web3');<br/>const web3 = new Web3(new Web3.providers.HttpProvider('<a class="ae jo" href="http://127.0.0.1:8545/'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8545/'</a>)); <br/>const web3Provider = new Web3.providers.HttpProvider('<a class="ae jo" href="http://127.0.0.1:8545/'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8545/'</a>);<br/>class Contract {<br/>    <br/>  constructor(privateKey='') {<br/>    this.privateKey = privateKey;<br/>    }</span><span id="4d8c" class="le jq ht lt b fv me ly l lz ma">static async createAccount() {<br/>       const newAccount = await web3.eth.accounts.create();<br/>       return newAccount;<br/>     }<br/>    <br/>    /*Contract Initialization */<br/>  async initContract(contractName){<br/>    const filePath = path.resolve('build/contracts/'+contractName+'.json');<br/>    let rawdata = fs.readFileSync(filePath);<br/>    this.contractArtificaits = JSON.parse(rawdata);<br/>    this.contract = contract(this.contractArtificaits);<br/>    if (this.privateKey) {<br/>      await this.WalletProviderInitContract();<br/>    }<br/>    else{<br/>      await this.web3ProviderInitContract();<br/>    }<br/>    this.instance = await this.contract.deployed();<br/>    return this.instance;<br/>  }<br/>    <br/>  async WalletProviderInitContract(){<br/>    this.provider = new WalletProvider(this.privateKey,"<a class="ae jo" href="http://127.0.0.1:8545/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8545/</a>");<br/>    this.contract.setProvider(this.provider);<br/>    }<br/>    <br/>  async web3ProviderInitContract(){<br/>    this.contract.setProvider(web3Provider);<br/>    }<br/>    <br/>    /*Account creation */<br/>  static async getAccount(privateKey) {<br/>    return web3.eth.accounts.privateKeyToAccount(privateKey);<br/>    }</span><span id="d37d" class="le jq ht lt b fv me ly l lz ma">static async createAccount() {<br/>    const newAccout = await web3.eth.accounts.create();<br/>    return newAccout;<br/>    }</span><span id="3a15" class="le jq ht lt b fv me ly l lz ma">/*Transactions submmitions */<br/>  async getter(contractName,methodName,args,_privateKey ='') {<br/>    if (_privateKey !== '') {<br/>         this.privateKey = _privateKey;<br/>    }  <br/>    await this.initContract(contractName)<br/>    if (this.privateKey) {<br/>      return await this.instance[methodName](...args,{from:web3.eth.accounts.privateKeyToAccount(this.privateKey).address});        <br/>    }<br/>    else{<br/>      return await this.instance[methodName](...args);        <br/>    }<br/>  }</span><span id="3cad" class="le jq ht lt b fv me ly l lz ma">async setter(contractName,methodName,args,_privateKey ='') {<br/>    if (_privateKey !== '') {<br/>        this.privateKey = _privateKey;<br/>    } <br/>    await this.initContract(contractName);<br/>    const value = await this.instance[methodName](...args,{from:web3.eth.accounts.privateKeyToAccount(this.privateKey).address});<br/>    return value;<br/>    }<br/>    <br/>  static async useContract(method,contractName,methodName,args,_privateKey ='') {<br/>    const contract = new Contract()<br/>    if (method === 'get') {<br/>        return await contract.getter(contractName,methodName,args,_privateKey);<br/>    } <br/>    else if(method === 'set'){<br/>           return await contract.setter(contractName,methodName,args,_privateKey);<br/>          }<br/>    else{<br/>        throw Error('Invalid Option');<br/>        }     <br/>    }</span><span id="531a" class="le jq ht lt b fv me ly l lz ma">/* Private Key Management */<br/>  static async createRandomEncryptedPrivateKey(password) {<br/>    const newAccount = web3.eth.accounts.create();<br/>    const privateKey = newAccount.privateKey;<br/>    const encryptedPrivateKey = CryptoJS.AES.encrypt(privateKey, password).toString();<br/>    return encryptedPrivateKey;<br/>  }</span><span id="6a2d" class="le jq ht lt b fv me ly l lz ma">static async accountFromEncryptedPrivateKey(encryptedPrivateKey, password) {<br/>    const decryptedObject = CryptoJS.AES.decrypt(encryptedPrivateKey, password);<br/>    const decryptedPrivateKey = decryptedObject.toString(CryptoJS.enc.Utf8);<br/>    return web3.eth.accounts.privateKeyToAccount(decryptedPrivateKey);<br/>  }</span><span id="49a3" class="le jq ht lt b fv me ly l lz ma">}  <br/>module.exports = Contract</span></pre><p id="75da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">目前，我们的团队正在寻找提供区块链即服务的最佳方式，以便以更快、更简单的方式实施区块链。然后我们将创建我们的微服务。如果你有什么更好的解决方法，请分享给我。我希望我说清楚了。但是，如果你有任何问题，请随时问我。</p><p id="652f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们正计划实施更多的功能，如获取事件日志，并分离前端团队的区块链服务，然后后端团队的区块链服务。我们很高兴听到您的意见或任何建议，以制定更好的解决方案。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff mf"><img src="../Images/e9dbce386c4f90837b5db529a4c87766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fZu_SfnNF6m_BGbXlsl-A@2x.png"/></div></a></figure><blockquote class="mg"><p id="22f4" class="mh mi ht bd mj mk ml mm mn mo mp jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="mr ms mt mu mv kx fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mq"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>