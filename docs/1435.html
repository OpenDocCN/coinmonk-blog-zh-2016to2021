<html>
<head>
<title>Machine Learning Tutorial #4: Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习教程#4:部署</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/machine-learning-tutorial-4-deployment-79764123e9e1?source=collection_archive---------3-----------------------#2018-09-02">https://medium.com/coinmonks/machine-learning-tutorial-4-deployment-79764123e9e1?source=collection_archive---------3-----------------------#2018-09-02</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="f92d" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">主题:堆栈选择、Heroku、测试</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/a472b44c367f2d8c3427db6f0c96d03f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T_-rIQ8yUgPba_ezxt6ogg.png"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Machine Learning project overview. Author: Adam Novotny</figcaption></figure><p id="2411" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">在这个系列的最后阶段，我将建议ML工程师部署他们的代码的几个选项。在大型组织中，项目的这一部分将由一个专门的团队来处理，这在关注可伸缩性时尤为重要。本系列其他教程:<a class="ae ku" rel="noopener" href="/coinmonks/machine-learning-tutorial-1-preprocessing-d90198e37577"> #1预处理</a>、<a class="ae ku" rel="noopener" href="/coinmonks/machine-learning-tutorial-2-training-f6f735830838"> #2训练</a>、<a class="ae ku" rel="noopener" href="/coinmonks/machine-learning-tutorial-3-evaluation-a157f90914c9"> #3评测</a>、#4部署(本文)。<a class="ae ku" href="https://github.com/adam5ny/blogs/tree/master/ml-deployment" rel="noopener ugc nofollow" target="_blank"> Github代码</a>。</p><h1 id="2c5f" class="kv kw ht bd kx ky kz la lb lc ld le lf iz lg ja lh jc li jd lj jf lk jg ll lm dt translated">堆栈选择</h1><p id="f0bb" class="pw-post-body-paragraph jy jz ht ka b kb ln iu kd ke lo ix kg kh lp kj kk kl lq kn ko kp lr kr ks kt hm dt translated">部署ML代码的选项有很多，但我通常至少在三个通用类别中做出选择:</p><ul class=""><li id="cd17" class="ls lt ht ka b kb kc ke kf kh lu kl lv kp lw kt lx ly lz ma dt translated">作为服务提供的解决方案(例如微软Azure Machine Learning Studio)</li><li id="1101" class="ls lt ht ka b kb mb ke mc kh md kl me kp mf kt lx ly lz ma dt translated">无服务器功能(例如<a class="ae ku" href="https://docs.aws.amazon.com/lambda/latest/dg/python-programming-model.html" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a></li><li id="2d9e" class="ls lt ht ka b kb mb ke mc kh md kl me kp mf kt lx ly lz ma dt translated">自定义后端代码(例如<a class="ae ku" href="http://flask.pocoo.org/docs/0.12/" rel="noopener ugc nofollow" target="_blank"> Python Flask </a>由<a class="ae ku" href="https://devcenter.heroku.com/articles/getting-started-with-python" rel="noopener ugc nofollow" target="_blank"> Heroku </a>提供服务)</li></ul><h2 id="619c" class="mg kw ht bd kx mh mi mj lb mk ml mm lf kh mn mo lh kl mp mq lj kp mr ms ll mt dt translated">即服务解决方案</h2><p id="fc5d" class="pw-post-body-paragraph jy jz ht ka b kb ln iu kd ke lo ix kg kh lp kj kk kl lq kn ko kp lr kr ks kt hm dt translated">微软Azure Machine Learning Studio等平台为整个项目提供全套工具，包括预处理和训练。自定义API端点通常很容易生成，而且由于有了拖放式接口，编写代码通常是不必要的。这些解决方案通常针对懒惰的学习者进行了很好的优化，因为评估是最昂贵的计算步骤。不利的一面是，在不经历平台上所有项目步骤的情况下，引入定制代码(比如最终的模型)有时更具挑战性。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mu"><img src="../Images/2ad9bc2eb2d0331c0d3b38e880c72384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4F3z9NovnqtOtIRWRCJn_Q.jpeg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">As-a-service deployment example: Microsoft Azure</figcaption></figure><h2 id="3191" class="mg kw ht bd kx mh mi mj lb mk ml mm lf kh mn mo lh kl mp mq lj kp mr ms ll mt dt translated">无服务器功能</h2><p id="806d" class="pw-post-body-paragraph jy jz ht ka b kb ln iu kd ke lo ix kg kh lp kj kk kl lq kn ko kp lr kr ks kt hm dt translated">无服务器函数是廉价计算的好解决方案。AWS使用3秒的默认超时来完成一个功能。虽然超时可以延长，但在决定是否合适时，默认值通常是一个很好的通用指南。Lambda只允许上传50MB的定制代码，这对于大多数机器学习目的来说通常是不够的。然而，函数非常适合快速计算，如线性回归模型。另一个缺点是平台只支持特定的语言。就Python解决方案而言，在撰写本文时，AWS Lambda仅支持2.7和3.6版本。</p><h2 id="85ef" class="mg kw ht bd kx mh mi mj lb mk ml mm lf kh mn mo lh kl mp mq lj kp mr ms ll mt dt translated">自定义后端代码</h2><p id="ccef" class="pw-post-body-paragraph jy jz ht ka b kb ln iu kd ke lo ix kg kh lp kj kk kl lq kn ko kp lr kr ks kt hm dt translated">在Heroku或Amazon的EC2等平台上编写定制的后端代码允许我们完全复制我们在本地机器上编写的代码。代码和服务器部署可以针对我们正在部署的ML算法类型进行完全定制。这种解决方案的缺点是操作复杂，因为我们需要关注许多与ML无关的步骤，例如安全性。</p><p id="2493" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">我将把代码部署在Heroku上，它为测试提供了一个自由层。轻量级的<a class="ae ku" href="http://flask.pocoo.org/" rel="noopener ugc nofollow" target="_blank">烧瓶框架</a>将驱动后端。这样选择的主要原因是，它允许我们在后端重用以前教程中编写的所有代码。我们可以将Flask与Python 3.6和我们以前使用的所有机器学习库并排安装。</p><p id="a521" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">使用Flask，运行应用程序的整个后端代码只有几行:</p><pre class="jj jk jl jm fq mv mw mx my aw mz dt"><span id="36c2" class="mg kw ht mw b fv na nb l nc nd">import pickle<br/>import pandas as pd<br/>from flask import Flask, jsonify, request, make_response</span><span id="cffb" class="mg kw ht mw b fv ne nb l nc nd">app = Flask(__name__)</span><span id="e848" class="mg kw ht mw b fv ne nb l nc nd"><a class="ae ku" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/forecast', methods=["POST"])<br/>def forecast_post():<br/>    """<br/>    Args:<br/>        request.data: json pandas dataframe<br/>            example: {<br/>                "columns": ["date", "open", "high", "low", "close",<br/>                   "volume"],<br/>                "index":[1, 0],<br/>                "data": [<br/>                   [1532390400000, 108, 108, 107, 107, 26316],<br/>                   [1532476800000, 107, 111, 107, 110, 30702]]<br/>            }<br/>    """<br/>    if request.data:<br/>        df = pd.read_json(request.data, orient='split')<br/>        X = preprocess(df)<br/>        model = pickle.load(open("dtree_model.pkl", "rb"))<br/>        y_pred = run_model(X, model)<br/>        resp = make_response(jsonify({<br/>           "y_pred": json.dumps(y_pred.tolist())<br/>        }), 200)<br/>        return resp<br/>    else:<br/>        return make_response(jsonify({"message": "no data"}), 400)</span></pre><ul class=""><li id="c753" class="ls lt ht ka b kb kc ke kf kh lu kl lv kp lw kt lx ly lz ma dt translated">pd.read_json(…):从<a class="ae ku" href="https://en.wikipedia.org/wiki/POST_(HTTP)" rel="noopener ugc nofollow" target="_blank"> POST请求</a>中读取数据，这是一个json对象，对应于与Yahoo finance prices(我们的原始数据源)格式相同的价格数据</li><li id="7fc9" class="ls lt ht ka b kb mb ke mc kh md kl me kp mf kt lx ly lz ma dt translated">预处理(…):来自<a class="ae ku" rel="noopener" href="/coinmonks/machine-learning-tutorial-1-preprocessing-d90198e37577">预处理</a>教程的代码副本，它将原始价格数据处理成特性。重要的是，所用的定标器必须与我们在预处理中使用的定标器完全相同，所以在预处理过程中必须先保存到pickle文件，然后从pickle加载</li><li id="6a1c" class="ls lt ht ka b kb mb ke mc kh md kl me kp mf kt lx ly lz ma dt translated">run_model(…):加载并运行我们保存的来自<a class="ae ku" rel="noopener" href="/coinmonks/machine-learning-tutorial-2-training-f6f735830838">培训</a>教程的最终模型</li><li id="1d0d" class="ls lt ht ka b kb mb ke mc kh md kl me kp mf kt lx ly lz ma dt translated">make_response(…):返回预测</li></ul><h1 id="e619" class="kv kw ht bd kx ky kz la lb lc ld le lf iz lg ja lh jc li jd lj jf lk jg ll lm dt translated">赫罗库</h1><p id="12fc" class="pw-post-body-paragraph jy jz ht ka b kb ln iu kd ke lo ix kg kh lp kj kk kl lq kn ko kp lr kr ks kt hm dt translated">将我们的预测代码部署到Heroku将需要我们从以前的教程中收集至少两段必要的代码:最终模型(保存为pickle文件)和来自<a class="ae ku" rel="noopener" href="/coinmonks/machine-learning-tutorial-1-preprocessing-d90198e37577">预处理</a>教程的代码，该教程将我们从现实世界中收集的原始特征转换为我们的模型可以处理的特征。</p><p id="e14d" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">关于如何在Heroku上部署Docker app，我就不赘述了。有大量的好材料包括Heroku的文档，非常好。在Heroku上运行和部署Docker应用程序的所有必要代码也在Github repo中。需要记住几个关键步骤:</p><ul class=""><li id="7256" class="ls lt ht ka b kb kc ke kf kh lu kl lv kp lw kt lx ly lz ma dt translated">将Dockerfile另存为<em class="nf"> Dockerfile.we </em> b，这是运行应用程序所需的所有代码的容器</li><li id="5e66" class="ls lt ht ka b kb mb ke mc kh md kl me kp mf kt lx ly lz ma dt translated">使用命令<a class="ae ku" href="https://devcenter.heroku.com/articles/container-registry-and-runtime" rel="noopener ugc nofollow" target="_blank"> heroku container:push </a>部署容器</li><li id="2418" class="ls lt ht ka b kb mb ke mc kh md kl me kp mf kt lx ly lz ma dt translated">使用命令<a class="ae ku" href="https://devcenter.heroku.com/articles/container-registry-and-runtime" rel="noopener ugc nofollow" target="_blank">释放容器heroku容器:释放</a></li></ul><p id="931c" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">此时，我们的代码已经部署完毕，我们可以使用<a class="ae ku" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjmut-U1JvdAhVKsqQKHaQUBg0QFjAAegQIBRAC&amp;url=https%3A%2F%2Fwww.getpostman.com%2F&amp;usg=AOvVaw1vWzpwzQOHi5ErKZnywLDR" rel="noopener ugc nofollow" target="_blank">邮递员</a>发出一个手动预测请求进行测试:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ng"><img src="../Images/3b132787d076747c9367f6d83f3650ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kvKnVEez88tZ96uTtOqjg.png"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Postman sample request</figcaption></figure><p id="6f41" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">日期由Unix时间戳表示。第一个主体窗口由我们以价格形式提供给端点的输入组成。第二个窗口从应用程序返回预测。</p><h1 id="34e9" class="kv kw ht bd kx ky kz la lb lc ld le lf iz lg ja lh jc li jd lj jf lk jg ll lm dt translated">测试</h1><p id="a25b" class="pw-post-body-paragraph jy jz ht ka b kb ln iu kd ke lo ix kg kh lp kj kk kl lq kn ko kp lr kr ks kt hm dt translated">为了测试实现，我将重用评估步骤中的代码。然而，我将使用Heroku应用程序批量预测评估的691个样本，而不是使用我们的sklearn模型在本地进行预测。目标是让我们在本地机器上做出的预测与使用我们的部署堆栈做出的预测完全匹配。</p><p id="dfcf" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">这一步对于确保我们能够使用预先训练的模型远程复制我们的结果至关重要。测试代码也可以在<a class="ae ku" href="https://github.com/adam5ny/blogs/blob/master/ml-deployment/backend/tests/test_app.py" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。我们确认Heroku应用的性能与评估教程中本地生成的性能相匹配:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff nh"><img src="../Images/2f084578f13bc66ad9674250ab2638f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oewaabcu926MZpC-zFFpHQ.png"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Tested deployment performance matches evaluation results</figcaption></figure><p id="f00f" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">总之，该项目旨在提供一个数据科学项目需要的思维类型的概述。不应在生产中使用该代码，它仅用于说明目的。一如既往，我欢迎所有建设性的反馈(积极的或消极的)。</p><p id="5d57" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">本系列其他教程:<a class="ae ku" rel="noopener" href="/coinmonks/machine-learning-tutorial-1-preprocessing-d90198e37577"> #1预处理</a>、<a class="ae ku" rel="noopener" href="/coinmonks/machine-learning-tutorial-2-training-f6f735830838"> #2训练</a>、<a class="ae ku" rel="noopener" href="/coinmonks/machine-learning-tutorial-3-evaluation-a157f90914c9"> #3评测</a>、#4部署(本文)。<a class="ae ku" href="https://github.com/adam5ny/blogs/tree/master/ml-deployment" rel="noopener ugc nofollow" target="_blank"> Github代码</a>。</p><p id="ebbb" class="pw-post-body-paragraph jy jz ht ka b kb kc iu kd ke kf ix kg kh ki kj kk kl km kn ko kp kq kr ks kt hm dt translated">作者网址:<a class="ae ku" href="https://www.adamnovotny.com/" rel="noopener ugc nofollow" target="_blank">adamnovotny.com</a></p></div></div>    
</body>
</html>