<html>
<head>
<title>Ethereum Under the Hood- Part 2 (RLP Encoding)-ver 0.3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引擎盖下的以太坊-第2部分(RLP编码)-0.3版</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethereum-under-the-hood-part-2-rlp-encoding-ver-0-3-c37a69781855?source=collection_archive---------1-----------------------#2021-02-25">https://medium.com/coinmonks/ethereum-under-the-hood-part-2-rlp-encoding-ver-0-3-c37a69781855?source=collection_archive---------1-----------------------#2021-02-25</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="bc47" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">原始发布日期:<a class="ae jo" rel="noopener" href="/coinmonks/ethereum-under-the-hood-part-ii-i-933411deebe1?source=post_page-----933411deebe1--------------------------------">2018年4月25日</a></p><p id="c9ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">更新:语法修正</em></p><p id="4828" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">文章的第二部分，如果你还没有完成第一部分，请完成。我们将在本文中介绍以太坊如何使用</em> <strong class="is hu"> <em class="jp">递归长度前缀</em> </strong> <em class="jp">对数据和状态进行编码。</em></p><p id="129e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是一个稍微长一点的阅读，所以给自己弄点咖啡，准备好被弄糊涂，我读了关于RLP的书</p><p id="1a2b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">问题:</strong></p><p id="a420" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以太坊是一台全球计算机，以太坊要处理的数据必须通过线路紧凑高效地发送。以太坊团队选择了<strong class="is hu">递归链接前缀</strong>解码/编码算法来实现上述目标。如果你浏览以太坊的文章，会发现提到了"<a class="ae jo" href="https://github.com/ethereum/wiki/wiki/Ethereum-Development-Tutorial#state-machine" rel="noopener ugc nofollow" target="_blank">堆叠机器</a>"以及它们在以太坊中的用法，所以让我们稍微介绍一下。</p><p id="6930" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">堆垛机:</strong></p><p id="10c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们简单介绍一下什么是<a class="ae jo" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">堆栈</a>。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/f49cbaf3b3ef86ec9dcfb497a849440b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KoN3TUmCCfGoiRzQ.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek"><strong class="bd kg">Stack Machine</strong></figcaption></figure><p id="f465" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://en.wikipedia.org/wiki/File:Lifo_stack.png" rel="noopener ugc nofollow" target="_blank">来源:维基</a></p><p id="125d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以太坊虚拟机(EVM)是一种基于堆栈的机器，它使用后进先出(LIFO)方法将指令和数据存储在基于堆栈的中。让我们以字符串"<strong class="is hu"> cat </strong>"为例，看看它是如何将<strong class="is hu">推入堆栈的</strong></p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="cf1a" class="km kn ht ki b fv ko kp l kq kr">['c','a','t' ] <br/>so the PUSH operation will be:<br/><strong class="ki hu">PUSH(‘c’) <br/>PUSH(‘a’) <br/>PUSH(‘t’)<br/></strong>When data has to be retrieved POP function is used in the order it was put in:<br/><strong class="ki hu">POP('t')<br/>POP('a')<br/>POP('c')</strong></span></pre><p id="b37b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以太坊栈有一定的限制。堆栈深度在<a class="ae jo" href="https://ethereum.stackexchange.com/questions/26938/why-is-the-evm-stack-limited-to-1024" rel="noopener ugc nofollow" target="_blank"> 1024 </a>元素处达到最大，每条指令的最大字长为256位或最大32字节。我认为这就是指令集的宽度，如下图所示。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ks"><img src="../Images/1cb1ad838b8ab52663ceb3d45f409e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*smlie3lAWS7nnMOs.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Ethereum Stack Machine(1024 elements max height, 32 bytes max word size)</figcaption></figure><p id="df39" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">栈式机器是实现小型编译器的理想选择。让我们来看一个表达</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="ba42" class="km kn ht ki b fv ko kp l kq kr">[<strong class="ki hu">[0x12344</strong>]<strong class="ki hu">,[ (a+b*c/d</strong>), <strong class="ki hu">'x', 9]</strong> ]</span></pre><p id="9bf8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">需要考虑一些事情，上面的数组中有两个项目。十六进制值和表达式。将十六进制值(0x12344)视为以太坊地址，将表达式视为状态变化信息。注意，该字的最大长度为256位。我们来考虑一下<code class="eh kt ku kv ki b">[(a+b*c/d), ‘x’, 9 ]. </code>整个表达式小于32字节。你问为什么是32字节？这里有一个关于这个话题的很好的<a class="ae jo" href="https://ethereum.stackexchange.com/questions/7382/rationale-behind-256-bit-words-in-evm" rel="noopener ugc nofollow" target="_blank">栈交换</a>讨论。</p><p id="0b1d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">看看这个关于<a class="ae jo" href="https://www.youtube.com/watch?v=GtKJ-ccF3oI" rel="noopener ugc nofollow" target="_blank">堆垛机</a>的youtube视频</p><p id="1700" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">字节数组和项目</strong>:</p><p id="34e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们回顾一下从上一篇文章中学到的一些概念。以太坊中的所有数据都被<a class="ae jo" href="https://stackoverflow.com/questions/3784143/what-is-the-difference-between-serializing-and-encoding" rel="noopener ugc nofollow" target="_blank">序列化</a>并反序列化为一个字节数组。放，一个字节数组是一个<a class="ae jo" href="https://stackoverflow.com/questions/4019837/what-do-we-mean-by-byte-array" rel="noopener ugc nofollow" target="_blank">字节数组</a>，值得重复一些这些字节数组的例子。</p><p id="402a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> RLP </strong>编码函数接受一个<strong class="is hu">项</strong>或一组<strong class="is hu">项</strong></p><ul class=""><li id="7d05" class="kw kx ht is b it iu ix iy jb ky jf kz jj la jn lb lc ld le dt translated">字符串(即字节数组)是一个项目</li><li id="c8b3" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn lb lc ld le dt translated">项目列表也是一个项目</li></ul><p id="f9a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="jp">例项和目项</em> </strong></p><ul class=""><li id="d53b" class="kw kx ht is b it iu ix iy jb ky jf kz jj la jn lb lc ld le dt translated"><strong class="is hu">“比特币”</strong></li><li id="cc1d" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn lb lc ld le dt translated"><strong class="is hu"> [ [] ] </strong></li><li id="068d" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn lb lc ld le dt translated"><strong class="is hu"> [《狮子》] </strong></li><li id="f4f6" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn lb lc ld le dt translated"><strong class="is hu"> [ ["猫"，123，' d '，' o '，' g'] ] </strong></li></ul><p id="66c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">现在，什么是<em class="jp">递归链接前缀</em> (RLP)？</strong></p><p id="708d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">RLP是一组编码和解码结构和数据的规则。<em class="jp">第二部分。我</em>关注<strong class="is hu"> RLP编码；我们</strong>将在<em class="jp">第二部中讲述<strong class="is hu">RLP</strong>T41】解码。II </em>的文章在后面的帖子里。让我们回顾一下RLP的内涵。如果你记得在之前的<a class="ae jo" rel="noopener" href="/@deepakraous/ethereum-under-the-hood-part-i-ver-0-1-4f2fb24b3d68">文章</a>中我们讨论过<strong class="is hu">“项目”</strong>，所有的“项目”都是<strong class="is hu">字节数组</strong>。RLP函数接受类型<strong class="is hu">对象的一个参数。</strong></p><p id="c6ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">RLP的一个重要方面是，它将特定结构的编码规则留给顶级层，例如，如果存在另一种结构，例如{“ABC”}。RLP会将其视为字符串元素，并将编码工作留给顶层</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="786d" class="km kn ht ki b fv ko kp l kq kr"><em class="jp">function</em> encodeRLP<strong class="ki hu">(rawData)</strong>{ <br/>  .....,<br/> return encodedData #type bytearray;<br/>}<em class="jp">function</em> decodeRLP<strong class="ki hu">(bytearray stateInfo)</strong>{<br/>  .....,<br/>  return decodeData #raw;<br/>}</span></pre><p id="3753" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们进入这些对象的RLP <strong class="is hu">编码</strong>规则:</p><p id="7d33" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">提示:我建议打开一个</em> <a class="ae jo" href="https://www.asciitable.com/" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> ASCII </em> </a> <em class="jp">图表。</em></p><h1 id="aa3d" class="lk kn ht bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">RLP编码规则定义如下:</h1><p id="2fdc" class="pw-post-body-paragraph iq ir ht is b it mh iv iw ix mi iz ja jb mj jd je jf mk jh ji jj ml jl jm jn hm dt translated"><strong class="is hu"> <em class="jp">规则1:当对具有1个字节的有效载荷进行编码并且该字节中的值落在以下范围[0x00，0x7f]内时，换句话说，落在[0，127]内，然后将该单字节编码为RLP本身</em> </strong></p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="ba5d" class="km kn ht ki b fv ko kp l kq kr">$ 120 to rlp<br/><strong class="ki hu"><em class="jp">78</em> <br/></strong>$ 127 to rlp<br/><strong class="ki hu"><em class="jp">7F<br/></em></strong>$ "a" to rlp<br/><strong class="ki hu">a</strong></span></pre><p id="8a8f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，将120编码成RLP导致了<strong class="is hu"> <em class="jp"> 78 </em> </strong>，127导致了<strong class="is hu"> <em class="jp"> 7F、</em> </strong>，对于“a”，编码导致了“<strong class="is hu"> a </strong>”，并且字节大小为1，并且编码规则#1适用。</p><p id="725e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="jp">规则2:当对一个介于0和55字节之间的字符串(在字节数组中)进行编码时，应用以下逻辑。</em>T29】</strong></p><p id="7032" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh kt ku kv ki b"><strong class="is hu">0x80+length(string),string</strong></code></p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="f659" class="km kn ht ki b fv ko kp l kq kr">string "dog" to byte-array in hex is [0x64,0x6f,0x67] and size of the byte array is 3</span></pre><p id="6822" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们将项目“<strong class="is hu"> dog </strong>”编码到RLP中，字节数组的大小即长度为3，因此编码到RLP中将导致</p><p id="b7b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh kt ku kv ki b">[0x80+3,0x64,0x6f,0x67] -&gt; [<strong class="is hu">0x83</strong>, 0x64, 0x6f, 0x67]</code></p><p id="f993" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">例如:另一个例子是RLP编码的“<strong class="is hu"> hello world </strong>”。“hello world”的大小是11字节。</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="6bd7" class="km kn ht ki b fv ko kp l kq kr">$ "hello world" to rlp<br/> [<strong class="ki hu">0x8B</strong> 0x68 0x65 0x6C 0x6C 0x6F 0x20 0x77 0x6F 0x72 0x6C 0x64]</span></pre><p id="3529" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="jp">规则3:对大于55字节的字符串(字节数组)进行编码时，应用以下规则。</em> </strong></p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="5059" class="km kn ht ki b fv ko kp l kq kr">1)0xb7+length_in_bytes(byte_size(string)) <br/>2)length(string)<br/>3)encoded string  <br/>Join 1,2,3</span></pre><p id="7647" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们举一个例子字符串“你好，我是一个很长很长的字符串，我将在RLP得到编码！”。<strong class="is hu">管柱</strong>的长度为<strong class="is hu"> 76，</strong>因此规则3适用。让我们先解决几个先决条件。</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="91e8" class="km kn ht ki b fv ko kp l kq kr"><em class="jp">a)len raw string = 76 <br/>b)byte_size(string) =76 <br/>c)length_in_bytes(byte_size(string) ) = 1</em></span></pre><p id="c57a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">遵循规则#3的步骤</p><ol class=""><li id="58b8" class="kw kx ht is b it iu ix iy jb ky jf kz jj la jn mm lc ld le dt translated">0xb7 + 1</li><li id="44c1" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn mm lc ld le dt">76</li><li id="49d6" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn mm lc ld le dt translated">"你好，我是一个很长很长的字符串，我将在RLP被编码！"</li><li id="4215" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn mm lc ld le dt translated">(0xb7+1)，76，“你好，我是一个非常非常长的字符串，我将在RLP得到编码！”</li></ol><p id="1d9b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以最终的十六进制RLP编码是:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="5e76" class="km kn ht ki b fv ko kp l kq kr"><strong class="ki hu">B84C</strong><em class="jp">48656C6C6F2074686572652C204920616D206120766572792076657279206C6F6E6720737472696E6720616E64204920616D20676F696E672067657420656E636F64656420696E20524C5021</em></span></pre><p id="9217" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="jp">规则4:当对一个列表进行编码，并且列表中的编码净荷在0–55字节之间时，应用以下编码规则。</em>T45】</strong></p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="f066" class="km kn ht ki b fv ko kp l kq kr">1)0xc0+length of (list)) <br/>2)Encoded string<br/>Join 1,2</span></pre><p id="53e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">用<strong class="is hu"> ["狗"、"老鼠"、"老虎"，127] </strong>给定一个输入给RLP编码</p><p id="4537" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们需要首先对列表中的有效载荷进行编码。</p><ul class=""><li id="11a4" class="kw kx ht is b it iu ix iy jb ky jf kz jj la jn lb lc ld le dt translated">“狗”:<strong class="is hu"> 0x83 </strong>，0x64，0x6F，0x67</li><li id="9c76" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn lb lc ld le dt translated">“鼠标”:<strong class="is hu"> 0x85 </strong>，0x6D，0x6F，0x75，0x73，0x65</li><li id="3c25" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn lb lc ld le dt translated">“老虎”:<strong class="is hu"> 0x86 </strong>，0x74，0x69，0x67，0x65，0x72，0x73</li><li id="8dca" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn lb lc ld le dt translated">127 : 0x7F</li></ul><p id="31cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，带有编码负载的列表如下所示:</p><p id="10c4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh kt ku kv ki b">[ <strong class="is hu">0x83</strong> 0x64 0x6F 0x67 <strong class="is hu">0x85</strong> 0x6D 0x6F 0x75 0x73 0x65 <strong class="is hu">0x86</strong> 0x74 0x69 0x67 0x65 0x72 0x73 <strong class="is hu">0x7F </strong>] and the length of the list is 18(12 in hex)</code></p><p id="ef3c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以这条规则的最终输出是:</p><ol class=""><li id="8cc7" class="kw kx ht is b it iu ix iy jb ky jf kz jj la jn mm lc ld le dt translated">0xc0+12 : <strong class="is hu"> 0xd2 </strong></li><li id="06e1" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn mm lc ld le dt translated"><code class="eh kt ku kv ki b">[<strong class="is hu"> 0x83</strong> 0x64 0x6F 0x67 <strong class="is hu">0x85</strong> 0x6D 0x6F 0x75 0x73 0x65 <strong class="is hu">0x86</strong> 0x74 0x69 0x67 0x65 0x72 0x73 <strong class="is hu">0x7F </strong>]</code></li><li id="523a" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn mm lc ld le dt translated">1和2的并集</li><li id="4dc7" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn mm lc ld le dt translated">最终输出:<strong class="is hu">0x D2</strong>T6】0x 830x 64 0x6F 0x 67<strong class="is hu">0x 85</strong>0x6D 0x6F 0x 75 0x 73 0x 65<strong class="is hu">0x 86</strong>0x 74 0x 69 0x 67 0x 65 0x 72 0x 73<strong class="is hu">0x7F</strong></li></ol><p id="1ddb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="jp">规则5:当对一个列表进行编码，并且列表中的编码净荷大于55字节时，应用以下编码规则。</em> </strong></p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="056b" class="km kn ht ki b fv ko kp l kq kr">1)0xf7+length_in_bytes(item 2)<br/>2)length(payload)<br/>3)Encoded payload<br/>Join 1,2,3</span></pre><p id="5f20" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我会让你做剩下的事情，非常类似于上面的规则。</p><p id="ede6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">最后一点注意事项</strong></p><ul class=""><li id="8b52" class="kw kx ht is b it iu ix iy jb ky jf kz jj la jn lb lc ld le dt translated">RLP以<a class="ae jo" href="https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/" rel="noopener ugc nofollow" target="_blank"> Big Endian格式、</a>对正整数进行编码，并丢弃前导零，整数值零与空字节数组相同。</li><li id="ebf6" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn lb lc ld le dt translated">空列表、字符串和整数0都有特定的常量</li></ul><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="714a" class="km kn ht ki b fv ko kp l kq kr">1) Empty List   <strong class="ki hu">[]</strong> encoded to <strong class="ki hu">0xC0</strong><br/>2) Empty String <strong class="ki hu">""</strong> encoded to <strong class="ki hu">0x80</strong><br/>3) Integer      <strong class="ki hu">0</strong>  encoded to <strong class="ki hu">0x80</strong></span></pre><p id="c38e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">重述重述重述</p><p id="d9e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我的建议是让这个消化一下，再回到文章上来。我也不能100%确定一些更好的细节，但我确实从stack-exchange的好人们那里获得了一些关于设计决策的有用观点和一些奇妙的帮助。</p><p id="6a61" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们回顾一下:</p><ul class=""><li id="895c" class="kw kx ht is b it iu ix iy jb ky jf kz jj la jn lb lc ld le dt translated">RLP是对一个项目或项目列表进行编码的一组规则。</li><li id="6173" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn lb lc ld le dt translated">RLP根据有效载荷的大小有一套不同的规则。</li><li id="7d19" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn lb lc ld le dt translated">字符串是一个字节数组。</li><li id="12c9" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn lb lc ld le dt translated">空字符串，列表有预定义的值。</li><li id="bff1" class="kw kx ht is b it lf ix lg jb lh jf li jj lj jn lb lc ld le dt translated">使用RLP<a class="ae jo" href="https://ethereum.stackexchange.com/questions/19092/why-was-rlp-chosen-as-the-low-level-protocol-encoding-algorithm" rel="noopener ugc nofollow" target="_blank">是因为</a>它能够压缩数据并且简单。</li></ul><p id="80e1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">提示:试着阅读关于以太坊团队为什么选择RLP的设计决策的</em> <a class="ae jo" href="https://github.com/ethereum/wiki/wiki/Design-Rationale" rel="noopener ugc nofollow" target="_blank"> <em class="jp">理由</em> </a> <em class="jp">。RLP有多种实现方式。我建议浏览一下。我确实参考了</em> <a class="ae jo" href="https://elixir-lang.org/" rel="noopener ugc nofollow" target="_blank"> <em class="jp">仙丹</em> </a> <em class="jp">和红宝石中的实现。</em></p><p id="58dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">也有其他伟大的媒体职位对RLP，我完全提到去，并将继续这样做，为未来的参考。在来自<a class="ae jo" href="https://medium.com/u/555875ec10a0?source=post_page-----933411deebe1--------------------------------" rel="noopener"> girishramnani </a>的代码片段的帮助下，查看我的<a class="ae jo" href="https://github.com/deepakraous/elixir_rlp" rel="noopener ugc nofollow" target="_blank">实现</a>，非常感谢<a class="ae jo" href="http://twitter.com/kvkalidindi" rel="noopener ugc nofollow" target="_blank">@ kvkalidi</a>的校对和宝贵意见。</p><p id="b8a6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在下一篇文章中，<a class="ae jo" rel="noopener" href="/coinmonks/ethereum-under-the-hood-part-3-rlp-decoding-df236dc13e58"> <em class="jp">第3部分</em> </a> <strong class="is hu"> <em class="jp">，</em> </strong>我们将介绍<strong class="is hu"> RLP解码</strong>的一些实现参考。</p><p id="39d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">参考资料:</p><div class="mn mo fm fo mp mq"><a href="http://hidskes.com/blog/2014/04/02/ethereum-building-blocks-part-1-rlp/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hu fv z el mv eo ep mw er et hs dt translated">以太坊积木第1部分:RLP</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">在这一系列的博客文章中，我将试着写更多关于这些部分的内容，当它们结合在一起时，就构成了新的…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">hidskes.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ka mq"/></div></div></a></div><div class="mn mo fm fo mp mq"><a rel="noopener follow" target="_blank" href="/@phansnt/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hu fv z el mv eo ep mw er et hs dt translated">以太坊中的数据结构。第1集:递归长度前缀(RLP)编码/解码。</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">有很多论文、博客解释以太坊是如何组织数据的，但它们似乎都太…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">medium.com</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne ka mq"/></div></div></a></div><div class="mn mo fm fo mp mq"><a href="https://easythereentropy.wordpress.com/2014/06/04/understanding-the-ethereum-trie/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab ej"><div class="ms ab mt cl cj mu"><h2 class="bd hu fv z el mv eo ep mw er et hs dt translated">了解以太坊trie</h2><div class="mx l"><h3 class="bd b fv z el mv eo ep mw er et ek translated">前几天，我终于开始阅读整个以太坊黄皮书，并弄清楚如何修改…</h3></div><div class="my l"><p class="bd b gc z el mv eo ep mw er et ek translated">easythereentropy.wordpress.com</p></div></div></div></a></div></div></div>    
</body>
</html>