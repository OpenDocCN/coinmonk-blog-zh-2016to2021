<html>
<head>
<title>Building A Simple Blockchain Data Structure With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建简单的区块链数据结构</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/building-a-simple-blockchain-data-structure-with-python-e7ebd448647a?source=collection_archive---------0-----------------------#2018-04-17">https://medium.com/coinmonks/building-a-simple-blockchain-data-structure-with-python-e7ebd448647a?source=collection_archive---------0-----------------------#2018-04-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/96cfe938c8f4a85b528f88ff03d56dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-4Rd4Ns-7eApL_aTGxFkdw.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by Mateusz Dach from Pexels</figcaption></figure><p id="b946" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在这里，我将建立一个简单的区块链数据结构，这是比特币的基础。这种数据结构甚至不足以构建简单的加密货币。但是我们必须从某个地方开始。</p><p id="d468" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在构建区块链数据结构之前，我必须解释一下散列法。比特币使用SHA-256。以下是如何用Python实现这一点:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="f414" class="km kn ht ki b fv ko kp l kq kr">&gt;&gt;&gt; import hashlib<br/>&gt;&gt;&gt; hashlib.sha256(b”hello world”).hexdigest()<br/>‘b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9’</span></pre><p id="d6e3" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这就是你在Python中如何做散列(SHA-256)。但是实际上哈希是什么呢？256在SHA-256到底意味着什么？</p><p id="3cd1" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">散列是一个将任何东西(只要你能把它表示成一个字符串)转换成一个固定的256位字符串的过程。在前面的示例中，字符串“hello world”的长度为11。事实上，“你好世界”的长度取决于你如何计算它。但为了简单起见，我们只统计有多少个字符。那个“hello world”字符串变成了固定大小的字符串，就是‘b 94d 27 b 9934d 3 e 08 a 52 e 52d 7 da 7 dab fac 484 EFE 37 a 5380 ee 9088 f 7 ace 2 EFC de 9’。假设我散列另一个不同长度的字符串。</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="7db5" class="km kn ht ki b fv ko kp l kq kr">&gt;&gt;&gt; import hashlib<br/>&gt;&gt;&gt; hashlib.sha256(b”I am the best president. Ever.”).hexdigest()<br/>‘fba0e4cc233f9df81278130ed748a31a842bce8f911766b661f8a4f7ddff5341’</span></pre><p id="a454" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">那串“我是最好的总统。永远不会。”与“hello world”的长度不同。但是输出具有相同的长度，大约64个字符。所以任何输入都会变成64个随机字符串。即使是一个23公里长的字符串也会变成一个64个随机字符的字符串。</p><p id="42a4" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这是一个十六进制字符串。这就是为什么它有64个字符。如果你把它转换成一个位串，它将有256个字符长。</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="7640" class="km kn ht ki b fv ko kp l kq kr">&gt;&gt;&gt; bin(0xb94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9)<br/>‘0b1011100101001101001001111011100110010011010011010011111000001000101001010010111001010010110101111101101001111101101010111111101011000100100001001110111111100011011110100101001110000000111011101001000010001000111101111010110011100010111011111100110111101001’</span></pre><p id="3be4" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这就是它被称为SHA-256的原因。</p><p id="968d" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">现在，哈希的一些特性对比特币非常重要。第一种叫做无碰撞。我的意思是，如果你要把任何东西变成一个固定的256位字符串，肯定会有不止一个输入有相同的输出。可能输入的大小大于可能输出的大小。是的，没错。但是找到x和y其中x不同于y并且hash(x)等于hash(y)是极其困难的(在SHA-256的情况下；一些聪明人在SHA-1发现了碰撞)。</p><p id="7c78" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">所以输入和输出之间没有明显的关系。即使你改变了输入的一点点，输出也会完全不同。这是第二个属性。</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="6cff" class="km kn ht ki b fv ko kp l kq kr">&gt;&gt;&gt; hashlib.sha256(b”1").hexdigest()<br/>‘6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b’<br/>&gt;&gt;&gt; hashlib.sha256(b”2").hexdigest()<br/>‘d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35’<br/>&gt;&gt;&gt; hashlib.sha256(b”3").hexdigest()<br/>‘4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce’<br/>&gt;&gt;&gt; hashlib.sha256(b”11").hexdigest()<br/>‘4fc82b26aecb47d2868c4efbe3581732a3e7cbcc6c2efb32062c08170a05eeb8’</span></pre><p id="2bb8" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">因此，找到具有相同输出的不同输入的唯一方法是，需要测试不同长度的所有字符组合。“abc”，“也许是一个loooooong字符串”，“17”等。完全不切实际。</p><p id="e703" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">但是有没有可能当你散列一些东西的时候，输出已经和“hello world”的散列一样了呢？或者只是任意两个不同的字符串，但具有相同的哈希？当然有。问题是这种可能性有多小。SHA-256的输出大约有2种⁵⁶可能性。2 ⁵⁶有多大？115792089237316195423570985008687907853269984665640564039457584007913129639936.或者1.15 e+77。或者大致是10⁷⁷.如果你认为这个数字很大，但不是很大，我有一个坏消息要告诉你。在可观测的宇宙中(从你的椅子上可以从任何方向看到460亿光年的宇宙)，总原子是10⁷⁸到10⁸。<a class="ae ks" href="https://www.universetoday.com/36302/atoms-in-the-universe/" rel="noopener ugc nofollow" target="_blank">https://www.universetoday.com/36302/atoms-in-the-universe/</a></p><p id="c2c2" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我的电脑有Nvidia Geforce 1080 Ti。它有11.3万亿次浮点运算(tera = 10)。翻牌是浮动操作。哈希是整数运算。所以是苹果对橘子。但是为了简单起见，假设散列也是一种浮动操作，并且每个散列需要3000次操作。所以我的显卡每秒可以计算376666666哈希。为了找到在<a class="ae ks" href="https://en.wikipedia.org/wiki/Birthday_attack" rel="noopener ugc nofollow" target="_blank">生日攻击</a>中描述的冲突，我们只需要计算2个⁸散列。假设这个星球上的每个人都有我的图形卡，我们一起计算碰撞攻击。这需要:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="57b3" class="km kn ht ki b fv ko kp l kq kr">&gt;&gt;&gt; 2**128 / (7000000000 * 3766666666.6666665)<br/>1.2905778770705631e+19</span></pre><p id="7c79" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这个数字比宇宙的年龄还要长(大约10 ⁷秒)。【https://www.space.com/24054-how-old-is-the-universe.html T4】</p><p id="16ad" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">要描述哈希算法，是相当费工夫的。但是有一天我会解释SHA-256背后的代码。现在你可以理解哈希的浩瀚，让我们继续。区块链就像一个链表，是很多计算机专业学生都知道的数据结构。让我们创建一个块。比特币中的第一块叫创世纪块。</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="4471" class="km kn ht ki b fv ko kp l kq kr">import hashlib, json</span><span id="e299" class="km kn ht ki b fv kt kp l kq kr">block_genesis = {<br/> ‘prev_hash’: None,<br/> ‘transactions’: [1, 3, 4, 2]<br/>}</span></pre><p id="b331" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">事务代表… <em class="ku">井</em>的事务。在比特币中，会像“杰森向玛丽苏支付2 btc”，“凯洛·雷恩向尤达支付10 btc”一样。为了简单起见，我们只放普通整数。</p><p id="5afa" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们对该块进行了序列化，因此可以对其进行哈希处理。</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="c723" class="km kn ht ki b fv ko kp l kq kr">block_genesis_serialized = json.dumps(block_genesis, sort_keys=True).encode(‘utf-8’)<br/>block_genesis_hash = hashlib.sha256(block_genesis_serialized).hexdigest()</span></pre><p id="20b8" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">现在我们有了另一个街区。</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="83f1" class="km kn ht ki b fv ko kp l kq kr">block_2 = {<br/> ‘prev_hash’: block_genesis_hash,<br/> ‘transactions’: [3, 3, 3, 8, 7, 12]<br/>}</span></pre><p id="181c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们散列块2。</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="91c2" class="km kn ht ki b fv ko kp l kq kr">block_2_serialized = json.dumps(block_2, sort_keys=True).encode(‘utf-8’)<br/>block_2_hash = hashlib.sha256(block_2_serialized).hexdigest()</span></pre><p id="1756" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们建造另一个街区。</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="1d9c" class="km kn ht ki b fv ko kp l kq kr">block_3 = {<br/> ‘prev_hash’: block_2_hash,<br/> ‘transactions’: [3, 4, 4, 8, 34]<br/>}</span></pre><p id="411c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们散列块3。这将是最后一个街区，我保证。</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="e65f" class="km kn ht ki b fv ko kp l kq kr">block_3_serialized = json.dumps(block_3, sort_keys=True).encode(‘utf-8’)<br/>block_3_hash = hashlib.sha256(block_3_serialized).hexdigest()</span></pre><p id="7923" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">为了确保数据没有被篡改，我只需要检查最后一个块的哈希，而不是检查从genesis块到最后一个块的所有数据。如果不一样，就说明有人试图篡改数据。</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="605a" class="km kn ht ki b fv ko kp l kq kr">import hashlib, json</span><span id="4a49" class="km kn ht ki b fv kt kp l kq kr">block_genesis = {<br/> ‘prev_hash’: None,<br/> ‘transactions’: [1, 3, 4, 2]<br/>}</span><span id="a28a" class="km kn ht ki b fv kt kp l kq kr">block_2 = {<br/> ‘prev_hash’: None,<br/> ‘transactions’: [3, 3, 3, 8, 7, 12]<br/>}</span><span id="f4b5" class="km kn ht ki b fv kt kp l kq kr">block_3 = {<br/> ‘prev_hash’: None,<br/> ‘transactions’: [3, 4, 4, 8, 34]<br/>}</span><span id="154b" class="km kn ht ki b fv kt kp l kq kr">def hash_blocks(blocks):<br/> prev_hash = None<br/> for block in blocks:<br/>  block[‘prev_hash’] = prev_hash<br/>  block_serialized = json.dumps(block, sort_keys=True).encode(‘utf-8’)<br/>  block_hash = hashlib.sha256(block_serialized).hexdigest()<br/>  prev_hash = block_hash</span><span id="19ba" class="km kn ht ki b fv kt kp l kq kr"> return prev_hash</span><span id="0798" class="km kn ht ki b fv kt kp l kq kr">print(“Original hash”)<br/>print(hash_blocks([block_genesis, block_2, block_3]))</span><span id="f595" class="km kn ht ki b fv kt kp l kq kr">print(“Tampering the data”)<br/>block_genesis[‘transactions’][0] = 3</span><span id="893a" class="km kn ht ki b fv kt kp l kq kr">print(“After being tampered”)<br/>print(hash_blocks([block_genesis, block_2, block_3]))</span></pre><p id="e071" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">结果是:</p><pre class="kd ke kf kg fq kh ki kj kk aw kl dt"><span id="c81c" class="km kn ht ki b fv ko kp l kq kr">Original hash<br/>45eda4f7a76bf0f92a0acda2ce4752dfbe167473376f766f22d7ec68501cac40<br/>Tampering the data<br/>After being tampered<br/>27d68dae05428be6aa244869196a481f431fca6645dd33c3df7a740afa03b7d9</span></pre><p id="6a31" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这是区块链的基本。但这还不够。如何决定下一个要添加的块？你需要共识和工作证明。那么区块链中的区块结构就复杂多了。我们将在下一篇文章中讨论这个问题。</p><blockquote class="kv"><p id="bfc7" class="kw kx ht bd ky kz la lb lc ld le kc ek translated">加入Coinmonks <a class="ae ks" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ks" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae ks" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="km kn ht bd lf lg lh li lj lk ll lm ln jq lo lp lq ju lr ls lt jy lu lv lw lx dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="ly lz ht jh b ji ma jm mb jq mc ju md jy me kc mf mg mh mi dt translated"><a class="ae ks" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae ks" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="14e6" class="ly lz ht jh b ji mj jm mk jq ml ju mm jy mn kc mf mg mh mi dt translated"><a class="ae ks" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae ks" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="ly lz ht jh b ji mj jm mk jq ml ju mm jy mn kc mf mg mh mi dt translated"><a class="ae ks" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae ks" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="f33b" class="ly lz ht jh b ji mj jm mk jq ml ju mm jy mn kc mf mg mh mi dt translated"><a class="ae ks" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae ks" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="ly lz ht jh b ji mj jm mk jq ml ju mm jy mn kc mf mg mh mi dt translated">开发人员的最佳加密API</li><li id="b359" class="ly lz ht jh b ji mj jm mk jq ml ju mm jy mn kc mf mg mh mi dt translated">最佳<a class="ae ks" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="ly lz ht jh b ji mj jm mk jq ml ju mm jy mn kc mf mg mh mi dt translated">杠杆代币的终极指南</li><li id="95d1" class="ly lz ht jh b ji mj jm mk jq ml ju mm jy mn kc mf mg mh mi dt translated"><a class="ae ks" href="https://coincodecap.com/bookmap-review-2021-best-trading-software" rel="noopener ugc nofollow" target="_blank"> Bookmap评论</a> | <a class="ae ks" href="https://coincodecap.com/crypto-exchange-usa" rel="noopener ugc nofollow" target="_blank">美国5大最佳加密交易所</a></li><li id="f5bb" class="ly lz ht jh b ji mj jm mk jq ml ju mm jy mn kc mf mg mh mi dt translated"><a class="ae ks" href="https://coincodecap.com/ftx-futures-trading" rel="noopener ugc nofollow" target="_blank">如何在FTX交易所交易期货</a> | <a class="ae ks" href="https://coincodecap.com/okex-vs-binance" rel="noopener ugc nofollow" target="_blank"> OKEx vs币安</a></li><li id="719e" class="ly lz ht jh b ji mj jm mk jq ml ju mm jy mn kc mf mg mh mi dt translated"><a class="ae ks" href="https://coincodecap.com/coinloan-review" rel="noopener ugc nofollow" target="_blank"> CoinLoan审查</a> | <a class="ae ks" rel="noopener" href="/coinmonks/youhodler-4-easy-ways-to-make-money-98969b9689f2"> YouHodler审查</a> | <a class="ae ks" href="https://coincodecap.com/blockfi-review" rel="noopener ugc nofollow" target="_blank"> BlockFi审查</a></li><li id="4ec1" class="ly lz ht jh b ji mj jm mk jq ml ju mm jy mn kc mf mg mh mi dt translated">XT.COM评论 | <a class="ae ks" href="https://coincodecap.com/xt-com-review" rel="noopener ugc nofollow" target="_blank">币安评论</a></li></ul></div></div>    
</body>
</html>