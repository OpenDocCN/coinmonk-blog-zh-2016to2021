<html>
<head>
<title>Beginner’s guide to feeding data in Tensorflow — Part2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tensorflow中馈送数据的初学者指南—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/beginners-guide-to-feeding-data-in-tensorflow-part2-5e2506d75429?source=collection_archive---------0-----------------------#2018-06-24">https://medium.com/coinmonks/beginners-guide-to-feeding-data-in-tensorflow-part2-5e2506d75429?source=collection_archive---------0-----------------------#2018-06-24</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/ba0cc340af42e7e6289f59f7e644e9f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*1RRz25yFDh8C1gSToxm6JA.jpeg"/></div></figure><p id="e978" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">嗨，这是本系列的第二部分。在这篇文章中，我将展示如何将TFRecord数据格式和原始图像输入到tensorflow模型中。TFRecords格式的各种优势是—</p><ol class=""><li id="a830" class="jv jw ht iz b ja jb je jf ji jx jm jy jq jz ju ka kb kc kd dt translated">读取速度比PNG或其他格式更快。</li><li id="1a85" class="jv jw ht iz b ja ke je kf ji kg jm kh jq ki ju ka kb kc kd dt translated">为您提供数据管道的灵活性。</li><li id="cb89" class="jv jw ht iz b ja ke je kf ji kg jm kh jq ki ju ka kb kc kd dt translated">当数据不适合内存时很有用。</li><li id="457a" class="jv jw ht iz b ja ke je kf ji kg jm kh jq ki ju ka kb kc kd dt translated">减少要管理的文件数量。(个人观点)</li></ol><p id="fa54" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">part-1的链接在这里是<a class="ae kj" rel="noopener" href="/@16vikas96/beginners-guide-to-feeding-data-in-tensorflow-faf21a745e4c"/>，转换成tfrecords的代码的链接在这里是<a class="ae kj" href="https://gist.github.com/shang-vikas/509cc87d4b37694308f717b1cbb3585a" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ea12" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">使用的数据集— </strong> MNIST</p><p id="f09e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">模型架构</strong> —两个各100个神经元的隐藏层和一个10个神经元的输出层。</p><p id="2418" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我假设您有TFRecords格式的数据。让我们开始吧。</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="82f6" class="kt ku ht kp b fv kv kw l kx ky">## import necessary stuff<br/>import tensorflow as tf<br/>import numpy as np<br/>import os,sys<br/>import time</span><span id="0f7e" class="kt ku ht kp b fv kz kw l kx ky">## defining the type of features columns to be used on model.<br/>feature_column = [tf.feature_column.numeric_column(key='image',shape=(784,))]</span><span id="c978" class="kt ku ht kp b fv kz kw l kx ky">##defining the model<br/>model = tf.estimator.DNNClassifier([100,100],n_classes=10,feature_columns=feature_column)</span></pre><p id="7994" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在我们已经创建了模型，让我们定义数据流。我们将使用数据集API中的<strong class="iz hu"> TFRecordDataset </strong>方法。</p><p id="37e5" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">首先，我们需要定义一个函数，将TFRecords格式转换回dtype的张量tf.float32(对于image)和tf.int32(对于label)。</p><p id="d6d9" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">转换会是这样的-</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="b877" class="kt ku ht kp b fv kv kw l kx ky"><strong class="kp hu">TFRecords --&gt; Serialized Example --&gt; Example --&gt; Tensor</strong></span></pre><p id="80fa" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这是函数—</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="da25" class="kt ku ht kp b fv kv kw l kx ky">def _parse_(serialized_example):<br/>    feature = {'image_raw':tf.FixedLenFeature([],tf.string),<br/>                'label':tf.FixedLenFeature([],tf.int64)}<br/>    example = tf.parse_single_example(serialized_example,feature)<br/>    image = tf.decode_raw(example['image_raw'],tf.int64) #remember to parse in int64. float will raise error<br/>    label = tf.cast(example['label'],tf.int32)<br/>    return (dict({'image':image}),label)</span></pre><p id="4318" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在上面的代码中，我们从序列化的例子中解析单个例子。为了解析一个例子或者简单地说一个数据点，我们需要提供特性的名称和它们对应的类型作为一个字典，连同序列化的例子一起提供给parse_single_example。我用' image_raw '键存储图像，用' label '键存储标签，数据类型分别为tf.string和tf.int64，所以我在字典中传递了相同的值。如果你不记得功能的名称，有一个技巧可以找出名称。在Linux里做<code class="eh la lb lc kp b">head -n20 /path/to/tfrecords</code>就行了。这将以可读的格式打印特征的名称。</p><p id="4fbb" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在我们知道了如何解析tfrecords，让我们编写使用this _parse_ function的函数，并返回要提供给模型的(features，label)批次。</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="00c4" class="kt ku ht kp b fv kv kw l kx ky">mnist_tfrecord_path = os.path.abspath('./mnist_train.tfrecords')</span><span id="16e6" class="kt ku ht kp b fv kz kw l kx ky">def tfrecord_train_input_fn(batch_size=32):<br/>    tfrecord_dataset = tf.data.TFRecordDataset(mnist_tfrecord_path)<br/>    tfrecord_dataset = tfrecord_dataset.map(lambda   x:_parse_(x)).shuffle(True).batch(batch_size)<br/>    tfrecord_iterator = tfrecord_dataset.make_one_shot_iterator()<br/>    <br/>    return tfrecord_iterator.get_next()</span></pre><p id="4fcb" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在我们已经创建了数据输入管道函数，让我们尝试训练模型。</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="f99c" class="kt ku ht kp b fv kv kw l kx ky">model.train(lambda:tfrecord_train_input_fn(32),steps=200)</span></pre><figure class="kk kl km kn fq iu fe ff paragraph-image"><div class="fe ff ld"><img src="../Images/1c6dbd84766cda9d53ae73cef0f89c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*EY5iVIPGWcc96WZFKtYw6w.png"/></div></figure><ul class=""><li id="32db" class="jv jw ht iz b ja jb je jf ji jx jm jy jq jz ju le kb kc kd dt translated"><strong class="iz hu">如果我在磁盘上有原始图像会怎样？？？</strong></li></ul><blockquote class="lf lg lh"><p id="8f6d" class="ix iy li iz b ja jb jc jd je jf jg jh lj jj jk jl lk jn jo jp ll jr js jt ju hm dt translated">在磁盘上将numpy数组写成jpg格式的代码在这里是<a class="ae kj" href="https://gist.github.com/shang-vikas/3670a06f0e4bfc1a52f4847ac3d31c78" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="ec64" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">上面的代码将以“image[i]_[class]的格式写入图像。其中class是图像的标签，I是计数。总图像是60k。现在，为了读取图像并对其进行预处理，我们需要再次编写一个解析函数来读取图像，分割标签，将标签转换为tf.int32的标量，将图像转换为tf.float并返回一个元组。</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="a66f" class="kt ku ht kp b fv kv kw l kx ky">path = os.path.abspath('./digit-recognizer/train/')</span><span id="44c0" class="kt ku ht kp b fv kz kw l kx ky">def _ondisk_parse_(filename):<br/>    filename = tf.cast([filename],tf.string)<br/>    <br/>    label = tf.string_split([tf.string_split(filename,'_').values[1]],'.').values[0]<br/>    label = tf.string_to_number([label],tf.int32)<br/>    <br/>    path = os.path.abspath('./digit-recognizer/train//')<br/>    path = tf.cast([path],tf.string)<br/>    <br/>    final_path = tf.string_join((path,tf.cast(['/'],tf.string),filename))<br/>    <br/>    image_string = tf.read_file(final_path[0])<br/>    image = tf.image.decode_jpeg(image_string)<br/>    image = tf.cast(image,tf.int8)<br/>    image = tf.cast(image,tf.float32)<br/>    image_reshaped = tf.reshape(image,(784,))<br/>    return (dict({'image':image}),label)</span></pre><p id="0250" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这里，我使用了tensorflow的原生string_split、string_to_number等。方法，因为它是tensorflow作者推荐的，否则我不得不包装我的将使用python方法的函数。分裂，串()等)在一个由张量流给定的包装上，我没有心情这样做。这里，记住将图像转换回int8，因为在保存图像时，格式是int8。直接将int8转换为其他格式会导致错误。</p><p id="f19d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在_ondisk_parse已经准备好了，让我们编写最终的训练输入函数。</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="d7af" class="kt ku ht kp b fv kv kw l kx ky">def ondisk_train_input_fn(filenames,batch_size=32):<br/>    dataset  = tf.data.Dataset.from_tensor_slices(filenames)<br/>    dataset = dataset.map(lambda x:_ondisk_parse_(x)).shuffle(True).batch(batch_size)<br/>    ondisk_iterator = dataset.make_one_shot_iterator()<br/>    <br/>    return ondisk_iterator.get_next()</span></pre><p id="5f9c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在这里，我再次使用了_from_tensor_slices方法，因为您可以传递内存中的数据(张量或numpy数组)或需要提供给该方法的图像的文件名。管道的其余部分与映射_ondisk_parse_ first相同，然后改组、创建批处理、生成one_shot_iterator并返回下一个批处理。</p><p id="8eb4" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">最后，训练部分—</p><pre class="kk kl km kn fq ko kp kq kr aw ks dt"><span id="52ec" class="kt ku ht kp b fv kv kw l kx ky">#list of the images in train folder<br/>f = !ls ./digit-recognizer/train/ <br/>#train the model<br/>model.train(lambda:ondisk_train_input_fn(f,32),steps=200)</span></pre><figure class="kk kl km kn fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lm"><img src="../Images/72e12485135d368e47407a132bda1b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_JrSwDNug_iGfMxIDQAL8Q.png"/></div></div></figure></div><div class="ab cl lr ls hb lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hm hn ho hp hq"><p id="3bb0" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">结束</strong></p><blockquote class="lf lg lh"><p id="d395" class="ix iy li iz b ja jb jc jd je jf jg jh lj jj jk jl lk jn jo jp ll jr js jt ju hm dt translated">完整的代码可以在<a class="ae kj" href="https://gist.github.com/shang-vikas/f25e13bfa5425258eb47c91d8739536b" rel="noopener ugc nofollow" target="_blank">这里找到。</a></p></blockquote><p id="2dac" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">如果你喜欢这篇文章，给点掌声。</p><blockquote class="ly"><p id="0d48" class="lz ma ht bd mb mc md me mf mg mh ju ek translated">加入Coinmonks <a class="ae kj" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae kj" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae kj" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="kt ku ht bd mi mj mk ml mm mn mo mp mq ji mr ms mt jm mu mv mw jq mx my mz na dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="jv jw ht iz b ja nb je nc ji nd jm ne jq nf ju le kb kc kd dt translated"><a class="ae kj" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae kj" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="jv jw ht iz b ja ke je kf ji kg jm kh jq ki ju le kb kc kd dt translated"><a class="ae kj" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae kj" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="jv jw ht iz b ja ke je kf ji kg jm kh jq ki ju le kb kc kd dt translated"><a class="ae kj" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae kj" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="jv jw ht iz b ja ke je kf ji kg jm kh jq ki ju le kb kc kd dt translated"><a class="ae kj" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae kj" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="jv jw ht iz b ja ke je kf ji kg jm kh jq ki ju le kb kc kd dt translated">开发人员的最佳加密API</li><li id="b359" class="jv jw ht iz b ja ke je kf ji kg jm kh jq ki ju le kb kc kd dt translated">最佳<a class="ae kj" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="jv jw ht iz b ja ke je kf ji kg jm kh jq ki ju le kb kc kd dt translated"><a class="ae kj" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li></ul></div></div>    
</body>
</html>