<html>
<head>
<title>Math in Solidity (Part 4: Compound Interest)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实的数学(第四部分:复利)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/math-in-solidity-part-4-compound-interest-512d9e13041b?source=collection_archive---------1-----------------------#2020-03-10">https://medium.com/coinmonks/math-in-solidity-part-4-compound-interest-512d9e13041b?source=collection_archive---------1-----------------------#2020-03-10</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="8329" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">本文是关于扎实做数学系列文章的第四篇。这次的题目是:<strong class="ak">复利</strong>。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/0de65433c959848b64ed9b1a5f5a73b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90QwWSiCwOwV3QSIR2EE1Q.jpeg"/></div></div></figure><h1 id="b061" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">介绍</h1><p id="e211" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">在我们的<a class="ae li" rel="noopener" href="/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1">上一篇文章</a>中，我们讨论了百分比以及它们是如何在可靠性中计算的。在金融数学中，百分比通常与贷款和存款的利息有关。在每个时期结束时，比如一个月或一年，一定百分比的本金支付给贷方或存款人。这种模式称为单利，每期支付的百分比称为定期利率。</p><p id="eae3" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">在计算机程序中，用利率代替利率是很常见的。例如，对于3%的利率，该比率为0.03。因此，一段时期的利息支付额可以计算为利息率乘以本金金额，从上一篇文章中我们已经知道如何有效而精确地完成这一操作。</p><p id="1e66" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">简单的利息模式很简单，但是如果利息不是立即支付给贷方或存款人，而是添加到本金中，事情就会变得复杂。在这种情况下，过去期间累积的利息会影响将来收取的利息金额。</p><p id="356d" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">在本文中，我们将讨论如何在Solidity中实现这种模式，这种模式的名称是:<strong class="ko hu">复利</strong>。</p><h1 id="12a6" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">周期性复利</h1><p id="c130" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">我们已经知道如何计算单利。计算复利的直接方法是在每个时间段结束时计算单利，然后将计算出的利息与本金相加。在高级语言中，比如JavaScript，它看起来像这样:</p><pre class="jj jk jl jm fq lo lp lq lr aw ls dt"><span id="b7ca" class="lt jv ht lp b fv lu lv l lw lx">principal += ratio * principal; // Do after each time period</span></pre><p id="4968" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">这里<code class="eh ly lz ma lp b">ratio</code>几乎肯定是分数，但是Solidity不支持分数，所以在Solidity中我们应该这样写:</p><pre class="jj jk jl jm fq lo lp lq lr aw ls dt"><span id="21c2" class="lt jv ht lp b fv lu lv l lw lx">principal += mulDiv (ratio, principal, 10^18);</span></pre><p id="9889" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">我们使用上一篇文章中的<code class="eh ly lz ma lp b">mulDiv</code>函数，并假设<code class="eh ly lz ma lp b">ratio</code>是一个小数点后有18位小数的定点数。</p><p id="8603" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">上面的代码在大多数情况下都能工作，但是它的<code class="eh ly lz ma lp b">+=</code>操作可能会溢出，所以为了保证代码的安全，我们需要像这样修改它:</p><pre class="jj jk jl jm fq lo lp lq lr aw ls dt"><span id="dced" class="lt jv ht lp b fv lu lv l lw lx">principal = add (principal, mulDiv (ratio, principal, 10^18));</span></pre><p id="2d63" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">这种变体对于生产来说可能是好的，但是难以阅读。在本文中，为了简单起见，我们将使用简单的算术运算，就好像坚固性将支持分数，并且算术运算不会溢出。在实际代码中，这些操作应该用适当的函数来代替。</p><p id="7d79" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">一旦我们知道如何计算单个周期的复利，问题就是:</p><h2 id="d479" class="lt jv ht bd jw mb mc md ka me mf mg ke kv mh mi kg kz mj mk ki ld ml mm kk mn dt translated">我们如何在每个时间段结束时触发复利？</h2><blockquote class="mo mp mq"><p id="05b6" class="km kn mr ko b kp lj iu kr ks lk ix ku ms ll kx ky mt lm lb lc mu ln lf lg lh hm dt translated">剧透:我们不应该</p></blockquote><p id="fbd3" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">与传统应用程序不同，智能合约不能有任何后台活动。契约的字节码仅在事务调用契约时执行，无论是直接调用还是通过另一个智能契约调用。人们可以依靠第三方服务，如<a class="ae li" href="https://provable.xyz/" rel="noopener ugc nofollow" target="_blank"> Provable </a>(以前称为Oraclize)，定期调用特定的智能合同，或者可以经济地激励普通人这样做。</p><p id="6da9" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">这种方法可行，但有许多缺点。首先，有人要为汽油付费，所以汽油不是免费的。第二，即使没有人会在接下来的时间内获得更新的本金，利息也必须在每个周期结束时复利。第三，时间周期越短，必须执行的复合越频繁，因此消耗的气体越多。第四，对于短时间周期，这种方法是不准确的，因为事务挖掘时间是不可预测的，并且在高网络负载时可能相当大。</p><p id="b058" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">所以，如果在每个期末复利不是一个稳健的好主意，那么</p><h2 id="6646" class="lt jv ht bd jw mb mc md ka me mf mg ke kv mh mi kg kz mj mk ki ld ml mm kk mn dt translated">什么时候应该复利？</h2><blockquote class="mo mp mq"><p id="0cf6" class="km kn mr ko b kp lj iu kr ks lk ix ku ms ll kx ky mt lm lb lc mu ln lf lg lh hm dt translated">剧透:“懒”复利</p></blockquote><p id="e749" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">更好的方法不是在每个时间段结束时复利，而是仅在有人需要存取本金金额或债务或存款时复利，并且在此时对自上次复利以来结束的所有时间段执行复利:</p><pre class="jj jk jl jm fq lo lp lq lr aw ls dt"><span id="aadd" class="lt jv ht lp b fv lu lv l lw lx">uint currentPeriod = block.timestamp / periodLength;<br/>for (uint period = lastPeriod; period &lt; currentPeriod; period++)<br/>  principal += ratio * principal;<br/>lastPeriod = currentPeriod;</span></pre><p id="088a" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">这段代码将所有尚未复利的利息加到本金中，每次有人想要访问<code class="eh ly lz ma lp b">principal</code>时都必须执行这段代码。这种方法被称为“懒惰”复合，实际计算被推迟，直到有人真正需要他们的结果。</p><p id="019b" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">然而，上面显示的“惰性”复合的实现有一个重要的问题。实际气体消耗线性地取决于自上次执行利息复利以来经过了多少时间间隔。如果时间周期很短，或者最后一次复利是在很久以前，那么在所有过去的时间周期内复利所需的天然气量可能超过区块天然气限制，实际上使进一步复利成为不可能。所以问题是:</p><h2 id="fa2f" class="lt jv ht bd jw mb mc md ka me mf mg ke kv mh mi kg kz mj mk ki ld ml mm kk mn dt translated">如何更高效地做“懒”复利？</h2><blockquote class="mo mp mq"><p id="d448" class="km kn mr ko b kp lj iu kr ks lk ix ku ms ll kx ky mt lm lb lc mu ln lf lg lh hm dt translated">剧透:间隔加倍</p></blockquote><p id="b259" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">首先，我们注意到，单个期限的复利可以写成这样:</p><pre class="jj jk jl jm fq lo lp lq lr aw ls dt"><span id="0bcd" class="lt jv ht lp b fv lu lv l lw lx">principal *= 1 + ratio;</span></pre><p id="8950" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">对于两个时间间隔，这将是:</p><pre class="jj jk jl jm fq lo lp lq lr aw ls dt"><span id="ba3f" class="lt jv ht lp b fv lu lv l lw lx">principal *= (1 + ratio) * (1 + ratio);</span></pre><p id="9ffe" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">那么我们注意到，(1+<em class="mr">r</em>)= 1+(2<em class="mr">r</em>+<em class="mr">r</em>)，那么双时间区间的有效利率为2 <em class="mr"> r </em> + <em class="mr"> r </em>，其中<em class="mr"> r </em>为单时间区间的利率。如果我们想要复利的时间间隔的数量是偶数，我们可以通过加倍时间间隔持续时间来使时间间隔的数量减半。当时间间隔的数量为奇数时，我们可以只执行一次复合，从而使剩余的时间间隔数量为偶数。代码如下:</p><pre class="jj jk jl jm fq lo lp lq lr aw ls dt"><span id="6262" class="lt jv ht lp b fv lu lv l lw lx">function compound (uint principal, uint ratio, uint n)<br/>public pure returns (uint) {<br/>  while (n &gt; 0) {<br/>    if (n % 2 == 1) {<br/>      principal += principal * ratio;<br/>      n -= 1;<br/>    } else {<br/>      ratio = 2 * ratio + ratio * ratio;<br/>      n /= 2;<br/>    }<br/>  }</span><span id="acf6" class="lt jv ht lp b fv mv lv l lw lx">  return principal;<br/>}</span></pre><p id="a515" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">上面的代码具有对数复杂度，并且当<code class="eh ly lz ma lp b">principal</code>和<code class="eh ly lz ma lp b">ratio</code>很大时工作良好，因此<code class="eh ly lz ma lp b">principal * ratio</code>产品具有足够的有效小数以达到体面的精度。但是，如果<code class="eh ly lz ma lp b">principal</code>和<code class="eh ly lz ma lp b">ratio</code>很小，上面的代码可能会产生不准确的结果。现在的问题是:</p><h2 id="9590" class="lt jv ht bd jw mb mc md ka me mf mg ke kv mh mi kg kz mj mk ki ld ml mm kk mn dt translated">如何提高懒复合的精度？</h2><blockquote class="mo mp mq"><p id="8262" class="km kn mr ko b kp lj iu kr ks lk ix ku ms ll kx ky mt lm lb lc mu ln lf lg lh hm dt translated">剧透:平方取幂</p></blockquote><p id="8355" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">在上面显示的代码中，精度在以下代码中丢失:</p><pre class="jj jk jl jm fq lo lp lq lr aw ls dt"><span id="f53e" class="lt jv ht lp b fv lu lv l lw lx">principal += principal * ratio;</span></pre><p id="cd84" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">这是因为我们假设<code class="eh ly lz ma lp b">principal</code>是整数，所以赋值必须舍入计算值。舍入可能被执行多次，并且舍入误差增加。</p><p id="2429" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">为了解决这个问题，我们可能会注意到，对于n个时间间隔，利息可能会像这样复合:</p><pre class="jj jk jl jm fq lo lp lq lr aw ls dt"><span id="27c3" class="lt jv ht lp b fv lu lv l lw lx">principal *= (1 + ratio) ** n;</span></pre><p id="0d43" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">这段代码在Solidity支持分数的情况下是可行的，但是只要它不支持分数，我们就需要自己实现指数运算。我们使用与上一节相同的对数复杂度方法，因此代码非常相似:</p><pre class="jj jk jl jm fq lo lp lq lr aw ls dt"><span id="8dd7" class="lt jv ht lp b fv lu lv l lw lx">function pow (uint x, uint n)<br/>public pure returns (uint r) {<br/>  r = 1.0;</span><span id="eece" class="lt jv ht lp b fv mv lv l lw lx">  while (n &gt; 0) {<br/>    if (n % 2 == 1) {<br/>      r *= x;<br/>      n -= 1;<br/>    } else {<br/>      x *= x;<br/>      n /= 2;<br/>    }<br/>  }<br/>}</span><span id="2ed9" class="lt jv ht lp b fv mv lv l lw lx">function compound (uint principal, uint ratio, uint n)<br/>public pure returns (uint) {<br/>  return principal * pow (1 + ratio, n);<br/>}</span></pre><p id="20bc" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">注意表情:<code class="eh ly lz ma lp b">r = 1.0</code>。这里要记住的是，我们在这里处理分数，就好像坚实度确实支持它们，而实际上并不支持。人们将不得不用实现分数数学函数来代替所有的算术运算。例如，下面是使用<a class="ae li" href="https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.md" rel="noopener ugc nofollow" target="_blank"> ABDK Math 64.64 </a>库实现64.64位定点数算术运算的真实代码:</p><pre class="jj jk jl jm fq lo lp lq lr aw ls dt"><span id="f55b" class="lt jv ht lp b fv lu lv l lw lx">function pow (int128 x, uint n)<br/>public pure returns (int128 r) {<br/>  r = ABDKMath64x64.fromUInt (1);</span><span id="f21e" class="lt jv ht lp b fv mv lv l lw lx">  while (n &gt; 0) {<br/>    if (n % 2 == 1) {<br/>      r = ABDKMath64x64.mul (r, x);<br/>      n -= 1;<br/>    } else {<br/>      x = ABDKMath64x64.mul (x, x);<br/>      n /= 2;<br/>    }<br/>  }<br/>}</span><span id="750e" class="lt jv ht lp b fv mv lv l lw lx">function compound (uint principal, uint ratio, uint n)<br/>public pure returns (uint) {<br/>  return ABDKMath64x64.mulu (<br/>    pow (<br/>      ABDKMath64x64.add (<br/>        ABDKMath64x64.fromUInt (1), <br/>        ABDKMath64x64.divu (<br/>          ratio,<br/>          10**18)),<br/>      n),<br/>    principal);<br/>}</span></pre><p id="7970" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">实际上，这个库已经有了<code class="eh ly lz ma lp b">pow</code>函数，可以用来代替我们的实现。</p><p id="ba3e" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">上面的代码非常精确和简单，但是它只适用于离散的时间间隔。如果我们需要计算任意时间间隔的复利呢？这种模式被称为</p><h1 id="c500" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">连续复合</h1><p id="3530" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">连续复利的思想是计算任意时期的利息，而不是固定时期的利息。实现这一点的一种方法是使用分数周期数。我们已经知道如何计算n个周期的复利:</p><pre class="jj jk jl jm fq lo lp lq lr aw ls dt"><span id="9d63" class="lt jv ht lp b fv lu lv l lw lx">principal *= (1 + ratio) ** n; </span></pre><p id="71ca" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">假设时间周期为一年，我们想计算1个月的复利，即一年的1/12。那么公式应该是:</p><pre class="jj jk jl jm fq lo lp lq lr aw ls dt"><span id="a775" class="lt jv ht lp b fv lu lv l lw lx">principal *= (1 + ratio) ** (1 / 12);</span></pre><p id="1957" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">不幸的是，上面给出的实度和<code class="eh ly lz ma lp b">pow</code>函数都不支持分数指数。我们可以通过整数幂和根，或者通过固定底对数和指数来实现它们，但是</p><h2 id="5fcb" class="lt jv ht bd jw mb mc md ka me mf mg ke kv mh mi kg kz mj mk ki ld ml mm kk mn dt translated">有没有更简单的方法来进行连续复合？</h2><blockquote class="mo mp mq"><p id="64ae" class="km kn mr ko b kp lj iu kr ks lk ix ku ms ll kx ky mt lm lb lc mu ln lf lg lh hm dt translated">剧透:是:不要做</p></blockquote><p id="5e35" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">现实世界中的时间是连续的，或者至少看起来是这样。以太中的时间是离散的。它以秒为单位，用整数表示。因此，以1秒为周期的周期性复利与连续复利一样有效，因为没有人会在周期中间观察到本金值。</p><p id="791e" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">每秒复利的想法乍看起来可能很奇怪，但在<a class="ae li" href="https://blog.coincodecap.com/tag/ethereum/" rel="noopener ugc nofollow" target="_blank">以太坊</a>上，它出奇地有效。3%的年利率实际上相当于每秒0.000000093668115524%的利率，或用18位小数表示的每秒0.00000000936681155的利率。这里我们假设1年有31556952秒。</p><p id="cf12" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">使用上述函数计算1年(31556952个周期)的复利，该比率得出2.9999999895%的年利率，因此几乎有10位有效数字的精度。对于大多数应用来说已经足够了。使用128.128位定点数而不是64.64位，甚至浮点可以实现更高的精度。</p><p id="02e8" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">在我们的实验中，1年的周期性每秒复利消耗了大约90K气体。对于大多数应用程序来说，这可能是可以承受的，但一般来说还是很高的。在我们的下一篇文章中，我们将介绍提供相同精度的更便宜的方法。</p><h1 id="b41f" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">结论</h1><p id="eef6" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">复杂的分数计算，例如那些复合定期利率所需的分数计算，由于缺乏本地分数支持，在可靠性方面可能具有挑战性。</p><p id="d900" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">然而，复利仍然可以通过平方算法和模拟定点数的幂运算来有效地计算。</p><p id="ebf6" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">建议的方法足够强大，可以在1年(甚至更长)的时间跨度内复利每秒的利率。然而，这种方法很费油。</p><p id="20fd" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">在我们的下一篇文章中，我们将提出更好的方法，下一个主题将是:<a class="ae li" rel="noopener" href="/coinmonks/math-in-solidity-part-5-exponent-and-logarithm-9aef8515136e"> <strong class="ko hu">指数和对数</strong> </a>。</p></div><div class="ab cl mw mx hb my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hm hn ho hp hq"><p id="a03b" class="pw-post-body-paragraph km kn ht ko b kp lj iu kr ks lk ix ku kv ll kx ky kz lm lb lc ld ln lf lg lh hm dt translated">本系列的其他文章:</p><ul class=""><li id="8503" class="nd ne ht ko b kp lj ks lk kv nf kz ng ld nh lh ni nj nk nl dt translated"><a class="ae li" rel="noopener" href="/coinmonks/math-in-solidity-part-1-numbers-384c8377f26d">第一部分:数字</a></li><li id="765e" class="nd ne ht ko b kp nm ks nn kv no kz np ld nq lh ni nj nk nl dt translated"><a class="ae li" rel="noopener" href="/coinmonks/math-in-solidity-part-2-overflow-3cd7283714b4">第二部分:溢出</a></li><li id="69e9" class="nd ne ht ko b kp nm ks nn kv no kz np ld nq lh ni nj nk nl dt translated"><a class="ae li" rel="noopener" href="/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1">第3部分:百分比和比例</a></li><li id="4024" class="nd ne ht ko b kp nm ks nn kv no kz np ld nq lh ni nj nk nl dt translated"><a class="ae li" rel="noopener" href="/coinmonks/math-in-solidity-part-5-exponent-and-logarithm-9aef8515136e">第五部分:指数和对数</a></li></ul><blockquote class="nr"><p id="69de" class="ns nt ht bd nu nv nw nx ny nz oa lh ek translated"><a class="ae li" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="oc od oe of og jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ob"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>