<html>
<head>
<title>Implementing Proof of Stake Part — 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实施利害关系证明第6部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/implementing-proof-of-stake-part-6-c811ce78ab0f?source=collection_archive---------0-----------------------#2019-02-10">https://medium.com/coinmonks/implementing-proof-of-stake-part-6-c811ce78ab0f?source=collection_archive---------0-----------------------#2019-02-10</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="0fe8" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">领导者、区块和ICO</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ji"><img src="../Images/67a3c3a562cf394e00d1dc1fd2774c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*X1523S70lXzN1lyg8sm7mQ.jpeg"/></div></figure><p id="44a9" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在前一篇文章中，我们创建了账户、股权模型和验证器。在本文中，我们将为我们的应用程序创建一个ICO和一个静态leader。我们还为我们的块添加了一个阈值，这将限制它的大小，并告诉我们何时应该确定下一个领导者。</p><h1 id="8919" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">交易阈值</h1><p id="44ba" class="pw-post-body-paragraph jq jr ht js b jt le iu jv jw lf ix jy jz lg kb kc kd lh kf kg kh li kj kk kl hm dt translated">在此应用中，阈值被定义为单个块中可以添加的事务数量。</p><p id="5a48" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">创建一个常量TRANSACTION_THRESHOLD，用作块的大小，并将其添加到<code class="eh lj lk ll lm b">config.js</code>文件中</p><pre class="jj jk jl jm fq ln lm lo lp aw lq dt"><span id="81f1" class="lr kn ht lm b fv ls lt l lu lv">// config.js<br/>const TRANSACTION_THRESHOLD = 5;</span><span id="0987" class="lr kn ht lm b fv lw lt l lu lv">const TRANSACTION_FEE = 1;</span><span id="9c79" class="lr kn ht lm b fv lw lt l lu lv">module.exports = {<br/>  TRANSACTION_THRESHOLD,<br/>  TRANSACTION_FEE<br/>};</span></pre><p id="e48d" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们的门槛只能达到一个地方，即p2p-server。这是我们接收新交易并将其添加到池中的地方。因此，在p2p服务器中，我们将添加一些逻辑来检查是否达到了阈值。</p><p id="33d6" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们可以编写一些代码来检查事务消息处理程序中的池长度。</p><pre class="jj jk jl jm fq ln lm lo lp aw lq dt"><span id="df42" class="lr kn ht lm b fv ls lt l lu lv">// p2p-server.js<br/>.<br/>.<br/>.</span><span id="1573" class="lr kn ht lm b fv lw lt l lu lv">case MESSAGE_TYPE.transaction:<br/> if (!this.transactionPool.transactionExists(data.transaction)) {</span><span id="5749" class="lr kn ht lm b fv lw lt l lu lv">    // check if pool is filled</span><span id="7615" class="lr kn ht lm b fv lw lt l lu lv">    let thresholdReached = this.transactionPool.addTransaction(<br/>      data.transaction<br/>    );</span><span id="c21e" class="lr kn ht lm b fv lw lt l lu lv">    this.broadcastTransaction(data.transaction);<br/>  }<br/>  break;<br/>.<br/>.<br/>.</span></pre><p id="f7dd" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">必须修改<code class="eh lj lk ll lm b">addTransaction</code>函数，以便在达到阈值时返回一个<code class="eh lj lk ll lm b">true</code>值，否则返回<code class="eh lj lk ll lm b">false</code>值。从<code class="eh lj lk ll lm b">config.js</code>文件导入常量，并在添加新事务时检查池的长度。</p><pre class="jj jk jl jm fq ln lm lo lp aw lq dt"><span id="26cf" class="lr kn ht lm b fv ls lt l lu lv">// transaction-pool.js</span><span id="2079" class="lr kn ht lm b fv lw lt l lu lv">addTransaction(transaction) {<br/>  this.transactions.push(transaction);<br/>  if (this.transactions.length &gt;= TRANSACTION_THRESHOLD) {<br/>    return true;<br/>  } else {<br/>    return false;<br/>  }<br/>}</span></pre><h1 id="08ff" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">领导者</h1><p id="aea4" class="pw-post-body-paragraph jq jr ht js b jt le iu jv jw lf ix jy jz lg kb kc kd lh kf kg kh li kj kk kl hm dt translated">下注最多硬币的验证者将成为领先者。让我们编写代码来获取给定块的领导者。</p><p id="922f" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在<code class="eh lj lk ll lm b">blockchain.js</code>文件中，我们可以添加调用stake类的<code class="eh lj lk ll lm b">getMax</code>的函数<code class="eh lj lk ll lm b">getLeader</code>。</p><pre class="jj jk jl jm fq ln lm lo lp aw lq dt"><span id="b9b6" class="lr kn ht lm b fv ls lt l lu lv">// blockchain.js</span><span id="30c1" class="lr kn ht lm b fv lw lt l lu lv">getLeader() {<br/>  return this.stakes.getMax(this.validators.list);<br/>}</span></pre><p id="8006" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><code class="eh lj lk ll lm b">getLeader</code>返回下注硬币最多的节点的地址。<code class="eh lj lk ll lm b">this.validators.list</code>是已经支付验证者费用并有资格被选为领导者的节点的地址列表。</p><p id="98da" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们将在p2p服务器中使用这个函数来检查当前节点是否是领导者。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="c084" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><em class="lz">注意:我们需要为上面的代码片段准备一个钱包。我们可以传递wallet实例，同时在</em> <code class="eh lj lk ll lm b"><em class="lz">index.js</em></code> <em class="lz">文件中创建一个p2p-server作为依赖项。</em></p><p id="d66b" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">最后，如果领导者当选，他现在可以创建一个块，并将该块广播到网络。在向网络广播之前，一个领导者在块上签名。因此，我们需要更新createBlock函数，并将钱包作为参数传递。</p><p id="a3ee" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">首先进入<code class="eh lj lk ll lm b">blockchain.js</code></p><pre class="jj jk jl jm fq ln lm lo lp aw lq dt"><span id="197b" class="lr kn ht lm b fv ls lt l lu lv">// blockchain.js</span><span id="2b68" class="lr kn ht lm b fv lw lt l lu lv">createBlock(transactions, wallet) {<br/>  const block = Block.createBlock(<br/>    this.chain[this.chain.length - 1],<br/>    transactions,<br/>    wallet<br/>  );<br/>  return block;<br/>}</span></pre><p id="c493" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">而在block.js中</p><pre class="jj jk jl jm fq ln lm lo lp aw lq dt"><span id="9cf2" class="lr kn ht lm b fv ls lt l lu lv">// block.js</span><span id="d1a1" class="lr kn ht lm b fv lw lt l lu lv">static createBlock(lastBlock, data, wallet) {<br/>  let hash;<br/>  let timestamp = Date.now();<br/>  const lastHash = lastBlock.hash;<br/>  hash = Block.hash(timestamp, lastHash, data);<br/>  <br/>  // get the validators public key<br/>  let validator = wallet.getPublicKey();<br/>  <br/>  // Sign the block<br/>  let signature = Block.signBlockHash(hash, wallet);<br/>  return new this(timestamp, lastHash, hash, data, validator, signature);<br/>}</span></pre><p id="b9ba" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在，我们可以在p2p服务器中使用它来创建块并广播它。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="ed53" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们实现<code class="eh lj lk ll lm b">broadcastBlock</code>功能。它只需要一个参数，即要广播的块和一个<code class="eh lj lk ll lm b">sendBlock</code>函数，就可以将它单独发送到每个连接的套接字，类似于我们对事务所做的。此外，我们需要为此添加一个新的<code class="eh lj lk ll lm b">MESSAGE_TYPE </code>和一个相应的消息处理程序。</p><pre class="jj jk jl jm fq ln lm lo lp aw lq dt"><span id="5dbd" class="lr kn ht lm b fv ls lt l lu lv">const MESSAGE_TYPE = {</span><span id="8c84" class="lr kn ht lm b fv lw lt l lu lv">  chain: "CHAIN",</span><span id="3ce0" class="lr kn ht lm b fv lw lt l lu lv">  block: "BLOCK",</span><span id="77fb" class="lr kn ht lm b fv lw lt l lu lv">  transaction: "TRANSACTION"</span><span id="6601" class="lr kn ht lm b fv lw lt l lu lv">};</span></pre><p id="3878" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">广播块</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="9e83" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">块的消息处理程序:<em class="lz"> ( </em> <code class="eh lj lk ll lm b"><em class="lz">isValidBlocks </em></code> <em class="lz">稍后实现)</em></p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lx ly l"/></div></figure><h1 id="0fa5" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">块的有效性</h1><p id="51f8" class="pw-post-body-paragraph jq jr ht js b jt le iu jv jw lf ix jy jz lg kb kc kd lh kf kg kh li kj kk kl hm dt translated">接收到的块可能是无效的、损坏的或旧的，因此诚实的节点应该只广播经过认证的块。要检查块的有效性，让我们在区块链类中编写一个函数，检查块是否可信，是否应该添加到链中。</p><p id="0e22" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">无效块的可能原因—</p><ol class=""><li id="2378" class="ma mb ht js b jt ju jw jx jz mc kd md kh me kl mf mg mh mi dt translated">无效哈希</li><li id="2155" class="ma mb ht js b jt mj jw mk jz ml kd mm kh mn kl mf mg mh mi dt translated">lastHash无效</li><li id="26ff" class="ma mb ht js b jt mj jw mk jz ml kd mm kh mn kl mf mg mh mi dt translated">无效的领导</li><li id="384c" class="ma mb ht js b jt mj jw mk jz ml kd mm kh mn kl mf mg mh mi dt translated">无效签名</li></ol><p id="8672" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">下面将所有情况总结成一个函数。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="99d4" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在，领导者可以创建块并广播它。当一个节点接收到一个有效的块时，它必须执行该块中的所有事务以具有最新的状态。</p><p id="580e" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">让我们为这个作业在区块链类中创建一个executeTransactions函数。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="c14d" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">对于每种类型的事务，处理方式是不同的。我还在<code class="eh lj lk ll lm b">accounts.js</code>中添加了一个<code class="eh lj lk ll lm b">transferFee </code>函数，它将费用从发送者发送给街区的领导者。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lx ly l"/></div></figure><h1 id="9d05" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">清除池</h1><p id="7ad1" class="pw-post-body-paragraph jq jr ht js b jt le iu jv jw lf ix jy jz lg kb kc kd lh kf kg kh li kj kk kl hm dt translated">执行完块后，我们必须清空池，从池中删除不需要的事务。</p><pre class="jj jk jl jm fq ln lm lo lp aw lq dt"><span id="0d21" class="lr kn ht lm b fv ls lt l lu lv">// transaction-pool.js</span><span id="1e7f" class="lr kn ht lm b fv lw lt l lu lv">clear() {</span><span id="bf46" class="lr kn ht lm b fv lw lt l lu lv">  this.transactions = [];</span><span id="4e90" class="lr kn ht lm b fv lw lt l lu lv">}</span></pre><p id="b04a" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">这个函数应该在我们添加并执行了这个块之后被调用。</p><h1 id="d920" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">图标</h1><p id="e41d" class="pw-post-body-paragraph jq jr ht js b jt le iu jv jw lf ix jy jz lg kb kc kd lh kf kg kh li kj kk kl hm dt translated">我们的应用程序几乎完成了，还有一件事要做。首次发行硬币。</p><p id="b266" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在最初的一段时间内，没有ICO或工作证明算法，赌注证明系统不能工作，直到开采出足够的硬币。</p><p id="1c63" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">可以简单地说，我们将需要一个最初的领导者，他将持有所有的硬币，并将它们转移到其他节点。最初的领导者必须硬编码到类、映射和列表中，并且应该有足够的初始平衡和赌注。</p><p id="57eb" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">为此，我们将创建一个单独的应用程序，专门负责初始硬币发行。稍后，我们可以断开该节点与网络的连接。</p><p id="71ed" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在根目录下创建一个名为<code class="eh lj lk ll lm b">ico</code>的文件夹。在这个文件夹中，创建一个文件<code class="eh lj lk ll lm b">index.js</code>。更新<code class="eh lj lk ll lm b">package.json</code>并添加运行ICO应用程序的脚本。</p><pre class="jj jk jl jm fq ln lm lo lp aw lq dt"><span id="7e75" class="lr kn ht lm b fv ls lt l lu lv">"scripts": {</span><span id="82a8" class="lr kn ht lm b fv lw lt l lu lv">"dev": "nodemon ./app",</span><span id="6900" class="lr kn ht lm b fv lw lt l lu lv">"ico": "nodemon ./ico",</span><span id="363d" class="lr kn ht lm b fv lw lt l lu lv">},</span></pre><p id="a99d" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><code class="eh lj lk ll lm b">ico/index.js</code>几乎与<code class="eh lj lk ll lm b">app/index.js</code>相似，但有一个已知的钱包。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="54e0" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">请注意，wallet实例有一个秘密“我是领导者”。我们可以很容易地找到这个秘密对应的公钥。</p><p id="cf52" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在<code class="eh lj lk ll lm b">wallet.js</code>文件所在的同一个目录中运行一个节点控制台，并为密钥创建一个wallet类的对象。使用这个对象将找到领导者的公钥。</p><pre class="jj jk jl jm fq ln lm lo lp aw lq dt"><span id="dc9d" class="lr kn ht lm b fv ls lt l lu lv">&gt; let Wallet = require('./wallet');<br/>&gt; let leader = new Wallet('i am the first leader');<br/>&gt; leader.getPublicKey();</span><span id="e28c" class="lr kn ht lm b fv lw lt l lu lv">'5aad9b5e21f63955e8840e8b954926c60e0e2d906fdbc0ce1e3afe249a67f614'</span></pre><p id="b406" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">这是领导者的公钥或地址，并且将保持不变，因为秘密是相同的。</p><p id="3992" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在我们可以将这个地址添加到我们的代码中，并给leader一个初始平衡，添加stake并使它成为一个验证器。</p><p id="a293" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">帐户. js</p><pre class="jj jk jl jm fq ln lm lo lp aw lq dt"><span id="35e6" class="lr kn ht lm b fv ls lt l lu lv">class Account {<br/>  constructor() {<br/>    this.addresses = [<br/>      "5aad9b5e21f63955e8840e8b954926c60e0e2d906fdbc0ce1e3afe249a67f614"<br/>    ];<br/>    this.balance = {<br/>      "5aad9b5e21f63955e8840e8b954926c60e0e2d906fdbc0ce1e3afe249a67f614": 1000<br/>    };<br/>  }<br/>  .<br/>  .<br/>  .<br/>  .</span></pre><p id="e58d" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">stake.js</p><pre class="jj jk jl jm fq ln lm lo lp aw lq dt"><span id="4109" class="lr kn ht lm b fv ls lt l lu lv">class Stake {<br/>  constructor() {<br/>    this.addresses = [<br/>      "5aad9b5e21f63955e8840e8b954926c60e0e2d906fdbc0ce1e3afe249a67f614"<br/>    ];<br/>    this.balance = {<br/>      "5aad9b5e21f63955e8840e8b954926c60e0e2d906fdbc0ce1e3afe249a67f614": 0<br/>    };<br/>  }<br/>  .<br/>  .<br/>  .<br/>  .</span></pre><p id="ea17" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">最初零股份就足够了，因为第一个领导者将是列表中的唯一领导者。</p><p id="2852" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">验证器. js</p><pre class="jj jk jl jm fq ln lm lo lp aw lq dt"><span id="accc" class="lr kn ht lm b fv ls lt l lu lv">class Validators {<br/>  constructor() {<br/>    this.list = [<br/>      "5aad9b5e21f63955e8840e8b954926c60e0e2d906fdbc0ce1e3afe249a67f614"<br/>    ];<br/>  }<br/>  .<br/>  .<br/>  .<br/>  .</span></pre><p id="9b71" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在第一个领导者可以向其他节点发送硬币并引导系统。</p><p id="ab0b" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">一旦节点有了足够的平衡，它们就可以成为验证器，并添加一个桩来锻造块。</p><p id="f9c9" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">运行一个ICO应用程序和其余的正常应用程序。使用ICO APIs将硬币转移到其他节点。您可以从API中获得公钥。让其他节点发送验证费和赌注一些硬币。下一个块将由新的验证器生成。</p><p id="dbbb" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">这最终完成的是股权实施的证明。我已经在<a class="ae mo" href="https://github.com/kashishkhullar/pos-blockchain" rel="noopener ugc nofollow" target="_blank"> github </a>上添加了完整的源代码供你参考。</p></div><div class="ab cl mp mq hb mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hm hn ho hp hq"><p id="b218" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><strong class="js hu">扩展:</strong></p><ol class=""><li id="d68b" class="ma mb ht js b jt ju jw jx jz mc kd md kh me kl mf mg mh mi dt translated">对于一段时间后加入网络的新节点，创建<code class="eh lj lk ll lm b">executeChain </code>函数</li><li id="23f8" class="ma mb ht js b jt mj jw mk jz ml kd mm kh mn kl mf mg mh mi dt translated">惩罚任何篡改块的欺诈节点</li><li id="2169" class="ma mb ht js b jt mj jw mk jz ml kd mm kh mn kl mf mg mh mi dt translated">创建<code class="eh lj lk ll lm b">isValidTransaction </code>函数来验证交易</li><li id="e8da" class="ma mb ht js b jt mj jw mk jz ml kd mm kh mn kl mf mg mh mi dt translated">添加连接关闭处理程序，以平稳地从网络中删除节点，而不会使应用程序崩溃。</li></ol></div><div class="ab cl mp mq hb mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hm hn ho hp hq"><p id="0ceb" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><em class="lz">感谢您阅读</em> <strong class="js hu"> <em class="lz">。我们成功地完成了我们的项目。</em> </strong> <em class="lz">希望你喜欢编码。如果你发现这很有帮助，请鼓掌。</em> </p><p id="4ed5" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">如果你对区块链、以太坊或整个世界有任何疑问，请发表评论。:)</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="http://bit.ly/2G71Sp7"><div class="fe ff mw"><img src="../Images/449450761cd76f44f9ae574333f9e9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKX2mtg7p1lOs7JmosPLsA.png"/></div></a></figure><blockquote class="mx"><p id="bf57" class="my mz ht bd na nb nc nd ne nf ng kl ek translated"><a class="ae mo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="ni nj nk nl nm jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nh"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>