<html>
<head>
<title>Technical Overview of the Chainlink Testnet Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Chainlink Testnet实施的技术概述</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/technical-overview-of-the-chainlink-testnet-implementation-c8a0b09276d1?source=collection_archive---------6-----------------------#2018-05-16">https://medium.com/coinmonks/technical-overview-of-the-chainlink-testnet-implementation-c8a0b09276d1?source=collection_archive---------6-----------------------#2018-05-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/8507a0d2cda59b4912b476f8ec999a41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oYrtbZKLTxbAgiMu.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek"><a class="ae jf" href="https://fynestuff.com/chainlink-vs-decentralized-oracles-analysis/" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="99b6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Chainlink试图通过分散式oracle将链外数据连接到链上智能合同。</p><p id="8eba" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">不久前，我对Chainlink的工作原理产生了兴趣。这是我发现的。</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><p id="da7c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Chainlink实现可以分为两个不同的部分:Chainlink节点和Chainlink智能合约。</p><p id="9852" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><a class="ae jf" href="https://github.com/smartcontractkit/chainlink/tree/master/solidity/contracts" rel="noopener ugc nofollow" target="_blank"><strong class="ji hu"/></a>:</p><p id="70ee" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Chainlink智能合约将部署在区块链上，并将被其他智能合约用来发起请求和接收链外数据。</p><p id="b7d7" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Chainlink testnet实现基于以太坊blockhain，因此，智能合约将使用Solidity <br/>编程语言。想要使用Chainlink请求链外数据的智能契约将继承【Chainlink智能契约。链式链接智能协定提供了函数、数据结构和其他链式链接智能协定的必要导入。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff kl"><img src="../Images/fef3f781840e016ccaef2cebf7d14747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F4SZCWvrTG3OnFX-_ba3mg.png"/></div></div></figure><p id="a0f5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要从API请求链外数据，发出请求的智能合约必须知道工作流的作业id(<a class="ae jf" href="https://github.com/smartcontractkit/chainlink/wiki/JobSpecs" rel="noopener ugc nofollow" target="_blank">job spec</a>),该工作流将在请求数据时被触发。每个JobSpec都有一个唯一的id。JobSpec作业id可以通过请求的智能契约构造函数传递(并在作业运行中引用)或在newRun函数中硬编码。</p><p id="064f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">想要请求数据的智能合约函数必须创建ChainlinkLib.Run. ChainlinkLib的实例。Run保存执行离线请求所需的信息—它是使用newRun函数创建的。newRun函数获取请求数据时将被触发的JobSpec的作业id、发送响应的智能契约的地址(在本例中是<strong class="ji hu"> this </strong> —当前契约的地址)，以及Chainlink节点将向其发送数据的函数签名。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff kq"><img src="../Images/edd0c42c125fb508cbbb9b11dc3b6b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09RnZOBBQWzfhn-GhKdArw.png"/></div></div></figure><p id="3856" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">发出请求的智能合约可以向运行中添加更多数据，例如要调用的API的URL、如何解析URL调用的响应等。</p><p id="eac5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">例如，URL“<a class="ae jf" href="https://min-api.cryptocompare.com/data/price?fsym=ETH&amp;tsyms=USD,EUR,JPY" rel="noopener ugc nofollow" target="_blank">https://min-api.cryptocompare.com/data/price?fsym=ETH&amp;tsyms =美元，欧元，日元</a>”返回以下JSON响应。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div class="fe ff kr"><img src="../Images/8ac11aa83ec3e3a21f861f463535f66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*EV49S1qp0bzvgQC5sR8wVg.png"/></div></figure><p id="fef5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通过将USD添加到path数组中，离线JobSpec将知道如何将JSON响应的USD部分发送回请求的智能契约。</p><p id="1920" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">ChainlinkLib。Run然后被传递给chainlinkRequest函数，其中包含合同愿意为请求支付的链接数量。<br/>因此，请求智能合约必须由链接令牌提供资金。</p><p id="136b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">chainlinkRequest函数将最终调用Oracle智能合约的requestData函数。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ks"><img src="../Images/c10bb1ca139f99f80dd51bac4aaa7294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rNZkxe4yL_M-hT8FW84_sg.png"/></div></div></figure><p id="c189" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">requestData函数将为请求分配一个惟一的id，并存储大部分的ChainlinkLib。在名为callbacks的映射中运行info，使用惟一的id作为键。然后，该函数将发出RunRequest日志，其中包含请求的惟一id、JobSpec的作业id、数据(比如要调用的URL和如何解析返回的JSON)以及一些其他必要的元数据。</p><p id="ee00" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">缺失的一环(双关语)是当前的标桩/匹配契约，它将推动oracle节点如何与请求智能契约相匹配的过程。这目前不在公开回购中。Steve在Gitter上描述了赌注/匹配合同的工作方式:</p><p id="d116" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="kt">“当节点最初存放链接到匹配的合同时，它们建立“可用存放”。可用的保证金由匹配的合同<br/>持有，但神谕可以随时提取。当oracle对SLA请求提出报价并被选中时，SLA所需的链路数量将由匹配的合同从可用保证金中移出并指定给SLA保证金。在SLA结束时，存放的未被扣分的链路以及接收到的服务链路被移回到可用存放中。”</em></p><p id="d309" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在已经有了一个对离线数据的请求，让我们检查一下当Chainlink节点启动时发生了什么，它如何能够发现来自区块链的请求，运行必要的JobSpec，并将数据返回给发出请求的智能合约。</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><p id="644c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">链环节点</strong>:</p><p id="5771" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Chainlink节点是用Golang写的。Golang拥有大多数编程语言所没有的独特特性，比如<a class="ae jf" href="https://golangbot.com/goroutines/" rel="noopener ugc nofollow" target="_blank"> Goroutines </a>和<a class="ae jf" href="https://gobyexample.com/channels" rel="noopener ugc nofollow" target="_blank"> channels </a>。<br/>如果你没有使用它们的经验，了解这两个特性是个不错的主意。</p><p id="d3d0" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Chainlink节点公开了一个<a class="ae jf" href="https://github.com/smartcontractkit/chainlink/wiki/Command-Line-Options" rel="noopener ugc nofollow" target="_blank">命令行界面</a>，允许用户启动Chainlink节点、显示所有/单个作业运行、创建作业规范、开始作业运行、备份数据库、导入密钥文件等。</p><p id="4afd" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了启动Chainlink节点，用户将在Chainlink可执行文件的名称后加上单词<strong class="ji hu"> node </strong>或<strong class="ji hu"> n. </strong>此外，在命令行上指定密码。</p><p id="314d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这个命令行调用最终调用了RunNode函数。RunNode函数的主要目标是连接到以太坊区块链，创建ChainlinkApplication对象，使用密钥库进行身份验证，调用ChainlinkApplication启动方法，并设置Chainlink REST API(允许创建JobSpecs、桥适配器等)。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ku"><img src="../Images/80a5588e8255b43c1d79582c8c666c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wkde5FFUYmXcgiQ0j9KlCQ.png"/></div></div></figure><p id="f86a" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">ChainlinkApplication对象很重要，因为它包含对控制节点工作流程的对象的引用。实例化后，chain link应用程序将保存这些引用:</p><p id="8700" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> HeadTracker </strong>“以线程安全的方式保存和存储这个特定节点经历的最新块号。”</p><p id="ce24" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">“管理来自以太坊节点的websocket的推送通知，以监听新标题和日志事件。”以太网监听器控制<a class="ae jf" href="https://github.com/smartcontractkit/chainlink/wiki/Initiators" rel="noopener ugc nofollow" target="_blank">运行日志</a>和<a class="ae jf" href="https://github.com/smartcontractkit/chainlink/wiki/Initiators" rel="noopener ugc nofollow" target="_blank">以太网日志</a>作业规范的逻辑。<br/> <br/> <strong class="ji hu">调度器</strong>控制<a class="ae jf" href="https://github.com/smartcontractkit/chainlink/wiki/Initiators" rel="noopener ugc nofollow" target="_blank"> Cron </a>和<a class="ae jf" href="https://github.com/smartcontractkit/chainlink/wiki/Initiators" rel="noopener ugc nofollow" target="_blank"> RunAt </a> JobSpecs的逻辑。</p><p id="45bb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> Store </strong>“包含数据库、配置、密钥库和TxManager的字段，用于保持应用程序状态与数据库同步。”实例化后，商店将通过连接到config.go 中的可配置<a class="ae jf" href="https://github.com/smartcontractkit/chainlink/blob/master/store/config.go" rel="noopener ugc nofollow" target="_blank">以太坊字段来建立到以太坊区块链的套接字连接。</a></p><p id="3d5f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">退出器</strong>用特定的退出代码退出链节节点。</p><p id="13b3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">密钥库认证</strong>:</p><p id="2b01" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">实例化ChainlinkApplication对象后，使用密钥库进行身份验证。一个<a class="ae jf" rel="noopener" href="/@julien.m./what-is-an-ethereum-keystore-file-86c8c5917b97">以太坊密钥库</a>是你的以太坊私钥的加密版本，可以通过输入密码来解密。一旦密钥库被解密，它将允许您签署交易并从您的帐户转移资金。如果在启动Chainlink节点时在命令行中指定了密码，Chainlink将检查它是否可以解锁位于文件系统上可配置目录中的所有密钥库文件。如果密码无法解锁所有密钥库文件，则Chainlink将不会启动。如果节点启动时没有提供密码，系统会提示用户输入密码。如果不存在密钥库文件，则将创建一个密钥库文件。要标记链接令牌，必须将密钥库导入到Chainlink节点中。</p><p id="3e41" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">chain link应用启动方式:</strong></p><p id="a378" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">身份验证完成后，将调用ChainlinkApplication Start方法—这将启动Chainlink节点。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff kv"><img src="../Images/30cedd58f18a485d346f352e70efb4dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wgjm_Q3SozuODyg4xNqnlw.png"/></div></div></figure><p id="4bc3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">该方法创建一个通道，当观察到<a class="ae jf" href="https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html" rel="noopener ugc nofollow" target="_blank"> SIGINT </a>或<a class="ae jf" href="https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html" rel="noopener ugc nofollow" target="_blank"> SIGTERM </a>系统调用时，该通道会得到通知(常见的终止信号，如按下control C或调用进程上的kill命令将触发该系统调用)。然后启动一个监听通道的Goroutine如果观察到终止信号，ChainLinkApplication将调用一个允许它正常退出的方法。</p><p id="5a3c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然后，该方法调用Store、HeadTracker和Scheduler Start方法。</p><p id="f972" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">店铺开始方式:</strong></p><p id="492c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Store Start方法将找到的第一个解锁的密钥库帐户设置为TxManager中的当前活动帐户。TxManager负责与以太坊区块链接口(发送签名交易，提高当前交易的gas数量等)。除了设置当前活动帐户之外，Store Start方法还设置<a class="ae jf" rel="noopener" href="/kinfoundation/making-sense-of-ethereum-nonce-sense-3858d5588c64">当前活动帐户nonce </a>(来自一个帐户的交易数量)。nonce是从当前活动帐户发送交易所必需的。</p><p id="88af" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">头部跟踪器启动方法:</strong></p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff kw"><img src="../Images/3317d23de0c6300c197f11f1f62f94f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8i1bHah_1Qf7UM4F4vsetA.png"/></div></div></figure><p id="028f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Headtracker订阅了以太坊区块链的新街区。当以太坊区块链上有一个新的块时，BlockHeader对象(代表以太坊区块链上的块头的数据结构)将通过管道进入一个名为headers的通道。</p><p id="26cb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Headtracker connect方法将从本地数据库中查询所有日志启动的JobSpec(RunLog和Ethlog)—对于每个job spec，将调用NewRPCLogSubscription方法。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff kx"><img src="../Images/123bb88cbb4dabf41a646d5813ebc235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njSQeFHS0WuNHVYHVhEWtg.png"/></div></div></figure><p id="6647" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">此方法将创建对新日志的订阅—新日志将通过管道传输到sub.logs通道。Goroutine listenToLogs将通过监听sub.logs通道来回填日志并处理新的日志条目。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ky"><img src="../Images/e7255c9164db5e2514c32aa868a25838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jTzxgGZIetg-oTLKrzuyHA.png"/></div></div></figure><p id="1de8" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">回填日志是Chainlink的一个重要功能，因为这意味着如果Chainlink节点关闭/退出，它将能够处理在Chainlink节点关闭时发生的日志/数据请求。“处理日志”意味着验证日志的类型是否正确——在RunLog <br/>验证中，即日志具有与Oracle.sol中发出的签名相同的签名，日志中的作业id与处理日志的RunLog实例的作业id相匹配，并且请求满足最少数量的链接。如果验证通过，作业运行将开始。</p><p id="2588" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">作业运行开始时会发生什么？</strong></p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff kz"><img src="../Images/a9cfcd0490d50ed5edfd7e60f0dfa7b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kt-NN4UfCdnSJtHhSGv4xQ.png"/></div></div></figure><p id="2978" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">可以在的<a class="ae jf" href="https://github.com/smartcontractkit/chainlink/wiki/JobSpecs" rel="noopener ugc nofollow" target="_blank">处找到工作规范示例。</a><a class="ae jf" href="https://github.com/smartcontractkit/chainlink/wiki/Job-Pipeline" rel="noopener ugc nofollow" target="_blank"> Chainlink按顺序运行JobSpec中的每个任务</a>，每次成功运行任务后保存结果。每个任务运行映射到一个特定的<a class="ae jf" href="https://github.com/smartcontractkit/chainlink/wiki/Adapters" rel="noopener ugc nofollow" target="_blank">适配器</a>的运行。Chainlink定义了保存当前TaskRun结果的RunResult数据结构。每个TaskRun的结果在RunResult的数据字段中设置，并发送给当前TaskRun。这样做是为了让当前的TaskRun可以使用上一次TaskRun运行的结果。</p><p id="9bd4" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Chainlink定义了每个任务在运行之前必须满足的最小确认数量SLA(针对日志启动的作业规范)。经过x次确认后，Chainlink可以相当确定启动作业运行的程序块是有效的(如果该程序块仍然存在)。如果运行未达到最小确认数，则运行会暂停并进入待定确认状态。</p><p id="2ddd" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">最重要的适配器之一叫做EthTx。这是负责向链上智能合约发送链外数据的适配器。在RunLog场景中，EthTx(如果在JobSpec中指定)将发送请求的唯一id(从Oracle.sol中requestData函数发出的RunRequest日志中读取——在下面的示例中为internalId ),并将数据变量的结果发送到Oracle.sol中的fulfillData函数</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff la"><img src="../Images/705015840bc3fa9138df54192c06d274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Xqk4_74hbuHjssawwsggw.png"/></div></div></figure><p id="11bc" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一旦该数据被发送到fulfillDataFunction，该函数将把请求的惟一id放入回调映射中。回调映射将返回回调数据结构，该结构包含将数据发送到正确的智能合约地址和函数所需的信息。<strong class="ji hu">从回调数据结构中获得必要的信息后，数据被发送到发出请求的智能合约！这就是满足要求的方式！</strong></p><p id="b8d1" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">陷入等待确认状态的工作是如何重新开始的？</strong></p><p id="f5ef" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">回到HeadTracker Start方法，该方法要做的最后一件事是启动一个名为listenToNewHeads的Goroutine，它将监听headers通道。Chainlink需要监听新的头，因为它需要将新的头保存到它的数据库中，以便它知道最后处理的头。<br/>如果节点关闭，然后启动，它将知道最后处理的头。此外，这个Goroutine将让Chainlink处理以前运行时不满足最低块确认SLA的所有挂起的作业运行。如果作业运行满足其最低块确认SLA，则链节节点启动另一个作业运行。</p><p id="69b5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">调度程序启动方法</strong></p><p id="1b91" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">调度程序启动方法将确保<a class="ae jf" href="https://github.com/smartcontractkit/chainlink/wiki/Initiators" rel="noopener ugc nofollow" target="_blank"> Cron </a>和<a class="ae jf" href="https://github.com/smartcontractkit/chainlink/wiki/Initiators" rel="noopener ugc nofollow" target="_blank"> RunAt </a> JobSpecs按照指定的时间表运行。</p><p id="630c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">Cron</strong>:“<code class="eh lb lc ld le b">Cron</code>启动器是一种调度重复作业运行的简单方法，它使用<a class="ae jf" href="https://en.wikipedia.org/wiki/Cron#Overview" rel="noopener ugc nofollow" target="_blank">标准Cron语法</a>和一个用于指定第二级粒度的额外字段。”</p><p id="dc30" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">RunAt</strong>:<code class="eh lb lc ld le b">RunAt</code>启动器在指定的时间触发一次性作业运行</p><p id="b4e4" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">对于Cron作业，Chainlink使用这个<a class="ae jf" href="https://github.com/mrwonko/cron" rel="noopener ugc nofollow" target="_blank">库</a>。该库的主要功能可以在AddFunc和run方法中看到。在调度程序启动方法中，首先要做的事情之一是调用Cron库启动方法，这将在一个GoRoutine中启动Cron库运行方法。</p><p id="f28d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">每个Cron JobSpec都将使用AddJob方法添加到Cron库中，这将调用Cron库AddFunc方法。AddFunc <strong class="ji hu"> </strong>方法将一个函数及其循环调度作为输入。Cron库将在每个重复的计划时间间隔调用传递给AddFunc方法的函数—在这种情况下，传递的函数调用BeginRun方法(开始新的作业运行)。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lf"><img src="../Images/23a171316a0a49b12f1ac74ad0ed39f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQQF-5f7LvDhaigulRv1BQ.png"/></div></div></figure><p id="63dd" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">AddFunc方法调用最终会将其输入(函数及其循环调度)封装在一个名为Entry的对象中。条目对象将被添加到Cron库条目集合中。在被添加到Entries集合之后，Entry对象将通过管道传递到add通道。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lg"><img src="../Images/d9789f4c4fac6bf6b4a39dff6ae73821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mMw56s8KoGmDC9cZRAGPQ.png"/></div></div></figure><p id="2bfe" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">cron添加通道在Cron run方法中使用。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lh"><img src="../Images/9cbcc229ac95f27467947ab07233384b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0lQKQFI8HqwbDb_51_zhg.png"/></div></div></figure><p id="41cf" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">run方法遍历entries集合中的所有条目，并查找每个函数的下一个预定时间。根据这些时间，run方法找到最早的预定时间(如果有)。从最早的预定时间开始，该方法将创建一个计时器对象(称为timer ),当计时器到期时，该对象将通过管道进入一个通道(称为C)。</p><p id="57d6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然后，该函数输入一个select语句，允许它在多个通道上等待。第一个通道将是下一个预定功能运行的定时器通道(如上所述)。另一个通道是我在AddFunc方法中提到的add通道(当添加一个新的cron时通过管道传输)。下一个通道是快照通道，当有人请求库中当前存在的所有条目的“快照”时，将通过管道传送该通道。最后一个通道将是关闭通道，当调度程序/Cron库被请求停止时将调用该通道。</p><p id="483d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当计时器对象通道被管道化时，其“下一次”运行时间小于当前时间的所有条目都将执行其功能。<br/>执行后，条目将被赋予一个新的下次运行时间，根据运行时间排序，select语句将再次开始监听所有通道。</p><p id="3521" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当添加通道被管道化时(从AddFunc方法),该方法将停止当前计时器(因为添加的函数可能具有比当前最早运行时间更早的运行时间)。然后，从最早的运行时创建一个新的timer对象，select语句再次开始监听所有通道。</p><p id="6512" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当存在对所有cron条目的请求时，快照通道被管道化。</p><p id="db26" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当调度程序/Cron库被请求停止时，关闭通道将被管道调用—它结束计时器对象并返回。</p><p id="3d1c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">RunAt函数与Cron作业非常相似，只是它们只运行一次。</p><figure class="km kn ko kp fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff li"><img src="../Images/bbec49f2afae5a1f17ed732d26698364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwM6K95NOgsEoJrtehPaTg.png"/></div></div></figure><p id="f636" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">对于每个RunAt JobSpec，Chainlink将启动一个新的Gorutine，它将使用select语句在两个通道上等待(就像在Cron库中一样)。当Chainlink想要正常退出时，将通过管道传输第一个通道。第二个<a class="ae jf" href="https://golang.org/pkg/time/#After" rel="noopener ugc nofollow" target="_blank">频道</a>将在RunAt JobSpec预定运行时通过管道传输。当第二个通道通过管道传输时，Chainlink将通过调用BeginRun方法执行JobSpec中格式化的运行。</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><p id="4421" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">总之，Chainlink能够通过让Chainlink节点侦听特定的以太坊日志(请求)，解析日志中的数据，运行顺序作业管道，然后将管道的结果发送到请求智能合约，来桥接链上数据请求和链外数据。</p><p id="bccb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">干杯！</p></div></div>    
</body>
</html>