<html>
<head>
<title>K vs. Coq as Language Verification Frameworks (Part 3 of 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">k与Coq作为语言验证框架(第3部分，共3部分)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/k-vs-coq-as-language-verification-frameworks-part-3-of-3-ea12e26be516?source=collection_archive---------6-----------------------#2019-12-12">https://medium.com/coinmonks/k-vs-coq-as-language-verification-frameworks-part-3-of-3-ea12e26be516?source=collection_archive---------6-----------------------#2019-12-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="ce37" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">作者:穆萨布·阿尔图基和布兰登·摩尔</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/ac5a5fa8a6721bb4c423c38f8320af20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dQerHFQ166Xns8f4.png"/></div></div></figure><p id="f06b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这是“作为语言验证框架的K与Coq”系列文章的第三部分，也是最后一部分。在说明了如何定义语言的语法结构(<a class="ae kq" rel="noopener" href="/@rv_inc/k-vs-coq-as-language-verification-frameworks-part-1-of-3-19ff603b4e91">第1部分</a>)以及如何在K和Coq中定义和测试其语义(<a class="ae kq" rel="noopener" href="/@rv_inc/k-vs-coq-as-language-verification-frameworks-part-2-of-3-a98ce2592f65">第2部分</a>)之后，我们现在描述如何实现验证工作流中的第三步，即指定和验证正确性属性。我们使用相同的工作示例SUM，并假设在前面的部分中描述了IMP和SUM的所有语言定义。</p><p id="b6e0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">回想一下，我们想要验证的正确性属性是程序SUM确实计算了从1到n的值的总和，其中n是一个非负整数。为了便于参考，我们在此再次显示了计划总和:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff kr"><img src="../Images/7edeab003726efddb9b17ad4fb32066a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*njZ1TIx4oojuPutl.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek"><em class="kw">Our working example program SUM</em></figcaption></figure><h1 id="c5a4" class="kx ky ht bd kz la lb lc ld le lf lg lh iz li ja lj jc lk jd ll jf lm jg ln lo dt translated">指定SUM的正确性</h1><p id="6d8c" class="pw-post-body-paragraph ju jv ht jw b jx lp iu jz ka lq ix kc kd lr kf kg kh ls kj kk kl lt kn ko kp hm dt translated">在验证属性之前，我们首先需要精确地指定属性声明的内容。</p><h1 id="7157" class="kx ky ht bd kz la lb lc ld le lf lg lh iz li ja lj jc lk jd ll jf lm jg ln lo dt translated">K中的属性规格</h1><p id="da9b" class="pw-post-body-paragraph ju jv ht jw b jx lp iu jz ka lq ix kc kd lr kf kg kh ls kj kk kl lt kn ko kp hm dt translated">关于用K语言定义的程序的正确性属性可以被指定为形式为<code class="eh lu lv lw lx b">p /\ c =&gt; p</code>的<a class="ae kq" href="http://fsl.cs.illinois.edu/index.php/Reachability_Logic_-_Supporting_Material" rel="noopener ugc nofollow" target="_blank">可达性逻辑</a>中的可达性规则，其中<a class="ae kq" href="http://www.matching-logic.org/index.php/Matching_Logic" rel="noopener ugc nofollow" target="_blank">中的<code class="eh lu lv lw lx b">p</code>和<code class="eh lu lv lw lx b">p'</code>模式匹配逻辑</a>和<code class="eh lu lv lw lx b">c</code>作为附带条件。直观地说，断言陈述了满足<code class="eh lu lv lw lx b">c</code>的<code class="eh lu lv lw lx b">p</code>(一种配置)的实例沿着执行的某条路径(对于单路可达性)或所有路径(对于全路可达性)到达<code class="eh lu lv lw lx b">p'</code>的实例(更精确的定义见<a class="ae kq" href="http://fsl.cs.illinois.edu/index.php/Matching_mu-Logic" rel="noopener ugc nofollow" target="_blank">本文</a>)。请注意，相同的K构造，即K规则，统一用于定义语言语义和陈述可达性属性。</p><p id="c0e0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">由于IMP是一种确定性语言(即任何IMP程序只能有一种可能的执行)，因此单向和全向可达性是一致的。</p><p id="e4c4" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">特别地，当指定<code class="eh lu lv lw lx b">SUM</code>的正确性属性作为可达性规则<code class="eh lu lv lw lx b">p /\ c =&gt; p</code>时:</p><ul class=""><li id="416b" class="ly lz ht jw b jx jy ka kb kd ma kh mb kl mc kp md me mf mg dt translated"><code class="eh lu lv lw lx b">p</code>是指定<code class="eh lu lv lw lx b">SUM</code>的初始配置的模式，其中<code class="eh lu lv lw lx b">&lt;k/&gt;</code>单元具有要执行的整个程序总和，而<code class="eh lu lv lw lx b">&lt;state/&gt;</code>单元为空。</li><li id="3f7e" class="ly lz ht jw b jx mh ka mi kd mj kh mk kl ml kp md me mf mg dt translated"><code class="eh lu lv lw lx b">p'</code>是一种指定最终配置的模式，其中<code class="eh lu lv lw lx b">&lt;k/&gt;</code>单元格为空(程序完成其执行)，而<code class="eh lu lv lw lx b">&lt;state/&gt;</code>单元格将<code class="eh lu lv lw lx b">n</code>映射为0，将<code class="eh lu lv lw lx b">sum</code>映射为值<code class="eh lu lv lw lx b">(n + 1) n / 2</code>(即<code class="eh lu lv lw lx b">sum</code>具有预期值)。</li><li id="4d98" class="ly lz ht jw b jx mh ka mi kd mj kh mk kl ml kp md me mf mg dt translated"><code class="eh lu lv lw lx b">c</code>是<code class="eh lu lv lw lx b">n</code>初始值非负的条件。</li></ul><p id="8602" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在K中，使用IMP的K模型中定义的相同语法定义和语义结构来指定可达性规则。指定正确性属性的规则如下所示(<code class="eh lu lv lw lx b">requires</code>子句指定了附带条件):</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff kr"><img src="../Images/4be893d5314d4dd7d465511bc12d0dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TXtUqak9j7f2om4C.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek"><em class="kw">The correctness property of SUM in K</em></figcaption></figure><p id="981b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">请注意，该规范是符号化的:程序变量<code class="eh lu lv lw lx b">n</code>被赋予一个符号整数值<code class="eh lu lv lw lx b">N</code>，它被规则约束为非负。该规则规定，当程序终止时(单元格是空计算)，状态将<code class="eh lu lv lw lx b">sum</code>映射到根据变量<code class="eh lu lv lw lx b">n</code>的初始值<code class="eh lu lv lw lx b">N</code>给出的符号表达式的值。</p><p id="6a13" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">虽然上面的规则定义了K中SUM的主要正确性属性，但是关于语言和/或程序的其他更具体的属性也可能需要被定义和证明为引理，然后才能开发主要属性的完整证明(这在演绎验证方法中是典型的)。</p><p id="e658" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">例如，对于SUM，还需要指定(并证明)一个<em class="mm">循环不变量</em>，它指定while循环如何在循环的每次迭代中更新程序变量。我们将在下一节中进一步阐述验证过程，但是这里要记住的一点是，所有属性都被指定为K规则，在结构上类似于上面的规则。</p><h1 id="6141" class="kx ky ht bd kz la lb lc ld le lf lg lh iz li ja lj jc lk jd ll jf lm jg ln lo dt translated">Coq中的属性规格</h1><p id="a946" class="pw-post-body-paragraph ju jv ht jw b jx lp iu jz ka lq ix kc kd lr kf kg kh ls kj kk kl lt kn ko kp hm dt translated">为了对Coq中的IMP程序执行进行推理，我们首先需要将我们想要验证的属性的语句形式化为可达性属性。遵循通过联合归纳进行<a class="ae kq" href="https://link.springer.com/chapter/10.1007/978-3-319-89884-1_21" rel="noopener ugc nofollow" target="_blank">程序验证的独立于语言的方法，我们将IMP程序属性定义为对形式为<code class="eh lu lv lw lx b">(Pgm * Env)</code>的程序状态的可达性声明。特别地，使用这里定义为</a><a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/coq/proof_system.v" rel="noopener ugc nofollow" target="_blank">的共归纳证明机制</a>，可以将<code class="eh lu lv lw lx b">SUM</code>的主要正确性属性定义为以下归纳命题(回想一下，引用的字符串<code class="eh lu lv lw lx b">"n"</code>和<code class="eh lu lv lw lx b">"sum"</code>是程序变量，而<code class="eh lu lv lw lx b">n</code>是表示符号值的通用量化逻辑名称):</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mn"><img src="../Images/e35475d67a0519d42489cbf34d0c7829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*91ufAzII2MbdKCbO.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek"><em class="kw">The correctness property of SUM in Coq</em></figcaption></figure><p id="93bf" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh lu lv lw lx b">Spec</code>是(独立于语言的)程序规范(可达性声明)的一般类型，在这里用IMP状态<code class="eh lu lv lw lx b">Spec (Pgm * Env)</code>进行实例化。该规范规定，对于所有非负值<code class="eh lu lv lw lx b">n</code>，由程序<code class="eh lu lv lw lx b">SUM</code>和空环境<code class="eh lu lv lw lx b">[]</code>组成的初始状态对达到一个状态，该状态将空程序<code class="eh lu lv lw lx b">skip</code>作为其第一组件，并且在其第二组件中有一个环境，该环境将程序变量<code class="eh lu lv lw lx b">"n"</code>映射为零，并将<code class="eh lu lv lw lx b">"sum"</code>映射到表达式<code class="eh lu lv lw lx b">((n + 1) * n)/2)</code>的值。</p><p id="69a6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">正如前面针对K所指出的，除了上面的主要正确性属性之外，可能还需要定义其他属性(在这种情况下，SUM的循环不变量)。在Coq中，这些属性通常被指定为程序状态的归纳定义命题，或者在使用这里描述的共归纳程序验证方法的情况下被实例化的<code class="eh lu lv lw lx b">Spec</code>命题。然而，与K中不同，Coq中的规范更详细，需要指定和证明其他更小的属性，例如，包括环境操纵操作的正确性属性。接下来，我们将进一步阐述验证过程。</p><h1 id="a169" class="kx ky ht bd kz la lb lc ld le lf lg lh iz li ja lj jc lk jd ll jf lm jg ln lo dt translated">验证SUM的正确性</h1><p id="8256" class="pw-post-body-paragraph ju jv ht jw b jx lp iu jz ka lq ix kc kd lr kf kg kh ls kj kk kl lt kn ko kp hm dt translated">在语言验证框架中，演绎程序验证需要表明性质S，如SUM的主要正确性性质，在逻辑上遵循给定的语言模型L(IMP)和程序模型P(SUM)，以及已经表明在L和P中成立的其他较小的中间性质</p><p id="9540" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">验证过程通常是手动的(因为它通常是不可判定的),并且需要大量的独创性，特别是对于复杂的语言和大型程序。然而，演绎验证的严格性可能是非常有益的，因为它在所有形式验证技术中提供了一些最高级别的保证。</p><p id="84f8" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">接下来，我们将通过SUM示例描述K和Coq中的验证过程。</p><h1 id="ce8c" class="kx ky ht bd kz la lb lc ld le lf lg lh iz li ja lj jc lk jd ll jf lm jg ln lo dt translated">K中的验证</h1><p id="0b88" class="pw-post-body-paragraph ju jv ht jw b jx lp iu jz ka lq ix kc kd lr kf kg kh ls kj kk kl lt kn ko kp hm dt translated">SUM程序包括一个while循环，它更新程序变量<code class="eh lu lv lw lx b">n</code>和<code class="eh lu lv lw lx b">sum</code>。因此，为了能够证明程序的正确性属性，这涉及到变量<code class="eh lu lv lw lx b">n</code>和<code class="eh lu lv lw lx b">sum</code>，我们将需要指定并证明适当的循环不变量。我们可以在K中这样做，只需添加另一个规则，将循环不变量指定为可达性声明:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff kr"><img src="../Images/09a1264420ae18d25b7a22b8277781ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BNtlHDXVuF1ijjKH.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek"><em class="kw">The loop invariant in K</em></figcaption></figure><p id="ec75" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">该规则规定了这样的性质，假设<code class="eh lu lv lw lx b">n</code>最初被映射到非负整数值<code class="eh lu lv lw lx b">N</code>并且<code class="eh lu lv lw lx b">sum</code>被映射到某个整数值<code class="eh lu lv lw lx b">S</code>，SUM的while循环到达一个配置，在该配置中，循环终止并且状态映射<code class="eh lu lv lw lx b">n</code>到零，并且<code class="eh lu lv lw lx b">sum</code>被从1到<code class="eh lu lv lw lx b">N</code>的值的总和递增。</p><p id="a405" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">虽然演绎验证是众所周知的手工操作，通常需要相当大的人力，但K自动化了可达性逻辑的相当大的片段，这在实践中有助于减少过程中所需的手工操作。当验证一个属性时，K采用语言的语义规范L和程序的规范P，并将其视为(单向)可达性规则的系统，然后证明(或否定)该系统需要指定正确性属性s的可达性规则<code class="eh lu lv lw lx b">p /\ c =&gt; p</code>。生成的K证明者使用语义进行符号执行，在内部推理模式，并使用外部SMT解算器(<a class="ae kq" href="https://github.com/Z3Prover/z3" rel="noopener ugc nofollow" target="_blank"> Z3 </a>)来检查生成的约束的可满足性。</p><p id="4a41" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">特别是，对于SUM，假设语言规范在<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/k/imp.k" rel="noopener ugc nofollow" target="_blank"> imp.k </a>中给出，首先使用<code class="eh lu lv lw lx b">kompile</code>如下编译规范(更多编译器选项参见<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/k/Makefile" rel="noopener ugc nofollow" target="_blank"> Makefile </a>):</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff kr"><img src="../Images/aded4d532de60a11905419c6aa6c3451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lYMttcdpeqxFR39t.png"/></div></div></figure><p id="c55f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">K编译器为IMP生成K语言工具，包括IMP的K证明器。假设sum程序保存在文件<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/k/sum/sum100.imp" rel="noopener ugc nofollow" target="_blank"> sum.imp </a>中，定义属性(循环不变量和SUM正确性属性)的规则保存在文件<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/k/sum/sum-spec.k" rel="noopener ugc nofollow" target="_blank"> sum-spec.k </a>中，我们可以使用命令调用为IMP on SUM和属性生成的K证明器:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff kr"><img src="../Images/06c3d2731b70b99b2ed5b110061b2161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zv9XwgbDlXBMVPIP.png"/></div></div></figure><p id="3c2d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">证明者自动验证循环不变量和SUM的正确性，并通过返回<code class="eh lu lv lw lx b">#True</code>来表明这一点。</p><p id="ae0c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/tree/master/k" rel="noopener ugc nofollow" target="_blank">示例的存储库</a>中，我们提供了一个Make file脚本，该脚本自动执行编译规范、运行SUM程序和验证其属性的步骤。为了感受一下<code class="eh lu lv lw lx b">kprove</code>的验证效率，脚本还显示了完成任务所需的时间。在此目录中，运行命令:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff kr"><img src="../Images/e597fa6bb3734a678cc1c0e07cac5c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t5F7CcHuLvQqxeOe.png"/></div></div></figure><p id="5bf2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">运行验证任务(如果需要，在编译规范后)并显示验证属性所用的时间。在VirtualBox虚拟机上运行Ubuntu 18.04.3 LTS的2.9GHz英特尔酷睿i9 MacBook Pro上，执行<code class="eh lu lv lw lx b">kprove</code>的验证任务需要大约8秒钟才能完成。</p><h1 id="b4b8" class="kx ky ht bd kz la lb lc ld le lf lg lh iz li ja lj jc lk jd ll jf lm jg ln lo dt translated">Coq中的验证</h1><p id="2b67" class="pw-post-body-paragraph ju jv ht jw b jx lp iu jz ka lq ix kc kd lr kf kg kh ls kj kk kl lt kn ko kp hm dt translated">遵循在此<a class="ae kq" href="http://dx.doi.org/10.1007/978-3-319-89884-1_21" rel="noopener ugc nofollow" target="_blank">描述的</a>与语言无关的共归纳验证方法，程序被示为通过以下方式满足其规范:(1)使用定义语言语义的步骤关系，在该语言中程序被编写为符号执行引擎，以及(2)对源自语言中递归或迭代构造(例如IMP中的循环)的循环行为使用简单的共归纳推理。Coq中指定的允许可达性逻辑证明策略的机制可以在<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/coq/proof_system.v" rel="noopener ugc nofollow" target="_blank">示例的知识库</a>中找到。</p><p id="7340" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">对于上面的K，要证明SUM的正确性性质，首先需要指定并展示循环不变量。为此，我们引入了另一个类型为<code class="eh lu lv lw lx b">sum_spec</code>的构造函数:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff kr"><img src="../Images/c7e4f50692cd8c25b11eaae0234863e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7UwRMllfbrTZ5vwr.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek"><em class="kw">The loop invariant in Coq</em></figcaption></figure><p id="64e5" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">注意，<code class="eh lu lv lw lx b">get x env</code>计算出x在<code class="eh lu lv lw lx b">env</code>(如果定义了的话)中映射到的值，而<code class="eh lu lv lw lx b">fst</code>和<code class="eh lu lv lw lx b">snd</code>分别返回状态对的第一和第二部分。规范<code class="eh lu lv lw lx b">sum_loop_claim</code>为K例子定义了与上述完全相同的循环不变量。</p><p id="6438" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在，为了验证SUM满足其由<code class="eh lu lv lw lx b">sum_spec</code>给出的规范，即SUM的初始状态以<code class="eh lu lv lw lx b">sum</code>的正确值发散或终止，我们用定义IMP的语义的步骤关系<code class="eh lu lv lw lx b">step_p</code>来实例化一般的共归纳可靠性定理，并显示以下语句:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff kr"><img src="../Images/9803cdc560fd3064a43cdc3a6ab876f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8ZdvFT5z5VzirIVc.png"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek"><em class="kw">The correctness lemma of SUM in Coq</em></figcaption></figure><p id="f3f9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh lu lv lw lx b">sound</code>是关于可达性声明的一般命题。这个实例化的证明是基于一个广义共归纳定理，该定理使验证方法机械化，并且在这里<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/coq/imp.v#L268-L314" rel="noopener ugc nofollow" target="_blank">可用</a>。</p><p id="170a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">与K相比，在Coq中检查SUM的正确性属性的可达性声明的过程在同一台机器上花费了相似的时间(大约8秒)来完成。在<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/tree/master/coq" rel="noopener ugc nofollow" target="_blank">示例的存储库</a>中，我们提供了一个Make脚本，该脚本支持编译Coq规范并对检查证据的过程进行计时，该脚本可以通过以下命令调用:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff kr"><img src="../Images/13483bb4cfaa531e9d4ec5f4374f710b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kvWj-X42Pd2EjJdx.png"/></div></div></figure><h1 id="7795" class="kx ky ht bd kz la lb lc ld le lf lg lh iz li ja lj jc lk jd ll jf lm jg ln lo dt translated">摘要</h1><p id="b82e" class="pw-post-body-paragraph ju jv ht jw b jx lp iu jz ka lq ix kc kd lr kf kg kh ls kj kk kl lt kn ko kp hm dt translated">Coq和K都非常适合作为语言验证框架，我们在<a class="ae kq" href="https://runtimeverification.com" rel="noopener ugc nofollow" target="_blank"> Runtime Verification </a>一直定期使用它们来提供我们的正式建模和验证服务。尽管我们的方法在Coq中实现了独立于语言的程序验证，并支持自动化，但我们认为K更适合于指定语言和验证程序的任务，主要原因如下:</p><ul class=""><li id="4624" class="ly lz ht jw b jx jy ka kb kd ma kh mb kl mc kp md me mf mg dt translated">k从一开始就被设计来为语言提供一个定义框架，在这个框架中，一种语言的所有程序分析和验证工具都是直接从它在框架中的形式规范中派生出来的。因此，K提供了几个Coq中没有的特性，它们是专门为形式化和分析语言而定制的，包括:</li><li id="100e" class="ly lz ht jw b jx mh ka mi kd mj kh mk kl ml kp md me mf mg dt translated">支持使用BNF的标准符号以及几个语法和语义注释来定义语言的语法结构，这些注释支持简洁而精确的定义(相对于Coq中的归纳式纯语法定义)。</li><li id="c3c2" class="ly lz ht jw b jx mh ka mi kd mj kh mk kl ml kp md me mf mg dt translated">支持从BNF规范自动生成语言解析器，因此程序的结构是由其文本定义的(与Coq中的语法程序编码不同)。</li><li id="c3c4" class="ly lz ht jw b jx mh ka mi kd mj kh mk kl ml kp md me mf mg dt translated">支持使用计算结构和延续、嵌套单元配置、模式匹配和配置抽象来定义复杂的操作行为(相对于Coq中的低级集合论外延)。</li><li id="1c15" class="ly lz ht jw b jx mh ka mi kd mj kh mk kl ml kp md me mf mg dt translated">k的规范是可执行的，因此一种语言的语法和语义的规范立即产生了该语言的解释器，用它可以模拟和测试程序。Coq中的规范通常是不可执行的，尽管某种程度的证明自动化是可以实现的。</li><li id="63d4" class="ly lz ht jw b jx mh ka mi kd mj kh mk kl ml kp md me mf mg dt translated">通过用变量重写模式，语言的规范也可以用作语言的符号执行引擎。结合其他高级技术(如统一、约束求解和共归纳推理)，符号引擎可用于验证可达性逻辑中的可达性声明。</li></ul><p id="61d2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">另一方面，Coq为建模任何数学领域和证明任意复杂的数学定理提供了一个非常通用的框架，但是除了类型理论和归纳结构的基本原则之外，它并不致力于任何特定的建模风格。这显然会产生一个更灵活的系统，但是作为一个语言验证框架，尤其是与K相比，当形式化一种语言和验证程序时，这种灵活性可能是很昂贵的(在努力和时间方面)。我们相信K作为一个语言验证框架取得了很好的平衡，在这个框架中，语言可以被有效地形式化建模和验证，同时保持高度的通用性和灵活性。值得一提的是，目前正在努力将K扩展为一个完全成熟的匹配逻辑的证明助手，它将提供与Coq相同的灵活性。</p><p id="f2a7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">最后，我们注意到Coq和K都在积极开发中，并且在它们背后有相当大的社区(例如，参见项目的库，用于Coq和Coq的库)。此外，这个帖子系列中的许多亮点来自正式方法和程序验证的活跃研究领域。</p></div><div class="ab cl mo mp hb mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hm hn ho hp hq"><p id="d386" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><em class="mm">原载于2019年12月12日</em><a class="ae kq" href="https://runtimeverification.com/blog/k-vs-coq-as-language-verification-frameworks-part-3-of-3/" rel="noopener ugc nofollow" target="_blank"><em class="mm">https://runtimeverification.com</em></a><em class="mm">。</em></p><blockquote class="mv"><p id="d22a" class="mw mx ht bd my mz na nb nc nd ne kp ek translated"><a class="ae kq" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ng nh ni nj nk jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nf"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff nl"><img src="../Images/a06b758bdcc47dca7c2504f298674d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_s6JsD3P0hVj32E7t9EtGg.jpeg"/></div></a></figure></div></div>    
</body>
</html>