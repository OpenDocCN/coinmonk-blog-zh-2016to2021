<html>
<head>
<title>Advanced EOS Series — Part 6 —Contract-to-Contract Communication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级EOS系列—第6部分—合同间通信</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/advanced-eos-series-part-6-contract-to-contract-communication-ab352a8b60aa?source=collection_archive---------1-----------------------#2019-01-31">https://medium.com/coinmonks/advanced-eos-series-part-6-contract-to-contract-communication-ab352a8b60aa?source=collection_archive---------1-----------------------#2019-01-31</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/27363975906b0585a7c487a309ec17b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*neSMLfVmMP0XASz1D-7j0w.jpeg"/></div></div></figure><p id="a7a7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎回到高级EOS开发系列，在这里我将触及教程或课程很少涉及的技术和功能。本系列的目的是将您需要完成的作为EOSIO区块链分布式应用程序开发人员的技能的缺失部分汇集在一起。每篇文章都是按照难度排序的，所以如果你想要一个总体的概述，我建议你从第1部分开始，一步步往上。这些例子的完整代码可以在GitHub 上找到<a class="ae jz" href="https://github.com/MitchPierias/Advanced-EOS-Examples/tree/master/06_Contract-to-Contract-Communication" rel="noopener ugc nofollow" target="_blank">。</a></p><div class="ka kb fm fo kc kd"><a href="https://github.com/MitchPierias/Advanced-EOS-Examples/tree/master/06_Contract-to-Contract-Communication" rel="noopener  ugc nofollow" target="_blank"><div class="ke ab ej"><div class="kf ab kg cl cj kh"><h2 class="bd hu fv z el ki eo ep kj er et hs dt translated">MitchPierias/高级-EOS-示例</h2><div class="kk l"><h3 class="bd b fv z el ki eo ep kj er et ek translated">一系列EOS合同开发实例。通过创建…为MitchPierias/Advanced-EOS-Examples开发做出贡献</h3></div><div class="kl l"><p class="bd b gc z el ki eo ep kj er et ek translated">github.com</p></div></div><div class="km l"><div class="kn l ko kp kq km kr iz kd"/></div></div></a></div><blockquote class="ks kt ku"><p id="9677" class="jb jc kv jd b je jf jg jh ji jj jk jl kw jn jo jp kx jr js jt ky jv jw jx jy hm dt translated">由于这些都是高级主题，我很危险地假设你已经知道了基础知识，并正在寻求进一步的知识。因此，这些文章中共享的代码将针对所讨论的主题进行精简。</p></blockquote></div><div class="ab cl kz la hb lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hm hn ho hp hq"><h1 id="b30b" class="lg lh ht bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md dt translated">在我们开始之前…</h1><p id="3137" class="pw-post-body-paragraph jb jc ht jd b je me jg jh ji mf jk jl jm mg jo jp jq mh js jt ju mi jw jx jy hm dt translated">执行内嵌操作需要自定义帐户权限。出于安全原因，EOS的发布版本现在需要调用内联动作的契约的<code class="eh mj mk ml mm b">eosio.code</code>权限。让我们看看如何为我们的合同帐户创建自定义权限。</p><h2 id="91a6" class="mn lh ht bd li mo mp mq lm mr ms mt lq jm mu mv lu jq mw mx ly ju my mz mc na dt translated"><strong class="ak">修改账户权限</strong></h2><p id="be39" class="pw-post-body-paragraph jb jc ht jd b je me jg jh ji mf jk jl jm mg jo jp jq mh js jt ju mi jw jx jy hm dt translated">在调用对我们的<code class="eh mj mk ml mm b">user</code>契约的操作之前，我们修改我们的<code class="eh mj mk ml mm b">timeline</code>帐户的权限。我们需要<code class="eh mj mk ml mm b">eosio.code</code>权限来调用我们的内联动作，所以我们将在调用动作的帐户上覆盖我们的<code class="eh mj mk ml mm b">active</code>键。让我们使用<code class="eh mj mk ml mm b">cleos set account permission</code>命令来实现这一点。</p><pre class="nb nc nd ne fq nf mm ng nh aw ni dt"><span id="d2dd" class="mn lh ht mm b fv nj nk l nl nm">cleos set account permission timeline active<br/>'{<br/>  "threshold":1,<br/>  "keys":[{<br/>    "key":"YOUR_PUBLIC_KEY",<br/>    "weight":1<br/>  }],<br/>  "accounts":[{<br/>    "permission":{<br/>      "actor":"timeline",<br/>      "permission":"eosio.code"<br/>    },"weight":1<br/>  }]<br/>}'<br/>owner -p timeline@owner</span></pre><p id="e684" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们已经修改了我们的权限，我们可以仔细看看在一个契约和另一个契约之间调用动作的<code class="eh mj mk ml mm b">eosio::action</code>方法。</p><h2 id="87ff" class="mn lh ht bd li mo mp mq lm mr ms mt lq jm mu mv lu jq mw mx ly ju my mz mc na dt translated">用户合同</h2><p id="f32f" class="pw-post-body-paragraph jb jc ht jd b je me jg jh ji mf jk jl jm mg jo jp jq mh js jt ju mi jw jx jy hm dt translated">首先，我们将编写一个<code class="eh mj mk ml mm b">user</code>契约来管理用户的注册、激活和验证。让我们定义我们的用户<code class="eh mj mk ml mm b">Profile</code>结构和一个<code class="eh mj mk ml mm b">create</code>动作来注册新用户。我们还将快速添加一个<code class="eh mj mk ml mm b">activate</code>动作来改变用户的<code class="eh mj mk ml mm b">active</code>状态。记得初始化您的契约并序列化您的ABI操作。</p><pre class="nb nc nd ne fq nf mm ng nh aw ni dt"><span id="8c1c" class="mn lh ht mm b fv nj nk l nl nm">// @abi action<br/>void create(const account_name username) {<br/>  profile_table profiles(_self, _self);<br/>  auto result = profiles.find(username);<br/>  eosio_assert(result == profiles.end(), "User already registered");<br/>  // Store new user profile<br/>  profiles.emplace(_self, [&amp;](auto&amp; profile) {<br/>    profile.uuid = username;<br/>  });<br/>}</span><span id="49cb" class="mn lh ht mm b fv nn nk l nl nm">// @abi action<br/>void activate(const account_name username, bool isActive) {<br/>  profile_table profiles(_self, _self);<br/>  auto results = profiles.find(username);<br/>  profiles.modify(results, 0, [&amp;](auto&amp; profile) {<br/>    profile.active = isActive;<br/>  });<br/>}</span><span id="c3e0" class="mn lh ht mm b fv nn nk l nl nm">// @abi table profiles i64<br/>struct Profile {<br/>  uint64_t      uuid;<br/>  bool          active = true;<br/>  bool          approved = true;<br/>  bool          flagged = false;<br/>  auto primary_key() const { return uuid; }<br/>  EOSLIB_SERIALIZE(Profile, (uuid)(active)(approved)(flagged));                         };</span><span id="db3d" class="mn lh ht mm b fv nn nk l nl nm">typedef multi_index&lt;N(profiles), Profile&gt; profile_table;</span></pre><p id="16eb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们还将编写一个validate方法来检查指定的用户是否通过了我们所有的验证要求。为此，我们将获取用户的个人资料，并检查他们的活动状态，如果他们已经被标记<em class="kv">(警告)</em>，如果他们的帐户被批准。</p><pre class="nb nc nd ne fq nf mm ng nh aw ni dt"><span id="97b1" class="mn lh ht mm b fv nj nk l nl nm">// @abi action<br/>void validate(const account_name username) {<br/>  profile_table profiles(_self, _self);<br/>  auto results = profiles.find(username);<br/>  eosio_assert(results-&gt;active, "User inactive");<br/>  eosio_assert(!results-&gt;flagged, "User flagged");<br/>  eosio_assert(results-&gt;approved, "User not approved");                         }</span></pre><h2 id="c333" class="mn lh ht bd li mo mp mq lm mr ms mt lq jm mu mv lu jq mw mx ly ju my mz mc na dt translated">时间表合同</h2><p id="ef42" class="pw-post-body-paragraph jb jc ht jd b je me jg jh ji mf jk jl jm mg jo jp jq mh js jt ju mi jw jx jy hm dt translated">现在我们要写一个<code class="eh mj mk ml mm b">timeline</code>契约来处理发布和删除帖子。为了保持这篇文章的简洁，我将只涉及出版方面。让我们定义<code class="eh mj mk ml mm b">Tweet</code>结构来存储我们发布的tweets。</p><pre class="nb nc nd ne fq nf mm ng nh aw ni dt"><span id="11ea" class="mn lh ht mm b fv nj nk l nl nm">// @abi table tweets i64<br/>struct Tweet {<br/>  uint64_t       id;<br/>  account_name   author;<br/>  string         msg;<br/>  bool           flagged;<br/>  auto primary_key() const { return id; }<br/>  EOSLIB_SERIALIZE(Tweet, (id)(author)(msg)(flagged));<br/>};</span><span id="66ad" class="mn lh ht mm b fv nn nk l nl nm">typedef multi_index&lt;N(tweets), Tweet&gt; tweet_table;</span></pre><h2 id="4ab4" class="mn lh ht bd li mo mp mq lm mr ms mt lq jm mu mv lu jq mw mx ly ju my mz mc na dt translated">合同间通信</h2><p id="a080" class="pw-post-body-paragraph jb jc ht jd b je me jg jh ji mf jk jl jm mg jo jp jq mh js jt ju mi jw jx jy hm dt translated">当我们试图用我们的<code class="eh mj mk ml mm b">timeline</code>合同<code class="eh mj mk ml mm b">publish</code>一条tweet时，我们的合同间通信将会发生。在存储推文之前，我们需要验证用户的帐户。让我们使用<code class="eh mj mk ml mm b">action(PERMISSIONS,TO_ACCOUNT,TO_ACTION,DATA_TUPLE).send()</code>方法调用<code class="eh mj mk ml mm b">user</code>合同上的<code class="eh mj mk ml mm b">validate</code>动作。</p><pre class="nb nc nd ne fq nf mm ng nh aw ni dt"><span id="aa26" class="mn lh ht mm b fv nj nk l nl nm">// @abi action<br/>void publish(const account_name username, const string&amp; msg_str) {<br/>  <br/>  eosio::action(<br/>    permission_level{_self, N(active)},<br/>    N(user),<br/>    N(validate),<br/>    std::make_tuple(username)<br/>  ).send();</span><span id="f6d6" class="mn lh ht mm b fv nn nk l nl nm">  tweet_table tweets(_self, _self);<br/>  tweets.emplace(_self, [&amp;](auto&amp; obj) {<br/>    obj.id = tweets.available_primary_key();<br/>    obj.author = username;<br/>    obj.msg = msg_str;<br/>  });<br/>}</span></pre><p id="6dc0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">就这么简单！只要你已经正确设置了合同帐户的<code class="eh mj mk ml mm b">eosio.code</code>权限，你就可以调用另一个合同的动作。</p><blockquote class="no"><p id="9a44" class="np nq ht bd nr ns nt nu nv nw nx jy ek translated"><a class="ae jz" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nz oa ob oc od iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ny"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>