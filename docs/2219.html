<html>
<head>
<title>Use dapp.tools for Ethereum Contract Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用dapp.tools进行以太坊合约开发</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/use-dapp-tools-for-ethereum-contract-development-2775d8b2ba0?source=collection_archive---------3-----------------------#2019-05-16">https://medium.com/coinmonks/use-dapp-tools-for-ethereum-contract-development-2775d8b2ba0?source=collection_archive---------3-----------------------#2019-05-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><h1 id="a48f" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">介绍</h1><p id="c1a5" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在开发和测试Solidity contract的时候，我相信大部分人都在用Remix，一个大家都可以通过浏览器使用的在线IDE(集成开发环境)。Remix带有编辑器、终端、编译器和运行时环境，可以在内置的以太坊模拟器或外部以太坊网络上运行。</p><p id="a9f6" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">因为一个新项目，我有机会使用来自<strong class="jq hu"> dapp.tools </strong>的工具集，并且找到了一个几乎等同于在我的本地主机上运行的Remix的命令行。我觉得很直观。此外，dapp.tools附带了一些包，我可以很容易地将它们合并到我的合同中。</p><p id="0590" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">在本文中，我首先展示了dapp.tools的一些基本功能和操作，我将使用一个简单的契约代码，看看如何在契约本身上创建单元测试，确保契约中定义的逻辑正是测试用例中所期望的。之后，我部署契约并与以太坊模拟testnet交互，testnet也来自dapp.tools。在下一篇文章中，我将创建另一个契约，并了解如何将预构建的令牌包合并到我的项目中。</p><h1 id="c337" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">dapp.tools概述和安装</h1><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="fe ff kr"><img src="../Images/8f403de0c30866d21f7decbc666ddba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aACMy9px482FjnDVVe0W3g.png"/></div></div></figure><p id="6330" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">dapp.tools最好的介绍在他们的<a class="ae ld" href="https://dapp.tools/" rel="noopener ugc nofollow" target="_blank">页面</a>。</p><p id="2507" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">正如他们的网站所描述的，dapp.tools是一套“用于区块链开发的命令行友好工具”。作为一个快速概述，dapp.tools附带了几个用于以太坊契约开发的便利工具。同样，您可以在这些工具及其网站上看到最佳描述。</p><p id="3d09" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">在我的演示中，我将使用<strong class="jq hu"> dapp </strong>来执行我的契约代码的单元测试，并将其部署在dapp.tools提供的testnet中。</p><p id="2c46" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">安装非常简单。因为我用的是Mac，所以我只是简单地按照他们的指示去做。</p><pre class="ks kt ku kv fq le lf lg lh aw li dt"><span id="40ba" class="lj ir ht lf b fv lk ll l lm ln">curl https://dapp.tools/install | sh</span></pre><h1 id="76f3" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">初始化工作区</h1><p id="bc04" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们演示的第一件事是使用<code class="eh lo lp lq lf b">dapp init</code>为dapp初始化一个工作区。</p><pre class="ks kt ku kv fq le lf lg lh aw li dt"><span id="e684" class="lj ir ht lf b fv lk ll l lm ln">mkdir simplestorage<br/>cd simplestorage</span><span id="7c0b" class="lj ir ht lf b fv lr ll l lm ln">dapp init</span></pre><p id="72ce" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">从输出中我们了解到，在<code class="eh lo lp lq lf b">dapp init</code>之后，我们有</p><ul class=""><li id="54db" class="ls lt ht jq b jr km jv kn jz lu kd lv kh lw kl lx ly lz ma dt translated">创建一个目录结构，目录<strong class="jq hu"> src </strong>保存我们的合同代码和测试代码，目录<strong class="jq hu"> lib </strong>保存包。</li><li id="1bae" class="ls lt ht jq b jr mb jv mc jz md kd me kh mf kl lx ly lz ma dt translated">在<strong class="jq hu"> src </strong>里面创建了两个文件:<strong class="jq hu"> Simplestorage.sol </strong>是我们的合同代码，<strong class="jq hu"> Simplestorage.t.sol </strong>是测试代码。它们都预先填充了基本合同结构。</li><li id="7f30" class="ls lt ht jq b jr mb jv mc jz md kd me kh mf kl lx ly lz ma dt translated">在<strong class="jq hu"> lib </strong>里面，安装了一个包<code class="eh lo lp lq lf b">ds-test</code>。这是测试我们合同的包装。</li><li id="61b9" class="ls lt ht jq b jr mb jv mc jz md kd me kh mf kl lx ly lz ma dt translated">执行健全性测试。</li><li id="1c15" class="ls lt ht jq b jr mb jv mc jz md kd me kh mf kl lx ly lz ma dt translated">为这个工作区创建了一个git存储库。</li></ul><p id="483b" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">下面是<code class="eh lo lp lq lf b">dapp init</code>之后的目录结构。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/d0bc1b38d16da33c834cd0c7dce3a164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/0*Ixh-zn1a4Rau7afC"/></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Directory structure created by <code class="eh lo lp lq lf b">dapp init</code></figcaption></figure><h1 id="2a67" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">合同代码和测试代码</h1><p id="7926" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在让我们准备合同代码和测试代码。</p><p id="478d" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">这里我使用了著名的简单存储契约代码。此契约在首次部署时保留一个存储值。并且我们可以使用两个函数与契约进行交互:<em class="ml"> get() </em>用于存储值，而<em class="ml"> set(x) </em>用于更新值。</p><p id="94f1" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">工作区初始化使用工作区目录名<strong class="jq hu"> src/Simplestorage.sol </strong>创建一个空契约。我们只是将合同代码复制到这个文件中。</p><pre class="ks kt ku kv fq le lf lg lh aw li dt"><span id="f231" class="lj ir ht lf b fv lk ll l lm ln">pragma solidity ^0.5.6;</span><span id="1b04" class="lj ir ht lf b fv lr ll l lm ln">contract Simplestorage {<br/> uint storedData;</span><span id="18a9" class="lj ir ht lf b fv lr ll l lm ln">function set(uint x) public {<br/>  storedData = x;<br/> }</span><span id="ca02" class="lj ir ht lf b fv lr ll l lm ln">function get() view public returns (uint retVal) {<br/>  return storedData;<br/> }</span><span id="f72d" class="lj ir ht lf b fv lr ll l lm ln">}</span></pre><p id="b96a" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">工作区初始化还会创建一个名为t . sol:<strong class="jq hu">src/simple storage . t . sol</strong>的测试契约。我们简单地复制这个文件中的测试代码。虽然它有两个样本测试。</p><pre class="ks kt ku kv fq le lf lg lh aw li dt"><span id="fa61" class="lj ir ht lf b fv lk ll l lm ln">pragma solidity ^0.5.6;</span><span id="e064" class="lj ir ht lf b fv lr ll l lm ln">import "ds-test/test.sol";</span><span id="c37f" class="lj ir ht lf b fv lr ll l lm ln">import "./Simplestorage.sol";</span><span id="81ac" class="lj ir ht lf b fv lr ll l lm ln">contract SimplestorageTest is DSTest {<br/>    Simplestorage simplestorage;</span><span id="a6a2" class="lj ir ht lf b fv lr ll l lm ln">function setUp() public {<br/>        simplestorage = new Simplestorage();<br/>    }</span><span id="7c59" class="lj ir ht lf b fv lr ll l lm ln">function testGetInitialValue() public {<br/>        assertTrue(simplestorage.get() == 0);<br/>    }</span><span id="f86c" class="lj ir ht lf b fv lr ll l lm ln">function testSetValue() public {<br/>        uint x = 300;<br/>        simplestorage.set(x);<br/>        assertTrue(simplestorage.get() == 300);<br/>    }</span><span id="10bf" class="lj ir ht lf b fv lr ll l lm ln">}</span></pre><p id="6beb" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">让我们看看这份测试合同。<strong class="jq hu"> Simplestorage.t.sol </strong>也是一个Solidity契约。它首先导入<code class="eh lo lp lq lf b">ds-test</code>包中的<strong class="jq hu"> test.sol </strong>(在工作区初始化时安装)和<strong class="jq hu"> Simplestorage.sol </strong>契约。</p><p id="8143" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们将测试用例定义为函数。在此之前，我们需要一个<em class="ml"> setUp() </em>函数来部署这个契约。</p><p id="012e" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">测试用例的函数以前缀<strong class="jq hu"> test </strong>命名。这些功能都将作为测试项目来执行。只有当assertTrue(条件)中的条件为真时，测试才通过<strong class="jq hu">。函数<em class="ml"> testGetInitialValue() </em>是在合同部署后用<em class="ml"> get() </em>函数获取存储值。函数<em class="ml"> testSetValue() </em>用于检查<em class="ml"> set(x) </em>是否可用于新值，并用<em class="ml"> get() </em>函数检查该值。</strong></p><p id="4b06" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">你可能会问测试在哪里进行。Dapp测试使用了Hevm，他们自己的evm实现很好的测试和调试。因此，我们不需要为合同测试运行任何testnet。</p><h1 id="71ae" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">测试合同代码</h1><p id="7715" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">如前所述，我们不需要testnet来进行契约测试。这里我们使用命令<code class="eh lo lp lq lf b">dapp test</code>进行单元测试。</p><pre class="ks kt ku kv fq le lf lg lh aw li dt"><span id="9396" class="lj ir ht lf b fv lk ll l lm ln">dapp test</span></pre><p id="0c55" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">Dapp将搜索那些带有t.sol扩展名的契约，并执行<em class="ml"> setUp() </em>和所有带有前缀test的函数:在我们的测试代码中有两个函数:<em class="ml"> testGetInitialValue() </em>和<em class="ml"> testSetValue() </em>。</p><p id="f7ce" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">这是结果。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="fe ff mm"><img src="../Images/81e03f43a9e07c73952a1cde9f78802e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NoO0eVrHHMe92SOc"/></div></div></figure><p id="05b2" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">从结果中我们看到dapp测试首先编译这两个契约。之后，运行<strong class="jq hu"> Simplestorage.t.sol </strong>中的两个测试用例并成功通过。</p><p id="0b92" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">同时编译结果存储在<strong class="jq hu"> out </strong>目录中。我们可以在这个目录中找到所有编译后的工件。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="fe ff mn"><img src="../Images/06fa0872628ba11f0c1fbb97809e82b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uOcGHMFQxe_ER3CP"/></div></div></figure><h1 id="c921" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">运行Testnet</h1><p id="8cef" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在我们的合同已经准备好部署了。我们将首先运行由dapp提供的以太网testnet。</p><p id="9138" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">使用不同的终端运行testnet</p><pre class="ks kt ku kv fq le lf lg lh aw li dt"><span id="11c3" class="lj ir ht lf b fv lk ll l lm ln">dapp testnet</span></pre><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/52fb16593b905bced012ec193f78063b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/0*mTJBnKvUO0IowKmU"/></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Use another terminal to run testnet</figcaption></figure><p id="3c53" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">运行dapp测试网的几点观察</p><ul class=""><li id="cae6" class="ls lt ht jq b jr km jv kn jz lu kd lv kh lw kl lx ly lz ma dt translated">所有的testnet设置都在我的主目录中，在~/下。dapp/testnet/8545。</li><li id="024c" class="ls lt ht jq b jr mb jv mc jz md kd me kh mf kl lx ly lz ma dt translated">如果我们看一下这个目录，我们会看到geth组件和其他设置。</li><li id="01ca" class="ls lt ht jq b jr mb jv mc jz md kd me kh mf kl lx ly lz ma dt translated">在keystore目录中，我们将设置coinbase帐户。testnet屏幕上也显示了地址(这里是0x62a8…c362，我们每次运行<code class="eh lo lp lq lf b">dapp testnet</code>的时候这个地址都不一样。)</li><li id="ead5" class="ls lt ht jq b jr mb jv mc jz md kd me kh mf kl lx ly lz ma dt translated">testnet实际上是一个运行中的geth，在这个目录中保存了genesis块和coinbase键。</li></ul><p id="87b1" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">这是测试网的目录结构。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/ff2aab57f2c9ea783e738feceb5d4c80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/0*rIB9Ur4SNYYSlKzE"/></div></figure><h1 id="b2bb" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">部署合同</h1><p id="8888" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">有了运行dapp testnet的终端，我们就可以部署契约了。</p><p id="2c7e" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们首先指定用于契约部署的coinbase地址，并告诉从哪里获取私钥。这是通过设置环境变量ETH_FROM和ETH_KEYSTORE来实现的。</p><pre class="ks kt ku kv fq le lf lg lh aw li dt"><span id="e2df" class="lj ir ht lf b fv lk ll l lm ln">export ETH_FROM=0x62a872619c4072f73724d0fb5905354fc6ecc362<br/>export ETH_KEYSTORE=~/.dapp/testnet/8545/keystore</span></pre><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/0670d2f7a671808afa232e67f15c3405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/0*2Yy0gvwwRW9wrghS"/></div></figure><p id="1881" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们使用<code class="eh lo lp lq lf b">dapp create</code>来部署合同。当提示输入密码时，testnet的密码为空。</p><pre class="ks kt ku kv fq le lf lg lh aw li dt"><span id="b288" class="lj ir ht lf b fv lk ll l lm ln">dapp create Simplestorage</span></pre><p id="e0a3" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">正如我们所看到的，一个事务被执行。这是合同部署。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/8d8188b60916f0deee6444bd304f7e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/0*8FJCewkztfaBAzbV"/></div></figure><p id="c50c" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">注意，我们将得到一个地址(0x9fa2…7fde)。它是部署后的合同ID(或合同地址)。为了便于访问，我们将定义另一个环境变量SIMSTO来保持这个值。</p><pre class="ks kt ku kv fq le lf lg lh aw li dt"><span id="82a6" class="lj ir ht lf b fv lk ll l lm ln">export SIMSTO=0x9fa245ee3daa5314fdfe33124b9215029c157fde</span></pre><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/b6b44d5f706c2940aaa8946718f8f61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/0*tTIOQqoqNPpL0wA-"/></div></figure><p id="cf69" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">现在契约已经部署好了，我们已经准备好与它进行交互了。</p><h1 id="447e" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">与合同交互</h1><p id="8ddb" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">为了与合同进行交互，我们使用了<code class="eh lo lp lq lf b">seth</code>。Seth是命令行制作的以太坊客户端。我们可以用<code class="eh lo lp lq lf b">seth</code>执行很多任务。这里我们只是用它来执行已部署契约中的功能。</p><p id="10f2" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">首先，我们将对函数<em class="ml"> get() </em>使用<code class="eh lo lp lq lf b">seth call</code>，而不更新区块链。我们需要的是部署的契约ID(我们在上一步中设置的环境变量)。</p><pre class="ks kt ku kv fq le lf lg lh aw li dt"><span id="0025" class="lj ir ht lf b fv lk ll l lm ln">seth call $SIMSTO “get()”</span></pre><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/7c4b3d6068ffe6a1ce007fc37df586f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/0*SvxTDP5W-m66RFBn"/></div></figure><p id="5680" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">正如所料，该值最初为零。</p><p id="a25c" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们将设置一个新的值。对于需要参数的函数，我们将参数列表放在函数之后。另外<code class="eh lo lp lq lf b">seth</code>需要十六进制输入，我们将使用<code class="eh lo lp lq lf b">seth --to-uint256</code>将数字转换成十六进制并适合256位。</p><p id="2d16" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们将使用<code class="eh lo lp lq lf b">seth send</code>函数更新区块链。</p><pre class="ks kt ku kv fq le lf lg lh aw li dt"><span id="131d" class="lj ir ht lf b fv lk ll l lm ln">seth send $SIMSTO “set(uint)” $(seth --to-uint256 100)</span></pre><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/d6d59cae59f7f7bc12f1aee5e68c5076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/0*tCvqJA1kZEEaXLgP"/></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">The first command is just to show a conversion of number to uint256</figcaption></figure><p id="90ff" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们看到创建了一个新事务，该事务包含在一个新块中。</p><p id="7caa" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">最后，我们用<em class="ml"> get() </em>再次检查存储的值。</p><pre class="ks kt ku kv fq le lf lg lh aw li dt"><span id="b490" class="lj ir ht lf b fv lk ll l lm ln">seth call $SIMSTO “get()”</span></pre><p id="6f3d" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">结果是0x64 (100)，和预期的一样。</p><h1 id="be11" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">清理</h1><p id="530e" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在我们完成我们的演示或测试之后，我们可以通过control-c . testnet的目录，即~ ~/来停止dapp testnet终端。dapp/testnet/8545将被清空。testnet中的所有信息，包括测试期间创建的帐户和块，都消失了。这很有帮助，因为我们不需要删除不同目录中的文件。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="fe ff ms"><img src="../Images/a20036d7c0cb2ff320ab598458de3cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kC4zhdfxwCwU2epJ"/></div></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">After testnet is stopped, all files in this directory are gone.</figcaption></figure><h1 id="8a8c" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">端节点:在公共以太坊部署合同</h1><p id="5a36" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><code class="eh lo lp lq lf b">seth</code>的默认设置是到本地RPC，也就是本地testnet。</p><p id="a88e" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">如果我们希望在公共以太网中部署我们的合同，我们需要的是通过环境变量让<code class="eh lo lp lq lf b">seth</code>知道目标网络。</p><p id="ff1b" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们需要的变量是</p><pre class="ks kt ku kv fq le lf lg lh aw li dt"><span id="1c65" class="lj ir ht lf b fv lk ll l lm ln">export SETH_CHAIN=&lt;the chain you are deploying, e.g. mainnet, rinkeby, etc&gt;</span><span id="b5ca" class="lj ir ht lf b fv lr ll l lm ln">export ETH_KEYSTORE=&lt;your keystore in the Ethereum network&gt;</span><span id="0bb1" class="lj ir ht lf b fv lr ll l lm ln">export ETH_FROM=&lt;your coinbase address in this Ethereum network&gt;</span></pre><p id="b29f" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">然后所有来自<code class="eh lo lp lq lf b">seth</code>的命令都会传到你指定的以太网。确保你的帐户里有乙醚。</p><h1 id="f02e" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">关闭</h1><p id="f971" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们只是展示了如何使用dapp工具为以太坊契约执行单元测试。我们还部署了一个testnet，并使用seth来执行已部署合同的功能。</p><p id="599f" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">这只显示了dapp工具非常基本的功能。在<a class="ae ld" rel="noopener" href="/@kctheservant/developing-a-marketplace-contract-with-token-payment-d865323ea88c">的下一篇文章</a>中，我将创建一个更大的合同，并看看如何在我的合同中加入<code class="eh lo lp lq lf b">ds-token</code>包以使token可用。</p><blockquote class="mt"><p id="1d09" class="mu mv ht bd mw mx my mz na nb nc kl ek translated"><a class="ae ld" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ne nf ng nh ni kw fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nd"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>