<html>
<head>
<title>Fibonacci in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚固性中的斐波那契</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/fibonacci-in-solidity-8477d907e22a?source=collection_archive---------0-----------------------#2018-09-28">https://medium.com/coinmonks/fibonacci-in-solidity-8477d907e22a?source=collection_archive---------0-----------------------#2018-09-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/b28647e0f26c6443846ac33cfbdb5572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gwvf_w1iyR0QtWYW-K-gBA.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">“We’ll ride the spiral to the end and may just go where no one’s been.” — Tool, Lateralus</figcaption></figure><p id="8af2" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">今天早上浏览<a class="ae kd" href="https://news.ycombinator.com/item?id=18091655" rel="noopener ugc nofollow" target="_blank">黑客新闻</a>时，我看到一个帖子，基准测试Github中最常用的10种语言返回斐波纳契数列中的第<em class="ke"> n </em>个元素。Solidity还不是一种非常流行的语言，所以我想我会探索一些解决方案，看看它如何比较。</p><p id="3ed1" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">从数学上讲，斐波那契数列是一个递归函数，它将前面的元素相加以获得下一个元素。像这样:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="35df" class="ko kp ht kk b fv kq kr l ks kt">Fn = Fn-1 + Fn-2</span></pre><h1 id="12a1" class="ku kp ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">递归</h1><p id="626f" class="pw-post-body-paragraph jf jg ht jh b ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy lv ka kb kc hm dt translated">最简单的方法是使用递归，就像这样:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="7d34" class="ko kp ht kk b fv kq kr l ks kt">//fib(4) = 15540 gas <br/>//fib(42) = no go<br/>function fib(uint n) public view returns(uint) { <br/>    if (n &lt;= 1) {<br/>       return n;<br/>    } else {<br/>       return this.fib(n - 1) + this.fib(n - 2);<br/>    }<br/>}</span></pre><p id="518f" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">不幸的是，递归是不可能的。我确信在紧要关头可以让<a class="ae kd" href="https://github.com/web3j/web3j/blob/master/codegen/src/test/resources/solidity/fibonacci/Fibonacci.sol" rel="noopener ugc nofollow" target="_blank">工作</a>，但是运行<code class="eh lw lx ly kk b">fib(42)</code>时remix挂起，甚至<code class="eh lw lx ly kk b">fib(4)</code>也要消耗~15k的汽油。</p><h1 id="434b" class="ku kp ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">记忆</h1><p id="16a5" class="pw-post-body-paragraph jf jg ht jh b ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy lv ka kb kc hm dt translated">对于我的第二种方法，我决定使用一种<em class="ke"> memoisation </em>技术，将序列存储在一个内存数组中，按照预期返回第n个元素。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="cffc" class="ko kp ht kk b fv kq kr l ks kt">//fib1(4) = 1593 gas<br/>//fib1(42) = 12237 gas <br/>//fib1(1042) = no-go...<br/>function fib1(uint n) external pure returns(uint) { <br/>    uint[] memory sequence = new uint[](n+1);<br/>    for (uint i = 0; i &lt;= n; i++) {<br/>        if (i &lt;= 1) {<br/>            sequence[i] = i;<br/>        } else {<br/>            sequence[i] = sequence[i -1] + sequence[i -2];    <br/>        }<br/>    }<br/>    return sequence[n];<br/>}</span></pre><p id="9f8a" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">好一点了，现在<code class="eh lw lx ly kk b">fib1(42)</code>可以正确返回，但是再次请求<code class="eh lw lx ly kk b">fib1(1042)</code>会导致混音挂起。这不好，实际上这个问题根本不需要我们把整个序列保存在内存中。</p><h1 id="729a" class="ku kp ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">循环</h1><p id="f803" class="pw-post-body-paragraph jf jg ht jh b ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy lv ka kb kc hm dt translated">需要一种更好的方法，所以我将算法改为只在内存中存储三个变量，并迭代<em class="ke"> n </em>次，直到找到序列中的第<em class="ke">n</em>个元素，如下所示:</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="e8c2" class="ko kp ht kk b fv kq kr l ks kt">//fib2(4) =  363 gas<br/>//fib2(42) = 2757 gas <br/>//fib2(1042) = 65757 gas<br/>function fib2(uint n) external pure returns(uint b) { <br/>    if (n == 0) {<br/>        return 0;   <br/>    }<br/>    uint a = 1;<br/>    b = 1;<br/>    for (uint i = 2; i &lt; n; i++) {<br/>        uint c = a + b;<br/>        a = b;<br/>        b = c;<br/>    }<br/>    return b;<br/>}</span></pre><p id="448d" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">那行得通。该功能仍然需要<code class="eh lw lx ly kk b">fib2(1042)</code>相当多的气体，但<a class="ae kd" href="https://github.com/drujensen/fib" rel="noopener ugc nofollow" target="_blank">原始挑战</a>的要求要低得多。</p><p id="d455" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">通常情况下，我会对结果感到满意，并继续进行一些实际的工作，但我担心没有什么可写的，我已经花了一个上午的时间来研究这个挑战。</p><h1 id="1447" class="ku kp ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">比奈公式(等价)</h1><p id="7e1b" class="pw-post-body-paragraph jf jg ht jh b ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy lv ka kb kc hm dt translated">我知道比奈的公式在Solidity中很难实现，但我想如果我能找到一个C语言的实现，我就能翻译它……你知道吗，我在这里找到了一个<a class="ae kd" href="https://stackoverflow.com/questions/9645193/calculating-fibonacci-number-accurately-in-c" rel="noopener ugc nofollow" target="_blank"/>。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="ce73" class="ko kp ht kk b fv kq kr l ks kt">//fib2(4) =  796 gas<br/>//fib3(42) = 1399 gas  <br/>//fib3(1042) = 2414 gas<br/>function fib3(uint n) external pure returns(uint a) { <br/>    if (n == 0) {<br/>        return 0;   <br/>    }<br/>    uint h = n / 2; <br/>    uint mask = 1;<br/>    // find highest set bit in n<br/>    while(mask &lt;= h) {<br/>        mask &lt;&lt;= 1;<br/>    }<br/>    mask &gt;&gt;= 1;<br/>    a = 1;<br/>    uint b = 1;<br/>    uint c;<br/>    while(mask &gt; 0) {<br/>        c = a * a+b * b;          <br/>        if (n &amp; mask &gt; 0) {<br/>            b = b * (b + 2 * a);  <br/>            a = c;                <br/>        } else {<br/>            a = a * (2 * b - a);  <br/>            b = c;                <br/>        }<br/>        mask &gt;&gt;= 1;<br/>    }<br/>    return a;<br/>}</span></pre><p id="2b88" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">为了好玩，我跑了一下<code class="eh lw lx ly kk b">fib3(1026281039383259811539107)</code>，只花了~16k的油。现在<em class="ke">那个</em>好看！</p><blockquote class="lz"><p id="0933" class="ma mb ht bd mc md me mf mg mh mi kc ek translated"><a class="ae kd" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mk ml mm mn mo iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mj"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>