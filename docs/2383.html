<html>
<head>
<title>The RV Bounded Model Checker — A lightweight semantics-based tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RV有界模型检查器——一个轻量级的基于语义的工具</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/the-rv-bounded-model-checker-a-lightweight-semantics-based-tool-35a6e37ce1c1?source=collection_archive---------6-----------------------#2019-08-30">https://medium.com/coinmonks/the-rv-bounded-model-checker-a-lightweight-semantics-based-tool-35a6e37ce1c1?source=collection_archive---------6-----------------------#2019-08-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="a422" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">作者:张懿</h2></div><p id="4b28" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">智能合约失败可能会造成数百万美元的损失，甚至可能导致公司和加密货币的死亡。此外，智能合约比普通软件更容易被黑客攻击，原因很简单，因为它们在区块链是公开的，任何人都可以从任何地方调用它们。因此，前所未有地需要保证代码的正确性。</p><p id="9af9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">众所周知，保证代码正确性的唯一方法是通过使用严格的形式方法，其中智能合约的正确性在数学上被表示为形式属性，编程语言或虚拟机也在数学上被表示为形式模型，并且前者从后者被严格证明。此外，智能合约的正确性必须是可独立检查的，而不必信任其作者或任何审计机构。因此，必须为它们提供机器可检查的正确性证书。</p><p id="027a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们在Runtime Verification (RV)开发了一个语言参数化的、完全成熟的智能合约形式验证工具，基于<a class="ae ke" href="http://matching-logic.org" rel="noopener ugc nofollow" target="_blank">匹配μ logic </a>，并结合了由形式方法社区开发的最佳技术、算法和数学基础。该工具是语言参数化的，这意味着它可以通过简单地插入语言的正式语义来快速实例化任何语言(或虚拟机)。目前，我们已经为EVM实例化了它，并使用EVM验证器<a class="ae ke" href="https://github.com/runtimeverification/verified-smart-contracts/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">来验证高规格智能合约</a>的全部功能正确性，包括ERC20令牌合约、以太坊卡斯珀FFG合约和DappHub MakerDAO合约。</p><p id="589b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然而，完全成熟的验证器需要相当大的努力和专业知识来使用。例如，设计和调试正式规范对于非专家来说是一项非常重要的任务。这项任务不仅需要大量的定理证明和逻辑知识，而且可能需要用户识别定制的抽象和相应的引理来推理某些程序行为。由于这些原因，我们当前的正式验证工具本质上是交互式的，只有少数专家能够有效地使用它。因此，尽管其基于语义的严格性，我们现有的正式验证工具的使用在我们的团队之外相当有限，并且我们认为在合同开发的早期阶段和/或日常基础上，或者由负担不起大量正式验证工作的小企业尝试使用它是不切实际的。</p><p id="e141" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了将正式技术引入日常合同开发，我们正在为合同开发人员开发一个全自动、轻量级的正式验证工具。该工具将作为<a class="ae ke" href="https://github.com/kframework/kore" rel="noopener ugc nofollow" target="_blank"> K的haskell后端</a>的一个组件提供给社区。这个工具是全自动的，因为除了提供程序和一组要验证的属性之外，它不需要额外的人工努力。这些属性可以是对任何程序通用的预定义属性，例如无溢出或被零除，或者其他用户定义的属性(例如，断言)。此外，该工具将仍然提供与完全成熟的验证者相同的关于某些执行步骤界限的完全形式保证。</p><p id="fa6c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">示例属性:</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="fe ff kf"><img src="../Images/e77cffb944ac8c789a09f4f247d38b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cViuUh53QuVqHnGH.png"/></div></div></figure><blockquote class="kr ks kt"><p id="33ce" class="ji jj ku jk b jl jm iu jn jo jp ix jq kv js jt ju kw jw jx jy kx ka kb kc kd hm dt translated"><em class="ht">在所有执行路径(AG)上，如果发生被零除的情况，程序将最终终止(EF)在恢复状态。注意:AG和EF是</em> <a class="ae ke" href="https://en.wikipedia.org/wiki/Computation_tree_logic" rel="noopener ugc nofollow" target="_blank"> <em class="ht">计算树逻辑</em> </a> <em class="ht"> (CTL)引入的时态运算符，在匹配μ逻辑中很容易定义(在本</em><a class="ae ke" href="http://fsl.cs.illinois.edu/index.php/Matching_mu-Logic" rel="noopener ugc nofollow" target="_blank"><em class="ht">【LICS】19论文</em> </a> <em class="ht">)。</em></p></blockquote><p id="0aac" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们的工具将如下工作。从一个通用的符号初始状态开始，它将象征性地执行整个程序，这将试图给出程序执行中所有可能的路径和(符号)状态。只要达到违反任何属性的状态，就会报告错误。然而，如果程序具有无界循环或递归，则在没有人工指导的情况下，符号执行可能不会终止(即，注释循环不变量)。为了使工具完全自动化，循环将展开到有限的迭代次数，称为一个界限。在这种情况下，该工具将显式地报告可能仍然存在潜在bug的未探索的迭代！。此外，基于我们在手动验证智能合约时积累的丰富经验，我们提出了一组通用的引理和抽象，它们将加速状态探索。</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="fe ff ky"><img src="../Images/6aef793aacbe7e74f398b850cd6c58a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sM2yNm9k1BzfCXpb.png"/></div></div></figure><p id="eabc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在智能合约的上下文中，我们实现这种BMC技术的概念验证工具非常有用和有效。这是因为智能合约通常是小而终止的程序，很少有循环或递归。像Vyper这样的语言甚至不允许递归调用和无限长循环作为语言设计的一部分。因此，预计在大多数情况下，我们的工具将不仅仅是查找bug。事实上，它将能够完全自动地证明大多数智能契约的功能正确性。</p><figure class="kg kh ki kj fq kk fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/e7b1dbc6a532a697c6844fdf0f0bbd30.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*HrFLDXz92JavTZXjhmvU7g.png"/></div></figure><blockquote class="la"><p id="ded0" class="lb lc ht bd ld le lf lg lh li lj kd ek translated"><a class="ae ke" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="ll lm ln lo lp kk fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lk"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>