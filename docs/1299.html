<html>
<head>
<title>Solidity and Prime Numbers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实度和质数</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-and-prime-numbers-2fe5dad33d4a?source=collection_archive---------7-----------------------#2018-08-12">https://medium.com/coinmonks/solidity-and-prime-numbers-2fe5dad33d4a?source=collection_archive---------7-----------------------#2018-08-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="5d99" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">减少以太坊智能合约的构造者传递的参数的思想实验。</h2></div><p id="d2f3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">约翰·夸恩斯特罗姆</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="fe ff ke"><img src="../Images/51daf083372a00ee1d5dd9de26819311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k_Um12LpQyZdNsyE.jpg"/></div></div></figure></div><div class="ab cl kq kr hb ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hm hn ho hp hq"><p id="8ecb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">假设我们正在编写一个“工厂”智能合同——它将作为发布数百个其他独特合同的蓝图。我们打算通过这些契约来管理支付偏好，因为它们将接受一个或多个Stablecoins作为契约的特定用例的“支付”。</p><p id="2aad" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">挑战:</strong>用户有不同的偏好——有些人会接受DAI或Tether，有些人会接受TrueUSD和DAI，有些人会<em class="kx">只</em>接受Basis。</p><p id="2350" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们如何通过构造函数无缝地管理所有这些参数呢？对于这个例子，让我们假设有五个不同的Stablecoins商家/交易者/任何人想要接受。</p></div><div class="ab cl kq kr hb ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hm hn ho hp hq"><p id="318c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">选项# 1</strong>(Lame)——在构造函数中传递五个不同的布尔参数，并将它们分配给各个布尔变量:</p><pre class="kf kg kh ki fq ky kz la lb aw lc dt"><span id="6796" class="ld le ht kz b fv lf lg l lh li"><em class="kx">constructor (bool _dai, bool _trueusd, bool _tether, ... ) {</em></span><span id="6926" class="ld le ht kz b fv lj lg l lh li"><em class="kx">    DAI_Accepted = _dai;</em></span><span id="d9a2" class="ld le ht kz b fv lj lg l lh li"><em class="kx">    TrueUSD_Accepted = _trueusd;</em></span><span id="6529" class="ld le ht kz b fv lj lg l lh li"><em class="kx">   Tether_Accepted = _tether;</em></span><span id="c38c" class="ld le ht kz b fv lj lg l lh li"><em class="kx">}</em></span></pre><p id="69b1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这种选择是可以接受的。在接受支付时，我们可以使用修饰符来检查状态变量(例如DAI_Accepted)是否为真。</p><p id="1d0f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">有没有更简单的方法，不需要传递5+个参数？<br/> <em class="kx">是的。</em></p></div><div class="ab cl kq kr hb ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hm hn ho hp hq"><p id="d8cb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">选项#2 </strong>(酷)—传递一个单位，它是对应于真值表的素数的倍数。</p><p id="bc4e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">假设我们有五个不同的稳定点:<br/> <strong class="jk hu">戴</strong><strong class="jk hu">true USD</strong><strong class="jk hu">系绳</strong><strong class="jk hu">基础</strong><strong class="jk hu">避风港</strong> (Havven？)</p><p id="d5ec" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们创建一个二进制真值表，而不是传递五个布尔参数，该真值表利用1和0的序列来创建一个唯一的<strong class="jk hu"> uint </strong>，该uint将存储特定智能合约的支付首选项。</p><p id="5afd" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这将是5个1和0的序列，产生2⁵组合(32)，如下表所示。左边第一个位置代表戴和智能合约是否接受(0 =否，1 =是)。第二个位置代表TrueUSD，依此类推。</p><p id="e269" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">最上面的一列代表质数，我们将乘以该质数以获得右边的最终“支付偏好”数。这个数是不是我们等式的一部分，是由对应的0/1决定的。</p></div><div class="ab cl kq kr hb ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hm hn ho hp hq"><pre class="kf kg kh ki fq ky kz la lb aw lc dt"><span id="4bbd" class="ld le ht kz b fv lf lg l lh li"><strong class="kz hu"><em class="kx">DAI — TrueUSD — Tether — Basis — Haven</em></strong></span><span id="ece8" class="ld le ht kz b fv lj lg l lh li"><strong class="kz hu">3–5–7–11–13</strong></span><span id="f33c" class="ld le ht kz b fv lj lg l lh li">0–0–0–0–0 = <strong class="kz hu">2</strong> … no Stablecoin accepted<br/>0–0–0–0–1 = <strong class="kz hu">13 </strong>… only Haven accepted<br/>0–0–0–1–0 = <strong class="kz hu">11</strong> … only Basis accepted<br/>0–0–0–1–1 = <strong class="kz hu">143</strong><br/>0–0–1–0–0 = <strong class="kz hu">7</strong> … only Tether accepted<br/>0–0–1–0–1 = <strong class="kz hu">91</strong><br/>0–0–1–1–0 = <strong class="kz hu">77</strong><br/>0–0–1–1–1 = <strong class="kz hu">1,001</strong><br/>0–1–0–0–0 = <strong class="kz hu">5</strong> … only TrueUSD accepted<br/>0–1–0–0–1 = <strong class="kz hu">65</strong><br/>0–1–0–1–0 = <strong class="kz hu">55</strong><br/>0–1–0–1–1 = <strong class="kz hu">715</strong><br/>0–1–1–0–0 = <strong class="kz hu">35</strong><br/>0–1–1–0–1 = <strong class="kz hu">455</strong><br/>0–1–1–1–0 = <strong class="kz hu">385</strong><br/>0–1–1–1–1 = <strong class="kz hu">5,005</strong><br/>1–0–0–0–0 = <strong class="kz hu">3</strong> … only DAI accepted<br/>1–0–0–0–1 = <strong class="kz hu">39</strong><br/>1–0–0–1–0 = <strong class="kz hu">33</strong><br/>1–0–0–1–1 = <strong class="kz hu">429</strong><br/>1–0–1–0–0 = <strong class="kz hu">21</strong><br/>1–0–1–0–1 = <strong class="kz hu">273</strong><br/>1–0–1–1–0 = <strong class="kz hu">231</strong><br/>1–0–1–1–1 = <strong class="kz hu">3,003</strong><br/>1–1–0–0–0 = <strong class="kz hu">15</strong> … only DAI &amp; TrueUSD accepted (my preference!)<br/>1–1–0–0–1 = <strong class="kz hu">195</strong><br/>1–1–0–1–0 = <strong class="kz hu">165</strong><br/>1–1–0–1–1 = <strong class="kz hu">2,145</strong><br/>1–1–1–0–0 = <strong class="kz hu">105</strong><br/>1–1–1–0–1 = <strong class="kz hu">1,365</strong><br/>1–1–1–1–0 = <strong class="kz hu">1,155</strong><br/>1–1–1–1–1 = <strong class="kz hu">15,015</strong> … all stablecoins accepted</span></pre><p id="a88d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">右边的结果数字可以在稍后使用修饰符中的模计算来引用。</p><p id="486d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们想象一个独特的金融合约，它接受稳定的硬币，以换取释放托管的资金(以太坊、ERC20代币、ERC721小饰品)。这些资金已经存在于合同中，我们假设有一个唯一的买家将接收这些资金(公共地址买家)。</p><pre class="kf kg kh ki fq ky kz la lb aw lc dt"><span id="838d" class="ld le ht kz b fv lf lg l lh li">// Contract is initialized with _paymentMethod = 15, then stored in the Payment_Preference variable. This will enable payments of either DAI or TrueUSD.</span><span id="8635" class="ld le ht kz b fv lj lg l lh li">constructor (uint _paymentMethod) {<br/>    Payment_Preference = _paymentMethod;<br/>}<br/></span><span id="2d69" class="ld le ht kz b fv lj lg l lh li">// A modifier to determine if payment is valid.</span><span id="4435" class="ld le ht kz b fv lj lg l lh li">modifier isValid(uint _mod) {<br/>    require( (Payment_Preference % _mod) == 0);<br/>    _;<br/>}<br/></span><span id="28c8" class="ld le ht kz b fv lj lg l lh li">// A set of functions to initiate payment acceptance.</span><span id="1644" class="ld le ht kz b fv lj lg l lh li">function acceptDAI()     isValid(3) { ... }<br/>function acceptTrueUSD() isValid(5) { ... }<br/>function acceptTether()  isValid(7) { ... }<br/>function acceptBasis()   isValid(11) { ... }<br/>function acceptHaven()   isValid(13) { ... }</span></pre><p id="eabb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">下一步将是模块化支付接受函数，将accept形式的所有函数<stablecoin>()浓缩成一个单一的模块化函数，该函数访问对应于用于除法的稳定货币和质数的键:值对结构。</stablecoin></p><p id="3d20" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这是否优化了我们的汽油成本？<em class="kx">也许——这可能会增加它们的数量。</em></p><p id="87b9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这会导致我们的代码更加模块化吗？<em class="kx">一定。</em></p><p id="07a9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">最终，这是我正在尝试的一种方法，以减少通过构造函数传递的参数数量。随着其他机制被引入智能合同，这可能会导致更有用的应用。</p></div><div class="ab cl kq kr hb ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hm hn ho hp hq"><blockquote class="lk ll lm"><p id="d244" class="ji jj kx jk b jl jm iu jn jo jp ix jq ln js jt ju lo jw jx jy lp ka kb kc kd hm dt translated"><strong class="jk hu">John quarn strom</strong><br/>www . inveth . io(暂时脱机)</p></blockquote></div></div>    
</body>
</html>