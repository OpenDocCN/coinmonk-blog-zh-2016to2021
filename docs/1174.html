<html>
<head>
<title>Attack on Pseudo-random number generator(PRNG) used in Cryptogs, an Ethereum (CVE-2018–14715)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">攻击以太坊Cryptogs(CVE-2018–14715)中使用的伪随机数发生器(PRNG)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/attack-on-pseudo-random-number-generator-prng-used-in-cryptogs-an-ethereum-cve-2018-14715-f63a51ac2eb9?source=collection_archive---------9-----------------------#2018-07-30">https://medium.com/coinmonks/attack-on-pseudo-random-number-generator-prng-used-in-cryptogs-an-ethereum-cve-2018-14715-f63a51ac2eb9?source=collection_archive---------9-----------------------#2018-07-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><h1 id="0b17" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">摘要</h1><p id="0059" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><a class="ae km" href="https://cryptogs.io/" rel="noopener ugc nofollow" target="_blank"> Cryptogs </a>是以太坊区块链[1]上的pogs游戏。这是一种唇枪舌剑的游戏。这个游戏使用<code class="eh kn ko kp kq b">blockhash(uint blockNumber)</code>产生随机数来决定赢家。在Solidity中，当<code class="eh kn ko kp kq b">blockNumber</code>距离当前块(<code class="eh kn ko kp kq b">block.number</code>)<a class="ae km" href="https://solidity.readthedocs.io/en/latest/units-and-global-variables.html" rel="noopener ugc nofollow" target="_blank">【2】</a>大于256块时，<code class="eh kn ko kp kq b">blockhash(uint blockNumber)</code>函数返回‘0’。Cryptogs不会检查<code class="eh kn ko kp kq b">blockNumber</code>是否太旧，因此攻击者可以预测随机数并总是获胜。</p><h1 id="4af7" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">细节</h1><p id="e2aa" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">产生随机数的函数有两个:<code class="eh kn ko kp kq b">endCoinFlip()</code>和<code class="eh kn ko kp kq b">throwSlammer()</code>。两个功能都需要预备功能:<code class="eh kn ko kp kq b">startCoinFlip()</code>和<code class="eh kn ko kp kq b">raiseSlammer()</code>。</p><p id="603a" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">首先我们来检查一下<code class="eh kn ko kp kq b">startCoinFlip()</code>和<code class="eh kn ko kp kq b">endCoinFlip()</code>。这两个函数决定谁先走。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff kw"><img src="../Images/18a4d1801b101a375f60f4d76ddaf9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cxzRGREs_sbHVr8IqClHTw.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Figure 1. startCoinFlip()</figcaption></figure><p id="aa7e" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">在<code class="eh kn ko kp kq b">startCoinFlip()</code>中，将当前块号<code class="eh kn ko kp kq b">block.number</code>存储到<code class="eh kn ko kp kq b">commitBlock[_stack]</code>中。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff lm"><img src="../Images/3d80d26e5bad3a6c1f60ca8efb822c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-V_Exo9qRfgy7qglczKQw.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Figure 2. endCoinFlip()</figcaption></figure><p id="8321" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">调用<code class="eh kn ko kp kq b">startCoinFlip()</code>后，玩家要调用<code class="eh kn ko kp kq b">endCoinFlip()</code>。在<code class="eh kn ko kp kq b">endCoinFlip()</code>中，它使用带有<code class="eh kn ko kp kq b">_reveal</code>的<code class="eh kn ko kp kq b">keccak256()</code>和<code class="eh kn ko kp kq b">commitBlock[_stack]</code>的blockhash生成随机数。如图2所示，在第464行，<code class="eh kn ko kp kq b">uint32(block.number) &gt; commitBlock[_stack]</code>是<code class="eh kn ko kp kq b">commitBlock[_stack]</code>的唯一条件。所以玩家可以在很长一段时间后调用<code class="eh kn ko kp kq b">endCoinFlip()</code>。然而在坚固性上，<code class="eh kn ko kp kq b">blockhash(uint blockNumber)</code>只对256个最近的块<a class="ae km" href="https://solidity.readthedocs.io/en/latest/units-and-global-variables.html" rel="noopener ugc nofollow" target="_blank">【2】</a>有效。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff ln"><img src="../Images/e7c289341c1fa994cbac6c6883c97d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34tAwRV8uqfXqyVW-30Gkw.png"/></div></div></figure><p id="0a58" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">如果<code class="eh kn ko kp kq b">blockNumber</code>比当前块老256块，则<code class="eh kn ko kp kq b">blockhash(uint blockNumber)</code>返回‘0’。因此，如果玩家在呼叫<code class="eh kn ko kp kq b">startCoinFlip()</code>的256个街区之后呼叫<code class="eh kn ko kp kq b">endCoinFlip()</code>，则<code class="eh kn ko kp kq b">pseudoRandomHash</code>与<code class="eh kn ko kp kq b">keccak256(_reveal, 0)</code>相同，因为<code class="eh kn ko kp kq b">block.blockhash(commitBlock[_stack])</code>为‘0’。<code class="eh kn ko kp kq b">_reveal</code>是<code class="eh kn ko kp kq b">endCoinFlip()</code>的一个参数，玩家可以随便放什么。所以攻击者可以生成随机数，得到第一阶。</p><p id="85cc" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">接下来，<code class="eh kn ko kp kq b">raiseSlammer()</code>和<code class="eh kn ko kp kq b">throwSlammer()</code>有同样的漏洞。在<code class="eh kn ko kp kq b">raiseSlammer()</code>中，当前块号<code class="eh kn ko kp kq b">block.number</code>被存储到<code class="eh kn ko kp kq b">commitBlock[_stack]</code>中。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff lo"><img src="../Images/c35d77bc3cbba688d723acffa89a6eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Un9-DSb3bNAaS-RPKbd0Q.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Figure 3. raiseSlammer()</figcaption></figure><p id="aec3" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">然后，以与第554行的<code class="eh kn ko kp kq b">endCoinFlip()</code>相同的方式计算<code class="eh kn ko kp kq b">pseudoRandomHash</code>。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff lp"><img src="../Images/36736690e6cfcddad4d70ac170158457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*73LX_XSl9d1-ehmYiUKAkA.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Figure 4. a part of throwSlammer()</figcaption></figure><p id="da8c" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">在第573行，选择<code class="eh kn ko kp kq b">pseudoRandomHash</code>的一个字节作为<code class="eh kn ko kp kq b">thisFlipper</code>。在第575行，检查<code class="eh kn ko kp kq b">thisFlipper</code>是否低于80。如果低于80，则翻转一次pog，该回合的玩家获得该pog。</p><p id="6caa" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">就像<code class="eh kn ko kp kq b">endCoinFlip()</code>一样，如果攻击者在呼叫<code class="eh kn ko kp kq b">raiseSlammer()</code>的256个街区后呼叫<code class="eh kn ko kp kq b">throwSlammer()</code>，<code class="eh kn ko kp kq b">keccak256(_reveal, block.blockhash(commitBlock[_stack])</code>与<code class="eh kn ko kp kq b">keccak256(_reveal, 0)</code>相同。因此，攻击者可以生成他们想要的<code class="eh kn ko kp kq b">pseudoRandomNumber</code>并获得所有的pog。</p><h1 id="c8a4" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">剥削</h1><p id="7a3f" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">因此，攻击场景如下:</p><ol class=""><li id="36a9" class="lq lr ht jq b jr kr jv ks jz ls kd lt kh lu kl lv lw lx ly dt translated">创建一个新游戏，等待受害者加入游戏。</li><li id="d665" class="lq lr ht jq b jr lz jv ma jz mb kd mc kh md kl lv lw lx ly dt translated">调用<code class="eh kn ko kp kq b">startCoinFlip()</code>并等待，直到生成256个块</li><li id="06aa" class="lq lr ht jq b jr lz jv ma jz mb kd mc kh md kl lv lw lx ly dt translated">256块后调用<code class="eh kn ko kp kq b">endCoinFlip()</code>得到第一单</li><li id="aa8a" class="lq lr ht jq b jr lz jv ma jz mb kd mc kh md kl lv lw lx ly dt translated">调用<code class="eh kn ko kp kq b">raiseSlammer()</code>并等待直到生成256个块</li><li id="e478" class="lq lr ht jq b jr lz jv ma jz mb kd mc kh md kl lv lw lx ly dt translated">在256个街区之后，呼叫<code class="eh kn ko kp kq b">throwSlammer()</code>并且在第一回合获得所有的pog</li></ol><p id="13f1" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">如果我们想按上述情况进行，我们应该计算满足以下条件的合适的<code class="eh kn ko kp kq b">pseudoRandomNumber</code>:</p><ol class=""><li id="abcf" class="lq lr ht jq b jr kr jv ks jz ls kd lt kh lu kl lv lw lx ly dt translated">偶数→获得第一个订单</li><li id="d8ef" class="lq lr ht jq b jr lz jv ma jz mb kd mc kh md kl lv lw lx ly dt translated">最高有效字节的所有10个字节都低于80 →在第一轮获得所有10个pog</li></ol><p id="77d3" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">由于该漏洞，<code class="eh kn ko kp kq b">pseudoRandomNumber</code>被计算为<code class="eh kn ko kp kq b">keccak256(_reveal, 0)</code>。所以我发现当<code class="eh kn ko kp kq b">_reveal</code>为'<strong class="jq hu"> 0x20182 </strong>'，<code class="eh kn ko kp kq b">pseudoRandomNumber</code>为'<strong class="jq hu">0x 262 f 33140 b 273901193 BC 3c c 78 C5 c 7 f 6 a BF 498 af 8 cc 1 FAA fc 5d 5454 DD 63 e 3 dec</strong>'满足以上两个条件。</p><p id="eba7" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">我在Ropsten测试网<a class="ae km" href="https://ropsten.etherscan.io/tx/0xed84edc7644eb4da5f91182b8bb638e9e7ad8cb2f17ebfec9d14ecca542a3a9c" rel="noopener ugc nofollow" target="_blank">【3】</a>开发了Cryptogs。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff me"><img src="../Images/510e61d417d9d6d52fb15c32145012d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Eg3GPfSQl6BAe1Wt6tpXnQ.gif"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Figure 5. exploit result</figcaption></figure><p id="6e8a" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">图5显示了我记录的利用结果。如你所见，我可以在第一回合获得所有10个pog。</p><h1 id="fd25" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">报告</h1><p id="e4ac" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我向开发商反映，他很快回复了我。他说他可能不会修复漏洞，因为Cryptogs中没有玩家。所以，我不建议玩密码游戏。但是，他说他将检查他的新游戏<a class="ae km" href="https://austingriffith.com/portfolio/galleass/" rel="noopener ugc nofollow" target="_blank"> Galleass </a>，是否存在同样的漏洞。</p><p id="61bf" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">令人惊讶的是，他给了我一些虫子赏金。起初我拒绝了赏金，但他一直试图把赏金给我，所以我终于收到了赏金。到目前为止，我发现了几个脆弱的智能合同，但他是第一个给予赏金的开发者。作为一个安全研究者，我觉得应该有更多像Cryptogs的开发者这样的人。所以，我希望捕虫者得到适当的补偿。</p><h1 id="7a0e" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">结论</h1><p id="4434" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">当你使用blockhash生成随机数时，你应该提醒一下<code class="eh kn ko kp kq b">blockhash(uint blockNumber)</code>只适用于256个最近的块。如果您尝试将<code class="eh kn ko kp kq b">blockhash</code>与太旧的块一起使用，它将返回‘0’。</p><h1 id="c4d7" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">参考</h1><p id="e83c" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">[1]<a class="ae km" href="https://cryptogs.io/" rel="noopener ugc nofollow" target="_blank">https://cryptogs . io</a></p><p id="36d4" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">[2]<a class="ae km" href="https://solidity.readthedocs.io/en/latest/units-and-global-variables.html" rel="noopener ugc nofollow" target="_blank">https://solidity . readthedocs . io/en/latest/units-and-global-variables . html</a></p><p id="a25f" class="pw-post-body-paragraph jo jp ht jq b jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh kv kj kk kl hm dt translated">[3]<a class="ae km" href="https://ropsten.etherscan.io/tx/0xed84edc7644eb4da5f91182b8bb638e9e7ad8cb2f17ebfec9d14ecca542a3a9c" rel="noopener ugc nofollow" target="_blank">https://ropsten . ethers can . io/tx/0 xed 84 EDC 7644 EB 4 da 5 f 91182 b 8 bb 638 e 9 e 7 ad 8 CB 2 f 17 ebfec 9d 14 ecca 542 a 3 a9 c</a></p><blockquote class="mf"><p id="60bf" class="mg mh ht bd mi mj mk ml mm mn mo kl ek translated"><a class="ae km" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mq mr ms mt mu lb fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mp"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>