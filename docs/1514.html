<html>
<head>
<title>Cryptocurrency UX and Key Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加密货币UX和密钥管理</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/crypto-ux-and-key-management-6e35b3cd466d?source=collection_archive---------8-----------------------#2018-09-17">https://medium.com/coinmonks/crypto-ux-and-key-management-6e35b3cd466d?source=collection_archive---------8-----------------------#2018-09-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/0ea825af40d213393e0b55c7116f0c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0NGbTkrcIIQ5Z1xPpuPYiA.jpeg"/></div></div></figure><p id="3271" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">用户体验是大规模采用加密货币的最大障碍之一。与Whatsapp在许多国家突然成为主导的安全消息应用程序类似，加密货币领域也有机会通过简化用户体验获得大规模采用。包含在UX这个刻意宽泛的话题中的有:</p><ul class=""><li id="262d" class="jz ka ht jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated">入职(痛苦的KYC经历，对开始需要什么的困惑)</li><li id="b90d" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">用户交互(地址、不熟悉的登录/模式/动作、终结效果、过于混乱的视图)</li><li id="4a44" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">教育(wtf是加密货币？区块链？钱包？交流？气体？)</li><li id="e93f" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">价格稳定(我为什么要用这个？太不稳定了)</li><li id="d199" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">密钥管理(私钥的存储、使用和添加/删除)</li><li id="f2c8" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">成本(可扩展性，eth 2.0/“Caspar McShardface”可被视为UX的“终极”长期目标)</li></ul><p id="4dba" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">密钥管理也许是一个合理的起点(与可伸缩性和稳定性相比！)密钥管理有许多不同的风格，并且从早期的密码学开始就作为一个研究领域存在。的确，对于加密货币的密钥管理问题，可以提供许多链外解决方案，例如<a class="ae kn" href="http://point-at-infinity.org/ssss/" rel="noopener ugc nofollow" target="_blank"> Shamir的秘密共享</a>、<a class="ae kn" href="https://github.com/dfinity/dkg" rel="noopener ugc nofollow" target="_blank">分布式密钥</a>、生成<a class="ae kn" href="https://wiki.parity.io/Secret-Store" rel="noopener ugc nofollow" target="_blank">存储</a>服务。然而，每一个都有自己的一系列挑战，UX当然也包括在内。</p><p id="955e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一组更简单、更容易实现的解决方案可能属于链上密钥管理的范畴。许多用户熟悉私钥的概念，或者至少在简单解释后理解这个概念。真正的难点在于这些密钥的实际管理，用户通常没有兴趣承担安全存储、备份、恢复和更改这些密钥所需的工作。受Multisig启发的链上密钥管理为其中一些挑战提供了解决方案。</p></div><div class="ab cl ko kp hb kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hm hn ho hp hq"><p id="f780" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">多什么？</strong></p><p id="a81e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">多重签名钱包对于加密货币领域的许多人来说是一个熟悉的概念，但尽管其概念过于简单，许多不熟悉该领域的人并不理解这个术语的含义，也不理解功能性多重签名结构的价值。为清楚起见，在本文中，我们认为多签名合同(通常)是一种设置，在发送/花费交易之前需要m/n签名(授权)。这些结构存在于传统银行业务中——在一个常见的简单案例中，两个合作伙伴可能有一个联合银行账户，每个人都有自己的借记卡/信用卡，从这个联合账户中消费。在密码术语中，这被认为是1/2多重信号。以太坊灵活的启动契约语言允许我们构建更高级的多重签名契约，施加任意的限制和允许，以及可调整的许可。</p><p id="0cbb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一种有趣的密钥管理方法是使用与多重签名结构相同的概念，但应用于私钥本身——例如，可以授权添加另一个私钥，而不是m-of-n授权消费。这可以称为“链上密钥管理”。这个想法(加上更多)是通过<a class="ae kn" href="https://github.com/ethereum/EIPs/issues/725" rel="noopener ugc nofollow" target="_blank"> ERC-725 </a>身份标准提案表达的。这个提议涵盖的不仅仅是在一个链上管理密钥的能力；可以认为它更接近于一个<a class="ae kn" href="http://www.lifewithalacrity.com/2016/04/the-path-to-self-soverereign-identity.html" rel="noopener ugc nofollow" target="_blank">自我主权身份</a>的规范(这些概念都是紧密相连的)，但是关键的管理原则是本文的主要兴趣所在。该标准已经获得了业界的极大关注，一个专门鼓励该标准发展的联盟<a class="ae kn" href="http://erc725alliance.org/" rel="noopener ugc nofollow" target="_blank">成立了</a>。我们将从讨论该标准开始，查看该标准的一个示例实现，检查它如何影响UX，并讨论该标准的扩展和限制。</p><p id="a2fa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> ERC-725 </strong></p><p id="ea35" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">从传统密钥管理的角度来看，ERC-725是一个在线密钥管理系统。该标准草案中涉及的每个密钥或者是公钥，或者是对应的以太坊地址，对应于链外私钥。每个键都有相应的<code class="eh kv kw kx ky b">keyType</code>、<code class="eh kv kw kx ky b">purpose</code>和实际<code class="eh kv kw kx ky b">key</code>值:</p><pre class="kz la lb lc fq ld ky le lf aw lg dt"><span id="008c" class="lh li ht ky b fv lj lk l ll lm">struct Key {<br/>    uint256 purpose;<br/>    uint256 keyType;<br/>    bytes32 key;<br/>}</span></pre><p id="8e19" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">到目前为止，已经定义了四个关键用途:<code class="eh kv kw kx ky b">MANAGEMENT</code>、<code class="eh kv kw kx ky b">ACTION</code>、<code class="eh kv kw kx ky b">CLAIM</code>、&amp;、<code class="eh kv kw kx ky b">ENCRYPTION</code>，按数值升序排列。<code class="eh kv kw kx ky b">MANAGEMENT</code>允许密钥执行管理类型的操作，例如添加或删除另一个密钥。<code class="eh kv kw kx ky b">ACTION</code>键不太“强大”,可能仅限于发送非管理事务。<code class="eh kv kw kx ky b">keyType</code>指定密钥相关的加密原语；RSA，椭圆曲线等。，尽管人们关心的是可以装入32个字节(256位)的密钥类型的数量。在ERC-725中，没有与每个密钥相关联的截止日期，这与uPort的ERC-1056提议形成对比。</p><p id="e27b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">索赔(或证明)和这些索赔的管理(<a class="ae kn" href="https://github.com/ethereum/EIPs/issues/725" rel="noopener ugc nofollow" target="_blank"> ERC-735 </a>索赔持有人)是ERC-725的一个很大的交织部分，但如前所述，主要焦点是检查关键的管理方面和这些带来的可用性的增加。ERC-725标准规定了实现应该遵守的高级功能，这些功能被认为符合该标准。为了说明的目的，更容易集中在一个实现上；处于<a class="ae kn" href="https://status.im/" rel="noopener ugc nofollow" target="_blank">地位的</a>，这是一家业内知名公司，目标是成为以太坊生态系统的一种移动网关。在他们的<a class="ae kn" href="https://github.com/status-im/contracts/tree/73-economic-abstraction/contracts/identity" rel="noopener ugc nofollow" target="_blank"> github库</a>中感兴趣的是<a class="ae kn" href="https://github.com/status-im/contracts/blob/73-economic-abstraction/contracts/identity/ERC725.sol" rel="noopener ugc nofollow" target="_blank"> ERC725 </a>和<a class="ae kn" href="https://github.com/status-im/contracts/blob/73-economic-abstraction/contracts/identity/Identity.sol" rel="noopener ugc nofollow" target="_blank"> Identity </a> Solidity契约。这不是实现该标准的唯一方法，但是突出了与在Solidity中编写智能合同相关的一些特征、模式和挑战。</p><p id="2b77" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> mynameisidentity.sol </strong></p><p id="edec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Identity.sol继承了ERC725和ERC735(在这个分析中我们将忽略它们)，这两个抽象的“接口”样式的契约。这意味着Identity.sol必须定义以下函数:</p><pre class="kz la lb lc fq ld ky le lf aw lg dt"><span id="4b31" class="lh li ht ky b fv lj lk l ll lm">function getKey(bytes32 _key, uint256 _purpose) public view returns(uint256 purpose, uint256 keyType, bytes32 key); </span><span id="2496" class="lh li ht ky b fv ln lk l ll lm">function getKeyPurpose(bytes32 _key) public view returns(uint256[] purpose); </span><span id="99d4" class="lh li ht ky b fv ln lk l ll lm">function getKeysByPurpose(uint256 _purpose) public view returns(bytes32[] keys); </span><span id="8932" class="lh li ht ky b fv ln lk l ll lm">function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) public returns (bool success); </span><span id="4cfc" class="lh li ht ky b fv ln lk l ll lm">function removeKey(bytes32 _key, uint256 _purpose) public returns (bool success); </span><span id="0d5a" class="lh li ht ky b fv ln lk l ll lm">function execute(address _to, uint256 _value, bytes _data) public returns (uint256 executionId); </span><span id="251e" class="lh li ht ky b fv ln lk l ll lm">function approve(uint256 _id, bool _approve) public returns (bool success);</span></pre><p id="1ebd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在讨论这些函数之前，我们定义了一些用于存储密钥的契约级变量、它们的相应用途以及每个密钥所需的或与之相关联的各种阈值:</p><pre class="kz la lb lc fq ld ky le lf aw lg dt"><span id="41b5" class="lh li ht ky b fv lj lk l ll lm">mapping(bytes32 =&gt; Key) keys; //keccak256(key, purpose)=&gt; Key Struct</span><span id="4b2b" class="lh li ht ky b fv ln lk l ll lm">mapping(uint256 =&gt; bytes32[]) keysByPurpose; //keys corresponding to each key purpose type (MANAGEMENT,ACTION, etc)</span><span id="6ec3" class="lh li ht ky b fv ln lk l ll lm">mapping(bytes32 =&gt; uint256) indexes; //indices of active keys</span><span id="ce7e" class="lh li ht ky b fv ln lk l ll lm">mapping(uint256 =&gt; uint256) purposeThreshold; //how many of keys are required to sign for that key purpose type (example: min of 1 for MANAGEMENT key)</span></pre><p id="8209" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">此外，交易被定义为:</p><pre class="kz la lb lc fq ld ky le lf aw lg dt"><span id="60cf" class="lh li ht ky b fv lj lk l ll lm">struct Transaction { <br/>   bool valid;  // flag to mark if tx is valid<br/>   address to;<br/>   uint256 value;<br/>   bytes data;<br/>   uint256 nonce; // tx nonce, not contract nonce<br/>   uint256 approverCount; // incremented by approve function<br/>   mapping(bytes32 =&gt; bool) approvals; //which keys have approved tx<br/>}</span></pre><p id="2d65" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">事务存储在映射中<code class="eh kv kw kx ky b">txx</code> —事务可能正在等待其他键的批准，这也防止了一种形式的重放攻击漏洞以及合同级别<code class="eh kv kw kx ky b">nonce</code>。为了检查关键管理功能，本合同的恢复相关字段/功能(<code class="eh kv kw kx ky b">recoveryContract</code>、<code class="eh kv kw kx ky b">recoveryManager</code>)在本分析中也被忽略。</p><pre class="kz la lb lc fq ld ky le lf aw lg dt"><span id="add4" class="lh li ht ky b fv lj lk l ll lm">mapping (uint256 =&gt; Transaction) txx; // generally should correspond to nonce =&gt; Transaction</span><span id="0620" class="lh li ht ky b fv ln lk l ll lm">uint256 nonce; // tx nonce to prevent replay attacks</span></pre><p id="d4ec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">添加、移除和更换钥匙</strong></p><p id="2b9f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">从外部可调用的“包装器”函数<code class="eh kv kw kx ky b">addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) public managementOnly returns (bool success)</code>开始，我们回忆起<code class="eh kv kw kx ky b">_key</code>参数可以是通用公钥或以太坊地址。实际上，在前面讨论的multisig环境中，该功能相当于添加一个授权消费者。</p><pre class="kz la lb lc fq ld ky le lf aw lg dt"><span id="d4ca" class="lh li ht ky b fv lj lk l ll lm">function addKey(bytes32 _key, uint256 _purpose, uint256 _type)<br/>public        <br/>managementOnly        <br/>returns (bool success)    <br/>{<br/>    _addKey(_key, _purpose, _type);<br/>    return true;<br/>}</span></pre><p id="ba09" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kv kw kx ky b">managementOnly</code>修饰符将对该函数的访问限制为内部调用，或者确保<code class="eh kv kw kx ky b">msg.sender</code>是一个<code class="eh kv kw kx ky b">MANAGEMENT</code>键。它通过无处不在的函数<code class="eh kv kw kx ky b">isKeyPurpose(bytes32 _key, uint256 _purpose)</code>来实现。该功能检查<code class="eh kv kw kx ky b">keys[keccak256(_key, _purpose)].purpose == _purpose</code>是否。注意，<code class="eh kv kw kx ky b">keys</code>映射不存储<code class="eh kv kw kx ky b">key.value =&gt; Key</code>的直接映射，而是存储键值和目的类型的keccak散列(<code class="eh kv kw kx ky b">keyHash</code>)。<code class="eh kv kw kx ky b">isKeyPurpose()</code>在整个合同中被调用，从而减少冗余代码，这是智能合同设计中的一个基本特征(由于部署/存储的高成本和安全分析/审计的增加的简易性)。</p><p id="ea6b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果<code class="eh kv kw kx ky b">managementOnly </code>修饰符允许函数调用继续，则调用内部受限的<code class="eh kv kw kx ky b">_addKey(bytes32 _key, uint256 _purpose, uint256 _type)</code>函数。该函数为传递的键计算<code class="eh kv kw kx ky b">keyHash</code>，确保该键尚未被添加，确保<code class="eh kv kw kx ky b">Key.keyType</code>已定义，然后将<code class="eh kv kw kx ky b">Key</code>添加到由<code class="eh kv kw kx ky b">keyHash</code>索引的<code class="eh kv kw kx ky b">key</code>映射中。</p><pre class="kz la lb lc fq ld ky le lf aw lg dt"><span id="421a" class="lh li ht ky b fv lj lk l ll lm">function _addKey( bytes32 _key, uint256 _purpose, uint256 _type ) private <br/>{ <br/>    bytes32 keyHash = keccak256(_key, _purpose);<br/>    require(keys[keyHash].purpose == 0); <br/>    <br/>    require( _purpose == MANAGEMENT_KEY || _purpose == ACTION_KEY ||<br/>    _purpose == CLAIM_SIGNER_KEY || _purpose == ENCRYPTION_KEY );<br/>    <br/>    keys[keyHash] = Key(_purpose, _type, _key);<br/>    indexes[keyHash] = keysByPurpose[_purpose].push(_key) — 1;<br/>    emit KeyAdded(_key, _purpose, _type);<br/>}</span></pre><p id="e58f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用<code class="eh kv kw kx ky b">_purpose</code>作为索引，<code class="eh kv kw kx ky b">_key</code>也被推入到<code class="eh kv kw kx ky b">keysByPurpose</code>映射中。例如，如果添加的是一个<code class="eh kv kw kx ky b">ACTION</code>键，这将增加存储在<code class="eh kv kw kx ky b">ACTION</code>索引下的键的数量(在<code class="eh kv kw kx ky b">ACTION</code>的情况下为2)。</p><p id="37c2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">还发出<code class="eh kv kw kx ky b">KeyAdded</code> <a class="ae kn" href="https://rinkeby.etherscan.io/tx/0x1071719b33598d3dbc8650cdba19700e268b025f293df7ccd6feb01d99f2ee64#eventlog" rel="noopener ugc nofollow" target="_blank">事件</a>，以便以太坊区块链之外的任何钱包/基础设施都可以反应/触发。</p><p id="a5d5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kv kw kx ky b"><a class="ae kn" href="https://github.com/status-im/contracts/blob/73-economic-abstraction/contracts/identity/Identity.sol#L147" rel="noopener ugc nofollow" target="_blank">removeKey(bytes32 _key, uint256 _purpose) public returns (bool success)</a></code>功能的工作方式与<code class="eh kv kw kx ky b">addKey()</code>基本相同，但(如预期的)方向相反。使用相同的<code class="eh kv kw kx ky b">managementOnly</code>限制器。键从<code class="eh kv kw kx ky b">key</code>映射中删除，并从<code class="eh kv kw kx ky b">keysByPurpose</code>映射中移除。一个<code class="eh kv kw kx ky b">KeyRemoved</code>事件也被触发。</p><p id="81e5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在ERC-725标准上以<code class="eh kv kw kx ky b">replaceKey</code>函数的形式提供了额外的功能，它先调用<code class="eh kv kw kx ky b">_addKey()</code>，然后调用<code class="eh kv kw kx ky b">_removeKey()</code>。</p><p id="5d44" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">ERC-725所需的其他关键功能</strong></p><p id="911c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kv kw kx ky b">getKeyPurpose(bytes32 _key)</code>和<code class="eh kv kw kx ky b">getKeysByPurpose(uint256 _purpose)</code>的行为与预期完全一致，其中<code class="eh kv kw kx ky b">getKeyPurpose</code>返回为被查询的<code class="eh kv kw kx ky b">_key</code>存储的目的。返回合同与那个<code class="eh kv kw kx ky b">_purpose</code>关联的所有键。</p><p id="847d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">批准并执行</strong></p><p id="33c9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Approve和execute是导致事务执行的两个外部可调用函数，前提是从适当的键类型获得足够的批准。这些函数是发送交易的主要接口。</p><pre class="kz la lb lc fq ld ky le lf aw lg dt"><span id="bed2" class="lh li ht ky b fv lj lk l ll lm">function execute(address _to, uint256 _value, bytes _data)         public <br/>returns (uint256 executionId)    <br/>{        <br/>    uint256 requiredKey = _to == address(this) ? MANAGEMENT_KEY :<br/>    ACTION_KEY;<br/>    if (purposeThreshold[requiredKey] == 1) {<br/>        executionId = nonce;          <br/>        nonce++;            <br/>        require(isKeyPurpose(bytes32(msg.sender), requiredKey));<br/>        _to.call.value(_value)(_data); <br/>        emit Executed(executionId, _to, _value, _data);<br/>    } <br/>    else {<br/>        executionId = _execute(_to, _value, _data); <br/>        approve(executionId, true);<br/>    }<br/>}</span></pre><p id="84b7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kv kw kx ky b">execute()</code>检查交易目的地是否是合同本身，如果是，则需要<code class="eh kv kw kx ky b">MANAGEMENT</code>键，如果不是<code class="eh kv kw kx ky b">ACTION</code>键。检查密钥类型的<code class="eh kv kw kx ky b">purposeThreshold</code>—如果该密钥用途类型只需要一个密钥，则使用<code class="eh kv kw kx ky b">isKeyPurpose</code>检查该密钥是否具有该用途，并使用低级调用<code class="eh kv kw kx ky b">_to.call.value(_value)(_data)</code>发送交易。如果特定键用途类型的<code class="eh kv kw kx ky b">purposeThreshold</code>不等于1，则调用内部<code class="eh kv kw kx ky b">_execute()</code>。这个内部函数构造一个<code class="eh kv kw kx ky b">Transaction</code>，设置<code class="eh kv kw kx ky b">approvalCount=0</code>，将其插入到<code class="eh kv kw kx ky b">txx</code>映射中，发出一个<code class="eh kv kw kx ky b">ExecutionRequested</code>事件并返回<code class="eh kv kw kx ky b">executionID</code>，这是契约级别<code class="eh kv kw kx ky b">nonce</code>。</p><p id="f8bf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后使用<code class="eh kv kw kx ky b">executionID</code>作为参数调用<code class="eh kv kw kx ky b">approve() </code>“包装器”函数。满足<code class="eh kv kw kx ky b">managerOrActor</code>修饰符后，调用<code class="eh kv kw kx ky b">_approve(bytes32(msg.sender), executionID, _approval=true)</code>。</p><pre class="kz la lb lc fq ld ky le lf aw lg dt"><span id="baca" class="lh li ht ky b fv lj lk l ll lm">function _approve(bytes32 _key, uint256 _id, bool _approval)         private         <br/>returns(bool success)<br/>{                <br/>    Transaction memory trx = txx[_id];<br/>    require(trx.valid);        <br/>    uint256 requiredKeyPurpose = trx.to == address(this) ?<br/>    MANAGEMENT_KEY : ACTION_KEY;<br/>    <br/>    require(isKeyPurpose(_key, requiredKeyPurpose));<br/>    bytes32 keyHash = keccak256(_key, requiredKeyPurpose);<br/>    require(txx[_id].approvals[keyHash] != _approval);<br/>    <br/>    if (_approval) {<br/>        trx.approverCount++;<br/>    }<br/>    else {<br/>        trx.approverCount--;<br/>    }<br/>    emit Approved(_id, _approval);<br/>    <br/>    if (trx.approverCount&lt;purposeThreshold[requiredKeyPurpose]) {<br/>        txx[_id].approvals[keyHash] = _approval;<br/>        txx[_id] = trx;<br/>    } <br/>    else {<br/>        delete txx[_id];<br/>        success = address(trx.to).call.value(trx.value)(trx.data);            <br/>        emit Executed(_id, trx.to, trx.value, trx.data);<br/>    }<br/>}</span></pre><p id="2c33" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">从<code class="eh kv kw kx ky b">txx</code>数组加载事务并检查其有效性。有趣的是，这里进行了优化以将事务加载到内存中(在基于256位堆栈的EVM中有三个内存“区域”——堆栈、内存和存储，按运行成本升序排列，按持久性和可访问性降序排列)。检查<code class="eh kv kw kx ky b">isKeyPurpose</code>并找到传递的键的<code class="eh kv kw kx ky b">keyHash</code>。事务处理的批准数组被检查为假。交易的<code class="eh kv kw kx ky b">approverCount</code>字段递增，并且如果对于<code class="eh kv kw kx ky b">requiredKeyPurpose</code>有足够的<code class="eh kv kw kx ky b">purposeThreshold</code>批准，则交易被发送:<code class="eh kv kw kx ky b">address(trx.to).call.value(trx.value)(trx.data).</code>如果没有足够的来自所需关键用途类型的适当批准，则该批准被添加到交易<code class="eh kv kw kx ky b">approvals</code>字段并保存回存储器，等待进一步所需的批准。</p><p id="3734" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这个实现展示了链上密钥管理的灵活性和多功能性，但也展示了智能合约变得复杂的速度。这种实现忽略了拥有不同<code class="eh kv kw kx ky b">keyType</code> (RSA、EC等)的能力。)因为这肯定会增加合同的复杂性。</p></div><div class="ab cl ko kp hb kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hm hn ho hp hq"><p id="9a1f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">一次性钥匙和无汽油交易</strong></p><p id="04a7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">设备丢失(不幸的是)很常见。最近的EOS ICO token到EOS mainnet的移植/转移事件表明，大约5%的用户丢失了他们的私钥，无法在时机成熟时将资金转移到EOS mainnet。这些用户中的大多数可能是相对精通技术的，他们首先参与了ICO，随着采用率的增加和技术意识较弱的用户加入进来，这一数字有望增加。</p><p id="0bd9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="lo">一次性键:</em>这些键更准确的术语是“上下文特定的应用程序键”。良好的用户体验包括由于丢失包含密钥的设备而遭受资金的完全损失。理想情况下，一次性密钥不包含货币值，但可能包含许可值。虽然非加密用户可能不太熟悉密钥管理的过程，但他们可能熟悉注销丢失的银行卡的过程，这是这种模式所模仿的。</p><p id="3a94" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">ERC-725促进了一次性密钥，天真地作为一个<code class="eh kv kw kx ky b">ACTION</code>密钥，结合由<a class="ae kn" href="https://github.com/status-im/contracts/blob/73-economic-abstraction/contracts/identity/IdentityGasRelay.sol" rel="noopener ugc nofollow" target="_blank"> IdentityGasRelay </a>中的逻辑引入的元事务能力。sol，它继承Identity.sol协定。各种关键授权用于支持无汽油交易功能。这份合同将在另一篇博文中分析。</p><p id="f568" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="lo">元或“无气”交易</em>:这与用户教育和密钥管理都有关系。不应期望最终用户理解停机问题或气体在防止停机中的作用。“其他人”需要为从一个设备发起的交易支付汽油，如果该设备包含一次性密钥并且该密钥不包含乙醚，因此没有能力发送交易。其他人可能是一群受到经济激励的中继者，或者仅仅是一个基于云的服务器。</p><p id="b929" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有<a class="ae kn" rel="noopener" href="/@austin_48503/ethereum-meta-transactions-90ccf0859e84">许多</a>不同的<a class="ae kn" rel="noopener" href="/gitcoin/technical-deep-dive-architecture-choices-for-subscriptions-on-the-blockchain-erc948-5fae89cabc7a">方法</a>来实现这一点，有几个不同的项目从不同的角度来应对挑战。事实上，一些链上架构模式对于订阅服务是有用的。<a class="ae kn" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1077.md" rel="noopener ugc nofollow" target="_blank"> ERC-1077 </a>是一个标准化这些可执行签名消息方法的提案，而<a class="ae kn" href="https://github.com/ethereum/EIPs/issues/948" rel="noopener ugc nofollow" target="_blank"> ERC-948 </a>试图对基于订阅的支付做同样的事情。</p><p id="7e63" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">限制</strong></p><p id="4298" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">隐私</strong>:和大多数以太坊基于链的计算一样，隐私是有限的。不考虑ERC-735公开证明/声明的隐私含义，在ERC-725中存在隐私泄露。例如，我想让整个区块链观测世界知道我添加了一个新的<code class="eh kv kw kx ky b">MANAGEMENT</code>键吗？这很容易辨认。这意味着什么？这是否会转化为现实世界风险的增加，以及如何转化？</p><p id="93b4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最终，通过使用零知识证明可以获得许多隐私方面的好处，这似乎特别适用于ERC-735声明，而不是该标准的关键管理方面。各种风格的证明将被构建，但是以太坊的当前状态验证起来很昂贵，而且实际上不可能生成，尽管存在验证预编译。</p><p id="b4dd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">成本</strong>:链上交易(目前)很贵。链上<a class="ae kn" href="https://eprint.iacr.org/2017/110.pdf" rel="noopener ugc nofollow" target="_blank">定制加密操作</a>甚至更昂贵。UX的最终目标是将可伸缩性提高到链上计算非常便宜的程度，以至于这类交易的成本实际上可以忽略不计，比如低于0.05美元，这是对当前发行新借记卡/信用卡的传统银行收费的重大改进。目前，部署的示例合同成本为4.17美元(@ 1ETH = 206美元，平均交易接受时间气价为5GWei)。添加第一个密钥的成本约为0.14美元。而移除第一个密钥的成本约为0.04美元。由于索引和存储相关的成本，这些成本会随着添加的密钥数量而略有不同。虽然部署可能被认为是昂贵的，但是添加和移除密钥是成本有效的。</p></div><div class="ab cl ko kp hb kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hm hn ho hp hq"><p id="fbd4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">解释Identity.sol和<a class="ae kn" href="https://github.com/status-im/contracts/blob/73-economic-abstraction/contracts/identity/IdentityGasRelay.sol" rel="noopener ugc nofollow" target="_blank"> IdentityGasRelay </a>的作用的后续帖子。无气交易的sol即将到来。</p><p id="7055" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在媒体上关注我或在推特上联系我:【https://twitter.com/gawnieg T2】</p><blockquote class="lp"><p id="9cc0" class="lq lr ht bd ls lt lu lv lw lx ly jy ek translated"><a class="ae kn" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="ma mb mc md me iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lz"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>