<html>
<head>
<title>Beginner’s guide to feeding data in Tensorflow — Part1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tensorflow中馈送数据的初学者指南—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/beginners-guide-to-feeding-data-in-tensorflow-faf21a745e4c?source=collection_archive---------0-----------------------#2018-06-23">https://medium.com/coinmonks/beginners-guide-to-feeding-data-in-tensorflow-faf21a745e4c?source=collection_archive---------0-----------------------#2018-06-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="6bd9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">嗨，这个系列是关于向tensorflow模型提供数据(图像和数字特征)的。阅读完所有帖子后，你将能够—</p><ol class=""><li id="aa3f" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated">将内存中的数据提供给模型。</li><li id="4548" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">将TFRecords格式提供给模型。</li><li id="4768" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">将磁盘上的原始图像输入到模型中。</li></ol><p id="f3b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这一部分中，我将重点关注内存中数据的输入。</p><p id="8f17" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这篇文章假设读者具备以下技能— <strong class="is hu">神经网络的基本工作原理，Tensorflow的基础知识或Keras中的基本建模知识。</strong></p><p id="b929" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这篇文章的代码可以在<a class="ae kc" href="https://gist.github.com/shang-vikas/36176e3bed6f3234fd1c27465d8bec22" rel="noopener ugc nofollow" target="_blank">这里找到。</a></p><p id="92e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们开始吧。</p></div><div class="ab cl kd ke hb kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hm hn ho hp hq"><p id="cd60" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">安装</strong></p><figure class="kl km kn ko fq kp fe ff paragraph-image"><div class="fe ff kk"><img src="../Images/42250e464e078330cba53587e66ff38f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*bk0bcNwkc_Z32fRJjEx6Gg.jpeg"/></div></figure><p id="26c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh ks kt ku kv b">pip install tensorflow-gpu keras</code></p><p id="a30b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">或者没有GPU的话，安装tensorflow的CPU版本。</p><p id="f05b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh ks kt ku kv b">pip install tensorflow keras</code></p><p id="6dd5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">数据集</strong></p><p id="a17c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将使用流行的MNIST数据集。它包含从0到9的数字图像。通常，该数据集以<strong class="is hu"> numpy数组</strong>格式提供。因此，我将提供代码来将数据转换为磁盘上的<a class="ae kc" href="https://gist.github.com/shang-vikas/509cc87d4b37694308f717b1cbb3585a" rel="noopener ugc nofollow" target="_blank"> TFRecords格式</a>和<a class="ae kc" href="https://gist.github.com/shang-vikas/3670a06f0e4bfc1a52f4847ac3d31c78" rel="noopener ugc nofollow" target="_blank"> raw图像</a>。</p><p id="2f16" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">使用估算器API </strong></p><p id="7af9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Tensorflow提供了高级估算器API，以最小的工作量定义您的模型。我们将使用这个API来构建我们的简单模型，该模型由100个神经元组成，每个神经元有10个输出层，因为数据集有<strong class="is hu"> 10个类。</strong></p><p id="4df5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当您使用Estimator API创建模型时，它会将数据集的要素列类型作为一个列表，在训练期间提供。由于我们使用包含数字的图像，我们将为其提供一个<strong class="is hu">数字类型</strong>的特征列。</p><pre class="kl km kn ko fq kw kv kx ky aw kz dt"><span id="da2a" class="la lb ht kv b fv lc ld l le lf">feature_column = [tf.feature_column.numeric_column(key=’image’,shape=(784,))]</span></pre><p id="fb11" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里的key是我们希望给这个特性列起的名字。请注意，在输入数据时，应该将相同的键传递给模型。</p><p id="ae98" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有关feature_columns类型的更详细列表，请访问<a class="ae kc" href="https://www.tensorflow.org/get_started/feature_columns" rel="noopener ugc nofollow" target="_blank"> tensorflow的文档</a>。</p><p id="7513" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，为了创建模型，我们将使用预先制作的估计器，特别是DNNClassifier，也称为深度神经网络分类器，可以根据需要添加任意多的密集层。</p><p id="8655" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"># #定义模型</p><pre class="kl km kn ko fq kw kv kx ky aw kz dt"><span id="d7d2" class="la lb ht kv b fv lc ld l le lf">model = tf.estimator.DNNClassifier([100,100],n_classes=10,feature_columns=feature_column)</span></pre><p id="7df2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们已经定义了我们的模型，让我们定义<strong class="is hu">数据集流。</strong></p><ol class=""><li id="6a5f" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated"><strong class="is hu">使用Numpy数组</strong></li></ol><pre class="kl km kn ko fq kw kv kx ky aw kz dt"><span id="b23c" class="la lb ht kv b fv lc ld l le lf">import numpy as np<br/>import pandas as pd<br/>from keras.datasets import mnist</span><span id="30ed" class="la lb ht kv b fv lg ld l le lf">(x_train,y_train),(x_test,y_test) = mnist.load_data()<br/>#since the model expects a single feature vector of size 784 #convert from (28,28) to 784 <br/>x_train = x_train.reshape(-1,784) <br/>x_test = x_test.reshape(-1,784)</span></pre><ul class=""><li id="b88a" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn lh ju jv jw dt translated">因为我们这里有numpy数组形式的数据。所以最简单的方法就是将数据传递给模型，对吗？？<strong class="is hu">正确。</strong> Tensorflow在<strong class="is hu"> tf.estimator.inputs下提供这个功能</strong>我们来传递数据，训练模型101步。这里的步骤是指模型看到的小批量的数量。默认批量是<strong class="is hu"> 128。</strong></li></ul><pre class="kl km kn ko fq kw kv kx ky aw kz dt"><span id="7cd3" class="la lb ht kv b fv lc ld l le lf">model.train(input_fn=tf.estimator.inputs.numpy_input_fn(<br/>dict({'image':x_train}),                                         np.array(y_train,np.int32),<br/>shuffle=True),steps=101)<br/></span></pre><p id="a537" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">输出应该是这样的-</p><figure class="kl km kn ko fq kp fe ff paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="fe ff li"><img src="../Images/42e5c4e002d65cf7137e30b5cdf44b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGsswPeQh95dJr0VS6ZykA.png"/></div></div></figure><p id="7892" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这样做很好，但是如果您想在将数据输入模型之前对其进行一些预处理，该怎么办呢？这里<strong class="is hu">数据集API </strong>来帮忙了。</p><p id="941a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">正如您在上面的代码行中看到的，model.train期望数据从输入函数中获得。因为该函数需要一个预处理函数，以防我们进行一些预处理，所以让我们编写一个预处理函数，将numpy数组转换为张量，并将数据类型更改为float32，因为密集层的权重是dtype float32。</p><p id="a9cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">注意:根据经验，总是首先将你的数据转换成张量(float32，int32 ),否则你会得到奇怪的错误，这会导致很多问题。</strong></p><pre class="kl km kn ko fq kw kv kx ky aw kz dt"><span id="82c4" class="la lb ht kv b fv lc ld l le lf">'''parse function to be used. This function is needed to do the preprocessing of data like reshaping ,converting to tensors from numpy arrays ,one-hot encoding ,etc.'''<br/>def _parse_and_preprocess(x,y):<br/>    x = tf.cast(x,tf.float32) <br/>    #cast to float32 as the weights are float32.<br/>    y = tf.cast(y,tf.int32) #cast to tensor of int32<br/>    return (dict({'image':x}),y) #return tuple of dict of feature # name with key as provided in the feature column and label.</span></pre><p id="6969" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在编写输入函数，返回一个生成器来获取下一批数据。</p><pre class="kl km kn ko fq kw kv kx ky aw kz dt"><span id="d56c" class="la lb ht kv b fv lc ld l le lf">##define the function that feeds the data to the model .<br/>def train_input_fn(x_train,y_train,batch_size=64):<br/>    ##Here we are using dataset API.<br/>    '''<br/>    take the data from tensor_slices i.e. an array of data-points in simple words.<br/>    '''<br/>    dataset =    tf.data.Dataset.from_tensor_slices((x_train,y_train)) <br/>    <br/>    <br/>    dataset = dataset.map(lambda x,y:_parse_and_preprocess(x,y)).shuffle(buffer_size=128) \<br/>                .batch(batch_size)</span><span id="34d9" class="la lb ht kv b fv lg ld l le lf">    dataset_iterator = dataset.make_one_shot_iterator()   <br/>    return dataset_iterator.get_next()</span></pre><p id="2e30" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里我们使用的是数据集API(tf.data.Dataset)。因为我们有数组形式的数据，所以我们可以调用from_tensor_slices方法并传递数据。</p><p id="9180" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我知道方法的名字是不明确的！！</p><p id="02ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">tensor_from_slices方法还获取存储在磁盘上的文件名列表。我将在下一篇文章中解释这一点。</p><p id="6f31" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您有一个包含各种数值和分类特征的数据集，那么您应该使用数据集API的<a class="ae kc" href="https://www.tensorflow.org/get_started/datasets_quickstart" rel="noopener ugc nofollow" target="_blank"> TextLineDataset </a>方法或tf.estimator.inputs的pandas_input_fn方法，但我强烈推荐前者。</p><p id="6f9d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">传入的数据现在被传递给我们编写的_parse_preprocess函数，并将返回一个由<strong class="is hu"> 2 </strong>元素组成的元组——第一个是包含键和图像<strong class="is hu">数据的字典，作为dtype tf.float32 </strong>的784张量，第二个是dtype tf.int32 的<strong class="is hu">标签。</strong></p><p id="47ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在顾名思义，<strong class="is hu">。洗牌()</strong>和<strong class="is hu">。batch() </strong>方法分别对数据进行混洗和批处理。</p><p id="f62b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了迭代这些数据点，我们调用<strong class="is hu"> make_one_shot_iterator </strong>返回迭代器，也称为生成器。</p><p id="ae38" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">的。get_next()只是返回下一批数据。</p><p id="2e46" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在是时候训练我们的模型了。</p><p id="672e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">注意:estimator.train()中的input_fn不接受函数中的参数。解决方法是使用python的lambda特性。</p><pre class="kl km kn ko fq kw kv kx ky aw kz dt"><span id="50e4" class="la lb ht kv b fv lc ld l le lf">import time<br/>t1 = time.time()<br/>model.train(input_fn=lambda:train_input_fn(x_train,y_train,64),steps=150)<br/>t2= time.time()<br/>print('time taken ---- \t {}'.format(t2 - t1))</span></pre><figure class="kl km kn ko fq kp fe ff paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="fe ff ln"><img src="../Images/e93d63bf23867a7659866bcfb3b0e3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9oLpdd7_7ncyXwxBoumvVA.png"/></div></div></figure><p id="2372" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">结论:</strong></p><p id="7352" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以上代码适用于numpy数组格式的图像数据。现在概括一下，不仅仅是图像数据，如果您有各种特性的数据，包括数字列、序数、名义类型，</p><ul class=""><li id="2c71" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn lh ju jv jw dt translated">创建模型时，只需在列表中传递特征名称。</li><li id="6c88" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated">使用tf.data.Dataset API中的TextLineDataset方法，而不是train_input_fn()中的from_tensor_slices。</li><li id="22c6" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated">将数据集映射到适当的预处理函数，该函数仍将返回包含具有dict和标签中适当键的特性的元组。</li><li id="c318" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated">然后洗牌，按要求分批，最后做一个迭代器，返回下一批。</li></ul><blockquote class="lo lp lq"><p id="57d3" class="iq ir lr is b it iu iv iw ix iy iz ja ls jc jd je lt jg jh ji lu jk jl jm jn hm dt translated">第二部分的链接在这里是<a class="ae kc" rel="noopener" href="/@16vikas96/beginners-guide-to-feeding-data-in-tensorflow-part2-5e2506d75429">。</a></p></blockquote><p id="a000" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">感谢您阅读帖子。如果你喜欢，请鼓掌。</p><blockquote class="lv"><p id="8e26" class="lw lx ht bd ly lz ma mb mc md me jn ek translated">加入Coinmonks <a class="ae kc" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae kc" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae kc" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="la lb ht bd mf mg mh mi mj mk ml mm mn jb mo mp mq jf mr ms mt jj mu mv mw mx dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="jo jp ht is b it my ix mz jb na jf nb jj nc jn lh ju jv jw dt translated"><a class="ae kc" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae kc" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="14e6" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated"><a class="ae kc" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae kc" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated"><a class="ae kc" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae kc" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="f33b" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated"><a class="ae kc" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae kc" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">最佳加密交易所</a></li><li id="47a8" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated">开发人员的最佳加密API</li><li id="b359" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated">最佳<a class="ae kc" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated">杠杆代币的终极指南</li><li id="95d1" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated"><a class="ae kc" href="https://coincodecap.com/best-vpns-for-crypto-trading" rel="noopener ugc nofollow" target="_blank">最适合加密交易的VPN</a></li><li id="918f" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated"><a class="ae kc" href="https://coincodecap.com/blockchain-analytics" rel="noopener ugc nofollow" target="_blank">最佳加密分析或链上数据</a> | <a class="ae kc" href="https://coincodecap.com/bexplus-review" rel="noopener ugc nofollow" target="_blank"> Bexplus评论</a></li><li id="51af" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated"><a class="ae kc" href="https://coincodecap.com/nft-marketplaces" rel="noopener ugc nofollow" target="_blank">NFT十大市场造币集锦</a></li><li id="f72f" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated"><a class="ae kc" href="https://coincodecap.com/ascendex-staking" rel="noopener ugc nofollow" target="_blank">AscendEx Staking</a>|<a class="ae kc" href="https://coincodecap.com/bot-ocean-review" rel="noopener ugc nofollow" target="_blank">Bot Ocean Review</a>|<a class="ae kc" href="https://coincodecap.com/bitcoin-wallets-india" rel="noopener ugc nofollow" target="_blank">最佳比特币钱包</a></li><li id="4ec1" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn lh ju jv jw dt translated"><a class="ae kc" href="https://coincodecap.com/bitget-review" rel="noopener ugc nofollow" target="_blank"> Bitget回顾</a>|<a class="ae kc" href="https://coincodecap.com/gemini-vs-blockfi" rel="noopener ugc nofollow" target="_blank">Gemini vs block fi</a>|<a class="ae kc" href="https://coincodecap.com/okex-futures-trading" rel="noopener ugc nofollow" target="_blank">OKEx期货交易</a></li></ul></div></div>    
</body>
</html>