<html>
<head>
<title>A computer science mystery: Investigating how Facebook Messenger’s M deals with currency values (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机科学之谜:调查Facebook Messenger的M如何处理货币价值(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-computer-science-mystery-investigating-how-facebook-messengers-m-deals-with-currency-values-557d63228498?source=collection_archive---------3-----------------------#2018-06-02">https://medium.com/coinmonks/a-computer-science-mystery-investigating-how-facebook-messengers-m-deals-with-currency-values-557d63228498?source=collection_archive---------3-----------------------#2018-06-02</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="5942" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jo">如果你还没看过第一部，</em> <a class="ae jp" rel="noopener" href="/@tylerjustinfisher/a-computer-science-mystery-investigating-how-facebook-messengers-m-deals-with-currency-values-570097a5ff2b"> <em class="jo">先看那个</em> </a> <em class="jo">。</em></p><p id="1233" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">那么，2⁶-2⁰来自哪里呢？</p><p id="798a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们首先想到的是研究一种更大的数据类型，即长double，它有16个字节。然而，这种类型似乎与2⁶没有任何关联，所以我们排除了这种合理的可能性，以及任何其他类似的巨大类型。此外，为什么脸书的工程师会使用这样一个不必要的大数据类型呢？</p><p id="35e3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我们决定深入研究其他常见的8字节类型时，我们取得了突破，将我们的范围扩展到了我们一直怀疑的long long之外。我们最初认为这个数字应该是一个很长很长的数字，而不是一个双精度数，因为我们知道<code class="eh jq jr js jt b">LLONG_MAX</code>正好在2⁶附近，而<code class="eh jq jr js jt b">DOUBLE_MAX</code>比<em class="jo">大得多，大约在2个⁰ ⁴.附近然而，当我们进一步思考这个问题时，整个谜团的迷雾开始消散。如何在不使用1024位的情况下得到一个像2 ⁰ ⁴那么大的数？</em></p></div><div class="ab cl ju jv hb jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hm hn ho hp hq"><p id="fcb7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">答案在于双精度是如何存储的。所有带符号的浮点数都存储为一个指数和一个二进制尾数(也称为小数有效数)加上一个符号(正或负)。特别是对于有符号的double，它的8个字节给了它64位来处理。其中，第一位是符号，接下来的11位是指数，剩下的52位是尾数。</p><figure class="kc kd ke kf fq kg fe ff paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="fe ff kb"><img src="../Images/7b0b7e8263fb349157fb18ac4c65c55b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dO6m3x_YGpKtwlLS"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Image from <a class="ae jp" href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noopener ugc nofollow" target="_blank">the Wikipedia page on doubles</a></figcaption></figure><p id="cf78" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">浮点运算的机制对我来说相当生疏，在我能够完全理解最终的解决方案之前，我必须花相当长的时间来重新熟悉浮点数的具体工作方式。如果你对浮点数感到不确定，就像我最近一样，这里有一个纲要:</p><p id="3f90" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Doubles和其他浮点数并不像int和longs那样直接存储数字。double不是实际存储数字本身，而是识别比所需数字小的最接近的2的幂，然后计算出该2的幂必须乘以什么系数才能得到所需数字。然后它存储这个2的幂和这个系数，而不是像定点类型那样存储数字本身。</p><p id="10ab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">例如，十进制数7可以精确地描述为4×1.75。这里，4是2的相关幂，因为2 = 4。小数1.75是从4到7的系数。因此，计算机实际上是将“4”和“1.75”存储在一起，并且能够确定它们相乘时等于“7”。(当然，它们都是用二进制表示的，因为十进制的1.75等于二进制的1.11，所以double实际上将7存储为2 ×1.11₂.)</p><p id="3931" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">类似地，对于十进制数18，double存储2⁴的指数以及二进制数1.001的尾数，这相当于十进制数1.125。这两个数的乘积是十进制数18，即16×1.125=18。</p><p id="73f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jo">(如果我的总结不清楚，</em> <a class="ae jp" href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" rel="noopener ugc nofollow" target="_blank"> <em class="jo">)维基百科页面上的浮点运算</em> </a> <em class="jo">给出了自己的解释，而</em> <a class="ae jp" href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noopener ugc nofollow" target="_blank"> <em class="jo">页面上的双精度运算</em> </a> <em class="jo">包含了更多的例子。)</em></p><p id="8335" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有了这样的理解，我们现在就可以理解浮点数不精确的细微差别，以及9，223，372，036，854，774，784这个数字的确切来源。浮点运算的本质意味着存储的数字只能精确到一定的精度。对于有符号双精度浮点数，其精度由尾数分配的52位决定。直到2⁵的数量级，每个整数都可以精确存储，整数之间的一些数字也是如此。从2⁵开始，只有整数可以被精确存储。在2⁵之后，整数精度也开始下降。具体来说，双精度浮点数不能精确存储的第一个整数是2⁵ +1。</p><p id="3e67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，双精度可以完美地存储整数2⁵和2⁵ +2。对于所有仅略大于2⁵的数字，每个奇数都因舍入误差而丢失。这种舍入误差是由于52位的尾数仍然只有2⁵到2⁵1范围内的唯一整数作为基数。现在的问题是，这个范围内的每个数字都要乘以2才能达到2⁵到2⁵⁴−1.的范围这允许double存储比2⁵高得多的数字，但精度明显下降。</p><p id="3ae0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每当达到2的新次方时，这个问题就会变得更加复杂。2⁵⁴之后，可以精确存储的整数间隔4；2⁵⁵之后，他们相距8；仅次于2⁵⁶16岁。更一般地说，确定在给定的2的幂附近的可存储数之间的间距的公式是2ⁿ⁻⁵，其中<em class="jo"> n </em>是低于期望数的最接近的2的幂。(这应该简洁地解释了为什么对于2⁵和2⁵1之间的数字，整数本身是可以精确存储的数字，因为n = 52，2ⁿ⁻⁵ = 2⁵ ⁻⁵ = 2⁰ = 1。)</p><p id="37d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">(快速补充:简单地考虑一下，这个间距暗示着接近<code class="eh jq jr js jt b">DOUBLE_MAX</code>和其他类似的巨大数字的疯狂。在这个数量级上，可存储的数字<em class="jo">间隔</em>2⁰⁴⁻⁵=2⁹⁷，这个数字<em class="jo">远远超过了可观测宇宙中的普朗克体积数。也就是说，在遥远的2 ⁰ ⁴附近的每个数字将被许多许多可观测的宇宙强制向上或向下舍入，以便被压缩成64位的浮点数。)</em></p><p id="c7c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">无论如何，这幅关于double如何工作的完整图片<em class="jo">主要是</em>解释了M愿意给出的数字的最后几位的奇怪行为:它被迫上下舍入数字以得到它能够存储为double的数字。例如，92，233，720，368，539，010美元变成了92，233，720，368，539，013.02美元，因为后者实际存储为9，223，372，036，853，901，302美分，是距离2⁶2 ⁰s(854，如果你好奇的话)的整数。这是最接近的可存储的数字，所以这是M必须使用的。</p><p id="f4b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这也清楚地表明了我们的实际极限2⁶2⁰来自哪里:在2⁶之后，每个可存储的数字由2⁶ ⁻⁵ = 2 ⁰.隔开由于2⁶这个数字本身太大而无法存储，所以可以用双精度表示的最大数字是2⁶以下第一个可以精确存储的数字，或者确切地说是2⁶2 ⁰.</p><p id="ca2b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">问题解决了，对吧？</p></div><div class="ab cl ju jv hb jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hm hn ho hp hq"><p id="24e6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">不完全是。</p><p id="6258" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果双打可以一直到2 ⁰ ⁴，为什么2⁶是相关的？难道我不应该让M变得更高吗，尽管我会开始觉得这些数字之间的间隔很可笑？</p><p id="5d54" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们最好的猜测是:在幕后有一个类型转换正在进行。最有可能的情况是，用户键入的文本首先被从字符串强制转换为long long，这种类型允许精确的整数表示，一直到2⁶1(因为没有尾数-指数舞蹈发生，它只是一个简单的二进制整数)。然后，这个数字从long long转换为double，这时就会出现精度损失。数字2⁶1被向下舍入到比它本身低一倍的最高可存储数，2⁶2⁰，我们有一个合理的解释。</p><p id="bf40" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，对我来说，这个难题已经解决了，所有潜在的技术机制都被揭开了。</p></div><div class="ab cl ju jv hb jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hm hn ho hp hq"><p id="f6a7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，有一个悬而未决的问题一直困扰着我:为什么从long到double的类型转换会发生？在我看来，在整个时间内将数字保持为long就足够了，而且实际上更健壮。</p><p id="c155" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">事实上，我被告知，一般来说，doubles和floats应该特别地用<em class="jo">而不是</em>来表示货币，因为正是这种类型的问题。不可能精确地表示十的负次方(. 1，. 01等)。)使用替身。考虑到货币值是用美分表示的，因此<em class="jo">总是</em>需要这样的值，这就变得非常禁止了。应该用定点数来代替。这个简单的Java例子应该让这个问题变得非常清楚:</p><pre class="kc kd ke kf fq kr jt ks kt aw ku dt"><span id="4189" class="kv kw ht jt b fv kx ky l kz la">System.out.println(0.91 - 0.32);</span><span id="9eb5" class="kv kw ht jt b fv lb ky l kz la">&gt; 0.5900000000000001</span></pre><p id="a4eb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当然，在呈现给用户之前，很难完成这一点点。但是如果M想做，比如说，复利计算呢？在一个足够大的利率下，或者在一个足够长的时间框架内，这一点点累积起来不会造成重大误差吗？至少，这不会给任何必须钻研相关代码的脸书开发人员增加一点头痛吗，特别是在调试的时候，尤其是<em class="jo">由于使用了机器学习，系统已经有点黑箱的感觉了。</em></p><p id="3f86" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">是的，我知道这样一个事实，因为数字是以美分而不是以美元存储的，这个问题在某种程度上被回避了，但是如果M想用零头美分做任何事情，它就会回到最前沿。</p><p id="28ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我愿意假定脸书是无辜的，并且让我的思想开放，在这里有一些使用浮点数据类型的好理由。我不知道它是什么，但是，我想了很多。如果我要确信这不仅仅是一个奇怪的疏忽，我需要听到一个好的解释。</p><p id="5df3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因为，在一天结束的时候，所有这些奇怪的行为都是完全可以避免的，如果这个数字被简单地存储在一个long long all…<em class="jo">along</em>中的话。</p></div></div>    
</body>
</html>