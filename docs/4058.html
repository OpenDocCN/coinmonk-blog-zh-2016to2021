<html>
<head>
<title>Merkle Trees: Concepts and Use Cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Merkle树:概念和用例</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/merkle-trees-concepts-and-use-cases-5da873702318?source=collection_archive---------0-----------------------#2021-02-16">https://medium.com/coinmonks/merkle-trees-concepts-and-use-cases-5da873702318?source=collection_archive---------0-----------------------#2021-02-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="cd78" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">比特币内部的数据结构，亚马逊迪纳摩DB，ZFS，…</h2></div><p id="6154" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">本文探讨了什么是Merkle树，以及它们在不同系统中的实际应用，包括比特币、亚马逊的Dynamo DB和ZFS文件系统。基本概念相当简单，但一些巧妙的应用并不那么明显。</p><p id="9937" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">首先，让我们从Merkle树的概念开始。如我所说，它的基本形式并不复杂。</p><h1 id="b57a" class="ke kf ht bd kg kh ki kj kk kl km kn ko iz kp ja kq jc kr jd ks jf kt jg ku kv dt translated">什么是Merkle树</h1><p id="c69a" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hm dt translated">Merkle树基本上就是一组层次化的<a class="ae lb" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank">散列</a>值，从一组实际数据(<em class="lc"> Merkle leaf </em>)到中间散列(<em class="lc">Merkle brachs</em>)直到将所有数据汇总到一个散列值中的<em class="lc"> Merkle root </em>。</p><h2 id="bf35" class="ld kf ht bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq dt translated">示例:一个基本的Merkle树</h2><p id="8bd9" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hm dt translated">下图显示了一个非常小的Merkle树:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/161c392b3288975b6c07ee695dcd4536.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*1e-wyMbvf8-u7Le1LUxTBA.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">A very small Merkle tree. Image by author.</figcaption></figure><p id="281c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在该图中，底部节点(<em class="lc">数据1 </em> - <em class="lc">数据4 </em>)是应用程序处理的实际数据。其中的每一个都由它们各自的哈希值(<em class="lc"> Hash1 </em> - <em class="lc"> Hash4 </em>)汇总，作为<em class="lc"> Merkle leaf </em>。从这些开始，Merkle树构建了一个层次结构，将散列组合在一起，直到只剩下一个。组合其他哈希节点的节点称为<em class="lc"> Merkle分支</em>(此处<em class="lc">哈希12 </em>，<em class="lc">哈希34 </em>)。当只剩下一根时(此处<em class="lc">有h1234 </em>)，这叫做<em class="lc"> Merkle根</em>。如下例所示，可以有多级分支和散列。</p><h2 id="8fc2" class="ld kf ht bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq dt translated">处理不平衡的Merkle树</h2><p id="86c6" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hm dt translated">上面的例子说明了Merkle树的基本情况。这是一个方便的例子，因为在每一层都有正好合适的节点数来形成精确的配对。如果您有奇数个叶(数据)节点，会发生什么情况？例如，如果您有5个数据节点，上面的示例会发生什么情况？可以将Data1+Data2散列在一起形成Merkle分支，Data3+Data4也是如此。但是数据5没有一对散列到新分支中。</p><p id="4cba" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">可以采取不同的方法来解决这个问题。例如，在这种情况下，比特币只是复制不可配对的(奇数)哈希，并将副本作为一对使用(奇数哈希与自身配对)。下图说明了这一点:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff md"><img src="../Images/ba396815f5e3dd945073159c15848c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*wNm1yknGeuiSQyIFYxHrhA.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Handling odd (uneven) numbers of hashes Bitcoin style. Image by author.</figcaption></figure><p id="68a1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在本例中，Hash 5没有直接配对，它被复制以与自身配对。Hash55也是如此。以上只是一个选项，有不同的方法来处理这个配对问题。在我看过的作品中，我最喜欢Monero(或<a class="ae lb" href="https://en.wikipedia.org/wiki/CryptoNote" rel="noopener ugc nofollow" target="_blank"> Cryptonote </a>？)一个最多。我将很快介绍它。首先，稍微有些不同。</p><h2 id="0137" class="ld kf ht bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq dt translated">Python中一个非常简单的Merkle树</h2><p id="c07a" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hm dt translated">理论和解释都很棒。但是对于技术人员来说，一些代码有助于形式化它。我的<a class="ae lb" href="https://github.com/mukatee/monero-scraper/blob/master/src/python/merkletrees/merkletree_simple.py" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中的以下代码展示了一个用Python实现Merkle树的简单例子(或者跳过它，以获得更多概念性解释):</p><figure class="ls lt lu lv fq lw"><div class="bz el l di"><div class="me mf l"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">A very simple and naive Merkle tree implementation in Python. Code by author.</figcaption></figure><p id="0b1c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">上面代码中的最后四行运行示例，创建一个带有数据节点<em class="lc">数据1 </em> - <em class="lc">数据5 </em>的Merkle树。用这种算法计算树看起来像这样(将散列裁剪为前5个字符):</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/41e8fd6f85935e796342670a3056e1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/1*yeJBU1VLzyNPH8v7iJ4cJQ.gif"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Merkle tree calculation example with actual values. Image and animation by author.</figcaption></figure><p id="6d5d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我在这个例子中使用了<a class="ae lb" href="https://keccak.team/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> keccak </em> </a>哈希函数，因为这是<a class="ae lb" href="https://www.getmonero.org/" rel="noopener ugc nofollow" target="_blank"> Monero </a>加密货币/区块链使用的函数，而且我最近在研究Monero代码。这里的第5个(奇数)数据元素(使用我上面的Python代码)的处理方式与比特币示例略有不同，因为如果剩下一个数据元素，这只是重新使用散列(不可配对，上面的<em class="lc"> cf54b </em>)。实际上，这种重复使用应该与比特币算法中的复制具有相同的效果。</p><h2 id="fb71" class="ld kf ht bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq dt translated">优化Merkle计算:Monero风格</h2><p id="b41c" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hm dt translated">当我在研究Monero区块链以更好地理解它时，我发现它有一个不同但聪明的方法来散列Merkle树。它的代码可以在<a class="ae lb" href="https://github.com/monero-project/monero" rel="noopener ugc nofollow" target="_blank"> Monero Github库</a>的<a class="ae lb" href="https://github.com/monero-project/monero/blob/8286f07b265d16a87b3fe3bb53e8d7bf37b5265a/src/crypto/tree-hash.c" rel="noopener ugc nofollow" target="_blank"> tree-hash.c </a>文件中找到。我在我的Github 中做了一个Python版本来实现同样的功能。</p><p id="12fd" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Monero方法可以被描述为将散列树转换成一棵<a class="ae lb" href="https://cs.stackexchange.com/questions/32397/is-there-a-difference-between-perfect-full-and-complete-tree" rel="noopener ugc nofollow" target="_blank">完美的二叉树</a>。它在第一次迭代中散列了足够多的叶节点，因此后面的迭代将总是有一些2ˣ(2的幂)节点的变体。下图说明了这一点:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/e239d2b4acef361b04baa98b621ad61a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*OA8k6-6HvA_4GJm1o6JrKQ.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Monero approach to Merkle tree building, with 5 nodes (transactions in Monero). Image by author.</figcaption></figure><p id="892c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">其工作方式如下:首先，计算<em class="lc"> x </em>，使得<em class="lc"> 2ˣ </em>大于事务数(数据节点)。在这个例子中，它是2 =8，因为8 &gt; 5(有5个事务/数据节点)。在此之前的<em class="lc"> x </em>的值，2 =4，将不适合(4 &gt; 5不为真)。从中减去交易次数。在这种情况下，8–5 = 3。这3是开始迭代1的事务的索引。在本例中，使用基于0的索引，起始索引是<em class="lc">数据4 </em>。</p><p id="030f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">以上解释可能有点抽象。下表列出了事务计数的具体示例，以及在迭代2和后续迭代中，如何将事务计数转换为“完美的二叉树”形状(大小始终为2ˣ，消除任何“奇数”计数或后续迭代中剩余的不可配对散列):</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="fe ff mi"><img src="../Images/07ef2e0a00acfc4cb46c485aab4c5368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IFN8ta_AB0ZbBwIpVIxg2Q.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Example calculations of Merkle size with the Monero (Cryptonote) algorithm. Image/Table by author.</figcaption></figure><p id="160a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这些列:</p><ul class=""><li id="f814" class="mn mo ht jk b jl jm jo jp jr mp jv mq jz mr kd ms mt mu mv dt translated"><em class="lc">事务</em>:正在计算的块中的事务数</li><li id="7df0" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><em class="lc">最接近的2^x </em>:大于<em class="lc">交易的第一个2ˣ</em></li><li id="d9e4" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><em class="lc">迭代1开始索引</em>:从事务列表中的该索引开始散列对</li><li id="3ebb" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><em class="lc">迭代1值</em>:从<em class="lc">迭代1起始索引</em>到交易列表结束的交易列表中的交易数</li><li id="9601" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><em class="lc">迭代1对</em> : <em class="lc">迭代1值</em>除以2(因为成对散列)</li><li id="0745" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><em class="lc">迭代2公式</em>:上述值如何导致在下一次迭代中哈希的项数</li><li id="e93d" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><em class="lc">迭代2大小</em>:迭代2中要散列的事务数。正如你所看到的，它总是2ˣ，并导致进入一个“完美的二叉树”。</li></ul><p id="e993" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我猜是数字和公式太多了。你睡着了吗？无论如何，如果您从上表中选择包含23笔交易的行，您可以按照我制作的这个漂亮的8位动画来查看Merkle根计算是如何针对该行进行的:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/ab4f6d1a21369af684220948b95220dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/1*glRGGJVYW1PVtz2HLnV8wg.gif"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Calculating Merkle root in Monero for block 1407480. Image/animation by author.</figcaption></figure><p id="a194" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在这种情况下(上面的动画)，开始索引计算为2⁶=32–23=9.这是交易号10(零索引加1)。接下来的迭代有16个节点，即2⁵，下一个是8个或2⁴，依此类推。上面的动画实际上展示了Monero代码如何在内存中操作散列数组。</p><h1 id="0765" class="ke kf ht bd kg kh ki kj kk kl km kn ko iz kp ja kq jc kr jd ks jf kt jg ku kv dt translated">示例使用案例</h1><p id="f7ce" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hm dt translated">概念是好的，而具体的、真实的用例才是重点。在这里，我将讨论Merkle树在区块链/加密货币中的使用，以及亚马逊的AWS DynamoDB分布式数据库。我还将简要介绍一下ZFS文件系统和Git版本控制系统，因为它们有时也会作为Merkle树使用的例子被提及。</p><h2 id="1e7a" class="ld kf ht bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq dt translated">加密货币和区块链:比特币、Monero等。</h2><p id="22d0" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hm dt translated">正如上面已经简要讨论的，比特币和类似的加密货币利用Merkle树来总结和验证块中的交易，并将Merkle根嵌入到它们的块头中，作为所有交易的总结。下图说明了这一点:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/1ccf70db62d15ee412f30fb0a230d41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*5qmDXWdAIi4Wtw-adC2deQ.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Blockchain and Merkle trees. Image by author.</figcaption></figure><p id="486b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">每个块都有一个ID值，它是其头字段的散列值。其中一部分是Merkle根。另一部分是前一个块ID(上图中的<em class="lc">父</em>)。通过与前一个块ID链接，并将其作为下一个块ID的一部分，这些块形成一个区块链。通过在其中嵌入Merkle根，他们在块中创建了一个不可变的事务记录。</p><p id="6453" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">例如，比特币块头包含:</p><ul class=""><li id="f2db" class="mn mo ht jk b jl jm jo jp jr mp jv mq jz mr kd ms mt mu mv dt translated">难度目标值(比特币中称为<em class="lc">位</em></li><li id="7431" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><strong class="jk hu"> Merkle root </strong>块中的所有事务</li><li id="bf41" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><em class="lc">Nonce</em>；在挖掘中为查找接受的块而更改的值</li><li id="a095" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><em class="lc">前一块哈希(块ID)</em>；将这个块链接到链中的前一个块(在上图中，这个前一个散列被命名为<em class="lc">父块</em>)</li><li id="b8f6" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><em class="lc">时间戳</em>；挖掘(创建哈希)块的时间</li><li id="73f9" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><em class="lc">块版本</em>；标识支持功能和格式(在一些区块链中也用于标识哈希函数，如Monero)</li></ul><p id="f7c0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这些报头字段都被散列在一起以形成块ID。使块ID成为所有报头数据的散列使得实际上不可能修改块报头。在块ID中包括Merkle根进一步使得实际上不可能修改块中的事务。</p><p id="370c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">但是让我们更详细地看看这些类型的区块链是如何以不同的方式使用Merkle树的。都是关于数据完整性的，但是方式不同，有时很巧妙。</p><p id="247b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">区块链用例1:交易数据(区块)不变性</strong></p><p id="e0d4" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">正如我上面提到的，比特币区块链中Merkle树的基本用例是将Merkle根构建到块头中，并使用它来验证没有交易被更改。</p><p id="2928" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">举个例子，让我们把前面例子中的<em class="lc">数据4 </em>改为<em class="lc">数据6 </em>:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/89f6246e2f6bdcd44dd721b41bb44870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*wSpmSYehSwaBPXOPT4jixg.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Changing one node value invalidates (changes the root of) the Merkle tree. Image by author.</figcaption></figure><p id="5d31" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">与之前的例子相比，使用<em class="lc">数据4 </em>，Merkle根是<em class="lc"> aa8d3 </em>。有了<em class="lc"> Data6 </em>，现在就是<em class="lc"> f8932 </em>。这样，任何事务数据的任何变化都会改变Merkle根，并且它不再匹配存储在该块的区块链中的Merkle根(在块头中)。并且通过块报头，该问题将传播到该块之后的整个区块链。</p><p id="b8a8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然而，如果你想一会儿，你可能会问一个问题:</p><p id="c88f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">真的需要Merkle树来验证块数据吗？</strong></p><p id="cf23" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">不。相反，我们可以将所有的事务数据连接在一起，构建一个单一的根哈希。考虑上述带有<em class="lc">数据1 </em> - <em class="lc">数据5 </em>的示例，但只是将它们散列在一起:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/da0575750018c885da467fe299da2d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*7TwPZorpW1qqIx6DAc3ORQ.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Concatenate+hash all data at once. Image by author.</figcaption></figure><p id="4d1f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在，只更改一个数据值会产生使摘要散列无效的相同效果:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/d132adcf0e49065c255b88d91f4558f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*D9jy3_wIL4p6LfAd0VKSLw.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Hash change detection in concat+hash all at once. Image by author.</figcaption></figure><p id="f319" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">该单个散列也可以用来代替块头和块散列中的Merkle根。目前为止效果相同。</p><p id="7683" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">那么在这里使用Merkle树的真正好处是什么呢？总的来说，我认为它在散列验证中给了您更多的粒度，并使其他巧妙的技巧能够更有效地处理区块链。同时还提供交易完整性保证/验证。</p><p id="4d90" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">最初的<a class="ae lb" href="https://bitcoin.org/bitcoin.pdf" rel="noopener ugc nofollow" target="_blank">比特币白皮书</a>提供了另外两个使用Merkle树的例子:<em class="lc">区块链修剪</em>和<em class="lc">简化支付验证</em> (SPV)。除了这些，我最喜欢的是<em class="lc">地层开采池协议</em>。接下来我们来看看这些。</p><h2 id="85e4" class="ld kf ht bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq dt translated">区块链剪枝</h2><p id="cb54" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hm dt translated">随着时间的推移，区块链会越积越多，变得越来越大。例如，今天(2021年2月)<a class="ae lb" href="https://bitinfocharts.com/" rel="noopener ugc nofollow" target="_blank">比特币区块链的大小约为380GB </a>。区块链修剪是一种借助Merkle树来减少这种已用空间的方法。通过从不再需要的本地存储器中移除用过的事务。</p><p id="526b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们希望拥有所有数据用于全面验证和历史记录，但不是对等网络中的所有节点都需要所有数据。在最初的比特币白皮书中提出的区块链修剪方法建议通过使用Merkle树从块中修剪(移除)花费(使用)的交易来解决这个问题。</p><p id="7776" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">下图说明了这一点:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/57413bb28957328f6d04f90b429fffda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*3kEM_0tRfMBFyg4WlOsusw.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Three out of five transactions used (spent) in the block (and Merkle tree). Image by author.</figcaption></figure><p id="cef3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在这个例子中，我们使用了(失效的)事务TX1、TX2和TX4。在这个块中，我们还有未使用的事务TX3和TX5。假设我们对具有完整存档的完整节点不感兴趣，只是保留一个可消费事务的列表。Satoshi的建议是从已使用的事务数据中删除块，只留下验证未使用的事务数据所需的Merkle树分支:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/fb9207afa0348b3aaf0765a701d7b9a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*JrlcF6o41lTiivSTDjy1sg.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">The Merkle tree pruned of the used transactions. Image by author.</figcaption></figure><p id="3a9e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我们还花费TX3:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/747a5a969ba6c4e6523be2f68e686285.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*81VQu60AIZMv2cg5kcE9Dg.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">One more transaction used, leaving just one unused in the Merkle tree (and the block). Image by author.</figcaption></figure><p id="2ba0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">该块现在可以被修剪为仅包含TX5数据，以及该块中另一个Merkle树分支的散列(<em class="lc"> 96b8d </em>):</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff ni"><img src="../Images/e70e8849ffb6a50fbcaea2ba2534761a.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*OpUqZSjVqemyOeVuAi3ERg.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Pruned Merkle tree with only one transaction left. Image by author.</figcaption></figure><p id="9ca7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们将节省存储5个事务中的4个和9个Merkle树节点中的6个所需的空间。该示例节省了大约80%的空间。区块链越长，使用得越多，花费的事务就越多。因此可以节省更多的空间。这是一个非常聪明的想法，就像最初的比特币白皮书中的大多数想法一样。</p><p id="0122" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">但是就像块验证一样，我们总是可以问这样一个问题:</p><p id="2e56" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">你真的需要万年青来修剪区块链吗？</strong></p><p id="b832" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><a class="ae lb" href="https://bitcoin.stackexchange.com/" rel="noopener ugc nofollow" target="_blank">比特币交易</a>充满了对修剪在实际实现中的实际应用方式的深刻讨论。虽然Merkle树修剪是一种聪明的方法，但在(至少)比特币核心软件中并没有以这种方式应用。</p><p id="83c8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">相反，<a class="ae lb" href="https://bitcoin.stackexchange.com/questions/2983/is-pruning-transaction-history-implemented-in-satoshis-bitcoin-client" rel="noopener ugc nofollow" target="_blank">未用完的交易存储在单独的数据库中，以便快速查找</a>。该数据库在首次启动时通过扫描区块链进行初始化，并在发现新的和失效的事务时更新数据库。随着比特币网络广播新的区块，数据库会不断更新。一个被删减的节点可以依赖于这个数据库。</p><p id="7228" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一般来说，运行一个修剪过的节点对于基本操作来说已经足够了，但是<a class="ae lb" href="https://bitcoin.stackexchange.com/questions/101768/if-pruning-is-so-safe-why-arent-100-of-the-bitcoin-nodes-pruning-why-keep-th" rel="noopener ugc nofollow" target="_blank">并不完全支持区块链</a>的所有特性，所以一些节点仍然需要保存完整的数据。但是这超出了本文的范围。</p><p id="6ef4" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我认为这里的基本要点是，Merkle树很酷，但有时基本的甚至更简单的方法也很好，甚至更好。当然，困难的部分是识别什么时候这是真的，什么时候更酷(Merkle)的方法是最好的。不要以任何方式认为这是不使用Merkle树的建议。只是考虑一下整体情况。还有比特币和相关的区块链，我相信Merkle树可以实现许多其他事情，因此很有意义。如下文所示。</p><h2 id="b856" class="ld kf ht bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq dt translated">简化支付验证(SPV)</h2><p id="6703" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hm dt translated">最初的<a class="ae lb" href="https://bitcoin.org/bitcoin.pdf" rel="noopener ugc nofollow" target="_blank">比特币白皮书</a>中也提出了<a class="ae lb" href="https://en.bitcoinwiki.org/wiki/Simplified_Payment_Verification" rel="noopener ugc nofollow" target="_blank">简化支付验证</a> (SPV)算法。在SPV中，一个轻量级区块链客户只存储块头，但也希望在区块链中验证它收到的付款是否为有效交易。由于缺乏完整的交易细节，SPV客户端使用Merkle树与完整节点协作来有效地验证交易细节。</p><p id="f8a7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我将重复使用上面区块链修剪的例子。SPV客户端想要验证给定块中的TX5。下图说明了这一点:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff nj"><img src="../Images/f5052f3837d851bac6daf8199a369a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*PXyTgBrBLFSsky2d9eFIFA.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">SPV client node verifying a single transaction is part of a given Merkle tree. Image by author.</figcaption></figure><p id="2839" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这里，SPV客户端节点向一个完整节点请求Merkle分支，这是用TX5数据构建Merkle根所需的。通过从感兴趣的事务(<em class="lc"> TX5 </em>)重建Merkle根(<em class="lc"> aa8d3 </em>)以及由完整节点提供的Merkle分支(<em class="lc"> 96b8d </em>)，SPV客户可以确信已经接收到有效的事务。通过对照存储在块头中的根来检查这个重建的Merkle根，可以验证整个树(以及<em class="lc"> TX5 </em>)实际上是有效的，并且是区块链的一部分。</p><p id="90b9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我发现SPV是一个有趣的例子，说明如何使用Merkle树，以及(块)数据过滤(<a class="ae lb" href="https://bitcoin.stackexchange.com/questions/57328/the-use-of-bloom-filter-in-spv-nodes" rel="noopener ugc nofollow" target="_blank">比特币使用</a> <a class="ae lb" href="https://en.wikipedia.org/wiki/Bloom_filter" rel="noopener ugc nofollow" target="_blank">布鲁姆过滤器</a>，但这又是另一个话题<a class="ae lb" href="https://bitcoin.stackexchange.com/questions/68668/bitcoin-full-clients-checks-all-the-blockchain-every-time-they-receive-bloom-fil" rel="noopener ugc nofollow" target="_blank"/>)，来同步和验证分布式系统中所选数据的存在和正确性。</p><p id="58af" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">池采:地层协议</strong></p><p id="c4a3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">创建加密货币的传统方式是通过工作证明(PoW)哈希进行挖掘。采矿池是小型采矿者联合在一起，根据他们对池的计算(哈希)能力的贡献获得一些采矿奖励的一种方式。这导致需要一个中央实体，即采矿池，能够协调矿工。它需要一种方法来跨所有客户机有效地分布和跟踪整个挖掘过程。通过一些巧妙的技巧，<a class="ae lb" href="https://en.bitcoin.it/wiki/Stratum_mining_protocol" rel="noopener ugc nofollow" target="_blank">地层协议</a>使用Merkle树来实现这一点。</p><p id="aba2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">特别是<a class="ae lb" href="https://braiins.com/stratum-v1/docs" rel="noopener ugc nofollow" target="_blank"> Stratum版本1 </a>利用Merkle树高效地分发工作。池服务器向挖掘器节点提供构建块所需的块头元素。这包括部分Merkle树，为除比特币基地事务之外的所有其他事务计算分支。coinbase交易是一种支付采矿报酬的特殊交易。下图说明了这一点:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/ebf0c8052ff863d2ea0c0aab4bcfd35e.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*tAXOOgBG4ZWsrqh1PjSs-g.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Merkle templating with the Stratum mining pool protocol (v1). Image by author.</figcaption></figure><p id="7051" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">该图包含三个元素:<em class="lc"> Merkle树模板</em>、<em class="lc">比特币基地模板</em>和<em class="lc">对随机数的搜索</em>。该池向挖掘器提供Merkle树模板，包含块中事务的预先计算的Merkle分支(这里是<em class="lc"> 96b8d </em>，从而大大降低了挖掘器的带宽和计算需求)。然后，miner需要用合适的coinbase事务填充Merkle树模板，该事务是从服务器提供的coinbase模板构建的。获胜者是用提供匹配区块链网络难度等级的散列值填充模板的人。意味着只是具有合适的小值的散列。</p><p id="d392" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">coinbase模板由池提供，并由矿工使用他们选择的<em class="lc"> nonce </em>和<em class="lc"> extranonce </em>字段来填充。当与Merkle树模板结合时，这些模板中的每一个都提供不同的块散列，并且找到获胜块的唯一方法是尝试值，直到产生匹配网络困难目标的散列。如果挖掘器找到一个与这个Merkle模板的网络散列难度相匹配的nonce，它就把它提交给挖掘池。coinbase模板包含矿池地址，确保矿池收到区块奖励，并可以分发给所有矿工。</p><p id="80ec" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在更广泛的上下文中，这里的Merkle树用于分发部分解决方案(预先计算的Merkle树分支和coinbase模板)，同时允许不同的分布式节点独立工作，以尝试找到缺失部分的解决方案(coinbase事务的nonces，以构建可接受的PoW散列)。通过将池地址作为模板的一部分嵌入，它确保了所有分布的节点为共同的目标做出贡献，并且可以共享回报。</p><h1 id="030e" class="ke kf ht bd kg kh ki kj kk kl km kn ko iz kp ja kq jc kr jd ks jf kt jg ku kv dt translated">AWS发电机数据库</h1><p id="0ded" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hm dt translated"><a class="ae lb" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> Dynamo DB </a>是一个分布式数据库，作为<a class="ae lb" href="https://en.wikipedia.org/wiki/Amazon_Web_Services" rel="noopener ugc nofollow" target="_blank">亚马逊网络服务(AWS) </a>平台的一部分提供。它最初是为了处理亚马逊的全球零售基础设施需求而设计的。因此，在使其可扩展和优化其架构的所有部分的效率方面，已经投入了大量的考虑。在2007年的<a class="ae lb" href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" rel="noopener ugc nofollow" target="_blank"> AWS Dynamo DB论文中描述了Dynamo DB的架构，包括它使用Merkle树来有效地同步发散的节点(论文的第4.7节)。</a></p><p id="dafa" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Dynamo DB就是所谓的键值存储。实际数据(值)存储在数据节点中，并通过它们的键进行标识和索引。Dynamo DB将这些数据存放在它称之为<em class="lc">的虚拟节点</em>中。每个虚拟节点拥有一个<em class="lc">键范围</em>。为了处理高可用性和可伸缩性需求，Dynamo DB跨这些键范围分布数据，并将每个键范围托管在多个虚拟节点上(跨多个物理节点，或<a class="ae lb" href="https://dzone.com/articles/partitioning-behavior-of-dynamodb" rel="noopener ugc nofollow" target="_blank">分区</a>)。</p><p id="ab58" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">下图试图说明这一点，其中有3个(虚拟)Dynamo DB节点，每个节点包含2个键范围，每个键范围在两个节点之间复制。我确信这并不完全符合所有的细节，而且自从这篇论文发表以来，这个系统已经发生了变化，但是我相信它已经很好地描述了总体概念:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/6f2b3fb68e5ad6dec926f5d1870161d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*lCzL_ojIfsyQH1_gHzdRwA.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">DynamoDB virtual nodes and distributed key ranges. Image by author.</figcaption></figure><p id="a8a8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在这种类型的分布式系统中，总有一天，这些虚拟节点中的一些会与持有相同键范围的其他虚拟节点不同步。Dynamo DB使用Merkle树对这些节点中的键范围进行有效的比较和同步。在上图中，我在每个键范围内做了一个小的3节点Merkle树来说明这一点。<em class="lc"> KR3 </em>键范围树部分显示为红色，以说明节点是如何发生分歧的，需要解析才能找到正确的值。</p><p id="4307" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为每个键范围构建一个Merkle树，其中树的叶节点是键范围数据值。Merkle根汇总了每个节点中的数据。通过比较托管相同键范围的每个虚拟节点的Merkle根，节点中的差异立即可见。这种完全的比较只需要单个值，即Merkle根的通信和比较。如果存在差异，可以继续比较树的分支，以有效地找到准确的分歧点，并同步数据值。</p><p id="5cbb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">下图说明了这一过程:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/89f6246e2f6bdcd44dd721b41bb44870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*wSpmSYehSwaBPXOPT4jixg.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">DynamoDB using Merkle trees to find data nodes out of sync. Image by author.</figcaption></figure><p id="8d0a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">正如你所看到的，我只是把区块链的例子复制到上图中。因为fundamel的结构，以及它所依赖的概念，是完全一样的！不同之处仅在于相同的基本原理在不同的环境中的(巧妙)应用。</p><p id="32b2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">是的，一些细节可能会有所不同。例如，DynamoDB可能使用与Keccak不同的散列函数。但是，如这里所示，基本的方法和概念是相同的，因此不仅仅适用于常见的区块链Merkle树的例子。</p><h1 id="8ec7" class="ke kf ht bd kg kh ki kj kk kl km kn ko iz kp ja kq jc kr jd ks jf kt jg ku kv dt translated">ZFS文件系统</h1><p id="4a2a" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hm dt translated">ZFS是一个支持分布在多个卷上的数据的文件系统，是一种分布式文件系统。多个ZFS卷可以被分组到<a class="ae lb" href="https://arstechnica.com/information-technology/2020/05/zfs-101-understanding-zfs-storage-and-performance/" rel="noopener ugc nofollow" target="_blank">存储池</a>，这些存储池也可以托管数据的冗余副本。ZFS被宣传为使用Merkle树来确保数据完整性。</p><p id="78bc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><a class="ae lb" href="https://zedfs.com/checksumming-in-filesystems-and-why-zfs-is-doing-it-right/" rel="noopener ugc nofollow" target="_blank"> ZFS使用Merkle树来检查数据</a>，以识别写入或读取磁盘的部分数据损坏(或误读)等问题。).与大多数文件系统一样，数据存储为特定大小的块。这些块形成了用于构建Merkle树的自然叶节点。</p><p id="da34" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我在网上找到的ZFS使用Merkle树的主要理由总是讨论ZFS如何将Merkle树作为校验和存储在块本身之外，为识别错误提供更高的弹性。这让我很不明白为什么你需要一个Merkle树，而不仅仅是在块外存储一个普通的校验和。有时候我觉得人们应该问更多的问题。</p><p id="ba86" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">另一方面，我可以看到通过使用分层Merkle树跨多个存储池及其副本验证数据的好处。这种情况非常类似于DynamoDB如何操作并使用Merkle树来同步节点(相对于ZFS卷)。然而，我找不到任何使用Merkle树的描述。如果有人知道的更好，我很乐意听到。</p><p id="0d6a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在任何情况下，这似乎与Dynamo DB非常相似，因为它被用来更有效地验证分布式数据存储系统的完整性。其额外的好处是将一致性属性(校验和散列)与数据本身分开，以提高弹性。</p><h1 id="729d" class="ke kf ht bd kg kh ki kj kk kl km kn ko iz kp ja kq jc kr jd ks jf kt jg ku kv dt translated">Git版本控制系统</h1><p id="e153" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hm dt translated">我发现另一个被引用作为Merkle树例子的例子是<a class="ae lb" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git版本控制系统</a>。Git确实使用了大量的散列，它的基本功能在很大程度上基于散列文件内容和各种元数据。Git形成了由这些散列标识的提交的<a class="ae lb" href="https://stackoverflow.com/questions/26395521/dag-vs-tree-using-git" rel="noopener ugc nofollow" target="_blank">有向非循环图</a> (DAG)。<a class="ae lb" href="https://stackoverflow.com/questions/26395521/dag-vs-tree-using-git" rel="noopener ugc nofollow" target="_blank">这似乎被一些人认为是一棵大树</a>。我不同意，所以我将以此作为概念中一些细微差别的例子。</p><p id="ca24" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">DAG是一种图，其中连接是单向的(有向的)，并且没有循环(无环的)。不幸的是，我不明白Git DAG怎么会是Merkle树。下图显示了一个Git DAG，其中包含一些最常见的Git图形操作——分支和合并:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/3107bb7e34cb9b1d06f2cdcfe10ca1ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*ui15DKuCKujGjFm39P3fng.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">A made up DAG representing Git commits. Arrows point to parent commits. Image by author.</figcaption></figure><p id="c1e5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这里有由散列标识的节点和一个树形结构，其中每个节点指向一个父节点，并有一个或多个子节点。然而，我认为将这种树称为Merkle树有很多问题:</p><ul class=""><li id="709b" class="mn mo ht jk b jl jm jo jp jr mp jv mq jz mr kd ms mt mu mv dt translated">Merkle树中的节点没有多个父节点。达格人知道。上图有两个这样的节点:<em class="lc"> 8e290 </em>和<em class="lc"> 184da </em>。</li><li id="9e6f" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">Merkle树只在其叶节点中散列实际数据，叶节点之后的Merkle分支是散列的散列。Git DAG没有基于散列的散列的分支，只有带有原始数据散列的节点。</li><li id="e138" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">Merkle树从叶节点开始，沿着树向上，在每次迭代中不断地将分支数量减半。Git DAG随着分支和合并一直收缩和扩展。因为它是图而不是树。</li></ul><p id="1bfc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Git DAG中的每个节点将它的父散列ID作为它自己的散列标识符的一部分进行散列，并且它是按时间排序的(定向的)。因此，它实际上非常类似于区块链。与加密货币不同，它允许分叉(分支)，并将这些整合为其结构的核心部分。然而，我认为放松这一点作为一般区块链定义的要求没有问题。我看不出区块链需要一棵默克尔树，正如我看不出吉特·达格需要一棵默克尔树一样。拥有一个加密货币是有用的，但是你可以拥有一个不同形式的加密货币，使用其他机制，比如Git。</p><p id="f773" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">总之，不是所有的东西都需要成为Merkle树，即使它很酷。虽然你应该考虑Merkle树，因为它们很酷。然而，我在Git DAG中(或者在Git的其他地方)没有看到Merkle树。如果你比较了解，乐于聆听和学习:)。</p><h1 id="7f5b" class="ke kf ht bd kg kh ki kj kk kl km kn ko iz kp ja kq jc kr jd ks jf kt jg ku kv dt translated">结论</h1><p id="80ce" class="pw-post-body-paragraph ji jj ht jk b jl kw iu jn jo kx ix jq jr ky jt ju jv kz jx jy jz la kb kc kd hm dt translated">我发现Merkle树是一种简单但聪明的数据结构。我最喜欢我的算法和系统简单而聪明。我在本文中提到的例子有</p><ul class=""><li id="a85a" class="mn mo ht jk b jl jm jo jp jr mp jv mq jz mr kd ms mt mu mv dt translated">区块链完整性验证，</li><li id="a1b0" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">区块链修剪</li><li id="e630" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">简化支付验证，</li><li id="5110" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">工作分配的挖掘池协议，</li><li id="82b6" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">DynamoDB数据同步</li><li id="36ec" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">ZFS校验和(以及可能的节点同步)</li></ul><p id="15ff" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">所有这些的共同点是什么？它们都使用Merkle树作为工具来获取潜在的大量数据元素，并在不同的步骤中分层验证它们的完整性。这允许有效的数据通信，并有效地处理全部数据的验证，仅在需要时进入更多细节。我相信这总结了我所看到的Merkle树的最佳用例:<em class="lc">支持分布式节点上的数据的有效验证和同步</em>。</p><p id="a29c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当然，还有stratum mining协议，它更进一步，使用Merkle树作为一种手段来分配工作，同时在分散和不可信的设置中控制输出的特定属性。酷毙了。</p><p id="7154" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在大多数日常的软件工程任务中，很少有机会使用和构建这些特性。但是学习它们肯定是有趣的，从而更好地理解一些基于它们的最新技术是基于什么。并在适当的时候做出明智的决定。对吗？</p><blockquote class="nn"><p id="c10f" class="no np ht bd nq nr ns nt nu nv nw kd ek translated">加入Coinmonks <a class="ae lb" href="https://t.me/joinchat/EPmjKpNYwRMsBI4p" rel="noopener ugc nofollow" target="_blank">电报集团</a>，了解加密交易和投资</p></blockquote><h2 id="bd97" class="ld kf ht bd kg le nx lg kk lh ny lj ko jr nz ll kq jv oa ln ks jz ob lp ku lq dt translated">另外，阅读</h2><ul class=""><li id="6ed0" class="mn mo ht jk b jl kw jo kx jr oc jv od jz oe kd ms mt mu mv dt translated">什么是<a class="ae lb" href="https://blog.coincodecap.com/what-are-flash-loans-on-ethereum" rel="noopener ugc nofollow" target="_blank">闪贷</a>？</li><li id="259b" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">最好的<a class="ae lb" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a> | <a class="ae lb" href="https://blog.coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a></li><li id="5241" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" rel="noopener" href="/coinmonks/3commas-review-an-excellent-crypto-trading-bot-2020-1313a58bec92">3商业评论</a> | <a class="ae lb" rel="noopener" href="/coinmonks/pionex-review-exchange-with-crypto-trading-bot-1e459d0191ea"> Pionex评论</a> | <a class="ae lb" href="https://blog.coincodecap.com/coinrule-review-a-perfect-trading-bot" rel="noopener ugc nofollow" target="_blank"> Coinrule评论</a></li><li id="25b2" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" rel="noopener" href="/coinmonks/aax-exchange-review-2021-67c5ea09330c"> AAX交易所评论</a> | <a class="ae lb" rel="noopener" href="/coinmonks/deribit-review-options-fees-apis-and-testnet-2ca16c4bbdb2">德里比特评论</a> | <a class="ae lb" rel="noopener" href="/coinmonks/ftx-crypto-exchange-review-53664ac1198f"> FTX交易所评论</a></li><li id="1a62" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" rel="noopener" href="/coinmonks/ngrave-zero-review-c465cf8307fc">n rave零点回顾</a> | <a class="ae lb" rel="noopener" href="/coinmonks/phemex-review-4cfba0b49e28"> Phemex回顾</a> | <a class="ae lb" rel="noopener" href="/coinmonks/primexbt-review-88e0815be858"> PrimeXBT回顾</a></li><li id="a108" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" rel="noopener" href="/coinmonks/bybit-exchange-review-dbd570019b71"> Bybit Exchange审查</a> | <a class="ae lb" href="https://blog.coincodecap.com/bityard-reivew" rel="noopener ugc nofollow" target="_blank"> Bityard审查</a> | <a class="ae lb" href="https://blog.coincodecap.com/coinspot-review" rel="noopener ugc nofollow" target="_blank"> CoinSpot审查</a></li><li id="cfc6" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" rel="noopener" href="/coinmonks/3commas-vs-pionex-vs-cryptohopper-best-crypto-bot-6a98d2baa203">3 commas vs crypto hopper</a>|<a class="ae lb" rel="noopener" href="/coinmonks/earn-crypto-interest-b10b810fdda3">赚取加密利息</a></li><li id="51e2" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">最好的比特币<a class="ae lb" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069?source=friends_link&amp;sk=324dd9ff8556ab578d71e7ad7658ad7c">硬件钱包</a> | <a class="ae lb" rel="noopener" href="/coinmonks/bitbox02-review-your-swiss-bitcoin-hardware-wallet-c36c88fff29"> BitBox02回顾</a></li><li id="4268" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" href="https://blog.coincodecap.com/ngrave-vs-ledger" rel="noopener ugc nofollow" target="_blank">莱杰vs n格拉夫</a> | <a class="ae lb" href="https://blog.coincodecap.com/ledger-nano-s-vs-x" rel="noopener ugc nofollow" target="_blank">莱杰纳米s vs x </a></li><li id="5c15" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">加密副本交易平台</a> | <a class="ae lb" href="https://blog.coincodecap.com/bityard-copy-trading" rel="noopener ugc nofollow" target="_blank">比特码副本交易</a></li><li id="8fd1" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" href="https://blog.coincodecap.com/vauld-review" rel="noopener ugc nofollow" target="_blank">Vauld Review</a>|<a class="ae lb" rel="noopener" href="/coinmonks/youhodler-4-easy-ways-to-make-money-98969b9689f2">you hodler Review</a>|<a class="ae lb" rel="noopener" href="/coinmonks/blockfi-review-53096053c097">BlockFi Review</a></li><li id="5243" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">最好的<a class="ae lb" rel="noopener" href="/coinmonks/best-crypto-tax-tool-for-my-money-72d4b430816b">加密税务软件</a> | <a class="ae lb" rel="noopener" href="/coinmonks/cointracking-review-a-reliable-cryptocurrency-tax-software-5114e3eb5737">硬币追踪评论</a></li><li id="7c4f" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">最佳<a class="ae lb" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a> | <a class="ae lb" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆令牌</a></li><li id="ab33" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" href="https://blog.coincodecap.com/ledger-nano-s-vs-trezor-one-ledger-nano-x-trezor-t" rel="noopener ugc nofollow" target="_blank">莱杰纳米S vs特雷佐one vs特雷佐T vs莱杰纳米X </a></li><li id="9efe" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" rel="noopener" href="/coinmonks/blockfi-vs-celsius-vs-hodlnaut-8a1cc8c26630">BlockFi vs Celsius</a>|<a class="ae lb" href="https://blog.coincodecap.com/hodlnaut-review" rel="noopener ugc nofollow" target="_blank">Hodlnaut回顾</a></li><li id="1dc3" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" rel="noopener" href="/coinmonks/bitsgap-review-a-crypto-trading-bot-that-makes-easy-money-a5d88a336df2"> Bitsgap审核</a> | <a class="ae lb" rel="noopener" href="/coinmonks/quadency-review-a-crypto-trading-automation-platform-3068eaa374e1"> Quadency审核</a></li><li id="d689" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" rel="noopener" href="/coinmonks/ellipal-titan-review-85e9071dd029">埃利帕尔泰坦评论</a> | <a class="ae lb" href="https://blog.coincodecap.com/secux-stone-hardware-wallet-review" rel="noopener ugc nofollow" target="_blank">赛克斯斯通评论</a></li><li id="5279" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" href="https://explorer.bitquery.io/ethereum/dex" rel="noopener ugc nofollow" target="_blank">DEX Explorer</a>|<a class="ae lb" href="https://explorer.bitquery.io/graphql" rel="noopener ugc nofollow" target="_blank">w</a>|<a class="ae lb" href="https://blog.coincodecap.com/localbitcoins-review" rel="noopener ugc nofollow" target="_blank">local bitcoins评论</a></li><li id="c46f" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">最佳<a class="ae lb" href="https://bitquery.io/blog/best-blockchain-analysis-tools-and-software" rel="noopener ugc nofollow" target="_blank">区块链分析</a>工具| <a class="ae lb" href="https://blog.coincodecap.com/earn-bitcoin" rel="noopener ugc nofollow" target="_blank">赚比特币</a></li><li id="b037" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" rel="noopener" href="/coinmonks/crypto-arbitrage-guide-how-to-make-money-as-a-beginner-62bfe5c868f6">加密套利</a>指南:新手如何赚钱</li><li id="b46f" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">最佳<a class="ae lb" rel="noopener" href="/coinmonks/what-are-the-best-charting-platforms-for-cryptocurrency-trading-85aade584d80">加密制图工具</a> | <a class="ae lb" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a></li><li id="00df" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" href="https://blog.coincodecap.com/buy-bitcoin-app-india" rel="noopener ugc nofollow" target="_blank">如何在印度购买比特币</a>？</li><li id="5524" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lb" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度比特币交易所</a> | <a class="ae lb" href="https://blog.coincodecap.com/bitcoin-savings-account" rel="noopener ugc nofollow" target="_blank">比特币储蓄账户</a></li><li id="ef45" class="mn mo ht jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv dt translated">了解比特币最好的<a class="ae lb" rel="noopener" href="/coinmonks/what-are-the-best-books-to-learn-bitcoin-409aeb9aff4b">书籍有哪些？</a></li></ul><blockquote class="nn"><p id="b751" class="no np ht bd nq nr of og oh oi oj kd ek translated"><a class="ae lb" rel="noopener" href="/coinmonks/newsletters/coinmonks">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ol om on oo op lw fe ff paragraph-image"><a href="https://medium.com/coinmonks/newsletters/coinmonks"><div class="fe ff ok"><img src="../Images/160ce73bd06d46c2250251e7d5969f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*BoDnKUyK8p4hitHAJZ5Pdw.png"/></div></a></figure></div></div>    
</body>
</html>