<html>
<head>
<title>Bytecraft with web3 and Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用web3和Haskell的Bytecraft</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/bytecraft-with-web3-and-haskell-f91244f1d36e?source=collection_archive---------10-----------------------#2018-06-30">https://medium.com/coinmonks/bytecraft-with-web3-and-haskell-f91244f1d36e?source=collection_archive---------10-----------------------#2018-06-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="788f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jo">(此贴在</em><a class="ae jp" href="https://github.com/antonbobkov/city_building_game_v1/tree/master/hs/minecraft-viewer" rel="noopener ugc nofollow" target="_blank"><em class="jo">github</em></a><em class="jo">)上也有</em></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/d8ff46eb72b8b3c86ae3bfbd3e2d8f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*ZXJtkNhFFQbMIl3rZXOy7Q.png"/></div></figure><p id="c02a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这篇文章中，我们将回顾如何使用Haskell <a class="ae jp" href="https://hackage.haskell.org/package/web3" rel="noopener ugc nofollow" target="_blank"> web3包</a>来制作<a class="ae jp" href="http://bytecraft.club/" rel="noopener ugc nofollow" target="_blank"> bytecraft </a>图像生成器。我们在这里还使用了其他几个包，我将只介绍必要的部分。我们在这里的主要目标是介绍如何在Haskell中使用web3包。</p><p id="a768" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，我们需要加载合同的abi:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="7d09" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是Haskell web3模块的魔法酱。它使用模板Haskell来生成调用我们的智能契约的类型检查的Haskell方法。这就是Haskell成为编写智能合约应用程序的绝佳语言的原因！</p><p id="2d62" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">函数名与ABI中的相匹配。我发现定义一个错误类型的方法来获取签名很有帮助。例如，在我们的例子中，这个</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="ddf5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">给出此误差，单位为千兆赫:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="37f8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这种情况下，<code class="eh ka kb kc kd b">getUpdateTimes</code>是一个采用<code class="eh ka kb kc kd b">Call</code>类型的函数，并返回包装在<code class="eh ka kb kc kd b">Web3</code>类型中的<code class="eh ka kb kc kd b">ListN 1024 (UIntN 256)</code>。我们将很快打开所有这些类型的包装。现在，我们知道这个函数与我们的solidity契约中的以下函数相匹配:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="d421" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的智能合同允许用户从1024x1024的网格中获得32x32的像素块。每个块是1024个像素，有1024个块。要将32x32的8位图像上传到块上，用户必须在块上下注。如果块上已经有一个股份，新的股份必须大于前一个，在这种情况下，前一个股份将返回给它的所有者。</p><p id="38c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该模块中的主要方法是<code class="eh ka kb kc kd b">query</code>:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="aaa0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它接受3个网络参数:输出的文件名前缀、契约地址和web3提供者URL。它还接受表示为<a class="ae jp" href="https://hackage.haskell.org/package/repa-3.4.1.3/docs/Data-Array-Repa.html" rel="noopener ugc nofollow" target="_blank"> repa </a>数组的输入图像。这是最后一个处理的图像，它将被修改以包含自上次调用此函数以来所有更新的块。最后，作为一个<code class="eh ka kb kc kd b">IO</code>操作，它返回一个新更新的图像。</p><p id="9193" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这个方法中，我们要做的第一件事是设置一些助手来帮助调用web3 api:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="a484" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因为我们没有在免费的GCloud实例上运行自己的完整节点，所以我们将依赖外部http提供者。我们的连接需要是<a class="ae jp" href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank"> TLS </a>，所以使用<code class="eh ka kb kc kd b">http-client-tls</code>包中的<code class="eh ka kb kc kd b">newTlsManager</code>是必要的。</p><p id="7fdd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来我们设置<code class="eh ka kb kc kd b">callData</code>，它有我们之前看到的<code class="eh ka kb kc kd b">Call</code>类型。<code class="eh ka kb kc kd b">Call</code>是一个记录类型，包含关于如何进行web3调用的信息。在我们的例子中，我们只关心<code class="eh ka kb kc kd b">callTo</code>参数。有趣的语法来自<code class="eh ka kb kc kd b">data-default</code>包，它为其他参数提供默认值。</p><p id="cb58" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh ka kb kc kd b">provider</code>是我们将web3 RPC调用发送到的地方。最后<code class="eh ka kb kc kd b">doW3</code>使用我们刚刚创建的管理器和提供者发出请求。<code class="eh ka kb kc kd b">doW3</code>用我们刚刚创建的管理器和提供者调用<code class="eh ka kb kc kd b">runWeb3With</code>。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="7fe3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们之前看到过<code class="eh ka kb kc kd b">Web3</code>单子。它包装一个web3 RPC调用，并且<code class="eh ka kb kc kd b"><a class="ae jp" href="http://hackage.haskell.org/package/web3-0.7.3.0/docs/Network-Ethereum-Web3-Provider.html#v:runWeb3With" rel="noopener ugc nofollow" target="_blank">runWeb3With</a></code>在<code class="eh ka kb kc kd b">IO</code>单子内执行<code class="eh ka kb kc kd b">Web3</code>单子。</p><p id="1fda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，我们轮询每个区块更新的最后一个块号。我们还对契约本身进行最后一次轮询，以便与中的缓存值进行比较..lastUpdate.json ":</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="a078" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里我们看到了我们的第一个web3调用！使用<code class="eh ka kb kc kd b">doW3</code>和<code class="eh ka kb kc kd b">callData</code>我们将得到一个<code class="eh ka kb kc kd b">m (Either Web3Error a)</code>类型的值。在这个例子中我们不做任何错误处理，所以你会经常看到类似<code class="eh ka kb kc kd b">either throw id updateTimes'</code>的表达式。这为我们提供了数据，但它属于<code class="eh ka kb kc kd b">ListN 1024 (UIntN 256)</code>类型。这些来自<code class="eh ka kb kc kd b"><a class="ae jp" href="http://hackage.haskell.org/package/web3-0.7.3.0/docs/Network-Ethereum-ABI-Prim.html" rel="noopener ugc nofollow" target="_blank">Network.Ethereum.ABI.Prim</a></code>模块，其中包含所有EVM类型的表示。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="1e2f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你需要EVM类型的复习，这是一个检查<a class="ae jp" href="http://solidity.readthedocs.io/en/v0.4.24/" rel="noopener ugc nofollow" target="_blank">可靠性文档</a>的好时机。</p><p id="9899" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">回头看看<code class="eh ka kb kc kd b"> getUpdateTimes</code>的定义，我们看到实度类型<code class="eh ka kb kc kd b">uint[1024]</code>变成了<code class="eh ka kb kc kd b">ListN 1024 (UintN 256)</code>。这是一个256位无符号整数的1024元素列表，两个大小都固定在类型级别！<code class="eh ka kb kc kd b">ListN</code>是<code class="eh ka kb kc kd b">IsList</code>的一个实例，其类型系列<code class="eh ka kb kc kd b">Item</code>被实现为</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="c7de" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">其中有方法</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="75ee" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们更熟悉的<code class="eh ka kb kc kd b">[Int]</code>使用</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="a6fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh ka kb kc kd b">UIntN</code>是<code class="eh ka kb kc kd b">Integral</code>的一个实例，所以我们可以使用<code class="eh ka kb kc kd b">fromIntegral</code>来转换它。</p><p id="dea0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好吧！因此，现在我们从智能合约中获得了第一个Haskell原语！接下来，我们想从每个块中获取实际的图像数据:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="0d2f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用<code class="eh ka kb kc kd b">updateTimes</code>我们构建了一个我们想要查询的块的<code class="eh ka kb kc kd b">(x,y)</code>索引列表。这些查询被分组为8个一批(使用助手函数<code class="eh ka kb kc kd b">group :: Int -&gt; [a] -&gt; [[a]]</code>)，并使用<code class="eh ka kb kc kd b">monad-parallel</code>包中的<code class="eh ka kb kc kd b">forM</code>并行执行。如果一次发出的请求太多，提供程序就会开始拒绝请求，并且按顺序运行这些请求会非常慢。8运行得够快了，我的治疗师/治疗师还没有拒绝我们的任何请求。</p><p id="e830" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<code class="eh ka kb kc kd b"> queryBlock</code>函数中，您将看到一个更有趣的转换:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="adca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">分别使用<code class="eh ka kb kc kd b">abiGet</code>和<code class="eh ka kb kc kd b">abiPut</code>可以将所有ABI原语转换为<code class="eh ka kb kc kd b">Get</code>和<code class="eh ka kb kc kd b">Put</code>的实例(来自<code class="eh ka kb kc kd b">binary</code>包)。<code class="eh ka kb kc kd b">runPut (abiPut color)</code>将代表原始8位图像数据的ABI原语<code class="eh ka kb kc kd b">ListN 32 (BytesN 32)</code>转换为<code class="eh ka kb kc kd b">ByteString</code>。<code class="eh ka kb kc kd b">Web3</code>是<code class="eh ka kb kc kd b">MonadIO</code>的一个实例，所以我们也用<code class="eh ka kb kc kd b">liftIO (putStrLn ...)</code>做一些进度记录。</p><p id="1338" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">稍后，我们将遍历表示为<code class="eh ka kb kc kd b">repa</code>数组的32位图像，将原始的8位图像数据转换并复制到正确的位置。该操作所需的所有数据都存储在<code class="eh ka kb kc kd b">ChunkInfo</code>中</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="ea34" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">回到<code class="eh ka kb kc kd b">query</code>方法。我们还有一些簿记工作要做。我不会在这里赘述，因为它不是web3特有的。最后一步是运行前面描述的图像转换过程，并返回输出:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="jy jz l"/></div></figure><p id="6625" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">就是这样！我希望你像我一样喜欢编写自己的web3 Haskell应用程序。或许试试我们的智能合同。</p><p id="93b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">bytecraft契约拥有任何被标在瓷砖上的以太。我们拥有任何到这里的以太<strong class="is hu"><em class="jo">0x 0d8a 07 e 01 FD 9 B3 da 4 ce 78109 DBD FD 385 be 59 BAE 2</em></strong></p></div></div>    
</body>
</html>