<html>
<head>
<title>Exploring Smart Contracts as Actors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索作为参与者的智能合同</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/exploring-smart-contracts-as-actors-eee23499a59d?source=collection_archive---------2-----------------------#2020-03-26">https://medium.com/coinmonks/exploring-smart-contracts-as-actors-eee23499a59d?source=collection_archive---------2-----------------------#2020-03-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="70bf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">智能合约背后的<a class="ae jo" href="https://blog.coincodecap.com/tag/cryptocurrency/" rel="noopener ugc nofollow" target="_blank">并发</a>模型到目前为止已经有很多方面的讨论和分析。在2017年发表的一篇漂亮的<a class="ae jo" href="https://arxiv.org/pdf/1702.05511.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>中，Ilya Sergey和Aquinas Hobor探索了智能合约和共享内存并发之间的相似之处。在Medium上发表的另一篇<a class="ae jo" rel="noopener" href="/spadebuilders/actor-factor-2b0005fde786">文章</a>中，Brooklyn Zelenka做了同样的事情，使用演员模型作为比较术语。</p><p id="c146" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这篇文章中，我将继续Brooklyn的想法，并进一步探索<a class="ae jo" href="https://blog.coincodecap.com/tag/smart-contact/" rel="noopener ugc nofollow" target="_blank">智能契约</a>和actors之间的差异和相似之处，重点关注这两种方法的类型安全性。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/97b81c32ea5caf394c0e0ba75a98b318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ViVdPHaIwiBpuCHBGYag1w.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Photo by <a class="ae jo" href="http://www.nyphotographic.com/" rel="noopener ugc nofollow" target="_blank">Nick Youngson</a> on <a class="ae jo" href="https://www.picpedia.org/highway-signs/p/protocol.html" rel="noopener ugc nofollow" target="_blank">Picpedia</a></figcaption></figure></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="ef9d" class="km kn ht bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">演员模型的简短说明</h1><p id="bba2" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">卡尔·休伊特、彼得·毕晓普和理查德·施泰格在1973年发表的一篇论文中首次将演员模型理论化:</p><blockquote class="lp lq lr"><p id="4918" class="iq ir ls is b it iu iv iw ix iy iz ja lt jc jd je lu jg jh ji lv jk jl jm jn hm dt translated">“Actor Model受到高度并行计算<br/>机器前景的推动，这些机器由数十、数百甚至数千个独立的<br/>微处理器组成，每个微处理器都有自己的本地存储器和通信处理器，T10通过高性能通信网络进行通信。”<br/>卡尔·休伊特<strong class="is hu"/></p></blockquote><p id="d444" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">演员和物体很相似。因此，它们可能拥有也可能不拥有内部状态(可能是可变的或不可变的)并公开方法来与之交互和修改它。然而，与对象不同的是，这样的方法不能被直接调用。事实上，与演员互动的唯一方式是向其发送信息。</p><p id="e7c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">参与者模型中的消息有四个主要特征:</p><ul class=""><li id="8280" class="lw lx ht is b it iu ix iy jb ly jf lz jj ma jn mb mc md me dt translated">它们是<strong class="is hu">异步</strong>(即发送方不阻塞等待响应)；</li><li id="4454" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">它们是<strong class="is hu">不可变的</strong>(即发送后不可修改)；</li><li id="ec68" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">它们被放入actor的邮箱，这个邮箱只是一个待处理消息的队列；</li><li id="9812" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">actor一次检查其邮箱中的一条消息，并在其线程中进行处理。</li></ul><p id="19bf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这四个特征确保不会发生竞争情况。事实上，消息是交互和修改参与者内部状态的唯一方式。然而，由于这种消息是由参与者本身一次处理一个(在一个线程中)，所以不可能出现争用情况(除非将状态的引用作为消息的参数传递，在这种情况下，参与者将失去对其状态的控制)。</p><p id="1dd3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，参与者和线程之间没有一一对应的关系。事实上，演员只是从池中“借用”线程。</p><h1 id="abc2" class="km kn ht bd ko kp mk kr ks kt ml kv kw kx mm kz la lb mn ld le lf mo lh li lj dt translated">智能合同和参与者</h1><h2 id="093e" class="mp kn ht bd ko mq mr ms ks mt mu mv kw jb mw mx la jf my mz le jj na nb li nc dt translated">一点术语</h2><p id="a552" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated"><em class="ls">智能合同</em>是使用<a class="ae jo" href="https://blog.coincodecap.com/tag/blockchain/" rel="noopener ugc nofollow" target="_blank">区块链</a>平台来执行特定操作的应用程序，例如在不依赖可信第三方实体的情况下交换信息或金钱。</p><p id="f1f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">智能契约非常像面向对象编程范式中的一个类，因此，它有一个状态并公开一组函数。调用函数是“激活”一个<a class="ae jo" href="https://blog.coincodecap.com/tag/smart-contact/" rel="noopener ugc nofollow" target="_blank">智能契约</a>的唯一方式，通常发生在事务的上下文中。</p><h2 id="5b20" class="mp kn ht bd ko mq mr ms ks mt mu mv kw jb mw mx la jf my mz le jj na nb li nc dt translated">并行的观点</h2><p id="b1db" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">乍一看，智能合同和参与者有许多相似之处:</p><ul class=""><li id="e65f" class="lw lx ht is b it iu ix iy jb ly jf lz jj ma jn mb mc md me dt translated">状态突变是消息/事务的结果；</li><li id="d074" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">消息被序列化，一次处理一条消息；</li><li id="38fd" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">消息是不可变的；</li><li id="22bd" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">需要一个地址来与一个演员或一个合同进行交互，并且地址是唯一的；</li><li id="5118" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">参与者和契约可以决定如何处理一个消息，可能会拒绝它；</li><li id="3629" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">它们都可以产生新的参与者/合同；</li><li id="ea26" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">他们都必须被杀死和再生，以修复他们行为中的错误。不过，对于合约来说，这就更加微妙了，因为它们也需要保持平衡。</li></ul><p id="d9ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，也有一些显著的差异:</p><ul class=""><li id="6a9c" class="lw lx ht is b it iu ix iy jb ly jf lz jj ma jn mb mc md me dt translated">一个智能契约很可能公开它的状态，任何引用它的其他契约都可以很容易地修改它的状态。这通常是通过生成状态变量<code class="eh nd ne nf ng b">public</code>来完成的；</li><li id="047b" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">契约有一种平衡，必须小心处理，以免招致不愉快的情况(读道)；</li><li id="d3f5" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">默认情况下，参与者是并发和异步的，而智能合约不是(在一个事务中)。这意味着只有第一次函数调用(发起事务的那个)是异步运行的，但是从那时起，该事务中发生的任何函数调用都将是同步的；</li><li id="ffe4" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">联系到前面的要点，参与者系统中的事务边界是单个参与者。这对于智能契约来说是不正确的，因为一个事务可以跨越不同契约的多次调用；</li><li id="1bd4" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">事务和状态变化保证在<a class="ae jo" href="https://blog.coincodecap.com/tag/blockchain/" rel="noopener ugc nofollow" target="_blank">区块链</a>中持久化(对于智能契约)，然而对于参与者来说这可能不是真的；</li><li id="75d2" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">智能合约的执行，在<a class="ae jo" href="https://blog.coincodecap.com/tag/ethereum/" rel="noopener ugc nofollow" target="_blank">以太坊</a>被所谓的gas所束缚。</li></ul><p id="5032" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">正如我们刚刚看到的，actors和smart contracts在处理传入消息的方式上非常相似，但是在并发行为和保持内部状态一致的影响上有很大的不同。事实上，Ilya Sergey在他的论文中描述了<em class="ls">并发对象</em>和智能契约之间的相似之处，强调了由于前者常见的笨拙实现而导致的错误可能会影响后者。</p><h1 id="fd6b" class="km kn ht bd ko kp mk kr ks kt ml kv kw kx mm kz la lb mn ld le lf mo lh li lj dt translated">符合协议</h1><h2 id="ffc5" class="mp kn ht bd ko mq mr ms ks mt mu mv kw jb mw mx la jf my mz le jj na nb li nc dt translated">“神谕”如何让事情变得更糟</h2><p id="14f2" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">当处理区块链之外的程序时，智能合约的“双重”并发行为也带来了一些挑战。在<a class="ae jo" href="https://blog.coincodecap.com/tag/ethereum/" rel="noopener ugc nofollow" target="_blank">以太坊</a>中，常见的解决方案是所谓的“<a class="ae jo" href="https://blog.coincodecap.com/ethereum-smart-contracts-and-the-oracle-problem/" rel="noopener ugc nofollow" target="_blank"> oracle模式</a>”，oracle是被授权向契约发送数据的实体(通过调用它的一个函数)。区块链并不验证数据的真实性，但是所有节点都同意这一点。</p><p id="5574" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这在理论上听起来不错，但天堂里有麻烦。在调用oracle和回调契约之间可能会经过任意长的时间。在此期间，合同可能会更改其状态，这可能会影响oracle输出的处理方式。</p><p id="5971" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个问题不仅与神谕有关。您可能还记得，智能契约一直受到可重入性问题的困扰，例如，那些涉及到DAO的问题。</p><p id="cd53" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这两种情况下，问题都源于这样一个事实，即坚固性对执行<strong class="is hu">协议</strong>没有任何帮助。</p><h1 id="cff8" class="km kn ht bd ko kp mk kr ks kt ml kv kw kx mm kz la lb mn ld le lf mo lh li lj dt translated">参与者、合同和协议</h1><p id="f852" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">参与者模型的最初表述没有提到协议或者如何实施它们。以太坊和实性也是一样。</p><p id="c33d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我特别喜欢的一个“协议”的同义词是“约定”:协议就是两方或多方之间，关于如何执行某事的协议。在oracle的情况下，它可能涉及Oracle回调契约时的预期状态。这通常通过将参与方建模为状态机来完成，每个状态机在每个状态中公开特定的功能(即接受特定的消息)。</p><p id="0d18" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通常的例子是一个文件:</p><ol class=""><li id="ec24" class="lw lx ht is b it iu ix iy jb ly jf lz jj ma jn nh mc md me dt translated">初始状态为<code class="eh nd ne nf ng b">Close</code>；</li><li id="9c84" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn nh mc md me dt translated">只有在<code class="eh nd ne nf ng b">Close</code>状态下才能<code class="eh nd ne nf ng b">open</code>ed；</li><li id="4533" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn nh mc md me dt translated">一旦为<code class="eh nd ne nf ng b">Open</code>，可用于<code class="eh nd ne nf ng b">read</code>和<code class="eh nd ne nf ng b">write</code>操作，也可再次为<code class="eh nd ne nf ng b">close</code> d。</li></ol><p id="4666" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所谓的“面向类型状态”编程允许在面向对象编程语言中定义协议，而不需要太多样板代码。当涉及到类型系统时，它们应该跟踪对象所处的状态，拒绝(即代码不编译)对该特定状态不支持的方法或操作的调用。这种方法应该更容易正确地推理协议，而不会迷失在笨拙的语法中。</p><p id="729d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，actor模型的许多实现都内置了对协议的支持。Akka就是一个例子，尤其是随着Akka Typed的出现。另一方面，Solidity没有提供任何显式的方法来将契约建模为状态机并定义协议。为了克服这个“限制”，一些语言被设计成支持面向类型状态的编程。其中最著名的是Obsidian，它是专门为提供更强的类型安全保证而设计的，并允许协议的规范。</p><h1 id="ee9e" class="km kn ht bd ko kp mk kr ks kt ml kv kw kx mm kz la lb mn ld le lf mo lh li lj dt translated">摘要</h1><p id="3e2a" class="pw-post-body-paragraph iq ir ht is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hm dt translated">交互契约——oracle可以从协议的引入中受益:契约可以忽略所有会修改其状态的方法调用，使Oracle假定的先决条件无效。</p><p id="f941" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">稳固性转向可能为时已晚，但黑曜石背后的想法可以帮助其他区块链使用面向协议的智能合同。</p><h1 id="464b" class="km kn ht bd ko kp mk kr ks kt ml kv kw kx mm kz la lb mn ld le lf mo lh li lj dt translated">参考资料和进一步阅读</h1><ul class=""><li id="06e6" class="lw lx ht is b it lk ix ll jb ni jf nj jj nk jn mb mc md me dt translated">智能合同的并行观点，伊利亚·谢尔盖和阿奎那·霍博尔，<a class="ae jo" href="https://arxiv.org/pdf/1702.05511.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1702.05511.pdf</a></li><li id="00eb" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">演员因素，布鲁克林泽伦卡，【https://medium.com/spadebuilders/actor-factor-2b0005fde786 T2】</li><li id="08e5" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">人工智能的通用模块演员形式主义，卡尔·休伊特，彼得·毕晓普，理查德·施泰格，【https://www.ijcai.org/Proceedings/73/Papers/027B.pdf】T4</li><li id="aeca" class="lw lx ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">黑曜石，更安全的区块链编程的类型状态和资产，<a class="ae jo" href="https://arxiv.org/pdf/1909.03523.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1909.03523.pdf</a></li></ul><blockquote class="nl"><p id="e82b" class="nm nn ht bd no np nq nr ns nt nu jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nw nx ny nz oa ju fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nv"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>