<html>
<head>
<title>ZKSnarks and Jabba’s Palace</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ZKSnarks和贾巴的宫殿</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/zksnarks-and-jabbas-palace-c0f819859f2d?source=collection_archive---------0-----------------------#2017-12-11">https://medium.com/coinmonks/zksnarks-and-jabbas-palace-c0f819859f2d?source=collection_archive---------0-----------------------#2017-12-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="c0e6" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">贾巴的保险箱</h2></div><p id="13dd" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这篇文章将讨论贾巴的宫殿是如何对付各种通过使用ZKSnarks进入的星际渣滓的。贾巴的名字并不等同于信任，经常出现在他宫殿里的赏金猎人和地痞无赖更不值得信任。尽管贾巴的交易肆无忌惮，但他的锁箱生意却蒸蒸日上——可疑人物可以在这里存放他们不想被窥探的东西。贾巴雇佣我们设计一个安全系统，如果顾客有有效的锁箱密码，就可以进入宫殿。有趣的是，客户不应该给贾巴或他的同伙密码箱的安全码，而是一些识别码。安全系统应该能够在不知道用户密码的情况下验证用户。</p><p id="b78d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我在网上搜索了一个很好的zksnark例子，发现了这两篇文章。我大量借鉴了内容来创作这篇文章</p><ul class=""><li id="5487" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km dt translated"><a class="ae kn" href="https://media.consensys.net/introduction-to-zksnarks-with-examples-3283b554fc3b" rel="noopener ugc nofollow" target="_blank">https://media . consensys . net/introduction-to-zksnarks-with-examples-3283 b 554 fc3b</a></li><li id="ae3a" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km dt translated">https://asecuritysite.com/encryption/zksnark01<a class="ae kn" href="https://asecuritysite.com/encryption/zksnark01" rel="noopener ugc nofollow" target="_blank"/></li></ul><h2 id="bbd0" class="kt ku ht bd kv kw kx ky kz la lb lc ld jr le lf lg jv lh li lj jz lk ll lm ln dt translated">ZKSnarks</h2><p id="1e16" class="pw-post-body-paragraph ji jj ht jk b jl lo iu jn jo lp ix jq jr lq jt ju jv lr jx jy jz ls kb kc kd hm dt translated">术语ZKSnark代表<em class="lt">零知识简洁的非交互式知识论证</em>，用于证明某人知道一个秘密，而不需要他们分享秘密本身。进入贾巴的宫殿是ZKSnark的完美用法，因为主人可以证明他们有一个带锁的箱子，然后才被允许进入宫殿，而不需要分享锁箱本身的密码。</p></div><div class="ab cl lu lv hb lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hm hn ho hp hq"><h2 id="d8f6" class="kt ku ht bd kv kw kx ky kz la lb lc ld jr le lf lg jv lh li lj jz lk ll lm ln dt translated">方程式</h2><p id="c3e6" class="pw-post-body-paragraph ji jj ht jk b jl lo iu jn jo lp ix jq jr lq jt ju jv lr jx jy jz ls kb kc kd hm dt translated"><em class="lt">生成器</em> —这个函数是zksnark过程的核心。它最终负责以零知识的方式运行验证逻辑。</p><p id="177f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="lt">证明者</em> —这个帮助器函数是生成器提供给我们的，作为一种对验证者隐藏锁箱代码的方法，但是给了他们一个可以验证的替代值。这个函数的输出被称为证明，并被传递给验证者。</p><p id="7229" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="lt"> Verifier — </em>这个辅助函数也是生成器给我们的，作为验证证明者给我们的证明的一种手段。它将返回true或false，以指示证明者是否已经验证了他们对已知秘密或有效锁箱代码的了解。</p><p id="f77e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">生成器采用逻辑函数(<em class="lt">条件)</em>和秘密参数(<em class="lt">λ</em>)，并返回<em class="lt">证明</em>函数和<em class="lt">验证</em>函数。</p><p id="b34f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu"> <em class="lt">注意，为了使系统可信，这些函数的底层代码应该对输入代码的人和接收证明的人可见。条件函数可以被逆向工程，因为它背后有逻辑，但真正的秘密是lambda参数。如果这个随机参数被泄露，那么系统将受到危害。</em>T3】</strong></p><p id="8e67" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们将直接进入贾巴宫殿的例子，所以请做好准备…</p><h2 id="443a" class="kt ku ht bd kv kw kx ky kz la lb lc ld jr le lf lg jv lh li lj jz lk ll lm ln dt translated">情况</h2><p id="2406" class="pw-post-body-paragraph ji jj ht jk b jl lo iu jn jo lp ix jq jr lq jt ju jv lr jx jy jz ls kb kc kd hm dt translated">假设我们已经将所有的锁箱代码设计为5个一位数，并且我们知道所有的数字加在一起应该等于13。所以，想象一个自行车密码锁，有5个数字可以选择0-9。一个示例组合可以是<em class="lt"> 11641。</em>注意，1+1+6+4+1 = 13。所以这是一个有效的密码，可以让我们进入贾巴的宫殿。我们的条件函数可以描述如下:</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="7d0c" class="kt ku ht mg b fv mk ml l mm mn"><strong class="mg hu">function </strong>requiredCondition(){<br/>  <strong class="mg hu">return </strong>13;<br/>}</span></pre><p id="fbbe" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这显然不是超级安全的，因为它很容易被猜到——然而，这就是<em class="lt">λ</em>的用武之地。</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="7de7" class="kt ku ht mg b fv mk ml l mm mn"><strong class="mg hu">const </strong>lambda = Math.floor((Math.random() * 1000000) + 1); //random number between 1 and a million</span></pre><p id="cd93" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">有了这两个输入，我们现在就可以创建生成器函数了</p><h2 id="11c9" class="kt ku ht bd kv kw kx ky kz la lb lc ld jr le lf lg jv lh li lj jz lk ll lm ln dt translated">发电机</h2><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="1079" class="kt ku ht mg b fv mk ml l mm mn">//random variable to make lockbox code difficult to guess<br/><strong class="mg hu">const </strong>lambda = Math.floor((Math.random() * 1000000) + 1); //random number between 1 and a million</span><span id="00ff" class="kt ku ht mg b fv mo ml l mm mn">//logic for a lockbox code to be considered valid<br/><strong class="mg hu">function </strong>requiredCondition(){<br/>  <strong class="mg hu">return </strong>13;<br/>}</span><span id="d99c" class="kt ku ht mg b fv mo ml l mm mn">//generator implementation<br/><strong class="mg hu">function </strong>generator(condition, lambda) {<br/>  <strong class="mg hu">return </strong>{<br/>    proofFunction: (code)=&gt;{<strong class="mg hu">return </strong>(code.reduce((a, b)=&gt; a+b)) + lambda},<br/>    verifyFunction: (proof)=&gt;{<strong class="mg hu">return </strong>(condition() + lambda === proof)}<br/>  };<br/>}</span></pre><p id="95ef" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">瞧啊。看看我们如何通过要求锁箱总和等于13 +一个介于1到100万之间的随机数来增加证明的难度。我们以后可能会改进这一点，但目前来说难度已经足够了。我们生成生成器客户端，传送到博巴-费特的巡洋舰和贾巴的宫殿。</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="d053" class="kt ku ht mg b fv mk ml l mm mn">//Generator usage - dispose of lambda by ionizing it<br/><strong class="mg hu">const </strong>generatorClient = generator(requiredCondition, lambda);</span><span id="f010" class="kt ku ht mg b fv mo ml l mm mn">//Send to bobba-fett<br/>BountyChat().send(<br/>'bobba-fett@hotmail.com',<br/>"Bobba, Long time... Use this proofFunction to get into Jabba's",<br/>generatorClient.proofFunction);</span><span id="c2b9" class="kt ku ht mg b fv mo ml l mm mn">//Send to Jabba's Palace<br/>GangsterChat().send(<br/>'jabba@hotmail.com',<br/>"Jabba, Salutations... Use this verifyFunction for entry security",<br/>generatorClient.verifyFunction);</span></pre><p id="b585" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">证明</strong></p><p id="231b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">博巴-费特将证明函数加载到他的计算机中，并对代码进行一些诊断，以查看它是否可信。看起来没问题，所以他跳进超空间去看他的锁箱。他让巡洋舰着陆，把锁箱密码输入他手臂上的键盘，然后把生成的证明传送到贾巴前门的数据端口。</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="d085" class="kt ku ht mg b fv mk ml l mm mn">//Bobba enters his code of 11641<br/><strong class="mg hu">const </strong>proof = generatorClient.proofFunction([1,1,6,4,1]);</span></pre><p id="6901" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">proof函数生成一个有效值，因为他的代码加起来是13。</p><p id="519b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">验证</strong></p><p id="6b68" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">贾巴的安全主管已经将验证功能加载到他们的安全系统中，并用它来验证博巴的证据</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="9711" class="kt ku ht mg b fv mk ml l mm mn">//Verifies Bobba's proof of access Jabba's security system<br/>const verified = verifyFunction(proof)</span></pre><p id="10de" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">证据被证实是真的，博巴被允许进入宫殿，以便将他的密码输入他的锁箱。<strong class="jk hu">注意，传递给保安的唯一值是<em class="lt"> 13 </em>，他们无法知道每个锁箱的编号。</strong>以下是完整代码:</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="6e33" class="kt ku ht mg b fv mk ml l mm mn">//random variable to make lockbox code condition to guess<br/><strong class="mg hu">const </strong>lambda = Math.floor((Math.random() * 1000000) + 1); //random number between 1 and a million</span><span id="44e1" class="kt ku ht mg b fv mo ml l mm mn">//logic for a lockbox code to be considered valid<br/><strong class="mg hu">function </strong>requiredCondition(){<br/>  <strong class="mg hu">return </strong>13;<br/>}</span><span id="d4ba" class="kt ku ht mg b fv mo ml l mm mn">//generator implementation<br/><strong class="mg hu">function </strong>generator(condition, lambda) {<br/>  <strong class="mg hu">return </strong>{<br/>    proofFunction: (code)=&gt;{<strong class="mg hu">return </strong>(code.reduce((a, b)=&gt; a+b)) + lambda},<br/>    verifyFunction: (proof)=&gt;{<strong class="mg hu">return </strong>(condition() + lambda === proof)}<br/>  };<br/>}</span><span id="59a8" class="kt ku ht mg b fv mo ml l mm mn">//Generator usage<br/><strong class="mg hu">const </strong>generatorClient = generator(requiredCondition, lambda);</span><span id="5477" class="kt ku ht mg b fv mo ml l mm mn">//Bobba enters his code of 11641<br/><strong class="mg hu">const </strong>lockBoxCode = [1,1,6,4,1];<br/><strong class="mg hu">const </strong>proof = generatorClient.proofFunction(lockBoxCode);</span><span id="bf9b" class="kt ku ht mg b fv mo ml l mm mn">//Security verifies it<br/><strong class="mg hu">const </strong>verified = generatorClient.verifyFunction(proof);</span><span id="c6b7" class="kt ku ht mg b fv mo ml l mm mn"><strong class="mg hu">if</strong>(verified) {<br/>  console.log("Prover CAN prove that they know the values: "+lockBoxCode+" that total to: "+requiredCondition());<br/>} <strong class="mg hu">else </strong>{<br/>  console.log("Prover CANNOT prove that they know the values: "+lockBoxCode+" that total to: "+requiredCondition());<br/>}</span></pre><h2 id="31dc" class="kt ku ht bd kv kw kx ky kz la lb lc ld jr le lf lg jv lh li lj jz lk ll lm ln dt translated">进攻！</h2><p id="e12c" class="pw-post-body-paragraph ji jj ht jk b jl lo iu jn jo lp ix jq jr lq jt ju jv lr jx jy jz ls kb kc kd hm dt translated">这是一个积极的场景，让我们来看一个案例，一个卑鄙的家伙，格里多截获了我们发给博巴-费特的信息，并试图在没有有效锁箱的情况下进入宫殿。格里多可以读取发送的证明函数，但他不知道lambda。他可以看到代码必须相加，但不知道有效的总和应该是多少。</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="babc" class="kt ku ht mg b fv mk ml l mm mn">(code)=&gt;{<strong class="mg hu">return </strong>(code.reduce((a, b)=&gt; a+b)) + lambda}</span></pre><p id="f440" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">格里多试图输入以下值，在他第三次尝试后，他被安全部门抓获并喂给了兰克。</p><pre class="mb mc md me fq mf mg mh mi aw mj dt"><span id="c5b3" class="kt ku ht mg b fv mk ml l mm mn">//Greedo enters his code of 66666<br/><strong class="mg hu">const </strong>lockBoxCode = [6,6,6,6,6];<br/><strong class="mg hu">const </strong>proof = generatorClient.proofFunction(lockBoxCode);<br/>//failure 1</span><span id="863d" class="kt ku ht mg b fv mo ml l mm mn">//Greedo enters his code of 65432<br/><strong class="mg hu">const </strong>lockBoxCode = [6,5,4,3,2];<br/><strong class="mg hu">const </strong>proof = generatorClient.proofFunction(lockBoxCode);<br/>//failure 2</span><span id="b51a" class="kt ku ht mg b fv mo ml l mm mn">//Greedo enters his code of 12345<br/><strong class="mg hu">const </strong>lockBoxCode = [1,2,3,4,5];<br/><strong class="mg hu">const </strong>proof = generatorClient.proofFunction(lockBoxCode);<br/>//failure 3</span></pre><h2 id="123c" class="kt ku ht bd kv kw kx ky kz la lb lc ld jr le lf lg jv lh li lj jz lk ll lm ln dt translated">摘要</h2><p id="9ea5" class="pw-post-body-paragraph ji jj ht jk b jl lo iu jn jo lp ix jq jr lq jt ju jv lr jx jy jz ls kb kc kd hm dt translated">我们使用了一个ZKSnark来控制贾巴宫殿的入口，只允许那些拥有有效密码的角色进入。请注意，一旦角色进入宫殿，他们仍然必须将他们的代码输入到锁箱中才能访问其中的内容。贾巴似乎对这个解决方案很满意，并给予我们2，000，000信用点作为对我们努力的奖励。</p><blockquote class="mp"><p id="ed36" class="mq mr ht bd ms mt mu mv mw mx my kd ek translated"><a class="ae kn" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="na nb nc nd ne nf fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mz"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>