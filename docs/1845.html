<html>
<head>
<title>8 Ways of Reducing the Gas Consumption of your Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">降低智能合同油耗的8种方法</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/8-ways-of-reducing-the-gas-consumption-of-your-smart-contracts-9a506b339c0a?source=collection_archive---------0-----------------------#2018-12-02">https://medium.com/coinmonks/8-ways-of-reducing-the-gas-consumption-of-your-smart-contracts-9a506b339c0a?source=collection_archive---------0-----------------------#2018-12-02</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="3424" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我目前正在做一个Dapp项目(<a class="jo jp gr" href="https://medium.com/u/f4b3a95f66b7?source=post_page-----9a506b339c0a--------------------------------" rel="noopener" target="_blank"> Shape </a>)，它的第一个主要开发阶段已经接近尾声。由于交易成本一直是开发人员关心的一个大问题，我想通过这篇文章来分享我在过去几周/几个月中在优化方面获得的一些见解。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/2f429953464f31a73678a6eab0965832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N0ODhAxqWx2iLANx"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">“closeup photo of 100 US dollar banknotes” by <a class="ae kg" href="https://unsplash.com/@timbatec?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pepi Stojanovski</a> on <a class="ae kg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d084" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面，我给出了一个优化技术的列表，其中一些参考了关于这个主题的更详细的文章，您可以将它们应用到您的合同设计中。我将从一些更基本、更熟悉的概念开始，然后随着我们的进展变得更复杂。</p><h1 id="210e" class="kh ki ht bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">目录</h1><h2 id="db78" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">1.首选数据类型</h2><h2 id="f2d9" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">2.在契约的字节码中存储值</h2><h2 id="ed00" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">3.通过SOLC将变量打包到单个插槽中</h2><h2 id="c718" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">4.用程序集将变量打包到单个插槽中</h2><h2 id="ba93" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">5.连接函数参数</h2><h2 id="d65a" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">6.减少存储负载的Merkle证明</h2><h2 id="54c5" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">7.无状态合同</h2><h2 id="5631" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">8.存储IPFS的数据</h2></div><div class="ab cl lt lu hb lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hm hn ho hp hq"><h2 id="8b7b" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">1.首选数据类型</h2><p id="55be" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hm dt translated">这可以用几句话来回答:<strong class="is hu">使用256位变量</strong>，因此uint256和bytes32！乍一看，这似乎有点违背直觉，但是当你更仔细地思考以太坊虚拟机(EVM)是如何操作的，这就完全说得通了。每个存储槽有256位。因此，如果你只存储一个uint8，EVM会用零填充所有缺失的数字——这很费油。此外，计算也毫无例外地由EVM在uint256中执行，因此这里除了uint256之外的任何类型也必须被转换。</p><p id="62d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">注意:一般来说，你的目标应该是调整变量的大小，使整个存储槽都被填满。在“<em class="mf">通过SOLC将变量打包到单个槽中”</em>一节中，当使用少于256位的变量更有意义时，这一点会变得更加清楚。</p><blockquote class="mg"><p id="90fd" class="mh mi ht bd mj mk ml mm mn mo mp jn ek translated">交易新手尝试<a class="ae kg" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或<a class="ae kg" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div><div class="ab cl lt lu hb lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hm hn ho hp hq"><h2 id="67d8" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">2.在契约的字节码中存储值</h2><p id="6dd4" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hm dt translated">一种相对便宜的存储和读取信息的方式是，当在区块链上部署智能合约时，将它们直接包含在智能合约的字节码中。不利的一面是，这个值以后不能改变。然而，加载和存储数据的气体消耗将大大减少。有两种可能的实现方式:</p><ol class=""><li id="1039" class="mq mr ht is b it iu ix iy jb ms jf mt jj mu jn mv mw mx my dt translated">将关键字<em class="mf">常量</em>附加到变量声明中</li><li id="d69f" class="mq mr ht is b it mz ix na jb nb jf nc jj nd jn mv mw mx my dt translated">将变量硬编码到任何需要使用它的地方。</li></ol><pre class="jr js jt ju fq ne nf ng nh aw ni dt"><span id="bffe" class="lf ki ht nf b fv nj nk l nl nm">uint256 public v1;<br/>uint256 public <strong class="nf hu">constant</strong> v2;</span><span id="fea9" class="lf ki ht nf b fv nn nk l nl nm">function calculate() returns (uint256 result) {<br/>    return v1 * v2 * 10000<br/>}</span></pre><p id="7a18" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">变量<em class="mf"> v1 </em>将是契约状态的一部分，而<em class="mf"> v2 </em>以及<em class="mf"> 1000 </em>是契约字节码的一部分。</p><p id="fe18" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="mf">(读取v1是通过SLOAD操作进行的，仅SLOAD操作就已经消耗了200气。)</em></p></div><div class="ab cl lt lu hb lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hm hn ho hp hq"><h2 id="21aa" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">3.通过SOLC将变量打包到单个插槽中</h2><p id="a278" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hm dt translated">当您在区块链上永久存储数据时，汇编命令SSTORE将在后台执行。这是最昂贵的命令，花费20，000汽油，所以我们应该尽量少用它。在结构内部，通过简单地重新排列变量，可以减少所执行的存储操作的数量，如下例所示:</p><pre class="jr js jt ju fq ne nf ng nh aw ni dt"><span id="1836" class="lf ki ht nf b fv nj nk l nl nm">struct Data {<br/>    uint64 a;<br/>    uint64 b;<br/>    uint128 c;<br/>    uint256 d;<br/>}</span><span id="a242" class="lf ki ht nf b fv nn nk l nl nm">Data public data;</span><span id="98dd" class="lf ki ht nf b fv nn nk l nl nm">constructor(uint64 _a, uint64 _b, uint128 _c, uint256 _d) public {<br/>    Data.a = _a;<br/>    Data.b = _b;<br/>    Data.c = _c;<br/>    Data.d = _d;<br/>}</span></pre><p id="fcdb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意，在该结构中，所有总共可以填充256位槽的变量都是彼此相邻排序的，以便编译器可以在以后将它们堆叠在一起(如果变量覆盖的位少于256位，这也适用)。在这个特定的例子中，SSTORE操作将只使用两次，一次用于存储<em class="mf"> a </em>、<em class="mf"> b </em>和<em class="mf"> c </em>，另一次用于存储<em class="mf"> d </em>。这同样适用于结构之外的变量。此外，请记住，将多个变量放入同一个槽中所节省的空间要比填满整个槽(首选数据类型)所节省的空间大得多。</p><p id="af13" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="mf">注意:记得激活SOLC的优化</em></p></div><div class="ab cl lt lu hb lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hm hn ho hp hq"><h2 id="dab1" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">4.用程序集将变量打包到单个插槽中</h2><p id="7b4d" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hm dt translated">将变量堆叠在一起以减少要执行的存储操作的技术也可以手动应用。下面的代码将4个uint64类型的变量一起堆叠到一个256位的槽中。</p><p id="b0ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">编码:将变量合并成一个。</strong></p><pre class="jr js jt ju fq ne nf ng nh aw ni dt"><span id="6206" class="lf ki ht nf b fv nj nk l nl nm">function encode(uint64 _a, uint64 _b, uint64 _c, uint64 _d) internal pure returns (bytes32 x) {<br/>    assembly {<br/>        let y := 0<br/>        mstore(0x20, _d)<br/>        mstore(0x18, _c)<br/>        mstore(0x10, _b)<br/>        mstore(0x8, _a)<br/>        x := mload(0x20)<br/>    }<br/>}</span></pre><p id="4e5f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了读取，需要对变量进行解码，这可以通过第二个函数来实现。</p><p id="eed6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">解码:将一个变量拆分成它的初始部分。</strong></p><pre class="jr js jt ju fq ne nf ng nh aw ni dt"><span id="5d23" class="lf ki ht nf b fv nj nk l nl nm">function decode(bytes32 x) internal pure returns (uint64 a, uint64 b, uint64 c, uint64 d) {<br/>    assembly {<br/>        d := x<br/>        mstore(0x18, x)<br/>        a := mload(0)<br/>        mstore(0x10, x)<br/>        b := mload(0)<br/>        mstore(0x8, x)<br/>        c := mload(0)<br/>    }<br/>}</span></pre><p id="fec6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">比较这种方法和上述方法的气体消耗，您会发现这种方法明显更便宜，原因如下:</p><ol class=""><li id="f153" class="mq mr ht is b it iu ix iy jb ms jf mt jj mu jn mv mw mx my dt translated"><strong class="is hu"> Precision: </strong>使用这种方法，您可以在位打包方面做任何事情。例如，如果您已经知道不需要变量的最后一位，您可以通过添加一个与256位变量结合使用的一位变量来轻松优化。</li><li id="24fd" class="mq mr ht is b it mz ix na jb nb jf nc jj nd jn mv mw mx my dt translated"><strong class="is hu">读一次:</strong>因为你的变量实际上是一起存储在一个槽中，你只需要执行一次加载操作就可以接收所有的变量。如果变量将被结合使用，这是特别有益的。</li></ol><p id="dbc4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">那么，为什么还要用之前的那个呢？看一下这两种实现，很明显我们也放弃了可读性，因为使用汇编来对变量进行解码，从而使第二种方法更容易出错。此外，由于我们将不得不为每个特定情况包含<em class="mf"> en </em>和<em class="mf">解码</em>功能，部署成本也将显著上升。然而，如果你真的需要降低你的函数的消耗，这是一条可行之路！(与另一种方法相比，在一个槽中装入的变量越多，节省的成本就越高。)</p></div><div class="ab cl lt lu hb lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hm hn ho hp hq"><h2 id="5f9c" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">5.连接函数参数</h2><p id="85ef" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hm dt translated">正如您可以使用上面的<em class="mf"> en- </em>和<em class="mf"> decode </em>函数来优化读取和存储数据的过程一样，您也可以使用它们来连接函数调用的参数，以减少调用数据的负载。尽管这导致交易的执行成本略有增加，但基本费用将会减少，因此总的来说，你的交易会更便宜。</p><p id="0e6d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">本文比较了两个函数调用，一个使用了这种技术，另一个没有使用这种技术(位压缩),并完美地展示了实际发生的情况:</p><div class="no np fm fo nq nr"><a rel="noopener follow" target="_blank" href="/coinmonks/techniques-to-cut-gas-costs-for-your-dapps-7e8628c56fc9"><div class="ns ab ej"><div class="nt ab nu cl cj nv"><h2 class="bd hu fv z el nw eo ep nx er et hs dt translated">为您的Dapps削减汽油成本的技巧</h2><div class="ny l"><h3 class="bd b fv z el nw eo ep nx er et ek translated">对于每个基于以太坊的Dapp来说，天然气成本在长期运行中扮演着重要的角色。我们分享几种实践技巧…</h3></div><div class="nz l"><p class="bd b gc z el nw eo ep nx er et ek translated">medium.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ka nr"/></div></div></a></div></div><div class="ab cl lt lu hb lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hm hn ho hp hq"><h2 id="42b8" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">6.减少存储负载的Merkle证明</h2><p id="4f30" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hm dt translated">简而言之，merkle证明使用单个数据块来证明大量数据的有效性。</p><p id="e555" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您不熟悉merkle样张背后的想法，请先查看这些文章，以便获得基本的了解:</p><div class="no np fm fo nq nr"><a href="https://media.consensys.net/ever-wonder-how-merkle-trees-work-c2f8b7100ed3" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab ej"><div class="nt ab nu cl cj nv"><h2 class="bd hu fv z el nw eo ep nx er et hs dt translated">想知道Merkle树是如何工作的吗？</h2><div class="nz l"><p class="bd b gc z el nw eo ep nx er et ek translated">media.consensys.net</p></div></div><div class="oa l"><div class="og l oc od oe oa of ka nr"/></div></div></a></div><div class="no np fm fo nq nr"><a rel="noopener follow" target="_blank" href="/crypto-0-nite/merkle-proofs-explained-6dd429623dc5"><div class="ns ab ej"><div class="nt ab nu cl cj nv"><h2 class="bd hu fv z el nw eo ep nx er et hs dt translated">Merkle证明解释。</h2><div class="ny l"><h3 class="bd b fv z el nw eo ep nx er et ek translated">这篇文章解释了如何获得和什么是merkle证明。</h3></div><div class="nz l"><p class="bd b gc z el nw eo ep nx er et ek translated">medium.com</p></div></div><div class="oa l"><div class="oh l oc od oe oa of ka nr"/></div></div></a></div><p id="64d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">merkle校样带来的好处真的很惊人。让我们看一个例子:</p><p id="9147" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">假设我们想要保存一个汽车的购买交易，包含所有，比如说，32个配置，已订购。创建一个有32个变量的结构，每个变量对应一个配置是非常昂贵的！这就是merkle校样的用武之地:</p><ol class=""><li id="7ce9" class="mq mr ht is b it iu ix iy jb ms jf mt jj mu jn mv mw mx my dt translated">首先，我们查看哪些信息将被一起请求，并相应地对32个属性进行分组。假设我们发现了4个组，每个组包含8个配置，以便保持简单。</li><li id="6396" class="mq mr ht is b it mz ix na jb nb jf nc jj nd jn mv mw mx my dt translated">现在，我们根据4个组中的数据为每个组创建一个散列，并根据前面的标准再次对它们进行分组。</li><li id="f2ed" class="mq mr ht is b it mz ix na jb nb jf nc jj nd jn mv mw mx my dt translated">我们将重复这个过程，直到只剩下一个散列，merkle-root (hash1234)。</li></ol><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff oi"><img src="../Images/f9850488241753105e64874ecf3a0c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cjqei4aadmRh3QjO2fgzbA.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Merkle-Tree for Car-Example</figcaption></figure><p id="bf3a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们之所以将它们分组，取决于两个元素是否会同时使用，是因为对于每个验证，该分支的所有元素(在图中用颜色表示)都是必需的，并且也是自动验证的。这意味着只需要一个验证过程。例如:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff oi"><img src="../Images/ac0d37be7101135dd4137248989973f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qxKQePgSCIP0JbJDgAxVYg.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Merkle-Proof for the pink Element</figcaption></figure><p id="2026" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们在这里的链上需要存储的只是merkle-root，通常是一个256位的变量(keccak256 ),然而，假设汽车制造商给你送来了一辆颜色错误的汽车，你可以很容易地证明这不是你订购的汽车。</p><pre class="jr js jt ju fq ne nf ng nh aw ni dt"><span id="7ab6" class="lf ki ht nf b fv nj nk l nl nm">bytes32 public merkleRoot;</span><span id="97af" class="lf ki ht nf b fv nn nk l nl nm"><br/>//Let a,...,h be the orange base blocks</span><span id="89af" class="lf ki ht nf b fv nn nk l nl nm">function check<br/>(<br/>    bytes32 hash4,<br/>    bytes32 hash12,<br/>    uint256 a,<br/>    uint32 b,<br/>    bytes32 c,<br/>    string d,<br/>    string e,<br/>    bool f,<br/>    uint256 g,<br/>    uint256 h<br/>)<br/>    public view returns (bool success)<br/>{</span><span id="a499" class="lf ki ht nf b fv nn nk l nl nm">    bytes32 hash3 = keccak256(abi.encodePacked(a, b, c, d, e, f, g, h));<br/>    bytes32 hash34 = keccak256(abi.encodePacked(hash3, hash4));<br/>    require(keccak256(abi.encodePacked(hash12, hash34)) == merkleRoot, "Wrong Element");<br/><br/>    return true;</span><span id="775f" class="lf ki ht nf b fv nn nk l nl nm">}</span></pre><p id="255a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请记住:如果某个变量需要非常频繁地被访问或者不时地被修改，那么以传统的方式存储这个特定的值可能更有意义。此外，注意你的分支不要变得太大，因为否则你将超过这个事务可用的堆栈槽的数量。</p></div><div class="ab cl lt lu hb lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hm hn ho hp hq"><h2 id="cced" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">7.无状态合同</h2><p id="e0ee" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hm dt translated">无状态契约利用了这样一个事实，即事务数据和事件调用完全保存在区块链上。因此，您需要做的是发送一个事务并传递您想要存储的值，而不是不断地更改契约的状态。由于SSTORE操作通常占了大部分的事务成本，所以无状态契约消耗的gas只是有状态契约的一小部分。下面的文章完美地解释了无状态契约背后的概念，以及如何创建一个无状态契约及其后端对应物。</p><div class="no np fm fo nq nr"><a rel="noopener follow" target="_blank" href="/@childsmaidment/stateless-smart-contracts-21830b0cd1b6"><div class="ns ab ej"><div class="nt ab nu cl cj nv"><h2 class="bd hu fv z el nw eo ep nx er et hs dt translated">无状态智能合约</h2><div class="ny l"><h3 class="bd b fv z el nw eo ep nx er et ek translated">无状态智能契约或哑契约是一种设计模式，用于大幅降低以太坊的气体成本…</h3></div><div class="nz l"><p class="bd b gc z el nw eo ep nx er et ek translated">medium.com</p></div></div><div class="oa l"><div class="oj l oc od oe oa of ka nr"/></div></div></a></div><p id="12ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">将这个应用到上面的汽车示例中，我们将发送一个或两个事务，这取决于我们是否可以连接函数参数<em class="mf"> (5。串联函数参数)</em>，我们将汽车的32种配置传递给它。只要我们只需要从外部验证信息，这很好，甚至比merkle校样还要便宜一点。然而，另一方面，如果不牺牲集中化、成本或用户体验，从合同内部访问这些信息实际上是不可能的。</p></div><div class="ab cl lt lu hb lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hm hn ho hp hq"><h2 id="73f7" class="lf ki ht bd kj lg lh li kn lj lk ll kr jb lm ln kv jf lo lp kz jj lq lr ld ls dt translated">8.存储IPFS的数据</h2><p id="96fe" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hm dt translated">IPFS网络是分散的数据存储，其中每个文件不是通过URL而是通过其内容的散列来识别的。这里的优点是散列不能被改变，因此，一个特定的散列将总是指向同一个文件。因此，我们可以将我们的数据广播到IPFS网络，然后在我们的契约中保存各自的散列，以便在以后引用这些信息。关于如何工作的更详细的解释可以在本文中找到:</p><div class="no np fm fo nq nr"><a rel="noopener follow" target="_blank" href="/@didil/off-chain-data-storage-ethereum-ipfs-570e030432cf"><div class="ns ab ej"><div class="nt ab nu cl cj nv"><h2 class="bd hu fv z el nw eo ep nx er et hs dt translated">离线数据存储:以太坊和IPFS</h2><div class="ny l"><h3 class="bd b fv z el nw eo ep nx er et ek translated">节省汽油</h3></div><div class="nz l"><p class="bd b gc z el nw eo ep nx er et ek translated">medium.com</p></div></div></div></a></div><p id="a635" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">就像无状态契约一样，这种方法并不真正允许实际使用智能契约中的数据(对于Oracles来说是可能的)。尽管如此，尤其是如果你想存储特别大量的数据，比如视频，这种方法是目前最好的方法。(附带说明:Swarm是一种不同的分散式存储系统，作为IPFS的替代方案也值得考虑。)</p><p id="64b5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于6、7和8的用例非常相似，这里总结了何时使用哪一个:</p><ul class=""><li id="2afd" class="mq mr ht is b it iu ix iy jb ms jf mt jj mu jn ok mw mx my dt translated"><strong class="is hu"> Merkle-trees: </strong>中小型数据。/ Data可以在协定内部使用。/更改数据相当复杂。</li><li id="69cd" class="mq mr ht is b it mz ix na jb nb jf nc jj nd jn ok mw mx my dt translated"><strong class="is hu">无状态契约:</strong>中小型数据。/ Data不能在协定内使用。/数据可以更改。</li><li id="e4c7" class="mq mr ht is b it mz ix na jb nb jf nc jj nd jn ok mw mx my dt translated"><strong class="is hu"> IPFS: </strong>大量的数据。/在合同中使用数据相当麻烦/更改数据相当复杂。</li></ul><blockquote class="mg"><p id="0680" class="mh mi ht bd mj mk ol om on oo op jn ek translated">加入Coinmonks <a class="ae kg" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae kg" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae kg" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="lf ki ht bd kj lg oq li kn lj or ll kr jb os ln kv jf ot lp kz jj ou lr ld ls dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="mq mr ht is b it ma ix mb jb ov jf ow jj ox jn ok mw mx my dt translated"><a class="ae kg" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae kg" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="mq mr ht is b it mz ix na jb nb jf nc jj nd jn ok mw mx my dt translated"><a class="ae kg" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae kg" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="mq mr ht is b it mz ix na jb nb jf nc jj nd jn ok mw mx my dt translated"><a class="ae kg" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae kg" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="mq mr ht is b it mz ix na jb nb jf nc jj nd jn ok mw mx my dt translated"><a class="ae kg" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae kg" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="mq mr ht is b it mz ix na jb nb jf nc jj nd jn ok mw mx my dt translated">开发人员的最佳加密API</li><li id="b359" class="mq mr ht is b it mz ix na jb nb jf nc jj nd jn ok mw mx my dt translated">最佳<a class="ae kg" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="mq mr ht is b it mz ix na jb nb jf nc jj nd jn ok mw mx my dt translated"><a class="ae kg" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li></ul></div></div>    
</body>
</html>