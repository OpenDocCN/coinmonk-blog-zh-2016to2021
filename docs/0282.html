<html>
<head>
<title>Fun Times With WebCrypto — Part 1: PBKDF2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebCrypto的欢乐时光第1部分:PBKDF2</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/fun-times-with-webcrypto-part-1-pbkdf2-815b1c978c9d?source=collection_archive---------2-----------------------#2018-04-13">https://medium.com/coinmonks/fun-times-with-webcrypto-part-1-pbkdf2-815b1c978c9d?source=collection_archive---------2-----------------------#2018-04-13</a></blockquote><div><div class="eg hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fj fl is it iu iv ff fg paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="ff fg ir"><img src="../Images/bda701d4c082c11567ccdbfe80710dd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4a6MOBxYhgQsBRcwbShRw.jpeg"/></div></div><figcaption class="jc jd fh ff fg je jf bd b be z el">Photo by <a class="ae jg" href="https://unsplash.com/photos/RkJF2BMrLJc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">William Bout</a> on <a class="ae jg" href="https://unsplash.com/search/photos/crypto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9386" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">更新:<a class="ae jg" rel="noopener" href="/p/fun-times-with-webcrypto-part-2-encrypting-decrypting-dfb9fadba5bc">第二部</a>出来了！</p><p id="27ce" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本周，我的队友——Ram Valsky和我接到了一个非常独特的任务:使用WebCrypto将我们在Node中编写的一个加密相关模块转换为JavaScript。因为Ram和我都喜欢任何与密码相关的东西，所以我们的反应如下:</p><figure class="ki kj kk kl fr iv ff fg paragraph-image"><div class="ff fg kh"><img src="../Images/b360ace06d59eaaf9ff5c1c10fe544c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/1*MsqDgA6nIGoDi5tLoD_vWg.gif"/></div><figcaption class="jc jd fh ff fg je jf bd b be z el">Via <a class="ae jg" href="https://giphy.com/gifs/excited-screaming-jonah-hill-5GoVLqeAOo6PK" rel="noopener ugc nofollow" target="_blank">GIPHY</a></figcaption></figure><h1 id="20b9" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">PBKDF2简介</h1><p id="ebd5" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">pbk df 2(Password Based Key Derivation Function，基于密码的密钥导出函数)顾名思义，是一种用于从密码中导出密钥的函数，然后可以通过加密算法将其用作加密密钥。它旨在减少加密密钥对暴力和字典攻击的脆弱性。</p><p id="6d3e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">什么时候用？<br/></strong></p><p id="313d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">pbk df 2在其他哈希函数之上有什么优势？<br/> </strong> Hash函数被设计得很快，而PBKDF2却故意慢。通过增加大量的迭代和一个长的随机salt来实现减慢，这使得对用PBKDF2创建的密钥的暴力攻击更加困难。</p><h1 id="8385" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">导出PBKDF2密钥</h1><p id="1643" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">我们的第一个任务是从一个已知的集合中导出一个PBKDF2密钥，该集合由哈希函数、秘密密码、salt、迭代计数和<a class="ae jg" href="https://en.wikipedia.org/wiki/Initialization_vector" rel="noopener ugc nofollow" target="_blank"> IV </a>长度组成。</p><p id="e851" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们首先为我们的<em class="lp"> getDerivation </em>函数创建签名:</p><figure class="ki kj kk kl fr iv"><div class="bz em l di"><div class="lq lr l"/></div></figure><p id="c1f0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了使用WebCrypto获得一个密钥，我们需要使用<code class="ei ls lt lu lv b">crypto.subtle</code>对象的<code class="ei ls lt lu lv b">deriveBits</code>函数。不过有一点需要注意:<code class="ei ls lt lu lv b">deriveBits</code>需要一个作为<code class="ei ls lt lu lv b">CryptoKey</code>对象的秘密密码，而我们只有一个字符串😕</p><p id="3eeb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在浏览位于<a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API" rel="noopener ugc nofollow" target="_blank"> MDN </a>的WebCrypto文档时，我们注意到了<code class="ei ls lt lu lv b">importKey</code>函数。这个函数基本上返回一个promise，这个promise根据它的参数解析为一个a <code class="ei ls lt lu lv b">CryptoKey</code>对象。查看输入参数列表，我们注意到一些重要的事情:密码必须以<code class="ei ls lt lu lv b">ArrayBuffer</code>或<code class="ei ls lt lu lv b">JSONWebKey</code>的形式给出。这就是<code class="ei ls lt lu lv b"><a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encode" rel="noopener ugc nofollow" target="_blank">TextEncoder</a> </code>类发挥作用的地方。<code class="ei ls lt lu lv b">TextEncoder</code>公开了<code class="ei ls lt lu lv b">encode</code>函数，该函数接受一个字符串参数并返回一个<code class="ei ls lt lu lv b"><a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays/Uint8Array" rel="noopener ugc nofollow" target="_blank">Uint8Arra</a>y</code>对象，然后我们可以将其用于<code class="ei ls lt lu lv b">importKey</code>函数！</p><figure class="ki kj kk kl fr iv"><div class="bz em l di"><div class="lq lr l"/></div><figcaption class="jc jd fh ff fg je jf bd b be z el">For more information about the parameters of importKey check out <a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey" rel="noopener ugc nofollow" target="_blank">MDN</a></figcaption></figure><p id="bfaa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们已经将密码转换成了一个<code class="ei ls lt lu lv b">CryptoKey</code>，我们可以用它来导出散列密钥。如上所述，我们将使用<code class="ei ls lt lu lv b">deriveBits</code>函数来实现。在调用<code class="ei ls lt lu lv b">deriveBits</code>函数之前，我们应该创建一个对象来保存它的配置:</p><figure class="ki kj kk kl fr iv"><div class="bz em l di"><div class="lq lr l"/></div></figure><p id="fb85" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">👉请注意，就像<code class="ei ls lt lu lv b">importKey</code>函数一样，<code class="ei ls lt lu lv b">deriveBits</code>要求salt作为<code class="ei ls lt lu lv b">ArrayBuffer</code>传递，而不是一个简单的字符串。</p><p id="e127" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">调用<code class="ei ls lt lu lv b">deriveBits</code>需要三个参数:</p><ol class=""><li id="e902" class="lw lx hu jj b jk jl jo jp js ly jw lz ka ma ke mb mc md me dt translated">我们之前创建的参数对象</li><li id="541a" class="lw lx hu jj b jk mf jo mg js mh jw mi ka mj ke mb mc md me dt translated">我们之前导入的密钥</li><li id="c41b" class="lw lx hu jj b jk mf jo mg js mh jw mi ka mj ke mb mc md me dt translated">我们希望导出的<strong class="jj hv">位的数量</strong></li></ol><figure class="ki kj kk kl fr iv"><div class="bz em l di"><div class="lq lr l"/></div></figure><p id="11b3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">😱你可能会问——为什么我们要将密钥长度乘以8？</p><figure class="ki kj kk kl fr iv ff fg paragraph-image"><div class="ff fg mk"><img src="../Images/e07c63fe5e6066514e7658135e974260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*h85AKlu55sFieLx9PP88VQ.gif"/></div><figcaption class="jc jd fh ff fg je jf bd b be z el">Via <a class="ae jg" href="https://giphy.com/gifs/adventure-time-math-finn-the-human-9lMoyThpKynde" rel="noopener ugc nofollow" target="_blank">Giphy</a></figcaption></figure><p id="8c9b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你还记得我在文章开头提到的，我们将要解密一个在NodeJS中加密的对象。NodeJS使用字节，所以我们使用的密钥长度(48)实际上是48字节。然而，WebCrypto使用位。因此，为了告诉WebCrypto我们希望从派生中派生出48个字节，我们将它乘以8，得到密钥长度的位值(48*8=384)。</p><h1 id="3a79" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">总结一下！</h1><p id="2fba" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">WebCrypto语法有时可能看起来很奇怪，但它实际上非常容易使用。我们发现使用位而不是字符串更容易处理，因为在这个过程中没有对它们进行转换。</p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><p id="f23a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在第2部分中，我们将描述如何使用我们导出的PBKDF2密钥，并将其用于WebCrypto的加密和解密模块。</p><p id="cd0f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">🔥特别感谢<a class="kf kg gs" href="https://medium.com/u/99b08f71892e?source=post_page-----815b1c978c9d--------------------------------" rel="noopener" target="_blank">拉姆·瓦尔斯基</a>和<a class="kf kg gs" href="https://medium.com/u/174ad61b0c66?source=post_page-----815b1c978c9d--------------------------------" rel="noopener" target="_blank">巴拉克·阿玛尔</a>帮助我完成这篇文章！</p></div></div>    
</body>
</html>