<html>
<head>
<title>Service-oriented Hyperledger Fabric application development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向服务的Hyperledger结构应用程序开发</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/service-oriented-hyperledger-fabric-application-development-32e66f578f9a?source=collection_archive---------0-----------------------#2019-07-23">https://medium.com/coinmonks/service-oriented-hyperledger-fabric-application-development-32e66f578f9a?source=collection_archive---------0-----------------------#2019-07-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="9fdc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当前链码开发最佳实践和<a class="ae jo" href="https://github.com/hyperledger/fabric-samples" rel="noopener ugc nofollow" target="_blank">应用示例</a>利用JSON数据模型、简单链码方法路由和<code class="eh jp jq jr js b">REST</code> API架构作为事实上的技术堆栈。本文提出了使用众所周知的规范格式(如<a class="ae jo" rel="noopener" href="/coinmonks/hyperledger-fabric-smart-contract-data-model-protobuf-to-chaincode-state-mapping-191cdcfa0b78">协议缓冲区消息</a>和<code class="eh jp jq jr js b">gRPC</code>服务定义)进行区块链应用程序开发的方法和工具。</p><h2 id="39f1" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn dt translated">Hyperledger结构网络组件</h2><p id="4a11" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">区块链网络由多个组件组成，包括链上(链码)和链下(API、oracles和其他外部应用程序，与智能合约交互)。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/31ddc7e753054e4a5286ec9767ea106b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*pxBWP_mbkI_3CttnI6fyZA.png"/></div></figure><p id="b68b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">例如，官方<a class="ae jo" href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/tutorial/commercial_paper.html" rel="noopener ugc nofollow" target="_blank">商业票据链码示例</a>包括智能合约实现和CLI工具，用于与部署的с链码进行交互。因为这个应用程序可以用不同的编程语言来实现，所以用一种标准的方法来定义服务接口和消息格式是很重要的。</p><h2 id="2f7b" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn dt translated">链码开发工具</h2><p id="4e21" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">有许多用Java、Golang和Javascript编写的用于开发链上和链下应用程序的库:</p><ul class=""><li id="102a" class="lb lc ht is b it iu ix iy jb ld jf le jj lf jn lg lh li lj dt translated">用于构建链外应用的SDK(Node-js、Java、Golang)</li><li id="e328" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated">链码方法路由库，如<a class="ae jo" href="https://github.com/hyperledger/fabric-chaincode-node" rel="noopener ugc nofollow" target="_blank">https://github.com/hyperledger/fabric-chaincode-node</a></li></ul><h1 id="90a9" class="lp ju ht bd jv lq lr ls jz lt lu lv kd lw lx ly kg lz ma mb kj mc md me km mf dt translated">链码数据模型和接口规范</h1><p id="b658" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">下一步是使用<a class="ae jo" href="https://developers.google.com/protocol-buffers/docs/proto3?hl=ru#services" rel="noopener ugc nofollow" target="_blank"> gRPC接口定义语言(IDL) </a>标准化区块链应用程序开发的以下方面:</p><ul class=""><li id="424f" class="lb lc ht is b it iu ix iy jb ld jf le jj lf jn lg lh li lj dt translated">链码接口定义</li><li id="96d5" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated">链码SDK和API的创建与代码生成</li><li id="2b46" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated">使用代码生成构建链代码文档</li></ul><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/91872a5264d672af50d89e1a9981600a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*b_CDU4JLywVN3Ki3RljpTg.png"/></div></figure><p id="53c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">提议的方法利用了<code class="eh jp jq jr js b">gRPC</code>服务和消息定义的力量。区块链应用开发者可以用高级接口定义语言来表达与app的接口，CCKit <code class="eh jp jq jr js b">cc-gateway</code> generator会自动生成:</p><ul class=""><li id="a0b4" class="lb lc ht is b it iu ix iy jb ld jf le jj lf jn lg lh li lj dt translated">链码服务接口和将服务嵌入链码路由器的帮助器</li><li id="5b63" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated">用于外部访问的链码网关(可用作SDK或暴露为<code class="eh jp jq jr js b">gRPC</code>或<code class="eh jp jq jr js b">REST</code>服务)</li><li id="f96a" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated"><code class="eh jp jq jr js b">markdown</code>格式的链码文件</li><li id="4ef8" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated">swagger格式的REST API规范</li></ul><p id="79d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">生成所有这些组件后，区块链开发人员只需实现链码业务逻辑，使用<code class="eh jp jq jr js b">CCKit</code>功能处理<a class="ae jo" href="https://github.com/hyperledger-labs/cckit/tree/main/state" rel="noopener ugc nofollow" target="_blank">状态</a>、<a class="ae jo" href="https://github.com/s7techlab/cckit/tree/master/extensions/owner" rel="noopener ugc nofollow" target="_blank">访问控制</a>或数据<a class="ae jo" href="https://github.com/s7techlab/cckit/tree/master/extensions/encryption" rel="noopener ugc nofollow" target="_blank">加密。</a></p><h1 id="6822" class="lp ju ht bd jv lq lr ls jz lt lu lv kd lw lx ly kg lz ma mb kj mc md me km mf dt translated">使用gRPC生态系统进行链码开发</h1><h2 id="e26c" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn dt translated">gRPC基础</h2><p id="f191" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">使用<a class="ae jo" href="https://www.grpc.io/docs/guides/concepts/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>，客户端应用程序可以直接调用远程机器上的服务器应用程序的方法，就像它是一个本地对象一样。<code class="eh jp jq jr js b">gRPC</code>基于传统远程过程调用(RPC)技术的基础，但在现代技术栈(如HTTP2、协议缓冲区等)之上实现。以确保最大的互操作性。</p><p id="bc44" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">像许多RPC系统一样，<code class="eh jp jq jr js b">gRPC</code>基于定义服务的思想，指定可以远程调用的方法及其参数和返回类型。<code class="eh jp jq jr js b">gRPC</code> technology stack本身支持使用接口定义语言(<code class="eh jp jq jr js b">IDL</code>)来指定服务契约的简洁而强大的方式:</p><ul class=""><li id="3483" class="lb lc ht is b it iu ix iy jb ld jf le jj lf jn lg lh li lj dt translated"><strong class="is hu">消息</strong>定义了输入参数和返回类型的数据结构。</li><li id="458e" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated">服务定义概述了可以远程调用的方法签名</li></ul><p id="a824" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当客户端调用服务时，客户端的<code class="eh jp jq jr js b">gRPC</code>库使用协议缓冲区并整理远程过程调用，然后通过HTTP2发送。在服务器端，请求被解组，相应的过程调用使用协议缓冲区执行。响应遵循从服务器到客户机的类似执行流程。</p><p id="9ae6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">用<code class="eh jp jq jr js b">gRPC</code>开发服务和客户端的主要优点是，您的服务代码或客户端代码不需要担心解析JSON或类似的基于文本的消息格式。进来的是二进制格式，它被解组成一个对象。此外，当我们必须处理多个微服务并确保和维护互操作性时，拥有通过<code class="eh jp jq jr js b">IDL</code>定义服务接口的一流支持是一个强大的功能。</p><h2 id="e40b" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn dt translated">gRPC服务作为RESTful HTTP API</h2><p id="0809" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">使用Google protocol buffers编译器<a class="ae jo" href="https://gist.github.com/vitiko/fe3ce6a19f184271fca644274e417d60" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">proto</strong></a><strong class="is hu">c</strong>的<a class="ae jo" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu"> grpc-gateway </strong> </a>插件，可以将<code class="eh jp jq jr js b">gRPC</code>服务公开为<code class="eh jp jq jr js b">REST</code>服务。它读取protobuf服务定义，并生成一个反向代理服务器，将RESTful HTTP API翻译成<code class="eh jp jq jr js b">gRPC</code>。</p><h1 id="a1d4" class="lp ju ht bd jv lq lr ls jz lt lu lv kd lw lx ly kg lz ma mb kj mc md me km mf dt translated">链码即服务</h1><blockquote class="mh mi mj"><p id="7baf" class="iq ir mk is b it iu iv iw ix iy iz ja ml jc jd je mm jg jh ji mn jk jl jm jn hm dt translated"><em class="ht">应用，与智能合约交互可以定义并实现为</em> <code class="eh jp jq jr js b"><em class="ht">gRPC</em></code> <em class="ht">服务。但是，如果chaincode本身以</em> <code class="eh jp jq jr js b"><em class="ht">gRPC</em></code> <em class="ht">格式实现服务定义呢？</em></p></blockquote><h2 id="c65e" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn dt translated">链码接口</h2><p id="0038" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">Chaincode与共享分类帐交互，并为区块链网络定义业务逻辑:一组涵盖通用术语、数据、规则、概念定义和流程的合同(例如，<a class="ae jo" href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/tutorial/commercial_paper.html" rel="noopener ugc nofollow" target="_blank">商业票据</a>或<a class="ae jo" rel="noopener" href="/coinmonks/erc20-token-as-hyperledger-fabric-golang-chaincode-d09dfd16a339"> ERC20 </a>令牌功能)，布局管理交易方之间所有交互的业务模型。</p><p id="9787" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Chaincode接口非常简单，只包含2个方法:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="49a4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用<code class="eh jp jq jr js b">ChaincodeStubInterface</code> <code class="eh jp jq jr js b">getArgs</code>方法chaincode实现可以以字节片(数组)的形式访问输入参数。</p><p id="3e24" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">目前，还没有通过某种定义语言来描述链码接口的标准方法。但是chaincode本身可以被认为是类似RPC的服务，用<code class="eh jp jq jr js b">gRPC</code>接口定义语言(IDL)定义，例如:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="5184" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于这个服务定义是强类型的(输入:<code class="eh jp jq jr js b">string</code> ad输出:<code class="eh jp jq jr js b">string</code>)而不是宽松的基本链码接口(输入:<code class="eh jp jq jr js b">[]byte</code>和输出:<code class="eh jp jq jr js b">[]byte</code>)，我们需要将输入<code class="eh jp jq jr js b">[]byte</code>转换为目标参数类型的机制，这取决于服务定义。</p><h1 id="c373" class="lp ju ht bd jv lq lr ls jz lt lu lv kd lw lx ly kg lz ma mb kj mc md me km mf dt translated">示例:商业票据链码</h1><p id="25f9" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">让我们使用<code class="eh jp jq jr js b">gRPC</code>服务定义和代码生成来实现<a class="ae jo" href="https://github.com/s7techlab/hyperledger-fabric-samples" rel="noopener ugc nofollow" target="_blank">商业票据</a>链码即服务。完整的示例代码可以在<a class="ae jo" href="https://github.com/s7techlab/hyperledger-fabric-samples/tree/master/commercial-paper" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="fb5f" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn dt translated">1.定义数据模型</h2><p id="7a3e" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">第一步，我们创建<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_asservice/schema/schema.proto" rel="noopener ugc nofollow" target="_blank">。proto </a>描述您希望存储和输入/输出有效载荷的数据结构。你可以在这里阅读关于链码状态建模<a class="ae jo" rel="noopener" href="/coinmonks/hyperledger-fabric-smart-contract-data-model-protobuf-to-chaincode-state-mapping-191cdcfa0b78">的细节。</a></p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="c9a4" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn dt translated">2.创建服务定义</h2><p id="4192" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">链码接口可以用gRPC <a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_asservice/service/service.proto" rel="noopener ugc nofollow" target="_blank">服务</a>符号描述。使用<code class="eh jp jq jr js b">grpc-gateway</code>选项，我们还可以为链码REST-API定义映射。</p><p id="59c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh jp jq jr js b">grpc-gateway</code>是谷歌协议缓冲编译器<code class="eh jp jq jr js b">protoc</code>的一个插件。它读取protobuf服务定义，并生成一个反向代理服务器，将RESTful HTTP API翻译成gRPC。这个服务器是根据服务定义中的<code class="eh jp jq jr js b">google.api.http</code>注释生成的。</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="1c30" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn dt translated">3.代码生成</h2><p id="50e3" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">链码即服务网关生成器允许从<code class="eh jp jq jr js b">gRPC</code>服务定义生成辅助组件。</p><p id="25b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">安装发电机:</p><pre class="ku kv kw kx fq mq js mr ms aw mt dt"><span id="a7db" class="jt ju ht js b fv mu mv l mw mx">GO111MODULE=on go install <!-- -->https://github.com/hyperledger-labs/cckit<!-- -->/gateway/protoc-gen-cc-gateway</span></pre><p id="e08c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于文件生成，安装<a class="ae jo" href="https://github.com/pseudomuto/protoc-gen-doc" rel="noopener ugc nofollow" target="_blank">协议生成文档</a>:</p><pre class="ku kv kw kx fq mq js mr ms aw mt dt"><span id="08df" class="jt ju ht js b fv mu mv l mw mx"><em class="mk">go get -u github.com/pseudomuto/protoc-gen-doc/cmd/protoc-gen-doc</em></span></pre><p id="26da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要生成验证代码，请安装<a class="ae jo" href="https://github.com/mwitkow/go-proto-validators" rel="noopener ugc nofollow" target="_blank"> ProtoBuf验证器编译器</a>:</p><pre class="ku kv kw kx fq mq js mr ms aw mt dt"><span id="1301" class="jt ju ht js b fv mu mv l mw mx"><em class="mk">go get github.com/mwitkow/go-proto-validators/protoc-gen-govalidators</em></span></pre><p id="a563" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">生成链码辅助代码的命令可以在<a class="ae jo" href="https://gist.github.com/vitiko/4f260dc1600c96765c4e6f8c88f72507#file-block5-makefile" rel="noopener ugc nofollow" target="_blank"> Makefile </a>中找到</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="mo mp l"/></div></figure><ul class=""><li id="8d41" class="lb lc ht is b it iu ix iy jb ld jf le jj lf jn lg lh li lj dt translated"><code class="eh jp jq jr js b">-I</code>标志定义数据模式源的来源(<a class="ae jo" href="https://gist.github.com/examples/cpaper_asservice/schema" rel="noopener ugc nofollow" target="_blank">)。模式</a>或<a class="ae jo" href="https://gist.github.com/examples/cpaper_asservice/service" rel="noopener ugc nofollow" target="_blank">服务定义</a></li><li id="38b6" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated"><code class="eh jp jq jr js b">go_out</code>标志为<code class="eh jp jq jr js b">protobuf</code>结构和<code class="eh jp jq jr js b">gRPC</code>服务客户端和服务器设置输出路径</li><li id="c000" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated"><code class="eh jp jq jr js b">govalidators_out</code>标志为<code class="eh jp jq jr js b">protobuf</code>参数验证器设置输出路径</li><li id="be14" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated"><code class="eh jp jq jr js b">grpc-gateway_out</code>标志为<code class="eh jp jq jr js b">gRPC</code>服务的REST-API代理设置输出路径</li><li id="c770" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated"><code class="eh jp jq jr js b">swagger_out</code>标志设置REST API swagger规范的输出</li><li id="0e41" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated"><code class="eh jp jq jr js b">doc_out</code>标记以降价格式设置文档的输出</li></ul><p id="03a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后<code class="eh jp jq jr js b">cc-gateway_out</code>标志为构建链上(chaincode)和链下(外部应用)区块链网络组件的辅助代码设置输出路径:</p><ul class=""><li id="4a57" class="lb lc ht is b it iu ix iy jb ld jf le jj lf jn lg lh li lj dt translated">链码服务到链码接口映射器</li><li id="d34f" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated">链码网关— <code class="eh jp jq jr js b">gRPC</code>链码对外访问的服务实现</li></ul><h2 id="a64c" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn dt translated">链码实现</h2><p id="3fa4" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">Chaincode服务实现必须符合接口，由服务定义<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_asservice/service/service.pb.cc.go" rel="noopener ugc nofollow" target="_blank"> CPaperChaincode </a>生成:</p><p id="1569" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于简单的情况，如<code class="eh jp jq jr js b">Commercial Paper</code>链码，服务充当<code class="eh jp jq jr js b">Create-Read-Update-Delete</code> (CRUD)应用:</p><ul class=""><li id="ed3b" class="lb lc ht is b it iu ix iy jb ld jf le jj lf jn lg lh li lj dt translated">在链码状态下创建商业票据条目(<code class="eh jp jq jr js b">Issue</code>方法)</li><li id="e791" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated">从链码状态读取(<code class="eh jp jq jr js b">List</code>、<code class="eh jp jq jr js b">Get</code>、<code class="eh jp jq jr js b">GetByExternalId</code>方法)</li><li id="4606" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated">更新商业票据条目(<code class="eh jp jq jr js b">Buy</code>、<code class="eh jp jq jr js b">Redeem</code>方法)</li><li id="4d14" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated">删除商业票据条目(<code class="eh jp jq jr js b">Delete</code>方法)</li></ul><p id="f1df" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用<code class="eh jp jq jr js b">CCKit</code> <a class="ae jo" href="https://github.com/s7techlab/cckit/tree/master/state" rel="noopener ugc nofollow" target="_blank">状态</a>包装器与实体映射，实现应该<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_asservice/chaincode.go#L57" rel="noopener ugc nofollow" target="_blank">相当简单明了</a>:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="6014" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">链码实现还必须包含<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_asservice/chaincode.go#L60" rel="noopener ugc nofollow" target="_blank">状态和事件映射</a>:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="1b28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，利用生成的<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_asservice/service/service.pb.cc.go#L58" rel="noopener ugc nofollow" target="_blank">registrastpaperchaincode</a>功能，将链码服务实现嵌入到链码方法路由器中:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="mo mp l"/></div></figure><h1 id="d39c" class="lp ju ht bd jv lq lr ls jz lt lu lv kd lw lx ly kg lz ma mb kj mc md me km mf dt translated">构建区块链网络层的组件</h1><h2 id="6b43" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn dt translated">链码服务到链码stubbinterface映射器</h2><p id="2855" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">在<code class="eh jp jq jr js b">gRPC</code>服务定义链码之上生成的服务映射器允许将链码服务实现嵌入到<a class="ae jo" href="https://github.com/s7techlab/cckit/tree/master/router" rel="noopener ugc nofollow" target="_blank"> CCKit路由器</a>中，利用中间件功能转换输入和输出数据。</p><p id="239a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">例如，<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_asservice/service/service.pb.cc.go" rel="noopener ugc nofollow" target="_blank">商业票据即服务</a>生成的代码包含<code class="eh jp jq jr js b">RegisterCPaperChaincode</code>方法，该方法将链码<code class="eh jp jq jr js b">Issue</code>方法映射到链码服务实现:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="f90e" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn dt translated">链代码调用服务</h2><p id="349c" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated"><a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/gateway/service/chaincode.go" rel="noopener ugc nofollow" target="_blank">链码调用服务</a>定义了gRPC服务，用于通过3种方法从外部应用程序与智能合同交互:</p><ul class=""><li id="64b3" class="lb lc ht is b it iu ix iy jb ld jf le jj lf jn lg lh li lj dt translated"><code class="eh jp jq jr js b">Query</code> ( <code class="eh jp jq jr js b">ChaincodeInput</code>)返回(<code class="eh jp jq jr js b">ProposalResponse</code>)</li><li id="5c13" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated"><code class="eh jp jq jr js b">Invoke</code> ( <code class="eh jp jq jr js b">ChaincodeInput</code>)返回(<code class="eh jp jq jr js b">ProposalResponse</code>)</li><li id="2a01" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated"><code class="eh jp jq jr js b">Events</code> ( <code class="eh jp jq jr js b">ChaincodeLocator</code>)返回(<code class="eh jp jq jr js b">ChaincodeEvent</code>)</li></ul><p id="6c9e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">本服务由<code class="eh jp jq jr js b">Chaincode gateway</code>使用，也可作为<code class="eh jp jq jr js b">gRPC</code>服务或<code class="eh jp jq jr js b">REST</code> API单独展示。<code class="eh jp jq jr js b">CCKit</code>包含基于<a class="ae jo" href="https://github.com/s7techlab/hlf-sdk-go" rel="noopener ugc nofollow" target="_blank"> hlf-sdk-go </a>的链码服务<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/gateway/service/chaincode.go" rel="noopener ugc nofollow" target="_blank">实现</a>、用于构建链外Hyperledger Fabric应用的非官方软件开发工具包(sdk)以及基于<a class="ae jo" href="https://gist.github.com/testing" rel="noopener ugc nofollow" target="_blank"> Mockstub </a>的<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/gateway/service/mock.go" rel="noopener ugc nofollow" target="_blank">测试版本</a>。</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="mo mp l"/></div></figure><h2 id="df07" class="jt ju ht bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn dt translated">链码网关</h2><p id="0a70" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated"><a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/gateway/chaincode.go" rel="noopener ugc nofollow" target="_blank"> Chaincode gateway </a>使用Chaincode服务与部署的chaincode进行交互。它知道通道和链码名称，但不知道链码方法签名。</p><p id="cd8c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Chaincode gateway支持<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/gateway/opt.go" rel="noopener ugc nofollow" target="_blank">选项</a>，用于在Chaincode调用期间提供瞬态数据，以及加密/解密数据。</p><p id="0175" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用<code class="eh jp jq jr js b">gRPC</code>服务定义，我们可以为特定的链码生成网关，例如<code class="eh jp jq jr js b">Commercial Paper</code>。该网关可用作:</p><ul class=""><li id="8e4e" class="lb lc ht is b it iu ix iy jb ld jf le jj lf jn lg lh li lj dt translated"><code class="eh jp jq jr js b">gRPC</code>服务</li><li id="6c95" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated">用于其他服务(oracle、API等)的链码SDK</li><li id="6753" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj dt translated"><code class="eh jp jq jr js b">REST</code>通过<a class="ae jo" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> grpc网关</a>的服务</li></ul><p id="e135" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">例如，<a class="ae jo" href="https://gist.github.com/examples/cpaper_asservice/service/service.pb.cc.go" rel="noopener ugc nofollow" target="_blank">为<a class="ae jo" href="https://gist.github.com/examples/cpaper_asservice" rel="noopener ugc nofollow" target="_blank">商业票据示例</a>生成的链码网关</a>如下所示:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="aaa1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用生成的链码网关你可以很容易地建立外部链码应用。例如，要创建<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_asservice/bin/api/mock/main.go" rel="noopener ugc nofollow" target="_blank"> API </a>应用程序，您需要为HTTP反向代理服务器创建入口点，并在<code class="eh jp jq jr js b">gRPC</code>服务器中使用生成的网关:</p><figure class="ku kv kw kx fq ky"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="2ff2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">提供的API <a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_asservice/bin/api/mock/main.go" rel="noopener ugc nofollow" target="_blank">示例</a>使用模拟链码调用服务，但是为了与真实的Hyperledger Fabric网络对等体进行交互，您只需要将链码调用服务更改为使用SDK实现，例如<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/gateway/service/chaincode.go" rel="noopener ugc nofollow" target="_blank"> hlf-sdk-go </a>。</p><p id="cea0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您可以使用命令运行提供的示例</p><blockquote class="mh mi mj"><p id="4eeb" class="iq ir mk is b it iu iv iw ix iy iz ja ml jc jd je mm jg jh ji mn jk jl jm jn hm dt translated"># CD examples/cpaper _ as service/bin/API/mock</p><p id="8d7b" class="iq ir mk is b it iu iv iw ix iy iz ja ml jc jd je mm jg jh ji mn jk jl jm jn hm dt translated">#去运行main.go</p></blockquote><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff my"><img src="../Images/554031b1fc0d71f8bbab21c527a05602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*DBTrLnB6Em46m27j9eplJg.png"/></div></figure><p id="7a9c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">商业票据服务<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_asservice/service/service.swagger.json" rel="noopener ugc nofollow" target="_blank"> REST-API规范</a>以<br/> <a class="ae jo" href="https://swagger.io" rel="noopener ugc nofollow" target="_blank"> swagger </a>格式生成:</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff mz"><img src="../Images/49e3de1c8645da74a3a33b4090e2c232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_4cUB2OHEUVV-ailrvWcg.png"/></div></div></figure><p id="f495" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后你可以使用API <a class="ae jo" href="https://github.com/s7techlab/cckit/tree/master/examples/cpaper_asservice/bin/api" rel="noopener ugc nofollow" target="_blank">的使用示例和样本负载</a>:</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="fe ff ne"><img src="../Images/bc46af7881a3c183df9f4ad2b2e47066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_5GM2-klrWrFkdeyGUB5cQ.png"/></div></div></figure><p id="c4a2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh jp jq jr js b">grpc-gateway</code>会自动将http请求转换为<code class="eh jp jq jr js b">gRPC</code>调用，将JSON有效负载输入到protobuf，调用chaincode服务，然后将返回值从protobuf转换为JSON。您也可以将此服务作为纯gRPC服务使用。可以用生成的<br/> <a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_asservice/service/service.pb.go#L93" rel="noopener ugc nofollow" target="_blank"> gRPC客户端</a>调用Chaincode方法。<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_asservice/service/service.md" rel="noopener ugc nofollow" target="_blank">服务</a>和<a class="ae jo" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_asservice/schema/schema.md" rel="noopener ugc nofollow" target="_blank">模式</a>文档也是自动生成的。</p><h1 id="f239" class="lp ju ht bd jv lq lr ls jz lt lu lv kd lw lx ly kg lz ma mb kj mc md me km mf dt translated">结论</h1><p id="58d9" class="pw-post-body-paragraph iq ir ht is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hm dt translated">提供的工具允许指定链码数据模型和接口，然后以一致的方式生成用于构建<code class="eh jp jq jr js b">on-chain</code>(链码)和<code class="eh jp jq jr js b">off-chain</code> (API、Oracles、SDK等)应用的代码。</p></div></div>    
</body>
</html>