<html>
<head>
<title>Linear Regression with TensorFlow Canned Estimators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">张量流罐装估计量的线性回归</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/linear-regression-with-tensorflow-canned-estimators-6cc4ffddd14f?source=collection_archive---------2-----------------------#2018-06-30">https://medium.com/coinmonks/linear-regression-with-tensorflow-canned-estimators-6cc4ffddd14f?source=collection_archive---------2-----------------------#2018-06-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/0bbc07179ae62937ed4539113b0d939e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*xxxqZtZExBJoxmYKIY-waw.png"/></div><figcaption class="ix iy fg fe ff iz ja bd b be z ek">Linear Regression Illustration</figcaption></figure><p id="7d9f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">线性回归是一种经常被教授给机器学习的第一次实践者的算法。使用线性回归教授梯度下降和损失的基本原理。</p><p id="143d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">本教程是关于使用TensorFlow实现线性回归。目标是通过向您展示如何在TensorFlow中使用固定估计量来节省您的时间。固定估算器是一个高级API，不同于要求你自己编程的低级API。</p><p id="7425" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们将从导入所需的库开始。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="f523" class="ki kj ht ke b fv kk kl l km kn">import numpy as np<br/>import pandas as pd<br/>import tensorflow as tf<br/>from sklearn.model_selection import train_test_split</span></pre><p id="0f8a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们将为此使用的数据集来自Kaggle <a class="ae ko" href="https://www.kaggle.com/c/boston-housing" rel="noopener ugc nofollow" target="_blank">这里</a>上的波士顿房价预测组合。让我们导入我们的训练数据集。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="1f6b" class="ki kj ht ke b fv kk kl l km kn">train_df = pd.read_csv('./train.csv')</span></pre><p id="6c96" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您需要检查数据帧，找出列名和类型。</p><p id="5986" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用TensorFlow时的一个概念是<em class="kp">特征列</em>。在实例化时，我们需要将我们的特性列传递给我们的固定估算器。让我们创建我们的专题专栏。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="8c78" class="ki kj ht ke b fv kk kl l km kn">crim = tf.feature_column.numeric_column('crim', dtype=tf.float64, shape=())<br/>zn = tf.feature_column.numeric_column('zn', dtype=tf.float64, shape=())<br/>indus = tf.feature_column.numeric_column('indus', dtype=tf.float64, shape=())<br/>chas = tf.feature_column.numeric_column('chas', dtype=tf.int64, shape=())<br/>nox = tf.feature_column.numeric_column('nox', dtype=tf.float64, shape=())<br/>rm = tf.feature_column.numeric_column('rm', dtype=tf.float64, shape=())<br/>age = tf.feature_column.numeric_column('age', dtype=tf.float64, shape=())<br/>dis = tf.feature_column.numeric_column('dis', dtype=tf.float64, shape=())<br/>rad = tf.feature_column.numeric_column('rad', dtype=tf.int64, shape=())<br/>tax = tf.feature_column.numeric_column('tax', dtype=tf.int64, shape=())<br/>ptratio = tf.feature_column.numeric_column('ptratio', dtype=tf.float64, shape=())<br/>black = tf.feature_column.numeric_column('black', dtype=tf.float64, shape=())<br/>lstat = tf.feature_column.numeric_column('lstat', dtype=tf.float64, shape=())</span></pre><p id="4c7b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在实例化过程中，我们需要将我们的特性列作为一个列表传递。所以，让我们来创造它。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="c319" class="ki kj ht ke b fv kk kl l km kn">feature_cols = [crim, zn, indus, chas, nox, rm, age, dis, rad, tax, ptratio, black, lstat]</span></pre><p id="22ad" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">通常，在处理数据时，我们会创建一个训练集和一个验证集。那么，让我们在这里也这样做。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="ac2e" class="ki kj ht ke b fv kk kl l km kn">feature_names = ['crim', 'zn', 'indus', 'chas', 'nox', 'rm', 'age', 'dis', 'rad', 'tax', 'ptratio', 'black', 'lstat']<br/>label_name = 'medv'</span><span id="af36" class="ki kj ht ke b fv kq kl l km kn">features_ndarray = train_df[feature_names]<br/>label_ndarray = train_df[label_name]</span><span id="5905" class="ki kj ht ke b fv kq kl l km kn">X_train, X_test, y_train, y_test = train_test_split(features_ndarray, label_ndarray, random_state=0, test_size=0.3)</span></pre><p id="e64a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果您一直在使用sklearn，您将习惯于简单地将您的数据传递给一个训练函数。在TensorFlow中，您使用输入函数。我们需要为训练和验证创建输入函数。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="37af" class="ki kj ht ke b fv kk kl l km kn">def train_input():<br/>    _dataset = tf.data.Dataset.from_tensor_slices(({'crim': X_train['crim'], <br/>                                                   'zn': X_train['zn'], <br/>                                                   'indus': X_train['indus'],<br/>                                                   'chas': X_train['chas'],<br/>                                                   'nox': X_train['nox'],<br/>                                                   'rm': X_train['rm'],<br/>                                                   'age': X_train['age'],<br/>                                                   'dis': X_train['dis'],<br/>                                                   'rad': X_train['rad'],<br/>                                                   'tax': X_train['tax'],<br/>                                                   'ptratio': X_train['ptratio'],<br/>                                                   'black': X_train['black'],<br/>                                                   'lstat': X_train['lstat']<br/>                                                  }, y_train))<br/>    dataset = _dataset.batch(32)<br/>    iterator = dataset.make_one_shot_iterator()<br/>    features, labels = iterator.get_next()<br/>    return features, labels</span></pre><p id="e4d6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">创建_dataset的方法有很多种。因为我们用pandas加载数据，所以我们有一个数据框架。因此，我们将使用<em class="kp"> from_tensor_slices() </em>来创建数据集。此功能在TensorFlow 1.8发布的tf.data模块中提供。特别注意这个功能很重要。第一个参数是一个字典。您需要将系列数据作为字典的值进行传递。第二个参数是代表训练数据中标签的序列。</p><p id="ce2a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下一个非常重要的步骤是，我们必须批量获取数据。您可以将批量大小作为参数传入。如果没有这个对<em class="kp"> batch() </em>的调用，你会得到一些关于size()的有趣错误。</p><p id="5df3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们还要做的一件事是创建一个迭代器。我们使用<em class="kp"> make_one_shot_iterator() </em>来实现这一点。</p><p id="e353" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们通过返回<em class="kp"> iterator.get_next() </em>来结束我们的函数。</p><p id="2db3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们需要一个类似的评估数据函数。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="614b" class="ki kj ht ke b fv kk kl l km kn">def val_input():<br/>    _dataset = tf.data.Dataset.from_tensor_slices(({'crim': X_test['crim'], <br/>                                                   'zn': X_test['zn'], <br/>                                                   'indus': X_test['indus'],<br/>                                                   'chas': X_test['chas'],<br/>                                                   'nox': X_test['nox'],<br/>                                                   'rm': X_test['rm'],<br/>                                                   'age': X_test['age'],<br/>                                                   'dis': X_test['dis'],<br/>                                                   'rad': X_test['rad'],<br/>                                                   'tax': X_test['tax'],<br/>                                                   'ptratio': X_test['ptratio'],<br/>                                                   'black': X_test['black'],<br/>                                                   'lstat': X_test['lstat']<br/>                                                  }, y_test))<br/>    dataset = _dataset.batch(32)<br/>    iterator = dataset.make_one_shot_iterator()<br/>    features, labels = iterator.get_next()<br/>    return features, labels</span></pre><p id="d5ee" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们现在准备实例化我们的固定估算器。回想一下我们之前创建的特性列列表，我们将它传递给对<em class="kp"> LinearRegressor() </em>的调用。我们可以传递许多不同的参数，比如要使用的优化器。此时我们将使用默认值。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="1968" class="ki kj ht ke b fv kk kl l km kn">estimator = tf.estimator.LinearRegressor(feature_columns=feature_cols)</span></pre><p id="5768" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们现在准备训练我们的估计器。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="f873" class="ki kj ht ke b fv kk kl l km kn">estimator.train(input_fn=train_input, steps=None)</span></pre><p id="2727" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">训练完成后，我们将准备评估我们的模型。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="4749" class="ki kj ht ke b fv kk kl l km kn">train_e = estimator.evaluate(input_fn=train_input)<br/>test_e = estimator.evaluate(input_fn=val_input)</span></pre><p id="5bfb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们准备进行推理。我们得到了这个调用的迭代器。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="9124" class="ki kj ht ke b fv kk kl l km kn">preds = estimator.predict(input_fn=val_input)</span></pre><p id="53a9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们需要对此进行迭代，并转换成一个numpy数组来获得结果。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="4a4f" class="ki kj ht ke b fv kk kl l km kn">predictions = np.array([item['predictions'][0] for item in preds])</span></pre><p id="3ee7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">仅此而已。我们在一个数组中有我们的预测。</p><p id="48d9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我希望你觉得这是有用的。</p></div></div>    
</body>
</html>