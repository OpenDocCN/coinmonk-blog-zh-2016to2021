<html>
<head>
<title>Solidity variables — storage, type conversions and accessing private variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可靠性变量——存储、类型转换和访问私有变量</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-variables-storage-type-conversions-and-accessing-private-variables-c59b4484c183?source=collection_archive---------2-----------------------#2021-07-28">https://medium.com/coinmonks/solidity-variables-storage-type-conversions-and-accessing-private-variables-c59b4484c183?source=collection_archive---------2-----------------------#2021-07-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/43855b8f84653f51e0b1e57f942d8c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ArYfbTXvInGGJWB7Dv5JA.jpeg"/></div></div></figure><p id="3963" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这篇文章向初学者介绍了solidity如何存储变量，进行类型转换，以及如何检查私有变量的值。这是为了获得在solidity中字节级事情是如何发生的基本理解。</p><p id="984a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里是我将要研究的变量类型— <code class="eh jz ka kb kc b">uint, string, bytes</code></p><h1 id="a226" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated"><strong class="ak">变量是如何存储在EVM的</strong></h1><p id="d0f6" class="pw-post-body-paragraph jb jc ht jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy hm dt translated">在以太坊虚拟机中，有3个区域可以存储数据[ <a class="ae lg" href="https://docs.soliditylang.org/en/v0.8.6/introduction-to-smart-contracts.html#storage-memory-and-the-stack" rel="noopener ugc nofollow" target="_blank"> 1 </a> ] -</p><ul class=""><li id="d2e7" class="lh li ht jd b je jf ji jj jm lj jq lk ju ll jy lm ln lo lp dt translated"><strong class="jd hu">存储</strong> —每个契约都有一个称为存储的数据区，它在函数调用和事务之间是持久的。默认情况下，状态变量(在函数外部声明的变量)被存储并永久写入区块链。存储的使用成本很高，应该谨慎使用。</li><li id="0788" class="lh li ht jd b je lq ji lr jm ls jq lt ju lu jy lm ln lo lp dt translated"><strong class="jd hu">内存</strong> —第二个数据区称为内存，其中一个契约为每个消息调用获取一个新清除的实例。在函数内部声明的变量是内存，当函数调用结束时会消失</li><li id="9e0d" class="lh li ht jd b je lq ji lr jm ls jq lt ju lu jy lm ln lo lp dt translated"><strong class="jd hu">堆栈</strong> —所有的计算都在一个称为堆栈的数据区上进行</li></ul><p id="2f19" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们将查看写入区块链的存储变量。所有变量都以十六进制形式存储在存储器中。</p><ul class=""><li id="b2c2" class="lh li ht jd b je jf ji jj jm lj jq lk ju ll jy lm ln lo lp dt translated"><code class="eh jz ka kb kc b">0x</code> —前缀表示消息的其余部分是十六进制的</li></ul><p id="86c4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以太坊根据变量类型使用两种格式</p><ul class=""><li id="babb" class="lh li ht jd b je jf ji jj jm lj jq lk ju ll jy lm ln lo lp dt translated"><strong class="jd hu">字符串和字节的Big endian </strong>格式<br/>例如，字符串“abcd”就是这样以十六进制格式(32字节)存储的:<br/> <code class="eh jz ka kb kc b">0x6162636400000000000000000000000000000000000000000000000000000000</code></li></ul><p id="c99b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">十六进制值以大端格式存储在左边，后跟零，而以小端格式存储在右边。</p><ul class=""><li id="102a" class="lh li ht jd b je jf ji jj jm lj jq lk ju ll jy lm ln lo lp dt translated">小端格式用于其他类型(布尔值、数字、地址等……)。<br/>数字“10”将被存储为<br/>T3】</li></ul><p id="6d34" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity将变量存储在存储槽中。solidity中的每个存储槽长32字节。【<a class="ae lg" href="https://docs.soliditylang.org/en/v0.8.6/internals/layout_in_storage.html" rel="noopener ugc nofollow" target="_blank">2</a>】<br/><code class="eh jz ka kb kc b">1 byte = 8 bits</code>T27】这意味着1个字节可以存储的最大值为(28–1)= 255。<br/>255的十六进制表示是<code class="eh jz ka kb kc b">ff</code>。为了存储更高的数字，将需要另一个字节。这意味着1个字节可以存储2位十六进制数。所以十六进制数的长度是32*2 = 64位数长。</p><h2 id="0db8" class="lv ke ht bd kf lw lx ly kj lz ma mb kn jm mc md kr jq me mf kv ju mg mh kz mi dt translated">单位的存储</h2><p id="7807" class="pw-post-body-paragraph jb jc ht jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy hm dt translated">让我们来看看uint是如何存储的。当我们声明一个变量为uint时，默认情况下是uint256。uint是无符号类型，这意味着它只能接受正值。</p><p id="bbac" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">uint256的长度为32字节。数字“256”代表位数。uint256中可存储的最大编号为<br/> <code class="eh jz ka kb kc b">2**256–1 (as numbers start from 0)</code></p><p id="0a82" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于uint8，最大数量是<code class="eh jz ka kb kc b">2**8–1 = 255</code>。这将只需要1个字节来存储。</p><p id="e6ee" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于占用少于32字节的类型，solidity会根据它们在契约中的定义，自动将它们与其他更低字节的变量打包在一起。<br/>例如，如果我们将变量定义为</p><pre class="mj mk ml mm fq mn kc mo mp aw mq dt"><span id="b0f3" class="lv ke ht kc b fv mr ms l mt mu">contract A {</span><span id="8be7" class="lv ke ht kc b fv mv ms l mt mu">uint8 a; # goes to storage slot 0<br/>uint8 b; # storage slot 0<br/>uint c; # storage slot 1</span><span id="2954" class="lv ke ht kc b fv mv ms l mt mu">}</span></pre><p id="03ee" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">它们将仅存储在两个存储槽中，a和b将放在同一个槽中。</p><p id="a23e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然而，如果我们把它们定义为</p><pre class="mj mk ml mm fq mn kc mo mp aw mq dt"><span id="59ac" class="lv ke ht kc b fv mr ms l mt mu">contract A {</span><span id="bea8" class="lv ke ht kc b fv mv ms l mt mu">uint8 a; # goes to storage slot 0<br/>uint c; # storage slot 1<br/>uint8 b; # storage slot 2</span><span id="aed9" class="lv ke ht kc b fv mv ms l mt mu">}</span></pre><p id="608e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">变量现在将占用3个存储槽。因为在这个例子中时隙是按顺序分配的。</p><p id="8517" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于更复杂的类型，如映射、动态数组或大字符串，存储槽位置是使用预先确定的公式计算的。你可以参考脚注中给出的Solidity文档链接。</p><h1 id="32d0" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">实度类型转换</h1><h2 id="afa5" class="lv ke ht bd kf lw lx ly kj lz ma mb kn jm mc md kr jq me mf kv ju mg mh kz mi dt translated">使用mod解释uint转换</h2><p id="cfda" class="pw-post-body-paragraph jb jc ht jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy hm dt translated">让我们以下列合同为例</p><pre class="mj mk ml mm fq mn kc mo mp aw mq dt"><span id="a394" class="lv ke ht kc b fv mr ms l mt mu">pragma solidity ^0.8.6;</span><span id="1e2b" class="lv ke ht kc b fv mv ms l mt mu">contract A {</span><span id="1f3e" class="lv ke ht kc b fv mv ms l mt mu">uint32 a = 100000;<br/>uint16 public b = uint16(a); //b = a % 65536<br/>uint8 public c = uint8(a); //c = a % 256</span><span id="36cc" class="lv ke ht kc b fv mv ms l mt mu">}</span></pre><p id="a16c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">任何低阶数字都可以通过在左边加零转换成高阶数字。然而，当我们将高阶数转换为低阶数时，实度会环绕较小的数并给出结果。</p><p id="6f97" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上面的示例中，可以通过将uint32 100000放在max(uint16)或65536周围来计算uint16。<br/> <code class="eh jz ka kb kc b">So b = a % 65536 = 34464</code> <br/> <code class="eh jz ka kb kc b">Similarly, c = a % 256 = 160</code></p><h2 id="5211" class="lv ke ht bd kf lw lx ly kj lz ma mb kn jm mc md kr jq me mf kv ju mg mh kz mi dt translated">字节32至字节16</h2><pre class="mj mk ml mm fq mn kc mo mp aw mq dt"><span id="19a2" class="lv ke ht kc b fv mr ms l mt mu">pragma solidity ^0.8.6;</span><span id="25ba" class="lv ke ht kc b fv mv ms l mt mu">contract C {</span><span id="e865" class="lv ke ht kc b fv mv ms l mt mu">bytes32 public b32 = bytes32(“This is a big string”);<br/>bytes16 public b16 = bytes16(b32);</span><span id="d0a3" class="lv ke ht kc b fv mv ms l mt mu">}</span></pre><p id="6f7b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">b32的值将是<code class="eh jz ka kb kc b">0x5468697320697320612062696720737472696e67000000000000000000000000</code></p><p id="abbe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当你把它转换成16个字节时，solidity会从右边去掉16个字节(或者32个十六进制数字)。</p><p id="6e48" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当bytesX转换为bytesY时，其中y&lt; x then x is truncated from the right hand side till the length in bytes is equal to y.</p><p id="d997" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">The value of b16 will be  【T5】 </p><h2 id="67e8" class="lv ke ht bd kf lw lx ly kj lz ma mb kn jm mc md kr jq me mf kv ju mg mh kz mi dt translated">Example with all types</h2><p id="75e0" class="pw-post-body-paragraph jb jc ht jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy hm dt translated">Bytes can be declared directly in solidity by prefixing with 0x.<br/>T6】</p><pre class="mj mk ml mm fq mn kc mo mp aw mq dt"><span id="077a" class="lv ke ht kc b fv mr ms l mt mu">bytes8 example = 0x11030330f020D5C5;<br/> <br/>//uint conversion — truncated from left when converting to lower //bytes; adds 0 to the left when coverting to higher bytes</span><span id="5835" class="lv ke ht kc b fv mv ms l mt mu">uint64 public v1 = uint64(example); <br/>//uint64 conversion is allowed for bytes8</span><span id="a943" class="lv ke ht kc b fv mv ms l mt mu">uint32 public v2 = uint32(v1); <br/>//v2 == uint32(0xf020D5C5)</span><span id="268b" class="lv ke ht kc b fv mv ms l mt mu">uint96 public v3 = uint96(v1);<br/>bytes12 public b = bytes12(v3); <br/>//bytes16(uint32(uint64(example))) = 0x0000000011030330f020d5c5</span><span id="f428" class="lv ke ht kc b fv mv ms l mt mu">bytes4 public b1 = bytes4(v2); <br/>//bytes4(uint32(uint64(example))) = 0xf020D5C5<br/> </span><span id="376f" class="lv ke ht kc b fv mv ms l mt mu">//bytes to bytes conversion — truncates from right</span><span id="ba90" class="lv ke ht kc b fv mv ms l mt mu">bytes4 public b2 = bytes4(example); <br/>//bytes4(example) 0x11030330</span><span id="bc48" class="lv ke ht kc b fv mv ms l mt mu"> <br/>//string conversion — truncates from right when converting to lower //bytes; adds 0 to the right when coverting to higher bytes</span><span id="c5bf" class="lv ke ht kc b fv mv ms l mt mu">string public s = “abcd”;</span><span id="d081" class="lv ke ht kc b fv mv ms l mt mu">bytes public b3 = bytes(s); <br/>//b3 = 0x61626364</span><span id="821a" class="lv ke ht kc b fv mv ms l mt mu">bytes2 public b4 = bytes2(b3); <br/>//b4 = bytes2(bytes(s)) = 0x6162</span><span id="dfba" class="lv ke ht kc b fv mv ms l mt mu">bytes16 public b5 = bytes16(b3); <br/>//b5 = bytes16(bytes(s)) = 0x61626364000000000000000000000000</span><span id="a75c" class="lv ke ht kc b fv mv ms l mt mu">string public s1 = string(b3); <br/>//s1 = “abcd”<br/> </span><span id="377f" class="lv ke ht kc b fv mv ms l mt mu">//address conversion</span><span id="d719" class="lv ke ht kc b fv mv ms l mt mu">address a1 = 0x2014a9707099DFcbA3Bb91D23b31cF7Be61941d9;<br/>bytes20 public b6 = bytes20(a1); // works<br/>bytes32 public b7 = bytes32(abi.encode(a1)); //works</span><span id="2f20" class="lv ke ht kc b fv mv ms l mt mu"><br/>//bool conversion</span><span id="d47e" class="lv ke ht kc b fv mv ms l mt mu">bytes32 public b8 = bytes32(abi.encode(true)); //works</span></pre><h1 id="f3cf" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">如何访问私有变量</h1><p id="8602" class="pw-post-body-paragraph jb jc ht jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy hm dt translated">变量的可见性可以是<code class="eh jz ka kb kc b">public, private or internal</code>。默认情况下，变量是内部变量。<code class="eh jz ka kb kc b">Public</code>变量可以从任何地方访问。<code class="eh jz ka kb kc b">internal</code>变量可以被同一个可靠性契约的函数或继承该契约的函数调用。而<code class="eh jz ka kb kc b">private</code>意味着该变量只能在同一个契约内访问。</p><p id="7b29" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然而，由于私有变量的值存储在区块链的EVM中，任何人都可以看到它。私有变量的值可以从EVM中提取。</p><p id="8a5c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如，让我们以下面的合同为例—</p><pre class="mj mk ml mm fq mn kc mo mp aw mq dt"><span id="870c" class="lv ke ht kc b fv mr ms l mt mu"><br/>pragma solidity ^0.8.6;<br/>contract A {<br/>uint private secretValue;</span><span id="2216" class="lv ke ht kc b fv mv ms l mt mu">constructor(uint _value) {<br/> secretValue = _value; }</span><span id="ec8c" class="lv ke ht kc b fv mv ms l mt mu">}</span></pre><p id="7617" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以在部署契约时定义secretValue。无法通过另一个程序查询此变量。但是，它的值将存储在约定的存储槽0中。如果我们使用一个简单的<code class="eh jz ka kb kc b">web3js</code>函数，我们将获得字节码中私有变量的值。【<a class="ae lg" href="https://web3js.readthedocs.io/en/v1.4.0/web3-eth.html#getstorageat" rel="noopener ugc nofollow" target="_blank">3</a><br/><code class="eh jz ka kb kc b">web3.eth.getStorageAt(contractAddress, 0)</code></p><p id="f8a4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">假设我们将secretValue定义为10。然后我会看到这个变量的值为<br/> <code class="eh jz ka kb kc b">0x000000000000000000000000000000000000000000000000000000000000000a</code></p><p id="b5a3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以很容易地将其转换回十进制值10。</p><h2 id="7edc" class="lv ke ht bd kf lw lx ly kj lz ma mb kn jm mc md kr jq me mf kv ju mg mh kz mi dt translated">参考</h2><ul class=""><li id="23e2" class="lh li ht jd b je lb ji lc jm mw jq mx ju my jy lm ln lo lp dt translated">[1][智能合约简介— Solidity 0.8.6文档](<a class="ae lg" href="https://docs.soliditylang.org/en/v0.8.6/introduction-to-smart-contracts.html#storage-memory-and-the-stack" rel="noopener ugc nofollow" target="_blank">https://docs . Solidity lang . org/en/v 0 . 8 . 6/Introduction-to-Smart-Contracts . html # storage-memory-and-the-stack</a>)</li><li id="5965" class="lh li ht jd b je lq ji lr jm ls jq lt ju lu jy lm ln lo lp dt translated">[2][存储中状态变量的布局— Solidity 0.8.6文档](<a class="ae lg" href="https://docs.soliditylang.org/en/v0.8.6/internals/layout_in_storage.html" rel="noopener ugc nofollow" target="_blank">https://docs . soliditylang . org/en/v 0 . 8 . 6/internals/Layout _ in _ Storage . html</a>)</li><li id="fb8e" class="lh li ht jd b je lq ji lr jm ls jq lt ju lu jy lm ln lo lp dt translated">[3] [web3.eth — web3.js 1.0.0文档](<a class="ae lg" href="https://web3js.readthedocs.io/en/v1.4.0/web3-eth.html#getstorageat" rel="noopener ugc nofollow" target="_blank">https://web 3 js . readthe docs . io/en/v 1 . 4 . 0/web 3-eth . html # get storage at</a>)</li></ul></div></div>    
</body>
</html>