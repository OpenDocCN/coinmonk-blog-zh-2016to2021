<html>
<head>
<title>Problems when IPFS and Blockchain are combined</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">IPFS和区块链结合时的问题</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/what-i-learned-by-building-a-dapp-511f7181787f?source=collection_archive---------3-----------------------#2018-11-13">https://medium.com/coinmonks/what-i-learned-by-building-a-dapp-511f7181787f?source=collection_archive---------3-----------------------#2018-11-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="fcd3" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">使用IPFS和区块链的完全去中心化的博客应用。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/0c8b7c37f43f599aec7d21c29971388c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*keutP1stCj4RSmEI5TNlJg.jpeg"/></div></div></figure><p id="7471" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">正如我在之前的博客中承诺的那样。在这篇博客中，我分享了一些关于使用IPFS和完全去中心化的区块链构建博客应用的想法。最好的部分是，它的认证是使用块链完成的。</p><h2 id="c1c1" class="kr ks ht bd kt ku kv kw kx ky kz la lb kd lc ld le kh lf lg lh kl li lj lk ll dt translated">什么是IPFS概述:</h2><p id="7800" class="pw-post-body-paragraph ju jv ht jw b jx lm iu jz ka ln ix kc kd lo kf kg kh lp kj kk kl lq kn ko kp hm dt translated"><a class="ae kq" href="https://ipfs.io/" rel="noopener ugc nofollow" target="_blank"> IPFS </a>是一个分布式文件系统，它使用基于内容的寻址系统。这意味着在常规的HTTP协议中，我们使用服务器的IP地址访问我们的文件，然后这个IP地址的服务器将从数据库中获取我们需要的文件。但在IPFS，我们的整个文件被转换成一个单一的加密哈希，这个哈希用于访问我们的文件在未来。</p><p id="90aa" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">与其直接解释这个DAPP，不如让我们通过与常规博客应用的比较来理解它。</p><h2 id="f12a" class="kr ks ht bd kt ku kv kw kx ky kz la lb kd lc ld le kh lf lg lh kl li lj lk ll dt translated">数据存储:</h2><p id="87a7" class="pw-post-body-paragraph ju jv ht jw b jx lm iu jz ka ln ix kc kd lo kf kg kh lp kj kk kl lq kn ko kp hm dt translated">在常规的博客应用程序中，会有一个服务器为博客服务，如果用户写或编辑博客，它会被存储在数据库中。但是在DAPP中，当用户写或编辑一个博客时，整个内容都存储在IPFS中，并返回一个base58编码的加密哈希，以便将来访问这个博客。</p><h2 id="5ad6" class="kr ks ht bd kt ku kv kw kx ky kz la lb kd lc ld le kh lf lg lh kl li lj lk ll dt translated">认证:</h2><p id="d00a" class="pw-post-body-paragraph ju jv ht jw b jx lm iu jz ka ln ix kc kd lo kf kg kh lp kj kk kl lq kn ko kp hm dt translated">每个人都知道网站服务的认证。基本上，整个身份验证过程用于确保在特定帐户上执行的操作由单个授权用户完成。同样，从IPFS接收的散列由用户用私钥签名，并作为分类帐的一部分存储在块链上。</p><p id="27ab" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">所以基本上写完博客后，我会在上面签名，告诉网络上的每个人，记住这个博客是属于我的。</p><h1 id="8214" class="lr ks ht bd kt ls lt lu kx lv lw lx lb iz ly ja le jc lz jd lh jf ma jg lk mb dt translated">技术问题:</h1><p id="04ab" class="pw-post-body-paragraph ju jv ht jw b jx lm iu jz ka ln ix kc kd lo kf kg kh lp kj kk kl lq kn ko kp hm dt translated">在建立这个DAPP的时候，我遇到了一些特殊的技术问题。其中，有一个似乎很重要。让我们知道如何解决它。</p><h2 id="5203" class="kr ks ht bd kt ku kv kw kx ky kz la lb kd lc ld le kh lf lg lh kl li lj lk ll dt translated">字符串问题:</h2><ul class=""><li id="a9fd" class="mc md ht jw b jx lm ka ln kd me kh mf kl mg kp mh mi mj mk dt translated">我们编写一个名为<strong class="jw hu"> blog、</strong>的<em class="ml"> solidity契约</em>来存储每个新blog的IPFS散列。用于存储每个用户内容的结构是…</li></ul><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mm mn l"/></div></figure><ul class=""><li id="a309" class="mc md ht jw b jx jy ka kb kd mo kh mp kl mq kp mh mi mj mk dt translated">每个用户都有这样一个映射..</li></ul><blockquote class="mr ms mt"><p id="132c" class="ju jv ml jw b jx jy iu jz ka kb ix kc mu ke kf kg mv ki kj kk mw km kn ko kp hm dt translated">(用户公共地址)-&gt;包含用户所有博客散列的结构</p></blockquote><ul class=""><li id="bbe9" class="mc md ht jw b jx jy ka kb kd mo kh mp kl mq kp mh mi mj mk dt translated">通常，当数据存储在IPFS时，它会返回一个base58编码的字符串。</li></ul><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mm mn l"/></div></figure><p id="e965" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这将记录base58编码的字符串:</p><blockquote class="mr ms mt"><p id="5d6a" class="ju jv ml jw b jx jy iu jz ka kb ix kc mu ke kf kg mv ki kj kk mw km kn ko kp hm dt translated">qmde 4 B1 fet 12 wrd 67 zptn 82 FCM 1 Zn 3 qamkspxmbseu 5 dwb</p></blockquote><ul class=""><li id="09b1" class="mc md ht jw b jx jy ka kb kd mo kh mp kl mq kp mh mi mj mk dt translated">这种刺痛被发送到solidity，并添加到每个用户的博客列表中。</li><li id="5fda" class="mc md ht jw b jx mx ka my kd mz kh na kl nb kp mh mi mj mk dt translated">现在，如果我想检索任何特定用户的博客，我需要返回我存储的字符串数组。</li><li id="35df" class="mc md ht jw b jx mx ka my kd mz kh na kl nb kp mh mi mj mk dt translated">但是在solidity中，我们只能返回像整数、字节、地址这样的原始数据类型的数组。但是我们将博客的散列数据存储在一个字符串数组中，该数组不能被返回。</li><li id="f6f1" class="mc md ht jw b jx mx ka my kd mz kh na kl nb kp mh mi mj mk dt translated">所以还有一个选择。</li></ul><h2 id="4300" class="kr ks ht bd kt ku kv kw kx ky kz la lb kd lc ld le kh lf lg lh kl li lj lk ll dt translated">解决方案:</h2><ul class=""><li id="603d" class="mc md ht jw b jx lm ka ln kd me kh mf kl mg kp mh mi mj mk dt translated">由于字符串格式不适合存储，我们可以将字符串转换为字节，并以字节格式存储</li></ul><blockquote class="mr ms mt"><p id="c9a2" class="ju jv ml jw b jx jy iu jz ka kb ix kc mu ke kf kg mv ki kj kk mw km kn ko kp hm dt translated">qmde 4 B1 fet 12 wrd 67 zptn 82 FCM 1 Zn 3 qamkspxmbseu 5 dwb</p></blockquote><ul class=""><li id="ab1a" class="mc md ht jw b jx jy ka kb kd mo kh mp kl mq kp mh mi mj mk dt translated">如果将上述base 58编码的字符串转换为十六进制，我们将得到一个34字节的十六进制字符串。</li></ul><p id="4e62" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><strong class="jw hu">注</strong>:下面的字符串是十六进制的，意思是每两个字符等于一个字节</p><blockquote class="mr ms mt"><p id="49b7" class="ju jv ml jw b jx jy iu jz ka kb ix kc mu ke kf kg mv ki kj kk mw km kn ko kp hm dt translated">1220 D2 EC 4d 8 f 062614722 a9 f 5330 b 591 BBA 9376971 a 10 b 79 fc 514 cf 9 DC D6 caaeb 3c</p></blockquote><ul class=""><li id="ce75" class="mc md ht jw b jx jy ka kb kd mo kh mp kl mq kp mh mi mj mk dt translated">但是solidity中允许的最大字节数是32字节。但是这个字符串的长度是34个字节。</li><li id="698c" class="mc md ht jw b jx mx ka my kd mz kh na kl nb kp mh mi mj mk dt translated">在上述十六进制字符串中，第一个字节<strong class="jw hu"> <em class="ml"> 12 </em> </strong>表示我们正在使用sha-256算法将整个内容还原为这个唯一的字符串。</li><li id="c7c4" class="mc md ht jw b jx mx ka my kd mz kh na kl nb kp mh mi mj mk dt translated">第二字节<strong class="jw hu"> <em class="ml"> 20 </em> </strong>表示其长度为32字节。看<strong class="jw hu"> <em class="ml"> 20 </em> </strong>是否被<strong class="jw hu"> <em class="ml"> </em> </strong>转换成十进制它给出32。</li><li id="2c5a" class="mc md ht jw b jx mx ka my kd mz kh na kl nb kp mh mi mj mk dt translated">所以基本上我们可以在存储字符串时省略前两个字节(即:<strong class="jw hu"> <em class="ml"> 1220 </em> </strong>)。意思是储存这个就够了。</li></ul><blockquote class="mr ms mt"><p id="be84" class="ju jv ml jw b jx jy iu jz ka kb ix kc mu ke kf kg mv ki kj kk mw km kn ko kp hm dt translated">DD 2 EC 4d 8 f 062614722 a9f 5330 b 591 BBA 9376971 a 10 b 79 fc 514 cf 9 DC D6 caaeb 3c</p></blockquote><ul class=""><li id="63e9" class="mc md ht jw b jx jy ka kb kd mo kh mp kl mq kp mh mi mj mk dt translated">这个字符串有32个字节，我们可以将它存储在solidity的bytes32数据类型中。</li></ul><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mm mn l"/></div></figure><ul class=""><li id="8d98" class="mc md ht jw b jx jy ka kb kd mo kh mp kl mq kp mh mi mj mk dt translated">现在，我们可以在任何需要的时候轻松地返回bytes32数组。</li></ul><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mm mn l"/></div></figure><blockquote class="mr ms mt"><p id="9310" class="ju jv ml jw b jx jy iu jz ka kb ix kc mu ke kf kg mv ki kj kk mw km kn ko kp hm dt translated">如果你想了解更多关于这种转变的信息，请访问<a class="ae kq" href="https://incoherency.co.uk/base58/" rel="noopener ugc nofollow" target="_blank">这个网站</a>。如果你有兴趣在你的应用中使用它，你可以在<a class="ae kq" href="https://incoherency.co.uk/base58/" rel="noopener ugc nofollow" target="_blank">这个网站</a>中找到源代码。您还可以在这里找到一些关于base58到十六进制转换的伪代码和更详细的解释</p></blockquote><p id="bce3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">您可以在我的github资源库中找到整个博客应用程序的代码，包括如何运行它的解释。</p><div class="nc nd fm fo ne nf"><a href="https://github.com/abhilashreddyy/blogging-Dapp-IPFS-and-blockchain" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab ej"><div class="nh ab ni cl cj nj"><h2 class="bd hu fv z el nk eo ep nl er et hs dt translated">abhilashreddyy/博客-Dapp-IPFS-区块链</h2><div class="nm l"><h3 class="bd b fv z el nk eo ep nl er et ek translated">使用区块链和IPFS的博客应用。为abhilashreddyy/blogging-Dapp-IPFS-区块链供稿…</h3></div><div class="nn l"><p class="bd b gc z el nk eo ep nl er et ek translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt js nf"/></div></div></a></div><p id="ba48" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">顺便说一下，如果你对这个博客有任何疑问，请随意发表评论，或者如果你喜欢我的博客，请给我一个掌声，以示感谢:-)</p><p id="7c77" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">下周我会带着另一篇关于区块链的博客尽快回来。在那之前拜拜。</p><blockquote class="nu"><p id="5af3" class="nv nw ht bd nx ny nz oa ob oc od kp ek translated"><a class="ae kq" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="of og oh oi oj jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff oe"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>