<html>
<head>
<title>Deep Dive — OpenZeppelin’s ERC777 Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深潜— OpenZeppelin的ERC777实施</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/deep-dive-openzeppelins-erc777-implementation-9db978ce1bea?source=collection_archive---------0-----------------------#2019-07-08">https://medium.com/coinmonks/deep-dive-openzeppelins-erc777-implementation-9db978ce1bea?source=collection_archive---------0-----------------------#2019-07-08</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/41529661517706edb694283d2eb5b57e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8crgmz3Srf9J9JmW"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by <a class="ae jf" href="https://unsplash.com/@rifje?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jaap Straydog</a> on <a class="ae jf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="abda" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">OpenZeppelin最近发布了他们对澎湃可替换令牌标准ERC777的实现。ERC777的目的是改进ERC20，同时保持向后兼容性。契约附带了两个钩子，<code class="eh ke kf kg kh b">tokensToSend</code>和<code class="eh ke kf kg kh b">tokensReceived</code>，地址可以实现这两个钩子来控制和恢复令牌操作。账户现在可以在单笔交易中接收资金和通知，取代了ERC20中的两步流程(<code class="eh ke kf kg kh b">approve</code> / <code class="eh ke kf kg kh b">transferFrom</code>)。让我们直接开始吧。</p><h1 id="33b8" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">界面</h1><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="13f2" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">777和ERC20的一个显著区别是增加了运算符。令牌持有者可以授权和撤销受信任的实体代表他们行事。合同部署者可以定义默认操作员，这些操作员可以为所有地址移动令牌。请注意，<code class="eh ke kf kg kh b">send</code>被用来代替<code class="eh ke kf kg kh b">transfer</code>和<code class="eh ke kf kg kh b">transferFrom</code>，反映了乙醚的转移。</p><h1 id="a010" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">合同</h1><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="d9c3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们从契约定义和变量声明开始。ERC777继承了EIP中定义的接口以及ERC20接口。需要一个自省注册表(ERC1820 ),契约和常规地址在其中发布它们实现的功能。当我们调用发送/接收钩子时，这两个硬编码的散列将会派上用场。</p><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="8abf" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">构造函数接受三个参数:令牌的<code class="eh ke kf kg kh b">name</code>、令牌的<code class="eh ke kf kg kh b">symbol</code>( DAI、BAT…等)和一个保存地址列表的数组<code class="eh ke kf kg kh b">defaultOperators</code>。私有变量被赋值。然后，合同声明其ERC777/ERC20与注册中心接口。</p><p id="0c12" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh ke kf kg kh b">view</code>函数看起来和预期的一样。ERC20合规性要求实施<code class="eh ke kf kg kh b">decimals</code>。</p><h1 id="6fd0" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">发送</h1><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="fe9e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们已经到达了<code class="eh ke kf kg kh b">send</code>，这是在账户之间移动代币的典型方法。嵌套在里面的<code class="eh ke kf kg kh b">_send</code>调用也将被<code class="eh ke kf kg kh b">operatorSend</code>调用(我们稍后会讲到)。</p><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="0249" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh ke kf kg kh b">_send</code>要求from和to不能是零地址。注意<code class="eh ke kf kg kh b">_move</code>是移动指针的那个(并发射两个<code class="eh ke kf kg kh b">events</code>，每个令牌标准一个)。<code class="eh ke kf kg kh b">_callTokensToSend</code> &amp; <code class="eh ke kf kg kh b">_callTokensReceived</code>是负责调用前面提到的钩子函数的二人组。</p><h1 id="9654" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">发送挂钩</h1><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="a889" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh ke kf kg kh b">_callTokensToSend</code>首先用自检注册表检查我们事务中的<code class="eh ke kf kg kh b">from</code>地址是否实现了send-hook。这使我们能够调用<code class="eh ke kf kg kh b">IERC777Sender(implementer).tokensToSend</code>。一旦触发，<code class="eh ke kf kg kh b">from</code>地址应该会收到一个提示(这将取决于接口的wallet实现)，允许发送者恢复交易。</p><h1 id="f034" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">接收钩</h1><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="acfd" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh ke kf kg kh b">_callTokensReceived</code>应该觉得熟悉。如果<code class="eh ke kf kg kh b">requireReceptionAck</code>为<code class="eh ke kf kg kh b">true</code> &amp; &amp; <code class="eh ke kf kg kh b">to</code>为合同，则末尾的<code class="eh ke kf kg kh b">else if</code>会恢复。只有当一个ERC20函数(<code class="eh ke kf kg kh b">transfer</code>、<code class="eh ke kf kg kh b">transferFrom</code>)调用<code class="eh ke kf kg kh b">_callTokensReceived</code>时<code class="eh ke kf kg kh b">requireReceptionAck</code>才是<code class="eh ke kf kg kh b">false</code>。回想一下，ERC777继承了ERC20。在调用<code class="eh ke kf kg kh b">tokensReceived</code>时，接收者将得到通知，有人正在向他们发送一些令牌，并允许接收者恢复。</p><h1 id="d356" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">铸造</h1><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="bf14" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一个777派生的契约意味着调用<code class="eh ke kf kg kh b">_mint</code>，因为作者选择在令牌创建方法中保持不可知论。状态变量被更新以反映铸造。只要接收钩准备就绪，新铸造硬币的接收者就会得到通知。最后，该方法发出<code class="eh ke kf kg kh b">Minted</code> (ERC777)和<code class="eh ke kf kg kh b">Transfer</code> (ERC20)事件。</p><h1 id="812b" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">烧伤</h1><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="47b7" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">函数<code class="eh ke kf kg kh b">burn</code>和<code class="eh ke kf kg kh b">operatorBurn</code>都调用底层的<code class="eh ke kf kg kh b">_burn</code>方法。发送挂钩允许刻录机恢复。<code class="eh ke kf kg kh b">_totalSupply</code>和<code class="eh ke kf kg kh b">_balances[from]</code>适当更新。</p><h1 id="ae5a" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">操作员发送/刻录</h1><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="3ad8" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">正如所料，这些函数代表令牌持有者调用<code class="eh ke kf kg kh b">_send</code>和<code class="eh ke kf kg kh b">_burn</code>方法。</p><h1 id="0f8a" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">操作员效用</h1><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="f1e4" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh ke kf kg kh b">authorizeOperator</code> &amp; <code class="eh ke kf kg kh b">revokeOperator</code>都要求<code class="eh ke kf kg kh b">msg.sender</code>不是所提供的参数。这两个函数都检查<code class="eh ke kf kg kh b">operator</code>是否是默认操作符列表的一部分，以便修改相应的数组。</p><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="5262" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh ke kf kg kh b">isOperatorFor</code>检查给定用户是否授权给定操作员。</p><h1 id="c891" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">向后兼容性</h1><figure class="lg lh li lj fq iu"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="651d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">ERC20的所有功能均已实现。</p><h1 id="da3e" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">资源</h1><ul class=""><li id="7ddc" class="lm ln ht ji b jj lo jn lp jr lq jv lr jz ls kd lt lu lv lw dt translated"><a class="ae jf" href="https://eips.ethereum.org/EIPS/eip-777" rel="noopener ugc nofollow" target="_blank"> EIP-777标准</a></li><li id="0c67" class="lm ln ht ji b jj lx jn ly jr lz jv ma jz mb kd lt lu lv lw dt translated"><a class="ae jf" href="https://github.com/OpenZeppelin/openzeppelin-solidity" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin Github </a> / <a class="ae jf" href="https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC777" rel="noopener ugc nofollow" target="_blank">实现</a></li></ul><blockquote class="mc"><p id="eb44" class="md me ht bd mf mg mh mi mj mk ml kd ek translated"><a class="ae jf" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mn mo mp mq mr iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mm"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>