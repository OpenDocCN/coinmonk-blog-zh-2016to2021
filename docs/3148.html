<html>
<head>
<title>Sidechains — Interoperable Blockchains in the Zendoo Protocol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">侧链Zendoo协议中的可互操作区块链</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/sidechains-interoperable-blockchains-in-the-zendoo-protocol-fbde17fafd2d?source=collection_archive---------1-----------------------#2020-07-13">https://medium.com/coinmonks/sidechains-interoperable-blockchains-in-the-zendoo-protocol-fbde17fafd2d?source=collection_archive---------1-----------------------#2020-07-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/ab716c3303096183ef0adc435a6a3579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSq3JV3Adar1kswQjXY9Dg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="e9aa" class="pw-subtitle-paragraph jb id ie bd b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ek translated">Horizen最近发布了一个高度创新的侧链协议。在这里，我将介绍侧链和Zendoo协议。</h2></div></div><div class="ab cl jv jw hb jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hm hn ho hp hq"><p id="1b2a" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated"><em class="ky">本文是</em> <a class="ae kz" href="https://bit.ly/3dcZxnH" rel="noopener ugc nofollow" target="_blank"> <em class="ky">堀场书院</em> </a> <em class="ky">专家内容及章节</em> <a class="ae kz" href="https://bit.ly/310g4sK" rel="noopener ugc nofollow" target="_blank"> <em class="ky">什么是区块链？</em></a><em class="ky"/></p></div><div class="ab cl jv jw hb jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hm hn ho hp hq"><p id="4e5f" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">区块链技术提供了一些独特的属性，例如在未知行为者之间达成共识，并为诚实行为提供强大的激励机制。然而，在区块链技术上构建真实世界的应用程序可能具有挑战性。</p><p id="ab97" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">在区块链上构建应用程序的第一个挑战是安全性。随着网络参与者数量的增加，区块链的安全性也在提高。因此，仅由少数几个利益相关方构建一个小型的特定于应用程序的区块链，并不能提供与利用一个已有数千个节点的系统相同的安全级别。</p><p id="ab3a" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">反过来，区块链的安全模式依赖于利用一种具有实际价值的代币，这种代币可以在成熟的市场上交易。这适用于<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/proof-of-work/" rel="noopener ugc nofollow" target="_blank">工作证明</a>区块链的案例，在该案例中，矿工因其计算能力而获得一个令牌作为奖励，也适用于股权证明区块链，在该案例中，验证者的保证金需要具有经济权重。因此，具有真实价值的本地令牌激励用户为网络提供额外的安全性(通过挖掘/标桩),并允许应用程序轻松转移价值。</p><p id="662b" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">直接在公共区块链上建造还会带来其他挑战。首先，区块链不太适合处理大量数据和交易。第二，部署一个新特性，这对于一个给定的应用程序来说可能是必要的，将需要在整个涉众社区中建立共识。如果只有一小部分参与者从该特性中受益，它就不太可能被实现。最后，如果特性和应用程序直接构建在主链上，代码库将很快变得难以管理。</p><p id="b766" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">总之，构建公共区块链的三个主要障碍是安全性和可伸缩性、引入新功能所需的繁琐的治理过程，以及缺乏具有真实价值的令牌。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff la"><img src="../Images/d439752d8b4403b829f010743712c97d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SC2kkV0zTdsEiJ1_.jpg"/></div></div></figure><p id="9965" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt lf translated">M  eet侧链。侧链受益于底层主区块链的去中心化和安全性，并保持解决高度特定用例的灵活性。在侧链上添加和删除功能并不取决于主链的社区共识，因为新功能只会影响侧链用户。此外，新功能可以添加到单独的侧链分类帐，减少主链上的压力。</p><p id="7d77" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">侧链不能从主链获得100%的安全性；它们仍然需要专用节点。但是可以建立激励机制，使得现有的主链节点也支持建立在其上的侧链。</p><h1 id="8f9c" class="lo lp ie bd lq lr ls lt lu lv lw lx ly jk lz jl ma jn mb jo mc jq md jr me mf dt translated">侧链的使用案例</h1><p id="6748" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">为了说明上面提到的好处，让我们看一些实际的侧链用例。</p><h1 id="60b9" class="lo lp ie bd lq lr ls lt lu lv lw lx ly jk lz jl ma jn mb jo mc jq md jr me mf dt translated">可量测性</h1><p id="c79c" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">侧链的使用案例包括数据或事务密集型应用。</p><p id="018a" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">交易密集型用例可以是实时游戏内支付系统，用户可以在其中赚取和消费代币。如果系统有几千个并发用户，并且在主链上记录所有奖励，传统的区块链将不适合处理负载。具有短块间隔的侧链和有效验证事务的集中一致机制是一种更可行的方法。</p><p id="f2b1" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">数据密集型用例可以是供应链跟踪系统。如果生产商、物流公司、零售商和其他第三方使用该系统，数据量将很快超过大多数公共区块链节点愿意处理的极限。一个带有附加数据字段的专用侧链可能是一个可行的解决方案，用于存储特定于产品的元数据。块大小可能会增加，以适应每单位时间更多的数据存储。</p><h1 id="527f" class="lo lp ie bd lq lr ls lt lu lv lw lx ly jk lz jl ma jn mb jo mc jq md jr me mf dt translated">管理</h1><p id="b6ff" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">部署特定于域的侧链可以绕过公共网络上使用的共识构建过程，从而实现快速的功能迭代。这种分离保护了主链，因为新特性部署产生的错误只会影响目标侧链。</p><p id="377e" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">Horizen正在评估先开发哪些侧链。选项包括支持复杂(图灵完成)<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/guaranteed-execution-with-smart-contracts/" rel="noopener ugc nofollow" target="_blank">智能合约</a>的侧链，接近即时支付结算，或处理Zen区块链基金会国库资金的侧链。</p><p id="8304" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">虽然Horizen的主链不支持自定义令牌，但侧链可以提供这一功能。任何开发者都可以自由地在Horizen的主链上构建和部署侧链，无需许可，也没有破坏东西的风险。</p><p id="d76e" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">侧链是扩展分布式分类帐功能并使其适用于更广泛的用例的重要技术步骤。</p><h1 id="d42d" class="lo lp ie bd lq lr ls lt lu lv lw lx ly jk lz jl ma jn mb jo mc jq md jr me mf dt translated">侧链的历史</h1><p id="bbfd" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">侧链是人们谈论多年的一个概念。第一个侧链提案写于2014年，从那以后，几个团队用不同的方式实现了它们。</p><h2 id="3036" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">钉住的侧链</h2><p id="35e0" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">Adam Back等人在2014年发表的一篇论文中首次提到了侧链。“<a class="ae kz" href="https://blockstream.com/sidechains.pdf" rel="noopener ugc nofollow" target="_blank">利用钉住的侧链实现区块链创新</a>”引入了<em class="ky">钉住的</em>侧链的技术概念，允许资产从一个链转移到另一个链。这篇论文介绍了许多至今仍在使用的关于侧链的术语。</p><h2 id="5166" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">对称与非对称Peg</h2><p id="13e9" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">作者区分了<em class="ky">对称</em>和<em class="ky">非对称钉</em>。在对称栓接侧链结构中，主链监控侧链，反之亦然。因为两个系统都知道对方，所以跨链传输的工作方式是相同的——它们是对称的。</p><p id="c4e7" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">在不对称双向peg结构中，侧链监控主链，但主链不跟踪侧链。在这种结构中，资产从主链到侧链的转移，即<em class="ky">正向转移</em>，非常简单，因为侧链节点可以自己验证传入的交易。资产向主链的转移，即<em class="ky">反向转移</em>，更加复杂。主链需要被“告知”即将到来的转账，并依赖于一些先前的交易验证。该文件的结论之一如下:</p><blockquote class="mz na nb"><p id="cc0a" class="kc kd ky ke b kf kg jf kh ki kj ji kk nc km kn ko nd kq kr ks ne ku kv kw kx hm dt translated">“关键的观察是，比特币脚本的任何增强都可以在外部实现，方法是让一个相互不信任的工作人员组成的可信联盟评估脚本，并通过签署普通的多重签名脚本来接受。”— <a class="ae kz" href="https://blockstream.com/sidechains.pdf" rel="noopener ugc nofollow" target="_blank">利用挂钩侧链实现区块链创新</a></p></blockquote><p id="2be6" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">换句话说，非对称侧链可以支持大多数可以想到的应用程序和内部交易，只要一组认证者以它支持的格式验证并转发相关交易到主链。</p><p id="2818" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">不对称侧链结构是理想的，因为它允许部署许多不同的侧链，而不需要社区的一致同意。对称的侧链将要求主链随着每个新的侧链部署而更新——使得减少的治理优势变得无用。</p><h2 id="c60b" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">权威证明侧链</h2><p id="e63b" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">一个著名的基于以太坊区块链的侧链是由<a class="ae kz" href="https://www.poa.network/" rel="noopener ugc nofollow" target="_blank"> POA Network </a>团队建造的。作者巴里诺夫、巴拉诺夫和卡胡林"<a class="ae kz" href="https://hackmd.io/@F67-rdJCQ0yHlzTN8AoRfw/HkV8Vw7_-?type=view" rel="noopener ugc nofollow" target="_blank">提出了</a>一个基于以太坊协议的开放许可网络，由独立验证者提供权威共识证明这种设计是不对称的:侧链监控主链，反之则不然。他们假设在智能合约上部署侧链比在基于比特币的系统上部署区块链更简单。他们声称前向和后向传输可以通过智能契约逻辑而不是核心协议来处理。</p><p id="42d2" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">尽管如此，POA网络中的每个侧链都依赖于一组个体，验证反向传输并将它们广播到以太坊主链。</p><blockquote class="mz na nb"><p id="4c76" class="kc kd ky ke b kf kg jf kh ki kj ji kk nc km kn ko nd kq kr ks ne ku kv kw kx hm dt translated">部署桥的每个项目必须考虑它自己的验证器。对于项目来说，确定被指派来验证桥接事务的一组个人/节点是绝对必要的。需要注意的是，任何bridge发布都需要验证程序。”— <a class="ae kz" rel="noopener" href="/poa-network/introducing-the-erc20-to-erc20-tokenbridge-ce266cc1a2d0"> POA网络，介绍ERC20至ERC20 TokenBridge </a></p></blockquote><h2 id="1cc9" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">其他侧链结构</h2><p id="9516" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">几个团队正在研究其他侧链结构。驱动链是建立在<a class="ae kz" href="https://blog.coincodecap.com/a-candid-explanation-of-bitcoin/" rel="noopener ugc nofollow" target="_blank">比特币网络</a>上的侧链，其中主链矿工执行从驱动到主链的交易验证。</p><p id="51ea" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">大多数边链协议都是建立在以太网上的。除了POA网络，等离子体是另一个值得注意的例子。它是由Joseph Poon和Vitalik Buterin在2017年提出的，基于以太坊主网上部署的智能合同。</p><p id="4beb" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">上述侧链结构假定了两种情况之一:</p><p id="63ed" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">该设计是对称的，要求主链监控所有侧链以验证反向传输。该结构是非对称的，并且主链依赖于某种认证器来验证和广播从侧链到主链的事务。</p><p id="215b" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">Horizen侧链构造的第一次迭代<a class="ae kz" href="https://www.horizen.global/assets/files/Horizen-Sidechains-Decoupled-Consensus-Between-Chains.pdf" rel="noopener ugc nofollow" target="_blank">也依赖于认证者签署撤回证书中的批量向后转移。</a></p><h1 id="c9e7" class="lo lp ie bd lq lr ls lt lu lv lw lx ly jk lz jl ma jn mb jo mc jq md jr me mf dt translated">Zendoo协议</h1><p id="0528" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">Horizen目前的侧链实现<a class="ae kz" href="https://arxiv.org/abs/2002.01847" rel="noopener ugc nofollow" target="_blank"> Zendoo协议</a>于2020年初发布。它引入了“一种标准化的机制来注册独立的侧链系统并与之交互。通过交互，我们指的是跨链传输协议，它能够以安全和可验证的方式将本机资产发送到侧链并接收回来，而主链不知道任何关于内部侧链构造或操作的信息。”</p><p id="2b5b" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">更概括地说，Zendoo协议允许基于比特币的区块链协议与任何特定领域的区块链或区块链类系统一起运行。<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/a-protocol-to-transfer-value/" rel="noopener ugc nofollow" target="_blank">区块链协议</a>只升级了一次，引入了部署侧链的机制，支持跨链传输。</p><p id="1ba3" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">Zendoo允许主链验证后向转移，而不依赖于外部验证器或认证器。主链不监控侧链(不对称peg ),也不了解它们的内部结构。Zendoo通过为每个侧链状态转换生成递归证明来实现这一点。</p><h2 id="1e8b" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">Zendoo中的主要组件</h2><p id="d2c7" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">大多数侧链结构由三部分组成:</p><ul class=""><li id="3d25" class="nf ng ie ke b kf kg ki kj kl nh kp ni kt nj kx nk nl nm nn dt translated">主链共识协议— MCP</li><li id="0642" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated">跨链传输协议— CCTP</li><li id="8c12" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated">侧链共识协议(SCP)</li></ul><p id="5e62" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">根据侧链的结构，这些组分可以是高度相互依赖的，也可以是高度解耦的。Zendoo协议允许关于SCP的各种自由度。跨链传输协议充当MCP和所有侧链之间的桥梁。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff nt"><img src="../Images/14c8e42fac2bfeaf614a8505059d547c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ct21vHi5eNvE8SsZ.jpg"/></div></div></figure><h2 id="7027" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">主链共识协议— MCP</h2><p id="2759" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">Horizen的主链共识协议包括<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/proof-of-work/" rel="noopener ugc nofollow" target="_blank">工作证明</a>和Nakamoto共识算法、<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/utxo-vs-account-model/" rel="noopener ugc nofollow" target="_blank"> UTXO会计模型</a>和交易逻辑。MCP的Zendoo特定部分是通过特殊的引导交易部署新的侧链、向侧链转移资产的新交易类型以及验证来自侧链的传入反向转移。</p><h2 id="f0a3" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">跨链传输协议— CCTP</h2><p id="20ed" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">跨链传输协议是主链和侧链之间的桥梁，由主链共识协议统一固定。它的两个主要组成部分是向前和向后转移。在正向传输中，ZEN从主链发送到侧链。在反向传输中，ZEN返回到主链。</p><p id="65b6" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">因为侧链监控主链，所以它们可以自己验证正向传输。由于主链不监控侧链，Zendoo引入了一种更强的机制，能够在不依赖认证者的情况下验证反向传输。</p><p id="3972" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">跨链转移协议的一个重要组成部分是<em class="ky">撤销证书</em>。该证书将给定时间段内从侧链进行的所有反向传输(即<em class="ky">撤销时期</em>)进行分组，并将它们广播到主链。每个侧链都需要一种机制来生成有效的提款证书。每个侧链还需要定义一个证明系统，以便主链可以验证传入的反向传输。我们很快会谈到验证系统。</p><h2 id="2e05" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">侧链共识协议(SCP)</h2><p id="5eff" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">侧链共识方案包括侧链的所有参数。通常，共识算法将描述对历史的单一版本达成一致的机制。</p><p id="20b4" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">Zendoo中的侧链可以运行与主链不同的<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/consensus-mechanisms/" rel="noopener ugc nofollow" target="_blank">共识机制</a>、<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/utxo-vs-account-model/" rel="noopener ugc nofollow" target="_blank">会计模型</a>或<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/blockchain-as-a-data-structure/" rel="noopener ugc nofollow" target="_blank">数据结构</a>。侧链甚至不一定是区块链，只要它遵守跨链传输协议，它就能够与主区块链通信。</p><p id="814d" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">Horizen兼容侧链允许很大的自由度。作为第一步，Horizen提供了一个名为Latus的侧链共识协议的参考实现，该协议基于一个受<a class="ae kz" href="https://eprint.iacr.org/2016/889.pdf" rel="noopener ugc nofollow" target="_blank"> Ouroboros Praos </a>启发的委托证明利益共识机制。Latus构造的详细描述超出了本文的范围。我们建议感兴趣的读者参考我们的<a class="ae kz" href="https://www.horizen.global/assets/files/Horizen-Sidechain-Zendoo-A_zk-SNARK-Verifiable-Cross-Chain-Transfer-Protocol.pdf" rel="noopener ugc nofollow" target="_blank"> Zendoo论文</a>以了解更多信息。</p><h1 id="6214" class="lo lp ie bd lq lr ls lt lu lv lw lx ly jk lz jl ma jn mb jo mc jq md jr me mf dt translated">主链协议的修改</h1><p id="4ea8" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">有必要对主链协议进行一些修改，以允许在基于比特币的区块链上部署和使用侧链。</p><ul class=""><li id="be16" class="nf ng ie ke b kf kg ki kj kl nh kp ni kt nj kx nk nl nm nn dt translated">首先，也是最重要的，引入了一种选择类型的引导事务来部署侧链。</li><li id="1402" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated">第二，需要一种机制来处理和验证收到的<em class="ky">取款凭证</em>。</li><li id="55ef" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated">第三，新的数据字段<em class="ky">侧链事务提交</em>被添加到主链块报头，其中记录了所有侧链相关事务的Merkle根。</li><li id="3cde" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated">最后，<em class="ky">撤回保障</em>作为一种机制被引入，以防止硬币供应的意外膨胀。</li></ul><p id="f386" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">在接下来的部分中，我们将讨论允许部署和使用侧链的主链修改。在关于事务的<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/transactions/" rel="noopener ugc nofollow" target="_blank">一章中，我们用整整一篇文章来讨论</a><a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/cross-chain-transactions/" rel="noopener ugc nofollow" target="_blank">跨链和侧链内部事务</a>。</p><p id="af7f" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">理解主链如何在不直接跟踪的情况下验证传入的侧链事务，对于理解所有其他主链协议变化至关重要；因此，我们将首先研究这种机制。</p><h2 id="f579" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">反向转移的核实</h2><p id="d141" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">大多数侧链协议依靠认证者作为链之间的桥梁。这些实体监控一个或多个侧链，收集和验证反向事务，并在主链上广播它们。认证者可以是一组受信任的集中式参与者，也可以是一组受激励遵守协议的分散式网络参与者。虽然我们假设大多数验证者是诚实的，但是仍然存在恶意活动的可能性。</p><p id="89e6" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">理想情况下，反向转移是客观可验证的，不需要依赖中介。这种消除中介的需求是Horizen建立反向转移机制的动机，这种机制依赖于证明系统，而不是由人类实体运行的软件实例。</p><h2 id="6078" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">证明系统</h2><p id="47e1" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">在最高层次上，证明系统允许证明者向验证者证明给定的陈述是真实的。验证者可以生成结果正确性的证明，而不是重做整个计算来验证结果。证明由一组值组成，验证者使用这些值来计算二进制输出——真或假。当验证函数返回true时，计算被正确执行，如果它返回false，则它没有被正确执行。</p><p id="3067" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">验证系统中的状态转换是证明系统的一个很好的用例。从这个意义上来说，区块链是一个状态机，每个模块都在分类账中记录新的交易，从而改变系统的状态。节点在将每个块添加到自己的分类帐版本之前会对其进行验证。他们检查交易是否附有有效的<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/digital-signatures/" rel="noopener ugc nofollow" target="_blank">数字签名</a>，是否仅花费了先前<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/utxo-vs-account-model/" rel="noopener ugc nofollow" target="_blank">未花费的交易输出</a>，以及是否附有区块的<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/proof-of-work/" rel="noopener ugc nofollow" target="_blank">工作证明</a>满足当前<a class="ae kz" href="https://academy.horizen.global/technology/expert/proof-of-work/#finding-a-nonce" rel="noopener ugc nofollow" target="_blank">难度</a>。使用证明系统，挖掘器可以生成状态转换(新块)是根据协议执行的证明。所有其他节点将只需验证证明是否正确，并且可以省去单独验证块的每个部分。</p><p id="9cba" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">zkSNARKs等零知识证明因其在隐私保护加密货币中的应用而闻名。Horizen、Zcash和其他协议利用zkSNARKs来实现私人转账。当凭证被用于私人转账时，用户根据区块链协议创建交易。用户生成交易有效的证明并广播该证明，而不是以明文形式向网络广播该交易。证明需要关于交易的所有必要信息:先前未花费的输入和满足输入的花费条件的<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/digital-signatures/" rel="noopener ugc nofollow" target="_blank">数字签名。</a></p><p id="e60a" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">一旦广播，节点将验证证据而不是明文交易。为此，证明系统的一个基本属性归结为<em class="ky">健全性</em>和<em class="ky">完整性</em>。</p><ul class=""><li id="4865" class="nf ng ie ke b kf kg ki kj kl nh kp ni kt nj kx nk nl nm nn dt translated"><em class="ky">可靠性</em>是指一个证明实际上不可能是伪造的。</li><li id="3624" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated"><em class="ky">完整性</em>意味着一个有效的证明在被验证时总是评估为真。</li></ul><p id="0402" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">虽然完整性可以从数学上得到保证，但可靠性实际上是有保证的，因为没有任何实体拥有无限的(从字面意义上来说)计算资源。</p><p id="c143" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">在Zendoo中，侧链会生成状态转换的证据。向主链提交撤销证书时，会附上正确状态转换的证明。主链上的矿工在将取款凭证包含在主链块中之前验证该证明。这就是一个算法如何取代认证者。但是状态转换的证明究竟是如何产生的呢？递归！</p><h2 id="7868" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">递归</h2><p id="2ef0" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">要理解状态转移证明的生成，我们需要理解递归的概念。递归不仅有助于理解侧链设计，也是普通计算机科学中的一个重要概念。</p><blockquote class="mz na nb"><p id="2309" class="kc kd ky ke b kf kg jf kh ki kj ji kk nc km kn ko nd kq kr ks ne ku kv kw kx hm dt translated">“计算机科学中的递归是一种解决问题的方法，其解决方案依赖于同一问题的较小实例的解决方案。”—维基百科</p></blockquote><p id="6d4c" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">递归解决问题意味着解决问题的函数可以调用自己。这在一个例子中得到最好的说明。最常见和直观的例子是计算给定数字的<a class="ae kz" href="https://en.wikipedia.org/wiki/Factorial" rel="noopener ugc nofollow" target="_blank">阶乘</a>。一个数的阶乘的一般表达式是:</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div class="fe ff nu"><img src="../Images/446478d0a909db2607e5e13632fb3e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*VeeZDZsH3mfFGdnEwGU4jA.png"/></div></figure><p id="0949" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">因此，5的阶乘是</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div class="fe ff nv"><img src="../Images/50f5537d430168a0bfc239f3c929c502.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*WilNskgjTRONG1J7mpLGCg.png"/></div></figure><p id="87e4" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">使用递归可以很好地编写一个计算给定数字的阶乘的函数。其思想是数字5的阶乘等于数字4的阶乘的5倍:5！=5 ⋅ 4!。问题的解决办法<em class="ky"> 5！</em>然后取决于同一个问题的一个更小的实例:<em class="ky"> 4！</em>。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff nt"><img src="../Images/2a216ac74e06940971fd3b4b0dc96c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TJyNxqi1MqIiOV03.jpg"/></div></div></figure><p id="6670" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">在上面的例子中，递归函数从第一个递归案例5！=5⋅4!，然后启动计算<em class="ky"> 4！</em> —以此类推。这一直持续到到达<em class="ky">基本情况</em>为止。基本情况是数字2的阶乘，等于2。</p><p id="1cdc" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">在将结果返回给函数的下一个最高实例后，函数的实例随后被关闭。在上面的例子中，基本情况将2返回给下一个最高的实例，它将使用结果来计算<em class="ky"> 3！</em>等等。最后一步，返回120，函数的最高实例被关闭。</p><p id="f84c" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">在C语言中，计算阶乘的函数可以写得很漂亮。下面可以看到函数<code class="eh nw nx ny nz b">factorial</code>是在函数本身(<code class="eh nw nx ny nz b">factorial(n-1)</code>)内部使用的。即使没有对软件开发的基本理解，您也可能会欣赏它的简单性。我们可以用四行代码计算任意给定数字的阶乘。</p><pre class="lb lc ld le fq oa nz ob oc aw od dt"><span id="e818" class="ml lp ie nz b fv oe of l og oh">long factorial(int n)<br/>{<br/>  if (n == 0)   //Base Case<br/>    return 1;<br/>  else          //Recursive Case(s)<br/>    return (n*factorial(n-1));<br/>}</span></pre><p id="f047" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated"><strong class="ke if">注意</strong>:在之前的图中，为了简单起见，我们称2 ⋅ 1为基础案例。</p><p id="c817" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">我们希望在侧链的上下文中实现状态转换的证明。如果状态转换被证明，那么产生的状态以及所有的向后转移都会被自动证明。但是递归如何应用于此呢？</p><h2 id="7aa2" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">状态转换证明</h2><p id="a3d5" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">区块链的<em class="ky">状态转换逻辑</em>是将当前状态<em class="ky"> s(i) </em>和最近一组事务<em class="ky"> t(i) </em>作为输入，并返回下一个状态<em class="ky"> s(i+1) </em>作为输出的函数。五的阶乘表示为计算四的阶乘的函数结果的五倍。还可以基于当前转换和用于计算最后状态的函数的结果来计算当前状态。让我们看一个具体的例子。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff nt"><img src="../Images/d517b210a0f178b953baa9a896d19bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SXQwuiR3MNqXQ42t.jpg"/></div></div></figure><p id="1c68" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">让我们假设一个侧链从状态<em class="ky"> s(1) </em>开始，带有它的起源块。第一转换t(1)由应用于第一状态的第一“实际”块中包括的所有事务组成。假设输入构成了<code class="eh nw nx ny nz b">update</code>函数的有效参数，transition函数，我们称之为<code class="eh nw nx ny nz b">update</code>，接受这两个参数，初始状态(Genesis块)和第一次转换(read: transactions)，并计算下一个状态s(2)。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div class="fe ff oi"><img src="../Images/e13c4861e25bcca6f8fd3053174f3177.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*blCJPfLb7yOTW6zePRuqCA.png"/></div></figure><p id="d44d" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">同样的逻辑适用于第二次状态转换。基于状态s(2)和第二个转换t(2)<code class="eh nw nx ny nz b">update</code>函数计算第三个状态s(3)。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div class="fe ff oj"><img src="../Images/2e50f521fea32b76e5df33e3d10c60fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*6rmCh5O55QcoGhnlpOd_LQ.png"/></div></figure><p id="c70e" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">现在，侧链的当前状态总是可以从初始状态s(1)和系统经历的所有跃迁来计算。它允许人们随后计算系统经历的每个状态。在我们的例子中，第三状态s(3)可以计算为</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div class="fe ff ok"><img src="../Images/b554270a29a3ae1df0614762de0c485f.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*81gtPhD8lT9SWWJO6hJV2w.png"/></div></figure><p id="d9b2" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">我们只是将本节第二个公式中的s(2)替换为第一个方程的右项。</p><h2 id="a296" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">递归状态转移证明</h2><p id="f89d" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">上面显示的构造遵循我们在计算阶乘时讨论的相同模式。你认识递归模式吗？函数<code class="eh nw nx ny nz b">update</code>随后调用自身，并打开同一函数的新实例，直到到达基本情况。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff nt"><img src="../Images/d5a0b0d6859cf70a56c033397d4dfd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Mm70Bfu8nSTayAlZ.jpg"/></div></div></figure><p id="f512" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">这里的基本情况是导致状态s(2)的第一个状态转换。一旦达到这个基本情况，<code class="eh nw nx ny nz b">update</code>函数的不同实例将它们的结果返回给同一函数的下一个最高实例，直到最后返回当前状态，并且关闭该函数的所有实例。</p><p id="5a4f" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">一个通用的数学表达式是</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div class="fe ff ol"><img src="../Images/9e6f2c1dffdf3c9d9e7de4d31a83701a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*qxqjly_mY4zAtgEIi5pwbA.png"/></div></figure><p id="d410" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">这种结构对于可验证的侧链有很大的价值。不仅可以递归计算状态，还可以证明每个状态和状态转换。Zendoo协议需要的是一个声明的证明:</p><p id="2140" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated"><strong class="ke if">存在一系列状态转换(t(1)，…，t(n))，并且通过将这些状态转换一个接一个地应用到初始状态s(1)，达到状态s(n+1)。</strong></p><p id="511f" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">我们现在理解了如何递归地计算状态。但是为什么我们要为每一个转变计算一个证明呢？请记住，主链不会监控不同的侧链，也不会验证状态转换。</p><p id="6aa2" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">为了避免监控所有的侧链，我们可以验证每一个收到的提款证明提交的证明。验证后，如果侧链按预期运行，该证明将返回<code class="eh nw nx ny nz b">true</code>，如果没有，则返回<code class="eh nw nx ny nz b">false</code>。当且仅当所附证明评估为<code class="eh nw nx ny nz b">true.</code>时，主链才接受取款凭证中包含的反向转账</p><h2 id="672b" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">使用SNARKS—<strong class="ak">S</strong>uccinct<strong class="ak">N</strong>on-Interactive<strong class="ak">Ar</strong>arg<strong class="ak">K</strong>knowledge</h2><p id="3b92" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">那么，对于给定的侧链，如何准确地生成证明呢？首先，存在广泛的证据制度。用于Zendoo侧链构建的证明系统是一个SNARK证明系统，是<em class="ky">简洁的非交互式知识论证</em>的缩写。让我们深入探讨一下:</p><ul class=""><li id="92b9" class="nf ng ie ke b kf kg ki kj kl nh kp ni kt nj kx nk nl nm nn dt translated"><em class="ky">简洁</em>指的是证明在生成和验证的计算开销方面“简短”。</li><li id="d602" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated"><em class="ky">非交互式</em>意味着证明者和验证者不必同时在线。使用非交互式证明，证明者可以在不需要与验证者通信的情况下构造证明。这种证明可以记录在区块链上，随时加以核实。</li><li id="d640" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated"><em class="ky">知识论证</em>描述了证明在计算上是可靠的，即没有对手能够构造虚假证明，即使访问巨大的计算资源。</li></ul><p id="7acb" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">有了SNARKs，我们可以为几乎任何类型的计算提供恒定大小的证明。一个SNARK证明系统由三个算法组成:<em class="ky">设置</em>、<em class="ky">证明</em>和<em class="ky">验证</em>。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff nt"><img src="../Images/de59f7198707235b1bcc538d75f19140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6f3H5XVcQkR89L11.jpg"/></div></div></figure><p id="940a" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">设置SNARK系统时，为系统<em class="ky"> C </em>生成证明密钥pkpk和验证密钥vkvk。侧链部署时，验证密钥在主链上注册。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div class="fe ff om"><img src="../Images/a987b5112505a691a21941f7cc18eeb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*eDdBEEEuS5hSyDhieRXtIw.png"/></div></figure><p id="1924" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">为了证明一个计算被正确地执行(或者，用更一般的术语来说，一个<em class="ky">语句</em>),一个证明▆被生成。基于四个输入产生从状态s1s1到最终状态snsn的正确状态转移tt的证明:</p><ul class=""><li id="38ac" class="nf ng ie ke b kf kg ki kj kl nh kp ni kt nj kx nk nl nm nn dt translated">验证密钥<em class="ky"> pk </em></li><li id="7417" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated">初始状态s(1)</li><li id="9077" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated">过渡测试</li><li id="cdf4" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated">和结果状态s(n)。</li></ul><figure class="lb lc ld le fq hv fe ff paragraph-image"><div class="fe ff on"><img src="../Images/2035d4ea2673f00fbbf19a9711c1a38a.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*Rq1umts4ptcYw1_M7xeazQ.png"/></div></figure><p id="18ae" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">就像我们递归计算状态一样，我们也可以递归计算证明。逻辑是完全相同的:从一个基本情况(第一次状态转换)开始，证明被顺序合并，直到对于所讨论的状态剩下一个证明。</p><p id="ab85" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">这个证明现在在主链上广播，在那里被验证。基于四个输入来验证状态n snsn的证明:</p><ul class=""><li id="124c" class="nf ng ie ke b kf kg ki kj kl nh kp ni kt nj kx nk nl nm nn dt translated">验证密钥vk</li><li id="ff9e" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated">初始状态s(1)</li><li id="8e4a" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated">最终状态s(n)</li><li id="9011" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated">证明π</li></ul><figure class="lb lc ld le fq hv fe ff paragraph-image"><div class="fe ff oo"><img src="../Images/c160c39b3e6a0ee5947edaaa5462445c.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*MTE1n6b6BGqK5gecd7Xaug.png"/></div></figure><p id="c609" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">侧链逻辑的正确执行的证明是周期性生成的，每个提款期一个。只有证明和最终状态必须被传送到主区块链。初始状态可以取自引导交易或最近的撤销证书。自部署以来，验证密钥就驻留在主链上。值得注意的是，证据的生成并不一定发生在不可信的环境中。如果一组可信的认证者生成证明，侧链也可以使用授权证明方案。</p><p id="edd8" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">现在对什么是证明系统，递归如何工作，以及如何应用它来为侧链的任何状态(块)以及所有撤销生成证明有了基本的理解，我们继续看启用侧链所需的对主链的其余修改。</p><h2 id="1785" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">SNARK在Latus侧链中的使用</h2><p id="f010" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">最终由侧链开发人员决定如何构造状态转换的证据。在Horizen的参考侧链实现Latus侧链中，首先为单个事务生成证明。然后将这些证明成对合并，以获得整个块的证明。另一个侧链实现可能会像上面的例子那样顺序合并它们。开发者可以选择他们喜欢的方法。</p><p id="7394" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">一旦撤销时期结束，包含在该时期中的所有块的证明被合并。这产生了整个时期和其中所有事务的证明。该撤销时期证明用于生成附加到该时期的撤销证书的最终证明。这个最终证明使所有向后传输到主链的操作合法化，证明所有主链块都被引用，并且所有向前传输都被包括在内。</p><p id="489a" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">密钥和证据生成以及证据验证的整个过程相当复杂。这里描述的一些机制被简化以将概念传达给更广泛的受众。请阅读全文以获得更详细的描述。在第五章中，我们还仔细研究了零知识证明及其数学基础。</p><h2 id="748b" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">侧链交易承诺</h2><p id="49ee" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">升级了主链块标题的结构，并引入了一个新的数据字段，即侧链事务提交(<code class="eh nw nx ny nz b">SCTxsCommitment</code>)。<code class="eh nw nx ny nz b">SCTxsCommitment</code>基本上是一个额外的<a class="ae kz" href="https://academy.horizen.global/technology/expert/blockchain-as-a-data-structure/#merkle-trees" rel="noopener ugc nofollow" target="_blank"> Merkle树</a>的Merkle根。除了包括在作为所有事务摘要的块头中的常规Merkle根之外，第二个Merkle树包括所有侧链相关的事务，即:</p><ul class=""><li id="9e1b" class="nf ng ie ke b kf kg ki kj kl nh kp ni kt nj kx nk nl nm nn dt translated"><strong class="ke if">正向转移(FTs) </strong>将资产从主链转移到副链</li><li id="ed31" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated"><strong class="ke if">取款凭证(WCerts) </strong>向主链传递反向转账</li><li id="19b9" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated"><strong class="ke if">反向传输请求(btr)</strong>从主链内部发起反向传输</li><li id="bac9" class="nf ng ie ke b kf no ki np kl nq kp nr kt ns kx nk nl nm nn dt translated"><strong class="ke if">停止侧链提取(CSW) </strong>允许用户从已经失效的侧链中提取资产</li></ul><p id="391f" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">所有这些与侧链相关的事件都放在一个Merkle树中，通过侧链标识符分组到不同的分支中。生成的Merkle树根放在主链块头中，作为侧链事务提交。</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff nt"><img src="../Images/6cffb61b91bc18129166f74fb5ace7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X_Eeqvz1plW-3vyx.jpg"/></div></div></figure><p id="543c" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">将该数据包含在<a class="ae kz" href="https://bit.ly/2BfMpRF" rel="noopener ugc nofollow" target="_blank">块头</a>中允许侧链节点轻松同步和验证侧链相关事务(侧链监控主链)，而无需传输整个主链块。此外，它允许构建一个SNARK，证明给定主链块的所有与侧链相关的事务都已被正确处理。</p><h2 id="8d2c" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">撤回保障</h2><p id="e64c" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">不受控制的货币供应膨胀是区块链可能遭受的最具破坏性的问题之一。我们必须考虑这样一种情况，即发生故障的侧链试图向主链转移比它最初接收到的更多的资产。这可能是恶意的，也可能只是无心之过。</p><p id="9e7f" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">Horizen实施了一项撤回保障措施来防止这种情况。主链跟踪向给定的侧链转移了多少资金，并且只接受不超过该金额的反向转移。这样，不受控制的通货膨胀就变得不可能了。</p><h2 id="dcb2" class="ml lp ie bd lq mm mn mo lu mp mq mr ly kl ms mt ma kp mu mv mc kt mw mx me my dt translated">侧链部署</h2><p id="75f0" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">Zendoo中的一个新的侧链需要使用一种特殊类型的事务向主链注册，这种事务称为引导事务。任何用户都可以构建新的侧链，并提交定义了几个基本参数的引导事务。</p><p id="3f35" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">首先，在引导事务中定义了侧链的唯一标识符<code class="eh nw nx ny nz b">ledgerId</code>。接下来，定义从哪个主链块开始，侧链将变为活动的。</p><p id="07a2" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">为每个侧链声明多个密钥，即验证侧链上生成的证明所需的验证密钥。有一个用于撤回凭证样张的验证密钥vk(WCert)，一个用于<a class="ae kz" href="https://academy.horizen.global/technology/expert/cross-chain-transactions/#backward-transfer-requests" rel="noopener ugc nofollow" target="_blank">反向传送请求</a>样张的验证密钥vk(BTR)，以及一个用于<a class="ae kz" href="https://academy.horizen.global/technology/expert/cross-chain-transactions/#ceased-sidechain-withdrawals" rel="noopener ugc nofollow" target="_blank">停止侧链撤回</a>样张的验证密钥vk(CSW)。</p><p id="9375" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">最后，定义了如何将证明数据从侧链提供给主链(包括的数据元素的数量和类型)。</p><h1 id="540b" class="lo lp ie bd lq lr ls lt lu lv lw lx ly jk lz jl ma jn mb jo mc jq md jr me mf dt translated">摘要</h1><p id="de9a" class="pw-post-body-paragraph kc kd ie ke b kf mg jf kh ki mh ji kk kl mi kn ko kp mj kr ks kt mk kv kw kx hm dt translated">这是一个相当长的阅读！让我们回顾一下。</p><p id="6543" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">首先，我们阐述了为什么侧链是有用的。它们提高了系统的可扩展性，并允许部署新的实验功能，而不必在所有网络参与者之间达成共识。它们还保持了代码库的可管理性，并允许开发人员通过即时访问已建立价值的令牌来构建新的分类帐系统。</p><p id="fcd3" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">存在几种侧链实现，其中一些比另一些更接近生产。一个常见的缺点是，这些结构通常要么依赖主链跟踪侧链，要么需要某种认证器来处理从侧链到主链的反向传输。Zendoo协议允许不对称的侧链结构，其中主链不监控侧链，但可以依靠客观可验证的证据来验证反向传输。</p><p id="1ec9" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">Zendoo包含三个主要元素:主链共识协议、侧链共识协议(Latus reference实现为其提供)和跨链传输协议。MCP和CCTP是固定的，而SCP有许多自由度。</p><p id="3827" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">接下来，我们查看了对Horizen主链协议的必要修改，以允许部署侧链。为了理解允许在没有证明者的情况下验证向后转移的递归证明系统，我们介绍了一般的证明系统。我们展示了如何使用递归来优雅地解决数学问题，例如计算一个数的阶乘，以及相同的概念如何用于计算状态转换和证明。</p><p id="13c6" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">对主链的另一个修改是添加了侧链事务承诺(SCTxsCommitment ),它以Merkle树的形式汇总了主链上所有与侧链相关的事务。撤回保障措施，防止意外的通货膨胀源于一个错误的或恶意的侧链。最后，引入了一种特殊类型的引导事务，以允许侧链的无权限部署。</p><p id="449d" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">在第四章中，涵盖了<a class="ae kz" href="https://bit.ly/3eOqobo" rel="noopener ugc nofollow" target="_blank">事务</a>，我们将回到我们的侧链结构来仔细看看<a class="ae kz" href="https://devweb-academy.horizen.global/technology/expert/cross-chain-transactions/" rel="noopener ugc nofollow" target="_blank">跨链事务</a>。</p></div><div class="ab cl jv jw hb jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hm hn ho hp hq"><p id="f24b" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">如果你觉得这篇文章很有价值，请考虑访问<a class="ae kz" href="https://bit.ly/3dcZxnH" rel="noopener ugc nofollow" target="_blank"><em class="ky"/></a><em class="ky">。在那里你还会找到一个</em> <strong class="ke if"> <em class="ky">延伸阅读</em> </strong> <em class="ky">列表，下面列出了大多数文章，引用了同一主题的伟大文章。</em></p><p id="3193" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated"><em class="ky"> Horizen Academy文章有三种复杂程度:初级、高级和专家。如果你开始阅读一篇文章，只是意识到它太详细或不够详细，你可以简单地使用侧边栏切换级别。</em></p><p id="8e99" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated"><em class="ky">下面有一段</em> <a class="ae kz" href="https://bit.ly/3fFoTMz" rel="noopener ugc nofollow" target="_blank"> <em class="ky">概述了</em> </a> <em class="ky">写作时的全部内容。</em></p><p id="8429" class="pw-post-body-paragraph kc kd ie ke b kf kg jf kh ki kj ji kk kl km kn ko kp kq kr ks kt ku kv kw kx hm dt translated">如果你想在推特上关注我:<a class="ae kz" href="https://twitter.com/SLebur" rel="noopener ugc nofollow" target="_blank">给你</a>；)</p><figure class="lb lc ld le fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff op"><img src="../Images/07535d578e15225bce5dd132d972a6ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aK0j-L5B_DKZdo8jiC8xIQ.png"/></div></div></figure><blockquote class="oq"><p id="dbc7" class="or os ie bd ot ou ov ow ox oy oz kx ek translated"><a class="ae kz" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="pb pc pd pe pf hv fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff pa"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>