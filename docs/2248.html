<html>
<head>
<title>Hyperledger Fabric chaincode unit testing: smart contract test driven development (TDD)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超级分类帐结构链代码单元测试:智能契约测试驱动开发(TDD)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/test-driven-hyperledger-fabric-golang-chaincode-development-dbec4cb78049?source=collection_archive---------1-----------------------#2019-06-06">https://medium.com/coinmonks/test-driven-hyperledger-fabric-golang-chaincode-development-dbec4cb78049?source=collection_archive---------1-----------------------#2019-06-06</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="3857" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">如何通过单元测试快速连续地检查智能契约逻辑:区块链事务、触发事件和链码许可</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ji"><img src="../Images/62aaf1a20adb67ec073ebea60ca79e2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*IS1i4d3hWed_v1AZYHIgNQ.jpeg"/></div></figure><p id="aac2" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">测试阶段是软件质量保证的关键要求，不管是这个web应用程序还是一个智能合同。测试必须足够快，以便在每次提交到存储库时运行。<a class="ae km" href="https://github.com/s7techlab/cckit/" rel="noopener ugc nofollow" target="_blank"> CCKit </a>，用于开发和测试Hyperledger Fabric Golang chaincode的编程工具包，通过扩展版本的MockStub增强了用于chain code测试的开发体验。</p><h2 id="a5e8" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">链码开发过程中的步骤</h2><p id="95ea" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">智能合约定义了业务对象的不同状态，并控制在这些不同状态之间移动对象的流程。智能合同允许架构师和智能合同开发人员定义业务流程和数据结构，这些数据在区块链网络中的不同组织间共享。</p><p id="e9d8" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">智能合同开发人员的工作是获取现有的业务流程，并将其表达为编程语言中的代码。链码开发的步骤:</p><ul class=""><li id="2ba2" class="ln lo ht js b jt ju jw jx jz lp kd lq kh lr kl ls lt lu lv dt translated">为状态条目、输入负载和事件定义链码模型— <a class="ae km" rel="noopener" href="/coinmonks/hyperledger-fabric-smart-contract-data-model-protobuf-to-chaincode-state-mapping-191cdcfa0b78">模式</a></li><li id="65dd" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">定义链码<a class="ae km" rel="noopener" href="/coinmonks/routing-and-middleware-for-developing-hyperledger-fabric-chaincode-written-in-go-90913951bf08">接口</a></li><li id="86ca" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">实现链代码实例化方法</li><li id="5e18" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">用业务逻辑实现链代码方法</li><li id="1f22" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">创建测试</li></ul><blockquote class="mb mc md"><p id="7251" class="jq jr me js b jt ju iu jv jw jx ix jy mf ka kb kc mg ke kf kg mh ki kj kk kl hm dt translated">测试驱动开发(TDD)或行为驱动开发(BDD)，可能是开发智能合约的单一方式。</p></blockquote><h2 id="91e0" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">链码(智能合约)测试</h2><p id="6959" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">测试必须确保链码按预期工作:</p><ul class=""><li id="7428" class="ln lo ht js b jt ju jw jx jz lp kd lq kh lr kl ls lt lu lv dt translated">特定的输入负载导致特定的业务对象状态变化</li><li id="db70" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">特定的(无效的)输入有效负载会导致验证或其他错误</li><li id="3615" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">特定对象状态允许状态转换子集(状态机)</li></ul><p id="dce8" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">任何软件测试(例如链码或web应用程序)可能是手工的，也可能是自动化的过程。手动软件测试由团队或个人领导，他们将手动操作软件产品，并确保它的行为符合预期。如果是链码测试，您可以通过<code class="eh mi mj mk ml b">peer</code> cli工具手动调用链码。</p><p id="6e96" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">自动化软件测试是对单个代码单元进行输入和输出正确性检查的实践。在自动化测试过程中，代码在模拟输入的测试环境中执行。</p><h2 id="c12d" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">运行链码</h2><p id="977a" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">将chaincode部署到区块链网络并不是世界上最快的事情，通过测试可以节省很多时间。此外，更重要的是，由于区块链是不可变的，而且因为代码在网络上，所以应该是安全的，所以我们不希望在代码中留下缺陷。</p><p id="0b68" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在链代码开发和部署到实时网络的过程中，我们可以将测试分为多个阶段——快速阶段(仅测试智能合约逻辑)和更复杂的阶段(使用实时区块链网络、多个对等点、部署的链上代码(智能合约)和链外应用程序进行集成测试，使用SDK连接区块链网络对等点)。</p><h2 id="d158" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">链码开发模式</h2><p id="b0ba" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">部署Hyperledger Fabric区块链网络，安装和初始化链码，设置起来相当复杂，而且是一个漫长的过程。使用<a class="ae km" href="https://hyperledger-fabric.readthedocs.io/en/latest/peer-chaincode-devmode.html" rel="noopener ugc nofollow" target="_blank">链码开发模式</a>，可以减少重新安装/升级智能合约代码的时间。通常链码由对等体启动和维护。在“开发”模式下，链码由用户构建和启动。在链代码开发阶段，这种模式对于快速编码/构建/运行/调试周期周转非常有用。然而，更新代码的过程仍然会很慢。</p><h2 id="de7f" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">模拟存根—模拟链代码存根</h2><p id="f465" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">模仿是一种单元测试现象，它通过用具有预定义/模拟行为的测试对象替换具有复杂行为的依赖对象来帮助测试孤立的对象。这些测试对象被称为模拟对象。</p><p id="7c23" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><a class="ae km" href="https://github.com/hyperledger/fabric/tree/master/core/chaincode/shim" rel="noopener ugc nofollow" target="_blank"> shim </a>包包含一个<a class="ae km" href="https://github.com/hyperledger/fabric/tree/master/core/chaincode/shim/mockstub.go" rel="noopener ugc nofollow" target="_blank"> MockStub </a>实现，该实现将调用包装到一个chaincode，模拟它在HLF对等环境中的行为。<code class="eh mi mj mk ml b">MockStub</code>不需要启动多个docker容器与对等体、世界状态数据库、链码，并允许几乎立即获得测试结果。</p><blockquote class="mb mc md"><p id="06ba" class="jq jr me js b jt ju iu jv jw jx ix jy mf ka kb kc mg ke kf kg mh ki kj kk kl hm dt translated">真正的单元测试通常运行得非常快，因为不需要设置运行时基础设施。</p></blockquote><p id="34a4" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><code class="eh mi mj mk ml b">MockStub</code>本质上取代了SDK和peer环境，允许在不实际启动区块链网络的情况下测试chaincode。它实现了实际存根所做的几乎所有功能，但是是在内存中。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff mm"><img src="../Images/f0509f89628d4eeb3ed6a496f02a1a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y2dhtx0617oWtnC9dp2JTA.png"/></div></div></figure><p id="8b07" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><code class="eh mi mj mk ml b">MockStub</code>来自<a class="ae km" href="https://github.com/hyperledger/fabric/" rel="noopener ugc nofollow" target="_blank">https://github.com/hyperledger/fabric/</a>库包括了大部分<code class="eh mi mj mk ml b">shim.ChaincodeStubInterface</code>功能的实现，但是直到当前版本的Hyperledger Fabric (1.4)，<code class="eh mi mj mk ml b">MockStub</code>还没有实现一些重要的方法，例如<code class="eh mi mj mk ml b">GetCreator</code>或处理私有状态范围的方法。由于chaincode将使用<code class="eh mi mj mk ml b">GetCreator</code>方法来获取访问控制的事务创建者证书，因此能够存根化该方法以便对chaincode进行完整的单元测试是非常关键的。</p><h2 id="be1c" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">CCKit模拟存根</h2><p id="7f71" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated"><a class="ae km" href="https://github.com/s7techlab/cckit" rel="noopener ugc nofollow" target="_blank"> CCKit </a> <a class="ae km" href="https://gist.github.com/vitiko/" rel="noopener ugc nofollow" target="_blank">测试</a>包包含:</p><ul class=""><li id="d21b" class="ln lo ht js b jt ju jw jx jz lp kd lq kh lr kl ls lt lu lv dt translated"><a class="ae km" href="https://github.com/s7techlab/cckit/blob/master/testing/mockstub.go" rel="noopener ugc nofollow" target="_blank"> MockStub </a>具有实现的<code class="eh mi mj mk ml b">GetTransient</code>和其他方法以及事件订阅功能</li><li id="d5b1" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">测试<a class="ae km" href="https://github.com/s7techlab/cckit/blob/master/testing/identity.go" rel="noopener ugc nofollow" target="_blank">身份</a>创建助手</li><li id="a0e9" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">链码响应<a class="ae km" href="https://github.com/s7techlab/cckit/blob/master/testing/expect/matcher.go" rel="noopener ugc nofollow" target="_blank">期望</a>助手</li></ul><h2 id="f608" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">示例:“商业票据”链代码</h2><h2 id="8564" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">方案</h2><p id="3811" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">官方hyperledger结构文档包含详细的<a class="ae km" href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/developapps/scenario.html" rel="noopener ugc nofollow" target="_blank">链码示例</a> — <code class="eh mi mj mk ml b">Commercial Paper</code>智能合同，该合同定义了商业票据的有效状态，以及将票据从一种状态转换到另一种状态的交易逻辑。我们将用<a class="ae km" rel="noopener" href="/coinmonks/routing-and-middleware-for-developing-hyperledger-fabric-chaincode-written-in-go-90913951bf08"> chaincode方法routing </a>和<a class="ae km" rel="noopener" href="/coinmonks/hyperledger-fabric-smart-contract-data-model-protobuf-to-chaincode-state-mapping-191cdcfa0b78"> protobuf状态</a>测试基于CCKit库的<a class="ae km" href="https://gist.github.com/examples/cpaper_extended" rel="noopener ugc nofollow" target="_blank">商业票据扩展chaincode示例</a>。</p><p id="df21" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们可以使用状态转换图来表示商业票据的生命周期:商业票据通过发行、购买和赎回交易在发行、交易和赎回状态之间转换。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff mr"><img src="../Images/9da81e234fe3dd75c5a7246e7a554654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uy2lKgiJmILk2WNjalHj-g.png"/></div></div></figure><h2 id="cfb2" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">要求</h2><p id="24d1" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">为了产生测试，我们首先需要定义测试应用程序的需求。让我们首先列出我们对商业票据链代码的要求:</p><ul class=""><li id="7ab6" class="ln lo ht js b jt ju jw jx jz lp kd lq kh lr kl ls lt lu lv dt translated">它应该允许发行人发行商业票据</li><li id="95d3" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">它应该允许参与者购买商业票据</li><li id="ff61" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">它应该允许所有者赎回商业票据</li></ul><p id="63b2" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在文件<a class="ae km" href="https://gist.github.com/examples/cpaper_extended/chaincode.go" rel="noopener ugc nofollow" target="_blank"> chaincode.go </a>中描述了链码接口函数，因此我们可以看到链码数据的所有可能的操作(事务):</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ms mt l"/></div></figure><h2 id="995d" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">入门指南</h2><p id="cebd" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">开始之前，请确保获得<code class="eh mi mj mk ml b">CCKit</code>:</p><p id="4fff" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><code class="eh mi mj mk ml b">git clone git@github.com:s7techlab/cckit.git</code></p><p id="f4d4" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">这将获取并安装带有<a class="ae km" href="https://github.com/s7techlab/cckit/tree/master/examples" rel="noopener ugc nofollow" target="_blank">示例的CCKit包。</a>之后，我们需要使用命令安装依赖项:</p><p id="6e70" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><code class="eh mi mj mk ml b">go mod vendor</code></p><h2 id="edc1" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">创建测试套件</h2><h2 id="a7af" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">Go中的测试</h2><p id="fe62" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">Go有一个名为<code class="eh mi mj mk ml b">go test</code>的内置测试命令和包<code class="eh mi mj mk ml b">testing</code>，它提供了一个最小但完整的测试体验。在我们的例子中，我们使用<a class="ae km" href="https://github.com/onsi/ginkgo" rel="noopener ugc nofollow" target="_blank">银杏</a> - BDD风格的go测试框架，构建在Go的测试包之上，并允许以有效的方式编写可读的测试。它最好与<a class="ae km" href="https://github.com/onsi/gomega" rel="noopener ugc nofollow" target="_blank"> Gomega </a> matcher库配对，但是被设计成与匹配器无关。</p><p id="dfab" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">与其他语言中流行的BDD框架一样，<code class="eh mi mj mk ml b">Ginkgo</code>允许您在<code class="eh mi mj mk ml b">Describe</code>和<code class="eh mi mj mk ml b">Context</code>容器块中分组测试。<code class="eh mi mj mk ml b">Ginkgo</code>提供了能够保存您的断言的<code class="eh mi mj mk ml b">It</code>和<code class="eh mi mj mk ml b">Specify</code>块。它还附带了便利的结构化工具，例如<code class="eh mi mj mk ml b">BeforeSuite</code>、<code class="eh mi mj mk ml b">AfterSuite</code>等，允许您将测试配置从测试创建中分离出来，并提高代码重用。</p><p id="557a" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><code class="eh mi mj mk ml b">Ginkgo</code>还支持编写异步测试。这使得测试使用带有chaincode事件的通道的代码与测试同步代码一样容易。</p><h2 id="a89b" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">测试包</h2><p id="64b6" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">为了编写一个新的测试套件，创建一个名为ends _test.go的文件，它包含了<code class="eh mi mj mk ml b">TestXxx</code>函数，在我们的例子中是<a class="ae km" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper_extended/chaincode_test.go" rel="noopener ugc nofollow" target="_blank">cpaper _ extended/chain code _ test . go</a></p><blockquote class="mb mc md"><p id="29f0" class="jq jr me js b jt ju iu jv jw jx ix jy mf ka kb kc mg ke kf kg mh ki kj kk kl hm dt translated">使用单独的测试包<strong class="js hu"> cpaper_extended_test </strong>而不是<strong class="js hu"> cpaper_extended </strong>允许我们尊重链码包的封装:您的测试将需要导入链码并从外部访问它。您不能摆弄内部，而是要关注暴露的chaincode接口。</p></blockquote><h2 id="1b38" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">导入匹配器和助手</h2><p id="2343" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">首先，我们需要从银杏测试包中导入<code class="eh mi mj mk ml b">matcher</code>功能，这样我们就可以使用不同的比较机制，比如比较响应对象或状态代码。</p><p id="7e41" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们导入了带有名称空间<code class="eh mi mj mk ml b">.</code>的<code class="eh mi mj mk ml b">ginkgo</code>和<code class="eh mi mj mk ml b">gomega</code>包，这样我们就可以使用这些包中的函数，而不需要包前缀。这允许我们用<code class="eh mi mj mk ml b">Describe</code>代替<code class="eh mi mj mk ml b">ginkgo.Describe</code>，用<code class="eh mi mj mk ml b">Equal</code>代替<code class="eh mi mj mk ml b">gomega.Equal</code>。</p><h2 id="a92c" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">引导程序</h2><p id="7672" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">对<code class="eh mi mj mk ml b">RegisterFailHandler</code>的调用注册了一个处理程序，来自<code class="eh mi mj mk ml b">Ginkgo</code>包的<code class="eh mi mj mk ml b">Fail</code>函数。这产生了<code class="eh mi mj mk ml b">Ginkgo</code>和<code class="eh mi mj mk ml b">Gomega</code>之间的耦合。</p><p id="c066" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">测试套件引导示例:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ms mt l"/></div></figure><h2 id="16ad" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">测试结构</h2><p id="3df7" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">该特定测试规范可使用<code class="eh mi mj mk ml b">Ginkgo</code>编写如下:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ms mt l"/></div></figure><h2 id="c7af" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">实施测试</h2><p id="09de" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">现在我们深入了解如何使用<code class="eh mi mj mk ml b">MockStub</code>特性创建专门用于链码开发的测试函数。</p><h2 id="bd1c" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">正在创建链码实例</h2><p id="f7f2" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">测试套件通常从创建新的chaincode实例开始，或者我们也可以在每个测试规范之前实例化一个新的chaincode实例。这个要看我们要怎么考，考什么。在这个例子中，我们实例化了一个可以在多个测试规范中使用的全局<code class="eh mi mj mk ml b">Commercial Paper</code>链码。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ms mt l"/></div></figure><h2 id="c124" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">测试链码"<code class="eh mi mj mk ml b">Init"</code>方法</h2><p id="e52d" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">所有链代码调用(通过SDK到区块链对等体或MockStub)的结果都是<a class="ae km" href="https://github.com/hyperledger/fabric/blob/release-1.4/protos/peer/proposal_response.pb.go" rel="noopener ugc nofollow" target="_blank">对等体。响应</a>结构:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ms mt l"/></div></figure><p id="7c42" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在测试过程中，我们可以检查<code class="eh mi mj mk ml b">Response</code>属性:</p><ul class=""><li id="f067" class="ln lo ht js b jt ju jw jx jz lp kd lq kh lr kl ls lt lu lv dt translated">状态(错误或成功)</li><li id="fb07" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">消息字符串(包含错误描述)</li><li id="1f62" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">有效负载内容(编组的JSON或Protobuf)</li></ul><p id="86b4" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">CCKit <a class="ae km" href="https://github.com/s7techlab/cckit/tree/master/testing" rel="noopener ugc nofollow" target="_blank">测试</a>包<a class="ae km" href="https://gist.github.com/vitiko/expect/matcher.go" rel="noopener ugc nofollow" target="_blank">包含</a>银杏<code class="eh mi mj mk ml b">expect</code>函数的多个助手/包装器。</p><p id="9fc5" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">最常用的助手是:</p><ul class=""><li id="b084" class="ln lo ht js b jt ju jw jx jz lp kd lq kh lr kl ls lt lu lv dt translated"><code class="eh mi mj mk ml b">ResponseOk</code> ( <em class="me">回应</em> <strong class="js hu">同行。响应</strong>期望对等响应包含<code class="eh mi mj mk ml b">ok</code>状态代码(<code class="eh mi mj mk ml b">200</code>)</li><li id="6a32" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated"><code class="eh mi mj mk ml b">ResponseError</code> ( <em class="me">回应</em> <strong class="js hu">同行。响应</strong>期望对等响应包含错误状态代码(<code class="eh mi mj mk ml b">500</code>)。或者，您可以传递预期的错误子字符串。</li><li id="a69a" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated"><code class="eh mi mj mk ml b">PayloadIs</code> ( <em class="me">响应</em> <strong class="js hu">对等。响应</strong>，<em class="me">目标</em> <strong class="js hu">接口{} </strong>)期望对等响应包含<code class="eh mi mj mk ml b">ok</code>状态码(<code class="eh mi mj mk ml b">200</code>)，并使用<code class="eh mi mj mk ml b">CCKit</code> <a class="ae km" href="https://github.com/s7techlab/cckit/tree/master/convert" rel="noopener ugc nofollow" target="_blank">转换</a>包将响应转换为<strong class="js hu">目标</strong>类型</li></ul><p id="b560" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">例如，我们可以简单地测试<code class="eh mi mj mk ml b">Init</code>方法(在链码初始化时调用)是否返回成功的状态码:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ms mt l"/></div></figure><h2 id="52de" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">测试“<code class="eh mi mj mk ml b">Issue"</code>方法</h2><p id="06ae" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">我们预计调用<code class="eh mi mj mk ml b">issue</code> chaincode方法将导致:</p><ul class=""><li id="7d7c" class="ln lo ht js b jt ju jw jx jz lp kd lq kh lr kl ls lt lu lv dt translated">具有<code class="eh mi mj mk ml b">Ok</code>状态的响应</li><li id="172a" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">事件<code class="eh mi mj mk ml b">IssueCommercialPaper</code>被触发</li></ul><p id="f79f" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在测试中，我们可以通过MockStub调用<code class="eh mi mj mk ml b">issue</code>方法，检查响应状态并检查chaincode事件。可以从<code class="eh mi mj mk ml b">chaincodeEventsChannel</code>接收链码事件。<code class="eh mi mj mk ml b">expect</code>功能的<code class="eh mi mj mk ml b">BeEquivalentTo</code>方法可以方便地比较事件负载。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ms mt l"/></div></figure><p id="f7da" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">该测试将被阻止，直到通过通道<code class="eh mi mj mk ml b">paperChaincode.ChaincodeEventsChannel</code>(链码事件)收到响应。死锁或超时是这类测试的常见故障模式。在这种情况下，一个简单的模式是在函数底部添加一个select语句，并包含一个&lt; -time。(X)通道后指定一个超时。银杏就有这种模式。所有非容器块(<code class="eh mi mj mk ml b">It</code>、<code class="eh mi mj mk ml b">BeforeEache</code>等)中的主体函数都可以使用可选的done <code class="eh mi mj mk ml b">Done</code>参数。</p><p id="ec01" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">做成了一个<code class="eh mi mj mk ml b">chan interface{}</code>。当<code class="eh mi mj mk ml b">Ginkgo</code>检测到已经请求了<code class="eh mi mj mk ml b">done Done</code>参数时，它将主体函数作为goroutine运行，用必要的逻辑包装它以应用超时断言。你必须关闭<code class="eh mi mj mk ml b">done</code>通道或者发送一些东西(任何东西)给它，告诉<code class="eh mi mj mk ml b">Ginkgo</code>你的测试已经结束。如果您的测试在超时后没有结束，<code class="eh mi mj mk ml b">Ginkgo</code>将使测试失败，并继续下一个测试。</p><p id="31e7" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">默认超时为1秒。您可以通过在body函数后传递一个float64(以秒为单位)来修改这个超时。在本例中，我们将超时设置为0.1秒。</p><h2 id="a856" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">测试<code class="eh mi mj mk ml b">Get"</code>方法</h2><p id="8392" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">我们预计调用<code class="eh mi mj mk ml b">get</code> chaincode方法将导致:</p><ul class=""><li id="e684" class="ln lo ht js b jt ju jw jx jz lp kd lq kh lr kl ls lt lu lv dt translated">具有<code class="eh mi mj mk ml b">Ok</code>状态的响应</li><li id="b525" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">响应有效载荷与前一步骤中添加的商业票据属性一起被编组<code class="eh mi mj mk ml b">*schema.CommercialPaper</code></li></ul><p id="c01b" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><code class="eh mi mj mk ml b">PayloadIs</code>允许检查响应状态并转换到<code class="eh mi mj mk ml b">*schema.CommercialPaper</code>，然后<code class="eh mi mj mk ml b">Expect</code>帮助检查接收到的数据与期望值是否相等:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ms mt l"/></div></figure><h2 id="893d" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">测试链代码许可</h2><p id="c2a1" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">每个用户可以拥有不同的权限来使用chaincode方法。所有权限都基于用户证书和成员资格服务提供商标识符，这意味着权限总是对应于X.509证书。</p><p id="b7cd" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">简单的<a class="ae km" href="https://gist.github.com/examples/cars" rel="noopener ugc nofollow" target="_blank"> car </a>包含控制谁可以调用<code class="eh mi mj mk ml b">carRegister</code>方法的逻辑。<a class="ae km" href="https://gist.github.com/examples/cars/cars_test.go" rel="noopener ugc nofollow" target="_blank">测试</a>使用<code class="eh mi mj mk ml b">From</code> MockStub方法设置证书和调用者的MSP id</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ms mt l"/></div></figure><h2 id="6c27" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">调试链代码执行</h2><p id="a814" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated"><code class="eh mi mj mk ml b">CCKit</code>支持Hyperledger Fabric<a class="ae km" href="https://github.com/hyperledger/fabric/blob/release-1.4/core/chaincode/shim/chaincode.go#L1105" rel="noopener ugc nofollow" target="_blank">chain code Logger</a>及其选项，因此可以使用<code class="eh mi mj mk ml b">CORE_CHAINCODE_LOGGING_LEVEL</code>环境变量。<code class="eh mi mj mk ml b">CCKit</code> <a class="ae km" href="https://gist.github.com/state" rel="noopener ugc nofollow" target="_blank">链码状态包装器</a>输出调试严重级别消息，例如:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ms mt l"/></div></figure><p id="5d90" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">它显示了在执行链代码时，链代码状态执行了几个操作:</p><ul class=""><li id="4ec6" class="ln lo ht js b jt ju jw jx jz lp kd lq kh lr kl ls lt lu lv dt translated">处理<code class="eh mi mj mk ml b">init</code>链码方法时，用<code class="eh mi mj mk ml b">OWNER</code>键检查存在条目</li><li id="8da2" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">用<code class="eh mi mj mk ml b">OWNER</code>键输入状态</li><li id="1ac6" class="ln lo ht js b jt lw jw lx jz ly kd lz kh ma kl ls lt lu lv dt translated">处理<code class="eh mi mj mk ml b">issue</code>链码方法时，用<code class="eh mi mj mk ml b">[_idx CommercialPaper ExternalId EXT0001]</code>放置状态条目(对于<code class="eh mi mj mk ml b">Commercial entry</code>实体没有唯一索引)...</li></ul><h2 id="a3a4" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">试探性试验</h2><p id="b639" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">要运行测试套件，您只需在测试套件所在的存储库中运行命令:</p><p id="92cf" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">如果您在测试中有任何失败，您可以使用<code class="eh mi mj mk ml b">-ginkgo.failFast</code>选项在任何测试失败后禁止运行额外的测试。</p><h2 id="e600" class="kn ko ht bd kp kq kr ks kt ku kv kw kx jz ky kz la kd lb lc ld kh le lf lg lh dt translated">结论</h2><p id="7a8d" class="pw-post-body-paragraph jq jr ht js b jt li iu jv jw lj ix jy jz lk kb kc kd ll kf kg kh lm kj kk kl hm dt translated">Chaincode <code class="eh mi mj mk ml b">MockStub</code>非常有用，因为它允许开发者测试他的Chaincode，而不用每次都启动网络。这减少了开发时间，因为他可以使用测试驱动开发(TDD)方法，而不需要启动网络(这需要+- 40-80秒，取决于计算机的规格)。</p></div></div>    
</body>
</html>