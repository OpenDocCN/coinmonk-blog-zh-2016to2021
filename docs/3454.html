<html>
<head>
<title>Selling Sensitive Data on IOTA Data Marketplace</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在IOTA数据市场上出售敏感数据</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/selling-sensitive-data-on-iota-data-marketplace-d57e6780d159?source=collection_archive---------1-----------------------#2020-10-05">https://medium.com/coinmonks/selling-sensitive-data-on-iota-data-marketplace-d57e6780d159?source=collection_archive---------1-----------------------#2020-10-05</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="b0c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">自从隔离以来，在我做毕业设计的时候，我发现了IOTA <a class="ae jo" href="https://data.iota.org/" rel="noopener ugc nofollow" target="_blank">数据市场</a>平台。我想为什么数据来源如此匮乏？为什么企业和不同的机构希望对他们的数据保密，尽管已经证明为了数据分析师研究数据的目的而共享数据对社会中的每个人都有好处？最重要的是，我们如何鼓励这些公司分享他们的数据？</p><p id="2ef7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，我们需要一种从不同来源收集敏感数据的方法，同时保持数据完整性，并且不会将信息暴露给未经授权的个人。</p><h1 id="4d98" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">问题是</h1><p id="0a70" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">机构投入了大量的精力和资源来收集数据，同时，他们不喜欢分享自己的数据，因为他们担心一些竞争对手可能会使用这些数据并对他们实施反策略。例如，工厂不会分享他们产品供应链或生产线的数据。医院也一样，他们不愿意分享病人的数据，因为这是他们的隐私。为了解决这个问题，我们需要一种匿名和安全的方式来共享数据。如果我们克服了这个问题，我们将拥有丰富的可信数据来源，有助于实施公共政策...等等。</p><h1 id="3211" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">解决方案</h1><p id="3e4e" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">在这篇文章中，我将介绍两个案例:第一个案例是在同一领域工作的机构，因此他们拥有相似的信息，面临相同的挑战。比如医疗保健、金融和分解机构。因此，我们将过滤数据，使其匿名，然后将所有相似的数据相互合并。</p><p id="b44a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">第二种情况是由在独特领域工作的机构组成，通常他们不喜欢分享他们的数据。因此，我们将提供一些用户可以在不访问数据的情况下实现的操作。</p><h2 id="8282" class="ks jq ht bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf dt translated">第一个案例</h2><p id="97bd" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">我们使用数据过滤器来实现数据过滤过程，以封装/隐藏涉及特定机构的所有信息。然后，a对所有相似的机构数据进行合并处理。</p><h2 id="b09a" class="ks jq ht bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf dt translated">用例示例</h2><p id="3095" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">例如，如果我们有三个工厂想要以匿名方式共享他们的数据。所有工厂都有自己的传感器和物联网设备来共享数据。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff lg"><img src="../Images/19ca2d221361bf97654904d405c0efa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6nlt9SpPap-87GYo"/></div></div></figure><p id="eeb6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">数据封装模块收集数据，然后将其封装和合并，最后发布到IOTA数据市场供数据分析师使用。这个例子可以应用于医院或同一领域的任何其他机构。我们可以在下面的小范围内实现这个图表。</p><h1 id="dcfd" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">让我们实现一个实际的例子</h1><p id="caad" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">为了阐述我的想法，我做了一个简单的Github要点。我试图尽可能简单地实现它。我们假设我们在一个机构内有我们的物联网设备，我们将数据部署到数据市场，我们的原型作为它们之间的中间件来过滤数据。物联网设备向我们的Github gist发送JSON对象。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/1d88ece84d7c7f9aa2c4a3bbd6ff0aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*Ur8ctJzcexgRjYOApkz9Mg.png"/></div></figure><p id="a3dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">根据上面的流程图，我将创建一个简单的应用程序来过滤数据，合并数据，然后推送和下载filtred JSON对象。</p><h2 id="faac" class="ks jq ht bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf dt translated">让我们编码</h2><p id="9089" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">我只用了30分钟就做出了这个例子。我使用IOTA <a class="ae jo" href="https://docs.iota.org/docs/core/1.0/getting-started/get-started-js" rel="noopener ugc nofollow" target="_blank">文档</a>让我的代码尽可能的干净&amp;清晰。</p><p id="1c16" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我到底要创造什么？</p><p id="060c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一个将<a class="ae jo" href="https://docs.iota.org/docs/getting-started/0.1/transactions/bundles" rel="noopener ugc nofollow" target="_blank">尾事务</a>、类别和数据作为参数的函数，类似这样。</p><pre class="lh li lj lk fq lt lu lv lw aw lx dt"><span id="bfb8" class="ks jq ht lu b fv ly lz l ma mb">//dataset to be filtred<br/>const inputData = {</span><span id="a0f6" class="ks jq ht lu b fv mc lz l ma mb">'name':'Patient X',</span><span id="2ea9" class="ks jq ht lu b fv mc lz l ma mb">'id':'YYYYY',</span><span id="4824" class="ks jq ht lu b fv mc lz l ma mb">'age':23,</span><span id="8d90" class="ks jq ht lu b fv mc lz l ma mb">'institution_name':'institution X',</span><span id="b980" class="ks jq ht lu b fv mc lz l ma mb">'institution_id':'IDIDIDID',</span><span id="f7d5" class="ks jq ht lu b fv mc lz l ma mb">'Result':'Important Info To save',</span><span id="e0e7" class="ks jq ht lu b fv mc lz l ma mb">'dates':'Important dates to save them',</span><span id="8f04" class="ks jq ht lu b fv mc lz l ma mb">'Medicines':'Important medicines to take'</span><span id="5d37" class="ks jq ht lu b fv mc lz l ma mb">}</span><span id="f670" class="ks jq ht lu b fv mc lz l ma mb">// 1.tail transcation to check for old data</span><span id="21fb" class="ks jq ht lu b fv mc lz l ma mb">// 2. Data category</span><span id="9956" class="ks jq ht lu b fv mc lz l ma mb">// 3. Data to be filtred <br/>main('DWAOSLKHKMC9AQKYAL9PQSISXNDAAJGYXIPYTZVZHQCZGZAIPTVRN9OFFFZIISYIQOTWQWPI9WHGJN999','hospitals',inputData);</span></pre><p id="018a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们需要包含我们的npm模块并初始化IOTA节点</p><pre class="lh li lj lk fq lt lu lv lw aw lx dt"><span id="9e6f" class="ks jq ht lu b fv ly lz l ma mb">// IOTA global<br/>const Iota = require('@iota/core');</span><span id="e3f0" class="ks jq ht lu b fv mc lz l ma mb">const Extract = require('@iota/extract-json');</span><span id="2da9" class="ks jq ht lu b fv mc lz l ma mb">const Converter = require('@iota/converter');</span><span id="1336" class="ks jq ht lu b fv mc lz l ma mb">// Connect to a node</span><span id="07a1" class="ks jq ht lu b fv mc lz l ma mb">const iota = Iota.composeAPI({</span><span id="da29" class="ks jq ht lu b fv mc lz l ma mb">provider: 'https://nodes.devnet.iota.org:443'</span><span id="2998" class="ks jq ht lu b fv mc lz l ma mb">});</span><span id="1b25" class="ks jq ht lu b fv mc lz l ma mb">const depth = 3;</span><span id="336a" class="ks jq ht lu b fv mc lz l ma mb">const minimumWeightMagnitude = 9;</span><span id="dca0" class="ks jq ht lu b fv mc lz l ma mb">// Define a seed and an address.</span><span id="932e" class="ks jq ht lu b fv mc lz l ma mb">// These do not need to belong to anyone or have IOTA tokens.</span><span id="072e" class="ks jq ht lu b fv mc lz l ma mb">// They must only contain a mamximum of 81 trytes</span><span id="eece" class="ks jq ht lu b fv mc lz l ma mb">// or 90 trytes with a valid checksum</span><span id="68d5" class="ks jq ht lu b fv mc lz l ma mb">const address =</span><span id="7515" class="ks jq ht lu b fv mc lz l ma mb">'HEQLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWOR99D';</span><span id="2686" class="ks jq ht lu b fv mc lz l ma mb">const seed =</span><span id="63b0" class="ks jq ht lu b fv mc lz l ma mb">'PUEOTSEITFEVEWCWBTSIZM9NKRGJEIMXTULBACGFRQK9IMGICLBKW9TTEVSDQMGWKBXPVCBMMCXWMNPDX';</span></pre><p id="e032" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于这个例子，过滤和迁移功能将以一种简单的方式实现。</p><pre class="lh li lj lk fq lt lu lv lw aw lx dt"><span id="71bf" class="ks jq ht lu b fv ly lz l ma mb">const filterAndMerge = (oldDataSet,dataset)=&gt;{</span><span id="8d8c" class="ks jq ht lu b fv mc lz l ma mb">const filter = ['name','id','age','institution_name','institution_id'];</span><span id="1aea" class="ks jq ht lu b fv mc lz l ma mb">for (let index = 0; index &lt; filter.length; index++) {</span><span id="a685" class="ks jq ht lu b fv mc lz l ma mb">delete dataset[filter[index]];</span><span id="649d" class="ks jq ht lu b fv mc lz l ma mb">}</span><span id="4b0f" class="ks jq ht lu b fv mc lz l ma mb">let newData = {};</span><span id="a287" class="ks jq ht lu b fv mc lz l ma mb">if (Object.keys(oldDataSet).length) {</span><span id="0d73" class="ks jq ht lu b fv mc lz l ma mb">newData = Object.assign(oldDataSet, dataset);</span><span id="25c0" class="ks jq ht lu b fv mc lz l ma mb">}</span><span id="42f3" class="ks jq ht lu b fv mc lz l ma mb">return newData;</span><span id="0de7" class="ks jq ht lu b fv mc lz l ma mb">}</span></pre><p id="dc85" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">获取和推送数据的功能与文档完全相同。我只是把<code class="eh md me mf lu b">.then()</code>换成了<code class="eh md me mf lu b">await</code></p><pre class="lh li lj lk fq lt lu lv lw aw lx dt"><span id="f45d" class="ks jq ht lu b fv ly lz l ma mb">//IOTA metods<br/>const fetch = async(tailTransactionHash)=&gt;{<br/>// Get the transaction objects in the bundle<br/>const bundle = await iota.getBundle(tailTransactionHash)<br/>// Extract and parse the JSON messages from the transactions' `signatureMessageFragment` fields<br/>const data = JSON.parse(Extract.extractJson(bundle));<br/>return data;<br/>}<br/>const pushData = async(dataCategory,filtredDataset)=&gt;{<br/>const message = JSON.stringify({dataCategory:dataCategory, dataset:filtredDataset});<br/>// Convert the message to trytes<br/>const messageInTrytes = Converter.asciiToTrytes(message);<br/>// Define a zero-value transaction object</span><span id="a612" class="ks jq ht lu b fv mc lz l ma mb">// that sends the message to the address</span><span id="f61a" class="ks jq ht lu b fv mc lz l ma mb">const transfers = [</span><span id="fd21" class="ks jq ht lu b fv mc lz l ma mb">{</span><span id="259d" class="ks jq ht lu b fv mc lz l ma mb">value: 0,</span><span id="ac2e" class="ks jq ht lu b fv mc lz l ma mb">address: address,</span><span id="228d" class="ks jq ht lu b fv mc lz l ma mb">message: messageInTrytes</span><span id="ae93" class="ks jq ht lu b fv mc lz l ma mb">}</span><span id="7543" class="ks jq ht lu b fv mc lz l ma mb">];</span><span id="963c" class="ks jq ht lu b fv mc lz l ma mb">// Create a bundle from the `transfers` array<br/>// and send the transaction to the node</span><span id="27de" class="ks jq ht lu b fv mc lz l ma mb">const trytes = await iota.prepareTransfers(seed, transfers);</span><span id="acb0" class="ks jq ht lu b fv mc lz l ma mb">const bundle =  await iota.sendTrytes(trytes, depth, minimumWeightMagnitude);</span><span id="822d" class="ks jq ht lu b fv mc lz l ma mb">return bundle[0].hash;</span><span id="38e3" class="ks jq ht lu b fv mc lz l ma mb">}</span></pre><p id="c42d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，我们将创建主函数。主要功能步骤与上述流程图相同。</p><pre class="lh li lj lk fq lt lu lv lw aw lx dt"><span id="6b59" class="ks jq ht lu b fv ly lz l ma mb">const main = async(tailTransaction,category,data)=&gt;{</span><span id="dc3a" class="ks jq ht lu b fv mc lz l ma mb">// check if this data category already exisit</span><span id="fb99" class="ks jq ht lu b fv mc lz l ma mb">const oldData = await fetch(tailTransaction);</span><span id="2ff9" class="ks jq ht lu b fv mc lz l ma mb">let newData;</span><span id="694b" class="ks jq ht lu b fv mc lz l ma mb">if (oldData.dataCategory === category) {</span><span id="deb9" class="ks jq ht lu b fv mc lz l ma mb">newData = filterAndMerge(oldData,data);</span><span id="6f79" class="ks jq ht lu b fv mc lz l ma mb">}else{</span><span id="106c" class="ks jq ht lu b fv mc lz l ma mb">newData = filterAndMerge({},data);</span><span id="b556" class="ks jq ht lu b fv mc lz l ma mb">}</span><span id="a358" class="ks jq ht lu b fv mc lz l ma mb">console.log(newData)</span><span id="362c" class="ks jq ht lu b fv mc lz l ma mb">const hash = await pushData(newData);</span><span id="ffde" class="ks jq ht lu b fv mc lz l ma mb">console.log(hash);</span><span id="7591" class="ks jq ht lu b fv mc lz l ma mb">return hash;</span><span id="8e96" class="ks jq ht lu b fv mc lz l ma mb">}</span></pre><p id="eebf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在你应该有类似的东西:</p><pre class="lh li lj lk fq lt lu lv lw aw lx dt"><span id="a653" class="ks jq ht lu b fv ly lz l ma mb">// IOTA global</span><span id="c536" class="ks jq ht lu b fv mc lz l ma mb">const Iota = require('@iota/core');</span><span id="7797" class="ks jq ht lu b fv mc lz l ma mb">const Extract = require('@iota/extract-json');</span><span id="ffaf" class="ks jq ht lu b fv mc lz l ma mb">const Converter = require('@iota/converter');</span><span id="a908" class="ks jq ht lu b fv mc lz l ma mb">// Connect to a node</span><span id="f12f" class="ks jq ht lu b fv mc lz l ma mb">const iota = Iota.composeAPI({</span><span id="faf0" class="ks jq ht lu b fv mc lz l ma mb">provider: 'https://nodes.devnet.iota.org:443'</span><span id="fee9" class="ks jq ht lu b fv mc lz l ma mb">});</span><span id="84df" class="ks jq ht lu b fv mc lz l ma mb">const depth = 3;<br/>const minimumWeightMagnitude = 9;<br/>// Define a seed and an address.</span><span id="4a9a" class="ks jq ht lu b fv mc lz l ma mb">// These do not need to belong to anyone or have IOTA tokens.</span><span id="f21f" class="ks jq ht lu b fv mc lz l ma mb">// They must only contain a mamximum of 81 trytes</span><span id="585e" class="ks jq ht lu b fv mc lz l ma mb">// or 90 trytes with a valid checksum</span><span id="25cb" class="ks jq ht lu b fv mc lz l ma mb">const address =</span><span id="3f35" class="ks jq ht lu b fv mc lz l ma mb">'HEQLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWORLDHELLOWOR99D';</span><span id="c475" class="ks jq ht lu b fv mc lz l ma mb">const seed =</span><span id="b003" class="ks jq ht lu b fv mc lz l ma mb">'PUEOTSEITFEVEWCWBTSIZM9NKRGJEIMXTULBACGFRQK9IMGICLBKW9TTEVSDQMGWKBXPVCBMMCXWMNPDX';</span><span id="6218" class="ks jq ht lu b fv mc lz l ma mb">//IOTA metods<br/>const fetch = async(tailTransactionHash)=&gt;{</span><span id="117f" class="ks jq ht lu b fv mc lz l ma mb">// Get the transaction objects in the bundle</span><span id="5b19" class="ks jq ht lu b fv mc lz l ma mb">const bundle = await iota.getBundle(tailTransactionHash)</span><span id="2aeb" class="ks jq ht lu b fv mc lz l ma mb">// Extract and parse the JSON messages from the transactions' `signatureMessageFragment` fields</span><span id="1804" class="ks jq ht lu b fv mc lz l ma mb">const data = JSON.parse(Extract.extractJson(bundle));</span><span id="4b37" class="ks jq ht lu b fv mc lz l ma mb">return data;</span><span id="4db6" class="ks jq ht lu b fv mc lz l ma mb">}<br/></span><span id="34dc" class="ks jq ht lu b fv mc lz l ma mb">const pushData = async(dataCategory,filtredDataset)=&gt;{<br/>const message = JSON.stringify({dataCategory:dataCategory, dataset:filtredDataset});</span><span id="02af" class="ks jq ht lu b fv mc lz l ma mb">// Convert the message to trytes<br/>const messageInTrytes = Converter.asciiToTrytes(message);</span><span id="dfb8" class="ks jq ht lu b fv mc lz l ma mb">// Define a zero-value transaction object<br/>// that sends the message to the address<br/>const transfers = [<br/>{</span><span id="485a" class="ks jq ht lu b fv mc lz l ma mb">value: 0,</span><span id="60f4" class="ks jq ht lu b fv mc lz l ma mb">address: address,</span><span id="1e0e" class="ks jq ht lu b fv mc lz l ma mb">message: messageInTrytes<br/>}];</span><span id="d974" class="ks jq ht lu b fv mc lz l ma mb">// Create a bundle from the `transfers` array<br/>// and send the transaction to the node</span><span id="f6ad" class="ks jq ht lu b fv mc lz l ma mb">const trytes = await iota.prepareTransfers(seed, transfers);</span><span id="4327" class="ks jq ht lu b fv mc lz l ma mb">const bundle =  await iota.sendTrytes(trytes, depth, minimumWeightMagnitude);</span><span id="7cd0" class="ks jq ht lu b fv mc lz l ma mb">return bundle[0].hash;</span><span id="5523" class="ks jq ht lu b fv mc lz l ma mb">}</span><span id="e39b" class="ks jq ht lu b fv mc lz l ma mb">const filterAndMerge = (oldDataSet,dataset)=&gt;{<br/>const filter = ['name','id','age','institution_name','institution_id'];</span><span id="aa1d" class="ks jq ht lu b fv mc lz l ma mb">for (let index = 0; index &lt; filter.length; index++) {</span><span id="92e8" class="ks jq ht lu b fv mc lz l ma mb">delete dataset[filter[index]];</span><span id="9bae" class="ks jq ht lu b fv mc lz l ma mb">}</span><span id="ca96" class="ks jq ht lu b fv mc lz l ma mb">let newData = {};</span><span id="f4c0" class="ks jq ht lu b fv mc lz l ma mb">if (Object.keys(oldDataSet).length) {</span><span id="5b9b" class="ks jq ht lu b fv mc lz l ma mb">newData = Object.assign(oldDataSet, dataset);</span><span id="40d3" class="ks jq ht lu b fv mc lz l ma mb">}</span><span id="9224" class="ks jq ht lu b fv mc lz l ma mb">return newData;</span><span id="d123" class="ks jq ht lu b fv mc lz l ma mb">}</span><span id="fa79" class="ks jq ht lu b fv mc lz l ma mb">const main = async(tailTransaction,category,data)=&gt;{<br/>// check if this data category already exisit<br/>const oldData = await fetch(tailTransaction);<br/>let newData;</span><span id="e4a5" class="ks jq ht lu b fv mc lz l ma mb">if (oldData.dataCategory === category) {</span><span id="dde1" class="ks jq ht lu b fv mc lz l ma mb">newData = filterAndMerge(oldData,data);</span><span id="81e7" class="ks jq ht lu b fv mc lz l ma mb">}else{</span><span id="62e9" class="ks jq ht lu b fv mc lz l ma mb">newData = filterAndMerge({},data);</span><span id="da63" class="ks jq ht lu b fv mc lz l ma mb">}</span><span id="55b9" class="ks jq ht lu b fv mc lz l ma mb">console.log(newData)</span><span id="6886" class="ks jq ht lu b fv mc lz l ma mb">const hash = await pushData(newData);</span><span id="651a" class="ks jq ht lu b fv mc lz l ma mb">console.log(hash);</span><span id="9383" class="ks jq ht lu b fv mc lz l ma mb">return hash;</span><span id="2ae5" class="ks jq ht lu b fv mc lz l ma mb">}</span><span id="1021" class="ks jq ht lu b fv mc lz l ma mb">const inputData = {</span><span id="7b94" class="ks jq ht lu b fv mc lz l ma mb">'name':'Patient X',</span><span id="b068" class="ks jq ht lu b fv mc lz l ma mb">'id':'YYYYY',</span><span id="0cec" class="ks jq ht lu b fv mc lz l ma mb">'age':23,</span><span id="c303" class="ks jq ht lu b fv mc lz l ma mb">'institution_name':'institution X',</span><span id="5aa5" class="ks jq ht lu b fv mc lz l ma mb">'institution_id':'IDIDIDID',</span><span id="4592" class="ks jq ht lu b fv mc lz l ma mb">'Result':'Important Info To save',</span><span id="7dab" class="ks jq ht lu b fv mc lz l ma mb">'dates':'Important dates to save them',</span><span id="c641" class="ks jq ht lu b fv mc lz l ma mb">'Medicines':'Important medicines to take'</span><span id="d4c7" class="ks jq ht lu b fv mc lz l ma mb">}</span><span id="2022" class="ks jq ht lu b fv mc lz l ma mb">main('DWAOSLKHKMC9AQKYAL9PQSISXNDAAJGYXIPYTZVZHQCZGZAIPTVRN9OFFFZIISYIQOTWQWPI9WHGJN999','hospitals',inputData);</span></pre><p id="2c9d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们运行代码，我们将得到这样的输出</p><pre class="lh li lj lk fq lt lu lv lw aw lx dt"><span id="7517" class="ks jq ht lu b fv ly lz l ma mb">node index.js <br/>{ dataCategory: 'hospitals',<br/>  dataset: '{pateientA:patientB,patientC:patientD}',<br/>  Result: 'Important Info To save',<br/>  dates: 'Important dates to save them',<br/>  Medicines: 'Important medicines to take' }<br/>HEDNKESCWPFNVGJBE99XNRZHHSYTRNZYRZXSVWHLQASANSWVKONYRNB9N9HCMHFIZIARDGARMKUCZS999</span></pre><h2 id="e157" class="ks jq ht bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf dt translated">第二种情况</h2><p id="df1f" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">在我看来，第二种情况更有趣，所以我将在另一篇文章中重点讨论它。如果我们对它们使用数据过滤器，一些数据可能是无用的，或者有暴露机构身份的风险。因此，我们将使用一个黑盒，数据安全地保存在其中。然后，我们可以在黑盒中实现选择的操作来获得输出。大概就是这样。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/13af35c35186879d533f239c12bf7b7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*9mXqfXLsYEVxgbs9icKaXg.png"/></div></figure><h2 id="960c" class="ks jq ht bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf dt translated">下一步做什么？</h2><p id="ca5c" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">我计划大规模实施这个项目。为IOTA数据市场创建一个插件，鼓励以安全的方式共享数据。这就是我写这篇文章的原因，我想知道有多少人对数据完整性感兴趣。如果我开始一个开源项目，社区会有兴趣贡献吗？我为全面实施创建了一个提案。如果有人感兴趣，我可以与她/他分享。</p><p id="489a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来的步骤将是:</p><ol class=""><li id="8c4e" class="mh mi ht is b it iu ix iy jb mj jf mk jj ml jn mm mn mo mp dt translated">我曾经在我所有的区块链项目中实施<a class="ae jo" href="https://ipfs.io/" rel="noopener ugc nofollow" target="_blank"> IPFS </a>作为分散存储。最近IOTA推出了存在证明(<a class="ae jo" href="https://docs.iota.org/docs/proof-of-existence/1.0/overview#" rel="noopener ugc nofollow" target="_blank"> POE </a>)我也打算试试。这对于验证过滤的数据可能是有用的。</li><li id="20ec" class="mh mi ht is b it mq ix mr jb ms jf mt jj mu jn mm mn mo mp dt translated">过滤和迁移过程应该保持数据匿名，同时以更好的方式对数据集进行排序和分析。我们可能需要一些算法来实现这一点。</li><li id="538a" class="mh mi ht is b it mq ix mr jb ms jf mt jj mu jn mm mn mo mp dt translated">机构认证和授权。</li><li id="cb8f" class="mh mi ht is b it mq ix mr jb ms jf mt jj mu jn mm mn mo mp dt translated">与IOTA数据市场集成。</li><li id="d392" class="mh mi ht is b it mq ix mr jb ms jf mt jj mu jn mm mn mo mp dt translated">如果机构根本不想共享他们的数据，应该增加一个外部安全层。或者，如果我们将数据集匿名化，数据集就没有用了。因此，我们上传机器学习模型，并在黑盒(其中包含机密数据)内进行操作，我们只分享结果。</li></ol><p id="00a6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我欢迎任何对开源世界感兴趣的人加入我的行列。如果你感兴趣，可以发邮件到yehiatarek67@gmail.com和我联系</p><h2 id="46be" class="ks jq ht bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf dt translated"><strong class="ak">同样，阅读</strong></h2><ul class=""><li id="f48c" class="mh mi ht is b it kn ix ko jb mv jf mw jj mx jn my mn mo mp dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/defi-future-10-promising-projects-in-the-defi-world-ff2b697ab006">顶级DeFi项目</a></li><li id="51e2" class="mh mi ht is b it mq ix mr jb ms jf mt jj mu jn my mn mo mp dt translated">最好的<a class="ae jo" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069?source=friends_link&amp;sk=324dd9ff8556ab578d71e7ad7658ad7c">硬件钱包</a></li><li id="69bb" class="mh mi ht is b it mq ix mr jb ms jf mt jj mu jn my mn mo mp dt translated">开发人员的最佳加密API</li></ul></div></div>    
</body>
</html>