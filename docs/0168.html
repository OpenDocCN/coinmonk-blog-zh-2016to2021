<html>
<head>
<title>Ethereum Solidity: Memory vs Storage &amp; When to Use Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊稳固性:内存与存储&amp;何时使用它们</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethereum-solidity-memory-vs-storage-which-to-use-in-local-functions-72b593c3703a?source=collection_archive---------0-----------------------#2018-03-18">https://medium.com/coinmonks/ethereum-solidity-memory-vs-storage-which-to-use-in-local-functions-72b593c3703a?source=collection_archive---------0-----------------------#2018-03-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/47824cd94c21cfecc23d9b97a04249f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4cy-ctwr3VNaoi68Dw8-g.png"/></div></div></figure><p id="2f34" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有人在<a class="ae jz" href="https://github.com/saurfang/ipfs-multihash-on-solidity/issues/1" rel="noopener ugc nofollow" target="_blank"> Github </a>上问我，在下面的简化代码片段中，我们应该使用<code class="eh ka kb kc kd b">storage</code>还是<code class="eh ka kb kc kd b">memory</code>关键字:</p><figure class="ke kf kg kh fq iu"><div class="bz el l di"><div class="ki kj l"/></div></figure><p id="9813" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于<code class="eh ka kb kc kd b">getUsingStorage</code>和<code class="eh ka kb kc kd b">getUsingMemory</code>，我尝试了<code class="eh ka kb kc kd b">storage</code>和<code class="eh ka kb kc kd b">memory</code>，我的单元测试在这两种情况下都能通过。那么<code class="eh ka kb kc kd b">storage</code>和<code class="eh ka kb kc kd b">memory</code>到底有什么区别，我们应该什么时候使用它们呢？</p><blockquote class="kk"><p id="bbfb" class="kl km ht bd kn ko kp kq kr ks kt jy ek translated"><a class="ae jz" href="https://coincodecap.com/category/blockchain-node-and-api" rel="noopener ugc nofollow" target="_blank">发现并回顾最佳以太坊开发工具</a></p></blockquote></div><div class="ab cl ku kv hb kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hm hn ho hp hq"><p id="9aad" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">根据<a class="ae jz" href="https://solidity.readthedocs.io/en/v0.4.21/types.html#reference-types" rel="noopener ugc nofollow" target="_blank">固体文件</a>，这两个关键字用于<code class="eh ka kb kc kd b">Reference Types</code>处</p><blockquote class="lb lc ld"><p id="03b6" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt translated">复杂类型，即不总是适合256位的类型，必须比我们已经看到的值类型更小心地处理。由于复制它们可能相当昂贵，我们必须考虑是希望它们存储在<strong class="jd hu">内存</strong>(不是持久的)还是<strong class="jd hu">存储器</strong>(保存状态变量的地方)。</p><p id="34f0" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt">…</p><p id="de11" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt translated">每个复杂类型，即<em class="ht">数组</em>和<em class="ht">结构</em>，都有一个附加的注释，即“数据位置”，关于它是存储在内存中还是存储在存储器中。</p></blockquote><p id="0679" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在重要的是看一下<a class="ae jz" href="http://solidity.readthedocs.io/en/v0.4.21/frequently-asked-questions.html#what-is-the-memory-keyword-what-does-it-do" rel="noopener ugc nofollow" target="_blank">EVM(以太坊虚拟机)在哪里存储数据</a>:</p><blockquote class="lb lc ld"><p id="6eec" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt translated">以太坊虚拟机有三个区域可以存储物品。</p><p id="1243" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt translated">第一个是“存储”，所有契约状态变量都驻留在这里。每个契约都有自己的存储，并且在函数调用之间是持久的，使用起来非常昂贵。</p><p id="b120" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt translated">第二个是“内存”，这是用来保存临时值。它在(外部)函数调用之间被擦除，使用起来更便宜。</p><p id="c095" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt translated">第三个是堆栈，用来保存小的局部变量。它几乎可以免费使用，但只能保存有限的值。</p></blockquote><p id="85d0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最重要的是，</p><blockquote class="lb lc ld"><p id="3e98" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt translated">例如，如果您在函数调用中传递这样的变量，如果它们的数据可以留在内存或存储中，则不会复制它们。</p></blockquote><p id="907e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这就是令人困惑的地方:</p><ol class=""><li id="4f7f" class="li lj ht jd b je jf ji jj jm lk jq ll ju lm jy ln lo lp lq dt translated"><code class="eh ka kb kc kd b">storage</code>和<code class="eh ka kb kc kd b">memory</code>关键字分别用于引用存储器和内存中的数据。</li><li id="2270" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy ln lo lp lq dt translated">合同存储是在合同构造期间预先分配的，不能在函数调用中创建。毕竟，如果要持久化，在函数的存储中创建新变量是没有意义的。</li><li id="cbea" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy ln lo lp lq dt translated">内存不能在契约构造期间分配，而是在函数执行时创建。契约<strong class="jd hu">状态变量</strong>总是在存储中声明。同样，拥有不能持久的状态变量是没有意义的。</li><li id="d018" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy ln lo lp lq dt translated">当将一个<code class="eh ka kb kc kd b">memory</code>引用的数据赋给一个<code class="eh ka kb kc kd b">storage</code>引用的变量时，我们将数据从内存复制到存储器。<strong class="jd hu">不创建新的存储。</strong></li><li id="93b6" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy ln lo lp lq dt translated">当将一个<code class="eh ka kb kc kd b">storage</code>引用数据赋给一个<code class="eh ka kb kc kd b">memory</code>引用变量时，我们将数据从存储器复制到内存。分配了新的内存。</li><li id="f03e" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy ln lo lp lq dt translated">当通过查找在函数中本地创建一个<code class="eh ka kb kc kd b">storage</code>变量时，它只是引用已经在存储器上分配的数据。没有创建新的存储。</li></ol><p id="9aa5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">概括地说，请参考文档:</p><blockquote class="lb lc ld"><p id="f247" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt translated">强制数据位置:</p><p id="410c" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt translated">*外部函数的参数(不返回):calldata</p><p id="7025" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt translated">*状态变量:存储</p><p id="d9d7" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt translated">默认数据位置:</p><p id="26b5" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt translated">*函数的参数(也是返回):内存</p><p id="dc7f" class="jb jc le jd b je jf jg jh ji jj jk jl lf jn jo jp lg jr js jt lh jv jw jx jy hm dt translated">*所有其他局部变量:存储</p></blockquote><p id="b3bf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以只对功能上的<code class="eh ka kb kc kd b">parameters of functions</code>和<code class="eh ka kb kc kd b">local variables</code>改变<code class="eh ka kb kc kd b">data location</code>。每当<code class="eh ka kb kc kd b">storage</code>引用被转换为<code class="eh ka kb kc kd b">memory</code>时，就会产生一个副本，并且对对象的进一步修改不会传播回契约状态。<code class="eh ka kb kc kd b">memory</code>如果内存数据可以复制到预先分配的状态变量，引用只能“分配”给<code class="eh ka kb kc kd b">storage</code>引用。</p></div><div class="ab cl ku kv hb kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hm hn ho hp hq"><p id="b68d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">回到我们上面的说明性契约，对于getters:</p><pre class="ke kf kg kh fq lw kd lx ly aw lz dt"><span id="1d88" class="ma mb ht kd b fv mc md l me mf">function getUsingStorage(uint _itemIdx)<br/>public<br/>// set to non-view to estimate gas<br/>// view<br/>returns (uint)<br/>{<br/>Item storage item = items[_itemIdx];<br/>return item.units;<br/>}</span><span id="eba3" class="ma mb ht kd b fv mg md l me mf">function getUsingMemory(uint _itemIdx)<br/>public<br/>// set to non-view to estimate gas<br/>// view<br/>returns (uint)<br/>{<br/>Item memory item = items[_itemIdx];<br/>return item.units;<br/>}</span></pre><p id="0474" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">两个函数返回相同的结果，除了在<code class="eh ka kb kc kd b">getUsingMemory</code>中创建了一个新变量并导致使用了更多的气体:</p><pre class="ke kf kg kh fq lw kd lx ly aw lz dt"><span id="6b3d" class="ma mb ht kd b fv mc md l me mf">// <!-- -->getUsingStorage<br/>"gasUsed": 21849</span><span id="32b8" class="ma mb ht kd b fv mg md l me mf">// <!-- -->getUsingMemory<br/>"gasUsed": 22149,</span></pre><p id="adf0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">另一方面，对于setters:</p><pre class="ke kf kg kh fq lw kd lx ly aw lz dt"><span id="a43a" class="ma mb ht kd b fv mc md l me mf">function addItemUsingStorage(uint _itemIdx, uint _units)<br/>public<br/>{<br/>Item storage item = items[_itemIdx];<br/>item.units += _units;<br/>}<br/></span><span id="23e8" class="ma mb ht kd b fv mg md l me mf">function addItemUsingMemory(uint _itemIdx, uint _units)<br/>public<br/>// set to non-view to estimate gas<br/>// view<br/>{<br/>Item memory item = items[_itemIdx];<br/>item.units += _units;<br/>}</span></pre><p id="b16d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">只有<code class="eh ka kb kc kd b">addItemUsingStorage</code>修改了状态变量(消耗更多气体):</p><pre class="ke kf kg kh fq lw kd lx ly aw lz dt"><span id="6782" class="ma mb ht kd b fv mc md l me mf">// addItemUsingStorage<br/>// `units` changes in `items`<br/>"gasUsed": 27053,</span><span id="f119" class="ma mb ht kd b fv mg md l me mf">// addItemUsingMemory<br/>// `units` does not change in `items`<br/>"gasUsed": 22287,</span></pre></div><div class="ab cl ku kv hb kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hm hn ho hp hq"><p id="c205" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，要点如下:</p><ol class=""><li id="87db" class="li lj ht jd b je jf ji jj jm lk jq ll ju lm jy ln lo lp lq dt translated"><code class="eh ka kb kc kd b">memory</code>和<code class="eh ka kb kc kd b">storage</code>指定变量引用哪个<code class="eh ka kb kc kd b">data location</code></li><li id="5879" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy ln lo lp lq dt translated"><code class="eh ka kb kc kd b">storage</code>不能在函数中新建。函数中的任何<code class="eh ka kb kc kd b">storage</code>引用变量总是引用合同存储器上预先分配的一段数据(状态变量)。函数调用后，任何突变都会持续。</li><li id="b7a3" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy ln lo lp lq dt translated"><code class="eh ka kb kc kd b">memory</code>只能在函数中新建。它可以是新实例化的复杂类型，如数组/结构(如通过<code class="eh ka kb kc kd b">new int[...]</code>)或从<code class="eh ka kb kc kd b">storage</code>引用的变量复制而来。</li><li id="fb82" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy ln lo lp lq dt translated">当引用通过函数参数在内部传递时，记住它们默认为<code class="eh ka kb kc kd b">memory</code>，如果变量在<code class="eh ka kb kc kd b">storage</code>上，它将创建一个副本，任何修改都不会持续。</li></ol></div><div class="ab cl ku kv hb kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hm hn ho hp hq"><p id="8a3a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">参考资料:</p><div class="mh mi fm fo mj mk"><a href="https://stackoverflow.com/questions/33839154/in-ethereum-solidity-what-is-the-purpose-of-the-memory-keyword" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd hu fv z el mp eo ep mq er et hs dt translated">以太坊坚固中，“记忆”关键字的用途是什么？</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">如果没有memory关键字，Solidity会尝试在存储中声明变量。Lead Solidity dev chriseth:“你可以思考…</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">stackoverflow.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my iz mk"/></div></div></a></div><div class="mh mi fm fo mj mk"><a href="https://ethereum.stackexchange.com/questions/1701/what-does-the-keyword-memory-do-exactly" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd hu fv z el mp eo ep mq er et hs dt translated">“记忆”这个关键词到底是做什么的？</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">强烈推荐完整阅读关于“内存”的Solidity FAQ，下面提供了一个片段。以太坊…</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">ethereum.stackexchange.com</p></div></div><div class="mt l"><div class="mz l mv mw mx mt my iz mk"/></div></div></a></div><div class="mh mi fm fo mj mk"><a rel="noopener follow" target="_blank" href="/loom-network/ethereum-solidity-memory-vs-storage-how-to-initialize-an-array-inside-a-struct-184baf6aa2eb"><div class="ml ab ej"><div class="mm ab mn cl cj mo"><h2 class="bd hu fv z el mp eo ep mq er et hs dt translated">以太坊稳固性:内存与存储&amp;如何在结构中初始化数组</h2><div class="mr l"><h3 class="bd b fv z el mp eo ep mq er et ek translated">在Loom Network的Telegram(拥有约8000名会员！)人们就各种话题提问，比如Loom的路线图……</h3></div><div class="ms l"><p class="bd b gc z el mp eo ep mq er et ek translated">medium.com</p></div></div><div class="mt l"><div class="na l mv mw mx mt my iz mk"/></div></div></a></div><blockquote class="kk"><p id="79e4" class="kl km ht bd kn ko nb nc nd ne nf jy ek translated">加入Coinmonks <a class="ae jz" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jz" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae jz" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="ma mb ht bd ng nh ni nj nk nl nm nn no jm np nq nr jq ns nt nu ju nv nw nx ny dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="li lj ht jd b je nz ji oa jm ob jq oc ju od jy oe lo lp lq dt translated"><a class="ae jz" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae jz" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="14e6" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy oe lo lp lq dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae jz" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy oe lo lp lq dt translated"><a class="ae jz" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae jz" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="f33b" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy oe lo lp lq dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae jz" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy oe lo lp lq dt translated">开发人员的最佳加密API</li><li id="b359" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy oe lo lp lq dt translated">最佳<a class="ae jz" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy oe lo lp lq dt translated"><a class="ae jz" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li><li id="95d1" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy oe lo lp lq dt translated"><a class="ae jz" href="https://coincodecap.com/best-vpns-for-crypto-trading" rel="noopener ugc nofollow" target="_blank">加密交易的最佳VPNs】</a></li><li id="918f" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy oe lo lp lq dt translated"><a class="ae jz" href="https://coincodecap.com/blockchain-analytics" rel="noopener ugc nofollow" target="_blank">最佳加密分析或链上数据</a> | <a class="ae jz" href="https://coincodecap.com/bexplus-review" rel="noopener ugc nofollow" target="_blank"> Bexplus评论</a></li><li id="51af" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy oe lo lp lq dt translated"><a class="ae jz" href="https://coincodecap.com/nft-marketplaces" rel="noopener ugc nofollow" target="_blank">NFT十大市场造币集锦</a></li><li id="f72f" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy oe lo lp lq dt translated"><a class="ae jz" href="https://coincodecap.com/ascendex-staking" rel="noopener ugc nofollow" target="_blank">AscendEx Staking</a>|<a class="ae jz" href="https://coincodecap.com/bot-ocean-review" rel="noopener ugc nofollow" target="_blank">Bot Ocean Review</a>|<a class="ae jz" href="https://coincodecap.com/bitcoin-wallets-india" rel="noopener ugc nofollow" target="_blank">最佳比特币钱包</a></li><li id="4ec1" class="li lj ht jd b je lr ji ls jm lt jq lu ju lv jy oe lo lp lq dt translated"><a class="ae jz" href="https://coincodecap.com/bitget-review" rel="noopener ugc nofollow" target="_blank"> Bitget回顾</a>|<a class="ae jz" href="https://coincodecap.com/gemini-vs-blockfi" rel="noopener ugc nofollow" target="_blank">Gemini vs block fi</a>|<a class="ae jz" href="https://coincodecap.com/okex-futures-trading" rel="noopener ugc nofollow" target="_blank">OKEx期货交易</a></li></ul></div></div>    
</body>
</html>