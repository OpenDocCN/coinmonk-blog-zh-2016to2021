<html>
<head>
<title>Create Bitcoin Exchange in Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Haskell中创建比特币交易所</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/roll-your-own-bitcoin-exchange-in-haskell-a8d782ab2a24?source=collection_archive---------8-----------------------#2018-05-16">https://medium.com/coinmonks/roll-your-own-bitcoin-exchange-in-haskell-a8d782ab2a24?source=collection_archive---------8-----------------------#2018-05-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="c616" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">在Haskell推出自己的比特币交易所</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/5f4f60483addac0e8ba4c7cabba19644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VjZ3vRbwMcccc0ZA.jpg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek"><a class="ae jy" href="https://www.abcfinanze.com/investimenti/trading-bitcoin/" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><blockquote class="jz ka kb"><p id="2615" class="kc kd ke kf b kg kh iu ki kj kk ix kl km kn ko kp kq kr ks kt ku kv kw kx ky hm dt translated"><strong class="kf hu">归属</strong> —这是<a class="ae jy" href="https://twitter.com/TheMichaelBurge" rel="noopener ugc nofollow" target="_blank">迈克尔·伯格的</a>博文<br/> <a class="ae jy" href="https://www.michaelburge.us/2017/08/31/roll-your-own-bitcoin-exchange.html" rel="noopener ugc nofollow" target="_blank">在哈斯克尔</a>推出你自己的比特币交易所的转载作品</p></blockquote><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="https://coinmonks.com"><div class="fe ff kz"><img src="../Images/24325228c537a09e28d6e4d8a7d100b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*2rvJnCn8s5msnFHnqh1LMw.png"/></div></a><figcaption class="ju jv fg fe ff jw jx bd b be z ek"><strong class="bd la">Click to Find blockchain Jobs</strong></figcaption></figure><p id="b540" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><a class="ae jy" href="https://coinmonks.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf hu">使用Coinmonks作业门户</strong> </a>查找加密作业</p><p id="a566" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><code class="eh le lf lg lh b"><a class="ae jy" rel="noopener" href="https://medium.com/coinmonks/contribute/home"><strong class="kf hu">Get published on Coinmonks</strong></a></code></p><p id="751e" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/monks-need-your-help-7440418d67ec"> <strong class="kf hu"> <em class="ke">捐造僧</em> </strong> </a></p><p id="29e0" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">证券交易所是一个复杂的庞然大物，但它的大部分可以简化为一个单一的数据结构:订单簿。比特币交易所在交易美元、BTC或瑞士法郎的货币对时使用相同的数据结构。本文将向您展示如何:</p><ul class=""><li id="8735" class="li lj ht kf b kg kh kj kk lb lk lc ll ld lm ky ln lo lp lq dt translated">设计一个可以处理限价订单和市价订单的订单簿</li><li id="f308" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">安装自动健全性检查，在每次写入订单时运行，防止黑客攻击和实施错误</li><li id="6829" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">构建一个人们可以用来与订单簿交互的HTTP API</li></ul><p id="5ce2" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">我们不会使用实际的比特币或钱包，因为它们增加了很多复杂性和风险，而不会让文章变得更有趣。相反，我们将假设“计费代码”已经写好，并且只关注交换的订单簿部分。</p><h1 id="3047" class="lw lx ht bd ly lz ma mb mc md me mf mg iz mh ja mi jc mj jd mk jf ml jg mm mn dt translated">类型</h1><p id="2aee" class="pw-post-body-paragraph kc kd ht kf b kg mo iu ki kj mp ix kl lb mq ko kp lc mr ks kt ld ms kw kx ky hm dt translated">那么什么是订单簿呢？</p><p id="bb54" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">首先，我们将定义订单:</p><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="fa27" class="mx lx ht lh b fv my mz l na nb"><strong class="lh hu">import</strong> Data.Tagged<br/><strong class="lh hu">import</strong> <strong class="lh hu">qualified</strong> Data.Map <strong class="lh hu">as</strong> M<br/><strong class="lh hu">import</strong> <strong class="lh hu">qualified</strong> Data.Sequence <strong class="lh hu">as</strong> Q<br/><br/><strong class="lh hu">type</strong> <strong class="lh hu">UserId</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Integer</strong><br/><br/><strong class="lh hu">type</strong> <strong class="lh hu">Currency</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Text</strong><br/><strong class="lh hu">type</strong> <strong class="lh hu">CurrencyPair</strong> <strong class="lh hu">=</strong> (<strong class="lh hu">Currency</strong>, <strong class="lh hu">Currency</strong>)<br/><strong class="lh hu">type</strong> <strong class="lh hu">Amount</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Integer</strong><br/><strong class="lh hu">type</strong> <strong class="lh hu">Price</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Double</strong><br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">LimitOrder</strong> <strong class="lh hu">=</strong> <strong class="lh hu">LimitOrder</strong> {<br/>  _lorder_user         <strong class="lh hu">::</strong> <strong class="lh hu">UserId</strong>,<br/>  _lorder_fromAmount   <strong class="lh hu">::</strong> <strong class="lh hu">Amount</strong>,<br/>  _lorder_toAmount     <strong class="lh hu">::</strong> <strong class="lh hu">Amount</strong><br/>  } <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)<br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">TBid</strong><br/><strong class="lh hu">data</strong> <strong class="lh hu">TAsk</strong><br/><br/><strong class="lh hu">type</strong> <strong class="lh hu">BidT</strong> a <strong class="lh hu">=</strong> <strong class="lh hu">Tagged</strong> <strong class="lh hu">TBid</strong> a<br/><strong class="lh hu">type</strong> <strong class="lh hu">AskT</strong> a <strong class="lh hu">=</strong> <strong class="lh hu">Tagged</strong> <strong class="lh hu">TAsk</strong> a<br/><strong class="lh hu">type</strong> <strong class="lh hu">Bid</strong> <strong class="lh hu">=</strong> <strong class="lh hu">BidT</strong> <strong class="lh hu">LimitOrder</strong><br/><strong class="lh hu">type</strong> <strong class="lh hu">Ask</strong> <strong class="lh hu">=</strong> <strong class="lh hu">AskT</strong> <strong class="lh hu">LimitOrder</strong><br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">MarketOrder</strong> <strong class="lh hu">=</strong> <strong class="lh hu">MarketOrder</strong> {<br/>  _morder_user   <strong class="lh hu">::</strong> <strong class="lh hu">UserId</strong>,<br/>  _morder_amount <strong class="lh hu">::</strong> <strong class="lh hu">Amount</strong><br/>  } <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)<br/><br/><strong class="lh hu">type</strong> <strong class="lh hu">MBid</strong> <strong class="lh hu">=</strong> <strong class="lh hu">BidT</strong> <strong class="lh hu">MarketOrder</strong><br/><strong class="lh hu">type</strong> <strong class="lh hu">MAsk</strong> <strong class="lh hu">=</strong> <strong class="lh hu">AskT</strong> <strong class="lh hu">MarketOrder</strong><br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">OrderBookF</strong> a <strong class="lh hu">=</strong> <strong class="lh hu">OrderBook</strong> {<br/>  _book_fromCurrency <strong class="lh hu">::</strong> <strong class="lh hu">Currency</strong>,<br/>  _book_toCurrency   <strong class="lh hu">::</strong> <strong class="lh hu">Currency</strong>,<br/>  _book_bids         <strong class="lh hu">::</strong> <strong class="lh hu">M.Map</strong> <strong class="lh hu">Price</strong> (<strong class="lh hu">Q.Seq</strong> (<strong class="lh hu">BidT</strong> a)),<br/>  _book_asks         <strong class="lh hu">::</strong> <strong class="lh hu">M.Map</strong> <strong class="lh hu">Price</strong> (<strong class="lh hu">Q.Seq</strong> (<strong class="lh hu">AskT</strong> a))<br/>  } <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Functor</strong>, <strong class="lh hu">Traversable</strong>, <strong class="lh hu">Foldable</strong>)<br/><strong class="lh hu">type</strong> <strong class="lh hu">OrderBook</strong> <strong class="lh hu">=</strong> <strong class="lh hu">OrderBookF</strong> <strong class="lh hu">LimitOrder</strong></span></pre><p id="5d4b" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">有几点需要注意:</p><ul class=""><li id="2576" class="li lj ht kf b kg kh kj kk lb lk lc ll ld lm ky ln lo lp lq dt translated">我们使用<code class="eh le lf lg lh b">Seq</code>而不是<code class="eh le lf lg lh b">List</code>或<code class="eh le lf lg lh b">Vector</code>，因为我们需要相对高效的插入和搜索。</li><li id="2c8b" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">更高阶的<code class="eh le lf lg lh b">OrderBookF</code>让我们不用写任何代码就可以得到<code class="eh le lf lg lh b">Traversable</code>、<code class="eh le lf lg lh b">Functor</code>和<code class="eh le lf lg lh b">Foldable</code>实例来操作订单簿。</li><li id="1c84" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated"><code class="eh le lf lg lh b">Bid</code>和<code class="eh le lf lg lh b">Ask</code>都是<code class="eh le lf lg lh b">LimitOrder</code>的，但是我想在类型系统中单独跟踪它们。所以我使用<code class="eh le lf lg lh b">Tagged</code>来附加一个<code class="eh le lf lg lh b">TBid</code>或<code class="eh le lf lg lh b">TAsk</code>标签。</li></ul><p id="9742" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">仅仅有<code class="eh le lf lg lh b">OrderBook</code>是不够的，因为我们想要跟踪买家和卖家之间实际转移的最终金额。让我们为此添加一些类型:</p><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="4f02" class="mx lx ht lh b fv my mz l na nb"><strong class="lh hu">data</strong> <strong class="lh hu">SingleEntry</strong> <strong class="lh hu">=</strong> <strong class="lh hu">SingleEntry</strong> {<br/>  _se_account  <strong class="lh hu">::</strong> <strong class="lh hu">UserId</strong>,<br/>  _se_currency <strong class="lh hu">::</strong> <strong class="lh hu">Currency</strong>,<br/>  _se_amount   <strong class="lh hu">::</strong> <strong class="lh hu">Amount</strong><br/>  } <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)<br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">DoubleEntry</strong> <strong class="lh hu">=</strong> <strong class="lh hu">DoubleEntry</strong> {<br/>  _de_fromAccount <strong class="lh hu">::</strong> <strong class="lh hu">UserId</strong>,<br/>  _de_toAccount   <strong class="lh hu">::</strong> <strong class="lh hu">UserId</strong>,<br/>  _de_currency    <strong class="lh hu">::</strong> <strong class="lh hu">Currency</strong>,<br/>  _de_amount      <strong class="lh hu">::</strong> <strong class="lh hu">Amount</strong><br/>  } <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)<br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">TradeF</strong> a <strong class="lh hu">=</strong> <strong class="lh hu">Trade</strong> {<br/>  _trade_from <strong class="lh hu">::</strong> a,<br/>  _trade_to   <strong class="lh hu">::</strong> a<br/>  } <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Functor</strong>, <strong class="lh hu">Traversable</strong>, <strong class="lh hu">Foldable</strong>, <strong class="lh hu">Generic</strong>)<br/><strong class="lh hu">type</strong> <strong class="lh hu">Trade</strong> <strong class="lh hu">=</strong> <strong class="lh hu">TradeF</strong> <strong class="lh hu">DoubleEntry</strong><br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">External</strong><br/><strong class="lh hu">type</strong> <strong class="lh hu">ExternalTransfer</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Tagged</strong> <strong class="lh hu">External</strong> <strong class="lh hu">SingleEntry</strong></span></pre><p id="fa3d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">“执行”一个订单会导致它变成至少一个<code class="eh le lf lg lh b">Trade</code>。每当美元/BTC货币对出现<code class="eh le lf lg lh b">Trade</code>时，用户的余额会发生4种变化:</p><ul class=""><li id="99f4" class="li lj ht kf b kg kh kj kk lb lk lc ll ld lm ky ln lo lp lq dt translated">买家损失了他的美元</li><li id="a316" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">卖方获得美元</li><li id="fad0" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">买方获得BTC</li><li id="a137" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">卖家失去了BTC</li></ul><p id="1b85" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">在处理任何种类的资金时，使用“复式记账法”是很重要的。每当钱易手时，在双方都增加一个分录，就能更好地防止记账错误。内部转账时，美元和BTC的总额应为零和。</p><p id="0dc1" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">有些账户在我们的交易所之外，比如银行账户中的美元，或者钱包中的BTC。在本例中，我选择了从交易所的视图中删除外部帐户，这样对于交易所之外的转账，我们只有单一条目簿记。出于会计目的，应该有一个单独的数据库来保存完整的复式记账财务数据，并且应该定期与交易所、任何银行账户和任何钱包进行核对。</p><p id="fe09" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">管理员或计费代码可以在创建或销毁交换中的货币供应时创建<code class="eh le lf lg lh b">SingleEntry</code>记录，而所有用户将在彼此之间创建<code class="eh le lf lg lh b">DoubleEntry</code>记录。</p><p id="3b3a" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">最后，这是交换将保持的全局状态:</p><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="0c08" class="mx lx ht lh b fv my mz l na nb"><strong class="lh hu">data</strong> <strong class="lh hu">Exchange</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Exchange</strong> {<br/>  _exchange_external <strong class="lh hu">::</strong> <strong class="lh hu">TVar</strong> (<strong class="lh hu">Q.Seq</strong> <strong class="lh hu">ExternalTransfer</strong>),<br/>  _exchange_book     <strong class="lh hu">::</strong> <strong class="lh hu">TVar</strong> <strong class="lh hu">OrderBook</strong>,<br/>  _exchange_trades   <strong class="lh hu">::</strong> <strong class="lh hu">TVar</strong> (<strong class="lh hu">Q.Seq</strong> <strong class="lh hu">Trade</strong>)<br/>  }</span></pre><p id="e6a1" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">简而言之，一个<code class="eh le lf lg lh b">Exchange</code>是一个外部转移的集合，将资金移入和移出系统，是一个单一货币对的订单簿，装满了等待执行的订单，以及以前的交易历史。</p><p id="d67d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">这个交易所没有交易费。这些将会是<code class="eh le lf lg lh b">Trade</code>或<code class="eh le lf lg lh b">External</code>类型，这取决于我们是对内部还是外部转移收费。</p><h1 id="8b53" class="lw lx ht bd ly lz ma mb mc md me mf mg iz mh ja mi jc mj jd mk jf ml jg mm mn dt translated">定货簿</h1><p id="8d86" class="pw-post-body-paragraph kc kd ht kf b kg mo iu ki kj mp ix kl lb mq ko kp lc mr ks kt ld ms kw kx ky hm dt translated">使用我们的订单簿需要哪些基本操作？我们希望:</p><ul class=""><li id="a2b3" class="li lj ht kf b kg kh kj kk lb lk lc ll ld lm ky ln lo lp lq dt translated">在账簿中添加订单，如果可以的话，自动执行交易。</li><li id="df60" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">取消订单</li><li id="c0f3" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">在订单簿上列出所有未完成的订单</li></ul><p id="f58d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">一旦我们有了这些，我们将把它包装在一个HTTP API中，脚本或网站可以使用它来与订单簿进行交互。</p><p id="821e" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">我现在只看<code class="eh le lf lg lh b">Bid</code>限价和市价单<code class="eh le lf lg lh b">Ask</code>版本非常相似。以下是我们需要的函数类型:</p><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="fe55" class="mx lx ht lh b fv my mz l na nb">cancelBid <strong class="lh hu">::</strong> <strong class="lh hu">Bid</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">OrderBook</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">OrderBook</strong><br/>fillBid <strong class="lh hu">::</strong> <strong class="lh hu">Bid</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">OrderBook</strong> <strong class="lh hu">-&gt;</strong> ([<strong class="lh hu">Trade</strong>], <strong class="lh hu">OrderBook</strong>)<br/>tryFillMBid <strong class="lh hu">::</strong> <strong class="lh hu">MBid</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">Balances</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">OrderBook</strong> <strong class="lh hu">-&gt;</strong> (<strong class="lh hu">Maybe</strong> <strong class="lh hu">MBid</strong>, [<strong class="lh hu">Trade</strong>], <strong class="lh hu">OrderBook</strong>)<br/>listOrders <strong class="lh hu">::</strong> <strong class="lh hu">OrderBook</strong> <strong class="lh hu">-&gt;</strong> [<strong class="lh hu">LimitOrder</strong>]<br/>listOrders <strong class="lh hu">=</strong> toList</span></pre><p id="84e8" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">因为生成的<code class="eh le lf lg lh b">Foldable</code>实例为我们做了<code class="eh le lf lg lh b">listOrders</code>，所以我继续并实现了它。我将把<code class="eh le lf lg lh b">cancelBid</code>的实现留在<a class="ae jy" href="https://github.com/MichaelBurge/lambda-exchange" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p><p id="f433" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">对于<code class="eh le lf lg lh b">fillBid</code>和<code class="eh le lf lg lh b">tryFillMBid</code>，我们将为限价订单编写一个合适的通用函数，并假设<code class="eh le lf lg lh b">MarketOrder</code>是一个不能保存在订单簿中的<code class="eh le lf lg lh b">LimitOrder</code>，用户在这里对其整个账户余额进行竞价:</p><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="a5d9" class="mx lx ht lh b fv my mz l na nb">fillBid <strong class="lh hu">::</strong> <strong class="lh hu">Bid</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">OrderBook</strong> <strong class="lh hu">-&gt;</strong> ([<strong class="lh hu">Trade</strong>], <strong class="lh hu">OrderBook</strong>)<br/>fillBid bid book <strong class="lh hu">=</strong> <strong class="lh hu">case</strong> matchBid bid book <strong class="lh hu">of</strong><br/>  (<strong class="lh hu">Nothing</strong>, trades, book) <strong class="lh hu">-&gt;</strong><br/>    (trades, book)<br/>  (<strong class="lh hu">Just</strong> bidRemainder, trades, book) <strong class="lh hu">-&gt;</strong><br/>    (trades, unsafe_addBid bidRemainder book)<br/><br/>tryFillMBid <strong class="lh hu">::</strong> <strong class="lh hu">MBid</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">Balances</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">OrderBook</strong> <strong class="lh hu">-&gt;</strong> (<strong class="lh hu">Maybe</strong> <strong class="lh hu">MBid</strong>, [<strong class="lh hu">Trade</strong>], <strong class="lh hu">OrderBook</strong>)<br/>tryFillMBid mbid bals book<strong class="lh hu">@OrderBook</strong>{<strong class="lh hu">..</strong>} <strong class="lh hu">=</strong><br/>  <strong class="lh hu">case</strong> <strong class="lh hu">M.</strong>lookup _book_toCurrency bals <strong class="lh hu">of</strong><br/>    <strong class="lh hu">Nothing</strong> <strong class="lh hu">-&gt;</strong> (<strong class="lh hu">Nothing</strong>, <strong class="lh hu">[]</strong>, book)<br/>    <strong class="lh hu">Just</strong> toBalance <strong class="lh hu">-&gt;</strong><br/>      <em class="ke">-- A Market order is a non-persistable limit order with the user bidding his entire balance.</em><br/>      <strong class="lh hu">let</strong> (<strong class="lh hu">Tagged</strong> <strong class="lh hu">MarketOrder</strong>{<strong class="lh hu">..</strong>}) <strong class="lh hu">=</strong> mbid<br/>          bid <strong class="lh hu">=</strong> <strong class="lh hu">Tagged</strong> <strong class="lh hu">$</strong> <strong class="lh hu">LimitOrder</strong> {<br/>            _lorder_user <strong class="lh hu">=</strong> _morder_user,<br/>            _lorder_fromAmount <strong class="lh hu">=</strong> _morder_amount,<br/>            _lorder_toAmount <strong class="lh hu">=</strong> toBalance<br/>            }<br/>      <strong class="lh hu">in</strong> <strong class="lh hu">case</strong> matchBid bid book <strong class="lh hu">of</strong><br/>        (<strong class="lh hu">Nothing</strong>, trades, book) <strong class="lh hu">-&gt;</strong><br/>          (<strong class="lh hu">Nothing</strong>, trades, book)<br/>        (<strong class="lh hu">Just</strong> bid, trades, book) <strong class="lh hu">-&gt;</strong><br/>          (<strong class="lh hu">Just</strong> <strong class="lh hu">$</strong> bidToMbid bid, trades, book)<br/><br/>bidToMBid <strong class="lh hu">::</strong> <strong class="lh hu">Bid</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">MBid</strong><br/>unsafe_addBid <strong class="lh hu">::</strong> <strong class="lh hu">Ask</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">OrderBook</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">OrderBook</strong></span></pre><p id="865b" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">我们的通用<code class="eh le lf lg lh b">matchBid</code>函数试图在<code class="eh le lf lg lh b">OrderBook</code>上填充一个限价单，并返回一个新的<code class="eh le lf lg lh b">Bid</code>，用于任何无法匹配的、任何已执行的<code class="eh le lf lg lh b">Trade</code>，以及新的<code class="eh le lf lg lh b">OrderBook</code>:</p><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="65ce" class="mx lx ht lh b fv my mz l na nb">matchBid <strong class="lh hu">::</strong> <strong class="lh hu">Bid</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">OrderBook</strong> <strong class="lh hu">-&gt;</strong> (<strong class="lh hu">Maybe</strong> <strong class="lh hu">Bid</strong>, [<strong class="lh hu">Trade</strong>], <strong class="lh hu">OrderBook</strong>)<br/>matchBid bid book <strong class="lh hu">=</strong><br/>  <strong class="lh hu">let</strong> pair <strong class="lh hu">=</strong> _book_pair book<br/>      loop <strong class="lh hu">::</strong> (<strong class="lh hu">Bid</strong>, [<strong class="lh hu">Trade</strong>], <strong class="lh hu">OrderBook</strong>) <strong class="lh hu">-&gt;</strong> (<strong class="lh hu">Maybe</strong> <strong class="lh hu">Bid</strong>, [<strong class="lh hu">Trade</strong>], <strong class="lh hu">OrderBook</strong>)<br/>      loop x<strong class="lh hu">@</strong>(bid, trades, book) <strong class="lh hu">=</strong><br/>        <strong class="lh hu">case</strong> lowestAsk book <strong class="lh hu">of</strong><br/>          <em class="ke">-- Case 1: The order book has no asks</em><br/>          (<strong class="lh hu">Nothing</strong>, <strong class="lh hu">_</strong>) <strong class="lh hu">-&gt;</strong> (<strong class="lh hu">Just</strong> bid, <strong class="lh hu">[]</strong>, book)<br/>          (<strong class="lh hu">Just</strong> lowestAsk, deletedBook) <strong class="lh hu">-&gt;</strong><br/>            <strong class="lh hu">case</strong> mergeBid pair bid lowestAsk <strong class="lh hu">of</strong><br/>              <em class="ke">-- Case 2: The bid was unable to be matched</em><br/>              (<strong class="lh hu">Just</strong> bid, <strong class="lh hu">Just</strong> <strong class="lh hu">_</strong>, <strong class="lh hu">Nothing</strong>) <strong class="lh hu">-&gt;</strong> (<strong class="lh hu">Just</strong> bid, trades,book)<br/>              <em class="ke">-- Case 3: The bid was partially matched; repeat the loop</em><br/>              (<strong class="lh hu">Just</strong> bidRemainder, <strong class="lh hu">Nothing</strong>, <strong class="lh hu">Just</strong> trade) <strong class="lh hu">-&gt;</strong><br/>                loop (bidRemainder, trade<strong class="lh hu">:</strong>trades, deletedBook)<br/>              <em class="ke">-- Case 4: The ask was partially matched; terminate the loop.</em><br/>              (<strong class="lh hu">Nothing</strong>, <strong class="lh hu">Just</strong> askRemainder, <strong class="lh hu">Just</strong> trade) <strong class="lh hu">-&gt;</strong><br/>                (<strong class="lh hu">Nothing</strong>, trade<strong class="lh hu">:</strong>trades, unsafe_addAsk askRemainder deletedBook)<br/>              <em class="ke">-- Case 5: The bid and ask exactly canceled each other out</em><br/>              (<strong class="lh hu">Nothing</strong>, <strong class="lh hu">Nothing</strong>, <strong class="lh hu">Just</strong> trade) <strong class="lh hu">-&gt;</strong><br/>                (<strong class="lh hu">Nothing</strong>, trade<strong class="lh hu">:</strong>trades, deletedBook)<br/>              <em class="ke">-- Case 6: Impossible cases</em><br/>              x <strong class="lh hu">-&gt;</strong> panic <strong class="lh hu">$</strong> "fillBid: Unexpected case: " <strong class="lh hu">&lt;&gt;</strong> show x<br/>  <strong class="lh hu">in</strong> loop (bid, <strong class="lh hu">[]</strong>, book)<br/><br/>mergeBid <strong class="lh hu">::</strong> <strong class="lh hu">CurrencyPair</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">Bid</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">Ask</strong> <strong class="lh hu">-&gt;</strong> (<strong class="lh hu">Maybe</strong> <strong class="lh hu">Bid</strong>, <strong class="lh hu">Maybe</strong> <strong class="lh hu">Ask</strong>, <strong class="lh hu">Maybe</strong> <strong class="lh hu">Trade</strong>)<br/><br/>lowestAsk <strong class="lh hu">::</strong> <strong class="lh hu">OrderBook</strong> <strong class="lh hu">-&gt;</strong> (<strong class="lh hu">Maybe</strong> <strong class="lh hu">Ask</strong>, <strong class="lh hu">OrderBook</strong>)<br/><br/>unsafe_addAsk <strong class="lh hu">::</strong> <strong class="lh hu">Ask</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">OrderBook</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">OrderBook</strong></span></pre><p id="760c" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">在这里，我们反复寻找订单簿上的最佳价格<code class="eh le lf lg lh b">Ask</code>，用它来填充我们的<code class="eh le lf lg lh b">Bid</code>，当我们用完合格的<code class="eh le lf lg lh b">Ask</code>时就停止。</p><p id="ab14" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><code class="eh le lf lg lh b">lowestAsk</code>很简单，因为我们的<code class="eh le lf lg lh b">Map</code>是按照<code class="eh le lf lg lh b">price</code>排序的。我将在<a class="ae jy" href="https://github.com/MichaelBurge/lambda-exchange" rel="noopener ugc nofollow" target="_blank"> Github </a>库中定义它和<code class="eh le lf lg lh b">unsafe_addAsk</code>。</p><p id="ea22" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><code class="eh le lf lg lh b">mergeBid</code>可能是最复杂的，因为它处理3件不同的事情:</p><ul class=""><li id="40f0" class="li lj ht kf b kg kh kj kk lb lk lc ll ld lm ky ln lo lp lq dt translated">如果出价或要价被部分满足，它将生成新订单</li><li id="812a" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">如果买价和卖价交叉，就会产生交易</li><li id="e448" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">它处理决定这些的计算</li></ul><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="8de6" class="mx lx ht lh b fv my mz l na nb">mergeBid <strong class="lh hu">::</strong> <strong class="lh hu">CurrencyPair</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">Bid</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">Ask</strong> <strong class="lh hu">-&gt;</strong> (<strong class="lh hu">Maybe</strong> <strong class="lh hu">Bid</strong>, <strong class="lh hu">Maybe</strong> <strong class="lh hu">Ask</strong>, <strong class="lh hu">Maybe</strong> <strong class="lh hu">Trade</strong>)<br/>mergeBid (fromCurrency, toCurrency) bid ask <strong class="lh hu">=</strong><br/>  <strong class="lh hu">let</strong> bidOrder <strong class="lh hu">=</strong> unTagged bid<br/>      askOrder <strong class="lh hu">=</strong> unTagged ask<br/>      n1 <strong class="lh hu">=</strong> _lorder_fromAmount bidOrder<br/>      d1 <strong class="lh hu">=</strong> _lorder_toAmount bidOrder<br/>      n2 <strong class="lh hu">=</strong> negate <strong class="lh hu">$</strong> _lorder_fromAmount askOrder<br/>      d2 <strong class="lh hu">=</strong> _lorder_toAmount askOrder<br/>      buyer <strong class="lh hu">=</strong> _lorder_user bidOrder<br/>      seller <strong class="lh hu">=</strong> _lorder_user askOrder<br/>      fi <strong class="lh hu">=</strong> fromIntegral<br/>      <em class="ke">-- If seller rounds down, price would be below his limit.</em><br/>      sellerPrice <strong class="lh hu">=</strong> ceiling (fi n2 <strong class="lh hu">/</strong> fi d2)<br/>      <em class="ke">-- If buyer rounds up, price would be above his limit.</em><br/>      buyerPrice <strong class="lh hu">=</strong> floor (fi n1 <strong class="lh hu">/</strong> fi d1)<br/><br/>      unitPrice <strong class="lh hu">=</strong> buyerPrice<br/>      numUnits <strong class="lh hu">=</strong> min n1 n2<br/>      toAmount <strong class="lh hu">=</strong> ceiling (fi numUnits <strong class="lh hu">/</strong> fi unitPrice)<br/>      fromTransfer <strong class="lh hu">=</strong> <strong class="lh hu">DoubleEntry</strong> {<br/>        _de_fromAccount <strong class="lh hu">=</strong> seller,<br/>        _de_toAccount   <strong class="lh hu">=</strong> buyer,<br/>        _de_amount      <strong class="lh hu">=</strong> numUnits,<br/>        _de_currency    <strong class="lh hu">=</strong> fromCurrency<br/>        }<br/>      toTransfer <strong class="lh hu">=</strong> <strong class="lh hu">DoubleEntry</strong> {<br/>        _de_fromAccount <strong class="lh hu">=</strong> buyer,<br/>        _de_toAccount   <strong class="lh hu">=</strong> seller,<br/>        _de_amount      <strong class="lh hu">=</strong> toAmount,<br/>        _de_currency    <strong class="lh hu">=</strong> toCurrency<br/>        }<br/>      trade <strong class="lh hu">=</strong> <strong class="lh hu">Trade</strong> fromTransfer toTransfer<br/>      (mNewBid, mNewAsk) <strong class="lh hu">=</strong> <strong class="lh hu">case</strong> d1 `compare` d2 <strong class="lh hu">of</strong><br/>        <em class="ke">-- Case 1: Buyer is done; seller still has inventory</em><br/>        <strong class="lh hu">LT</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">let</strong> newAsk <strong class="lh hu">=</strong> <strong class="lh hu">Tagged</strong> <strong class="lh hu">$</strong> <strong class="lh hu">LimitOrder</strong> {<br/>                    _lorder_user       <strong class="lh hu">=</strong> seller,<br/>                    _lorder_fromAmount <strong class="lh hu">=</strong> n2 <strong class="lh hu">-</strong> numUnits,<br/>                    _lorder_toAmount   <strong class="lh hu">=</strong> sellerPrice<br/>                    }<br/>              <strong class="lh hu">in</strong> (<strong class="lh hu">Nothing</strong>, <strong class="lh hu">Just</strong> newAsk)<br/>        <em class="ke">-- Case 2: Seller is out; buyer needs more</em><br/>        <strong class="lh hu">GT</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">let</strong> newBid <strong class="lh hu">=</strong> <strong class="lh hu">Tagged</strong> <strong class="lh hu">$</strong> <strong class="lh hu">LimitOrder</strong> {<br/>                    _lorder_user       <strong class="lh hu">=</strong> buyer,<br/>                    _lorder_fromAmount <strong class="lh hu">=</strong> n1 <strong class="lh hu">-</strong> numUnits,<br/>                    _lorder_toAmount   <strong class="lh hu">=</strong> buyerPrice<br/>                    }<br/>              <strong class="lh hu">in</strong> (<strong class="lh hu">Just</strong> newBid, <strong class="lh hu">Nothing</strong>)<br/>        <em class="ke">-- Case 3: Buyer and seller exactly traded</em><br/>        <strong class="lh hu">EQ</strong> <strong class="lh hu">-&gt;</strong> (<strong class="lh hu">Nothing</strong>, <strong class="lh hu">Nothing</strong>)<br/>  <strong class="lh hu">in</strong> <strong class="lh hu">if</strong> buyerPrice <strong class="lh hu">&gt;=</strong> sellerPrice<br/>     <em class="ke">-- Bid has crossed the ask, so we can generate a trade.</em><br/>     <strong class="lh hu">then</strong> (mNewBid, mNewAsk, <strong class="lh hu">Just</strong> trade)<br/>     <em class="ke">-- Bid is less than ask, so they can't be merged.</em><br/>     <strong class="lh hu">else</strong> (<strong class="lh hu">Just</strong> bid, <strong class="lh hu">Just</strong> ask, <strong class="lh hu">Nothing</strong>)</span></pre><p id="0c3c" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><code class="eh le lf lg lh b">mergeBid</code>非常微妙，以至于你可能不放心仅仅基于视觉检查来信任它的实现。在下一节中，我们将在每次写入时安装自动化的健全性检查，以便阻止任何实现错误。</p><h1 id="e4f7" class="lw lx ht bd ly lz ma mb mc md me mf mg iz mh ja mi jc mj jd mk jf ml jg mm mn dt translated">安全性</h1><p id="6ba4" class="pw-post-body-paragraph kc kd ht kf b kg mo iu ki kj mp ix kl lb mq ko kp lc mr ks kt ld ms kw kx ky hm dt translated">当我们不可避免地被黑客攻击时，我们如何阻止我们的交易所亏损？</p><p id="2971" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">最重要的是确保我们交易所拥有的比特币或以太币钱包的安全。幸运的是，我们没有钱包，避免了这个问题。</p><p id="50cf" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">第二件最重要的事情是拥有仅附加备份，如果我们检测到黑客攻击，我们可以回滚到该备份。这并不理想，因为我们仍然必须告诉我们所有的客户我们被黑了。</p><p id="47b9" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">第三件最重要的事情是首先要避免损失这笔钱。</p><p id="b0f6" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">在我的上一篇文章中，我展示了如何使用定理证明器来正式证明关于你的数据结构的某些属性成立。我们不能在Haskell中做到这一点，但是让我为你定义几个不变量，我将向你展示一个技巧。</p><h1 id="c4e0" class="lw lx ht bd ly lz ma mb mc md me mf mg iz mh ja mi jc mj jd mk jf ml jg mm mn dt translated">不变量</h1><p id="6428" class="pw-post-body-paragraph kc kd ht kf b kg mo iu ki kj mp ix kl lb mq ko kp lc mr ks kt ld ms kw kx ky hm dt translated">以下是我们的词汇不变量:</p><ul class=""><li id="5b60" class="li lj ht kf b kg kh kj kk lb lk lc ll ld lm ky ln lo lp lq dt translated">用户不能和自己交易</li><li id="391d" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">用户不能有负余额</li><li id="d75d" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">用户在未决交易中的资金不能超过他们账户中的资金。</li><li id="3786" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">用户和订单簿不能有不存在的货币</li></ul><p id="f97b" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">这是他们的代码:</p><ul class=""><li id="7a46" class="li lj ht kf b kg kh kj kk lb lk lc ll ld lm ky ln lo lp lq dt translated">s不能与自己交易</li></ul><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="f236" class="mx lx ht lh b fv my mz l na nb"><strong class="lh hu">type</strong> <strong class="lh hu">ConsistencyCheck</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Exchange</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">STM</strong> <strong class="lh hu">Bool</strong><br/><br/>consistency_noSelfTrades <strong class="lh hu">::</strong> <strong class="lh hu">ConsistencyCheck</strong><br/>consistency_noSelfTrades <strong class="lh hu">=</strong> <strong class="lh hu">\</strong>exchange <strong class="lh hu">-&gt;</strong> <strong class="lh hu">do</strong><br/>  trades <strong class="lh hu">&lt;-</strong> readTVar <strong class="lh hu">$</strong> _exchange_trades exchange<br/>  return <strong class="lh hu">$</strong> all checkTrade trades<br/>  <strong class="lh hu">where</strong><br/>    checkDe <strong class="lh hu">DoubleEntry</strong>{<strong class="lh hu">..</strong>} <strong class="lh hu">=</strong> _de_fromAccount <strong class="lh hu">/=</strong> _de_toAccount<br/>    checkTrade <strong class="lh hu">Trade</strong>{<strong class="lh hu">..</strong>} <strong class="lh hu">=</strong> checkDe _trade_from <strong class="lh hu">&amp;&amp;</strong> checkDe _trade_to</span></pre><ul class=""><li id="7950" class="li lj ht kf b kg kh kj kk lb lk lc ll ld lm ky ln lo lp lq dt translated">用户不能有负余额</li></ul><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="8f70" class="mx lx ht lh b fv my mz l na nb">consistency_noNegativeBalances <strong class="lh hu">::</strong> <strong class="lh hu">ConsistencyCheck</strong><br/>consistency_noNegativeBalances <strong class="lh hu">=</strong> <strong class="lh hu">\</strong>exchange <strong class="lh hu">-&gt;</strong> <strong class="lh hu">do</strong><br/>  bals <strong class="lh hu">&lt;-</strong> userBalances exchange<br/>  <strong class="lh hu">let</strong> checkUser (userId, balances) <strong class="lh hu">=</strong><br/>        flip all (<strong class="lh hu">M.</strong>toList balances) <strong class="lh hu">$</strong> <strong class="lh hu">\</strong>(currency, balance) <strong class="lh hu">-&gt;</strong><br/>        <strong class="lh hu">if</strong> balance <strong class="lh hu">&gt;=</strong> 0<br/>        <strong class="lh hu">then</strong> <strong class="lh hu">True</strong><br/>        <strong class="lh hu">else</strong> <strong class="lh hu">error</strong> <strong class="lh hu">$</strong> "Negative balance for " <strong class="lh hu">&lt;&gt;</strong> show (userId, currency, balance)<br/>  return <strong class="lh hu">$</strong> all checkUser <strong class="lh hu">$</strong> <strong class="lh hu">M.</strong>toList bals<br/><br/>userBalances <strong class="lh hu">::</strong> <strong class="lh hu">Exchange</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">STM</strong> (<strong class="lh hu">M.Map</strong> <strong class="lh hu">UserId</strong> <strong class="lh hu">Balances</strong>)<br/>userBalances <strong class="lh hu">=</strong> undefined</span></pre><ul class=""><li id="1e32" class="li lj ht kf b kg kh kj kk lb lk lc ll ld lm ky ln lo lp lq dt translated">用户在未决交易中的资金不能超过他们账户中的资金。</li></ul><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="0bb4" class="mx lx ht lh b fv my mz l na nb">consistency_ordersBackedByAccount <strong class="lh hu">::</strong> <strong class="lh hu">ConsistencyCheck</strong><br/>consistency_ordersBackedByAccount <strong class="lh hu">=</strong> <strong class="lh hu">\</strong>exchange <strong class="lh hu">-&gt;</strong> <strong class="lh hu">do</strong><br/>  usersBals <strong class="lh hu">&lt;-</strong> userBalances exchange<br/><br/>  <strong class="lh hu">let</strong> checkUserBalance <strong class="lh hu">::</strong> <strong class="lh hu">Balances</strong> <strong class="lh hu">-&gt;</strong> (<strong class="lh hu">Currency</strong>, <strong class="lh hu">Amount</strong>) <strong class="lh hu">-&gt;</strong> <strong class="lh hu">Bool</strong><br/>      checkUserBalance userBals (currency, bookAmount) <strong class="lh hu">=</strong><br/>        <strong class="lh hu">case</strong> <strong class="lh hu">M.</strong>lookup currency userBals <strong class="lh hu">of</strong><br/>          <strong class="lh hu">Nothing</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">False</strong><br/>          <strong class="lh hu">Just</strong> userAmount <strong class="lh hu">-&gt;</strong> userAmount <strong class="lh hu">&gt;=</strong> bookAmount<br/><br/>  <strong class="lh hu">let</strong> checkUser <strong class="lh hu">::</strong> (<strong class="lh hu">UserId</strong>, <strong class="lh hu">Balances</strong>) <strong class="lh hu">-&gt;</strong> <strong class="lh hu">STM</strong> <strong class="lh hu">Bool</strong><br/>      checkUser (user, userBals) <strong class="lh hu">=</strong> <strong class="lh hu">do</strong><br/>        bookBals <strong class="lh hu">&lt;-</strong> userBookBalances exchange user<br/>        <strong class="lh hu">let</strong> currenciesPending <strong class="lh hu">=</strong> <strong class="lh hu">M.</strong>toList bookBals<br/>        return <strong class="lh hu">$</strong> all (checkUserBalance userBals) currenciesPending<br/>  allM checkUser <strong class="lh hu">$</strong> <strong class="lh hu">M.</strong>toList usersBals<br/><br/>userBookBalances <strong class="lh hu">::</strong> <strong class="lh hu">Exchange</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">UserId</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">STM</strong> <strong class="lh hu">Balances</strong><br/>userBookBalances <strong class="lh hu">=</strong> undefined</span></pre><ul class=""><li id="8dc5" class="li lj ht kf b kg kh kj kk lb lk lc ll ld lm ky ln lo lp lq dt translated"><code class="eh le lf lg lh b">User</code> s和<code class="eh le lf lg lh b">OrderBook</code> s不能有不存在的货币</li></ul><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="3ed0" class="mx lx ht lh b fv my mz l na nb">consistency_allCurrenciesExist <strong class="lh hu">::</strong> <strong class="lh hu">ConsistencyCheck</strong><br/>consistency_allCurrenciesExist <strong class="lh hu">=</strong> <strong class="lh hu">\</strong>exchange <strong class="lh hu">-&gt;</strong> <strong class="lh hu">do</strong><br/>  usersBals <strong class="lh hu">&lt;-</strong> userBalances exchange<br/>  bookBals <strong class="lh hu">&lt;-</strong> bookBalances exchange<br/>  <strong class="lh hu">let</strong> valid currency <strong class="lh hu">=</strong> currency `elem` allCurrencies<br/>      checkBals bals <strong class="lh hu">=</strong> all valid <strong class="lh hu">$</strong> <strong class="lh hu">M.</strong>keys bals<br/>      usersCheck <strong class="lh hu">=</strong> all checkBals usersBals<br/>      booksCheck <strong class="lh hu">=</strong> all valid <strong class="lh hu">$</strong> <strong class="lh hu">M.</strong>keys bookBals<br/>  return <strong class="lh hu">$</strong> usersCheck <strong class="lh hu">&amp;&amp;</strong> booksCheck<br/><br/>bookBalances <strong class="lh hu">::</strong> <strong class="lh hu">Exchange</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">STM</strong> <strong class="lh hu">Balances</strong><br/>bookBalances <strong class="lh hu">=</strong> undefined</span></pre><p id="b192" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">只要这些函数总是返回true，我们就可以对剩下的代码有一些信心。</p><p id="8119" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><code class="eh le lf lg lh b">userBalances</code>、<code class="eh le lf lg lh b">bookBalances</code>、<code class="eh le lf lg lh b">userBookBalances</code>汇总交易和对外转账，得到最终余额。我将把它们的实现放在<a class="ae jy" href="https://github.com/MichaelBurge/lambda-exchange" rel="noopener ugc nofollow" target="_blank"> Github </a>库中。</p><h1 id="2ab4" class="lw lx ht bd ly lz ma mb mc md me mf mg iz mh ja mi jc mj jd mk jf ml jg mm mn dt translated">诀窍是</h1><p id="64f9" class="pw-post-body-paragraph kc kd ht kf b kg mo iu ki kj mp ix kl lb mq ko kp lc mr ks kt ld ms kw kx ky hm dt translated">人们经常在关系数据库中使用触发器或约束来自动执行不变量。使用Haskell的软件事务内存库，我们可以做一些类似的事情:</p><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="fa18" class="mx lx ht lh b fv my mz l na nb">installSanityChecks <strong class="lh hu">::</strong> <strong class="lh hu">Exchange</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">IO</strong> ()<br/>installSanityChecks exchange <strong class="lh hu">=</strong><br/>  atomically <strong class="lh hu">$</strong> mapM_ installCheck [<br/>    (consistency_noNegativeBalances, "No negative balances"),<br/>    (consistency_ordersBackedByAccount, "Orders must be backed by account"),<br/>    (consistency_allCurrenciesExist, "Non-existent currency"),<br/>    (consistency_noSelfTrades, "Users cannot trade with themselves")<br/>    ]<br/>  <strong class="lh hu">where</strong><br/>    installCheck (check, message) <strong class="lh hu">=</strong> alwaysSucceeds <strong class="lh hu">$</strong> <strong class="lh hu">do</strong><br/>      b <strong class="lh hu">&lt;-</strong> check exchange<br/>      <strong class="lh hu">if</strong> b<br/>        <strong class="lh hu">then</strong> return ()<br/>        <strong class="lh hu">else</strong> <strong class="lh hu">error</strong> message</span></pre><p id="105f" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><code class="eh le lf lg lh b">atomically</code>进入<code class="eh le lf lg lh b">STM</code>意义上的“交易”。它被设计成一种允许多个线程并发更新共享数据结构的有效方式。如果存在对同一变量的并发更新，事务可以中止并重试。如果我们的一个健全性检查失败，我们也可以中止。</p><p id="7fa7" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><code class="eh le lf lg lh b">alwaysSucceed</code>函数将运行一次健全性检查，如果通过，则在以后的每个事务之后运行它。如果健全性检查因异常而失败，它将回滚有异常的事务。</p><p id="b81d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">在初始化或加载我们的交换状态之后，我们将在程序开始时调用<code class="eh le lf lg lh b">installSanityChecks</code>。那么每一次写操作都将被自动地进行完整性检查，并在出现异常的情况下回滚。我们的HTTP库<code class="eh le lf lg lh b">warp</code>将捕获异常并中止请求。</p><h1 id="0f14" class="lw lx ht bd ly lz ma mb mc md me mf mg iz mh ja mi jc mj jd mk jf ml jg mm mn dt translated">建立工作关系网</h1><p id="3100" class="pw-post-body-paragraph kc kd ht kf b kg mo iu ki kj mp ix kl lb mq ko kp lc mr ks kt ld ms kw kx ky hm dt translated">我们需要5个API端点:</p><ul class=""><li id="8639" class="li lj ht kf b kg kh kj kk lb lk lc ll ld lm ky ln lo lp lq dt translated">列出订单</li><li id="b19d" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">取消订单</li><li id="d70f" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">添加订单</li><li id="e683" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">在交易所创造货币</li><li id="bd3b" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">列出余额</li></ul><p id="c0d6" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">以下是请求类型:</p><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="1bcc" class="mx lx ht lh b fv my mz l na nb"><strong class="lh hu">data</strong> <strong class="lh hu">Request_ListOrders</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Request_ListOrders</strong> {<br/>  _reqListOrders_user <strong class="lh hu">::</strong> <strong class="lh hu">Maybe</strong> <strong class="lh hu">UserId</strong><br/>  } <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)<br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">Request_CancelOrder</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Request_CancelBid</strong> {<br/>  _reqCancelOrder_bid <strong class="lh hu">::</strong> <strong class="lh hu">Bid</strong><br/>  } <strong class="lh hu">|</strong> <strong class="lh hu">Request_CancelAsk</strong> {<br/>  _reqCancelOrder_ask <strong class="lh hu">::</strong> <strong class="lh hu">Ask</strong><br/>  } <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)<br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">Request_AddOrder</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Request_AddBid</strong> {<br/>  _reqAddOrder_bid <strong class="lh hu">::</strong> <strong class="lh hu">Bid</strong><br/>  } <strong class="lh hu">|</strong> <strong class="lh hu">Request_AddAsk</strong> {<br/>  _reqAddOrder_ask <strong class="lh hu">::</strong> <strong class="lh hu">Ask</strong><br/>  } <strong class="lh hu">|</strong> <strong class="lh hu">Request_AddMBid</strong> {<br/>  _reqAddOrder_mbid <strong class="lh hu">::</strong> <strong class="lh hu">MBid</strong><br/>  } <strong class="lh hu">|</strong> <strong class="lh hu">Request_AddMAsk</strong> {<br/>  _reqAddOrder_mask <strong class="lh hu">::</strong> <strong class="lh hu">MAsk</strong><br/>  } <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)<br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">Request_CreateMoney</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Request_CreateMoney</strong> {<br/>  _reqCreateMoney_singleEntry <strong class="lh hu">::</strong> <strong class="lh hu">SingleEntry</strong><br/>  } <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)<br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">Request_ListBalances</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Request_ListBalances</strong> <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)</span></pre><p id="c148" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">和响应类型:</p><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="6578" class="mx lx ht lh b fv my mz l na nb"><strong class="lh hu">data</strong> <strong class="lh hu">Response_ListOrders</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Response_ListOrders</strong> {<br/>  _resListOrders_orders <strong class="lh hu">::</strong> [<strong class="lh hu">LimitOrder</strong>]<br/>  } <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)<br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">Response_CancelOrder</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Response_CancelOrder</strong> <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)<br/><strong class="lh hu">data</strong> <strong class="lh hu">Response_AddOrder</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Response_AddBid</strong> {<br/>  _resAddOrder_trades <strong class="lh hu">::</strong> [<strong class="lh hu">Trade</strong>]  <br/>  } <strong class="lh hu">|</strong> <strong class="lh hu">Response_AddAsk</strong> {<br/>  _resAddOrder_trades <strong class="lh hu">::</strong> [<strong class="lh hu">Trade</strong>]<br/>  } <strong class="lh hu">|</strong> <strong class="lh hu">Response_AddMBid</strong> {<br/>  _resAddOrder_mbidRemainder <strong class="lh hu">::</strong> <strong class="lh hu">Maybe</strong> <strong class="lh hu">MBid</strong>,<br/>  _resAddOrder_trades        <strong class="lh hu">::</strong> [<strong class="lh hu">Trade</strong>]<br/>  } <strong class="lh hu">|</strong> <strong class="lh hu">Response_AddMAsk</strong> {<br/>  _resAddOrder_maskRemainder <strong class="lh hu">::</strong> <strong class="lh hu">Maybe</strong> <strong class="lh hu">MAsk</strong>,<br/>  _resAddOrder_trades        <strong class="lh hu">::</strong> [<strong class="lh hu">Trade</strong>]<br/>  } <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)<br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">Response_CreateMoney</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Response_CreateMoney</strong> <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)<br/><br/><strong class="lh hu">data</strong> <strong class="lh hu">Response_ListBalances</strong> <strong class="lh hu">=</strong> <strong class="lh hu">Response_ListBalances</strong> {<br/>  _resListBalances_externals <strong class="lh hu">::</strong> [(<strong class="lh hu">UserId</strong>, <strong class="lh hu">Currency</strong>, <strong class="lh hu">Amount</strong>)],<br/>  _resListBalances_internals <strong class="lh hu">::</strong> [(<strong class="lh hu">UserId</strong>, <strong class="lh hu">Currency</strong>, <strong class="lh hu">Amount</strong>)],<br/>  _resListBalances_helds     <strong class="lh hu">::</strong> [(<strong class="lh hu">UserId</strong>, <strong class="lh hu">Currency</strong>, <strong class="lh hu">Amount</strong>)],<br/>  _resListBalances_totalBals <strong class="lh hu">::</strong> [(<strong class="lh hu">UserId</strong>, <strong class="lh hu">Currency</strong>, <strong class="lh hu">Amount</strong>)],<br/>  _resListBalances_bookBals  <strong class="lh hu">::</strong> [(<strong class="lh hu">Currency</strong>, <strong class="lh hu">Amount</strong>)]<br/>  } <strong class="lh hu">deriving</strong> (<strong class="lh hu">Eq</strong>, <strong class="lh hu">Show</strong>, <strong class="lh hu">Generic</strong>)</span></pre><p id="9b08" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">任何想要与我们的交易所互动的人最终都会创建一个<code class="eh le lf lg lh b">Request</code>并收到一个合适的<code class="eh le lf lg lh b">Response</code>。下面是服务器的实际入口点:</p><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="436a" class="mx lx ht lh b fv my mz l na nb"><strong class="lh hu">import</strong> Network.Wai <strong class="lh hu">as</strong> W<br/><strong class="lh hu">import</strong> Network.Wai.Handler.Warp<br/><strong class="lh hu">import</strong> Network.HTTP.Types.Method<br/><strong class="lh hu">import</strong> Network.HTTP.Types.Status<br/><br/>le_port <strong class="lh hu">=</strong> 2345<br/><br/>serverMain <strong class="lh hu">::</strong> <strong class="lh hu">IO</strong> ()<br/>serverMain <strong class="lh hu">=</strong> <strong class="lh hu">do</strong><br/>  state <strong class="lh hu">&lt;-</strong> initialize<br/>  installSanityChecks state<br/>  putStrLn <strong class="lh hu">$</strong> "Listening on " <strong class="lh hu">++</strong> show le_port<br/>  run le_port <strong class="lh hu">$</strong> <strong class="lh hu">\</strong>req respond <strong class="lh hu">-&gt;</strong><br/>    <strong class="lh hu">let</strong> <strong class="lh hu">?</strong>req <strong class="lh hu">=</strong> req<br/>        <strong class="lh hu">?</strong>respond <strong class="lh hu">=</strong> respond<br/>        <strong class="lh hu">?</strong>state <strong class="lh hu">=</strong> state<br/>    <strong class="lh hu">in</strong> <strong class="lh hu">do</strong><br/>      print req<br/>      body <strong class="lh hu">&lt;-</strong> strictRequestBody req<br/>      <strong class="lh hu">case</strong> (pathInfo req, requestMethod req) <strong class="lh hu">of</strong><br/>        ("createMoney" <strong class="lh hu">:</strong> <strong class="lh hu">_</strong>, "POST") <strong class="lh hu">-&gt;</strong> withParsedRequest body api_createMoney<br/>        ("listOrders" <strong class="lh hu">:</strong> <strong class="lh hu">_</strong>,  "POST") <strong class="lh hu">-&gt;</strong> withParsedRequest body api_listOrders<br/>        ("addOrder" <strong class="lh hu">:</strong> <strong class="lh hu">_</strong>,    "POST") <strong class="lh hu">-&gt;</strong> withParsedRequest body api_addOrder<br/>        ("cancelOrder" <strong class="lh hu">:</strong> <strong class="lh hu">_</strong>, "POST") <strong class="lh hu">-&gt;</strong> withParsedRequest body api_cancelOrder<br/>        ("listBalances" <strong class="lh hu">:</strong> <strong class="lh hu">_</strong>, "POST") <strong class="lh hu">-&gt;</strong> withParsedRequest body api_listBalances<br/>        <strong class="lh hu">_</strong> <strong class="lh hu">-&gt;</strong> respond (<strong class="lh hu">W.</strong>responseLBS status404 <strong class="lh hu">[]</strong> "Unknown path")<br/><br/>initialize <strong class="lh hu">::</strong> <strong class="lh hu">IO</strong> <strong class="lh hu">Exchange</strong><br/>initialize <strong class="lh hu">=</strong> <strong class="lh hu">Exchange</strong> <strong class="lh hu">&lt;$&gt;</strong> newTVarIO <strong class="lh hu">Q.</strong>empty <strong class="lh hu">&lt;*&gt;</strong> newTVarIO (newBook ("USD", "BTC")) <strong class="lh hu">&lt;*&gt;</strong> newTVarIO <strong class="lh hu">Q.</strong>empty<br/><br/><strong class="lh hu">type</strong> <strong class="lh hu">HandlerT</strong> a <strong class="lh hu">=</strong> (<strong class="lh hu">?</strong>req <strong class="lh hu">::</strong> <strong class="lh hu">Request</strong>, <strong class="lh hu">?</strong>respond <strong class="lh hu">::</strong> (<strong class="lh hu">Response</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">IO</strong> <strong class="lh hu">ResponseReceived</strong>), <strong class="lh hu">?</strong>state <strong class="lh hu">::</strong> <strong class="lh hu">Exchange</strong>) <strong class="lh hu">=&gt;</strong> a <strong class="lh hu">-&gt;</strong> <strong class="lh hu">IO</strong> <strong class="lh hu">ResponseReceived</strong><br/><br/>withParsedRequest <strong class="lh hu">::</strong> <strong class="lh hu">FromJSON</strong> a <strong class="lh hu">=&gt;</strong> <strong class="lh hu">BSL.ByteString</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">HandlerT</strong> (a <strong class="lh hu">-&gt;</strong> <strong class="lh hu">IO</strong> <strong class="lh hu">ResponseReceived</strong>)<br/>withParsedRequest bs handler <strong class="lh hu">=</strong> <strong class="lh hu">case</strong> decode bs <strong class="lh hu">of</strong><br/>  <strong class="lh hu">Nothing</strong> <strong class="lh hu">-&gt;</strong> <strong class="lh hu">?</strong>respond (<strong class="lh hu">W.</strong>responseLBS status400 <strong class="lh hu">[]</strong> "Unable to parse")<br/>  <strong class="lh hu">Just</strong> x <strong class="lh hu">-&gt;</strong> handler x</span></pre><p id="64a9" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">下面是如何实现我们的一个处理程序:</p><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="919b" class="mx lx ht lh b fv my mz l na nb">api_listOrders <strong class="lh hu">::</strong> <strong class="lh hu">HandlerT</strong> <strong class="lh hu">Request_ListOrders</strong><br/>api_listOrders <strong class="lh hu">_</strong> <strong class="lh hu">=</strong> <strong class="lh hu">do</strong><br/>  <strong class="lh hu">let</strong> <strong class="lh hu">Exchange</strong>{<strong class="lh hu">..</strong>} <strong class="lh hu">=</strong> <strong class="lh hu">?</strong>state<br/>  book <strong class="lh hu">&lt;-</strong> readTVarIO _exchange_book<br/>  <strong class="lh hu">?</strong>respond <strong class="lh hu">$</strong> <strong class="lh hu">W.</strong>responseLBS status200 <strong class="lh hu">[]</strong> <strong class="lh hu">$</strong> encode <strong class="lh hu">$</strong> <strong class="lh hu">Response_ListOrders</strong> <strong class="lh hu">$</strong> toList book</span></pre><p id="3a0b" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">我还在<a class="ae jy" href="https://github.com/MichaelBurge/lambda-exchange" rel="noopener ugc nofollow" target="_blank"> Github </a>库中包含了JSON序列化器和反序列化器。</p><h1 id="619c" class="lw lx ht bd ly lz ma mb mc md me mf mg iz mh ja mi jc mj jd mk jf ml jg mm mn dt translated">测试</h1><p id="20bb" class="pw-post-body-paragraph kc kd ht kf b kg mo iu ki kj mp ix kl lb mq ko kp lc mr ks kt ld ms kw kx ky hm dt translated">我们实际上如何端到端测试我们的比特币交易所？</p><p id="2d11" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">第一步是打印一个请求值，以获得其对应的JSON:</p><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="97ff" class="mx lx ht lh b fv my mz l na nb">print <strong class="lh hu">$</strong> encode <strong class="lh hu">$</strong> <strong class="lh hu">Request_AddBid</strong> <strong class="lh hu">$</strong> <strong class="lh hu">Tagged</strong> <strong class="lh hu">$</strong> <strong class="lh hu">LimitOrder</strong> {<br/>    _lorder_user <strong class="lh hu">=</strong> 1<br/>    _lorder_fromAmount <strong class="lh hu">=</strong> 4600,<br/>    _lorder_toAmount <strong class="lh hu">=</strong> 1<br/>    }</span></pre><p id="5b2a" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">第二步是使用shell脚本将JSON发送到服务器:</p><pre class="jj jk jl jm fq mt lh mu mv aw mw dt"><span id="4ea1" class="mx lx ht lh b fv my mz l na nb">cat <strong class="lh hu">&lt;&lt;</strong>'EOF' | curl localhost:2345/addOrder -XPOST -d @-<br/>{<br/>  "bid":{<br/>    "toAmount":1,<br/>    "user":1,<br/>    "fromAmount":4600<br/>  },<br/>  "tag":"Request_AddBid"<br/>}<br/>EOF</span></pre><p id="1334" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">此时，您可以使用5个端点的任意组合来更改或检查交换的状态。</p><h1 id="49f6" class="lw lx ht bd ly lz ma mb mc md me mf mg iz mh ja mi jc mj jd mk jf ml jg mm mn dt translated">结论</h1><p id="0e10" class="pw-post-body-paragraph kc kd ht kf b kg mo iu ki kj mp ix kl lb mq ko kp lc mr ks kt ld ms kw kx ky hm dt translated">我们展示了如何在Haskell中实现一个简单的订单簿，它可以成为成熟的比特币交易所的基础。未来的文章可能包括:</p><ul class=""><li id="44f9" class="li lj ht kf b kg kh kj kk lb lk lc ll ld lm ky ln lo lp lq dt translated">为了提高效率，用C编写订单簿，并在更大的Haskell程序中使用。</li><li id="b28b" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">编写一个程序，监视实际的比特币被发送，这样钱就可以进入我们的交易所。</li><li id="3f9d" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">使用单元测试来验证订单簿的实现。</li><li id="f246" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">向交易所添加多个货币对。</li><li id="ebdd" class="li lj ht kf b kg lr kj ls lb lt lc lu ld lv ky ln lo lp lq dt translated">添加身份验证，这样用户就不能无限制地访问exchange。</li></ul></div></div>    
</body>
</html>