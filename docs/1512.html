<html>
<head>
<title>Ethernaut Lvl 16 Preservation Walkthrough: How to inject malicious contracts with delegatecall</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ethernaut Lvl 16保留演练:如何用delegatecall注入恶意契约</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethernaut-lvl-16-preservation-walkthrough-how-to-inject-malicious-contracts-with-delegatecall-81e071f98a12?source=collection_archive---------6-----------------------#2018-09-17">https://medium.com/coinmonks/ethernaut-lvl-16-preservation-walkthrough-how-to-inject-malicious-contracts-with-delegatecall-81e071f98a12?source=collection_archive---------6-----------------------#2018-09-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="e203" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">这是一个围绕<a class="ae ji" href="https://openzeppelin.org/" rel="noopener ugc nofollow" target="_blank"> Zeppelin </a>团队的<a class="ae ji" href="https://ethernaut.zeppelin.solutions/" rel="noopener ugc nofollow" target="_blank">智能合约安全拼图</a>的<a class="ae ji" rel="noopener" href="/@nicolezhu">深度系列</a>。我会给你直接的资源和你需要的关键概念来100%自己解决这些难题。</h2></div><p id="47d0" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">这个级别要求你结合来自级别<a class="ae ji" rel="noopener" href="/coinmonks/ethernaut-lvl-6-walkthrough-how-to-abuse-the-delicate-delegatecall-466b26c429e4"> 6 </a>和<a class="ae ji" rel="noopener" href="/coinmonks/ethernaut-lvl-12-privacy-walkthrough-how-ethereum-optimizes-storage-to-save-space-and-be-less-c9b01ec6adb6"> 12 </a>的知识来声明合同的所有权。</p></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="1878" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated"><code class="eh le lf lg lh b">Refresher on delegatecall</code></h1><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff li"><img src="../Images/d9398b021c39e52b7d9b94fee730b61f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2illD1nDsdULcEH5qVnmg.jpeg"/></div></div></figure><h2 id="d06b" class="lu kn ht bd ko lv lw lx ks ly lz ma kw js mb mc ky jw md me la ka mf mg lc mh dt translated"><a class="ae ji" rel="noopener" href="/coinmonks/ethernaut-lvl-6-walkthrough-how-to-abuse-the-delicate-delegatecall-466b26c429e4">从第6级召回</a>:</h2><ul class=""><li id="e27d" class="mi mj ht jl b jm mk jp ml js mm jw mn ka mo ke mp mq mr ms dt translated"><code class="eh le lf lg lh b">Delegate</code> call是一种特殊的低级函数调用，旨在从另一个(通常是库)契约中调用函数。</li><li id="fd61" class="mi mj ht jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms dt translated">如果契约A对契约B做了一个<code class="eh le lf lg lh b">delegatecall</code>，它允许契约B自由地改变它的存储A，给定契约B的<em class="my">相对</em>存储引用指针。</li></ul><blockquote class="mz na nb"><p id="d824" class="jj jk my jl b jm jn iu jo jp jq ix jr nc jt ju jv nd jx jy jz ne kb kc kd ke hm dt translated"><strong class="jl hu">提示</strong>:如果契约A调用契约B，并且你可以控制契约B，那么你就可以很容易地突变契约A的状态。</p></blockquote></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="aa76" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">合同存储复习</h1><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff nf"><img src="../Images/500d2d0f89ce4dfe91bcfb4c2f264bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m5NBfllEpvUj_yYC-UYJzA.jpeg"/></div></div></figure><h2 id="985a" class="lu kn ht bd ko lv lw lx ks ly lz ma kw js mb mc ky jw md me la ka mf mg lc mh dt translated"><a class="ae ji" rel="noopener" href="/coinmonks/ethernaut-lvl-12-privacy-walkthrough-how-ethereum-optimizes-storage-to-save-space-and-be-less-c9b01ec6adb6">从第12级召回:</a></h2><ul class=""><li id="e931" class="mi mj ht jl b jm mk jp ml js mm jw mn ka mo ke mp mq mr ms dt translated">以太坊分配32字节大小的存储槽<em class="my">来存储状态。插槽从索引<code class="eh le lf lg lh b">0</code>开始，依次向上到2个⁵⁶插槽。</em></li><li id="5bd4" class="mi mj ht jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms dt translated">从位置<code class="eh le lf lg lh b">0,</code>开始，然后是<code class="eh le lf lg lh b">1</code>，直到<code class="eh le lf lg lh b">2²⁵⁶-1</code>，基本数据类型在存储器中连续排列。</li><li id="26fd" class="mi mj ht jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms dt translated">如果顺序声明数据的<strong class="jl hu"> <em class="my">组合大小</em> </strong>小于32字节 ，则顺序数据点被打包到单个存储槽中以优化空间和气体。</li></ul><blockquote class="mz na nb"><p id="d2bf" class="jj jk my jl b jm jn iu jo jp jq ix jr nc jt ju jv nd jx jy jz ne kb kc kd ke hm dt translated"><strong class="jl hu">提示</strong>:如果您可以匹配合同A和合同B之间的存储数据位置，您就可以精确地操作合同A中所需的变量。</p></blockquote></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><figure class="lj lk ll lm fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff ng"><img src="../Images/3f07646a514183f0dfeb271cd03c2b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i-iTqgpFEJA83oIqvpifNQ.png"/></div></div></figure><h1 id="2426" class="km kn ht bd ko kp nh kr ks kt ni kv kw iz nj ja ky jc nk jd la jf nl jg lc ld dt translated">详细演练</h1><p id="247c" class="pw-post-body-paragraph jj jk ht jl b jm mk iu jo jp ml ix jr js nm ju jv jw nn jy jz ka no kc kd ke hm dt translated">首先，请注意<code class="eh le lf lg lh b">LibraryContract</code>修改了插槽0的状态。此外，它允许外部方用任何其他32字节变量替换<code class="eh le lf lg lh b">storedTime</code>。</p><blockquote class="mz na nb"><p id="cc52" class="jj jk my jl b jm jn iu jo jp jq ix jr nc jt ju jv nd jx jy jz ne kb kc kd ke hm dt translated"><strong class="jl hu">提示</strong>:如果我们用契约地址替换槽0会怎么样？</p></blockquote><pre class="lj lk ll lm fq np lh nq nr aw ns dt"><span id="b41a" class="lu kn ht lh b fv nt nu l nv nw">uint storedTime; <br/>function setTime(uint _time) public { <br/>    storedTime = _time;<br/>}</span></pre><p id="1d40" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">其次，注意你可以通过<code class="eh le lf lg lh b">setFirstTime</code>中的delegatecall从<strong class="jl hu"> Preservation.sol </strong>中调用<code class="eh le lf lg lh b">setTime</code>。</p><p id="0926" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">这意味着你<strong class="jl hu">可以修改</strong>的Preservation.sol中的slot 0，即改变<code class="eh le lf lg lh b">timeZone1Library</code>的地址！</p><blockquote class="mz na nb"><p id="bec2" class="jj jk my jl b jm jn iu jo jp jq ix jr nc jt ju jv nd jx jy jz ne kb kc kd ke hm dt translated"><strong class="jl hu">提示:</strong>如果您可以重新指向<code class="eh le lf lg lh b">timeZone1Libary</code>一个修改Preservation.sol中其他状态变量的恶意契约会怎么样？</p></blockquote><h2 id="62b0" class="lu kn ht bd ko lv lw lx ks ly lz ma kw js mb mc ky jw md me la ka mf mg lc mh dt translated">第一部分—创建恶意合同</h2><p id="4f04" class="pw-post-body-paragraph jj jk ht jl b jm mk iu jo jp ml ix jr js nm ju jv jw nn jy jz ka no kc kd ke hm dt translated">在第一部分中，让我们创建一个<code class="eh le lf lg lh b">timeZone1Libary</code>将指向的恶意契约。</p><ol class=""><li id="e52e" class="mi mj ht jl b jm jn jp jq js nx jw ny ka nz ke oa mq mr ms dt translated">注意<strong class="jl hu"> Preservation.sol </strong>在<strong class="jl hu">槽2 </strong>存储<code class="eh le lf lg lh b">owner</code>地址。让我们创建一个具有<em class="my">相同</em>存储布局的恶意合同:</li></ol><pre class="lj lk ll lm fq np lh nq nr aw ns dt"><span id="595e" class="lu kn ht lh b fv nt nu l nv nw">contract BadLibraryContract {<br/>    address public timeZone1Library; // SLOT 0<br/>    address public timeZone2Library; // SLOT 1<br/>    address public owner;            // SLOT 2<br/>    uint storedTime;                 // SLOT 3<br/>...</span></pre><p id="f66b" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">2.在BadContract中创建一个<code class="eh le lf lg lh b">setTime</code>函数，用你的钱包地址更新slot 2。</p><pre class="lj lk ll lm fq np lh nq nr aw ns dt"><span id="f523" class="lu kn ht lh b fv nt nu l nv nw">function setTime(uint _time) public {<br/>    owner = msg.sender;<br/>}</span></pre><p id="5347" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><em class="my">注意:使用与LibraryContract中相同的函数名很重要，因为Preservation.sol通过名称调用函数:</em></p><pre class="lj lk ll lm fq np lh nq nr aw ns dt"><span id="b295" class="lu kn ht lh b fv nt nu l nv nw">bytes4(keccak256(“setTime(uint256)”));</span></pre><p id="6090" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">3.在<a class="ae ji" href="http://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a>中部署BadLibraryContract到Ropsten，并保存其实例地址。然后，计算<code class="eh le lf lg lh b">uint(address)</code>以导出输入变量:</p><pre class="lj lk ll lm fq np lh nq nr aw ns dt"><span id="e2b0" class="lu kn ht lh b fv nt nu l nv nw">setFirstTime(uint _timeStamp)</span></pre><h2 id="4046" class="lu kn ht bd ko lv lw lx ks ly lz ma kw js mb mc ky jw md me la ka mf mg lc mh dt translated">第二部分—将时区1库更新为恶意合同</h2><ol class=""><li id="2805" class="mi mj ht jl b jm mk jp ml js mm jw mn ka mo ke oa mq mr ms dt translated">在混音中，访问你的关卡实例。</li><li id="ee4d" class="mi mj ht jl b jm mt jp mu js mv jw mw ka mx ke oa mq mr ms dt translated">用转换后的<code class="eh le lf lg lh b">uint(address)</code>调用<code class="eh le lf lg lh b">setFirstTime</code>。</li><li id="0552" class="mi mj ht jl b jm mt jp mu js mv jw mw ka mx ke oa mq mr ms dt translated">仔细检查<code class="eh le lf lg lh b">timeZone1Library</code>现在是你的恶意合同地址。</li></ol><h2 id="dc7e" class="lu kn ht bd ko lv lw lx ks ly lz ma kw js mb mc ky jw md me la ka mf mg lc mh dt translated">第三部分—获得所有权</h2><ol class=""><li id="652d" class="mi mj ht jl b jm mk jp ml js mm jw mn ka mo ke oa mq mr ms dt translated">第二次，用任意输入的uint变量调用<code class="eh le lf lg lh b">setFirstTime</code>。这一次，你实际上是在调用<code class="eh le lf lg lh b">owner = msg.sender</code>。</li><li id="a6ca" class="mi mj ht jl b jm mt jp mu js mv jw mw ka mx ke oa mq mr ms dt translated">仔细检查保存处的主人。sol现在是你的钱包地址。</li></ol></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="c35c" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">关键安全要点</h1><ul class=""><li id="ce87" class="mi mj ht jl b jm mk jp ml js mm jw mn ka mo ke mp mq mr ms dt translated">理想情况下，库不应该存储状态。</li><li id="4c7e" class="mi mj ht jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms dt translated">创建库时，使用<code class="eh le lf lg lh b">library</code>，而不是<code class="eh le lf lg lh b">contract</code>，以确保当调用者使用<code class="eh le lf lg lh b">delegatecall</code>时，库不会修改调用者存储数据。</li><li id="e8a8" class="mi mj ht jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms dt translated">使用更高级的函数调用来继承库，特别是当你I)不需要改变契约存储和ii)不关心气体控制的时候。</li></ul><h1 id="fd2d" class="km kn ht bd ko kp nh kr ks kt ni kv kw iz nj ja ky jc nk jd la jf nl jg lc ld dt translated">更多级别</h1><div class="ob oc fm fo od oe"><a rel="noopener follow" target="_blank" href="/coinmonks/ethernaut-lvl-15-naught-coin-walkthrough-how-to-abuse-erc20-tokens-and-bad-icos-6668b856a176"><div class="of ab ej"><div class="og ab oh cl cj oi"><h2 class="bd hu fv z el oj eo ep ok er et hs dt translated">以太币15级零硬币演练:如何滥用ERC20代币和坏ico</h2><div class="ol l"><h3 class="bd b fv z el oj eo ep ok er et ek translated">这是一个围绕齐柏林团队的智能合同安全难题的深入系列。我们学习关键的可靠性概念…</h3></div><div class="om l"><p class="bd b gc z el oj eo ep ok er et ek translated">medium.com</p></div></div><div class="on l"><div class="oo l op oq or on os ls oe"/></div></div></a></div><div class="ob oc fm fo od oe"><a rel="noopener follow" target="_blank" href="/coinmonks/ethernaut-lvl-17-locked-walkthrough-how-to-properly-use-structs-in-solidity-f9900c8843e2"><div class="of ab ej"><div class="og ab oh cl cj oi"><h2 class="bd hu fv z el oj eo ep ok er et hs dt translated">Ethernaut Lvl 17锁定演练:如何在Solidity中正确使用结构</h2><div class="ol l"><h3 class="bd b fv z el oj eo ep ok er et ek translated">这是一个围绕齐柏林团队的智能合同安全难题的深入系列。我会给你直接的资源…</h3></div><div class="om l"><p class="bd b gc z el oj eo ep ok er et ek translated">medium.com</p></div></div><div class="on l"><div class="ot l op oq or on os ls oe"/></div></div></a></div><blockquote class="ou"><p id="b10a" class="ov ow ht bd ox oy oz pa pb pc pd ke ek translated"><a class="ae ji" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="pf pg ph pi pj ln fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff pe"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>