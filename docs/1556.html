<html>
<head>
<title>Gasless or Meta Transactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无汽油或元交易</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/gasless-transactions-f75382095c4f?source=collection_archive---------0-----------------------#2018-09-26">https://medium.com/coinmonks/gasless-transactions-f75382095c4f?source=collection_archive---------0-----------------------#2018-09-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/2bf9cf11975b13ae9d1f2900c889d638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNqD7OHW3IW5Iz6ADGK5zw.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Gas can lead to UX problems, “Gasless” transactions may hold the solution.</figcaption></figure><p id="d66f" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">{这篇文章是上一篇文章<a class="ae kd" rel="noopener" href="/coinmonks/crypto-ux-and-key-management-6e35b3cd466d">的延续。</a> }</p><p id="7b2b" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">气体的概念对于大多数非技术用户来说是陌生的。然而，支付交易费的想法是不可行的。许多传统的实体银行<a class="ae kd" href="https://www.ratehub.ca/chequing-accounts/accounts/personal" rel="noopener ugc nofollow" target="_blank">对每笔借记卡交易收取固定的交易费用，或者将这些费用计入固定的季度“维护”费用。事实上，这就是人们所认为的UX问题，</a><a class="ae kd" href="https://cryptobriefing.com/eos-ethereum-smart-contract-war-winner/" rel="noopener ugc nofollow" target="_blank">一些连锁店</a>已经转向相反的模式，即执行合同支付天然气费用，而不是交易发送方。</p><p id="a32a" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">天然气成本可通过以下等式转化为货币成本:成本=美元/天然气价格*天然气数量。天然气数量取决于交易的复杂程度，天然气价格是一个<a class="ae kd" href="https://ethgasstation.info/index.php" rel="noopener ugc nofollow" target="_blank">用户选择的值</a>，该值通常规定交易需要多长时间才能包含在区块中。一天中的时间对网络拥塞程度有很大影响，因此，如果交易不紧急，则可以设置低的天然气价格，并且该交易可能最终被包括在内。</p><p id="82a8" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">没有任何关联以太网的密钥对不能直接在以太网上发送交易，因为它们没有支付汽油费用的能力，但不用担心，已经设计了几种机制来回避这个问题。其中一些机制很好地结合了一次性密钥的概念，之前在这里讨论过<a class="ae kd" rel="noopener" href="/coinmonks/crypto-ux-and-key-management-6e35b3cd466d"/>。签署符合<a class="ae kd" href="https://github.com/ethereum/EIPs/issues/191" rel="noopener ugc nofollow" target="_blank"> ERC-191 </a>的事务并将该事务发送到富含以太/气体的节点的能力是一个强大的概念，该节点然后可以将该签署的事务广播到网络。通过支付一些ERC-20代币，甚至复制传统的“维护”收费模式(用户为交易支付特定的季度费用)，可以从经济上激励这个中继器广播这些交易。</p><p id="8409" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">基于身份的气体继电器</strong></p><p id="79ce" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">Status<a class="ae kd" href="https://github.com/status-im/contracts/blob/73-economic-abstraction/contracts/identity/IdentityGasRelay.sol" rel="noopener ugc nofollow" target="_blank">identitygasrelay . sol</a>中描述了其中一个无气交易模型。该合同继承了<a class="ae kd" href="https://github.com/status-im/contracts/blob/73-economic-abstraction/contracts/identity/Identity.sol" rel="noopener ugc nofollow" target="_blank"> Identity.sol </a>，在<a class="ae kd" rel="noopener" href="/coinmonks/crypto-ux-and-key-management-6e35b3cd466d">上一篇文章</a>中有详细分析。从Identity.sol继承的<code class="eh ke kf kg kh b">nonce</code>字段对照传递的<code class="eh ke kf kg kh b">_nonce</code>进行检查并递增，以保持对重放攻击的抵抗，并确保事务与身份契约同步。</p><p id="bebc" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><code class="eh ke kf kg kh b">MANAGEMENT</code>和<code class="eh ke kf kg kh b">ACTION</code>密钥用于确保交易签名人有足够的权限来执行所请求的交易，而<code class="eh ke kf kg kh b">purposeThreshold</code>映射用于确保已达到足够数量的签名人用于该密钥目的。<code class="eh ke kf kg kh b">isKeyPurpose()</code>，在Identity.sol中广泛使用，再次用于确保密钥达到预期目的。类似于身份契约，它旨在为每个用户部署该契约的一个单独实例(这与uPort的<a class="ae kd" href="https://github.com/ethereum/EIPs/issues/1056" rel="noopener ugc nofollow" target="_blank"> ERC-1056 </a>轻量级身份提议形成对比)。</p><p id="a47a" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">工作原理</strong></p><p id="7e08" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">该气体继电器的主要功能通过两个主要功能实现:<code class="eh ke kf kg kh b">callGasRelayed(...)</code>和<code class="eh ke kf kg kh b">approveAndCallGasRelayed(...)</code>。这些功能的总体结构是相似的:</p><ol class=""><li id="eca0" class="ki kj ht jh b ji jj jm jn jq kk ju kl jy km kc kn ko kp kq dt translated">执行健全性检查</li><li id="3819" class="ki kj ht jh b ji kr jm ks jq kt ju ku jy kv kc kn ko kp kq dt translated">计算应该签名的散列值</li><li id="29fe" class="ki kj ht jh b ji kr jm ks jq kt ju ku jy kv kc kn ko kp kq dt translated">确保签名是正确的</li><li id="1bf0" class="ki kj ht jh b ji kr jm ks jq kt ju ku jy kv kc kn ko kp kq dt translated">发送事务，向观察者发出确认事件</li><li id="1621" class="ki kj ht jh b ji kr jm ks jq kt ju ku jy kv kc kn ko kp kq dt translated">适当地退款给打电话的人</li></ol><p id="3b3c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这两个<code class="eh ke kf kg kh b">callGasRelayed(...)</code>和<code class="eh ke kf kg kh b">approveAndCallGasRelayed(...)</code>采用相似的参数:要中继的交易目的地地址、交易值、交易数据、当前nonce、要退还给该函数调用方的汽油价格。这些功能旨在由“汽油丰富”的继电器调用，并且这些功能中内置了这样的逻辑，以乙醚的形式或者如果指定的话，以某种类型的ERC-20令牌的形式向调用者退还汽油费用。</p><p id="694b" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这两个外部可调用的函数都从执行一些健全性和安全性检查开始:确保函数调用与预期使用的量相比有足够的gas，确保<code class="eh ke kf kg kh b">nonce’s</code>匹配，以及在<code class="eh ke kf kg kh b">approveAndCallRelayed</code>的情况下，退款ERC-20令牌地址是否有效。</p><p id="bb9c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">然后计算出<code class="eh ke kf kg kh b">signHash</code>。这是所传递参数的keccak散列，符合ERC-191: <code class="eh ke kf kg kh b">signHash = keccak256(“\x19Ethereum Signed Message:\n32”, _hash);</code>。这个<code class="eh ke kf kg kh b">signHash</code>将用于确保交易由适当的密钥签名。</p><p id="0e82" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这两个函数的主要区别在于执行检查以确保签名密钥具有正确的权限。<code class="eh ke kf kg kh b">callGasRelayed() </code>允许签名来自<code class="eh ke kf kg kh b">MANAGEMENT</code>或<code class="eh ke kf kg kh b">ACTION</code>键:</p><pre class="kw kx ky kz fq la kh lb lc aw ld dt"><span id="95af" class="le lf ht kh b fv lg lh l li lj">// callGasRelayed(...)<br/>...<br/>verifySignatures( <br/>    _to == address(this) ? MANAGEMENT_KEY : ACTION_KEY,<br/>    signHash,<br/>    _messageSignatures <br/>);<br/>...</span></pre><p id="ee00" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><code class="eh ke kf kg kh b">callGasRelayed</code>然后继续执行一个低级调用:<code class="eh ke kf kg kh b">_to.call.value(_value)(_data)</code>的事务，并发出一个<code class="eh ke kf kg kh b">ExecutedGasRelayed</code>事件，表示该调用成功。相反，<code class="eh ke kf kg kh b">approveAndCallGasRelayed</code>不允许使用<code class="eh ke kf kg kh b">MANAGEMENT</code>键:</p><pre class="kw kx ky kz fq la kh lb lc aw ld dt"><span id="a811" class="le lf ht kh b fv lg lh l li lj">// approveAndCallGasRelayed(...)<br/>...<br/>verifySignatures(<br/>    ACTION_KEY, //no management with approveAndCall<br/>    signHash,<br/>   _messageSignatures<br/>);<br/>...</span></pre></div><div class="ab cl lk ll hb lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hm hn ho hp hq"><p id="0f08" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">验证签名</strong></p><p id="9931" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><code class="eh ke kf kg kh b">verifySignatures()</code>有<code class="eh ke kf kg kh b">view</code>修饰符，它允许函数中的代码读取合同状态，但无论如何不能修改它。像<code class="eh ke kf kg kh b">view</code>和<code class="eh ke kf kg kh b">pure</code>这样的内置修饰符<a class="ae kd" href="https://ethereum.stackexchange.com/questions/28898/when-to-use-view-and-pure-in-place-of-constant" rel="noopener ugc nofollow" target="_blank">被认为是最佳实践</a>，很好地反映了C++的封装原则——尽可能地限制状态修改能力。</p><pre class="kw kx ky kz fq la kh lb lc aw ld dt"><span id="bcc6" class="le lf ht kh b fv lg lh l li lj">function verifySignatures(uint256 _requiredKey,<br/>bytes32 _signHash,<br/>bytes _messageSignatures )<br/> <br/>public view returns(bool) <br/>{ <br/>  uint _amountSignatures = _messageSignatures.length / 72;<br/>  require(_amountSignatures == purposeThreshold[_requiredKey]);<br/>  bytes32 _lastKey = 0;<br/>  for (uint256 i = 0; i &lt; _amountSignatures; i++) <br/>  { <br/>   bytes32 _currentKey = recoverKey(_signHash,_messageSignatures,i);<br/>   require(_currentKey &gt; _lastKey); //assert keys are different <br/>   require(isKeyPurpose(_currentKey, _requiredKey));<br/>   _lastKey = _currentKey;<br/>  }<br/>  return true;<br/>}</span></pre><p id="d165" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">多个签名作为<code class="eh ke kf kg kh b">_messageSignatures</code>被传递给<code class="eh ke kf kg kh b">verifySignatures()</code>，签名的数量通过除以72字节(单个签名的预期大小= 32 + 32 + 1)确定，并连同之前计算的<code class="eh ke kf kg kh b">signHash</code>和<code class="eh ke kf kg kh b">_messageSignatures</code>字节变量内的签名索引一起被发送给<code class="eh ke kf kg kh b">recoverKey()</code>。</p><pre class="kw kx ky kz fq la kh lb lc aw ld dt"><span id="41db" class="le lf ht kh b fv lg lh l li lj">function recoverKey (bytes32 _signHash,<br/>bytes _messageSignature,<br/>uint256 _pos)</span><span id="cc14" class="le lf ht kh b fv lr lh l li lj">pure public returns(bytes32)<br/>{<br/>  uint8 v;<br/>  bytes32 r;<br/>  bytes32 s;<br/>  (v,r,s) = signatureSplit(_messageSignature, _pos);<br/>  return bytes32(ecrecover(_signHash,v,r,s));<br/>}</span></pre><p id="5795" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><code class="eh ke kf kg kh b">signatureSplit()</code>获取字节blob和一个索引<code class="eh ke kf kg kh b">pos</code>(循环迭代器)，并使用内联汇编提取签名的<code class="eh ke kf kg kh b">v</code>、<code class="eh ke kf kg kh b">r</code>和<code class="eh ke kf kg kh b">s</code>组件。内联汇编在这里对于细粒度提取编码在<code class="eh ke kf kg kh b">_signatures</code>字节中的信息是必要的，回想一下EVM是一个基于256位堆栈的虚拟机，因此默认为32字节的字。签名格式是<code class="eh ke kf kg kh b">{bytes32 r}{bytes32 s}{uint8 v}</code>的紧凑形式。值<code class="eh ke kf kg kh b">r</code>和<code class="eh ke kf kg kh b">s </code>提取起来很简单——索引乘以32字节的偏移量，这个索引偏移量被加到指向<code class="eh ke kf kg kh b">_signatures</code>开头的指针上。这里很好地解释了这种使用内联汇编提取值的技术<a class="ae kd" href="https://blog.colony.io/parameterized-transaction-reviews-11f0cdc40479" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a280" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">紧凑意味着，<code class="eh ke kf kg kh b">uint8</code>没有填充到32字节，这使得提取<code class="eh ke kf kg kh b">v</code>变得有点棘手。此外，EVM指令集中没有<code class="eh ke kf kg kh b">mload8</code>操作码来做这件事。相反，我们加载最后32个字节，包括31个字节的<code class="eh ke kf kg kh b">s</code>，并使用<code class="eh ke kf kg kh b">and</code>和<code class="eh ke kf kg kh b">0xff</code>(十进制255)来提取最后一个字节。</p><pre class="kw kx ky kz fq la kh lb lc aw ld dt"><span id="baab" class="le lf ht kh b fv lg lh l li lj">// signatureSplit(...)<br/>...<br/>assembly {            <br/>  r := mload(add(_signatures, mul(32,pos)));<br/>  s := mload(add(_signatures, mul(64,pos)));<br/>  v := and(mload(add(_signatures, mul(65,pos))), 0xff);<br/>}</span></pre><p id="04ec" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><code class="eh ke kf kg kh b">ecrecover()</code>是一个存在于<a class="ae kd" href="https://github.com/ethereum/go-ethereum/blob/master/core/vm/contracts.go#L42" rel="noopener ugc nofollow" target="_blank">预编译契约</a>中的函数，自Frontier发布以来一直可用。等效功能可以用<a class="ae kd" href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.12.0/contracts/ECRecovery.sol" rel="noopener ugc nofollow" target="_blank">实度</a>表示。该函数采用<a class="ae kd" href="https://hackernoon.com/a-closer-look-at-ethereum-signatures-5784c14abecc" rel="noopener ugc nofollow" target="_blank"> EC </a>签名的<code class="eh ke kf kg kh b">v</code>、<code class="eh ke kf kg kh b">r</code>和<code class="eh ke kf kg kh b">s</code>参数以及这些参数所代表的消息的散列，并从签名密钥对中返回对应于公钥的地址。要求<code class="eh ke kf kg kh b">v </code>等于27或28。该参数有助于缓解<a class="ae kd" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md" rel="noopener ugc nofollow" target="_blank">特定重放攻击</a>。</p><p id="ce27" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在<code class="eh ke kf kg kh b">verifySignature()</code>中备份，从<code class="eh ke kf kg kh b">ecrecover()</code>返回的地址与<code class="eh ke kf kg kh b">require(isKeyPurpose(_currentKey, _requiredKey))</code>动作所需的密钥进行核对。因此，签名检查控制流看起来像这样:</p><pre class="kw kx ky kz fq la kh lb lc aw ld dt"><span id="f616" class="le lf ht kh b fv lg lh l li lj">[callGasRelayed() or approveAndCallGasRelayed()] =&gt; verifySignatures() =&gt;<br/>forEach(signature){<br/>=&gt; recoverKey() =&gt; splitSignature() =&gt; ecrecover() =&gt; isKeyPurpose()<br/>}</span></pre></div><div class="ab cl lk ll hb lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hm hn ho hp hq"><p id="fee4" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">经济激励</strong></p><p id="374a" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在<code class="eh ke kf kg kh b">nonce</code>递增、预期值和数据被发送、或ERC-20令牌传输被批准、以及<code class="eh ke kf kg kh b">ExecutedGasRelayed</code>事件被发出之后，是时候对被调用的函数(面向gas的账户)进行经济奖励了:</p><pre class="kw kx ky kz fq la kh lb lc aw ld dt"><span id="1053" class="le lf ht kh b fv lg lh l li lj">...<br/>if (_gasPrice &gt; 0) {<br/>  uint256 _amount = 21000 + (startGas - gasleft());<br/>  _amount = _amount * _gasPrice;<br/>  if (_gasToken == address(0)) { // if no token specified send Ether<br/>    address(msg.sender).transfer(_amount); <br/>  }<br/>  else { // if token specified then <br/>    ERC20Token(_gasToken).transfer(msg.sender, _amount);            <br/>  }<br/>}</span></pre><p id="ae64" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这部分代码可以根据经济上的考虑进行配置。例如，如果中继站可以选择乙醚或通过ERC-20令牌批准退款，那么它可能希望检查它正在接收的ERC-20令牌的价值是否足够，并根据此信息做出决定。这最有可能在链外完成，因为对oracle合同的调用可能无法证明天然气使用量的增加是合理的，但图灵完整语言的可能性和灵活性在这里是显而易见的。正如本帖介绍中提到的，传统的交易费用模型可能在这里实现。继电器可以在单独的合同中维护余额的映射，并相应地减少或增加。</p></div><div class="ab cl lk ll hb lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hm hn ho hp hq"><p id="6dd0" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">分析</strong></p><p id="a500" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这种架构功能强大且灵活，允许任意执行事务，但也存在一些问题:</p><ul class=""><li id="e127" class="ki kj ht jh b ji jj jm jn jq kk ju kl jy km kc ls ko kp kq dt translated"><em class="lt">审查</em>:交易必须以某种方式到达中继器。因为这是在链外完成的，所以有信任的假设，即富气继电器将按预期运行，并且不会增加对该交易的审查。这个问题并不是这种情况下独有的，交易审查在区块链是一个相对未解决的问题。像这样的“网络边缘”问题是很难有效解决的。</li><li id="318a" class="ki kj ht jh b ji kr jm ks jq kt ju ku jy kv kc ls ko kp kq dt translated"><em class="lt">签名持久性</em>:这种架构要求该动作所需的所有签名都出现在对<code class="eh ke kf kg kh b">callGasRelayed</code>或<code class="eh ke kf kg kh b">approveAndGasRelayed</code>的单个调用中。一个稍微灵活一点的设置是在被中继的调用之间有一些持久性，尽管这可以通过一个更迂回的方法来建立，通过使用<code class="eh ke kf kg kh b">IdentityGasRelay.sol</code>来调用<code class="eh ke kf kg kh b">Identity.sol</code>中的持久性函数。</li><li id="ea2c" class="ki kj ht jh b ji kr jm ks jq kt ju ku jy kv kc ls ko kp kq dt translated"><em class="lt">签名排序</em>:出于某种原因，也许是为了加强简洁性，降低燃气成本，签名<a class="ae kd" href="https://github.com/status-im/contracts/blob/73-economic-abstraction/contracts/identity/IdentityGasRelay.sol#L188" rel="noopener ugc nofollow" target="_blank">必须以升序</a>发送，这降低了合同的灵活性。</li></ul></div><div class="ab cl lk ll hb lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hm hn ho hp hq"><p id="cfc5" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">向为<a class="ae kd" href="https://metatx.io/" rel="noopener ugc nofollow" target="_blank">元交易</a>空间做出重大贡献的<a class="ae kd" href="https://twitter.com/austingriffith" rel="noopener ugc nofollow" target="_blank">奥斯汀·格里菲斯</a>致敬。</p><p id="681e" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在媒体上关注我或在推特上联系我:<a class="ae kd" href="https://twitter.com/gawnieg" rel="noopener ugc nofollow" target="_blank">https://twitter.com/gawnieg</a></p><blockquote class="lu"><p id="8e5b" class="lv lw ht bd lx ly lz ma mb mc md kc ek translated"><a class="ae kd" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mf mg mh mi mj iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff me"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>