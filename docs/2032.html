<html>
<head>
<title>Implementing Proof of Stake Part — 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实施利害关系证明第3部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/implementing-proof-of-stake-part-3-c68b953a50be?source=collection_archive---------0-----------------------#2019-02-01">https://medium.com/coinmonks/implementing-proof-of-stake-part-3-c68b953a50be?source=collection_archive---------0-----------------------#2019-02-01</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="e9dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">本文给出了一个在node.js中实现利益一致性算法的简单方法</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/67a3c3a562cf394e00d1dc1fd2774c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*X1523S70lXzN1lyg8sm7mQ.jpeg"/></div></figure><p id="44a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在之前的<a class="ae jw" rel="noopener" href="/coinmonks/implementing-proof-of-stake-part-2-748156d5c85e">帖子</a>中，我们编写了一个基本的区块链。在这一部分中，我们将实现验证一个链并添加多个贡献者的功能。</p><p id="2669" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了增加对多个贡献者的支持，我们需要添加某种形式的验证。网络中的每个节点可能在某个时间点具有不同的链。为了达到一个共同的状态，我们需要验证我们为其他节点收到的新链。在比特币中，使用的是最长链规则。其中，有效的链，即所有块都有效并且具有最大块数的链被认为是有效链。因此，所有节点将其链替换为最长的链。对我们来说，在任何新的连接上，我们发送我们的链并从另一个节点接收链。</p><p id="1b80" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将在区块链类中创建一个<code class="eh jx jy jz ka b">isValidChain(chain)</code>静态函数，它告诉我们这个链是否有效。在这个函数中，我们重新计算块的散列，并将其与块的给定散列进行比较。这将检查该块是否已被篡改。</p><p id="f9d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在添加这个函数之前，我们需要一种方法来找到给定块实例的块的散列。让我们将此功能添加到block类中。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kb kc l"/></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">Handover a block, and I’ll hash it</figcaption></figure><p id="2bb6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们可以在我们的<code class="eh jx jy jz ka b">isValidChain()</code>函数中使用这个函数。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kb kc l"/></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">chain valid ? yes : no ;</figcaption></figure><p id="9459" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">继续前进。当我们收到一个有效的比我们的更长的新链时，我们必须使用那个链并丢弃我们的链，更正式地说，我们必须用新的更长的链替换我们的链。让我们添加这个功能。</p><p id="f559" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在区块链类中创建一个函数<code class="eh jx jy jz ka b">replaceChain(chain)</code>。这会将当前区块链对象的新链分配给作为参数接收的新链。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="65aa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们继续围绕我们已经创建的这个区块链系统创建一个web API。这些API将允许用户通过每个HTTP请求与区块链进行交互，由于我们很快就会有多链验证，我们将有多个minorss更新一个在整个网络上分散的区块链中共享的minor。</p><p id="e0d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我们有我们的web API之前，让我们组织我们的项目，因为我们将很快在我们的项目中添加更多的文件。</p><p id="cf68" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">创建一个名为区块链的新目录，并将块和区块链文件与测试文件一起移动到该目录中。</p><p id="f773" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的文件项目结构应该如下所示</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="e4e2" class="kl km ht ka b fv kn ko l kp kq">blockchain/<br/>     blockchain.js<br/>     block.js</span></pre><p id="ebab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在让我们为我们的应用程序创建一个单独的<code class="eh jx jy jz ka b">app</code>文件夹。让我们在这个文件夹中创建一个新的<code class="eh jx jy jz ka b">index.js</code>文件。</p><p id="44b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了制作我们的API，我们将使用express模块。让我们安装它。</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="b0bd" class="kl km ht ka b fv kn ko l kp kq">npm i express --save</span></pre><p id="49af" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了在post请求中操作数据，我们需要一个bodyparser模块。所以把那个也装上。</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="c63b" class="kl km ht ka b fv kn ko l kp kq">npm i body-parser --save</span></pre><p id="bc9d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将有多个用户运行我们的应用程序。为了在我们自己的机器上测试这个应用程序，我们需要在每次运行新实例时在不同的端口上运行这个应用程序。因此，我们必须在每次运行新的应用程序时提供一个新的端口。</p><p id="3b37" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将使用环境变量来实现这一点。我们可以从终端传递端口，并将其分配给运行应用程序的端口。默认情况下，我们将在端口3000上运行我们的应用程序。</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="2ed3" class="kl km ht ka b fv kn ko l kp kq">const HTTP_PORT = process.env.HTTP_PORT || 3001;</span><span id="da28" class="kl km ht ka b fv kr ko l kp kq">// we can run our app something like the following to run on a<br/>// different port</span><span id="c3e2" class="kl km ht ka b fv kr ko l kp kq">HTTP_PORT = 3002 npm run dev</span></pre><p id="649d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还需要这个API中的区块链实例来发送和接收块数据。</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="f2a0" class="kl km ht ka b fv kn ko l kp kq">const Blockchain = require('../blockchain');<br/>const blockchain = new Blockchain();</span></pre><p id="0057" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还需要向我们的应用程序添加一个启动脚本。在package.json文件中，添加一个脚本来运行app目录中的index.js文件。</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="7f1e" class="kl km ht ka b fv kn ko l kp kq">"dev": "nodemon ./app"</span></pre><p id="dcda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们为应用添加了一些基本的端点:</p><p id="45e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">获取<code class="eh jx jy jz ka b"> /blocks</code> —将链发送给用户。</p><p id="a68d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Post <code class="eh jx jy jz ka b">/mine</code> —在创建新块的请求中发送数据。</p><p id="2b68" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们创建我们的应用程序。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kb kc l"/></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">Plain simple APIs</figcaption></figure><p id="abcc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">太棒了。让我们在《邮差》中尝试一下。</p><p id="1764" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">发出get请求会给整个链。在我们的例子中，我们只有一个创世纪块。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/58c3b80fc4da6f8ce12842e82d9baeaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*0bSH0bGwvBH67Q-Ke-PYtQ.png"/></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">Get request sends the entire chain</figcaption></figure><p id="cc4b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">发出post请求将会生成一个新的块。因此，我们还需要传入一些数据。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff kt"><img src="../Images/13ed924bb5b8c6ded0557d2061f4e57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnGdIXw8AWg-axw86bYCSg.png"/></div></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">Post request with data</figcaption></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ky"><img src="../Images/9b13dd7d24f228057606d4f56d0def04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jRWtu-C3uNa55tWRDYJjuA.png"/></div></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">The response has a new chain added to the blockchain</figcaption></figure><p id="e8cd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">酷毙了。</p><p id="fd90" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们可以与区块链互动，但我们仍然只有一个用户。为了拥有多个对等点，我们将制作一个p2p服务器，并使用WebSockets连接这些对等点，允许每个对等点与其他对等点通信并传输数据。</p><p id="e9cf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我们启动我们的应用程序时，我们将连接到一些同行，当我们启动我们的应用程序时，我们将通过他们的地址。</p><h1 id="6b97" class="kz km ht bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">P2P服务器</h1><p id="1304" class="pw-post-body-paragraph iq ir ht is b it lw iv iw ix lx iz ja jb ly jd je jf lz jh ji jj ma jl jm jn hm dt translated">我们需要一个p2p服务器，以便分散网络中的不同对等点可以通过网络相互发送块、链、事务和其他消息。</p><p id="70fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了在node.js中实现p2p服务器，我们需要一个名为<code class="eh jx jy jz ka b">ws</code>的模块，这是一个轻量级且易于使用的网络套接字模块。还有各种其他模块可用，但为了简单起见，我们将坚持使用这个模块。</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="b575" class="kl km ht ka b fv kn ko l kp kq">npm i ws --save</span></pre><p id="9cbc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在app内，目录下创建一个文件<code class="eh jx jy jz ka b">p2p-server.js</code>。导入<code class="eh jx jy jz ka b">ws</code>模块，为服务器定义一个<code class="eh jx jy jz ka b">P2P_PORT</code>。像我们的HTTP服务器一样，我们可以使用环境变量从终端分配一个端口。</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="1070" class="kl km ht ka b fv kn ko l kp kq">const P2P_PORT = process.env.P2P_PORT || 5001;</span></pre><p id="07dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们需要一个列表<code class="eh jx jy jz ka b">peers </code>，当我们启动应用程序时，我们将连接到它。每个对等体都有一个这样的地址</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="ded8" class="kl km ht ka b fv kn ko l kp kq">PEERS = ws://localhost:5002 P2P_PORT=5001 HTTP_PORT=3001 npm run dev</span><span id="12de" class="kl km ht ka b fv kr ko l kp kq">const peers = process.env.PEERS ? process.env.PEERS.split(',') : [];</span></pre><p id="3951" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，我们可以将我们希望从终端连接到的对等点地址作为一个环境变量进行传递，并在以后访问我们的p2p服务器。</p><p id="9ae2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在让我们在p2p-server.js中创建一个P2pServer类，它将保存所有的消息处理程序和事件侦听器。</p><p id="b750" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">p2p服务器将有一个区块链变量，这将是我们在应用程序中使用的相同的区块链。因此，我们将传递一个区块链实例作为依赖项。我们的p2p服务器也有一个在给定时间内连接的套接字列表。</p><p id="bca3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们使用<code class="eh jx jy jz ka b">peers</code>列表通过遍历每个对等体并将其套接字连接对象保存在套接字列表中以备后用来连接对等体。</p><p id="af1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们实施我们到目前为止所讨论的。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kb kc l"/></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">P2pserver class</figcaption></figure><p id="0397" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我们的<code class="eh jx jy jz ka b">app/index.js</code>文件中，我们将创建p2pserver的实例，传递区块链实例，然后启动p2pserver。</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="f97d" class="kl km ht ka b fv kn ko l kp kq">const P2pServer = require('./p2p-server.js');</span><span id="d09d" class="kl km ht ka b fv kr ko l kp kq">const p2pserver = new P2pServer(blockchain);<br/>// passing blockchain as a dependency</span><span id="3f87" class="kl km ht ka b fv kr ko l kp kq">.<br/>.<br/>.<br/>.</span><span id="4539" class="kl km ht ka b fv kr ko l kp kq">p2pserver.listen(); // starts the p2pserver</span></pre><p id="04e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好了，现在让我们测试我们的p2p服务器。</p><p id="7629" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">启动终端，打开三个标签。在第一次选项卡运行中</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="be9a" class="kl km ht ka b fv kn ko l kp kq">npm run dev</span></pre><p id="3efc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在第二个</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="ba45" class="kl km ht ka b fv kn ko l kp kq">HTTP_PORT = 3002 P2P_PORT = 5002 PEERS = ws://localhost:5001 npm run dev</span></pre><p id="8c87" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在第三个</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="4931" class="kl km ht ka b fv kn ko l kp kq">HTTP_PORT = 3003 P2P_PORT = 5003 PEERS = ws://localhost:5002,ws://localhost:5001 npm run dev</span></pre><p id="8ab7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在第一个终端中，我们将得到输出</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="6687" class="kl km ht ka b fv kn ko l kp kq">Listening for peer to peer connection on port : 5001<br/>listening on port 3001<br/>Socket Connected<br/>Socket Connected</span></pre><p id="b2c1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在第二个终端中，我们将得到输出</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="068a" class="kl km ht ka b fv kn ko l kp kq">Listening for peer to peer connection on port : 5002<br/>listening on port 3002<br/>Socket Connected<br/>Socket Connected</span></pre><p id="0fda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在第一个终端中，我们将得到输出</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="7b0e" class="kl km ht ka b fv kn ko l kp kq">Listening for peer to peer connection on port : 5003<br/>listening on port 3003<br/>Socket Connected<br/>Socket Connected</span></pre><p id="26c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的插座现在互相连接了。</p><p id="a0f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">厉害！让我们使用这个P2P服务器来同步区块链，以构建一个完全分散的区块链网络。</p><p id="4b6d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们给p2p服务器添加一个消息处理程序。这个messageHandler函数将接受一个套接字作为参数。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kb kc l"/></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">I handle your messages</figcaption></figure><p id="f455" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们需要将这个处理程序分配给每个套接字。每次在<code class="eh jx jy jz ka b">connectSocket()</code>函数中建立新的连接时，我们都可以这样做。</p><p id="d19e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我们连接到对等体时，我们需要向它发送消息。因此，我们可以在连接上使用<code class="eh jx jy jz ka b">socket.send()</code>来这样做，我们希望将我们的链发送给对等体。因此，当我们连接到一个套接字时，我们将把链作为消息发送给它们。</p><p id="657d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="mb">注意:理想情况下，我们会发送块，因为链的大小非常大。但是为了简单起见，我们将发送整个链。</em></p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="2db8" class="kl km ht ka b fv kn ko l kp kq">connectSocket(socket){</span><span id="a8d5" class="kl km ht ka b fv kr ko l kp kq">// push the socket too the socket array<br/>        this.sockets.push(socket);<br/>        console.log("Socket connected");</span><span id="3c97" class="kl km ht ka b fv kr ko l kp kq">// register a message event listener to the socket<br/>        this.messageHandler(socket);</span><span id="10ed" class="kl km ht ka b fv kr ko l kp kq">// on new connection send the blockchain chain to the peer</span><span id="b4df" class="kl km ht ka b fv kr ko l kp kq">socket.send(JSON.stringify(this.blockchain));<br/>}</span></pre><p id="5f5a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您运行两个不同的应用程序，您会看到另一个对等体的链打印在第一个对等体的控制台上，反之亦然。这意味着我们的套接字正在正确地相互发送消息。</p><p id="7ff9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了使我们的链与对等体的链同步，我们可以检查接收到的链是否有效和更长。我们已经在区块链类中实现了这个功能。让我们在p2pserver类中使用<code class="eh jx jy jz ka b">replaceChain()</code>函数，当我们从一个对等点接收到一个链时。</p><p id="b949" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<code class="eh jx jy jz ka b">messageHandler(socket)</code>功能中添加</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="bb75" class="kl km ht ka b fv kn ko l kp kq">this.blockchain.replaceChain(data);</span></pre><p id="1071" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了让我们的生活更容易，我们将在我们的p2pserver中添加两个助手函数<code class="eh jx jy jz ka b">sendChain()</code>和<code class="eh jx jy jz ka b">syncChain()</code>。</p><p id="63d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh jx jy jz ka b">sendChain(socket)</code>将用于发送我们的链到一个套接字</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kb kc l"/></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">The chain sender</figcaption></figure><p id="6dc4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh jx jy jz ka b">syncChain(socket)</code>将在我们的索引文件中用来同步链</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kb kc l"/></div><figcaption class="kd ke fg fe ff kf kg bd b be z ek">The chain synchronizer</figcaption></figure><p id="8dc8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，在我们的app/index.js文件中，每当我们向链中添加一个新块时，我们都可以使用<code class="eh jx jy jz ka b">syncChain()</code>函数。</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="8273" class="kl km ht ka b fv kn ko l kp kq">app.post('mine',(req,res) =&gt; {<br/>    .<br/>    .<br/>    .<br/>    p2pserver.syncChain();<br/>}</span></pre><p id="ba3b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们为p2pserver编写的最终代码将类似于</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kb kc l"/></div></figure><p id="cb10" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通过启动两个应用程序实例来测试这个功能。在第一个应用程序中添加新块。</p><p id="02d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在打开第二个终端，您将看到控制台中打印的输出。</p><pre class="jp jq jr js fq kh ka ki kj aw kk dt"><span id="fe49" class="kl km ht ka b fv kn ko l kp kq">Listening for peer to peer connection on port : 5002<br/>listening on port 3002<br/>Socket Connected<br/>Replacing the current chain with new chain</span></pre><p id="2d51" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您可以通过使用第二个应用程序的get端点来确认这一点。您可以对第二个实例进行同样的尝试，第一个实例的链将被更长的更改所取代。</p><p id="bef4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">太好了！我们的区块链开始同步了。</p><p id="a683" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在下一部分中，我们将为我们的项目创建一个钱包。</p></div><div class="ab cl mc md hb me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hm hn ho hp hq"><p id="3a41" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="mb">感谢您的阅读。</em> <strong class="is hu"> <em class="mb">在下一部分中，我们将编写代码来验证区块链并添加对多节点的支持。</em> </strong> <em class="mb">希望你喜欢编码。如果你发现这很有帮助，请鼓掌。</em>T11】</p><p id="4ed5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您对区块链、以太坊或整个世界有任何疑问，请发表评论。:)</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><a href="http://bit.ly/2G71Sp7"><div class="fe ff mj"><img src="../Images/449450761cd76f44f9ae574333f9e9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKX2mtg7p1lOs7JmosPLsA.png"/></div></a></figure></div></div>    
</body>
</html>