<html>
<head>
<title>Part 5: Implementing Blockchain and Cryptocurrency with PoW consensus algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第5部分:用PoW共识算法实现区块链和加密货币</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/part-5-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-a7f8853d23dc?source=collection_archive---------2-----------------------#2018-10-28">https://medium.com/coinmonks/part-5-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-a7f8853d23dc?source=collection_archive---------2-----------------------#2018-10-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="3086" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在node.js中使用工作共识算法证明，小规模、易于理解、全面、逐步实施区块链和加密货币</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/ca1a2e2c4224dbbeb2b00eaca6e45a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*4tiX8RcB0DnrDZZ0l8yxGw.jpeg"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Source: <a class="ae ka" href="https://en.bitcoinwiki.org/wiki/Proof-of-work" rel="noopener ugc nofollow" target="_blank">Bitcoin Wiki</a></figcaption></figure><p id="8a7f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<a class="ae ka" rel="noopener" href="/coinmonks/part-4-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-9201eb7e8a41">之前的文章</a>中，我们创建了一个p2p服务器来创建一个分散的网络并发送数据。我们还添加了将链更新为最长链的功能。</p><p id="5c62" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这篇文章中，我们将改进我们的工作证明算法，并实现nonce和难度的概念。</p><p id="cb5f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们将完成我们的工作证明算法，并为其添加更多功能。之前，我们刚刚添加了创建新块和链接先前块的链的功能。在这里，我们将添加所谓的nonce和困难。</p><p id="e4e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">简单回顾一下，工作系统的证明是这样的，</p><p id="ccda" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于难度= 6的区块链中的块，块的散列应该具有等于难度的前导零。</p><p id="fbb1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">前导零等于难度的哈希是有效的哈希。</p><p id="2d76" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了生成新的散列，我们需要改变块中的一些值，以给出与以前不同的相应散列。为此，块中有一个名为nonce的变量。</p><p id="93b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">随机数与块数据一起用于生成新的块哈希，也存储在块中。挖掘器必须调整或增加随机数，并再次生成哈希，直到我们得到前导数字为0的哈希。</p><p id="e244" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这需要巨大的计算能力。这就是所谓的挖矿。</p><p id="bd74" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果我们降低难度，挖掘时间也会减少。比特币使用了动态难度的概念，即根据上一个区块调整当前区块的难度。</p><p id="a993" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们从在block.js文件中实现nonce值开始。</p><p id="f08a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在块的<code class="eh kb kc kd ke b">constructor()</code>和<code class="eh kb kc kd ke b">toString()</code>函数中添加随机数，在<code class="eh kb kc kd ke b">hash()</code>和<code class="eh kb kc kd ke b">blockHash()</code>函数中也添加随机数。最后，我们将在genesis函数中添加一个默认的nonce值0。</p><p id="beee" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们在<code class="eh kb kc kd ke b">mineBlock()</code>中做些改变，这里我们将创建一个局部变量nonce，并持续计算块哈希，直到前导零与难度匹配。</p><p id="3ab5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，为了访问难点，我们将使用一个<code class="eh kb kc kd ke b"> const DIFFICULTY</code>变量，并将其设置为4。</p><p id="44c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在让我们将循环添加到我们的<code class="eh kb kc kd ke b">mineBlock()</code>函数中。</p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="78ce" class="kj kk ht ke b fv kl km l kn ko">static mineBlock(lastBlock,data){</span><span id="a2ea" class="kj kk ht ke b fv kp km l kn ko">let hash;</span><span id="2de4" class="kj kk ht ke b fv kp km l kn ko">let timestamp;</span><span id="141f" class="kj kk ht ke b fv kp km l kn ko">const lastHash = lastBlock.hash;</span><span id="af0f" class="kj kk ht ke b fv kp km l kn ko">let { difficulty } = lastBlock;</span><span id="a8f8" class="kj kk ht ke b fv kp km l kn ko">let nonce = 0;</span><span id="c0b2" class="kj kk ht ke b fv kp km l kn ko">//generate the hash of the block</span><span id="d281" class="kj kk ht ke b fv kp km l kn ko">do {</span><span id="78e7" class="kj kk ht ke b fv kp km l kn ko">nonce++;</span><span id="5095" class="kj kk ht ke b fv kp km l kn ko">timestamp = Date.now();</span><span id="4f26" class="kj kk ht ke b fv kp km l kn ko">hash = Block.hash(timestamp,lastHash,data,nonce);</span><span id="3689" class="kj kk ht ke b fv kp km l kn ko">// checking if we have the required no of leading number of zeros</span><span id="905f" class="kj kk ht ke b fv kp km l kn ko">} while(hash.substring(0,<!-- -->DIFFICULTY<!-- -->) !== '0'.repeat(<!-- -->DIFFICULTY<!-- -->));</span><span id="8505" class="kj kk ht ke b fv kp km l kn ko">return new this(timestamp,lastHash,hash,data,nonce);</span><span id="f23c" class="kj kk ht ke b fv kp km l kn ko">}</span></pre><p id="efea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好吧。</p><p id="f6df" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们将编写一些代码来实现动态难度。我们可以通过降低当前块的难度来实现这一点。如果生成该块所用的时间超过了某个特定的时间，类似地，对于相反的情况，我们将增加它。</p><p id="2d9d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了检查之前的块生成是快还是慢，我们将创建一个名为<code class="eh kb kc kd ke b">MINE_RATE</code>的常数，它是创建块所需的额外时间(以毫秒为单位)。把这当作一个门槛。</p><p id="6480" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了保持代码的整洁，让我们将两个常量移到一个<code class="eh kb kc kd ke b">config.js </code>文件中，并要求它们进入<code class="eh kb kc kd ke b">block.js</code>文件。</p><p id="6e6d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于我们需要访问前一个块的难度，我们将在构造函数中添加一个默认值为<code class="eh kb kc kd ke b">DIFFICULTY</code>的难度，然后在<code class="eh kb kc kd ke b">toString()</code>、<code class="eh kb kc kd ke b">hash()</code>和<code class="eh kb kc kd ke b">blockHash()</code>函数中添加难度。</p><p id="53a1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将在mineBlock()函数中使用最后一个块的难度，并根据这个难度和时间戳调整难度。</p><pre class="jp jq jr js fq kf ke kg kh aw ki dt"><span id="7a6d" class="kj kk ht ke b fv kl km l kn ko">let { difficulty } = lastBlock;</span></pre><p id="6ea2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了调整难度，我们将调用函数<code class="eh kb kc kd ke b">adjustDifficulty(difficulty,currentTime)</code>，它将返回一个新的调整后的难度。因此，每次生成新的散列时，我们都必须不断地调用这个函数。因为当我们生成一个新的散列时，时间戳也会改变，所以我们也必须在我们的<code class="eh kb kc kd ke b">timestamp </code>变量中获得一个新的时间。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kq kr l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">dynamic difficulty</figcaption></figure><p id="3b7f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是最终的矿块功能的样子</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kq kr l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">the mine function</figcaption></figure><p id="46e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">总而言之，如果前一个块的生成花费了很多时间，那么我们的下一个块将会很快生成。此外，我们已经快速计算了前一个区块，我们当前的区块将需要更多的时间。</p><p id="ab80" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们通过制作一些测试案例来测试我们的现时性和难度。将这些添加到block.test.js中</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kq kr l"/></div></figure><p id="c5a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你运行这些测试，你将有12个测试通过。</p><p id="e768" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意，这一次测试将比以前运行得慢，这是由于我们刚刚实现的挖掘。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kq kr l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">The block class</figcaption></figure><p id="d662" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">非常酷！</p><p id="0210" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们已经完成了工作算法的验证。</p><p id="613d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在下一篇文章中，我们将在区块链中添加事务和事务池。</p><p id="a90e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae ka" rel="noopener" href="/coinmonks/part-6-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-87b274e86ce4">第六部分:用PoW共识算法实现区块链和加密货币</a></p></div><div class="ab cl ks kt hb ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hm hn ho hp hq"><p id="f8c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kz">感谢您的阅读。</em> <strong class="is hu"> <em class="kz">在下一部分中，我们将为事务创建一个类，并创建一个事务池来存储这些事务。</em> </strong> <em class="kz">希望你喜欢编码。如果你发现这很有帮助，请鼓掌。</em> </p><p id="4ed5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你对区块链、以太坊或整个世界有任何问题，请发表评论。:)</p><blockquote class="la"><p id="ffeb" class="lb lc ht bd ld le lf lg lh li lj jn ek translated"><a class="ae ka" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ll lm ln lo lp jt fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lk"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>