<html>
<head>
<title>K vs. Coq as Language Verification Frameworks (Part 1 of 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">k与Coq作为语言验证框架(第1部分，共3部分)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/k-vs-coq-as-language-verification-frameworks-part-1-of-3-19ff603b4e91?source=collection_archive---------3-----------------------#2019-12-12">https://medium.com/coinmonks/k-vs-coq-as-language-verification-frameworks-part-1-of-3-19ff603b4e91?source=collection_archive---------3-----------------------#2019-12-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="a7cd" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">作者:穆萨布·阿尔图基和布兰登·摩尔</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/97b561a4808b52b67f43900274233054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lKm1KotDDeEZ3Ay3.png"/></div></div></figure><p id="2004" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">形式验证程序，如验证区块链系统中的智能合同或验证嵌入式设备中的飞机飞行控制器，是确保正确性和增加系统可靠性的一种强有力的技术。在这种情况下，“为什么使用<a class="ae kq" href="http://www.kframework.org" rel="noopener ugc nofollow" target="_blank"> K </a>而不是<a class="ae kq" href="https://coq.inria.fr" rel="noopener ugc nofollow" target="_blank"> Coq </a>的问题？”在与可能不熟悉K，但之前听说过或使用过Coq的同事讨论K时，似乎经常出现。在这一系列的文章中，我们试图通过一个工作示例来强调K和Coq作为语言的正式验证框架的一些重要区别。我们希望向读者传达为什么我们认为K在这种情况下更合适。在我们继续之前，我们想指出，作为用户和库/框架开发人员，我们对Coq有丰富的经验。</p><p id="f7e1" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这一系列文章并不意味着对K和Coq进行基础的或详细的比较。事实上，这两个框架是非常不同的，并且是在不同的理念、目标和设计目标下开发的，针对不同的分析和验证方法。我们在这里关注一类特殊的应用程序，即验证用某种语言编写的程序，并通过这个镜头说明它们之间的差异。</p><h1 id="1bb3" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">运行时验证的k和Coq</h1><p id="3959" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">作为语言验证框架，<a class="ae kq" href="https://coq.inria.fr" rel="noopener ugc nofollow" target="_blank"> Coq </a>和<a class="ae kq" href="http://www.kframework.org" rel="noopener ugc nofollow" target="_blank"> K </a>都非常有能力，我们在<a class="ae kq" href="https://runtimeverification.com" rel="noopener ugc nofollow" target="_blank"> Runtime Verification </a>一直定期使用它们来提供我们的正式建模和验证服务。</p><p id="8cdf" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">最近基于K的开发的例子包括以太坊虚拟机<a class="ae kq" href="https://doi.org/10.1109/CSF.2018.00022" rel="noopener ugc nofollow" target="_blank"> KEVM </a>和捆绑在<a class="ae kq" href="https://runtimeverification.com/firefly/" rel="noopener ugc nofollow" target="_blank"> Firefly工具集</a>中的生成解释器和演绎验证器的语义，区块链语言<a class="ae kq" href="http://hdl.handle.net/2142/100320" rel="noopener ugc nofollow" target="_blank"> IELE </a>的完整定义，<a class="ae kq" href="https://github.com/runtimeverification/beacon-chain-spec" rel="noopener ugc nofollow" target="_blank">以太坊2.0信标链规范</a>的具体模型，以及<a class="ae kq" href="https://github.com/kframework/wasm-semantics" rel="noopener ugc nofollow" target="_blank">KWasm</a>:Web程序集<a class="ae kq" href="https://webassembly.org" rel="noopener ugc nofollow" target="_blank">的正式可执行语义</a>，等等。</p><p id="d937" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">运行时验证中一些最近基于Coq的开发(不一定是基于语言的验证)包括<a class="ae kq" href="https://arxiv.org/abs/1907.05523" rel="noopener ugc nofollow" target="_blank"> Algorand协议</a>的建模和验证其安全性，以及<a class="ae kq" href="https://github.com/runtimeverification/casper-proofs" rel="noopener ugc nofollow" target="_blank"> Casper </a>中以太坊终结机制的建模和验证。我们还在Coq中开发了独立于语言的程序验证框架，我们在这里使用它作为本帖中描述的工作示例，在这里<a class="ae kq" href="http://dx.doi.org/10.1007/978-3-319-89884-1_21" rel="noopener ugc nofollow" target="_blank">会有更详细的解释</a>。</p><h1 id="472d" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">工作示例</h1><p id="c6fb" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">因为我们在这里的目标是强调在使用K和Coq进行程序验证时的一些主要差异，所以我们使用一个非常简单但有意义的例子，它是下面的程序SUM，用一种我们称为IMP的命令式类C语言编写:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff lo"><img src="../Images/f60f170045ae5da95645605c710c056e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u77-W7kpYT9qCOtP.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek"><em class="lt">Our working example program SUM</em></figcaption></figure><p id="052d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们想要验证的关于SUM的一个重要属性是，在终止时，对于任何非负整数<code class="eh lu lv lw lx b">n</code>，变量<code class="eh lu lv lw lx b">sum</code>的值只能是(n + 1) n / 2(从1到<code class="eh lu lv lw lx b">n</code>的整数值之和)。我们使用这个验证示例来说明K和Coq作为语言框架是如何进行比较和对比的，并让读者感受一下每个框架在这个过程中所涉及的工作流。</p><p id="3348" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这个例子在K和Coq中的完整规范以及验证脚本都可以在<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="e902" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">我们需要什么</h1><p id="b358" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">无论我们选择使用哪种框架，通常都需要以下三个工件来验证程序的正确性:</p><ul class=""><li id="3c07" class="ly lz ht jw b jx jy ka kb kd ma kh mb kl mc kp md me mf mg dt translated">你想分析其程序的编程语言的语法和语义的正式模型。该模型需要是正式的，以便语法和语义被很好地定义和明确，并且使得它能够进行正式的推理。此外，它需要在一个抽象层次上，使得争论模型对语言的预期语义的忠实程度足够容易。本质上，从现在开始，L将被认为是IMP，而引用IMP构造的唯一方式是通过L。</li><li id="a3ff" class="ly lz ht jw b jx mh ka mi kd mj kh mk kl ml kp md me mf mg dt translated">待分析程序模型中的一种形式表示。这通常是程序结构的模型，如抽象语法树(AST)或某种语言的程序编码。有了支持工具(即可以生成适当规范的词法分析器和语法分析器)，它也可以是程序文本本身。</li><li id="524c" class="ly lz ht jw b jx mh ka mi kd mj kh mk kl ml kp md me mf mg dt translated">验证程序所依据的属性的规范。取决于用于验证的模型和底层形式逻辑，这可以是例如一个或多个时态逻辑公式、可达性逻辑断言、霍尔三元组中的前置条件和后置条件，或者一阶逻辑或其他逻辑形式中的公式。</li></ul><p id="65d4" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这对SUM来说意味着我们需要:</p><ul class=""><li id="9351" class="ly lz ht jw b jx jy ka kb kd ma kh mb kl mc kp md me mf mg dt translated">语言IMP的语义的正式模型，它精确地定义了语言的构造，如<code class="eh lu lv lw lx b">while</code>和赋值<code class="eh lu lv lw lx b">=</code>的含义(不考虑它们在程序中的使用位置)。</li><li id="09a5" class="ly lz ht jw b jx mh ka mi kd mj kh mk kl ml kp md me mf mg dt translated">程序和结构的精确说明。</li><li id="4441" class="ly lz ht jw b jx mh ka mi kd mj kh mk kl ml kp md me mf mg dt translated">一种形式化的性质，即计算出的值确实是从1到<code class="eh lu lv lw lx b">n</code>的整数之和。</li></ul><h1 id="8fc9" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">语言框架与传统程序验证器</h1><p id="b0f2" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">区分框架(如Coq和K)和传统的程序验证器是很有见地的。传统的程序验证器是为特定的编程语言制作的，比如针对C语言的<a class="ae kq" href="https://www.microsoft.com/en-us/research/project/vcc-a-verifier-for-concurrent-c/" rel="noopener ugc nofollow" target="_blank"> VCC </a>，针对可靠性的<a class="ae kq" href="https://github.com/microsoft/verisol" rel="noopener ugc nofollow" target="_blank"> Verisol </a>等。，这意味着所选择的语言语义L是硬连线在工具本身中的。此外，传统的程序验证器通常还提供特定于语言的机制来从程序本身中提取程序结构P，以及从对程序的用户友好的语法糖注释中提取规范S。这些使得程序验证器更容易使用，对用户更友好，但代价是该工具本质上受限于特定的编程语言(版本)和属性形式主义。对编程语言的任何改变，例如从一个版本迁移到下一个版本，或者对属性形式的任何改变，例如添加新的逻辑或断言构造，都需要整个程序验证工具本身由它的开发者或维护者更新，如果仍然可用的话，并且工具的用户等待直到这完成，然后切换到本质上新的工具。</p><p id="bd29" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">语言框架从根本上来说是不同的，因为工具本身的实现独立于它们所应用的语言。这种关注点的分离允许独立地开发和改进工具，同时将语言语义隔离为一个独立的形式工件，它本身是有价值的(例如，参见<a class="ae kq" href="https://jellopaper.org" rel="noopener ugc nofollow" target="_blank">EVM·杰洛帕</a>，它目前作为以太坊虚拟机语言的规范规范)。付出的代价是一种潜在的不太友好的正式符号。</p><p id="6af0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">因此，语言框架中的一般程序验证工作流主要由以下步骤组成:</p><ol class=""><li id="71d0" class="ly lz ht jw b jx jy ka kb kd ma kh mb kl mc kp mm me mf mg dt translated">正式定义语言结构(语法),并用它来说明程序p的结构。</li><li id="ac9b" class="ly lz ht jw b jx mh ka mi kd mj kh mk kl ml kp mm me mf mg dt translated">定义语言的形式语义，使用开发的语言模型L(语法和语义)探索程序的行为。</li><li id="627c" class="ly lz ht jw b jx mh ka mi kd mj kh mk kl ml kp mm me mf mg dt translated">指定属性S，并验证属性S对于L中的P成立，或者表明它不成立。</li></ol><p id="329b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这是三篇文章的第一部分。在第一部分的剩余部分，我们将展示如何在K和Coq中构建IMP和程序SUM的语法的正式模型(上述工作流的第一步)。定义IMP的语义和测试SUM的执行(第二步)在<a class="ae kq" rel="noopener" href="/@rv_inc/k-vs-coq-as-language-verification-frameworks-part-2-of-3-a98ce2592f65">第2部分</a>中解释。第三步，即指定和验证正确性属性，在<a class="ae kq" rel="noopener" href="/@rv_inc/k-vs-coq-as-language-verification-frameworks-part-3-of-3-ea12e26be516">第3部分</a>中描述。</p><h1 id="3149" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">定义IMP的语法</h1><p id="4504" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">定义一种语言的形式模型的第一步是定义它的句法结构。下面，我们定义语言IMP的语法。</p><h1 id="f1d2" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">K中的语法定义</h1><p id="5f4b" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">k的底层逻辑<a class="ae kq" href="http://matching-logic.org" rel="noopener ugc nofollow" target="_blank">是匹配逻辑</a>，但它包含了几个专门为定义语言而设计的特性。首先，编程语言语法可以用标准的、被广泛接受的BNF格式给出，还有结构和语义注释，比如结合性和求值顺序注释。例如，IMP的算术表达式是使用以下产生式规则定义的:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff lo"><img src="../Images/9ca3742e18759524c58f19eb27956ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yqp-RuCSE3QvQIVM.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek"><em class="lt">Syntax in K of IMP’s arithmetic expressions</em></figcaption></figure><p id="29a0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">规则为算术表达式指定了一个语法类别(使用<code class="eh lu lv lw lx b">syntax</code>关键字引入)。终端以双引号字符串的形式给出，而非终端以大写字母开头的名称给出。<code class="eh lu lv lw lx b">Int</code>和<code class="eh lu lv lw lx b">Id</code>分别是整数和标识符的非终结符。</p><p id="d6fb" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">使用了几个注释:<code class="eh lu lv lw lx b">&gt;</code>表示操作符之间的优先级，<code class="eh lu lv lw lx b">left</code>表示左关联二元操作符，<code class="eh lu lv lw lx b">strict</code>表示指定求值顺序。注释<code class="eh lu lv lw lx b">bracket</code>意味着圆括号<code class="eh lu lv lw lx b">(</code> <code class="eh lu lv lw lx b">)</code>仅用于分组表达式，不应该在解析树中为它们创建专用节点(更多细节参见<a class="ae kq" href="http://www.kframework.org/index.php/K_Tutorial" rel="noopener ugc nofollow" target="_blank"> K教程</a>)。注意，Coq不需要这些类型的注释，因为Coq不处理解析。</p><p id="6229" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">布尔表达式<code class="eh lu lv lw lx b">BExp</code>，如关系表达式，和程序语句<code class="eh lu lv lw lx b">Stmt</code>，如条件和循环结构，使用相似的产生式规则定义。</p><p id="9c08" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">最后，<code class="eh lu lv lw lx b">Pgm</code>是IMP中程序的语法类别，每个语法上有效的IMP程序，像上面的SUM一样，在这个规范中都有<code class="eh lu lv lw lx b">Pgm</code>作为它的分类(<code class="eh lu lv lw lx b">Ids</code>是一个标识符列表):</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff lo"><img src="../Images/dda014f993b899165b0228cceda028ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CNFgfxFx9u3nWQnu.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek"><em class="lt">Syntax in K of IMP programs</em></figcaption></figure><p id="524b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">因此，IMP中的程序由一系列变量声明和程序语句组成。</p><p id="a28c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">定义语言IMP语法的完整K模块可以在<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/k/imp.k#L4-L26" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="1fd4" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">Coq中的语法定义</h1><p id="f502" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">Coq的底层逻辑是<a class="ae kq" href="https://hal.inria.fr/hal-01094195/" rel="noopener ugc nofollow" target="_blank">归纳结构演算</a>。因此，要定义IMP，最自然的方法是使用归纳定义的数据类型指定IMP的语法，使用归纳定义的函数和关系指定其语义。</p><p id="fd89" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">例如，IMP中算术表达式的语法可以在Coq中使用下面的归纳类型声明来定义，该声明由关键字<code class="eh lu lv lw lx b">Inductive</code>引入(<code class="eh lu lv lw lx b">string</code>和<code class="eh lu lv lw lx b">Z</code>是Coq中的字符串和整数类型):</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff lo"><img src="../Images/d394dad3c5fe61f92754294134d1a17b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QPFxhVS5WheWjTrH.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek"><em class="lt">Syntax in Coq of IMP’s arithmetic expressions</em></figcaption></figure><p id="a3e4" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">一般来说，IMP中可以用来构建算术表达式的每个语言构造，例如变量，都是由指定其参数类型的类型<code class="eh lu lv lw lx b">AExp</code>中的构造函数捕获的。例如，变量由应用于字符串(变量名)的构造函数<code class="eh lu lv lw lx b">var</code>构造，而常量值由应用于整数的<code class="eh lu lv lw lx b">con</code>构造。使用这个定义，例如，表达式<code class="eh lu lv lw lx b">x + 2</code>由具有形式<code class="eh lu lv lw lx b">plus (var "x") (con 2)</code>的类型<code class="eh lu lv lw lx b">AExp</code>的Coq中的术语表示。</p><p id="b610" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">IMP中布尔表达式和语句的语法也有类似的定义，分别是归纳类型<code class="eh lu lv lw lx b">BExp</code>和<code class="eh lu lv lw lx b">Stmt</code>。例如，while循环语句<code class="eh lu lv lw lx b">while : BExp -&gt; Stmt -&gt; Stmt</code>的构造函数有两个参数:作为布尔表达式的条件和作为语句的循环体。</p><p id="f4a9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">类型为<code class="eh lu lv lw lx b">Pgm</code>的IMP程序由<code class="eh lu lv lw lx b">pgm</code>构建，它将一列字符串(被声明的变量)和程序语句作为参数:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff lo"><img src="../Images/d5a2a470feed2cab30106f0b2e931012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uS6fKinYpHPdUUjN.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek"><em class="lt">Syntax in Coq of IMP programs</em></figcaption></figure><p id="f322" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">IMP(抽象)语法的完整Coq定义可以在<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/coq/imp.v#L19-L42" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="0496" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">注意，将IMP程序编码成Coq中的术语对应于构建程序的解析树。然而，这种编码过程必须是手工的，因为Coq不提供将程序解析成归纳类型的特性(如K中的结合性或操作符优先注释)。此外，这些Coq术语(解析树)是纯语法的。在这个阶段，它们没有与之相关的语义信息。例如，在Coq中，没有K风格的简化来指定操作符的严格性或其他评估策略。</p><h1 id="9c56" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">以K和Coq表示的总和的规格</h1><p id="3946" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">用于指定IMP语法的K的BNF样式和所使用的注释能够将程序文本解析成明确定义程序结构的抽象语法树(AST)。因此，指定程序结构的繁重工作由K解析器自动负责，由BNF语法规范生成IMP。这意味着程序文本本身可以直接用于执行、验证，或者被任何其他K工具使用。下面，我们给程序文本的<code class="eh lu lv lw lx b">n</code>中的<code class="eh lu lv lw lx b">sum_pgm</code>参数起一个名字:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff lo"><img src="../Images/3e488b4195e09793cd18b4fd597db4de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vbe0f92EUIfZDYZU.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek"><em class="lt">K Definition of SUM</em></figcaption></figure><p id="46c0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">注意，上面的K规则是由关键字<code class="eh lu lv lw lx b">rule</code>引入的，它定义了应用于整数值的术语<code class="eh lu lv lw lx b">sum_pgm</code>的含义。例如，<code class="eh lu lv lw lx b">sum_pgm 100</code>是变量<code class="eh lu lv lw lx b">n</code>初始化为100的SUM程序。</p><p id="2f94" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">然而，在Coq中，程序文本(比如上面的SUM)不能直接使用，需要被解析成在Coq模型中有效的相应术语。对于像IMP和SUM这样的小型语言和程序，这个解析任务非常简单，但是对于更复杂的语言和更大的程序，这个过程通常需要开发外部解析器和Coq规范生成器，这可能是一个不小的任务。</p><p id="f2b7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在我们的Coq模型中，程序SUM作为类型为<code class="eh lu lv lw lx b">Pgm</code>的项具有以下表示形式，我们如上所述将其命名为<code class="eh lu lv lw lx b">sum_pgm</code>:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff lo"><img src="../Images/baf2ee0907796bcbafbe0a8db04f1541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BkVeofzzTUamUPeC.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek"><em class="lt">Coq Definition of SUM</em></figcaption></figure><p id="1594" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">构造函数<code class="eh lu lv lw lx b">seq</code>和<code class="eh lu lv lw lx b">assign</code>分别表示IMP中的排序和赋值语句(参见完整定义<a class="ae kq" href="https://github.com/runtimeverification/k-vs-coq-language-frameworks/blob/master/coq/imp.v#L1-L51" rel="noopener ugc nofollow" target="_blank">这里的</a>)。</p><h2 id="7a62" class="mn ks ht bd kt mo mp mq kx mr ms mt lb kd mu mv ld kh mw mx lf kl my mz lh na dt translated">接下来:语义…</h2><p id="6223" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">现在我们有了IMP语法的正式定义和SUM的正式表示，下一步是正式定义IMP的语义，并使用语义测试SUM的执行。这将在本帖的第二部分中描述。</p></div><div class="ab cl nb nc hb nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hm hn ho hp hq"><p id="3c50" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><em class="ni">原载于2019年12月12日</em><a class="ae kq" href="https://runtimeverification.com/blog/k-vs-coq-as-language-verification-frameworks-part-1-of-3/" rel="noopener ugc nofollow" target="_blank"><em class="ni">【https://runtimeverification.com】</em></a><em class="ni">。</em></p><blockquote class="nj"><p id="4a90" class="nk nl ht bd nm nn no np nq nr ns kp ek translated"><a class="ae kq" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nu nv nw nx ny jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nt"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff nz"><img src="../Images/a06b758bdcc47dca7c2504f298674d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_s6JsD3P0hVj32E7t9EtGg.jpeg"/></div></a></figure></div></div>    
</body>
</html>