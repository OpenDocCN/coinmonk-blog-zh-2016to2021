<html>
<head>
<title>Yield Farming Tutorial — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高产农业教程—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/yield-farming-tutorial-part-2-ea5b5254805d?source=collection_archive---------1-----------------------#2021-06-16">https://medium.com/coinmonks/yield-farming-tutorial-part-2-ea5b5254805d?source=collection_archive---------1-----------------------#2021-06-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="4eb3" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">使用Hardhat和Chai测试智能合约</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/6b9331533c10788bff819e9d5ec8983d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Exia2VquNMKBg5Mghi2C0Q.jpeg"/></div></div></figure><p id="3a6d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><em class="kq">*如果你错过了，</em> <a class="ae kr" rel="noopener" href="/coinmonks/yield-farming-tutorial-part-1-3fd5972ce717"> <em class="kq">产量农业教程—第一部分。</em> </a></p><h1 id="d0d7" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">介绍</h1><p id="fdc1" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">作为一名Solidity开发人员，你将花费大部分时间来测试你的合同。我将我的智能合同代码视为一篇论文。我创建的测试最终成为支持这个论点的证据。这种立场允许我确保我的逻辑的有效性，而不是仅仅让它工作。花时间在早期创建智能测试可以为您(和/或您的团队)免除未来的技术债务。</p><p id="18e8" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在我们开始使用Hardhat和Chai测试智能合约之前，我想建议您在编写代码时进行测试。出于本教程组织的目的，我选择将智能契约的编写和测试分开。当你编写单元测试函数时，它可以在未来为你节省大量的重构时间——我绝对可以证明这一点。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff lp"><img src="../Images/ef5b1d45c9df4a4aeb48cd07336a7b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRt95aaamFGwHKwoL4Rv0w.jpeg"/></div></div></figure><p id="924f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">前进！</p></div><div class="ab cl lq lr hb ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hm hn ho hp hq"><h1 id="1605" class="ks kt ht bd ku kv lx kx ky kz ly lb lc iz lz ja le jc ma jd lg jf mb jg li lj dt translated">设置</h1><p id="0d02" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">在您的根目录中，创建一个测试文件夹和一个测试文件:</p><p id="0b97" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh mc md me mf b">mkdir test</code></p><p id="3919" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh mc md me mf b">touch test/pmknFarm.test.ts</code></p><p id="e606" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">让我们看看我们的进口货:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="3daf" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">Hardhat已经包含了一个专门针对Hardhat运行时的Ethers库。我们从柴引进<em class="kq"> expect </em>作为我们的主要测试工具。因为我们用TypeScript声明类型，所以我们将包括来自Ethers库的<em class="kq">契约</em>和<em class="kq"> BigNumber </em>导入类型。我们将用SignerWithAddress声明owner、Alice和Bob的帐户。最后，我们将从<a class="ae kr" href="https://openzeppelin.com/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a>的测试助手导入时间。</p><p id="1f5e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">接下来，我们将声明常量变量:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="e2e6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">第一个<em class="kq">描述</em>作为测试实例的保护伞。在这些测试中，主人<em class="kq">和<em class="kq">虱子</em>以及<em class="kq">鲍勃</em>组成了我们的密码演员。我包含了<em class="kq"> res </em>(作为结果)来避免自己一遍又一遍地重新声明同一个变量。接下来是我们必需的合同。请注意，它们是以驼峰式格式声明的。最后，我们有<em class="kq"> daiAmount </em>用于资助演员的模拟Dai余额。</em></p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="29be" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在测试智能合约时，Chai允许许多不同的设置。我用的最多的两个包括<strong class="jw hu"> before() </strong>和<strong class="jw hu"> beforeEach() </strong>钩子<strong class="jw hu">。</strong>before each()钩子在每个测试用例之前执行整个代码块。这为较小的单元测试提供了很好的覆盖率。如果使用before()钩子，可以节省一些测试时间；因为，代码块在第一次测试之前只运行一次。此后的所有测试共享相同的状态。换句话说，如果你在测试用例#1中将5个ETH从Alice发送给Bob，并且不移动它，那么Bob在上面提到的初始<em class="kq">描述</em>伞内的所有后续测试用例中仍然持有这5个ETH。</p><p id="5170" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">首先，我们获取合同的合同工厂，并将它们存储在PascalCasing声明中。接下来，我们将部署的MockDai契约存储在<em class="kq"> mockDai中(</em>如前所述)并声明我们的签名者。因为我们使用的是本地的mockDai契约，所以我们可以为我们的演员铸造mDai来使用(代替真实的DAI)。最后，初始化pmknToken和pmknFarm协定。我们需要PmknFarm的构造函数中的MockDai和PmknToken协定地址；因此，请确保在pmknFarm实例之前部署这些组件。</p><p id="fb09" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们设置的最后一步包括创建一个TypeScript配置文件。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mi"><img src="../Images/5a58c53bd9340bbc90f747acbf4bbb95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iV3DoGDs6Dx21yiyOneTWQ.png"/></div></div></figure><p id="0e2c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果没有上述文件，您将会遇到一个错误，指出“chai”只能使用“esModuleInterop”标志默认导入。这与TypeScript中的假设缺陷有关。在<a class="ae kr" href="https://www.typescriptlang.org/tsconfig#esModuleInterop" rel="noopener ugc nofollow" target="_blank"> TS文档</a>中阅读关于此问题的更多信息。</p><p id="e1cc" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在项目根中，键入:<code class="eh mc md me mf b"><em class="kq">touch tsconfig.json</em></code></p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="3049" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在文件中插入这个JSON。</p><p id="6c52" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在，我们准备测试我们的代码。</p></div><div class="ab cl lq lr hb ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hm hn ho hp hq"><h1 id="f33c" class="ks kt ht bd ku kv lx kx ky kz ly lb lc iz lz ja le jc ma jd lg jf mb jg li lj dt translated"><strong class="ak">测试用例</strong></h1><h2 id="1832" class="mj kt ht bd ku mk ml mm ky mn mo mp lc kd mq mr le kh ms mt lg kl mu mv li mw dt translated">初始化</h2><p id="5514" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">让我们创建我们的第一个<em class="kq">描述</em>测试用例，并将其命名为<em class="kq">初始化</em>。在深入测试之前，我鼓励您确保测试设置的准确性。添加一个<em class="kq"> it </em>语句，然后测试契约部署是否没有错误。到目前为止，您的代码应该如下所示:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="dfd2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在项目根目录下的终端中，键入:<code class="eh mc md me mf b">npx hardhat test</code></p><p id="2c33" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果你设置正确，你应该看到绿色的多巴胺诱导词:<em class="kq">通过</em>。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mx"><img src="../Images/5d305d4c15e1a40dc174377ee87c168f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YAOcprqj1w0R0MfHYKZ50Q.png"/></div></div></figure><p id="ef1c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我通常按照功能组织我的测试——意思是，每个<em class="kq">描述</em>测试一个特定的功能和其中的副作用。我将提供一些必要的测试来帮助你开始。让我们从stake()函数开始。</p></div><div class="ab cl lq lr hb ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hm hn ho hp hq"><h2 id="ebcf" class="mj kt ht bd ku mk ml mm ky mn mo mp lc kd mq mr le kh ms mt lg kl mu mv li mw dt translated">木桩()</h2><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="cdb1" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们的<strong class="jw hu"> stake() </strong>测试用例中的第一个测试验证了我们的函数确实如预期的那样。第二个测试检查一个边缘案例——你应该<strong class="jw hu">总是</strong>测试什么。如果用户多次下注，总下注余额会反映正确的余额吗？最后，我们测试该函数是否准确地恢复。我鼓励你添加一些你自己的测试。一些想法:</p><ul class=""><li id="b776" class="my mz ht jw b jx jy ka kb kd na kh nb kl nc kp nd ne nf ng dt translated">it(“应无偿归还股份”)</li><li id="9f32" class="my mz ht jw b jx nh ka ni kd nj kh nk kl nl kp nd ne nf ng dt translated">it("应以零作为赌注金额来还原赌注")</li></ul><p id="e2b3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><em class="kq">*每次测试后记得运行</em> <code class="eh mc md me mf b"><em class="kq">npx hardhat test</em></code> <em class="kq">！</em></p></div><div class="ab cl lq lr hb ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hm hn ho hp hq"><h2 id="9c18" class="mj kt ht bd ku mk ml mm ky mn mo mp lc kd mq mr le kh ms mt lg kl mu mv li mw dt translated">拆分()</h2><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="22e8" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><strong class="jw hu"> unstake() </strong>函数没有提供太多需要注意的副作用。在这里，我们测试了在取消整个赌注金额时，余额恢复为零。我留了几个重要的测试给你自己做:</p><ul class=""><li id="f6ae" class="my mz ht jw b jx jy ka kb kd na kh nb kl nc kp nd ne nf ng dt translated">它(“在取消部分已下注余额时，应显示正确的余额”)</li><li id="bef3" class="my mz ht jw b jx nh ka ni kd nj kh nk kl nl kp nd ne nf ng dt translated">it("部分取消堆叠时，isStaking映射应等同于true ")</li></ul></div><div class="ab cl lq lr hb ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hm hn ho hp hq"><h2 id="2883" class="mj kt ht bd ku mk ml mm ky mn mo mp lc kd mq mr le kh ms mt lg kl mu mv li mw dt translated">撤回产量()</h2><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="1d74" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在我们的设置中，测试<strong class="jw hu"> WithdrawYield() </strong>函数需要一些额外的步骤。由于我们正在自动化PmknToken的发行，我们首先必须将所有权转移给PmknFarm契约。</p><p id="ae7d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们正在测试计算的产量，这需要时间来通过；因此，我们利用OpenZeppelin的<em class="kq">测试助手</em> <strong class="jw hu"> time() </strong>函数。这使得我们的智能合约能够进行时间旅行。time()函数将86400作为其参数(与calculateYieldTotal()函数中硬编码的86400相同)。在第一个测试中，我们验证了经过的总时间等于86400。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="bf8d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果您还记得最初的智能合约教程，我们给了calculateYieldTime()函数一个公共可见性。这就是为什么。</p><p id="00e0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在第二个测试中，我们通过使用TypeScript模拟计算来确保数学的有效性。此后，我们调用withdrawYield()函数并交叉检查PmknToken总供应量以及Alice的PmknToken余额是否等于相同的初始保证金。由于Solidity排除了浮点数(以及我们针对百分比的变通解决方案)，金额不会完全匹配；因此，我们将格式化后的结果设置为固定的浮点3。</p><p id="594d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">第三个测试检查用户未实现收益的准确性，当他们取消一些DAI时。</p></div><div class="ab cl lq lr hb ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hm hn ho hp hq"><h1 id="a781" class="ks kt ht bd ku kv lx kx ky kz ly lb lc iz lz ja le jc ma jd lg jf mb jg li lj dt translated">结论</h1><p id="fd62" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">本教程不应该被视为一个全面的测试列表；相反，我鼓励你以此为起点，不断扩展。DeFi中开发人员越多，协议就越强大。我希望这为您提供了一些价值，并增强了您的开发技能。这是我们检查过的累积测试:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="7c35" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果你有任何问题，一定要联系我。感谢您的阅读！</p><p id="d420" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><a class="ae kr" rel="noopener" href="/coinmonks/yield-farming-tutorial-part-3-53dd62bc7819">第3部分:使用Hardhat部署智能合约</a></p><blockquote class="nm nn no"><p id="729e" class="ju jv kq jw b jx jy iu jz ka kb ix kc np ke kf kg nq ki kj kk nr km kn ko kp hm dt translated">*非常感谢提示！<br/> ETH地址:0xd 300 faed 55 AE 89229 f7d 725 e0d 710551927 b5 b 15</p></blockquote><h2 id="0907" class="mj kt ht bd ku mk ml mm ky mn mo mp lc kd mq mr le kh ms mt lg kl mu mv li mw dt translated">也阅读</h2><ul class=""><li id="09fa" class="my mz ht jw b jx lk ka ll kd ns kh nt kl nu kp nd ne nf ng dt translated"><a class="ae kr" rel="noopener" href="/coinmonks/defi-future-10-promising-projects-in-the-defi-world-ff2b697ab006">顶级DeFi项目</a></li><li id="a2a3" class="my mz ht jw b jx nh ka ni kd nj kh nk kl nl kp nd ne nf ng dt translated">最好的以太坊<a class="ae kr" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">硬皮钱包</a></li></ul></div></div>    
</body>
</html>