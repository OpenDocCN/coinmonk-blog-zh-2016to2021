<html>
<head>
<title>Expressjs User Authentication with MetaMask &amp; meta-auth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用元掩码和元身份验证的Expressjs用户身份验证</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/expressjs-user-authentication-with-metamask-meta-auth-630b6da123ef?source=collection_archive---------0-----------------------#2018-02-25">https://medium.com/coinmonks/expressjs-user-authentication-with-metamask-meta-auth-630b6da123ef?source=collection_archive---------0-----------------------#2018-02-25</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="0956" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">去年三月，MetaMask的维护者Dan Finlay写了<a class="ae jo" rel="noopener" href="/metamask/the-new-secure-way-to-sign-data-in-your-browser-6af9dd2a1527">在你的浏览器</a>中签署数据的新的安全方法。</p><p id="682c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">他的代码示例对从服务器发送的消息进行签名和身份验证。这使得元掩码能够处理用户名和密码的用户验证。此外，使用元掩码创建用户帐户不需要个人识别信息。它与你的以太坊钱包具有相同的安全级别——因为它是一个以太坊钱包。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/6f528abda272dc7a6fbb931573b54855.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*Ajditq7CoiSbj9-2OPAO8w.png"/></div></figure><p id="915f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它是这样工作的。服务器生成询问消息。您的浏览器请求询问消息。MetaMask使用您的以太坊私钥对消息进行签名。服务器从签名的消息中重新创建以太坊地址。</p><p id="46d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这与以太坊交易的安全性相同。MetaMask对文本数据进行签名，而不是以太坊交易数据。就像你的私人密钥签署花费你的硬币一样，它签署它收到的服务器消息。该文本可以是随机的，服务条款或其他完全。</p><p id="c906" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用您的加密签名，服务器能够在您每次不使用用户名或密码访问时验证您是同一个唯一的用户。</p><p id="296d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你可以在<a class="ae jo" href="https://github.com/I-Gave/meta-auth" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>上找到<code class="eh jx jy jz ka b">meta-auth</code>的源代码。或者了解更多关于<a class="ae jo" href="https://www.npmjs.com/package/meta-auth" rel="noopener ugc nofollow" target="_blank"> npm </a>的信息。</p><p id="03f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它是这样工作的，</p><h1 id="73dc" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">后端</h1><p id="ad1b" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">首先，安装<code class="eh jx jy jz ka b">express</code>和<code class="eh jx jy jz ka b">meta-auth</code></p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="f9ba" class="li kc ht ka b fv lj lk l ll lm">$ npm install express meta-auth</span></pre><p id="dd67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">初始化两个模块</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="573d" class="li kc ht ka b fv lj lk l ll lm">const express = require('express');</span><span id="1737" class="li kc ht ka b fv ln lk l ll lm">const MetaAuth = require('meta-auth');</span><span id="55bd" class="li kc ht ka b fv ln lk l ll lm">const app = express();</span><span id="57eb" class="li kc ht ka b fv ln lk l ll lm">const metaAuth = MetaAuth();</span></pre><p id="69db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">默认情况下，<code class="eh jx jy jz ka b">meta-auth</code>将观察三个路线参数</p><ol class=""><li id="5dcb" class="lo lp ht is b it iu ix iy jb lq jf lr jj ls jn lt lu lv lw dt translated">MetaAddress —用于发布地址的质询消息。</li><li id="98d2" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw dt translated">元消息—客户端返回的质询消息。</li><li id="268f" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw dt translated">元签名-已签名的质询与元消息一起返回。</li></ol><p id="39b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">初始化<code class="eh jx jy jz ka b">meta-auth</code>时，这些参数名称是可配置的</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="3d95" class="li kc ht ka b fv lj lk l ll lm">const metaAuth = require('meta-auth')({</span><span id="71b9" class="li kc ht ka b fv ln lk l ll lm">  message: 'msg',</span><span id="adb3" class="li kc ht ka b fv ln lk l ll lm">  signature: 'sig',</span><span id="45ac" class="li kc ht ka b fv ln lk l ll lm">  address: 'address'</span><span id="4a67" class="li kc ht ka b fv ln lk l ll lm">});</span></pre><p id="b67a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">包括metaAuth中间件。第一个函数发出一个以太坊地址的挑战。如果指定了:MetaAddress路由参数，中间件将创建具有<code class="eh jx jy jz ka b">challenge</code>属性的<code class="eh jx jy jz ka b">req.metaAuth</code>对象。</p><p id="148f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">第二个验证消息签名，并为<code class="eh jx jy jz ka b">req.metaAuth</code>提供一个<code class="eh jx jy jz ka b">recovered</code>属性。如果地址被恢复，服务器具有密码证明该地址属于用户。让他们登录是安全的。</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="6a28" class="li kc ht ka b fv lj lk l ll lm">app.get('/auth/:MetaAddress', metaAuth, (req, res) =&gt; {</span><span id="8c11" class="li kc ht ka b fv ln lk l ll lm">  // Request a message from the server</span><span id="d528" class="li kc ht ka b fv ln lk l ll lm">  res.send(req.metaAuth.challenge)</span><span id="d316" class="li kc ht ka b fv ln lk l ll lm">});</span><span id="6ebe" class="li kc ht ka b fv ln lk l ll lm">app.get('/auth/:MetaMessage/:MetaSignature', metaAuth, (req, res) =&gt; {</span><span id="460d" class="li kc ht ka b fv ln lk l ll lm">  if (req.metaAuth.recovered) {</span><span id="d31d" class="li kc ht ka b fv ln lk l ll lm">    // Signature matches the cache address/challenge</span><span id="35f4" class="li kc ht ka b fv ln lk l ll lm">    // Authentication is valid, assign JWT, etc.</span><span id="4d75" class="li kc ht ka b fv ln lk l ll lm">    res.send(req.metaAuth.recovered);</span><span id="5a29" class="li kc ht ka b fv ln lk l ll lm">  } else {</span><span id="26da" class="li kc ht ka b fv ln lk l ll lm">    // Sig did not match, invalid authentication</span><span id="d070" class="li kc ht ka b fv ln lk l ll lm">    res.status(500).send();</span><span id="6625" class="li kc ht ka b fv ln lk l ll lm">  };</span><span id="bfb7" class="li kc ht ka b fv ln lk l ll lm">});</span></pre><p id="250b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面是引擎盖下发生的事情</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="b5e8" class="li kc ht ka b fv lj lk l ll lm">function createChallenge (address) {</span><span id="aec3" class="li kc ht ka b fv ln lk l ll lm">  const hash = crypto.createHmac('sha256', secret)</span><span id="26b3" class="li kc ht ka b fv ln lk l ll lm">    .update(address + uuidv4())</span><span id="3c18" class="li kc ht ka b fv ln lk l ll lm">    .digest('hex');</span><span id="7ddc" class="li kc ht ka b fv ln lk l ll lm">  cache.set(address, hash);</span><span id="0dce" class="li kc ht ka b fv ln lk l ll lm">  return hash;</span><span id="947b" class="li kc ht ka b fv ln lk l ll lm">}</span></pre><p id="7abb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，客户机将其地址发送给服务器。它创建地址和uuidv4的盐散列。它缓存地址/挑战对，以便以后查找。</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="ad18" class="li kc ht ka b fv lj lk l ll lm">function checkChallenge(challenge, sig) {</span><span id="2bc6" class="li kc ht ka b fv ln lk l ll lm">  const data = [{</span><span id="78a7" class="li kc ht ka b fv ln lk l ll lm">    type: 'string',</span><span id="8bc0" class="li kc ht ka b fv ln lk l ll lm">    name: 'challenge',</span><span id="4afe" class="li kc ht ka b fv ln lk l ll lm">    value: challenge</span><span id="cebd" class="li kc ht ka b fv ln lk l ll lm">  }]</span><span id="43e4" class="li kc ht ka b fv ln lk l ll lm">  const recovered = sigUtil.recoverTypedSignature({</span><span id="7e59" class="li kc ht ka b fv ln lk l ll lm">    data,</span><span id="da17" class="li kc ht ka b fv ln lk l ll lm">    sig</span><span id="c036" class="li kc ht ka b fv ln lk l ll lm">  });</span><span id="3446" class="li kc ht ka b fv ln lk l ll lm">  const storedChallenge = cache.get(recovered);</span><span id="cd7a" class="li kc ht ka b fv ln lk l ll lm">  if (storedChallenge === challenge) {</span><span id="f1a0" class="li kc ht ka b fv ln lk l ll lm">    cache.del(recovered);</span><span id="26f8" class="li kc ht ka b fv ln lk l ll lm">    return recovered;</span><span id="c28c" class="li kc ht ka b fv ln lk l ll lm">  }</span><span id="e51f" class="li kc ht ka b fv ln lk l ll lm">  return false;</span><span id="287e" class="li kc ht ka b fv ln lk l ll lm">}</span></pre><p id="db60" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">挑战和签名返回给服务器。它从签名中恢复地址。然后确保质询是针对地址的。然后从高速缓存中移除数据并返回恢复的地址。</p><p id="f271" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">返回快速验证路线</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="7a43" class="li kc ht ka b fv lj lk l ll lm">app.get('/auth/:MetaMessage/:MetaSignature', metaAuth, (req, res) =&gt; {</span><span id="4e91" class="li kc ht ka b fv ln lk l ll lm">  if (req.metaAuth.recovered) {</span><span id="dec1" class="li kc ht ka b fv ln lk l ll lm">    // Signature matches the cache address/challenge</span><span id="e658" class="li kc ht ka b fv ln lk l ll lm">    // Authentication is valid, assign JWT, etc.</span><span id="ce49" class="li kc ht ka b fv ln lk l ll lm">    res.send(req.metaAuth.recovered);</span><span id="2ac5" class="li kc ht ka b fv ln lk l ll lm">  } else {</span><span id="076a" class="li kc ht ka b fv ln lk l ll lm">    // Sig did not match, invalid authentication</span><span id="af67" class="li kc ht ka b fv ln lk l ll lm">    res.status(400).send();</span><span id="785e" class="li kc ht ka b fv ln lk l ll lm">  };</span><span id="274f" class="li kc ht ka b fv ln lk l ll lm">});</span></pre><p id="ad57" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果找到了<code class="eh jx jy jz ka b">recovered</code>属性，<code class="eh jx jy jz ka b">meta-auth</code>成功地从消息签名中恢复了地址。</p><p id="c717" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从这里，启动用户的会话，分配一个JWT，让他们访问他们的数据，无论你想做什么。</p><h1 id="a419" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">前端</h1><p id="3e59" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">至此，您已经知道客户机将向服务器发出两个请求</p><ol class=""><li id="4c03" class="lo lp ht is b it iu ix iy jb lq jf lr jj ls jn lt lu lv lw dt translated">接收基于以太坊地址的挑战</li><li id="7199" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw dt translated">用签名返回挑战。</li></ol><p id="ce69" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是针对服务器的，但是客户端需要在这期间第三次调用它的web3提供者。</p><p id="45e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">(代码可以在<a class="ae jo" href="https://github.com/I-Gave/meta-auth/tree/master/examples" rel="noopener ugc nofollow" target="_blank">这里找到</a>)</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="29a8" class="li kc ht ka b fv lj lk l ll lm">$.get('http://localhost:3000/auth/' + web3.eth.accounts[0], (res) =&gt;   {</span><span id="267c" class="li kc ht ka b fv ln lk l ll lm">  challenge = [{</span><span id="8756" class="li kc ht ka b fv ln lk l ll lm">    type: 'string',</span><span id="5c3a" class="li kc ht ka b fv ln lk l ll lm">    name: 'challenge',</span><span id="2236" class="li kc ht ka b fv ln lk l ll lm">    value: res</span><span id="4007" class="li kc ht ka b fv ln lk l ll lm">  }];</span><span id="27c1" class="li kc ht ka b fv ln lk l ll lm">  const from = web3.eth.accounts[0];</span><span id="a521" class="li kc ht ka b fv ln lk l ll lm">  const params = [challenge, from];</span><span id="6293" class="li kc ht ka b fv ln lk l ll lm">  const method = 'eth_signTypedData';</span><span id="410a" class="li kc ht ka b fv ln lk l ll lm">  web3.currentProvider.sendAsync({</span><span id="8cee" class="li kc ht ka b fv ln lk l ll lm">    method,</span><span id="dc7a" class="li kc ht ka b fv ln lk l ll lm">    params,</span><span id="4753" class="li kc ht ka b fv ln lk l ll lm">    from</span><span id="7746" class="li kc ht ka b fv ln lk l ll lm">  }, async (err, result) =&gt; {</span><span id="bf84" class="li kc ht ka b fv ln lk l ll lm">    signature = result.result;</span><span id="7d27" class="li kc ht ka b fv ln lk l ll lm">    if (err) {</span><span id="2e8d" class="li kc ht ka b fv ln lk l ll lm">      return console.error(err);</span><span id="b2a6" class="li kc ht ka b fv ln lk l ll lm">    }</span><span id="a844" class="li kc ht ka b fv ln lk l ll lm">  if (result.error) {</span><span id="952b" class="li kc ht ka b fv ln lk l ll lm">    return console.error(result.error);</span><span id="d9ad" class="li kc ht ka b fv ln lk l ll lm">  }</span><span id="1f7f" class="li kc ht ka b fv ln lk l ll lm">  $('.signature').text(signature);</span><span id="6617" class="li kc ht ka b fv ln lk l ll lm">  });</span><span id="9ba4" class="li kc ht ka b fv ln lk l ll lm">});</span></pre><p id="9ac4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从服务器接收质询，MetaMask将处理sendAsync调用以签署所提供的质询。</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="08b8" class="li kc ht ka b fv lj lk l ll lm">$.get('http://localhost:3001/auth/' + challenge[0].value + '/' + signature, (res) =&gt; {</span><span id="dde5" class="li kc ht ka b fv ln lk l ll lm">  if (res === web3.eth.accounts[0]) {</span><span id="f35d" class="li kc ht ka b fv ln lk l ll lm">    $('.success').show();</span><span id="55c4" class="li kc ht ka b fv ln lk l ll lm">  } else {</span><span id="091f" class="li kc ht ka b fv ln lk l ll lm">    $('.fail').show(); </span><span id="b0e4" class="li kc ht ka b fv ln lk l ll lm">  }</span><span id="b90c" class="li kc ht ka b fv ln lk l ll lm">});</span></pre><p id="3bde" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了验证，客户端返回相同的挑战和他们的签名。如果服务器响应与用户的以太坊地址匹配，则认证成功。</p><blockquote class="mc"><p id="7c89" class="md me ht bd mf mg mh mi mj mk ml jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mn mo mp mq mr ju fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mm"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><p id="8ea3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你可以在<a class="ae jo" href="https://github.com/I-Gave/meta-auth" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>上找到<code class="eh jx jy jz ka b">meta-auth</code>的源代码。或者了解更多关于<a class="ae jo" href="https://www.npmjs.com/package/meta-auth" rel="noopener ugc nofollow" target="_blank"> npm </a>的信息</p></div></div>    
</body>
</html>