<html>
<head>
<title>Part 6: Implementing Blockchain and Cryptocurrency with PoW consensus algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第6部分:用PoW共识算法实现区块链和加密货币</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/part-6-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-87b274e86ce4?source=collection_archive---------0-----------------------#2018-10-29">https://medium.com/coinmonks/part-6-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-87b274e86ce4?source=collection_archive---------0-----------------------#2018-10-29</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="3086" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在node.js中使用工作共识算法证明，小规模、易于理解、全面、逐步实施区块链和加密货币</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/ca1a2e2c4224dbbeb2b00eaca6e45a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*4tiX8RcB0DnrDZZ0l8yxGw.jpeg"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Source: <a class="ae ka" href="https://en.bitcoinwiki.org/wiki/Proof-of-work" rel="noopener ugc nofollow" target="_blank">Bitcoin Wiki</a></figcaption></figure><p id="131a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">到目前为止，我们已经创建了我们的区块链和p2p服务器，这就完成了区块链。在这一部分，我们将创建事务。</p><p id="57ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，我们将在刚刚创建的区块链上制作一种加密货币。还记得块中的数据字段吗？这就是交易进行的地方。</p><p id="2a0f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了创造一种加密货币，我们需要一个钱包。钱包将有两个密钥，即公钥和一个对应的私钥。公钥/私钥对是不对称加密的一部分，我们将使用它来创建数字签名。</p><p id="3c43" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">数字签名允许用户验证创建区块和交易的矿工。一旦使用私钥对数据进行了签名/加密，就只能使用公钥对其进行验证/解密。</p><p id="76b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kb">注意:公钥是网络已知的，私钥是矿工私有的。</em></p><p id="50e4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我们继续之前，让我们了解一下区块链中的事务是如何工作的。</p><p id="6f37" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">交易是脚本的集合，指示哪个人向谁发送多少钱。</p><p id="490e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在区块链，事务主要有两个脚本，输入脚本和输出脚本。</p><p id="b91d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">输入脚本包括时间戳、发送者的余额和发送者的公钥。</p><p id="f8bc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">输出脚本包括我们希望发送给发送者的金额和发送者的公钥</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff kc"><img src="../Images/05dece63cc928db34866e4387d0117a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v0rncYIUkaW0RQ9lWHbO3Q.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">A basic transaction</figcaption></figure><p id="73dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这个图中，我们在左边有一个交易，发送方0xfoo1有一个余额500，发送40到0xbar2。但是还有另一个输出脚本，它是针对发送者本身的。注意，输出脚本中的金额总和等于输入脚本中提到的余额。这里真正发生的是，发送者将他所有的货币发送到一个交易中，交易的一部分，即第一个输出脚本到达接收者，第二个返回发送者。最初，他可能会发送他的全部余额，但后来他会收到与他发送的差额相等的货币。</p><p id="e489" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Miner使用这些输出脚本来确定自己的余额，然后使用更新后的余额来创建新的输入脚本。</p><p id="d433" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用这些输出脚本，可以验证输入脚本中矿工的平衡是否正确。他们只需将输出脚本中的金额相加，并与输入脚本中的金额进行比较。</p><p id="db85" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好吧，让我们创建一个钱包。</p><p id="6795" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在根目录中创建一个单独的文件夹wallet，并添加一个<code class="eh kh ki kj kk b">index.js</code>文件，我们将在其中创建我们的wallet类。</p><p id="7fc0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的钱包将有3个主要属性，余额、密钥对和公钥。测试我们的应用程序将从500英镑的初始余额开始。为了简洁地做到这一点，让我们在<code class="eh kh ki kj kk b">config.js</code>中添加一个常量，并将其命名为<code class="eh kh ki kj kk b">INITIAL_BALANCE</code>，并在我们的wallet类中要求这样做。</p><h2 id="d9d4" class="kl km ht bd kn ko kp kq kr ks kt ku kv jb kw kx ky jf kz la lb jj lc ld le lf dt translated">钱包</h2><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="lg lh l"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">The wallet</figcaption></figure><p id="1bac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了创建一个密钥对(公钥和私钥),我们将使用一个叫做椭圆的模块。让我们安装它。</p><pre class="jp jq jr js fq li kk lj lk aw ll dt"><span id="0563" class="kl km ht kk b fv lm ln l lo lp">npm i elliptic --save</span></pre><p id="073d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们在根目录下创建一个名为<code class="eh kh ki kj kk b">chain-util.js</code>的新文件，它将保存与加密货币相关的函数。我们将使用刚刚安装的这个模块，我们将在我们的应用程序中使用基于<code class="eh kh ki kj kk b">ec</code>曲线的算法。所以在chainUtil.js中需要来自椭圆的ec算法，并使用<code class="eh kh ki kj kk b">secp256k1</code>创建一个实例，因为比特币使用的是相同的。</p><pre class="jp jq jr js fq li kk lj lk aw ll dt"><span id="9a55" class="kl km ht kk b fv lm ln l lo lp">const EC = require('elliptic').ec;<br/>const ec = new EC('secp256k1');</span><span id="d0f8" class="kl km ht kk b fv lq ln l lo lp">// secp256k1 is the algorithm to generate key pair</span></pre><p id="bdd1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们在<code class="eh kh ki kj kk b">chainUtil </code>类中创建一个函数，我们将在应用程序中使用它来生成密钥对。</p><pre class="jp jq jr js fq li kk lj lk aw ll dt"><span id="eb62" class="kl km ht kk b fv lm ln l lo lp">class ChainUtil{</span><span id="9dc5" class="kl km ht kk b fv lq ln l lo lp">static genKeyPair(){<br/>        return ec.genKeyPair();<br/>    }<br/>}</span><span id="ca7a" class="kl km ht kk b fv lq ln l lo lp">module.exports = ChainUtil;</span></pre><p id="20b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们可以在我们的wallet类中使用这个函数，并使用<code class="eh kh ki kj kk b">getPublic()</code>函数来获取public并将它编码成十六进制格式。</p><pre class="jp jq jr js fq li kk lj lk aw ll dt"><span id="cdc6" class="kl km ht kk b fv lm ln l lo lp">this.keyPair = ChainUtil.genKeyPair();</span><span id="a751" class="kl km ht kk b fv lq ln l lo lp">this.publicKey = this.keyPair.getPublic().encode('hex');</span></pre><p id="1779" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每笔交易都需要一个唯一的id。为了生成这些唯一的数字，我们将使用一个名为<code class="eh kh ki kj kk b">uuid</code>的模块</p><pre class="jp jq jr js fq li kk lj lk aw ll dt"><span id="d389" class="kl km ht kk b fv lm ln l lo lp">npm i uuid --save</span></pre><p id="e480" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们在chain-util.js文件中创建这个模块的一个实例。</p><pre class="jp jq jr js fq li kk lj lk aw ll dt"><span id="051e" class="kl km ht kk b fv lm ln l lo lp">const uuidV1 = require('uuid/v1');</span><span id="7359" class="kl km ht kk b fv lq ln l lo lp">// version 1 use timestamp to generate unique ids</span></pre><p id="d111" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们创建一个函数来生成id。</p><pre class="jp jq jr js fq li kk lj lk aw ll dt"><span id="0be8" class="kl km ht kk b fv lm ln l lo lp">static id(){<br/>        return uuidV1();<br/>}</span></pre><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="1f2f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好吧。有了惟一的id，我们现在可以创建我们的事务类。</p><p id="8eb2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们在wallet目录中创建一个文件transaction.js。我们需要一个chainUtil类的实例。</p><p id="67b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将用id、输入和输出作为属性进行类事务。</p><pre class="jp jq jr js fq li kk lj lk aw ll dt"><span id="a09f" class="kl km ht kk b fv lm ln l lo lp">const ChainUtil = require('../chain-util');</span><span id="df4b" class="kl km ht kk b fv lq ln l lo lp">class Transaction{<br/>    constructor(){<br/>        this.id = ChainUtil.id();<br/>        this.input = null;<br/>        this.outputs = [];<br/>    }<br/>}</span><span id="8cf2" class="kl km ht kk b fv lq ln l lo lp">module.exports = Transaction;</span></pre><p id="19b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">输入将是一个对象，输出可以是多个，所以它的对象数组。</p><p id="cbc5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们创建一个函数来创建一个事务。这个函数将接收发送者的钱包实例、发送的金额和接收者的地址。</p><p id="b955" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它将检查发送方是否有足够的余额，然后在输出数组中推送一个输出脚本。输出脚本将包含收款人的金额和地址。</p><pre class="jp jq jr js fq li kk lj lk aw ll dt"><span id="60bf" class="kl km ht kk b fv lm ln l lo lp">static newTransaction(senderWallet,recipient,amount){</span><span id="01da" class="kl km ht kk b fv lq ln l lo lp">if(amount &gt; senderWallet.balance){<br/>            console.log(`Amount : ${amount} exceeds the balance`);<br/>            return;<br/>        }</span><span id="378f" class="kl km ht kk b fv lq ln l lo lp">// call to the helper function that creates and signs the<br/>// transaction outputs</span><span id="f876" class="kl km ht kk b fv lq ln l lo lp">return transaction.outputs.push(...[<br/>            {amount: senderWallet.balance -amount,address:<br/>             senderWallet.publicKey},<br/>            {amount: amount,address: recipient}<br/>        ]);<br/>}</span></pre><p id="9154" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的事务现在需要一个输入对象。我们将使用wallets密钥对对交易进行签名，并将签名和其他相关信息一起添加到输入对象中。</p><p id="db83" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们在<code class="eh kh ki kj kk b">wallet/index.js</code>文件中添加一个符号函数</p><pre class="jp jq jr js fq li kk lj lk aw ll dt"><span id="aa29" class="kl km ht kk b fv lm ln l lo lp">sign(dataHash){</span><span id="7ac5" class="kl km ht kk b fv lq ln l lo lp">return this.keyPair.sign(dataHash);</span><span id="3316" class="kl km ht kk b fv lq ln l lo lp">}</span></pre><p id="23f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我们创建一个新的事务时，我们将在<code class="eh kh ki kj kk b">transaction.js</code>文件中使用这个函数。让我们在transaction类中添加一个名为<code class="eh kh ki kj kk b">signTransaction()</code>的函数。该函数将获取transaction和senders wallet的实例，并在transaction中创建一个签名输入。</p><p id="eebc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意，我们多次使用散列函数。我们可以将其抽象成chain-util.js，使我们的代码更加可重用。让我们在<code class="eh kh ki kj kk b">chainUtil</code>中创建一个<code class="eh kh ki kj kk b">hash(data)</code>函数并使用它，而不是直接使用<code class="eh kh ki kj kk b">SHA256</code></p><pre class="jp jq jr js fq li kk lj lk aw ll dt"><span id="a2af" class="kl km ht kk b fv lm ln l lo lp">static hash(data){</span><span id="c63f" class="kl km ht kk b fv lq ln l lo lp">    return SHA256(JSON.stringify(data)).toString();</span><span id="2077" class="kl km ht kk b fv lq ln l lo lp">}</span></pre><p id="9e45" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们也在block.js文件中进行这些更改。</p><p id="8ac0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好的，接下来我们将在transaction.js中创建<code class="eh kh ki kj kk b">signTransaction(senderWallet,transaction)</code>函数</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="a3b3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在在<code class="eh kh ki kj kk b">newTranasaction()</code>函数中，我们可以用参数调用<code class="eh kh ki kj kk b">signTransaction()</code>作为当前交易和发送者的钱包。</p><p id="0e71" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还需要验证交易真实性的功能。</p><p id="f251" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们创建一个验证事务函数，它将验证事务的散列和数字签名。</p><p id="c96a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了验证一个签名，我们需要使用公钥解密它。<code class="eh kh ki kj kk b">ec</code>内置了这一功能。让我们在chainUitl类中创建一个函数verifySignature()，我们稍后将使用它。</p><pre class="jp jq jr js fq li kk lj lk aw ll dt"><span id="c581" class="kl km ht kk b fv lm ln l lo lp">static verifySignature(publicKey,signature,dataHash){</span><span id="8546" class="kl km ht kk b fv lq ln l lo lp">return ec.keyFromPublic(publicKey,'hex').verify(dataHash,signature);</span><span id="b3f4" class="kl km ht kk b fv lq ln l lo lp">}</span></pre><p id="e65e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，在Transaction类中，让我们创建一个名为<code class="eh kh ki kj kk b">verifyTransaction()</code>的函数，其中我们将使用刚刚创建的verifySignature函数。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="8636" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">酷毙了。</p><p id="45df" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还有一件事要做。想象一个场景，您在系统中进行了一个事务，但是它还没有被发送或添加到一个块中(<em class="kb">这意味着它存在于事务池中)。与此同时，你与其他人进行了另一笔交易，但这次你创建了一笔不同的交易。请注意，我们已经有一个尚未发送的事务，我们可以通过更新输出和重新生成签名来优化流程。</em></p><p id="568c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们将创建一个update()函数，该函数将找到发送者的输出，更新金额，创建一个新的输出，并对更新后的事务进行签名。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="033e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">太棒了。</p><p id="4387" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是我们到目前为止创建的transaction.js文件。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="0fe3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们测试一下我们的钱包和交易。在wallet目录中创建一个transaction . test . js文件，并添加一些测试用例。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="4f79" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行jest测试运行程序，现在您将看到20个测试通过。厉害！</p><p id="89b4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们已经在我们的区块链中实现了事务。</p><p id="6dea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在下一篇文章中，我们将在区块链中添加事务池。</p><p id="97f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae ka" rel="noopener" href="/coinmonks/part-7-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-bf9a16063ec1">第七部分:用PoW共识算法实现区块链和加密货币</a></p></div><div class="ab cl lr ls hb lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hm hn ho hp hq"><p id="4722" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kb">感谢您的阅读。</em> <strong class="is hu"> <em class="kb">在下一部分中，我们将为事务轮询创建一个类，在其中存储所有尚未添加到块中的事务。</em> </strong> <em class="kb">希望你喜欢编码。</em> <strong class="is hu"> <em class="kb">如果你发现这很有帮助，请鼓掌。</em> </strong></p><p id="4ed5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你对区块链、以太坊或整个世界有任何问题，请发表评论。:)</p><blockquote class="ly"><p id="4831" class="lz ma ht bd mb mc md me mf mg mh jn ek translated"><a class="ae ka" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="mj mk ml mm mn jt fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mi"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>