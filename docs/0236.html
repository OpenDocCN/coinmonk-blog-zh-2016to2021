<html>
<head>
<title>Solidity Development: Creating our first smart contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可靠性开发:创建我们的第一个智能合同</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-development-creating-our-first-smart-contract-54943b47d7f3?source=collection_archive---------3-----------------------#2018-04-09">https://medium.com/coinmonks/solidity-development-creating-our-first-smart-contract-54943b47d7f3?source=collection_archive---------3-----------------------#2018-04-09</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/3964b3ab2e99da7b519800749248647c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akY6ZRmE6OD_08Va8oKxTA.jpeg"/></div></figure><p id="1a1c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在上一篇文章中，我们已经发现了如何设置我们的环境。我更喜欢用Webstorm，Truffle和Ganache的溶液，但你可以随意使用任何合适的。现在，我们将编写我们的第一份智能合同。为了给开发过程增加一些乐趣，让我们创建一个加密游戏。众所周知，每个人都喜欢小猫和饼干。虽然，我们已经有了CryptoKitties，让我们来做CryptoCookieMonsters吧。</p><figure class="jx jy jz ka fq iu fe ff paragraph-image"><div class="fe ff jw"><img src="../Images/16bb3d8df4f2d5fd73a06090677bea29.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*kh384-CpKvYdbWDSC5bw0Q.png"/></div></figure><h2 id="d773" class="kb kc ht bd kd ke kf kg kh ki kj kk kl ji km kn ko jm kp kq kr jq ks kt ku kv dt translated">构建合同</h2><p id="e52c" class="pw-post-body-paragraph ix iy ht iz b ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju hm dt translated">首先，让我们在IDE中创建扩展名为<code class="eh lb lc ld le b">.sol</code>的Solidity文件。每个Solidity文件的第一行包含了我们将要使用的语言版本的信息。最新的稳定版本是<code class="eh lb lc ld le b">0.4.21</code>，我们来用一下:</p><pre class="jx jy jz ka fq lf le lg lh aw li dt"><span id="2715" class="kb kc ht le b fv lj lk l ll lm">pragma solidity ^0.4.21;</span></pre><p id="c24e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这就是我们每个实体文件的第一行的样子。现在让我们为我们的应用程序创建一个契约。让我们更快，因为加密饼干怪物不喜欢等待。</p><pre class="jx jy jz ka fq lf le lg lh aw li dt"><span id="ac05" class="kb kc ht le b fv lj lk l ll lm">contract CryptoCookieMonsters {<br/>  address public owner;<br/>  <br/>  function CryptoCookieMonsters() {<br/>    owner = msg.sender;<br/>  }<br/>}</span></pre><p id="e13b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">因此，我们刚刚为我们的应用程序定义了智能合约。让我们更深入地看看这里发生了什么。在契约体内部，我们定义了构造函数和<code class="eh lb lc ld le b">owner</code>字段，类型为<code class="eh lb lc ld le b">address</code>。这是存储钱包或其他合同地址的特殊类型。<code class="eh lb lc ld le b">public</code>访问修饰符的工作方式与其他常见语言略有不同。当您向属性添加<code class="eh lb lc ld le b">public</code>修饰符时，它会自动为该属性生成getter，避免直接设置值。<strong class="iz hu">这样，</strong> <code class="eh lb lc ld le b">public</code> <strong class="iz hu">属性都是只读的。</strong></p><p id="3b29" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">万岁，我们已经完成了合同第一行的解释。但是我们为什么需要那个<code class="eh lb lc ld le b">owner</code>属性呢？</p><figure class="jx jy jz ka fq iu fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/a9f30a0dee6b8a153c2f00c4f4b49e52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*NFjjEddAFXrztJKWdjOg6Q.jpeg"/></div></figure><p id="736f" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">初级！在这个属性中，我们将存储将合同部署到以太网的人的地址。后来，它可以帮助我们限制一些功能，所以它们只能由所有者调用。当契约被部署到网络时，契约构造函数被调用一次，所以这是设置所有者的理想位置。</p><h2 id="d192" class="kb kc ht bd kd ke kf kg kh ki kj kk kl ji km kn ko jm kp kq kr jq ks kt ku kv dt translated">味精是什么？</h2><p id="4430" class="pw-post-body-paragraph ix iy ht iz b ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju hm dt translated">如您所见，我们从某个<code class="eh lb lc ld le b">msg</code>对象中获取了所有者地址。<code class="eh lb lc ld le b">msg</code>是一个对象，它伴随着通过网络进行的每一笔交易。它包括以下属性:</p><ul class=""><li id="5048" class="lo lp ht iz b ja jb je jf ji lq jm lr jq ls ju lt lu lv lw dt translated"><code class="eh lb lc ld le b">msg.data</code>包含完整的calldata</li><li id="8531" class="lo lp ht iz b ja lx je ly ji lz jm ma jq mb ju lt lu lv lw dt translated"><code class="eh lb lc ld le b">msg.sender</code>告诉我们运行交易的地址</li><li id="1c32" class="lo lp ht iz b ja lx je ly ji lz jm ma jq mb ju lt lu lv lw dt translated"><code class="eh lb lc ld le b">msg.value</code>是魏的量，随消息送来</li><li id="be55" class="lo lp ht iz b ja lx je ly ji lz jm ma jq mb ju lt lu lv lw dt translated"><code class="eh lb lc ld le b">msg.gas</code>表示剩余气体</li><li id="f10c" class="lo lp ht iz b ja lx je ly ji lz jm ma jq mb ju lt lu lv lw dt translated"><code class="eh lb lc ld le b">msg.sig</code>显示了呼叫数据的前四个字节</li></ul><blockquote class="mc md me"><p id="f9df" class="ix iy mf iz b ja jb jc jd je jf jg jh mg jj jk jl mh jn jo jp mi jr js jt ju hm dt translated"><strong class="iz hu">注</strong> : Gas是以太坊网络中运行交易或合同的内部定价。魏是以太坊中最小的面额。就像一分钱一分货一样。ETH值10卫。</p></blockquote><h2 id="f950" class="kb kc ht bd kd ke kf kg kh ki kj kk kl ji km kn ko jm kp kq kr jq ks kt ku kv dt translated">添加一些逻辑</h2><p id="e16a" class="pw-post-body-paragraph ix iy ht iz b ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju hm dt translated">因为我们要创建一个游戏，我们需要一些功能来生成新的加密Cookie怪物。让我们在契约体中为它定义函数:</p><pre class="jx jy jz ka fq lf le lg lh aw li dt"><span id="dea9" class="kb kc ht le b fv lj lk l ll lm">function createCookieMonster() external {<br/>}</span></pre><p id="923d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><code class="eh lb lc ld le b">external</code>修饰符告诉我们这个函数只能在智能合约之外被调用。现在让我们为我们的怪物创建一个模型。在Solidity中，我们有一个<code class="eh lb lc ld le b">struct</code>数据结构。这正是我们需要的:</p><pre class="jx jy jz ka fq lf le lg lh aw li dt"><span id="f29c" class="kb kc ht le b fv lj lk l ll lm">struct CookieMonster {<br/>  string name;<br/>  uint256 id;<br/>  uint16 level;<br/>}</span></pre><p id="5b21" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在我们可以在我们的<code class="eh lb lc ld le b">createCookieMonster()</code>函数中创建<code class="eh lb lc ld le b">CookieMonster</code>实例。但是，在此之前，我们必须考虑如何设置新怪物的属性。我们去哪弄身份证？也许，我们必须在我们的合同中添加某种计数器，我们将在创建每个新的CookieMonster后递增。我们可以将这个值用作id和名称的一部分。</p><pre class="jx jy jz ka fq lf le lg lh aw li dt"><span id="12c3" class="kb kc ht le b fv lj lk l ll lm">uint256 counter = 0;</span></pre><p id="7ac4" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">此外，让我们创建一个由契约中创建的所有Cookie Monsters组成的数组。为此，我们可以在契约体中定义一组<code class="eh lb lc ld le b">CookieMonster</code>结构:</p><pre class="jx jy jz ka fq lf le lg lh aw li dt"><span id="359d" class="kb kc ht le b fv lj lk l ll lm">CookieMonster[] public monsters; //public makes it readonly directly</span></pre><p id="206e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在我们可以完成实现<code class="eh lb lc ld le b">createCookieMonster()</code>函数了:</p><pre class="jx jy jz ka fq lf le lg lh aw li dt"><span id="35a0" class="kb kc ht le b fv lj lk l ll lm">function createCookieMonster() external {<br/>  CookieMonster memory newMonster = CookieMonster("Test Monster",    counter++, 1);<br/>  monsters.push(newMonster);<br/>}</span></pre><p id="c93b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">完整的代码可以在<a class="ae jv" href="https://ethfiddle.com/wZF5ik7rX5" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><h2 id="ce89" class="kb kc ht bd kd ke kf kg kh ki kj kk kl ji km kn ko jm kp kq kr jq ks kt ku kv dt translated">结论</h2><p id="4434" class="pw-post-body-paragraph ix iy ht iz b ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju hm dt translated">最后，在这篇文章中，我们发现了如何创建一个简单的智能契约，发现了诸如数组、结构、函数等结构的使用。此外，我们还学习了<code class="eh lb lc ld le b">msg</code>对象和一些访问修饰符，如<code class="eh lb lc ld le b">public</code>和<code class="eh lb lc ld le b">external</code>。在下一章，我们将学习如何存储用户和他的财产之间的关系(在我们的例子中是加密怪物)，改进<code class="eh lb lc ld le b">id</code>的生成，学习Solidity语言中的事件结构。</p><blockquote class="mj"><p id="438c" class="mk ml ht bd mm mn mo mp mq mr ms ju ek translated"><a class="ae jv" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mu mv mw mx my iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mt"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><h1 id="7df9" class="mz kc ht bd kd na nb nc kh nd ne nf kl ng nh ni ko nj nk nl kr nm nn no ku np dt translated">❤️喜欢，分享，留下你的评论</h1><p id="f8fe" class="pw-post-body-paragraph ix iy ht iz b ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju hm dt translated">如果你喜欢这篇文章，不要忘记喜欢，与你的朋友和同事分享，并在下面留下你对这篇文章的评论。跟我来……</p><figure class="jx jy jz ka fq iu"><div class="bz el l di"><div class="nq nr l"/></div></figure></div></div>    
</body>
</html>