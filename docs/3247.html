<html>
<head>
<title>Tezos Explorer API Best Practices: #2 Request only what you actually need</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tezos Explorer API最佳实践:#2只请求您实际需要的东西</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/tezos-explorer-api-best-practices-2-request-only-what-you-actually-need-5e265dbaba2b?source=collection_archive---------2-----------------------#2020-08-10">https://medium.com/coinmonks/tezos-explorer-api-best-practices-2-request-only-what-you-actually-need-5e265dbaba2b?source=collection_archive---------2-----------------------#2020-08-10</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/71cf2846073993bcb7a35dc411d098b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1CR-4GbeGfged5na.jpg"/></div></div></figure><p id="28ad" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<a class="ae jz" href="https://baking-bad.org/blog/2020/07/29/tezos-explorer-api-tzkt-how-often-to-make-requests/" rel="noopener ugc nofollow" target="_blank">的上一篇文章</a>中，我们分析了如何根据块和周期之间的时间优化对Tezos Explorer API的请求频率，并展示了使用这一知识的最有效方法。</p><p id="d4d7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在本文中，我们将继续向您展示如何最大限度地利用<a class="ae jz" href="https://api.tzkt.io/" rel="noopener ugc nofollow" target="_blank"> TzKT，Tezos Explorer API </a>。几乎每天都有新的面包师、钱包、DApps、交换者甚至各种探险家出现在Tezos生态系统中。在这一系列文章中，我们将尝试帮助开发者以更有效的方式使用Tezos Explorer API，我们相信这将带来更好的用户体验。</p><h1 id="832b" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">目录</h1><ul class=""><li id="f5ba" class="ky kz ht jd b je la ji lb jm lc jq ld ju le jy lf lg lh li dt translated">✅ <a class="ae jz" href="https://baking-bad.org/blog/2020/07/29/tezos-explorer-api-tzkt-how-often-to-make-requests/#how-often-do-i-need-to-make-api-requests" rel="noopener ugc nofollow" target="_blank">不请求相同的数据，直到它实际发生变化</a></li><li id="851f" class="ky kz ht jd b je lj ji lk jm ll jq lm ju ln jy lf lg lh li dt translated">✅ <a class="ae jz" href="https://baking-bad.org/blog/2020/08/10/tezos-explorer-api-tzkt-request-only-what-you-need/#request-only-what-you-actually-need" rel="noopener ugc nofollow" target="_blank">只要求你实际需要的东西</a></li><li id="093f" class="ky kz ht jd b je lj ji lk jm ll jq lm ju ln jy lf lg lh li dt translated">🔜过滤API上的数据，而不是客户端上的数据</li><li id="eff7" class="ky kz ht jd b je lj ji lk jm ll jq lm ju ln jy lf lg lh li dt translated">🔜小心使用分页</li></ul><h1 id="d737" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">只请求你真正需要的东西</h1><p id="05f8" class="pw-post-body-paragraph jb jc ht jd b je la jg jh ji lb jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">默认情况下，API返回包含最大数据集的对象，以覆盖尽可能多的案例并满足尽可能多的用户的需求。然而，对于每个特定的用户和每个特定的任务，大部分结果数据都是冗余的，因为它们根本没有被使用。这导致网络流量的低效使用，有时还会导致低效的响应时间。</p><p id="f4de" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为此，TzKT API提供了使用查询参数<code class="eh lr ls lt lu b">?select=</code>和<code class="eh lr ls lt lu b">?select.values=</code>只请求所需数据的能力。</p><p id="a04a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如，我们希望获得快照级别。我们可以使用<a class="ae jz" href="https://api.tzkt.io/v1/cycles" rel="noopener ugc nofollow" target="_blank"> /cycles </a>端点轻松地做到这一点。虽然，这个端点返回一个充满有用数据的对象数组:</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="a0ca" class="md kb ht lu b fv me mf l mg mh">[{<br/>    "index": 7,<br/>    "snapshotIndex": 9,<br/>    "snapshotLevel": 2560,<br/>    "randomSeed": "1bcd1d832aff2d72a8d16a9f9e5f994e177e29eac789138b019f0c4a30c4e5ec",<br/>    "totalBakers": 52,<br/>    "totalRolls": 19077,<br/>    "totalStaking": 190989137117557,<br/>    "totalDelegators": 312,<br/>    "totalDelegated": 187846516221396<br/>},{<br/>    "index": 8,<br/>    "snapshotIndex": 14,<br/>    "snapshotLevel": 7936,<br/>    "randomSeed": "4a38061cdab9818e0aa6e05e57fc65b5e80abc53618e82b9ab9a12bbf739c764",<br/>    "totalBakers": 168,<br/>    "totalRolls": 22422,<br/>    "totalStaking": 224673132682556,<br/>    "totalDelegators": 1169,<br/>    "totalDelegated": 215276722522456<br/>}]</span></pre><p id="4bcb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然而，我们只需要<code class="eh lr ls lt lu b">snapshotLevel</code>。因此，通过将查询参数<code class="eh lr ls lt lu b">?select=snapshotLevel</code>附加到我们的请求<a class="ae jz" href="https://api.tzkt.io/v1/cycles?select=snapshotLevel" rel="noopener ugc nofollow" target="_blank"> /cycles？select=snapshotLevel </a>我们将得到我们实际需要的东西:</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="400b" class="md kb ht lu b fv me mf l mg mh">[2560, 7936, 9728, 15872, 20480, 24576, ...]</span></pre><p id="5e3d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这样好多了，不是吗？我们只收到了我们需要的东西。</p><p id="dd60" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在某些情况下，使用<code class="eh lr ls lt lu b">?select=</code>查询参数有助于减少传输的数据量和响应时间，因为在请求数据库时<code class="eh lr ls lt lu b">JOIN</code>操作的数量较少。</p><p id="f047" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下面是数据选择如何影响性能的另一个很好的例子:</p><figure class="lv lw lx ly fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mi"><img src="../Images/01d2b20bbdde7a7fd4e2102fa1bd4dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bfudIR8f7vOE6akmxIXrg.png"/></div></div></figure><p id="5b88" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如您所看到的，通过使用<code class="eh lr ls lt lu b">?select=</code>查询参数，您可以获得显著的性能提升。</p><h1 id="ec6a" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">选择与选择值</h1><p id="f742" class="pw-post-body-paragraph jb jc ht jd b je la jg jh ji lb jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">正如我们上面已经提到的，TzKT API允许以两种方式进行数据选择:<code class="eh lr ls lt lu b">select</code>和<code class="eh lr ls lt lu b">select.values</code>。现在让我们更详细地关注它们。</p><p id="cb3e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这两种模式下，我们都需要指定一个逗号分隔的字段列表来包含在响应中。在<code class="eh lr ls lt lu b">select</code>模式下，响应将被表示为常规JSON对象的列表。</p><blockquote class="mj mk ml"><p id="0bc0" class="jb jc mm jd b je jf jg jh ji jj jk jl mn jn jo jp mo jr js jt mp jv jw jx jy hm dt translated"><strong class="jd hu"> <em class="ht">例题</em> </strong></p><p id="b338" class="jb jc mm jd b je jf jg jh ji jj jk jl mn jn jo jp mo jr js jt mp jv jw jx jy hm dt translated"><code class="eh lr ls lt lu b"><em class="ht">?select=address,balance</em></code><em class="ht">=&gt;</em>T7】</p></blockquote><p id="987e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<code class="eh lr ls lt lu b">select.values</code>模式的情况下，响应将是值数组的数组。</p><blockquote class="mj mk ml"><p id="153b" class="jb jc mm jd b je jf jg jh ji jj jk jl mn jn jo jp mo jr js jt mp jv jw jx jy hm dt translated"><strong class="jd hu"> <em class="ht">例题</em> </strong></p><p id="2d66" class="jb jc mm jd b je jf jg jh ji jj jk jl mn jn jo jp mo jr js jt mp jv jw jx jy hm dt translated"><code class="eh lr ls lt lu b"><em class="ht">?select.values=address,balance</em></code> <em class="ht"> = &gt; </em> <code class="eh lr ls lt lu b"><em class="ht">[ [ "tz1abcd", 1000 ] ]</em></code></p></blockquote><p id="de06" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了更好地理解这两种模式之间的区别，让我们再看几个例子</p><figure class="lv lw lx ly fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mq"><img src="../Images/b3e13087a6c739c3d32a9c1627234709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-E8anI4lqKLVKGmKKeLXzg.png"/></div></div></figure><p id="d04b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如你所见，数据中有巨大的差异。显然，有时这种差异并不显著:</p><figure class="lv lw lx ly fq iu fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/32d34eaefd56c749320f63bb810aaf49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*dA8t8BnbmR7sDwznkRxpLw.png"/></div></figure><p id="930f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这主要取决于字段名的长度和字段中包含的数据量，因此在每种特定情况下，最好估计数据量，并在此基础上在易用性和响应时间之间做出选择。</p><blockquote class="mj mk ml"><p id="9666" class="jb jc mm jd b je jf jg jh ji jj jk jl mn jn jo jp mo jr js jt mp jv jw jx jy hm dt translated"><strong class="jd hu">注<em class="ht">注</em>注</strong></p><p id="6254" class="jb jc mm jd b je jf jg jh ji jj jk jl mn jn jo jp mo jr js jt mp jv jw jx jy hm dt translated"><em class="ht">如果选择单字段，在</em> <code class="eh lr ls lt lu b"><em class="ht">.fields</em></code> <em class="ht">和</em> <code class="eh lr ls lt lu b"><em class="ht">.values</em></code> <em class="ht">两种模式下，响应都将是一个值数组。</em></p></blockquote><h1 id="207c" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">结论</h1><p id="f535" class="pw-post-body-paragraph jb jc ht jd b je la jg jh ji lb jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">在本文中，我们演示了如何使用<code class="eh lr ls lt lu b">?select</code>和<code class="eh lr ls lt lu b">?select.values</code>参数来显著减少网络流量并提高应用程序的性能。如果您在Tezos API中遗漏了什么，请<a class="ae jz" href="https://baking-bad.org/docs/#contacts" rel="noopener ugc nofollow" target="_blank">联系我们</a>，我们将尽最大努力帮助您！</p><h1 id="1f8d" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">下一步是什么？</h1><p id="c89e" class="pw-post-body-paragraph jb jc ht jd b je la jg jh ji lb jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">这是“Tezos Explorer API最佳实践”系列的第二篇文章。在下一篇文章中，我们将讨论API请求中的数据过滤。</p><p id="fe77" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">干杯！</p></div><div class="ab cl ms mt hb mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hm hn ho hp hq"><p id="4148" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="mm">原载于2020年8月10日</em><a class="ae jz" href="https://baking-bad.org/blog/2020/08/10/tezos-explorer-api-tzkt-request-only-what-you-need/" rel="noopener ugc nofollow" target="_blank"><em class="mm">【https://baking-bad.org】</em></a><em class="mm">。</em></p><blockquote class="mz"><p id="b751" class="na nb ht bd nc nd ne nf ng nh ni jy ek translated"><a class="ae jz" href="https://coincodecap.com?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nk nl nm nn no iu fe ff paragraph-image"><a href="https://coincodecap.com?utm_source=coinmonks"><div class="fe ff nj"><img src="../Images/160ce73bd06d46c2250251e7d5969f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*BoDnKUyK8p4hitHAJZ5Pdw.png"/></div></a></figure></div></div>    
</body>
</html>