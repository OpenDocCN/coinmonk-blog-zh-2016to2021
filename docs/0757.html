<html>
<head>
<title>Solidity and object oriented programming (OOP)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可靠性和面向对象编程</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-and-object-oriented-programming-oop-191f8deb8316?source=collection_archive---------0-----------------------#2018-06-12">https://medium.com/coinmonks/solidity-and-object-oriented-programming-oop-191f8deb8316?source=collection_archive---------0-----------------------#2018-06-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/1b3043fbbb17eb093fab9521baea24c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*TZFAebPslxxZ8s3H7FagdQ.png"/></div></figure><p id="01d3" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">合同构成:</strong></p><p id="02e8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">坚固性支持合同组成。组合是指将多个契约或数据类型组合在一起，以创建复杂的数据结构和契约。</p><p id="fe1c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">将问题分解成多个契约解决方案，并使用契约组合将它们组合在一起，这是一个很好的实践。</p><p id="676f" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">传承:</strong></p><p id="8787" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">继承是面向对象的支柱之一，而可靠性支持智能契约之间的继承。继承是定义多个通过父子关系相互关联的契约的过程。</p><p id="dbaf" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">被继承的契约称为<em class="jv">父契约</em>，被继承的契约称为<em class="jv">子契约</em>。<br/>类似地，契约具有被称为<em class="jv">派生类</em>的父契约，并且父契约被称为<em class="jv">基础契约</em>。<br/>继承主要是关于<em class="jv">代码的可重用性。</em>基础契约和派生契约之间存在is-a关系，所有公共和内部作用域<br/>函数和状态变量对派生契约可用。</p><p id="6f44" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">事实上，Solidity编译器将基本契约字节码复制到派生契约字节码中。is关键字用于继承派生协定中的基础协定。这是每个Solidity开发人员都应该掌握的最重要的概念之一，因为这是契约版本化和部署的方式。</p><p id="eb81" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">Solidity支持多种类型的继承，包括多重继承。Solidity将基础契约复制到派生契约中，并通过继承创建单个契约。生成在父子关系中的合同之间共享的单个地址。</p><p id="9039" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">单一继承:</strong></p><p id="3d0a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">单一继承有助于将基本契约的变量、函数、修饰符和事件继承到派生类中。</p><figure class="jx jy jz ka fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="fe ff jw"><img src="../Images/856122cef26e9b2519f2d1bc3adfbb7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WgbEbMz2_1bwpm13lu3Rgw.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek"><strong class="bd kj">Single inheritance</strong></figcaption></figure><p id="2f5b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">多级继承:</strong></p><p id="d42a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">多级继承非常类似于单级继承；然而，不仅仅是单一的<br/>亲子关系，还有多层次的亲子关系。</p><figure class="jx jy jz ka fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="fe ff kk"><img src="../Images/c9d040c5c5228a90c5e0cc4b5b80e46d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9IJ41qAxyMmgNO4kC_u5Gg.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek"><strong class="bd kj">Multi-level inheritance</strong></figcaption></figure><p id="ea8d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">下图显示了这一点。合同A是合同B的父合同，合同B是合同C的父合同:</p><p id="4857" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">层次继承:</strong></p><p id="b524" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">分层继承也类似于简单继承。然而，在这里，单个契约充当多个派生契约的基础契约。</p><figure class="jx jy jz ka fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="fe ff kl"><img src="../Images/463b2ae42dde41221d62fd9419799933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQ4C62ayAdh4LJfXRfNu9Q.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek"><strong class="bd kj">Hierarchical inheritance</strong></figcaption></figure><p id="6786" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">下图显示了这一点。此处，合同A源自合同B和合同C:</p><p id="c5bb" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">多重继承:</strong></p><p id="f1ad" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">坚固性支持多重继承。单一继承可以有多个级别。然而，也可以有从同一基础契约派生的多个契约。<br/>这些派生的契约可以在进一步的子类中一起用作基础契约。<br/>当合同从这样的子合同一起继承时，存在多重继承，如下图所示:</p><figure class="jx jy jz ka fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="fe ff km"><img src="../Images/6fdae3cf622b17af234e2e02e95383dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSRyRgRxBcj_V2FLBUfLTQ.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek"><strong class="bd kj">Multiple inheritance :</strong></figcaption></figure><p id="b8b0" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">注意:</strong> Solidity遵循Python的路径，使用<strong class="iz hu"> C3线性化</strong>，也称为<strong class="iz hu">方法解析顺序(MRO) </strong>，在基础契约的图中强制特定顺序。这些协定在继承时应该遵循特定的顺序，从基础协定开始，一直到最派生的协定。</p><p id="24fb" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">封装:</strong></p><p id="8e97" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">封装是OOP最重要的支柱之一。封装是指隐藏或允许直接访问状态变量以改变其状态的过程。<br/>是指声明变量的模式，这些变量不能被客户端直接访问，只能用函数修改。这有助于约束对变量的访问，但同时也允许对类进行足够的访问以对其采取行动。</p><p id="49a8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">Solidity提供了多个可见性修饰符，如<em class="jv">外部</em>、<em class="jv">公共</em>、<em class="jv">内部</em>和<em class="jv">私有</em>，它们影响状态变量在定义它们的契约中的可见性，继承子契约或外部契约。</p><p id="9815" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">多态性:</strong></p><p id="7f68" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">多态性意味着有多种形式。多态性有以下两种:<br/> <strong class="iz hu"> 1。</strong>函数多态性<br/> <strong class="iz hu"> 2。</strong>契约多态性</p><p id="7f21" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">函数多态性:</strong></p><p id="a34e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">函数多态性是指在同一个契约中声明多个函数，或者继承同名的契约。<br/>函数的参数数据类型或参数数量不同。在确定多态性的有效函数签名时，不考虑返回类型。这也被称为<strong class="iz hu">方法重载</strong>。</p><pre class="jx jy jz ka fq kn ko kp kq aw kr dt"><span id="ca5d" class="ks kt ht ko b fv ku kv l kw kx">pragma solidity ^0.4.19;</span><span id="312e" class="ks kt ht ko b fv ky kv l kw kx">contract helloFunctionPloymorphism {<br/> <br/> function getVariableData(int8 data) public pure returns(int8 output) {<br/> return data;<br/> }</span><span id="1bba" class="ks kt ht ko b fv ky kv l kw kx">function getVariableData(int16 data) public pure returns(int16 output) {<br/> return data;<br/> }<br/>}</span></pre><p id="6807" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">合同多态性:</strong></p><p id="562c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">契约多态性是指当契约通过继承的方式相互关联时，可以互换地使用多个契约实例。契约多态性有助于使用基本契约实例调用派生的契约函数。</p><pre class="jx jy jz ka fq kn ko kp kq aw kr dt"><span id="50b6" class="ks kt ht ko b fv ku kv l kw kx">pragma solidity ^0.4.19;</span><span id="73e9" class="ks kt ht ko b fv ky kv l kw kx">contract ParentContract {<br/> uint internal simpleInteger;</span><span id="5f30" class="ks kt ht ko b fv ky kv l kw kx">function SetInteger(uint _value) public {<br/> simpleInteger = _value;<br/> }</span><span id="6db9" class="ks kt ht ko b fv ky kv l kw kx">function GetInteger() public view returns (uint) {<br/> return 10;<br/> }<br/>}</span><span id="b0f8" class="ks kt ht ko b fv ky kv l kw kx">contract ChildContract is ParentContract {<br/> <br/> function GetInteger() public view returns (uint) {<br/> return simpleInteger;<br/> }<br/>}</span></pre><p id="936c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">抽象合同:</strong></p><p id="31ec" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">抽象契约是具有部分功能定义的契约。您不能创建抽象合同的实例。抽象契约必须被子契约继承才能使用其功能。抽象契约有助于定义契约的结构，从它继承的任何类都必须确保为它们提供实现。<br/>如果子合同没有提供不完整功能的实现，甚至不能创建它的实例。<br/>函数签名使用分号，；，性格。<br/>没有Solidity提供的关键字将合同标记为抽象。<br/>如果一个契约有函数但没有实现，那么它就变成了一个抽象类。</p><pre class="jx jy jz ka fq kn ko kp kq aw kr dt"><span id="7a53" class="ks kt ht ko b fv ku kv l kw kx">pragma solidity ^0.4.19;</span><span id="2415" class="ks kt ht ko b fv ky kv l kw kx">contract abstractHelloWorld {<br/> function GetValue() public view returns (uint);<br/> function SetValue(uint _value) public;</span><span id="b39c" class="ks kt ht ko b fv ky kv l kw kx">function AddNumber(uint _value) public returns (uint) {<br/> return 10;<br/> }<br/>}</span><span id="bfe4" class="ks kt ht ko b fv ky kv l kw kx">contract HelloWorld is abstractHelloWorld{<br/> uint private simpleInteger;</span><span id="b050" class="ks kt ht ko b fv ky kv l kw kx">function GetValue() public view returns (uint) {<br/> return simpleInteger;<br/> }<br/> <br/> function SetValue(uint _value) public {<br/> simpleInteger = _value;<br/> }</span><span id="07a5" class="ks kt ht ko b fv ky kv l kw kx">function AddNumber(uint _value) public returns (uint ){<br/> return simpleInteger = _value;<br/> }<br/>}</span></pre><p id="920a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">接口:</strong></p><p id="39d0" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">接口就像抽象契约，但还是有区别的。接口不能包含任何定义。<br/>它们只能包含函数声明。这意味着接口中的函数不能包含任何代码。它们也被称为纯抽象合同。一个接口只能包含函数的签名。</p><pre class="jx jy jz ka fq kn ko kp kq aw kr dt"><span id="6782" class="ks kt ht ko b fv ku kv l kw kx">pragma solidity ^0.4.19;</span><span id="23df" class="ks kt ht ko b fv ky kv l kw kx">contract abstractHelloWorld {<br/> function GetValue() public view returns (uint);<br/> function SetValue(uint _value) public;</span><span id="8f01" class="ks kt ht ko b fv ky kv l kw kx">function AddNumber(uint _value) public returns (uint) {<br/> return 10;<br/> }<br/>}</span><span id="b0d4" class="ks kt ht ko b fv ky kv l kw kx">contract HelloWorld is abstractHelloWorld{<br/> uint private simpleInteger;</span><span id="ff55" class="ks kt ht ko b fv ky kv l kw kx">function GetValue() public view returns (uint) {<br/> return simpleInteger;<br/> }<br/> <br/> function SetValue(uint _value) public {<br/> simpleInteger = _value;<br/> }</span><span id="6936" class="ks kt ht ko b fv ky kv l kw kx">function AddNumber(uint _value) public returns (uint ){<br/> return simpleInteger = _value;<br/> }<br/>}</span></pre><p id="09fa" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">概要:</strong></p><p id="cdae" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在本文中，我主要关注智能契约、创建实例的不同方法以及与之相关的所有重要的面向对象概念，包括继承、多态、抽象和封装。</p><p id="aa73" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">Solidity中可以实现多种类型的继承。讨论了简单的、多重的、分层的和多层次的继承，以及抽象契约和接口的使用和实现。应该注意，在Solidity中使用继承，最终只部署一个契约，而不是多个契约。任何具有父子层次结构的协定只能使用一个地址。</p><figure class="jx jy jz ka fq iu fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/e6acaab1ccc3a9f7b47bec65997fcef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*0uj3gz9uY6w1qOpauS9k3w.gif"/></div></figure><blockquote class="la"><p id="ed32" class="lb lc ht bd ld le lf lg lh li lj ju ek translated">加入Coinmonks <a class="ae lk" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae lk" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae lk" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="ks kt ht bd ll lm ln lo lp lq lr ls lt ji lu lv lw jm lx ly lz jq ma mb mc md dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="me mf ht iz b ja mg je mh ji mi jm mj jq mk ju ml mm mn mo dt translated"><a class="ae lk" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae lk" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="me mf ht iz b ja mp je mq ji mr jm ms jq mt ju ml mm mn mo dt translated"><a class="ae lk" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae lk" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="me mf ht iz b ja mp je mq ji mr jm ms jq mt ju ml mm mn mo dt translated"><a class="ae lk" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae lk" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="me mf ht iz b ja mp je mq ji mr jm ms jq mt ju ml mm mn mo dt translated"><a class="ae lk" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae lk" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="6065" class="me mf ht iz b ja mp je mq ji mr jm ms jq mt ju ml mm mn mo dt translated"><a class="ae lk" href="https://coincodecap.com/binance-vs-bitstamp" rel="noopener ugc nofollow" target="_blank">币安vs比特邮票</a> | <a class="ae lk" href="https://coincodecap.com/bitpanda-coinbase-coinsbit" rel="noopener ugc nofollow" target="_blank">比特熊猫vs比特币基地vs Coinsbit </a></li><li id="5711" class="me mf ht iz b ja mp je mq ji mr jm ms jq mt ju ml mm mn mo dt translated"><a class="ae lk" href="https://coincodecap.com/buy-ripple-india" rel="noopener ugc nofollow" target="_blank">如何购买Ripple (XRP) </a> | <a class="ae lk" href="https://coincodecap.com/crypto-exchange-africa" rel="noopener ugc nofollow" target="_blank">非洲最好的加密交易所</a></li><li id="861b" class="me mf ht iz b ja mp je mq ji mr jm ms jq mt ju ml mm mn mo dt translated"><a class="ae lk" href="https://coincodecap.com/crypto-exchange-africa" rel="noopener ugc nofollow" target="_blank">非洲最佳加密交易所</a> | <a class="ae lk" href="https://coincodecap.com/hoo-exchange-review" rel="noopener ugc nofollow" target="_blank"> Hoo交易所评论</a></li><li id="452c" class="me mf ht iz b ja mp je mq ji mr jm ms jq mt ju ml mm mn mo dt translated"><a class="ae lk" href="https://coincodecap.com/etoro-robinhood" rel="noopener ugc nofollow" target="_blank">eToro vs robin hood</a>|<a class="ae lk" href="https://coincodecap.com/bybit-bityard-moonxbt" rel="noopener ugc nofollow" target="_blank">MoonXBT vs by bit vs Bityard</a></li><li id="47a8" class="me mf ht iz b ja mp je mq ji mr jm ms jq mt ju ml mm mn mo dt translated">开发人员的最佳加密API</li><li id="b359" class="me mf ht iz b ja mp je mq ji mr jm ms jq mt ju ml mm mn mo dt translated">最佳<a class="ae lk" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="me mf ht iz b ja mp je mq ji mr jm ms jq mt ju ml mm mn mo dt translated"><a class="ae lk" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae lk" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="me mf ht iz b ja mp je mq ji mr jm ms jq mt ju ml mm mn mo dt translated">杠杆代币的终极指南</li></ul></div></div>    
</body>
</html>