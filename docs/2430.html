<html>
<head>
<title>Make HTTP Request Using Your Solidity Smart Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用您的Solidity智能合同发出HTTP请求</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/make-http-request-using-your-solidity-smart-contract-4f7173bd391c?source=collection_archive---------0-----------------------#2019-10-03">https://medium.com/coinmonks/make-http-request-using-your-solidity-smart-contract-4f7173bd391c?source=collection_archive---------0-----------------------#2019-10-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="a03e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你有没有尝试过把一个微服务集成到你的智能合约里？试着做一个API请求？这在可靠性上可能吗？简而言之，答案是否定的。以太区块链协议与API协议完全不同。以太网是确定性的，它不能随时间改变，所有节点都应该批准它，但是HTTPS请求随时间改变</p><h1 id="40ac" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated"><strong class="ak">为什么像Nodejs和Laravel一样不容易</strong></h1><p id="aff7" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">问题是，智能合约作为区块链上的对象，不能只发送HTTP请求。这将与所有区块链协议的一个基本原则相矛盾——它们的确定性“任何事务的结果必须总是相同的，以便节点验证它，无论我们在哪里、如何以及何时调用它”。所以我们不能使用solidity进行API调用。解决这个问题的一个诀窍是“或现实化”。什么是Orcalize？</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/fafabed38fb3172459709be11ff7d382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*dzUQFmGfDL_w_CUTAemyjg.png"/></div></figure><p id="4f70" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用Oracle作为区块链和API之间的中介。每当有事务发生时，Oracle都保持列表(观察智能契约)。Oracle请求API数据并将响应注入智能合约。在<a class="ae jo" href="https://docs.provable.xyz" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae jo" href="https://github.com/yehia67/ethereum-examples" rel="noopener ugc nofollow" target="_blank">资源库</a>上可以找到很多例子和解释</p><p id="d90b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">不幸的是，大多数代码示例都只是GET调用。不知道为什么？我甚至认为Oraclize只为GET调用提供解决方案。或者老实说，我找到了一些例子，但它们对像我这样的新手来说有点复杂。所以我写了这篇文章来用更简单的方式解释它。</p><h1 id="b716" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">代码实现</h1><p id="d0c5" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">1-我们需要导入Orcalize库，其名称为“provable”clone<a class="ae jo" href="https://github.com/provable-things/ethereum-api" rel="noopener ugc nofollow" target="_blank">GitHub库</a>然后导入合同</p><pre class="kt ku kv kw fq la lb lc ld aw le dt"><span id="e0a3" class="lf jq ht lb b fv lg lh l li lj">import “github.com/oraclize/ethereum-api/provableAPI.sol”;</span></pre><p id="19c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2-如果API调用失败或成功，最好在调用时发出事件。</p><p id="c380" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3-检查我们的合同是否有足够的余额进行交易</p><pre class="kt ku kv kw fq la lb lc ld aw le dt"><span id="1d44" class="lf jq ht lb b fv lg lh l li lj">if (provable_getPrice(“computation”) &gt; address(this).balance) </span></pre><p id="b1b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">4-然后使用用于进行所有API调用的“provable_query”函数进行HTTP调用，例如，进行Post调用:(文档中的示例)</p><pre class="kt ku kv kw fq la lb lc ld aw le dt"><span id="32e9" class="lf jq ht lb b fv lg lh l li lj">// The URL datasource also supports a supplement argument, useful for creating HTTP POST requests.</span><span id="5f91" class="lf jq ht lb b fv lk lh l li lj">// If that argument is a valid JSON string, it will be automatically sent as JSON.</span><span id="85e8" class="lf jq ht lb b fv lk lh l li lj">provable_query(“URL”, “json(https://shapeshift.io/sendamount).success.deposit",</span><span id="bd27" class="lf jq ht lb b fv lk lh l li lj">‘{“pair”:”eth_btc”,”amount”:”1",”withdrawal”:”1AAcCo21EUc1jbocjssSQDzLna9Vem2UN5"}’)</span></pre><p id="fb49" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">完整的代码应该是这样的</strong></p><pre class="kt ku kv kw fq la lb lc ld aw le dt"><span id="9cdd" class="lf jq ht lb b fv lg lh l li lj">if (provable_getPrice(“computation”) &gt; address(this).balance) {</span><span id="7364" class="lf jq ht lb b fv lk lh l li lj">emit LogNewProvableQuery(“Provable query was NOT sent, please add some ETH to cover for the query fee”);</span><span id="2877" class="lf jq ht lb b fv lk lh l li lj">} else {</span><span id="d780" class="lf jq ht lb b fv lk lh l li lj">emit LogNewProvableQuery(“Provable query was sent, standing by for the answer…”);</span><span id="6b25" class="lf jq ht lb b fv lk lh l li lj">provable_query(“URL”, “json(https://shapeshift.io/sendamount).success.deposit",</span><span id="0ee7" class="lf jq ht lb b fv lk lh l li lj">‘{“pair”:”eth_btc”,”amount”:”1",”withdrawal”:”1AAcCo21EUc1jbocjssSQDzLna9Vem2UN5"}’)<br/>}</span><span id="6aa3" class="lf jq ht lb b fv lk lh l li lj">}</span></pre><p id="f1dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让你的代码更动态，更容易调用任何类型的方法，比如普通的后端。您可以解析来自外部<code class="eh ll lm ln lb b">request</code>函数所有<code class="eh ll lm ln lb b">provable_query</code>函数参数，如下所示:</p><pre class="kt ku kv kw fq la lb lc ld aw le dt"><span id="0e22" class="lf jq ht lb b fv lg lh l li lj">function request(</span><span id="7e1b" class="lf jq ht lb b fv lk lh l li lj">string memory _query,</span><span id="56dc" class="lf jq ht lb b fv lk lh l li lj">string memory _method,</span><span id="bf51" class="lf jq ht lb b fv lk lh l li lj">string memory _url,</span><span id="2551" class="lf jq ht lb b fv lk lh l li lj">string memory _kwargs</span><span id="fa4e" class="lf jq ht lb b fv lk lh l li lj">)</span><span id="d669" class="lf jq ht lb b fv lk lh l li lj">public</span><span id="9f23" class="lf jq ht lb b fv lk lh l li lj">payable</span><span id="d372" class="lf jq ht lb b fv lk lh l li lj">{</span><span id="d40d" class="lf jq ht lb b fv lk lh l li lj">if (provable_getPrice(“computation”) &gt; address(this).balance) {</span><span id="c6fb" class="lf jq ht lb b fv lk lh l li lj">emit LogNewProvableQuery(“Provable query was NOT sent, please add some ETH to cover for the query fee”);</span><span id="0ad6" class="lf jq ht lb b fv lk lh l li lj">} else {</span><span id="9eb8" class="lf jq ht lb b fv lk lh l li lj">emit LogNewProvableQuery(“Provable query was sent, standing by for the answer…”);</span><span id="55cf" class="lf jq ht lb b fv lk lh l li lj">provable_query(“computation”,</span><span id="852a" class="lf jq ht lb b fv lk lh l li lj">[_query,</span><span id="965a" class="lf jq ht lb b fv lk lh l li lj">_method,</span><span id="3c93" class="lf jq ht lb b fv lk lh l li lj">_url,</span><span id="8b4c" class="lf jq ht lb b fv lk lh l li lj">_kwargs]</span><span id="8e8e" class="lf jq ht lb b fv lk lh l li lj">);</span><span id="1b64" class="lf jq ht lb b fv lk lh l li lj">}</span><span id="1b00" class="lf jq ht lb b fv lk lh l li lj">}</span></pre><p id="fab5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">就是这样，你可以在这个<a class="ae jo" href="https://github.com/yehia67/ethereum-examples/tree/master/solidity/truffle-examples" rel="noopener ugc nofollow" target="_blank">链接</a>上找到很多松露的例子。谢谢！</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff lo"><img src="../Images/a06b758bdcc47dca7c2504f298674d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_s6JsD3P0hVj32E7t9EtGg.jpeg"/></div></a></figure><blockquote class="lp"><p id="4542" class="lq lr ht bd ls lt lu lv lw lx ly jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="ma mb mc md me kx fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lz"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>