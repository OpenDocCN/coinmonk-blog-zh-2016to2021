<html>
<head>
<title>Attack on Pseudo-random number generator (PRNG) used in 1000 Guess, an Ethereum lottery game (CVE-2018–12454)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">攻击以太坊彩票游戏1000 Guess(CVE-2018–12454)中使用的伪随机数发生器(PRNG)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/attack-on-pseudo-random-number-generator-prng-used-in-1000-guess-an-ethereum-lottery-game-7b76655f953d?source=collection_archive---------1-----------------------#2018-06-17">https://medium.com/coinmonks/attack-on-pseudo-random-number-generator-prng-used-in-1000-guess-an-ethereum-lottery-game-7b76655f953d?source=collection_archive---------1-----------------------#2018-06-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><h1 id="a2b1" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">摘要</h1><p id="bae5" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">以太坊彩票游戏1000 Guess有一个漏洞，它会生成可预测的随机数。当对合同下注的玩家数量达到预定数量时，该游戏通过随机数决定赢家。合同使用带有私有变量和当前块变量的<code class="eh km kn ko kp b">sha256()</code>函数生成随机数，如<code class="eh km kn ko kp b">block.timestamp</code> <em class="kq">、</em> <code class="eh km kn ko kp b">block.coinbase</code>、<em class="kq">、</em>、<em class="kq"> </em>、<code class="eh km kn ko kp b">block.difficulty</code>。然而，它们很容易阅读。首先，使用<code class="eh km kn ko kp b">web3.eth.getStorageAt</code>可以很容易地访问私有变量。其次，众所周知，块变量很容易被恶意挖掘者操纵。然而，即使攻击者不是矿工，这也是危险的。在本文中，我将解释如何利用内部事务攻击PRNG。</p><h1 id="a8f6" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">细节</h1><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="fe ff kr"><img src="../Images/fb90c443de7af40e25dbbeed3ae13a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*elmQ0F3N5xE45gZuBAEujA.png"/></div></div><figcaption class="ld le fg fe ff lf lg bd b be z ek">Figure 1. 1000 guess generates a random number with block variables and a private variable</figcaption></figure><p id="610b" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">1000 Guess使用带有<code class="eh km kn ko kp b">block.timestamp</code>、<code class="eh km kn ko kp b">block.coinbase</code>、<code class="eh km kn ko kp b"> block.difficulty</code>和私有变量<code class="eh km kn ko kp b">curhash</code>的<code class="eh km kn ko kp b">sha256()</code>函数生成一个随机数。这些都是任何人都可以访问的，所以任何人都可以预先计算随机数，并成为赢家。</p><h2 id="d674" class="lm ir ht bd is ln lo lp iw lq lr ls ja jz lt lu je kd lv lw ji kh lx ly jm lz dt translated">如何访问私有变量？</h2><p id="ce94" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">首先，我们如何访问私有变量？在此之前，让我们来看看如何访问一个公共变量。访问公共变量非常简单和直观。如果有一个公共变量<code class="eh km kn ko kp b">uint data</code>，我们可以像这样在web3js中访问它:</p><pre class="ks kt ku kv fq ma kp mb mc aw md dt"><span id="69c5" class="lm ir ht kp b fv me mf l mg mh">contractInstance.methods.data().call()</span></pre><p id="aa85" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">或者，我们可以调用一个返回<code class="eh km kn ko kp b">data</code>的函数，如果存在，</p><pre class="ks kt ku kv fq ma kp mb mc aw md dt"><span id="4992" class="lm ir ht kp b fv me mf l mg mh">function getData() public returns (uint){<br/>    return data;<br/>}</span></pre><p id="898f" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">在web3js中，我们调用getData()来获取这样的数据</p><pre class="ks kt ku kv fq ma kp mb mc aw md dt"><span id="f915" class="lm ir ht kp b fv me mf l mg mh">contractInstance.methods.getData().call()</span></pre><p id="b604" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">但是，我们不能使用上述方法来访问私有变量。为此，有人认为隐藏了一个私有变量。然而，在Solidity文档中，它说所有的东西对所有的观察者都是可见的，即使它是私有的。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="fe ff mj"><img src="../Images/a619ce6124fc5924ff962c962c13a73b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_IIDWb2HVDzKaDtvXFhZQ.png"/></div></div><figcaption class="ld le fg fe ff lf lg bd b be z ek">Figure 2. In a contract, everything is visible to all external observers</figcaption></figure><p id="7943" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">那么，我们怎样才能访问私有变量呢？在web3js中，我们可以像这样访问一个私有变量<a class="ae mi" href="https://web3js.readthedocs.io/en/1.0/web3-eth.html#getstorageat" rel="noopener ugc nofollow" target="_blank">【2】</a>:</p><pre class="ks kt ku kv fq ma kp mb mc aw md dt"><span id="9c20" class="lm ir ht kp b fv me mf l mg mh">web3.eth.getStorageAt(contractAddress, position);</span></pre><p id="69c1" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">我们可以使用上述方法检索智能合约中的所有变量。在智能契约中，变量按顺序位于存储槽中。例如，第一个声明的变量位于槽0，第二个变量位于槽1。所以我们要读<code class="eh km kn ko kp b">curhash</code>，就要知道<code class="eh km kn ko kp b">curhash</code>的位置。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/dd7fc0b48543c2f9d1b16fcce21cf250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*DzLQ40W8mMC9RpGTVV0bjg.png"/></div><figcaption class="ld le fg fe ff lf lg bd b be z ek">Figure 3. variables declaration in the smart contract of 1000 Guess</figcaption></figure><p id="30fc" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">第一个变量是<code class="eh km kn ko kp b">state</code>，所以<code class="eh km kn ko kp b">curhash</code>位于槽1004。<code class="eh km kn ko kp b">constant</code>变量没有存储在存储槽中，所以<code class="eh km kn ko kp b">uint constant maxguess</code>被排除。因此，我们可以将<code class="eh km kn ko kp b">curhash</code>读作:</p><pre class="ks kt ku kv fq ma kp mb mc aw md dt"><span id="1881" class="lm ir ht kp b fv me mf l mg mh">web3.eth.getStorageAt(contractAddress, 1004);</span></pre><p id="72cb" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">当我写这篇文章时，我试图用下面的代码读取<code class="eh km kn ko kp b">curhash</code>和其他变量。我在1000 Guess几个版本中的<a class="ae mi" href="https://etherscan.io/address/0x386771ba5705da638d889381471ec1025a824f53#readContract" rel="noopener ugc nofollow" target="_blank">0x 386771 ba 5705 da 638d 889381471 EC 1025 a 824 f 53</a>上测试。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="fe ff ml"><img src="../Images/867cf2b66330a2700531072c7a97b3b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aydE2TtGG8_5qS3zjEJDQQ.png"/></div></div><figcaption class="ld le fg fe ff lf lg bd b be z ek">Figure 4. Example code of accessing variables</figcaption></figure><p id="e343" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">结果如下:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="fe ff mm"><img src="../Images/d708dfe015c02e6ad5c09019782f53f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vd7ErqfMRarEkoLlgGc3wA.png"/></div></div><figcaption class="ld le fg fe ff lf lg bd b be z ek">Figure 5. State of variables</figcaption></figure><p id="4ec1" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">从结果可以知道<code class="eh km kn ko kp b">numguesses</code>、<code class="eh km kn ko kp b">curhash</code>、<code class="eh km kn ko kp b">_gameindex</code>、<code class="eh km kn ko kp b">_starttime</code>的当前状态。您可以使用<code class="eh km kn ko kp b">getBettingStatus()</code>功能确认上述结果。</p><h2 id="4701" class="lm ir ht bd is ln lo lp iw lq lr ls ja jz lt lu je kd lv lw ji kh lx ly jm lz dt translated">用相同的块变量生成随机数</h2><p id="7977" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在，我们知道如何读取私有变量，所以我们只需使用当前块变量来计算<code class="eh km kn ko kp b">curhash</code>。很明显，当前块变量是可访问的。但是，您无法知道您的事务被执行的块号。例如，有一个智能合约，当你在区块数为偶数时发送交易，你就可以成为赢家。简单来说，你连续观察当前的块数，然后在块数为偶数时向合约发送一个交易。然而，它并不总是成功的，因为你的事务并没有在你发送事务的块中被执行。因此，如果您希望您的事务在特定的块中执行，您应该使用另一种方法。</p><p id="ef05" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">内部交易可以是一种解决方案。首先，在契约中计算new <code class="eh km kn ko kp b">curhash</code>，然后通过契约中的内部事务调用1000 Guess契约。然后，计算相同的<code class="eh km kn ko kp b">curhash</code>,因为两个计算在相同的块中执行。</p><h1 id="6162" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">剥削</h1><p id="13d7" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我利用了1000个猜测契约中的一个:<a class="ae mi" href="https://etherscan.io/address/0x386771ba5705da638d889381471ec1025a824f53#readContract" rel="noopener ugc nofollow" target="_blank">https://ethers can . io/address/0x 386771 ba 5705 da 638d 889381471 EC 1025 a 824 f 53</a>。本合同中，<code class="eh km kn ko kp b">bettingprice</code>为0.01乙醚，<code class="eh km kn ko kp b">arraysize</code>为10乙醚。我准备了两个账户:一个受害者和一个攻击者。</p><p id="026a" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">首先，受害者账户连续在1000张猜合约上下注0.01乙醚，直到<code class="eh km kn ko kp b">numguesses</code>是9也就是<code class="eh km kn ko kp b">arraysize-1</code>。在这种状态下，如果有人在这份合同上下赌注，<code class="eh km kn ko kp b">_finish()</code>将被执行，然后<code class="eh km kn ko kp b">_winner</code>将由新的<code class="eh km kn ko kp b">curhash</code>决定。</p><p id="8dde" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">第二，攻击帐户部署了如下攻击契约:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="fe ff mn"><img src="../Images/985d6ad7191f4817bbd2d448d3127757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omZsDcfb-nGiBPeVOz7RUw.png"/></div></div><figcaption class="ld le fg fe ff lf lg bd b be z ek">Figure 6. Attacker’s contract</figcaption></figure><p id="66fb" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated"><code class="eh km kn ko kp b">attack()</code>函数需要4个参数:</p><ul class=""><li id="98e9" class="mo mp ht jq b jr lh jv li jz mq kd mr kh ms kl mt mu mv mw dt translated"><code class="eh km kn ko kp b">address target</code>:1000猜合约的地址。</li><li id="e939" class="mo mp ht jq b jr mx jv my jz mz kd na kh nb kl mt mu mv mw dt translated"><code class="eh km kn ko kp b">curhash</code>:当前<code class="eh km kn ko kp b">curhash</code>中的1000猜合约</li><li id="c539" class="mo mp ht jq b jr mx jv my jz mz kd na kh nb kl mt mu mv mw dt translated"><code class="eh km kn ko kp b">arraysize</code>:当前<code class="eh km kn ko kp b">arraysize</code></li><li id="bdd2" class="mo mp ht jq b jr mx jv my jz mz kd na kh nb kl mt mu mv mw dt translated"><code class="eh km kn ko kp b">attackeridx</code>:攻击者地址在<code class="eh km kn ko kp b">guessess</code>数组中的索引</li></ul><p id="80d0" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">在攻击契约中，它以与1000个猜测契约相同的方式计算<code class="eh km kn ko kp b">curhash</code>。攻击帐户不断向攻击契约发送交易，直到契约计算出使攻击者成为赢家的<code class="eh km kn ko kp b">curhash</code>。经过几次尝试，终于传输了一个内部交易，攻击帐户获得了奖励。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="fe ff nc"><img src="../Images/03bee6f5d851504dd5fd5dbae222e117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AHnSINND37_RgkqytArHMA.png"/></div></div><figcaption class="ld le fg fe ff lf lg bd b be z ek">Figure 7. Internal transactions executed on the target contract</figcaption></figure><p id="8c8d" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">我测试了两次，成功了两次。图7显示了内部事务。‘0x 48 e9 c 58 bb 66d 0…’是攻击契约，‘0x 1973 f 023 E4 c 03 ef…’是1000 Guess的开发者。当攻击成功后，1000 Guess向攻击契约发送奖励(0.099以太)，向开发者发送费用(0.001以太)。</p><p id="6724" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">您可以检查以下结果:</p><ul class=""><li id="9c3b" class="mo mp ht jq b jr lh jv li jz mq kd mr kh ms kl mt mu mv mw dt translated">1000猜合约:<a class="ae mi" href="https://etherscan.io/address/0x386771ba5705da638d889381471ec1025a824f53" rel="noopener ugc nofollow" target="_blank">https://ethers can . io/address/0x 386771 ba 5705 da 638d 889381471 EC 1025 a 824 f 53</a></li><li id="0c19" class="mo mp ht jq b jr mx jv my jz mz kd na kh nb kl mt mu mv mw dt translated">攻击契约:<a class="ae mi" href="https://etherscan.io/address/0x48e9c58bb66dd0b0f218cf0448a797096d585179#internaltx" rel="noopener ugc nofollow" target="_blank">https://ethers can . io/address/0x 48 e9 c 58 bb 66 DD 0 b 0f 218 cf 0448 a 797096d 585179</a></li><li id="6bce" class="mo mp ht jq b jr mx jv my jz mz kd na kh nb kl mt mu mv mw dt translated">受害者账号:<a class="ae mi" href="https://etherscan.io/address/0x9dbea040fde74f9014c873401675ccd298d302ba" rel="noopener ugc nofollow" target="_blank">https://ethers can . io/address/0x 9 dbea 040 FDE 74 f 9014 c 873401675 CCD 298d 302 ba</a></li><li id="533e" class="mo mp ht jq b jr mx jv my jz mz kd na kh nb kl mt mu mv mw dt translated">攻击者账号:<a class="ae mi" href="https://etherscan.io/address/0x28fb13eb570c23bf65f606431a6cc3ff34f41af0" rel="noopener ugc nofollow" target="_blank">https://ethers can . io/address/0x 28 FB 13 EB 570 c 23 BF 65 f 606431 a6 cc 3 ff 34 f 41 af 0</a></li></ul><p id="366f" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">你可以看到有几个失败的交易，因为攻击契约在契约计算的<code class="eh km kn ko kp b">curhash</code>不能让攻击者成为赢家的时候执行<code class="eh km kn ko kp b">revert()</code>。但是，如果它向目标契约发送一个内部事务，它就能获得回报。当然，攻击者应该支付一些气体，因为他尝试了几次，但与他将获得的奖励相比，这是微不足道的。</p><p id="f42c" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">当我在1000 Guess合同上进行开发时，它只包含开发人员发送的0.01乙醚。所以，在我的漏洞利用之后，我把0.01乙醚还给了开发者。</p><h1 id="c249" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">报告</h1><p id="af80" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我向开发商反映了。然后，他立刻关闭了所有1000个猜谜游戏。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="fe ff nd"><img src="../Images/c1adc0310efc1851a820c76ebceb7698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5d6_P2hTm6JA93YiM1kyg.png"/></div></div><figcaption class="ld le fg fe ff lf lg bd b be z ek">Figure 8. The developer closed the game</figcaption></figure><p id="6405" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">http://www.1000guess.com的<a class="ae mi" href="http://www.1000guess.com/" rel="noopener ugc nofollow" target="_blank">网站</a>，现在已经完全关闭。现在，你只能查看1000个猜测的推特账号:<a class="ae mi" href="https://twitter.com/1000guess" rel="noopener ugc nofollow" target="_blank">https://twitter.com/1000guess</a>。</p><h1 id="7d71" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">结论</h1><p id="7be8" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在以太坊智能合约中生成一个随机数并不容易。据我所知，有两种方法可以安全地生成随机数。第一种方法是使用future block的变量，另一种方法是使用Oraclize[3]之类的库从以太网外部获取随机数。开发人员应该研究如何安全地生成随机数。此外，如果用户想要使用合约，他们应该检查合约如何生成随机数。</p><h1 id="28ed" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">参考</h1><p id="84e8" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">[1]<a class="ae mi" href="http://solidity.readthedocs.io/en/v0.4.24/contracts.html" rel="noopener ugc nofollow" target="_blank">http://solidity.readthedocs.io/en/v0.4.24/contracts.html</a></p><p id="5794" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">[2]<a class="ae mi" href="https://web3js.readthedocs.io/en/1.0/web3-eth.html#getstorageat" rel="noopener ugc nofollow" target="_blank">https://web 3js . readthe docs . io/en/1.0/web 3-eth . html # get storage at</a></p><p id="fee9" class="pw-post-body-paragraph jo jp ht jq b jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ll kj kk kl hm dt translated">[3]<a class="ae mi" href="http://www.oraclize.it/" rel="noopener ugc nofollow" target="_blank">http://www.oraclize.it/</a></p></div></div>    
</body>
</html>