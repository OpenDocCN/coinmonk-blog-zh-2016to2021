<html>
<head>
<title>Basic Consensus Algorithms, Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本共识算法，已解释</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/basic-consensus-algorithms-explained-69a7a67ac13e?source=collection_archive---------3-----------------------#2021-08-04">https://medium.com/coinmonks/basic-consensus-algorithms-explained-69a7a67ac13e?source=collection_archive---------3-----------------------#2021-08-04</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><h1 id="3cd4" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">目录</h1><p id="e4f7" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><em class="km">拜占庭故障<br/> 3m + 1处理器算法<br/>工作证明<br/>终结性问题<br/>卡斯珀·FFG</em></p><h1 id="6960" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">拜占庭断层</h1><p id="e0fd" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><strong class="jq hu">一致性</strong>是分布式系统中所有节点对单一状态达成一致或做出相同决定的过程。<strong class="jq hu">共识算法</strong>是流程的一套协议或规则。</p><p id="7343" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">共识是复杂的，因为它基本上是许多身体问题，当包括各种约束时甚至复杂得多。最困难的约束之一是拜占庭故障。</p><p id="1ac2" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated"><strong class="jq hu">拜占庭故障</strong>表示可能存在异常或恶意节点，它们不遵守规则，甚至故意违反规则来阻止共识。这些节点可能会这样做，因为它们被黑客破坏或占用。虽然这个问题从“拜占庭”这个名称来看似乎是一个非常古老的问题，但直到80年代人们才开始研究拜占庭断层。</p><p id="d95e" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在1982年发表的早期论文中，拜占庭断层被描述成如下图。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/dfb99b642d7cd821cf1d2cf3efc9ea59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*uvyXN-54G4qteDEipnAlAw.png"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Byzantine Problem</figcaption></figure><p id="0b50" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">拜占庭军队的几个师在敌人周围扎营。每个师的将军都必须做出进攻或撤退的决定。他们希望达成一致的决定，以避免出现一些师进攻而另一些师撤退的麻烦情况。为了统一决策，拜占庭将军可以派使者把他的意图传达给其他将军。但问题是，将军中也可能有叛徒。这些叛徒会扰乱信息交换，阻止所有正常的将军得出相同的结论。例如，如果将军⑥是叛徒，他可能会向将军①发出进攻意图，但向将军②和将军⑤发出撤退意图，以防止达成共识。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff le"><img src="../Images/ed2165b1e27b66e93704ce5ad7025b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*qNtqzl16gNJigzkyv7HlFQ.png"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Traitor general tries to disturb the consensus.</figcaption></figure><p id="fb4c" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">如果没有叛徒，简单多数原则总能让将军们达成共识。换句话说，每个将军收集所有其他将军的意图，并根据包括他自己在内的半数以上将军的意图得出结论。如果所有的将军正好被分成两半，则可以应用默认动作。但是有了叛徒的可能性，问题就变得复杂了。如果6个将军中只有一个叛徒，这种多数原则是否也能让其他5个将军一直达成共识<strong class="jq hu"/>？或者，是否有其他规则可以保证达成共识？6个将军中2个叛徒怎么样？</p><p id="b3f9" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在像上面这样的情况下，如果一个共识算法可以使所有忠诚(非叛徒)的将军得出相同的决策，这个算法就被称为<strong class="jq hu">拜占庭容错</strong>。算法具有拜占庭容错的特征或要求是<strong class="jq hu">拜占庭容错</strong>或<strong class="jq hu"> BFT </strong>简称。</p><p id="079e" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">为了更清楚地理解，让我们用一个最简单的案例进行更详细的解释。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff lf"><img src="../Images/4acfeaa4daa3c72a136f00f04d156145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_gJa7p-nUO02KWBiJ4mvmA.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Simplest Case : 2 Loyal Generals and 1 Traitor</figcaption></figure><p id="994b" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">假设总共有三个将军，其中只有一个是叛徒。当然没有人知道谁是叛徒。共识算法是一个简单的多数规则。</p><p id="620d" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">这个叛徒总是向其他两位将军发出相反的意图来阻碍共识。你可以看到上图中的情况(1)和情况(2)，如果2个忠诚的将军有相同的意图，他们会不顾叛徒的干扰，建立一个相同的结论。但就像情况(3)，如果2个忠诚的将军有不同的意图，他们中的一个会进攻，另一个会在最后撤退。在情况(3)中，共识将被打破，因此对于这2个忠诚的将军和1个叛徒，多数规则是<strong class="jq hu">而不是</strong>拜占庭容错。那么，针对这种情况的拜占庭容错一致性算法是什么呢？</p><p id="f2d2" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">从理论上证明了如果不使用消息签名，不存在3个将军1个叛徒的拜占庭容错算法。</p><p id="76da" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">除了拜占庭式的错误，共识中还有<strong class="jq hu">各种各样的约束</strong>。最常见的约束是消息传递是否有保证，消息是否签名，以及网络是否完全连接。<br/>一个网络被称为<strong class="jq hu">同步</strong> (sync。)如果在一定的延迟限制内保证交付，或者<strong class="jq hu">异步</strong> (async。)如果消息可能由于通信故障或过载而丢失。当然，让异步网络比同步网络具有拜占庭式的容错能力要困难得多。如果应用了消息签名，恶意节点在转发来自其他节点的消息时不能更改消息，尽管它自己的消息仍然可以被操纵。因此，使用消息签名，可以更容易地设计拜占庭容错算法。但是，建立可靠的消息签名系统也需要相当大的成本和精力。</p><p id="c221" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">[1] L .兰波特、r .肖斯塔克和m .皮斯，《拜占庭将军问题<a class="ae lk" href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Byzantine-Generals-Problem.pdf" rel="noopener ugc nofollow" target="_blank">》，1982年<br/><br/></a><a class="ae lk" href="https://en.wikipedia.org/wiki/Digital_signature" rel="noopener ugc nofollow" target="_blank">数字签名</a></p></div><div class="ab cl ll lm hb ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hm hn ho hp hq"><h1 id="ae56" class="iq ir ht bd is it ls iv iw ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn dt translated">3m + 1处理器算法</h1><p id="3091" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">保证拜占庭容错的通用算法的第一个成果是1980年出现的“<strong class="jq hu"> 3 <em class="km"> m </em> + 1处理器算法</strong>”。</p><p id="4cab" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">本文首先证明了对于一个有<em class="km"> m </em>个故障节点的同步网络，如果网络总共有等于或小于3个<strong class="jq hu"> <em class="km"> m </em> </strong>个节点，则不存在拜占庭容错一致性算法。换句话说，先决条件是<strong class="jq hu">等于或大于3个<em class="km"> m个</em> + 1个</strong>节点。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff lx"><img src="../Images/5a4cd313d5ca7ed9492012c1cac5656a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRGD6u4yL9HsYhQm7aXybg.png"/></div></div></figure><p id="307f" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">例如，如果3个节点中有1个故障节点，则不存在拜占庭容错算法。当预计有1个故障节点时，网络应该至少有4 (3 <em class="km"> m </em> + 1，<em class="km"> m </em> = 1)个节点，如上图中左起第二个。如果节点更脆弱，并且可以同时存在2个故障节点，则网络应该至少有7 (3 <em class="km"> m </em> + 1，<em class="km"> m </em> = 2)个节点用于拜占庭容错，如上图中的最后一个。</p><p id="1e65" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">那么，什么是拜占庭容错算法，保证3 <em class="km"> m </em> + 1约束的情况下。在讨论细节之前，我们先来看一个简单的消息传递符号。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff ly"><img src="../Images/81e4f25dc5336b07efa773d63bdfa3ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SBf9EtAKzWLXfcguQLGC9A.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Message Delivery for 4 Nodes Network</figcaption></figure><p id="ed46" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">上图显示了一个简单的4节点网络的消息传递。从节点①到节点④最多可以有5条不同的路径传递消息，包括中继。但是消息将访问中间节点超过2次的重复中继被排除在外。<br/> 5条路径包括1条直接传送路径、2条带有1个中继的间接传送路径和2条带有2个中继的路径。<br/>这些案例表示如下</p><pre class="kt ku kv kw fq lz ma mb mc aw md dt"><span id="003a" class="me ir ht ma b fv mf mg l mh mi"><em class="km">v:1:4                     : direct delivery from <br/>v:1:2:4                   : relayed by node 2<br/>v:1:3:4                   : relayed by node 3<br/>v:1:2:3:4                 : relayed by node 2 and 3 in turn<br/>v:1:3:2:4                 : relayed by node 3 and 2 in turn</em></span></pre><p id="2894" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">例如，<em class="km"> v:1:3:2:4 </em>表示消息由节点①发送到节点③，由节点③中继到节点②，再由节点②中继，最后到达节点④。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff mj"><img src="../Images/b23a495a8d04e2f1e3eae6142b40a199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mX4VHyS--b86Up19D_SzNw.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">3m + 1 Processor Algorithm</figcaption></figure><p id="294c" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">以上语句是名为<strong class="jq hu"> 3 <em class="km"> m </em> + 1处理器算法</strong>的共识算法。该算法强制足够的<strong class="jq hu">继电器</strong>用于拜占庭容错。<br/>更确切地说，对于一个最多可能有<em class="km"> m </em>个故障节点，因此至少包含3 <em class="km"> m </em> + 1个节点的网络，应该<strong class="jq hu">将每个消息<em class="km"> m </em>次</strong>中继。并且每个节点必须考虑<em class="km"> m </em>次中继的节点，代表多数原则决定其他节点的意图。</p><p id="c354" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">如果网络有4个节点(<em class="km"> m </em> = 1)来覆盖最多1个故障节点，每个节点必须在收集来自其他3个节点的直接消息(<em class="km"> OM(1) </em>)和1次中继消息(<em class="km"> OM(0) </em>)后做出决策。对于<em class="km"> m </em> = 1，2次中继也是可以的，但是按照算法1次中继就够了。<br/>对于<em class="km"> m </em> = 2，网络有7个节点克服2个故障节点，每个节点应收集直接消息(<em class="km"> OM(2) </em>)、1次中继消息(<em class="km"> OM(1) </em>)和2次中继消息(<em class="km"> OM(0) </em>)。7个节点，最多可以中继5次，中继2次就够了。<br/>因此，当用<em class="km"> m </em>个故障节点概括时，至少3个<em class="km"> m </em> + 1个节点中的每个正常节点必须收集直接传递的消息(<em class="km"> OM(m) </em>，1次中继的(<em class="km"> OM(m-1) </em>，2次中继的(<em class="km"> OM(m-2) </em>，等等，直到那些<em class="km"> m </em>次中继的(<em class="km"> OM(0) 【T31)</em></p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Recursions of 3m + 1 Processor Algorithm</figcaption></figure><p id="deaf" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">您可能会注意到，在转发消息时，消息不会被再次发送到之前已经传递过的节点。例如，在7节点网络中，节点①的消息经过节点②中继后到达节点③，就不会再发送到节点②或节点①。该消息将被发送到④到⑦的其他节点。</p><h2 id="e564" class="me ir ht bd is mm mn mo iw mp mq mr ja jz ms mt je kd mu mv ji kh mw mx jm my dt translated">最简单的情况</h2><p id="2a54" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">为了理解继电器如何对拜占庭容错做出更多贡献，让我们更详细地讨论最简单的情况(其中<em class="km"> m </em> = 1)。</p><p id="8999" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">下图显示了节点①、③和④如何根据3 <em class="km"> m </em> + 1处理器算法收集节点②发出的消息</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff mz"><img src="../Images/a10f35476f245f6be7eb9b2dddea892f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xDRwUf1DxhdEfpO0-Um0gg.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">OM(1) and OM(0)</figcaption></figure><p id="56d0" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">如果节点②是叛逆者，则有<strong class="jq hu"> 6种不同的情况</strong>节点②将其意图发送给其他节点以扰乱共识。您可以从下表中的<em class="km"> v:2:1 </em>、<em class="km"> v:2:3 </em>和<em class="km"> v:2:4 </em>列中看到这些情况。在这6种情况下，节点②向其他节点发送不同的意图。排除节点②发送相同意图的情况，因为这些情况不会扰乱共识。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff na"><img src="../Images/718127c39bd1ab38f567ed08529898ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Augr2JqCy-fn2QzNwFgJ0A.png"/></div></div></figure><p id="7e35" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">如果节点①、③和④只接收来自节点②的直接消息，它们将对每种情况得出不同的意图(进攻或撤退)。你可以在上表的浅橙色背景栏中看到它。<br/>但令人惊讶的是，<strong class="jq hu">如果有一次中继信息被收集到</strong>，事情就变了。<br/>参见上表中的浅绿色列。对于情况1)。虽然节点②向节点①和③发送'攻'，但向节点④发出'退'，每个节点都可以集合所有这些'攻'、'攻'、'退'。换句话说，节点①、③和④都从节点②收集相同的值(<em class="km"> 2A + R </em>，2个‘攻’和1个‘退’)，所以它们在节点②上有相同的结论。<br/>对于其他情况——情况2)情况6)，情况相同。即使收集的值可能因情况而异，如<em class="km"> 2A + R </em>或<em class="km"> A + 2R </em>。在单个案例中，所有节点的值都相同。<br/>6例中仅1例出现。因此，在任何情况下，节点①、③和④对节点②都有相同的结论。</p><p id="6aae" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">更一般地说，通过中继，每个正常节点(①、③或④)可以收集发送者(②)发送给其他节点(①为③和④，④为③和①，④为①和③)的所有消息。换句话说，每个节点将看到相同的消息集，因此有相同的结论。</p><pre class="kt ku kv kw fq lz ma mb mc aw md dt"><span id="f6c1" class="me ir ht ma b fv mf mg l mh mi"># When node 2 is traitor</span><span id="06b4" class="me ir ht ma b fv nb mg l mh mi"><em class="km">v:2:3:1 = v:2:3<br/>v:2:4:1 = v:2:4<br/>v:2:::1 = v:2:1 + v:2:3:1 + v:2:4:1 = v:2:1 + v:2:3 + v:2:4</em></span><span id="1ffe" class="me ir ht ma b fv nb mg l mh mi"><em class="km">v:2:1:3 = v:2:1<br/>v:2:4:3 = v:2:4<br/>v:2:::3 = v:2:3 + v:2:1:3 + v:2:4:3 = v:2:3 + v:2:1 + v:2:4</em></span><span id="0378" class="me ir ht ma b fv nb mg l mh mi"><em class="km">v:2:1:4 = v:2:1<br/>v:2:3:4 = v:2:3<br/>v:2:::4 = v:2:4 + v:2:1:4 + v:2:3:4 = v:2:4 + v:2:1 + v:2:3</em></span><span id="e716" class="me ir ht ma b fv nb mg l mh mi"><strong class="ma hu"><em class="km">v:2:::1 = v:2:::3 = v:2:::4</em></strong></span></pre><p id="9b1c" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">基于中继的相同原理即使在有更多节点时也适用。经过足够的中继后，每个节点可以收集从一个节点发送到其他节点的所有消息，从而做出相同的决策。</p><p id="d4e5" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">3m  + 1处理器算法看起来非常有用，因为它有简单的递归规则。但实际上，由于其复杂性，该算法在可扩展性方面存在致命弱点。从下表中可以看出，随着中继的重复，消息的数量急剧增加。相对于<em class="km"> m </em>(故障节点数)的复杂度为<em class="km"> O </em> ( <em class="km"> nᵐ </em>)。因此，该算法仅适用于小型网络。对于大型网络，我们需要其他算法。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="a4d3" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">[1] M. Pease、R. Shostak和L. Lamport，<a class="ae lk" href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/Reaching-Agreement-in-the-Presence-of-Faults.pdf" rel="noopener ugc nofollow" target="_blank">在</a>面前达成协议</p></div><div class="ab cl ll lm hb ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hm hn ho hp hq"><h1 id="626c" class="iq ir ht bd is it ls iv iw ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn dt translated">工作证明</h1><p id="48d6" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在上面解释的3 <em class="km"> m </em> + 1处理器算法或pBFT中，节点<strong class="jq hu">协作</strong>来克服拜占庭故障。为了在损坏或被攻击的节点的干扰下进行协作，算法对节点的数量有限制，并且需要足够的通信，这限制了<strong class="jq hu">可扩展性</strong>。<br/> 3 <em class="km"> m </em> + 1处理器算法复杂度为<em class="km"> O </em> ( <em class="km"> nᵐ </em>)，pBFT复杂度为<em class="km"> O </em> ( <em class="km"> n </em>)。</p><p id="ab97" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">工作证明(PoW)算法采用完全不同方法。在电力网络中，每个节点<strong class="jq hu">竞争</strong>而不是合作。成功解决一个极难解决但非常容易验证的数学难题的节点将在那时为整个网络做出决定。在一个谜题被解决并且答案在网络中传播之后，下一个谜题的竞争就开始了。<br/>这类谜题有几种，包括哈希计算和大整数的质因数分解。没有特殊的公式或技术来更快地解决这类难题。只有简单的反复试验才是有效的策略。<br/>所以，一个节点解谜的几率完全是<strong class="jq hu">概率</strong>。概率完全取决于节点的计算能力。如果计算能力在节点间足够分散，那么特定的一个或多个节点实际上不可能统治PoW网络。</p><p id="c5f9" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">公共区块链网络，如比特币和以太坊，由于网络对任何人开放，任何人都可以作为自己的节点加入，计算能力的集中在很大程度上受到抑制。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff nc"><img src="../Images/99ec109a024b6c25fdc13e7b4ca54e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJqbioyLLfdi5qLb9SRMMg.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Process of PoW</figcaption></figure><p id="b1b8" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">对于比特币和以太坊，难题是找到一个随机数，该随机数满足与随机数结合的块头散列的非常特定的条件。<br/>作为理解的一个简单(不真实)的例子，条件说散列应该以4个前导零开始。下面的句子更简洁明了地表达了情况或难题— <em class="km"> SHA-256 </em>是流行的哈希函数之一，而<em class="km">数据</em>表示块头</p><pre class="kt ku kv kw fq lz ma mb mc aw md dt"><span id="482c" class="me ir ht ma b fv mf mg l mh mi"><em class="km">Find </em><strong class="ma hu"><em class="km">nonce</em></strong><em class="km"> for </em><strong class="ma hu"><em class="km">SHA-256</em></strong><em class="km">(</em><strong class="ma hu"><em class="km">data </em></strong><em class="km">+ </em><strong class="ma hu"><em class="km">nonce</em></strong><em class="km">) to Start with '</em><strong class="ma hu"><em class="km">0000</em></strong><em class="km">'</em></span></pre><p id="64a5" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">哈希function⁴是一个将任意大小数据转换为固定大小的数据的函数，这些数据的值完全不同且不可预测。<br/>哈希函数有一些重要而独特的特性。第一个也是最重要的一个是函数是不可逆的。更正式地说，散列函数没有反函数。<br/>例如，简单明了的SHA-256⁵哈希值为“<em class="km"> Hello，world！</em>"是"<em class="km"> 0x315f5bdb76d0… </em>"，但是对于"<em class="km"> 0x315f5bdb76d0… </em>"是"<em class="km">你好，世界！</em>“使用任何配方或特殊技术。</p><pre class="kt ku kv kw fq lz ma mb mc aw md dt"><span id="40b9" class="me ir ht ma b fv mf mg l mh mi">SHA-256("Hello, world!") = "0x315f5bdb76d0…"    # easy<br/>SHA-256⁻¹("0x315f5bdb76d0…") = "Hello, world!"  # no formula</span></pre><p id="fda7" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">第二个特征是，即使输入发生很小的变化，哈希函数也会改变输出(哈希值)很多。换句话说，哈希函数非常动态地扩散输入。<br/>您可以在下表中看到这一点。在表中，输入值与“<em class="km"> Hello，world！</em>【到】<em class="km">你好，世界！</em><strong class="jq hu"><em class="km">0</em></strong><em class="km">你好，世界！</em> <strong class="jq hu"> <em class="km"> 1 </em> </strong>，<em class="km">你好，世界！</em> <strong class="jq hu"> <em class="km"> 2 </em> </strong>等等。但是它们的哈希值完全不同。你永远猜不到也算不出“<em class="km">你好，世界！</em> <strong class="jq hu"> <em class="km"> 1 </em> </strong>【来自哈什】<em class="km">你好，世界！</em><strong class="jq hu"><em class="km">0</em></strong><em class="km">你好，世界！</em> <strong class="jq hu"> <em class="km"> 2 </em> </strong>"，或其他类似的输入。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff nd"><img src="../Images/d488e36fe96d14176dd65b8c7303a3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ko6zjSGEyD4TP2F---uUSA.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Finding Nonce Example</figcaption></figure><p id="d792" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">如果您需要找到一个nonce，当追加到“Hello，world！”之后时，它将产生以4个前导零(“0x0000”)开始的哈希值—比如“你好，世界！在上表的最后一行，没有比来自<em class="km"> Hello，world的简单顺序试验更有效的特殊方式或方法了！</em> <strong class="jq hu"> <em class="km"> 0 </em> </strong>【到】<em class="km">你好，世界！</em> <strong class="jq hu"> <em class="km"> 4250 </em> </strong>”。</p><p id="5784" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">以太坊使用具体幂算法是Ethash⁶.Ethash使用Keccak-256作为哈希函数。Ethash的难题是找到一个nonce，使得块头的Keccak-256散列和该nonce小于指定值。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/d88e458d2e7fe76d9b1459f54e7813b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*WgRyBzAhjk-_lSPKlM_8JA.png"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Mining Function of Ethash</figcaption></figure><p id="15ef" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">以上<code class="eh nf ng nh ma b"><em class="km">mine</em></code>是Ethash specification⁶.中描述的Python函数在比特币或以太坊中，找到满足条件的nonce并解谜的过程称为<strong class="jq hu">挖掘</strong>。成功找到随机数的节点将被给予奖励。所以解谜就像挖金子一样。</p><p id="78a9" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在上述函数的<code class="eh nf ng nh ma b"><em class="km">while</em></code>子句中，重复试验，将nonce改变1，直到散列值(<code class="eh nf ng nh ma b"><em class="km">hashimoto_full</em></code>)等于或小于某个<code class="eh nf ng nh ma b"><em class="km">target</em></code>。<code class="eh nf ng nh ma b"><em class="km">target</em></code>是将2个⁵⁶除以指定的<code class="eh nf ng nh ma b"><em class="km">difficulty</em></code>得到的值。SHA-256的哈希值是64位十六进制数，最大值是2 ⁵⁶.<code class="eh nf ng nh ma b"><em class="km">target</em></code>小于2 ⁵⁶，所以当用64位十六进制表示时，值有前导<code class="eh nf ng nh ma b"><em class="km">0</em></code>(零)s，例如，<code class="eh nf ng nh ma b"><em class="km">target</em></code>值2 ⁷有7个前导<code class="eh nf ng nh ma b"><em class="km">0</em></code> s，<code class="eh nf ng nh ma b"><em class="km">target</em></code>值2 ⁰⁵有12个前导<code class="eh nf ng nh ma b"><em class="km">0</em></code></p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ni ml l"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Target and Difficulty</figcaption></figure><p id="aa7d" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated"><code class="eh nf ng nh ma b"><em class="km">target</em></code> <em class="km"> </em>和<code class="eh nf ng nh ma b"><em class="km">difficulty</em></code> <em class="km"> </em>的乘积是常数2 ⁵⁶.升高<code class="eh nf ng nh ma b"><em class="km">difficulty</em></code> <em class="km"> </em>将降低<code class="eh nf ng nh ma b"><em class="km">target</em></code> <em class="km"> </em>以便更领先<code class="eh nf ng nh ma b"><em class="km">0</em></code> s。<br/>sha-256的所有散列值的数量是2个⁵⁶，在给定的难度下，成功挖掘的散列值的数量是<code class="eh nf ng nh ma b"><em class="km">target</em></code>。所以，<code class="eh nf ng nh ma b"><em class="km">target</em></code> /2 ⁵⁶在单次试验中成功开采的可能性很大。这与<code class="eh nf ng nh ma b"><em class="km">difficulty</em></code> (1/ <code class="eh nf ng nh ma b"><em class="km">difficulty</em></code>)的逆运算相同。</p><p id="6e02" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">下表是以太坊mainnet中几个区块的真实<code class="eh nf ng nh ma b"><em class="km">difficulty</em></code> s和<code class="eh nf ng nh ma b"><em class="km">target</em></code> s。如果<code class="eh nf ng nh ma b"><em class="km">difficulty</em></code>设法保持不变，块创建间隔将受到节点数量或它们消耗的总计算能力的影响。为了防止块创建间隔的波动并保持块创建时间的一致性和可预测性，以太坊根据最近的块时间不断地协调新块的<code class="eh nf ng nh ma b"><em class="km">difficulty</em></code> <em class="km"> </em>。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff nj"><img src="../Images/9d3837dd66fbd0a6216e128cd43c8df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1eQekkaPdNKvyBtn5hDrQA.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Difficulty and Target Samples from Ethereum Mainnet</figcaption></figure><p id="b378" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在比特币或以太坊中，每笔交易都经过数字签名，因此故障或叛徒节点无法操纵交易。块非常容易验证，尽管极难挖掘，使得恶意节点不能传播无效块。像这种方式，同时使用<strong class="jq hu"> PoW </strong>和<strong class="jq hu">数字签名</strong>，比特币和以太坊可以<strong class="jq hu">实现拜占庭容错</strong>。</p><p id="7835" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">因为PoW是基于竞争而不是合作来工作的，所以<strong class="jq hu">复杂性与节点数量</strong>无关。复杂程度很大程度上取决于拼图的难度。因此，对于包含数百或数千个节点的大型网络，PoW似乎比基于公司的一致性算法(如pBFT)更有利。但是权力也有致命问题。最广为人知的一个是激烈竞争造成的巨大能源浪费，另一个重要的问题是<strong class="jq hu">终结性问题</strong>，下面将详细解释。</p><h2 id="0f83" class="me ir ht bd is mm mn mo iw mp mq mr ja jz ms mt je kd mu mv ji kh mw mx jm my dt translated">终结性问题</h2><p id="fdf7" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">概括地说，成功的解谜被称为战俘网络中的挖掘。采矿意味着一个新的区块被创造出来，矿工得到奖励。大量节点激烈竞争以获得奖励。<br/>查看挖掘规则的详细信息，除了要添加的事务和nonce之外，哈希计算还包括最后一个块的哈希值。这是为了保持区块链线性或一维。这使得损害区块链的完整性更加困难，并防止了区块链的冲突状态。在大多数情况下，开采间隔足以保持区块链线性。但是无论<code class="eh nf ng nh ma b"><em class="km">difficulty</em></code> <em class="km"> </em>增加多少，几乎都可以同时进行挖掘，因为挖掘本质上是概率性的。<br/>虽然验证非常简单，但是将挖掘出的块传播到世界上的所有节点需要时间。所以同时挖掘会使整个网络有点不均匀。</p><p id="2d93" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">比如下面这个例子。如果两个遥远的节点<strong class="jq hu"> <em class="km"> P </em> </strong>和<strong class="jq hu"> <em class="km"> Q </em> </strong>成功地挖掘出一个block—block<strong class="jq hu"><em class="km">【B(m)</em></strong><em class="km"/>和block<strong class="jq hu"><em class="km">【B(n)</em></strong><em class="km"/>中的每一个—几乎同时，在时间内不足以传播<strong class="jq hu"><em class="km">【B(m)</em></strong><em class="km"/>和<strong class="jq hu"> 围绕<strong class="jq hu"> <em class="km"> P </em> </strong>的节点将把<strong class="jq hu"><em class="km">【B(m)</em></strong>作为最后一个块，围绕<strong class="jq hu"><em class="km">【Q</em></strong>的节点将把<strong class="jq hu"><em class="km">B(m)</em></strong><em class="km"/>作为最后一个块。 与<strong class="jq hu"> <em class="km"> P </em> </strong>和<strong class="jq hu"> <em class="km"> Q </em> </strong>距离相近的节点无法区分哪个区块实际上最先开采。</strong></p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff nk"><img src="../Images/dd66766f95bfe0b2ef25d25b13dd7f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vU6npBPInQBHmgZaC_PjIw.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Two different nodes may succeed mining almost simultaneously.</figcaption></figure><p id="ce5f" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated"><strong class="jq hu"><em class="km">B(m)</em></strong><em class="km"/>和<strong class="jq hu"><em class="km">B(n)</em></strong><em class="km"/>都是基于同一个前一个块。换句话说，它们包含前一个块头的相同散列。因此，前一个块被称为父块。</p><p id="7b8c" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">节点不断尝试挖掘下一个块以获取奖励。首先接收到<strong class="jq hu"> <em class="km"> B(m) </em> </strong>的一些节点将基于<strong class="jq hu"> <em class="km"> B(m) </em> </strong>挑战下一个块，但是之前接收到<strong class="jq hu"> <em class="km"> B(n) </em> </strong>的其他节点将基于<strong class="jq hu"> <em class="km"> B(n) </em> </strong>挑战下一个块。尽管由于大多数情况下的困难，成功的开采有足够的时间间隔，但几乎同时进行下一次开采的可能性非常低。在这些情况下，挖掘块可以具有不同的父块。例如，第二个同步块之一基于<strong class="jq hu"> <em class="km"> B(m) </em> </strong>，另一个基于<strong class="jq hu"> <em class="km"> B(n) </em> </strong>，如下图所示。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff nk"><img src="../Images/76f3910cf523c66dc21e9c13be674210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lkAmUZhKA8RLp1TVZ3Inow.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Next time, another 2 different miners may succeed mining almost simultaneously again.</figcaption></figure><p id="1a02" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">您可以看到整个链不再是线性的，尽管之前没有违反PoW规则。这叫分叉，从分叉点开始的每一个线性(线性连接)的部分叫分支。在上面的例子中，有两个分支。一个分支是<strong class="jq hu"> <em class="km"> B(m) </em> </strong>后跟<strong class="jq hu"> <em class="km"> B(m2) </em> </strong>另一个是<strong class="jq hu"> <em class="km"> B(n) </em> </strong>后跟<strong class="jq hu"> <em class="km"> B(n2) </em> </strong>。</p><p id="3690" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">随着高度的挖掘竞争和网络中的不均匀性，先前的异常(但不是非法的)情况可以进一步继续。换句话说，2个分支长得更像<strong class="jq hu"><em class="km">B(m)</em></strong><em class="km">-</em><strong class="jq hu"><em class="km">B(m2)</em></strong><em class="km">-</em><strong class="jq hu"><em class="km">B(m3)</em></strong><em class="km">-</em><strong class="jq hu"><em class="km">B(M4)</em></strong>和<strong class="jq hu"><em class="km">B(n)</em></strong><em class="km">-</em><strong class="jq hu"><em class="km">或者甚至可能出现另一个分支。但是，最终只有一个分支会存活下来，因为挖掘真的很难，而且所有这些都是概率性的。还有另一种称为最长链规则的机制，它强制在分叉情况下选择最长的分支。一旦其中一个同时发生的分支开始快速生长，最长规则只会加速一个分支的存活。</em></strong></p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff nk"><img src="../Images/683a01cece382e3e0cacf5e5f10c2ddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHeNrhRwDPUXlBypzzDEWA.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Eventually, only one branch will survive after a fork.</figcaption></figure><p id="d0ea" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">虽然从长远来看，这个链仍然是线性的，但与此同时，可能会有一个叫做终结性问题的严重问题。<strong class="jq hu">终结性问题</strong>是成功挖掘的事务或块由于上述分叉而变得无效或取消的情况。它不是由侵犯权力引起的。这是权力固有一面。<br/>下图描述了一个终结性问题的典型过程。它显示了区块链随着时间的推移而成长。在<em class="km"> ② </em>处，包含<strong class="jq hu"> <em class="km"> tx(b) </em> </strong>的<strong class="jq hu"> <em class="km"> B(n) </em> </strong>区块开采成功。但几乎同时另一块<strong class="jq hu"><em class="km">【B(m)</em></strong>它不是<strong class="jq hu"><em class="km">【B(n)</em></strong>的子块也在制作一个fork( <em class="km"> ③ </em>)。虽然两个分支一直在一起生长，但毕竟一个源于<strong class="jq hu"> <em class="km"> B(m) </em> </strong>的分支幸存了下来，使块<strong class="jq hu"><em class="km">【n】</em></strong>和事务<strong class="jq hu"><em class="km">【tx(B)</em></strong>失效，就像<em class="km"> ⑥ </em>一样。这意味着一次完全提交的事务可以在以后回滚。从数据持久性系统的角度来看，这是一个很大的缺点。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff nl"><img src="../Images/4104c38c63e396f6d9795ceb1987a4bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pM7fAswiRUhYoJgia3oxsA.png"/></div></div></figure><p id="8bb2" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">为了解决终结性问题，我们应该等待并观察一段时间，让包含我们的事务的块在挖掘后进一步增长。通常，比特币需要6块，以太坊需要12块。当然，这些数字并不能保证完美的结局。目前以太坊的封锁时间大约是13秒。但最终性问题使得确认交易的实际时间从13秒变成了2.6分钟。</p><p id="6bd5" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">终结性问题可以被一个巨大的矿工利用来损害区块链的完整性和信任。如果他或她拥有整个采矿能力的50%以上，他或她可以使非常重要或昂贵的交易无效，以赚取利润或达到邪恶的目的。这叫“51%攻击”。<br/>尽管在数百家独立和活跃的矿商中占据50%以上的开采权几乎是不可能的，但实际上仍有51%的attack⁷.以太坊类(ETC)是2019年1月的attacked⁸，比特币黄金(BTG)是1月的2020⁹.</p><p id="6939" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">为了解决终结性问题，以太坊开发了一种新的共识算法，称为卡斯珀FFG，这是以太坊2.0的关键特性之一。</p><p id="a8fa" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">[1] <a class="ae lk" href="https://en.wikipedia.org/wiki/Proof_of_work" rel="noopener ugc nofollow" target="_blank">工作证明</a><br/>【2】<a class="ae lk" href="https://privacycanada.net/mathematics/prime-factorization/" rel="noopener ugc nofollow" target="_blank">质因数分解</a><br/>【3】<a class="ae lk" href="https://en.wikipedia.org/wiki/Trial_and_error" rel="noopener ugc nofollow" target="_blank">试错</a><br/>【4】<a class="ae lk" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank">哈希函数</a><br/><a class="ae lk" href="https://en.wikipedia.org/wiki/SHA-2" rel="noopener ugc nofollow" target="_blank">SHA-256</a><br/>【6】<a class="ae lk" href="https://github.com/ethereum/wiki/wiki/Ethash" rel="noopener ugc nofollow" target="_blank">Ethash规范</a><br/>【7】<a class="ae lk" href="https://academy.binance.com/en/articles/what-is-a-51-percent-attack" rel="noopener ugc nofollow" target="_blank">什么是51%攻击？</a><br/>【8】<a class="ae lk" href="https://bravenewcoin.com/insights/etc-51-attack-what-happened-and-how-it-was-stopped" rel="noopener ugc nofollow" target="_blank">ETC 51 %攻击——发生了什么以及如何被阻止</a>(2019年1月14日)<br/>【9】<a class="ae lk" href="https://cointelegraph.com/news/bitcoin-gold-blockchain-hit-by-51-attack-leading-to-70k-double-spend" rel="noopener ugc nofollow" target="_blank">比特币黄金区块链遭受51%攻击导致70K美元双倍支出</a>(2019年1月27日)</p></div><div class="ab cl ll lm hb ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hm hn ho hp hq"><h1 id="77bc" class="iq ir ht bd is it ls iv iw ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn dt translated">卡斯帕·FFG</h1><p id="71ab" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><strong class="jq hu">卡斯珀·FFG</strong>是一种PoS(利害关系证明)共识算法，具有一些独特的功能，有望解决或显著改善终结性问题。它由Vitalik Buterin和Virgil Griffith在2017年首次提出。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/c5c5282f05b215205c9f7652964b5c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*DlVVrRASrzyJTglIlQecZA.png"/></div></figure><p id="74c1" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">首先，卡斯帕FFG是一个部分一致算法，它只承担T2终结协议。卡斯帕·FFG没有包括任何规则来制作或确认方块。它定义了一个协议，以便在fork情况下更快地在几个分支中确定一个真正的最终块。它可以应用于其他一致性算法，如PoW。因此，卡斯珀FFG被归类为覆盖算法。</p><p id="af83" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">第二，卡斯珀·FFG本身是一种<strong class="jq hu"> PoS(利益相关证明)算法</strong>，它期望选择的节点运行。与PoW网络中任何节点都可以参与挖掘不同，在PoS网络中，只有一些特殊的、有一定利害关系的节点才能加入共识，以决定类似阻塞的事情。在卡斯帕FFG，这些节点被称为<strong class="jq hu">验证器</strong>。</p><p id="26fe" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">第三，卡斯帕·FFG定义了激励规则和惩罚规则。包括pBFT在内的其他PoS算法通常没有惩罚规则。因此，即使一些恶意节点试图扰乱共识，也没有有效的方法来阻止它们。“无利害关系”是PoS算法最著名的问题之一。但是，在卡斯帕·FFG的案例中，不利用任何利害关系的验证者将受到惩罚，并失去他们所有的股份。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff nn"><img src="../Images/37887a718b8d3de747b76867bc354460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*de1Ps9_92CK_lJhuq_1eVw.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Casper FFG Processes — 1) Voting, 2) Justified, 3) Finalized</figcaption></figure><p id="47f8" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">像pBFT或通常的PoS算法一样，卡斯珀pBFT在固定的时间表内运行<strong class="jq hu">轮</strong>。在每一轮中，所有的验证者都应该按照两个严格的规则投票。如果一个验证器违反了一条规则，即使只有一次，它也会失去它的股份，并被逐出验证器。所以，这些规则被称为<strong class="jq hu">斜线条件</strong>。</p><p id="4d5a" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">如果一个区块在一轮中收到超过2/3的验证者的投票，则该区块被认为是<strong class="jq hu">合理的</strong>。对齐块仍然可以分叉，所以<strong class="jq hu">没有</strong>最终确定。但如果两个<strong class="jq hu">顺序块</strong>被对齐，则两者的<strong class="jq hu">父块</strong>成为<strong class="jq hu">最终终结</strong>。<br/>补充一些细节，因为斜杠条件禁止跨越投票，在两个相邻块赢得投票后，最多1/3的验证者可以在后面的回合中按照规则投票给父块以下的任何块。因此，除非另外1/3的验证器违反了斜杠条件，失去了所有的股份，否则父块将是所有后来的合理投票的祖先。</p><p id="cba1" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">由于惩罚规则(斜线条件)，卡斯帕FFG预计将促进更紧密的合作，并导致比最长链规则更快和更有效的最终确定。</p><p id="a09e" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">Casper FFG是信标链的控制算法，信标链是以太坊2.0相位0⁴.的最高特性</p><p id="2070" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">为了更具体的理解，如果阅读最新的论文，我在SlideShare的presentation⁵可能会有所帮助。</p><p id="8135" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">[1] Vitalik Buterin和Virgil Griffith，“<a class="ae lk" href="https://arxiv.org/pdf/1710.09437v1.pdf" rel="noopener ugc nofollow" target="_blank">Casper the Friendly Finality Gadget</a>”，2017<br/>【2】<a class="ae lk" href="https://www.mangoresearch.co/casper-nothing-at-stake-problem/" rel="noopener ugc nofollow" target="_blank">没有什么利害攸关的问题——一个分叉的烂摊子！</a><br/>【3】<a class="ae lk" href="https://hackmd.io/@benjaminion/eth2_info" rel="noopener ugc nofollow" target="_blank">以太坊2.0信息</a><br/>【4】<a class="ae lk" href="https://blog.ethereum.org/2019/11/27/validated-staking-on-eth2-0/" rel="noopener ugc nofollow" target="_blank">验证:下注eth 2 # 0</a><br/>【5】<a class="ae lk" href="https://www.slideshare.net/OhSangmoon/casper-ffg-explained-198734791" rel="noopener ugc nofollow" target="_blank">卡斯帕Info解释<br/></a>【6】维塔利克·布特林和维吉尔·格里菲斯，“<a class="ae lk" href="https://arxiv.org/pdf/1710.09437v4.pdf" rel="noopener ugc nofollow" target="_blank">卡斯帕友好的终结小工具，版本。4 </a>，2019</p><blockquote class="no"><p id="0454" class="np nq ht bd nr ns nt nu nv nw nx kl ek translated">加入<a class="ae lk" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank"> Coinmonks电报频道</a>，了解加密交易和投资</p></blockquote><h2 id="5638" class="me ir ht bd is mm ny mo iw mp nz mr ja jz oa mt je kd ob mv ji kh oc mx jm my dt translated">也阅读</h2><div class="od oe fm fo of og"><a href="https://blog.coincodecap.com/crypto-exchange" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab ej"><div class="oi ab oj cl cj ok"><h2 class="bd hu fv z el ol eo ep om er et hs dt translated">最佳加密交易所| 2021年十大加密货币交易所</h2><div class="on l"><h3 class="bd b fv z el ol eo ep om er et ek translated">加密货币交易所的加密交易需要了解市场，这可以帮助你获得利润…</h3></div><div class="oo l"><p class="bd b gc z el ol eo ep om er et ek translated">blog.coincodecap.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ky og"/></div></div></a></div><div class="od oe fm fo of og"><a href="https://blog.coincodecap.com/crypto-lending" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab ej"><div class="oi ab oj cl cj ok"><h2 class="bd hu fv z el ol eo ep om er et hs dt translated">2021年9大最佳加密借贷平台</h2><div class="on l"><h3 class="bd b fv z el ol eo ep om er et ek translated">当谈到加密货币贷款时，大量因素等同于良好的收入状况。此外，借款的一部分…</h3></div><div class="oo l"><p class="bd b gc z el ol eo ep om er et ek translated">blog.coincodecap.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ky og"/></div></div></a></div><div class="od oe fm fo of og"><a rel="noopener follow" target="_blank" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a"><div class="oh ab ej"><div class="oi ab oj cl cj ok"><h2 class="bd hu fv z el ol eo ep om er et hs dt translated">加密交易机器人——最佳免费加密交易机器人</h2><div class="on l"><h3 class="bd b fv z el ol eo ep om er et ek translated">2021年币安、比特币基地、库币和其他密码交易所的最佳密码交易机器人。四进制，位间隙…</h3></div><div class="oo l"><p class="bd b gc z el ol eo ep om er et ek translated">medium.com</p></div></div><div class="op l"><div class="ow l or os ot op ou ky og"/></div></div></a></div><div class="od oe fm fo of og"><a rel="noopener follow" target="_blank" href="/coinmonks/best-crypto-signals-telegram-5785cdbc4b2b"><div class="oh ab ej"><div class="oi ab oj cl cj ok"><h2 class="bd hu fv z el ol eo ep om er et hs dt translated">最佳6个加密交易信号电报通道</h2><div class="on l"><h3 class="bd b fv z el ol eo ep om er et ek translated">这是乏味的找到正确的加密交易信号提供商。因此，在本文中，我们将讨论最好的…</h3></div><div class="oo l"><p class="bd b gc z el ol eo ep om er et ek translated">medium.com</p></div></div><div class="op l"><div class="ox l or os ot op ou ky og"/></div></div></a></div><div class="od oe fm fo of og"><a href="https://blog.coincodecap.com/blockfi-review" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab ej"><div class="oi ab oj cl cj ok"><h2 class="bd hu fv z el ol eo ep om er et hs dt translated">BlockFi评论2021:利弊和利率</h2><div class="on l"><h3 class="bd b fv z el ol eo ep om er et ek translated">今天，我们提出了一个全面的BlockFi评论，这是一个成立于2017年的加密贷款平台，拥有其…</h3></div><div class="oo l"><p class="bd b gc z el ol eo ep om er et ek translated">blog.coincodecap.com</p></div></div><div class="op l"><div class="oy l or os ot op ou ky og"/></div></div></a></div><div class="od oe fm fo of og"><a rel="noopener follow" target="_blank" href="/coinmonks/best-crypto-tax-tool-for-my-money-72d4b430816b"><div class="oh ab ej"><div class="oi ab oj cl cj ok"><h2 class="bd hu fv z el ol eo ep om er et hs dt translated">加密税务软件——五大最佳比特币税务计算器[2021]</h2><div class="on l"><h3 class="bd b fv z el ol eo ep om er et ek translated">不管你是刚接触加密还是已经在这个领域呆了一段时间，你都需要交税。</h3></div><div class="oo l"><p class="bd b gc z el ol eo ep om er et ek translated">medium.com</p></div></div><div class="op l"><div class="oz l or os ot op ou ky og"/></div></div></a></div><div class="od oe fm fo of og"><a rel="noopener follow" target="_blank" href="/coinmonks/pionex-review-exchange-with-crypto-trading-bot-1e459d0191ea"><div class="oh ab ej"><div class="oi ab oj cl cj ok"><h2 class="bd hu fv z el ol eo ep om er et hs dt translated">Pionex评论2021 |免费加密交易机器人和交换</h2><div class="on l"><h3 class="bd b fv z el ol eo ep om er et ek translated">Pionex是为交易自动化提供工具的后起之秀。Pionex上提供了9个加密交易机器人…</h3></div><div class="oo l"><p class="bd b gc z el ol eo ep om er et ek translated">medium.com</p></div></div><div class="op l"><div class="pa l or os ot op ou ky og"/></div></div></a></div><div class="od oe fm fo of og"><a href="https://blog.coincodecap.com/best-hardware-wallet-bitcoin" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab ej"><div class="oi ab oj cl cj ok"><h2 class="bd hu fv z el ol eo ep om er et hs dt translated">存储比特币的最佳加密硬件钱包[2021]</h2><div class="on l"><h3 class="bd b fv z el ol eo ep om er et ek translated">保管您的数字资产很容易，但找到正确的存储方式却是一项繁琐的任务。在线钱包有一个风险…</h3></div><div class="oo l"><p class="bd b gc z el ol eo ep om er et ek translated">blog.coincodecap.com</p></div></div><div class="op l"><div class="pb l or os ot op ou ky og"/></div></div></a></div></div></div>    
</body>
</html>