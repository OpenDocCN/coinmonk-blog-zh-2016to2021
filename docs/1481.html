<html>
<head>
<title>Chubby: A lock service for distributed coordination</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Chubby:用于分布式协调的锁服务</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/chubby-a-centralized-lock-service-for-distributed-applications-390571273052?source=collection_archive---------0-----------------------#2018-09-10">https://medium.com/coinmonks/chubby-a-centralized-lock-service-for-distributed-applications-390571273052?source=collection_archive---------0-----------------------#2018-09-10</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="c04c" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">介绍</h2></div><p id="27fa" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在本帖中，我们将介绍谷歌的<a class="ae ke" href="https://static.googleusercontent.com/media/research.google.com/en//archive/chubby-osdi06.pdf" rel="noopener ugc nofollow" target="_blank">小胖锁服务</a>。本文介绍了一个锁服务，它可以帮助使用锁语义的分布式环境中的协调。Chubby在Google内部被广泛用于各种系统，如GFS、BigTable。主要目标是提供可靠的锁服务。Chubby没有针对高性能、频繁锁定的场景进行优化。有成千上万的客户端使用Chubby，但他们偶尔会使用Chubby——用于粗粒度锁定。通常，这种粗粒度的锁会被保持几个小时或几天，而不是几秒钟。Chubby在多个应用程序中的一个典型应用是选举一个主设备——第一个获得锁的设备获胜并成为主设备。</p><h2 id="d865" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">Paxos还是锁服务？</h2><p id="07a4" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">如果我们扩展上一节提到的例子，这个特定的问题实际上是一个在分布式系统中建立共识的问题。因此，人们可以通过使用paxos来解决这个问题，而不是建立一个集中的锁服务。为了让paxos工作，可以构建一个库，所有应用程序都将使用该库来加入共识。以下几点很好地解释了为什么谷歌生态系统选择了锁定服务。</p><ol class=""><li id="641f" class="lf lg ht jk b jl jm jo jp jr lh jv li jz lj kd lk ll lm ln dt translated"><strong class="jk hu">开发者友好</strong>:一般来说，开发人员在代码中添加锁定语义比基于共识的机制要容易得多。特别是，很多应用程序一开始并不庞大，随着它们变得越来越大，它们会添加代码来建立协调。大多数开发人员也更熟悉锁定语义。</li><li id="01c3" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated"><strong class="jk hu">带数据的事件通知</strong>:在大多数情况下，应用程序需要访问这种分布式环境中的少量数据——这意味着需要以一致的方式写入和读取数据。这非常适合锁定机制。</li><li id="8e30" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated"><strong class="jk hu">应用程序进度</strong>:在类似paxos的设置中，您需要启动大多数应用程序才能取得进展。在集中式锁服务模式中，即使只有一个客户机启动，只要它从Chubby正确访问锁，它就可以取得进展。</li></ol><h2 id="0cd9" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">设计决策</h2><p id="ca9a" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">以下主要设计决策来自上一节提到的主题。</p><ol class=""><li id="d381" class="lf lg ht jk b jl jm jo jp jr lh jv li jz lj kd lk ll lm ln dt translated">粗粒度锁定—应用程序不需要持续时间更短的锁定。例如，选举主人不是一件经常发生的事情。</li><li id="eba3" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">除了锁服务之外的小数据存储(小文件操作)能力</li><li id="2b04" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">允许成千上万的客户观察变化。因此，锁服务需要扩展以处理许多客户端，尽管事务率可能没有那么高。</li><li id="0e01" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">一种通知机制，通过这种机制，客户端可以知道共享文件中何时发生了更改，例如主文件发生了更改</li><li id="5d84" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">支持客户端缓存来处理可能想要主动轮询的客户端</li><li id="de71" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">强大的缓存保证简化开发人员的使用</li></ol><h2 id="96d6" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">系统结构</h2><figure class="lu lv lw lx fq ly fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/a008d08a64c364466089e33270432b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*o6RufyMOdnD56kZAiYfMJQ.png"/></div><figcaption class="mb mc fg fe ff md me bd b be z ek">Each client application uses chubby client side library for distributed coordination. Chubby master is elected as a leader among 5 replicas using a consensus protocol like paxos.</figcaption></figure><p id="17bc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">系统中有两个主要组件，chubby master和chubby client library。每个应用程序都对与chubby客户端库的分布式协调链接感兴趣。然后，客户端库代表客户端应用程序执行锁定协议。</p><p id="9525" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">主节点:胖胖的主节点由多个副本组成，其中一个副本使用分布式共识协议(如paxos)被选为主节点。所有副本还会授予主服务器一个租约，在此期间它们不会选举新的主服务器。</p><p id="a44c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一旦选择了主服务器，它就负责将它需要的任何持久状态写入数据库，然后在其他副本服务器上复制这些状态。在向客户端发回确认之前，写入操作需要进行大部分复制。只要租约还没有到期，主设备就可以向客户端提供读取服务，这表明周围没有其他主设备。</p><p id="794d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果主节点失败，则再次运行共识协议来选举新的主节点。</p><p id="29e7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">客户端</strong>:一个胖胖的单元为数千个客户端提供服务，因此这些客户端连接到一个主机来满足所有的协调需求。客户端使用DNS来查找主服务器。副本通过将客户端重定向到当前主服务器来响应客户端发出的DNS查询。一旦客户端找到主服务器，所有请求都会发送到该主服务器。客户端代表应用程序运行锁定协议，并向应用程序通知某些事件，如发生了主服务器故障转移。</p><h2 id="cde9" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">基于文件接口</h2><p id="1e5b" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">Chubby像API一样导出UNIX文件系统。文件和目录被称为节点。系统中不允许有链接。节点可以是永久的，也可以是短暂的。短暂节点消失，因为没有使用该节点的客户端消失。文件可以以指示排他性的读/写模式打开。客户端获得给定节点的句柄。每个节点还会分配以下元数据:</p><ol class=""><li id="f019" class="lf lg ht jk b jl jm jo jp jr lh jv li jz lj kd lk ll lm ln dt translated">实例编号—对于相同的名称，总是增加</li><li id="ee2f" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">内容生成编号—在内容被覆盖时增加</li><li id="d5b5" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">锁生成号—当锁从自由状态转换为持有状态时增加</li><li id="1250" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">与传统文件系统一样，节点上也有用于控制访问的ACL，ACL数量会随着ACL的变化而增加。</li></ol><p id="1855" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">还有其他带有客户端使用的句柄的元数据。这主要与新主机看到由以前的主机生成的句柄的情况有关。</p><h2 id="e2ab" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">锁、锁延迟和序列器</h2><p id="6ba2" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">客户端可以以写(独占)或读(共享)模式创建节点/文件。所有的锁都是建议性的，即参与实体需要遵循锁协议来访问分布式临界区。锁定文件并不能阻止对文件的自由访问。</p><p id="0692" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">分布式系统中锁的问题之一是持有锁的应用程序可能会死亡。想想下面的例子，R1最终以不一致的方式访问数据。在最后一步(第6步之后)，来自R1的更新会落到主服务器上，并会破坏数据。R1当时没有有效的锁，因为它在步骤4中死亡，同时，主人将N的锁授予了客户R2。</p><figure class="lu lv lw lx fq ly fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mf"><img src="../Images/3101612247ba1d42d17e77277f06c921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GBh7ke0mybIeeko80Qoug.jpeg"/></div></div><figcaption class="mb mc fg fe ff md me bd b be z ek">Update from step 3 B=by R1 arrives at master somewhat late. By that time master has already granted the lock on N to another client R2.</figcaption></figure><p id="1164" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">处理这种情况的方法之一是使用锁定延迟。当持有锁的应用程序在不释放锁的情况下死亡时，在一段可配置的时间内，没有其他人获得现已失效的应用程序持有的锁。这就形成了一个简单而有效(但并不完美)的解决方案，客户端可以指定故障应用程序可以持有锁的阈值。</p><p id="af2a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">查比提供的另一个可能的解决方案是基于序列器的检查。当客户端获得锁时，它可以向胖主人请求序列器。这是一个字符串，由锁名、锁生成号(每次从自由转换到保持时都会改变)和获取模式组成。该字符串可以传递给需要受保护事务锁的模块。这些模块可以使用定序器来检查锁的有效性，方法是对照胖主人进行检查，或者使用模块的胖缓存。</p><h2 id="5dc9" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">使用事件检测变化</h2><p id="d928" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">Chubby还允许发布和订阅机制的一些小方面。chubby中的文件还允许存储少量数据，这比仅仅指示锁是否被占用更有效。正如我们之前讨论过的，客户有兴趣知道何时选择了新的主锁，或者他们使用的锁的内容何时发生了变化。这是使用在打开文件时注册的事件和回调来实现的。使用以下事件:</p><ol class=""><li id="fadb" class="lf lg ht jk b jl jm jo jp jr lh jv li jz lj kd lk ll lm ln dt translated">文件内容已更改:用于描述给定服务的新位置</li><li id="5fa0" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">添加到目录的子节点:用于描述新副本的添加</li><li id="7356" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">胖主人故障转移:用于客户端进入恢复模式</li><li id="eb9f" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">无效句柄:某些通信问题</li></ol><h2 id="51a1" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">使用Chubby选择小学</h2><p id="7304" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">使用到目前为止所描述的机制，客户端现在可以选择一个主。这很容易做到:</p><ol class=""><li id="4025" class="lf lg ht jk b jl jm jo jp jr lh jv li jz lj kd lk ll lm ln dt translated">所有想成为主人的实体，尝试以写模式打开一个文件。</li><li id="40ea" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">其中只有一个获得了写模式访问权限，其他的都失败了。</li><li id="b164" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">具有写访问权限的，然后将其标识写入文件</li><li id="cad3" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">所有其他人都获得了文件修改事件，并且知道了现在的主人。</li><li id="73d4" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd lk ll lm ln dt translated">Primary使用定序器或基于锁定延迟的机制来确保乱序消息不会导致不一致的访问，并且服务可以确认当前主机的定序器是否有效。</li></ol><h2 id="e60e" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">缓存和KeepAlive调用</h2><p id="8ca8" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">客户端保留一个用于读取的缓存，并且始终保持一致。对于写操作，写操作会传播到主节点，直到主节点确认才完成。Master维护所有客户端的状态信息，因此如果其他人写入同一文件，可能会使客户端的缓存无效。在这种情况下，发出写操作的客户端将被阻止，直到所有无效操作都已发送给其他客户端并得到它们的确认。</p><p id="654b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">客户端对主服务器进行KeepAlive调用。在任何时候，对于一个表现良好的客户端，总会有一个未完成的KeepAlive调用。基本上，客户端通过发出下一个KeepAlive调用来确认主人的响应。服务器可以在以后发送一些信息作为对该调用的响应，例如，无效可以作为对先前KeepAlive调用的响应发送给客户端。客户端将看到响应，然后使自己的缓存无效，然后在主机上打开另一个KeepAlive调用，以便将来与主机通信。这种机制的另一个优点是不需要在防火墙上打孔。通常允许来自客户端的出站呼叫，并且客户端不需要打开端口并监听主机启动与客户端的连接。</p><h2 id="495d" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">会议</h2><p id="cf87" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">我们在最后一节讨论了KeepAlive RPCs。这些建立了一个客户-主人查比会议。当客户端对主服务器进行KeepAlive调用时，主服务器会阻止该调用。然后，Master还会将租约分配给客户。这个主租约保证主不会单方面终止这个会话。当租约即将到期时，或者如果客户端订阅了某个事件，master可以使用此阻止的调用将信息发送回。在前一种情况下，主机可以延长租约，或者在后一种情况下，主机可以发送信息，例如哪些文件已经更改。</p><p id="087d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">客户端无法确定主服务器是否还活着，以及客户端拥有的租约是否仍然有效。因此，客户端保持稍微小一点的本地租用超时。如果发生这种超时，而主服务器没有响应，那么客户端不确定主服务器是否还在，它的本地租约是否有效。此时，客户认为其会话处于危险中，并开始宽限期。它还会禁用其缓存。如果客户端在宽限期(45s)内收到主机的回复，则客户端可以再次启用缓存。如果客户端没有收到主机的回复，那么就认为主机不可访问，客户端会将错误返回给应用程序。应用程序从胖乎乎的客户端库中获得关于<em class="mk">危险</em>和<em class="mk">过期</em>事件的信息。</p><h2 id="7801" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">主故障转移</h2><p id="2413" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">可能发生的最具破坏性的事件之一是主服务器在相当长的时间内失败，而一段时间后会选出新的主服务器。让我们看看这个序列是怎样的。本地租约超时、危险宽限期在这段时间内在客户端触发。使用该主服务器的所有客户机都需要切换到新的主服务器，而新的主服务器需要使用主服务器用来管理持久状态的复制数据库来重新创建客户机的状态信息。</p><figure class="lu lv lw lx fq ly fe ff paragraph-image"><div class="fe ff ml"><img src="../Images/4037b493a3ba01af8be1589bf8db4a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*rZZ8nsb6tw3gQ1khvxsgVg.png"/></div><figcaption class="mb mc fg fe ff md me bd b be z ek">Master fails. Local lease timeout triggers on the client. Grace period also ends. Clients finally manages to establish a valid KeepAlive session with the master.</figcaption></figure><p id="a6e2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们从左到右遍历所有垂直倾斜的KeepAlive调用。</p><ul class=""><li id="33d4" class="lf lg ht jk b jl jm jo jp jr lh jv li jz lj kd mm ll lm ln dt translated">KA1:客户打电话。尚未分配任何租约。主人转让租约M1。客户目前拥有C1租约。</li><li id="750f" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated">KA2:在对KA1的响应中，为客户分配了一个较小的本地租赁C2。Master还将其租约扩展至M2。</li><li id="634e" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated">KA3:客户机确认KA2并发出需要在主服务器上完成的RPC调用。主人接到电话后死亡。因此不能转让新的租约。客户端的C2租约到期，客户端库通知应用程序它已进入危险状态。宽限期从客户端开始。</li><li id="824a" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated">KA4:与此同时，一个新的主人会被选出，客户会得到通知。新的主设备收到这个KA4消息，并作出回应。Master还根据以前master的租约承诺保守地分配租约M3——请记住，客户端缓存依赖于此。</li><li id="a2d5" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated">KA5: Master不知道这只是一个延迟的数据包，还是客户端试图建立一个新的会话。因为这个主设备使用一个纪元编号，如果它注意到一个旧的纪元编号(客户端发送给主设备),那么该调用实际上不会延长任何一方的租期，并且响应是一个拒绝。</li><li id="174e" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated">KA6:这一个使用由主发送的新纪元编号。所以成功了，但是租约还没有被主服务器延长。</li><li id="7f22" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated">KA7:这个允许客户将其本地租约扩展到C3。现在客户脱离危险，可以退出宽限期。</li><li id="7a8a" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated">KA8:这又一次保持了与主服务器的会话，我们回到了正常操作。由于所有这些都发生在宽限期结束之前，应用程序没有看到任何错误。如果KA6发生在宽限期结束后，应用程序将会看到错误。</li></ul><p id="1515" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当选的新主人会经历一个相当详细的重建过程。这似乎是一个非常棘手的代码。在高层次上:</p><ul class=""><li id="f4d9" class="lf lg ht jk b jl jm jo jp jr lh jv li jz lj kd mm ll lm ln dt translated">主创建上述纪元编号</li><li id="f0f8" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated">重建关于客户端租约等的内存状态。通过读取由最后一个主机维护的数据库</li><li id="bc00" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated">现在，它不再只拒绝保持活动会话请求。其他的都还在被拒绝。</li><li id="bf74" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated">向客户端发送故障转移事件信息。然后，客户端可以使其缓存无效，因为某些事件可能已被错过。</li><li id="52e2" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated">在所有客户端确认或超时之后，系统似乎处于稳定状态，所有其他RPC都被主服务器允许</li></ul><h2 id="434b" class="kf kg ht bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz dt translated">结论</h2><p id="1413" class="pw-post-body-paragraph ji jj ht jk b jl la iu jn jo lb ix jq jr lc jt ju jv ld jx jy jz le kb kc kd hm dt translated">我发现带有锁定语义的集中式协调服务的想法非常有用。锁定语义似乎简化了分布式环境中应用程序的开发，而不是参与基于共识的机制，因为大多数开发人员对此非常熟悉。此外，服务器和客户端协议通过客户端库和相关回调进行操作的方式，提供了一种从应用程序中抽象复杂协议的良好机制，并允许更容易的集成。</p><blockquote class="mn"><p id="2292" class="mo mp ht bd mq mr ms mt mu mv mw kd ek translated">加入Coinmonks <a class="ae ke" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ke" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae ke" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="kf kg ht bd kh ki mx kk kl km my ko kp jr mz kr ks jv na ku kv jz nb kx ky kz dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="lf lg ht jk b jl la jo lb jr nc jv nd jz ne kd mm ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae ke" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="f33b" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae ke" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">开发人员的最佳加密API</a></li><li id="f1dd" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated"><a class="ae ke" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="b359" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated">最佳<a class="ae ke" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated">杠杆代币的终极指南</li><li id="95d1" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/best-vpns-for-crypto-trading" rel="noopener ugc nofollow" target="_blank">加密交易的最佳VPN</a></li><li id="918f" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/huobi-crypto-trading-signals" rel="noopener ugc nofollow" target="_blank">用于Huobi的加密交易信号</a> | <a class="ae ke" rel="noopener" href="/coinmonks/hitbtc-review-c5143c5d53c2"> HitBTC审查</a></li><li id="58f1" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/traderwagon-review" rel="noopener ugc nofollow" target="_blank"> TraderWagon回顾</a> | <a class="ae ke" href="https://coincodecap.com/kraken-vs-gemini-vs-bityard" rel="noopener ugc nofollow" target="_blank">北海巨妖vs双子星vs BitYard </a></li><li id="ad10" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/ftx-futures-trading" rel="noopener ugc nofollow" target="_blank">如何在FTX交易所交易期货</a></li><li id="71f4" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/okex-kucoin" rel="noopener ugc nofollow" target="_blank"> OKEx vs KuCoin </a> | <a class="ae ke" href="https://coincodecap.com/celsius-alternatives" rel="noopener ugc nofollow" target="_blank">摄氏替代度</a> | <a class="ae ke" href="https://coincodecap.com/buy-vechain" rel="noopener ugc nofollow" target="_blank">如何购买VeChain </a></li><li id="e6a8" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/3commas-vs-pionex-vs-cryptohopper" rel="noopener ugc nofollow" target="_blank">3 commas vs . Pionex vs . crypto hopper</a></li><li id="0539" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/cornix-trading-bot" rel="noopener ugc nofollow" target="_blank">如何使用Cornix交易机器人</a></li><li id="7ed0" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/bitget-review" rel="noopener ugc nofollow" target="_blank"> Bitget回顾</a>|<a class="ae ke" href="https://coincodecap.com/gemini-vs-blockfi" rel="noopener ugc nofollow" target="_blank">Gemini vs block fi</a>cmd |<a class="ae ke" href="https://coincodecap.com/okex-futures-trading" rel="noopener ugc nofollow" target="_blank">OKEx期货交易</a></li><li id="60b3" class="lf lg ht jk b jl lo jo lp jr lq jv lr jz ls kd mm ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/buy-crypto-with-credit-card" rel="noopener ugc nofollow" target="_blank">用信用卡购买密码的10个最佳地点</a></li></ul></div></div>    
</body>
</html>