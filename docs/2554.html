<html>
<head>
<title>TzKT #2 — overview of architecture and core components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TzKT #2 —架构和核心组件概述</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/tzkt-2-overview-of-architecture-and-core-components-d18903a19d1c?source=collection_archive---------1-----------------------#2019-12-03">https://medium.com/coinmonks/tzkt-2-overview-of-architecture-and-core-components-d18903a19d1c?source=collection_archive---------1-----------------------#2019-12-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/5f5b579e613ac698f323ef3b419dc11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dIsxmn-f5J9-aorH5Xfh6g.png"/></div></div></figure><p id="aaf3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎来到致力于<a class="ae jz" href="https://tzkt.io/" rel="noopener ugc nofollow" target="_blank"> TzKT </a>开发过程的<a class="ae jz" href="https://baking-bad.org/docs" rel="noopener ugc nofollow" target="_blank"> Baking Bad </a>播客，这是一个轻量级、API优先、面向帐户的块浏览器，基于它自己的索引器，由Tezos基金会支持。</p><p id="af26" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<a class="ae jz" rel="noopener" href="/@_MisterWalker_/tzkt-1-reflections-on-an-ideal-block-explorer-4f18d3427657">的上一篇文章</a>中，我们讨论了关于理想块浏览器的几个假设，现在是时候展示一些实践了。在本文中，我们将讨论TzKT explorer的体系结构，它的优点和缺点，以及我们为什么选择这样或那样的方法。我们开始吧。</p><h1 id="0a7c" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">概貌</h1><p id="bdc9" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">TzKT由三个主要部分组成:区块链索引器、API服务和前端部分。将它们结合在一起，我们得到了下面的图片。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ld"><img src="../Images/ac81c13e285a087e86409a6d5f798eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*63JDJcaAhq-NPsBY"/></div></div></figure><p id="9191" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">值得注意的是，每个组件都是作为一个单独和独立的服务。这实际上非常好，因为它使消费者能够只使用所需的组件，甚至用自己的组件替换一些组件。</p><p id="ec33" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这样的微服务架构不仅灵活，而且具有很好的横向可扩展性。虽然一个工作的索引器足以收集数据，但一个API服务器甚至一个数据库实例可能不足以(取决于系统负载)提供高质量的服务。</p><p id="1c4c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此结果可能如下所示。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff li"><img src="../Images/b7f53eca459b77d6b34acf4d4ca0a142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q6StE5vASYNgRpXd"/></div></div></figure><p id="0c58" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们详细看看索引器和API组件。</p><h1 id="bfd6" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">TzKT索引器</h1><p id="034e" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">在幕后，索引器是一个简单的循环，它处理来自区块链的每个块。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div class="fe ff lj"><img src="../Images/bdbbf9b81df4aa2bd1578f71834fb1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/0*MSYmYgzhSXtZ7v7n"/></div></figure><p id="f9a4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">但是，正如我们所知，Tezos经历了几个协议(将来会有更多的协议)，这意味着不同的块必须根据特定的协议进行不同的验证和处理。</p><h2 id="6b66" class="lk kb ht bd kc ll lm ln kg lo lp lq kk jm lr ls ko jq lt lu ks ju lv lw kw lx dt translated">协议处理程序</h2><p id="8990" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">最初，我们计划创建一个灵活且可扩展的协议处理程序，但是当我们意识到Tezos协议之间有太多的突破性变化(甚至RPC响应有不同的模式)时，我们决定为每个Tezos协议创建单独的协议处理程序。所以我们并不真正关心Tezos提案中的变化，但是我们必须编写更多的重复代码。我们相信这是值得的。</p><p id="f649" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，循环的第一步是确定协议处理程序。之后，选择的协议处理程序反序列化并验证该块。</p><h2 id="35d0" class="lk kb ht bd kc ll lm ln kg lo lp lq kk jm lr ls ko jq lt lu ks ju lv lw kw lx dt translated">阻止验证</h2><p id="43a2" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">当块被反序列化时，我们希望确保它包含正确的/预期的值。例如，如果巴比伦块的优先级为0，并且包括32个背书，则面包师将获得16 tez奖励，而不是15.9或16.1，等等。另一方面，块验证对于测试我们对当前协议的了解是必要的，所以如果有一个意外的值，那么我们可能在协议处理程序实现过程中遗漏了一些东西。</p><h2 id="6cfb" class="lk kb ht bd kc ll lm ln kg lo lp lq kk jm lr ls ko jq lt lu ks ju lv lw kw lx dt translated">提交更改</h2><p id="0ab2" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">当块被验证时，我们将它“分割”成一堆原子提交，在取消最后一个块的情况下，这些提交可以被应用或恢复。</p><p id="46bd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">实际上，每次提交都代表索引器的一个特定特性。例如，如果我们想要存储事务，我们创建一个事务提交，它从块中提取所有事务，处理它们并保存到数据库。或者，如果我们想要收集统计数据，我们创建一个适当的提交，从块进程中获取所需的数据并保存它。</p><p id="71a1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">老实说，用这种方法给索引器添加特性非常方便。</p><h2 id="af4c" class="lk kb ht bd kc ll lm ln kg lo lp lq kk jm lr ls ko jq lt lu ks ju lv lw kw lx dt translated">诊断学</h2><p id="6dd4" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">还有一个在应用或恢复提交之前进行自我诊断的选项。需要这个选项来确保协议处理程序正确完成所有工作。但是作为副作用，它会进行额外的RPC调用(顺便说一下，这非常慢)，所以在与区块链同步期间应该禁用它。否则，需要很长时间。</p><p id="1f17" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">完成这些步骤后，更改被保存到数据库，索引器开始等待下一个块。</p><h2 id="36fa" class="lk kb ht bd kc ll lm ln kg lo lp lq kk jm lr ls ko jq lt lu ks ju lv lw kw lx dt translated">一点糖果</h2><p id="e35f" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">在Tezos mainnet的第173个周期结束时，TzKT索引器消耗大约70MB RAM(完全同步期间的峰值为100MB)和大约5GB磁盘空间(1GB数据+ 4GB索引)。背书操作占了其中的80%😆。</p><p id="a1db" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">此外，不需要从genesis同步索引器，因为我们将提供最近的快照(目前约800MB)，使消费者能够尽快启动它。</p><h1 id="16ac" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">TzKT API</h1><p id="0eb9" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">除了TzKT索引器之外，我们还开发了一个本地API来提供访问数据的便捷方式。这比直接查询数据库更简单、更快(由于智能缓存)。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ly"><img src="../Images/57fea885dcdd6f20202ab5d98f501a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G2Bbj1YrSH_KJrzK"/></div></div></figure><p id="5b14" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如您所见，TzKT API不仅使用索引器数据库，还使用额外的数据源/提供者，这使我们能够用有用的元数据丰富答案，例如地址别名、提案描述等。这也意味着，只需添加定制的数据提供者，就可以根据任何人的需求轻松定制API。</p><h2 id="caae" class="lk kb ht bd kc ll lm ln kg lo lp lq kk jm lr ls ko jq lt lu ks ju lv lw kw lx dt translated">证明文件</h2><p id="bac5" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">保持API文档最新真的是一个痛苦的过程，所以我们决定让TzKT代码自文档化(通过使用Swagger，Open API 3)，这意味着文档是自动生成的，我们不必关心它。</p><h2 id="30f4" class="lk kb ht bd kc ll lm ln kg lo lp lq kk jm lr ls ko jq lt lu ks ju lv lw kw lx dt translated">资源消耗</h2><p id="f35e" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">禁用缓存时，API服务器消耗大约150MB RAM(不包括高负载)，缓存所有账户时消耗大约400MB RAM(不包括操作等相关实体)。所以在云中使用TzKT API非常便宜。</p><blockquote class="lz ma mb"><p id="53ad" class="jb jc mc jd b je jf jg jh ji jj jk jl md jn jo jp me jr js jt mf jv jw jx jy hm dt translated">TzKT API在公共网络上部署和公开是安全的，但是仍然建议使用反向代理，比如Nginx或Apache。</p></blockquote><h1 id="6f86" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">结论</h1><p id="2e4b" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">我们刚刚描述了基本的TzKT概念，它的架构和核心组件，索引器和API。正如你所看到的，它真的是轻量级的，非常灵活和可扩展。老实说，这只是开始，因为只有最初的功能已经实现，但它的工作！有许多工作要做，许多功能要添加，我们将尽最大努力在短时间内实现计划中的一切。</p><p id="ff34" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在MIT许可下发布的该项目的源代码可以在这里找到。通过提出拉动请求或制造问题的任何参与都受到高度赞赏！此外，我们总是很高兴在我们的<a class="ae jz" href="https://t.me/baking_bad_chat" rel="noopener ugc nofollow" target="_blank">电报聊天</a>中看到每个人，并乐意讨论与我们的项目相关的一切。</p><h1 id="b47c" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">以下步骤</h1><p id="f86b" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">我们计划在不久的将来采取以下措施:</p><ul class=""><li id="457f" class="mg mh ht jd b je jf ji jj jm mi jq mj ju mk jy ml mm mn mo dt translated">发布关于如何构建和部署TzKT索引器和API服务器的指南；</li><li id="1f6b" class="mg mh ht jd b je mp ji mq jm mr jq ms ju mt jy ml mm mn mo dt translated">发布第一版的浏览器网络界面，有几个可爱的特性。</li></ul><p id="5f4e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">之后，我们将继续致力于扩展索引器功能和API端点，以及改进浏览器UI。</p><p id="190a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<a class="ae jz" href="https://twitter.com/tezosbakingbad" rel="noopener ugc nofollow" target="_blank">推特</a>和<a class="ae jz" href="https://github.com/baking-bad" rel="noopener ugc nofollow" target="_blank"> Github </a>上关注我们，保持更新。<br/>干杯！</p><p id="f7d9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="mc">最初发表于2019年12月03日</em><a class="ae jz" href="https://baking-bad.org/blog/2019/12/03/tezos-explorer-tzkt-2-overview-of-architecture-and-core-components/" rel="noopener ugc nofollow" target="_blank"><em class="mc">https://baking-bad.org</em></a><em class="mc">，在那里你可以找到文章的完整版本。</em></p><figure class="le lf lg lh fq iu fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff mu"><img src="../Images/0ac758d7122ac1c2860cc155daf2c5d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*sfsGJhpBk0-yxJur_WuGoQ.png"/></div></a></figure><blockquote class="mv"><p id="429e" class="mw mx ht bd my mz na nb nc nd ne jy ek translated"><a class="ae jz" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ng nh ni nj nk iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nf"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>