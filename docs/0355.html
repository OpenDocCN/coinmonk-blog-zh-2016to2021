<html>
<head>
<title>Ethernaut Coin Flip problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太币翻转问题</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethernaut-coin-flip-problem-4f326df872cb?source=collection_archive---------1-----------------------#2018-04-22">https://medium.com/coinmonks/ethernaut-coin-flip-problem-4f326df872cb?source=collection_archive---------1-----------------------#2018-04-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/d816fc9dda8067fda7d442b7fc44db9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5QIx35bAIqMI5LCV3RvI7w.png"/></div></div></figure><p id="b8ce" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">不确定什么时候发生的，但是在CTF的游戏中有一些新的挑战；“T <a class="ae jz" href="https://ethernaut.zeppelin.solutions/" rel="noopener ugc nofollow" target="_blank"> he Ethernaut </a>”。这是一个开始智能合约开发的好地方，因为所有的挑战都是完全独立的，并且是基于已经让很多人失去了一些ETH的实际漏洞。</p><p id="c7f6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我将分解挑战，标题为:“<a class="ae jz" href="https://ethernaut.zeppelin.solutions/level/0xd340de695bbc39e72df800dfde78a20d2ed94035" rel="noopener ugc nofollow" target="_blank"><strong class="jd hu"/></a><strong class="jd hu">”。</strong></p><h1 id="6f20" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">让我们创造自己的运气🍀</h1><figure class="kz la lb lc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ky"><img src="../Images/27ca95c7abb142ade22930d623a271fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ebs1DqN57kHr-L6DIyqCvA.png"/></div></div><figcaption class="ld le fg fe ff lf lg bd b be z ek">The CoinFlip contract</figcaption></figure><blockquote class="lh li lj"><p id="851a" class="jb jc lk jd b je jf jg jh ji jj jk jl ll jn jo jp lm jr js jt ln jv jw jx jy hm dt translated">“这是一个抛硬币游戏，你需要通过猜测抛硬币的结果来建立你的连胜纪录。要完成这一关，你需要用你的通灵能力连续猜对10次。”</p></blockquote><p id="bb3f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">其实没必要黑这个合同！我们可以只翻转10次，希望连续猜对10次的概率是0.5 ⁰。这可能需要一段时间，但没有什么比艰苦的重复性工作更能磨炼灵魂了。</p><p id="bc7c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">或者我们可以在提交猜测之前检查结果。</p><p id="ba92" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">但在此之前，让我们先把合同通读一遍，然后再考虑解决方案。</p><pre class="kz la lb lc fq lo lp lq lr aw ls dt"><span id="d09c" class="lt kb ht lp b fv lu lv l lw lx">function CoinFlip() public {<br/>   consecutiveWins = 0;   <br/>}</span></pre><p id="8896" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">此契约的构造函数并不做太多工作，它只是将连续Wins计数器设置为0。它实际上不需要这样做，因为每个已定义但未赋值的变量都默认为其空状态(对于uint为0)，但无论如何这样做有利于清晰。</p><p id="9ed1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">契约存储中的其他值得注意的事情是lastHash，我们现在还不知道它的用途，但值得注意的是它不是公共存储的一部分。还有一个因素就是屁股大！经过一番查找，它看起来确实很“神奇”,原来这个数字等于2 ⁵⁵(好奇🤔)</p><h1 id="be1a" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">翻转🐬</h1><p id="a21a" class="pw-post-body-paragraph jb jc ht jd b je ly jg jh ji lz jk jl jm ma jo jp jq mb js jt ju mc jw jx jy hm dt translated">看起来大部分的思考都必须在<strong class="jd hu"> flip() </strong>函数的方向上进行。</p><p id="5fd4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看看函数签名:</p><pre class="kz la lb lc fq lo lp lq lr aw ls dt"><span id="c4b7" class="lt kb ht lp b fv lu lv l lw lx">function flip(bool _guess) public returns (bool) {...</span></pre><p id="9573" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">"<em class="lk">函数，我给出一个布尔值，然后返回一个布尔值</em>"</p><p id="abd7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">继续前进。</p><pre class="kz la lb lc fq lo lp lq lr aw ls dt"><span id="bd4c" class="lt kb ht lp b fv lu lv l lw lx">uint256 blockValue = uint256(block.blockhash(block.number-1));</span></pre><p id="8b0b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">block.number和block.blockhash分别是一个全局可用的变量和函数，它们的作用如下:</p><p id="06f3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="lk">块号(uint) </em>:当前块号</p><p id="bc8c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="lk">block . block hash(function(uint)returns(bytes 32))</em>:给定块的散列—仅针对256个最近的块</p><p id="bd43" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">换句话说，每当翻转事务包含在一个块中时，我们查看前一个块的编号，我们使用该编号来查找前一个块的哈希(类型为bytes32 ),并将它转换为类型uint256。</p><p id="2299" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这到底是什么样子？让我们来填补空白，以便获得一个概念:</p><pre class="kz la lb lc fq lo lp lq lr aw ls dt"><span id="87fe" class="lt kb ht lp b fv lu lv l lw lx">// Current block number 30010 <br/>// Network, Ropsten (This matters, naturally)</span><span id="a992" class="lt kb ht lp b fv md lv l lw lx">1. blockValue = uint256(block.blockhash((30010-1));<br/>2. blockValue = uint256(block.blockhash((30009));<br/>3. blockValue = uint256( 0xf5e22612a5c856807346a40b329664fb393e6ea0e585bd34cffc9f59a50353bd<br/>);<br/>4. blockValue = 111216218108639340416231065655650431318691078275559772203362371055421202060221</span></pre><p id="9407" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">大数就是大。值得注意的是，将字节32转换为uint256覆盖了相同的数字空间。任何有效的uint256都可能出现在32字节的转换中。</p><p id="00ef" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来:</p><pre class="kz la lb lc fq lo lp lq lr aw ls dt"><span id="5a1d" class="lt kb ht lp b fv lu lv l lw lx">if (lastHash == blockValue) {revert();}<br/>lastHash = blockValue;</span></pre><p id="594a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">好的。这就是lastHash的用途。如果有一个成功的事务，那么lastHash将被设置为这个blockValue，它完全依赖于包含该事务的块，blockValue等于lastHash值的唯一合理的方法是在同一个块中有对这个函数的多个事务。如果是这样的话，只有第一个会通过，这就为我们关闭了一条通道。如果这里没有这个，我们可以用相同的猜测对每个块进行10次，并为每个事务获得相同的块值。</p><pre class="kz la lb lc fq lo lp lq lr aw ls dt"><span id="0f10" class="lt kb ht lp b fv lu lv l lw lx">coinFlip = uint256(uint256(blockValue) / FACTOR);<br/>bool side = coinFlip == 1 ? true : false;</span></pre><p id="04e3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">3 / 4 = 0，在固体中。我们把任何除法的结果四舍五入，然后去掉余数。直觉应该告诉你<em class="lk"> (blockValue / Factor) </em>应该等于1或者等于0。而且很有道理！为了更便于管理，让我们将blockValue视为uint8，将Factor视为uint7。</p><pre class="kz la lb lc fq lo lp lq lr aw ls dt"><span id="ebc6" class="lt kb ht lp b fv lu lv l lw lx">//Maxed out!<br/>FACTOR = X 1 1 1 1 1 1 1<br/>blockValue = ? ? ? ? ? ? ? </span></pre><p id="3e3f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">重要的是，对于大于因子的块值，它只需要最左边的位等于1，否则它将小于因子(或等于)。</p><p id="1b22" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，这种除法的结果(0或1)取决于blockvalue的最左边的一位，这显然是随机确定的。酷毙了。</p><pre class="kz la lb lc fq lo lp lq lr aw ls dt"><span id="32fa" class="lt kb ht lp b fv lu lv l lw lx">if (side == _guess){ consecutiveWins++; return true; } <br/>else { consecutiveWins = 0; return false; }</span></pre><p id="fd3a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，我们比较我们的伪随机翻转结果与用户提供的猜测，并相应地调整连续的胜利。那么，它呢？无论如何，你会想到这份合同吗？</p><p id="b75b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果您考虑lastHash子句的必要性，另一个漏洞应该变得非常明显。</p><h1 id="92f6" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">解决方法！🏅</h1><blockquote class="me"><p id="65ff" class="mf mg ht bd mh mi mj mk ml mm mn jy ek translated">同一个块中的每个事务都可以评估“coinflip”结果！！</p></blockquote><p id="c90a" class="pw-post-body-paragraph jb jc ht jd b je mo jg jh ji mp jk jl jm mq jo jp jq mr js jt ju ms jw jx jy hm dt translated">因此，通常情况下，破解智能合同的最佳方式是与另一方合作:</p><figure class="kz la lb lc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mt"><img src="../Images/ec356003ef1868a04124643c97e0d206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wa6Kz1xxcc2t3RuzlKP2Ow.png"/></div></div><figcaption class="ld le fg fe ff lf lg bd b be z ek">Str8 outta Remix</figcaption></figure><p id="2f33" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里我们实例化定义CoinFlip契约的接口，并使用我们的目标契约的地址实例化它。然后，只需在我们迂回的dirtyRat契约上调用欺骗函数，就会评估coinflip的结果，并将“猜测”传递给真正的CoinFlip契约。</p><p id="7721" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是在单个事务中完成的，因此我们的CoinFlip计算显然将与CoinFlip契约中的计算相同，因为我们必须在同一个块中进行。</p><p id="ec35" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在剩下的就是十次垃圾邮件作弊功能。😎</p><h1 id="73a5" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">还有一件事…</h1><p id="469c" class="pw-post-body-paragraph jb jc ht jd b je ly jg jh ji lz jk jl jm ma jo jp jq mb js jt ju mc jw jx jy hm dt translated">这里还有另一个同样明显的弱点。矿工。在一个区块最终确定之前，矿商们通过不同的交易建立区块，并相互竞争将区块提交给区块链。这意味着他们可以在搭积木时运用自己的判断力。一个矿工，给时间可以尝试许多不同的猜测，而不是提交块，他是错误的。</p><p id="5208" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这种基于共识的工作证明的属性是在区块链上实现真正随机结果的最大障碍之一。在建立一个分散的乐透之前，考虑一下这个问题🤑</p></div></div>    
</body>
</html>