<html>
<head>
<title>Debugging Smart Contracts with Truffle Debugger: A Practical Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Truffle调试器调试智能合约:一种实用的方法</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/debugging-smart-contracts-with-truffle-debugger-a-practical-approach-3410e9d20837?source=collection_archive---------0-----------------------#2018-11-02">https://medium.com/coinmonks/debugging-smart-contracts-with-truffle-debugger-a-practical-approach-3410e9d20837?source=collection_archive---------0-----------------------#2018-11-02</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/b96ab0cb5501a2934a7b1d242b691ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*PjHq4AuTbMjXz7Gq.jpg"/></div></figure><blockquote class="ix"><p id="1be8" class="iy iz ht bd ja jb jc jd je jf jg jh ek translated"><em class="ji">给足了眼球，所有的bug都是浅的。~ </em> <a class="ae jj" href="https://en.wikiquote.org/wiki/Linus_Torvalds" rel="noopener ugc nofollow" target="_blank"> <em class="ji">莱纳斯定律</em> </a></p></blockquote><p id="e0c8" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jh hm dt translated">虫子！bug是外星人，他们在晚上没人注意的时候潜入程序员的代码，改变代码的状态。这些外星人只有一个使命——挫败一个程序员的生活。程序员如何在沮丧而死之前杀死一个bug？是的，你猜对了！通过调试和删除有问题的代码。但是为什么一个程序员会在没有合适工具的情况下投入调试战争呢？如果程序员要调试，他最好用正确的方法，使用正确的工具。</p><blockquote class="ix"><p id="124d" class="iy iz ht bd ja jb kh ki kj kk kl jh ek translated"><em class="ji">如果说调试是去除软件bug的过程，那么编程一定是把bug放进去的过程。~ </em> <a class="ae jj" href="https://en.wikiquote.org/wiki/Edsger_W._Dijkstra" rel="noopener ugc nofollow" target="_blank"> <em class="ji">埃德格·迪杰斯特拉</em> </a></p></blockquote><p id="7e77" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg jh hm dt translated">在智能合约开发中，像传统的集中式软件开发一样，在智能合约的开发生命周期中，bug会潜入智能合约开发人员的代码中。虽然智能合约可能存在漏洞有“太多”的原因，但有一点仍然很重要，在智能合约部署到mainnet之前，必须消除所有的漏洞，否则，我们将面临资金损失的风险，并最终失去智能合约的可信度。</p><p id="7871" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">在solidity中有几个开发智能合同的框架。在本文中，重点是Truffle框架。<a class="ae jj" href="https://truffleframework.com/truffle" rel="noopener ugc nofollow" target="_blank"> Truffle旨在通过为智能合约开发提供开发环境、测试框架和调试工具，使开发人员的生活更加轻松</a>。智能合约错误可能很难发现，错误消息可能很难理解。当使用Truffle构建智能契约时，Truffle调试器在调试契约时非常方便。<strong class="jm hu"> <em class="kr">这是因为在调试智能合约时，你不是在实时运行代码；相反，您将步入该事务在区块链上的历史执行，并将该执行映射到其关联的代码上。传统上来说，这种调试过程可能是乏味的，而这正是Truffle调试器真正有用的地方——只要我们有代码和事务的工件，我们就可以调试任何事务。让我们简单谈谈Truffle调试器，然后举一个例子来说明如何使用这个工具。</em></strong></p><blockquote class="ix"><p id="679b" class="iy iz ht bd ja jb kh ki kj kk kl jh ek translated"><em class="ji">调试是一个涉及执行测试和代码修正的循环活动。</em></p></blockquote><h1 id="eac3" class="ks kt ht bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">Truffle调试器</h1><p id="cea1" class="pw-post-body-paragraph jk jl ht jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg jh hm dt translated">Truffle Debugger是一个集成到Truffle框架中的命令行工具，它允许使用智能合约代码和交易工件来调试智能合约交易。当调试器启动时，命令行界面提供在事务过程中处理或创建的地址列表、事务的初始入口点以及使用调试器的可用命令列表。下面突出显示了一些调试器命令:</p><figure class="lw lx ly lz fq iu fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/5c7dba7663a5cc3e3b97ff00b258ad29.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/0*Y4702SJw0La4wY7v.png"/></div></figure><p id="7d54" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated"><code class="eh ma mb mc md b">[o] step over</code>:</p><p id="e634" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">该命令评估由虚拟机相对于协定评估的指令，直到当前智能协定文件中的下一行，跳过在当前执行点引用的函数(如果有)。</p><p id="66b0" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated"><code class="eh ma mb mc md b">[i] step into</code>:</p><p id="ca43" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">该命令进入在当前执行点调用的函数。</p><p id="c5f8" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated"><code class="eh ma mb mc md b">[u] step out</code>:</p><p id="633f" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">该命令将使调试器跳出当前函数，直接执行下一行。</p><p id="baf1" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated"><code class="eh ma mb mc md b">[n] step next</code>:</p><p id="0ece" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">此命令会单步执行当前调用的函数中的下一个逻辑语句或表达式。</p><p id="4b73" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated"><code class="eh ma mb mc md b">[;] step instruction</code>:</p><p id="a4ff" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">该命令单步执行由虚拟机评估的每个单独的指令。</p><p id="49a7" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">你可以在这里查看其他命令<a class="ae jj" href="https://truffleframework.com/docs/truffle/getting-started/debugging-your-contracts#debugging-interface" rel="noopener ugc nofollow" target="_blank"/></p><p id="f40f" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">到目前为止，我们已经讨论了调试和Truffle调试器，让我们用一个例子来真正理解它。</p><h1 id="7c27" class="ks kt ht bd ku kv kw kx ky kz la lb lc ld me lf lg lh mf lj lk ll mg ln lo lp dt translated">调试FoodCart智能合约</h1><p id="c2fa" class="pw-post-body-paragraph jk jl ht jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg jh hm dt translated">下面的智能合同模拟了一个简单的食品推车，它允许任何人将食品添加到推车上进行销售，也允许任何有足够乙醚的人从推车上购买食品。此契约仅用于说明目的，不应在生产环境中使用。在我们开始本示例之前，需要遵循以下要求才能顺利完成本示例:</p><ol class=""><li id="8bc5" class="mh mi ht jm b jn km jr kn jv mj jz mk kd ml jh mm mn mo mp dt translated">松露4.0或以上</li><li id="10bf" class="mh mi ht jm b jn mq jr mr jv ms jz mt kd mu jh mm mn mo mp dt translated">Solidity编译器版本0.4.24或以上</li><li id="cdfe" class="mh mi ht jm b jn mq jr mr jv ms jz mt kd mu jh mm mn mo mp dt translated">私有区块链(Ganache CLI v6.1.6或更高版本)</li></ol><p id="58b0" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">本文的存储库可以在<a class="ae jj" href="https://github.com/mayorcoded/FoodCartTutorial" rel="noopener ugc nofollow" target="_blank">这里</a>找到，以防您想在不编写智能契约的情况下完成调试过程。</p><h2 id="baf8" class="mv kt ht bd ku mw mx my ky mz na nb lc jv nc nd lg jz ne nf lk kd ng nh lo ni dt translated"><code class="eh ma mb mc md b">Step 1: Building the smart contract</code></h2><ul class=""><li id="ecea" class="mh mi ht jm b jn lq jr lr jv nj jz nk kd nl jh nm mn mo mp dt translated">让我们首先为这个项目创建一个目录，并构建智能契约。在终端输入以下命令:</li></ul><pre class="lw lx ly lz fq nn md no np aw nq dt"><span id="7c9e" class="mv kt ht md b fv nr ns l nt nu">mkdir FoodCart</span></pre><ul class=""><li id="46cd" class="mh mi ht jm b jn km jr kn jv mj jz mk kd ml jh nm mn mo mp dt translated">进入文件夹，创建一个裸露的块菌项目。</li></ul><pre class="lw lx ly lz fq nn md no np aw nq dt"><span id="f126" class="mv kt ht md b fv nr ns l nt nu">cd FoodCart<br/>truffle init</span></pre><ul class=""><li id="41ad" class="mh mi ht jm b jn km jr kn jv mj jz mk kd ml jh nm mn mo mp dt translated">导航到合同文件夹并创建一个<code class="eh ma mb mc md b">FoodCart.sol</code>智能合同文件</li></ul><pre class="lw lx ly lz fq nn md no np aw nq dt"><span id="6671" class="mv kt ht md b fv nr ns l nt nu">cd contracts<br/>touch FoodCart.sol</span></pre><ul class=""><li id="a22d" class="mh mi ht jm b jn km jr kn jv mj jz mk kd ml jh nm mn mo mp dt translated">在您选择的任何IDE中打开您的FoodCart项目。我将使用Visual Studio代码。为什么？我真的不知道…lol。😂。打开<code class="eh ma mb mc md b">FoodCart.sol</code>合同，在下面输入智能合同:</li></ul><figure class="lw lx ly lz fq iu"><div class="bz el l di"><div class="nv nw l"/></div></figure><p id="53c2" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">在我们继续之前，让我解释一下上面的智能合同。FoodCart智能合同可以分为6个部分:</p><ul class=""><li id="d28a" class="mh mi ht jm b jn km jr kn jv mj jz mk kd ml jh nm mn mo mp dt translated">状态变量:状态变量<code class="eh ma mb mc md b">owner</code>和<code class="eh ma mb mc md b">skuCount</code>分别存储所有者的地址和添加到购物车中的食品数量。映射<code class="eh ma mb mc md b">foodItems</code>将SKU映射到食品项目。</li><li id="bd18" class="mh mi ht jm b jn mq jr mr jv ms jz mt kd mu jh nm mn mo mp dt translated">枚举:<code class="eh ma mb mc md b">State</code>枚举是一个用户定义的数据类型，保存购物车中食品的状态。枚举中列出的类型可以显式地与整数相互转换，即(<code class="eh ma mb mc md b">ForSale = 0</code>、<code class="eh ma mb mc md b">Sold = 1</code>)。</li><li id="4520" class="mh mi ht jm b jn mq jr mr jv ms jz mt kd mu jh nm mn mo mp dt translated">事件:事件<code class="eh ma mb mc md b">ForSale</code>和<code class="eh ma mb mc md b">Sold</code>记录了待售或售出的食品的详细信息。这些事件可以由javascript中的回调函数调用，它们的内容可以用来使dApps的使用更具交互性。</li><li id="c844" class="mh mi ht jm b jn mq jr mr jv ms jz mt kd mu jh nm mn mo mp dt translated">struct:struct<code class="eh ma mb mc md b">FoodItem</code>是一个用户定义的类型，用于保存食品的属性。可以使用结构上的点标记来访问这些属性。</li><li id="d5e1" class="mh mi ht jm b jn mq jr mr jv ms jz mt kd mu jh nm mn mo mp dt translated">函数修饰符:修饰符<code class="eh ma mb mc md b">doesFoodItemExist</code>、<code class="eh ma mb mc md b">isFoodItemForSale</code>和<code class="eh ma mb mc md b">hasBuyerPaidEnough</code>是在执行应用它们的函数之前自动检查条件的函数。这个智能契约中使用的函数修饰符的作用从它们的名字就很明显。</li><li id="a673" class="mh mi ht jm b jn mq jr mr jv ms jz mt kd mu jh nm mn mo mp dt translated">功能:<code class="eh ma mb mc md b">addFoodItem</code>、<code class="eh ma mb mc md b">buyFoodItem</code>和<code class="eh ma mb mc md b">fetchFoodItem</code>功能分别为合同添加食品、允许购买食品和查看食品的详细信息。构造函数用部署契约的地址初始化<code class="eh ma mb mc md b">owner</code>状态变量。匿名<code class="eh ma mb mc md b">payable</code>函数允许以太发送到这个契约。</li></ul><h2 id="690e" class="mv kt ht bd ku mw mx my ky mz na nb lc jv nc nd lg jz ne nf lk kd ng nh lo ni dt translated"><code class="eh ma mb mc md b">Step 2: Deploying the smart contract</code></h2><p id="78e5" class="pw-post-body-paragraph jk jl ht jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg jh hm dt translated">让我们在专用网络上部署智能合同。</p><ul class=""><li id="0144" class="mh mi ht jm b jn km jr kn jv mj jz mk kd ml jh nm mn mo mp dt translated">在您的IDE中，在<code class="eh ma mb mc md b">migrations</code>文件夹中创建一个名为<code class="eh ma mb mc md b">2_foodcart_migration.js</code>的新文件。创建文件后打开它，并添加以下代码:</li></ul><figure class="lw lx ly lz fq iu"><div class="bz el l di"><div class="nv nw l"/></div></figure><p id="619c" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">这段代码将使框架能够将我们的<code class="eh ma mb mc md b">FoodCart.sol</code>合同部署到私有的区块链。</p><ul class=""><li id="4c97" class="mh mi ht jm b jn km jr kn jv mj jz mk kd ml jh nm mn mo mp dt translated">打开您的终端，导航到该项目的文件夹，并键入以下命令:</li></ul><pre class="lw lx ly lz fq nn md no np aw nq dt"><span id="13f2" class="mv kt ht md b fv nr ns l nt nu">truffle develop</span></pre><p id="e6a0" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">这个命令启动了一个开发区块链，我们可以用它开始测试我们的契约。运行该命令应该会产生以下结果:</p><figure class="lw lx ly lz fq iu fe ff paragraph-image"><div class="fe ff nx"><img src="../Images/2642f2e70aee0d127257071a9f1e1310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/0*yvHXSFgJTNtoareF.png"/></div></figure><p id="613b" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">上图显示，在端口9545上已经启动了一个开发区块链，测试账户也已经创建使用，终端导航到一个新的提示<code class="eh ma mb mc md b">truffle(develop)&gt;</code>。</p><ul class=""><li id="ee35" class="mh mi ht jm b jn km jr kn jv mj jz mk kd ml jh nm mn mo mp dt translated">在<code class="eh ma mb mc md b">truffle(develop)&gt;</code>提示符下，键入<code class="eh ma mb mc md b">compile</code>命令来编译合同。编译的结果存储在项目目录的build文件夹中。</li></ul><pre class="lw lx ly lz fq nn md no np aw nq dt"><span id="fc70" class="mv kt ht md b fv nr ns l nt nu">truffle(develop)&gt; compile</span></pre><p id="6868" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">运行<code class="eh ma mb mc md b">compile</code>命令应该会产生这样的结果:</p><figure class="lw lx ly lz fq iu fe ff paragraph-image"><div class="fe ff ny"><img src="../Images/75b22673075a5bdeacc5dfa52389349f.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/0*HyFUeMHsq9rTZhQb.png"/></div></figure><ul class=""><li id="337d" class="mh mi ht jm b jn km jr kn jv mj jz mk kd ml jh nm mn mo mp dt translated">最后，让我们将编译好的契约迁移到区块链进行部署。在终端，键入<code class="eh ma mb mc md b">migrate</code>命令，将合同迁移到已经为我们启动的开发区块链。</li></ul><pre class="lw lx ly lz fq nn md no np aw nq dt"><span id="d090" class="mv kt ht md b fv nr ns l nt nu">truffle(develop)&gt; migrate</span></pre><p id="e3ee" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">运行<code class="eh ma mb mc md b">migrate</code>命令应该会产生以下结果:</p><figure class="lw lx ly lz fq iu fe ff paragraph-image"><div class="fe ff nz"><img src="../Images/4bd312f7ea1d7dc6a8357a84048fb04c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/0*Uo1YFzj5zsoZiU6t.png"/></div></figure><h2 id="31c8" class="mv kt ht bd ku mw mx my ky mz na nb lc jv nc nd lg jz ne nf lk kd ng nh lo ni dt translated"><code class="eh ma mb mc md b">Step 3: Interacting with the smart contract</code></h2><p id="aa98" class="pw-post-body-paragraph jk jl ht jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg jh hm dt translated">让我们与我们的智能合同互动，感受一下它是如何工作的。我们将添加食物到购物车，检查添加到购物车的食物的详细信息，并从我们开始开发区块链时为我们创建的一个帐户中购买含有乙醚的购物车中的食物。</p><ul class=""><li id="c30d" class="mh mi ht jm b jn km jr kn jv mj jz mk kd ml jh nm mn mo mp dt translated">仍然在<code class="eh ma mb mc md b">truffle(develop)&gt;</code>提示符下，创建一个<code class="eh ma mb mc md b">foodCart</code>变量，并将已部署契约的实例存储在其中。</li></ul><pre class="lw lx ly lz fq nn md no np aw nq dt"><span id="149e" class="mv kt ht md b fv nr ns l nt nu">truffle(develop)&gt; let foodCart; truffle(develop)&gt; FoodCart.deployed().<strong class="md hu">then</strong>((instance) =&gt; { foodCart = instance; });</span></pre><p id="5fcd" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">在上面的简短代码片段中，我们通过web3 <code class="eh ma mb mc md b">.deployed</code>方法访问已部署的<code class="eh ma mb mc md b">FoodCart</code>契约，该方法返回一个promise接口，我们传递一个函数，该函数将已部署契约的实例存储在<code class="eh ma mb mc md b">foodCart</code>变量中。有了存储在<code class="eh ma mb mc md b">foodCart</code>变量中的契约实例，我们可以通过<code class="eh ma mb mc md b">foodCart</code>变量访问契约的功能。</p><ul class=""><li id="50e9" class="mh mi ht jm b jn km jr kn jv mj jz mk kd ml jh nm mn mo mp dt translated">让我们在<code class="eh ma mb mc md b">truffle(develop)&gt;</code>提示符下运行下面的代码片段，将一些食品添加到购物车中。首先，让我们添加一个函数，它将帮助我们添加食物项目，并在控制台上轻松地打印交易结果。</li></ul><figure class="lw lx ly lz fq iu"><div class="bz el l di"><div class="nv nw l"/></div></figure><p id="fffc" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated"><code class="eh ma mb mc md b">addFoodItemToCart</code>函数允许我们在调用时将食品的名称和价格作为参数传递给函数，从而轻松地将食品添加到购物车中。该函数充当智能契约中<code class="eh ma mb mc md b">addFoodItem</code>的包装器，为我们进行智能契约调用，并格式化从函数调用返回的日志输出。通过运行以下命令，我们可以用<code class="eh ma mb mc md b">addFoodItemToCart</code>功能添加一些食物:</p><figure class="lw lx ly lz fq iu"><div class="bz el l di"><div class="nv nw l"/></div></figure><ul class=""><li id="bc4d" class="mh mi ht jm b jn km jr kn jv mj jz mk kd ml jh nm mn mo mp dt translated">现在我们在食品推车上有大约3种食品，让我们从推车上买一些食品。在我们购买食品之前，我们需要指定我们将使用什么地址来购买，因为我们可以从这个地址获得资金<code class="eh ma mb mc md b">in ether</code>来购买食品。回想一下，当我们开始我们的私人区块链时，为我们创建了10个测试账户，每个账户都有100以太币，我们可以用它来购买我们想要的任何东西，我们发财了🤑🤑。让我们创建一个变量来存储这些地址或帐户中的一个，以便我们可以随时轻松地调用它。</li></ul><pre class="lw lx ly lz fq nn md no np aw nq dt"><span id="6f60" class="mv kt ht md b fv nr ns l nt nu">truffle(develop)&gt; <strong class="md hu">const</strong> buyerAddress = web3.eth.accounts[1]; truffle(develop)&gt; buyerAddress '0xf17f52151ebef6c7334fad080c5704d77216b732'</span></pre><p id="1b71" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">由于我们有一个账户<code class="eh ma mb mc md b">0xf17f52151ebef6c7334fad080c5704d77216b732</code>(你的会不同)，我们可以添加一个功能，在我们的<code class="eh ma mb mc md b">truffle(develop)&gt;</code>提示下购买食品购物车中的食品。</p><figure class="lw lx ly lz fq iu"><div class="bz el l di"><div class="nv nw l"/></div></figure><p id="f874" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">通过使用商品的<code class="eh ma mb mc md b">itemSku</code>和<code class="eh ma mb mc md b">amount</code>调用函数，<code class="eh ma mb mc md b">buyFoodItemFromCart</code>允许我们从购物车中购买食品。为该商品支付的金额来自存储在我们的<code class="eh ma mb mc md b">buyerAddress</code>变量中的账户。我们去食品车上买炒饭吧。从我们以前的交易中，我们记得炒饭的sku是<code class="eh ma mb mc md b">0</code>，它的价格是<code class="eh ma mb mc md b">10 wei</code>。所以在<code class="eh ma mb mc md b">truffle(develop)&gt;</code>提示符下，我们用这些值调用<code class="eh ma mb mc md b">buyFoodItemFromCart</code>函数:</p><figure class="lw lx ly lz fq iu"><div class="bz el l di"><div class="nv nw l"/></div></figure><p id="9859" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">从输出中，我们看到该商品的状态是<code class="eh ma mb mc md b">Sold</code>，而<code class="eh ma mb mc md b">foodItemExist</code>现在是<code class="eh ma mb mc md b">false</code>，表明该商品不再出售。</p><h2 id="3d5a" class="mv kt ht bd ku mw mx my ky mz na nb lc jv nc nd lg jz ne nf lk kd ng nh lo ni dt translated"><code class="eh ma mb mc md b">Step 4: Debugging errors in the smart contract</code></h2><p id="5894" class="pw-post-body-paragraph jk jl ht jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg jh hm dt translated">如果你已经做到了这一步，你应该因为坚韧而获得诺贝尔奖，🎖，享受它带来的名声吧。到目前为止，我们已经看到了契约应该如何表现。为了能够使用Truffle调试器特性，我们将在与契约交互时引入一些错误，然后使用调试器来调试错误并修复它。为了调试一个事务，我们需要有事务的散列，然后在<code class="eh ma mb mc md b">truffle(develop)&gt;</code>提示符下运行命令<code class="eh ma mb mc md b">debug [transaction hash]</code>，后面跟着任何调试器命令，直到我们找到事务失败的地方。</p><p id="e852" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">我们将尝试以下无效交易:</p><ul class=""><li id="64b0" class="mh mi ht jm b jn km jr kn jv mj jz mk kd ml jh nm mn mo mp dt translated">尝试购买不存在的食物</li><li id="2e82" class="mh mi ht jm b jn mq jr mr jv ms jz mt kd mu jh nm mn mo mp dt translated">尝试支付少于食物价格的金额</li></ul><p id="eb8d" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">在我们开始这些事务之前，我们需要在另一个终端中启动<code class="eh ma mb mc md b">truffle develop logger</code>，但是仍然在示例项目中。打开一个新的终端，导航到FoodCart项目并运行这个命令<code class="eh ma mb mc md b">truffle develop --log</code>。</p><pre class="lw lx ly lz fq nn md no np aw nq dt"><span id="ecca" class="mv kt ht md b fv nr ns l nt nu">FoodCart $ truffle develop --log</span></pre><p id="c436" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">您应该得到以下输出:</p><pre class="lw lx ly lz fq nn md no np aw nq dt"><span id="402d" class="mv kt ht md b fv nr ns l nt nu">Connected to existing Truffle Develop session at <a class="ae jj" href="http://127.0.0.1:9545/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:9545/</a></span></pre><p id="2e05" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">记录器连接到指定端口的现有会话，监听事务事件，并记录事务的输出，其中应包括事务哈希、块号等项目。让我们继续下去，让我们的合同生活成为人间地狱👹。</p><h2 id="8459" class="mv kt ht bd ku mw mx my ky mz na nb lc jv nc nd lg jz ne nf lk kd ng nh lo ni dt translated">无效交易#1:试图购买不存在的食品</h2><p id="57fd" class="pw-post-body-paragraph jk jl ht jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg jh hm dt translated">在之前的交易中，我们将食品添加到购物车中，我们分别为3种食品添加了SKU<code class="eh ma mb mc md b">0, 1, 2</code>。我们将尝试使用sku <code class="eh ma mb mc md b">6</code>购买一个不存在的食品。</p><figure class="lw lx ly lz fq iu"><div class="bz el l di"><div class="nv nw l"/></div></figure><p id="5334" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">尝试购买上面命令中显示的商品会产生错误<code class="eh ma mb mc md b">UnhandledPromiseRejectionWarning: Error: VM Exception while processing transaction: revert ...</code>,它并没有真正告诉我们问题来自哪里。现在，当没有调试器时，这可能是一个真正令人头痛的问题。我花了很多时间试图在不使用调试器的情况下调试一个智能合同，它可以榨干一个智能合同的最后一滴血。让我们看看日志输出，看看我们有什么。</p><figure class="lw lx ly lz fq iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/f66a5fc7b8d0cc8becf4671301d29b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*2u1w9REoFddpOfFV.png"/></div></figure><p id="7ca1" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">对我们来说，日志中最重要的内容是事务哈希<code class="eh ma mb mc md b">0x90a2ef83e54426848523a4edcf0c9628045e03c69d95f989c5b3b557367c848c</code>，这将与您机器上的不同。有了事务散列，我们可以调试事务并找出问题所在。让我们调试这个事务。从调试器终端复制事务的散列，并在<code class="eh ma mb mc md b">truffle(develop)&gt;</code>提示符下运行这个命令:<code class="eh ma mb mc md b">debug your-trasanction-hash</code>。您的输出应该如下所示:</p><figure class="lw lx ly lz fq iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/088422680b490fb70f86f7a23bd619eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*Z-N1G3C6OYyqP2uB.png"/></div></figure><p id="7bb8" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">从图中我们可以看到，当debug命令运行时，调试器会编译协定，收集事务数据，获取受影响的地址和在该地址部署的协定，并显示我们可以用来与调试器交互的调试器命令列表。在调试器中使用的最具交互性的命令是<code class="eh ma mb mc md b">step next</code>命令，它一次一个地单步执行一个事务中执行的所有指令。通过按下<code class="eh ma mb mc md b">enter</code>或<code class="eh ma mb mc md b">n</code>来执行<code class="eh ma mb mc md b">step next</code>命令，当然是在键盘上。</p><p id="ad29" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">在<code class="eh ma mb mc md b">debug(develop:0x90a2ef83...)&gt;</code>提示符下，连续按enter键，跟随每个指令步骤，直到到达交易失败的指令。在我们到达停止交易的最后一条指令之前还有<code class="eh ma mb mc md b">8</code>个步骤——您必须按9次enter键才能到达停止指令。让我们看看下图中的前4个步骤:</p><figure class="lw lx ly lz fq iu fe ff paragraph-image"><div class="fe ff oa"><img src="../Images/9203d7f36f568afd4883ba44afcecfd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/0*BQtfMkzZO0FmVFDW.png"/></div></figure><p id="4618" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">从图中，我们看到在第<code class="eh ma mb mc md b">61</code>行调用了<code class="eh ma mb mc md b">buyFoodItem</code>函数，但是在执行该函数之前，第<code class="eh ma mb mc md b">64</code>行的修饰符<code class="eh ma mb mc md b">doesFoodItemExist</code>被调用来检查购物车中是否存在要购买的食品。在进一步的检查中，在第<code class="eh ma mb mc md b">33</code>行，我们看到修改者使用了<code class="eh ma mb mc md b">require</code>函数来确保带有给定sku的食品项目的<code class="eh ma mb mc md b">foodItemExist</code>属性是<code class="eh ma mb mc md b">true</code>。让我们看看下图中的其余步骤发生了什么:</p><figure class="lw lx ly lz fq iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/58b4757d39f62a241c4e3bda0ca12b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*JFYzY8EuOmBINj-7.png"/></div></figure><p id="fdcf" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">在上图第33行的最后一步，我们看到交易停止了，因为交易没有满足从购物车中购买食品的条件。我们想购买的商品不存在。<code class="eh ma mb mc md b">require</code>函数在其应用的条件失败时抛出<strong class="jm hu">状态恢复</strong>异常。<strong class="jm hu">状态恢复</strong>异常恢复或撤销当前调用(及其所有子调用)中对状态所做的所有更改，并向调用者标记错误。我们已经能够使用Truffle调试器成功地调试这段代码，这真是太棒了。</p><h2 id="7b12" class="mv kt ht bd ku mw mx my ky mz na nb lc jv nc nd lg jz ne nf lk kd ng nh lo ni dt translated">无效交易#2:尝试支付低于食品价格的金额</h2><p id="0b5c" class="pw-post-body-paragraph jk jl ht jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg jh hm dt translated">在此交易中，我们将尝试以低于食品价格的金额购买食品。在“步骤3:与智能合约交互”中，我们添加了3种食品。我们试试买sku <code class="eh ma mb mc md b">1</code>价格<code class="eh ma mb mc md b">10 wei</code>的‘鸡椒汤’。在<code class="eh ma mb mc md b">truffle(develop)&gt;</code>的提示下，调用<code class="eh ma mb mc md b">buyFoodItem</code>功能购买一个金额少于价格的食品。</p><pre class="lw lx ly lz fq nn md no np aw nq dt"><span id="a6de" class="mv kt ht md b fv nr ns l nt nu">truffle(develop)&gt; buyFoodItemFromCart(1, 5); <br/>truffle(develop)&gt; (node:40269) UnhandledPromiseRejectionWarning: Error: VM Exception while processing transaction: revert</span></pre><p id="45fd" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">不出所料，这个事务失败了，像往常一样给出一个含糊的错误消息。为了调试这个事务，我们转到我们的日志终端，复制事务的散列。在我的机器上，事务哈希是<code class="eh ma mb mc md b">0x5dc12d3ac524cfd1e3c0ea9265a155149ff16fcb18f904016a87e83cca5f9a30</code>。有了这个事务散列，我们将调试事务并找出事务在哪里停止。</p><pre class="lw lx ly lz fq nn md no np aw nq dt"><span id="ac20" class="mv kt ht md b fv nr ns l nt nu">truffle(develop)&gt; debug 0x2ad4c056a678f221d761d0bc11f641f6b4e63b3016587acd8b16ccf5295bd4d3</span></pre><p id="9dc6" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">就像我们在第一次调试过程中所做的那样，我们将使用<code class="eh ma mb mc md b">step next</code>调试器命令来单步执行事务，因为它非常具有交互性，并且显示所有已经执行的指令，直到我们到达暂停事务的指令。使用<code class="eh ma mb mc md b">enter</code>浏览交易历史，直到到达暂停交易的指令，如下图所示:</p><figure class="lw lx ly lz fq iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/131c183d084d2c979774b39b07b960b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*ucRZyDBRUlCiiU25.png"/></div></figure><p id="8568" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated">在上图中，我们看到在第44行，修饰符<code class="eh ma mb mc md b">hasBuyerPaidEnough</code>在<code class="eh ma mb mc md b">buyFoodItemFromCart</code>函数执行之前被调用，在第45行，修饰符要求买方发送的值大于或等于商品的价格。然而，我们知道我们无视这一条件，因此，它停止了我们的交易。因此，如果我们发送正确的数量，我们肯定会购买我们需要的食品。</p><h1 id="8f97" class="ks kt ht bd ku kv kw kx ky kz la lb lc ld me lf lg lh mf lj lk ll mg ln lo lp dt translated">结论</h1><p id="eb80" class="pw-post-body-paragraph jk jl ht jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg jh hm dt translated">总之，在构建智能契约时使用调试器的重要性怎么强调都不为过。有了调试器，我们可以测试我们的修饰符以确保我们的契约行为正确，我们可以通过向我们的契约发送恶意事务以查看它将如何行为来确保我们的契约是安全的，并且正确地调试事务以查看在事务停止之前已经执行的指令，如果它停止的话。最重要的是，每当我们面临智能合约的问题时，通过使用调试器，而不是摸索我们的代码，我们可以节省我们最有价值的资产，即<strong class="jm hu">时间</strong>。</p><h1 id="4a2b" class="ks kt ht bd ku kv kw kx ky kz la lb lc ld me lf lg lh mf lj lk ll mg ln lo lp dt translated">参考资料:</h1><ul class=""><li id="35b5" class="mh mi ht jm b jn lq jr lr jv nj jz nk kd nl jh nm mn mo mp dt translated"><a class="ae jj" href="https://truffleframework.com/docs/truffle/getting-started/debugging-your-contracts" rel="noopener ugc nofollow" target="_blank">松露调试器</a></li><li id="c260" class="mh mi ht jm b jn mq jr mr jv ms jz mt kd mu jh nm mn mo mp dt translated"><a class="ae jj" href="https://www.d.umn.edu/~gshute/softeng/testing.html" rel="noopener ugc nofollow" target="_blank">调试和测试</a></li><li id="54c7" class="mh mi ht jm b jn mq jr mr jv ms jz mt kd mu jh nm mn mo mp dt translated"><a class="ae jj" href="https://www.jetbrains.com/help/idea/debug-tool-window.html" rel="noopener ugc nofollow" target="_blank"> IntelliJ IDEA调试工具</a></li></ul></div><div class="ab cl ob oc hb od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="hm hn ho hp hq"><p id="3f62" class="pw-post-body-paragraph jk jl ht jm b jn km jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg jh hm dt translated"><em class="kr">最初发表于</em><a class="ae jj" href="https://www.mayowatudonu.com/blockchain/debugging-smartcontracts-with-truffle-debugger" rel="noopener ugc nofollow" target="_blank">T5【www.mayowatudonu.com】</a><em class="kr">。</em></p><blockquote class="ix"><p id="9573" class="iy iz ht bd ja jb kh ki kj kk kl jh ek translated"><a class="ae jj" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="oj ok ol om on iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff oi"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>