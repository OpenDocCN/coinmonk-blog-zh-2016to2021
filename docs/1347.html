<html>
<head>
<title>Serverless application with AWS Lambda and Kotlin. Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS Lambda和Kotlin的无服务器应用程序。第三部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/serverless-application-with-aws-lambda-and-kotlin-part-3-f733511f1326?source=collection_archive---------1-----------------------#2018-08-18">https://medium.com/coinmonks/serverless-application-with-aws-lambda-and-kotlin-part-3-f733511f1326?source=collection_archive---------1-----------------------#2018-08-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/19180411ab35008409d8ebbd3c3661ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yj35hxTNyWzesBWUEdyXhg.png"/></div></div></figure><h1 id="ac75" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">第3部分—提高性能:Kotlin + Node.js+ AWS Lambda</h1><p id="6c96" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hm dt translated">本系列文章由4部分组成:</p><ol class=""><li id="1fc7" class="kx ky ht kb b kc kz kg la kk lb ko lc ks ld kw le lf lg lh dt translated"><a class="ae li" rel="noopener" href="/@sulevsky/serverless-application-with-aws-lambda-and-kotlin-part-1-62d12ce7d64f">无服务器应用和功能即服务简介</a></li><li id="762f" class="kx ky ht kb b kc lj kg lk kk ll ko lm ks ln kw le lf lg lh dt translated"><a class="ae li" rel="noopener" href="/@sulevsky/serverless-application-with-aws-lambda-and-kotlin-part-2-26c06dc62099">第一滴血:在AWS Lambda上用Kotlin为Java平台编写函数</a></li><li id="b72c" class="kx ky ht kb b kc lj kg lk kk ll ko lm ks ln kw le lf lg lh dt translated">预热优化:在AWS Lambda上用Kotlin为Node.js平台编写函数(你在这里)</li><li id="dcb8" class="kx ky ht kb b kc lj kg lk kk ll ko lm ks ln kw le lf lg lh dt translated"><a class="ae li" rel="noopener" href="/@sulevsky/serverless-application-with-aws-lambda-and-kotlin-part-4-b364f9dfd9cd">使用熟悉的工具:使用AWS Lambda上的Spring Cloud函数为Java平台编写Kotlin函数</a></li></ol><p id="5790" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">这部分系列的目的是展示如何使用Kotlin编程语言在基于Node.js平台的AWS Lambda上创建一个函数。</p></div><div class="ab cl lr ls hb lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hm hn ho hp hq"><p id="b73e" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">在前一章中，我们已经使用Kotlin编程语言部署了一个简单的基于Java平台的无服务器应用程序。问题是所谓的<strong class="kb hu">冷启动</strong>——当第一次函数调用花费很长时间时——在我们的例子中是8秒，而不是后面调用的300毫秒。</p><p id="a748" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">tech <a class="ae li" href="https://read.acloud.guru/does-coding-language-memory-or-package-size-affect-cold-starts-of-aws-lambda-a15e26d12c76" rel="noopener ugc nofollow" target="_blank">博客</a>中推荐的解决这个问题的方法之一是使用动态类型语言(Python，JavaScript)而不是静态类型语言。但我们还是想用Kotlin和它很酷的功能。实际上，Kotlin在开发过程中提供的类型检查非常有用。</p><p id="f709" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">有可能将Kotlin代码编译成JavaScript。有了KotlinJS，我们将努力使启动更快。</p><p id="fa1c" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">应用程序的想法与上一篇文章相同——从API网关接收数据，并将其存储到S3桶中。我们仍然希望在Gradle中配置部署。</p><p id="3a40" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">所有源代码都可以从<a class="ae li" href="https://github.com/sulevsky/aws-lambda-java/tree/master/lambda-kotlin-nodejs" rel="noopener ugc nofollow" target="_blank"> Github </a>下载。</p><ol class=""><li id="de27" class="kx ky ht kb b kc kz kg la kk lb ko lc ks ld kw le lf lg lh dt translated"><strong class="kb hu">设置项目</strong></li></ol><p id="3010" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">在Java示例中，我们构建了一个胖jar来包含可部署工件的所有运行时依赖项。在这个例子中，我们将以类似方式创建包含JS库的可部署工件(zip存档)。</p><p id="69cb" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">要设置JS步骤的gradle编译，我们需要包含<code class="eh ly lz ma mb b">kotlin2js</code> gradle插件，它增加了gradle任务<code class="eh ly lz ma mb b">compileKotlin2Js</code>、<code class="eh ly lz ma mb b">compileTestKotlin2Js</code>。配置相当简单。</p><figure class="mc md me mf fq iu"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="8a5b" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">安装依赖项是项目设置的重要部分。首先，我们需要包含<code class="eh ly lz ma mb b">kotlin-stdlib-js</code>依赖，它在JS环境中提供了标准的Kotlin特性。</p><figure class="mc md me mf fq iu"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="cb38" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">其次，我们需要提供JS运行时依赖。在<code class="eh ly lz ma mb b">package.json</code>中，我们指定它们。</p><figure class="mc md me mf fq iu"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="f064" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">在gradle脚本中，我们将创建一个任务来安装依赖项(需要<code class="eh ly lz ma mb b">com.moowork.node</code>插件)。</p><figure class="mc md me mf fq iu"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="c334" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">打包是用gradle的zip任务和aws-gradle插件完成的。</p><figure class="mc md me mf fq iu"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="e965" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">2.<strong class="kb hu">λ码</strong></p><p id="f34c" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">我们的意图是保留业务逻辑与Java平台实现中的代码最相似的代码，以尽可能无缝地从Java过渡到Node.js。它需要封装Kotlin代码和JS的交互。当有许多库时，任务可能会变得困难，但在我们的情况下，只有AWS S3 SDK和少量标准JS函数(<code class="eh ly lz ma mb b">require</code>和<code class="eh ly lz ma mb b">process.env</code>)。在其他方面，切换到KotlinJS对Java/Kotlin开发人员来说并不困难。</p><figure class="mc md me mf fq iu"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="8210" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">对封装在特定模块中的JS函数的调用，业务逻辑不应该与平台特定的函数耦合。</p><p id="fcf1" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated"><strong class="kb hu">重要提示</strong>:我并不是说从Kotlin到KotlinJS的转换将是无缝的，您已经学习了KotlinJS的特定概念，如动态类型、外部修饰符、kotlin-js标准库等。</p><p id="230a" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">要实现函数，我们必须创建接收请求对象、上下文和回调参数的函数，并用注释<code class="eh ly lz ma mb b">@JsName</code>对其进行标记，以便导入。</p><figure class="mc md me mf fq iu"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="a8e4" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">AWS Lambda要求指定函数的入口点。让我们创建简单的JS文件并指定入口点。</p><figure class="mc md me mf fq iu"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="f618" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">就这样，我们已经建立了一个项目，可以导入JS依赖，建立和部署功能到AWS。</p><p id="4a74" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">对于开发来说，设置测试特性也是很好的。</p><p id="3bd0" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">3.<strong class="kb hu">测试</strong></p><p id="49fa" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">JetBrains提供了一个库<code class="eh ly lz ma mb b">org.jetbrains.kotlin:kotlin-test-js</code> <strong class="kb hu"> </strong>用于在KotlinJS中进行测试。正如您在示例中看到的，测试与JUnit测试非常相似，这再次简化了Java/Kotlin开发人员的开发。</p><figure class="mc md me mf fq iu"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek">Sample test with <code class="eh ly lz ma mb b">kotlin-test-js</code></figcaption></figure><p id="0c0e" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">为了测试，我们需要正确地设置编译、打包和运行测试框架(在我们的例子中是Jasmin)。</p><figure class="mc md me mf fq iu"><div class="bz el l di"><div class="mg mh l"/></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek">Testing tasks</figcaption></figure><p id="1dab" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">我们已经为开发、测试和部署准备好了环境。</p><p id="0b11" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated"><strong class="kb hu">一些性能指标</strong></p><figure class="mc md me mf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mm"><img src="../Images/a00c3587b8eb03f6e43a5672c4ddf669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fF7M5-2sLtIlkcEjmIRt_Q.png"/></div></div><figcaption class="mi mj fg fe ff mk ml bd b be z ek">Function duration on Node.js comparing to Java platform</figcaption></figure><p id="6642" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated">正如您在我们的测量中所看到的，与Java平台相比，Node.js平台上运行的函数的启动时间要少得多。但是这种改进是有代价的——对于用Kotlin编写代码并编译成JS的Java/Kotlin开发人员来说，需要一些平台知识。</p><p id="9552" class="pw-post-body-paragraph jz ka ht kb b kc kz ke kf kg la ki kj kk lo km kn ko lp kq kr ks lq ku kv kw hm dt translated"><strong class="kb hu">总结:</strong></p><ol class=""><li id="2381" class="kx ky ht kb b kc kz kg la kk lb ko lc ks ld kw le lf lg lh dt translated">在这个例子中，我们已经为开发管道准备好了<strong class="kb hu">，并且用一个命令<code class="eh ly lz ma mb b">gradle deployFunction</code>就覆盖了整个构建/测试/部署生命周期</strong></li><li id="e508" class="kx ky ht kb b kc lj kg lk kk ll ko lm ks ln kw le lf lg lh dt translated">由于js代码的封装，从Java过渡到Node.js平台应该不需要太多努力</li><li id="243e" class="kx ky ht kb b kc lj kg lk kk ll ko lm ks ln kw le lf lg lh dt translated">我们的测量显示，与Java平台相比，Node.js上的预热时间更短，在这两个示例中，负责业务逻辑的代码都有很小的变化</li></ol><blockquote class="mn"><p id="86fa" class="mo mp ht bd mq mr ms mt mu mv mw kw ek translated"><a class="ae li" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="my mz na nb nc iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mx"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>