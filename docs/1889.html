<html>
<head>
<title>A Tutorial Introduction to Michelson &amp; Tezos, Part I: Hello Michelson</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迈克尔逊&amp;泰佐斯教程介绍，第一部分:你好，迈克尔逊</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-tutorial-introduction-to-michelson-tezos-part-i-hello-michelson-6cc6504aae9e?source=collection_archive---------2-----------------------#2018-12-17">https://medium.com/coinmonks/a-tutorial-introduction-to-michelson-tezos-part-i-hello-michelson-6cc6504aae9e?source=collection_archive---------2-----------------------#2018-12-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="1589" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">迈克尔逊是特佐斯区块链人聪明的契约语言。大致来说，迈克尔逊之于Tezos，就像以太坊虚拟机之于以太坊。两种语言都是基于堆栈的，这意味着计算是通过根据指令序列(程序)改变数据元素序列(堆栈)来完成的。</p><h1 id="def5" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">堆垛机</h1><p id="6a4a" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">迈克尔逊和EVM之间最显著的区别是，迈克尔逊是以人类可读的文本格式编写的，而EVM运算是以字节表示的。例如，如果你查找EVM 的操作码表，你会看到操作码<code class="eh kt ku kv kw b">01</code>取了两个数字(在栈顶)并将它们相加。迈克尔逊中的等价运算写成<code class="eh kt ku kv kw b">ADD</code>。</p><p id="460b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">(公平地说，EVM中的加法操作码<code class="eh kt ku kv kw b">01</code>有<code class="eh kt ku kv kw b">ADD</code>作为中间助记符表示)</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div class="fe ff kx"><img src="../Images/1adf2e548f6f05adf31c3d350a5b6924.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/0*MUMXBJIwbH3CoQSC"/></div></figure><p id="dcc4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在上图中，我们有一个堆栈，可以写成</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="72d2" class="lj jq ht kw b fv lk ll l lm ln">20 : 7 : 13 : 45 : []</span></pre><p id="7ea7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">其中<code class="eh kt ku kv kw b">:</code>是我们的元素分隔符，<code class="eh kt ku kv kw b">[]</code>表示堆栈的底部。</p><p id="7827" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在图示中，我们将操作<code class="eh kt ku kv kw b">ADD</code>应用于堆栈，其定义如下:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="692c" class="lj jq ht kw b fv lk ll l lm ln">ADD / a : b : S =&gt; (a + b) : S</span></pre><p id="32aa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">用简单的英语来说，这个定义是“操作<code class="eh kt ku kv kw b">ADD</code>移除栈顶的两个元素(定义中的<code class="eh kt ku kv kw b">a</code>和<code class="eh kt ku kv kw b">b</code>，然后将元素<code class="eh kt ku kv kw b">(a + b)</code>放回栈顶:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="66c1" class="lj jq ht kw b fv lk ll l lm ln">ADD / 20 : 7 : 13 : 45 : [] =&gt; <br/>    (20 + 7) : 13 : 45 : [] =&gt; <br/>          27 : 13 : 45 : []</span></pre><p id="e3d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">迈克尔逊的所有计算都是基于这种堆栈突变的过程进行的。我们在上面的例子中使用了<code class="eh kt ku kv kw b">ADD</code>，但是我们也可以使用其他算术运算，如减法或乘法，或者逻辑运算，如<code class="eh kt ku kv kw b">NOT</code>、<code class="eh kt ku kv kw b">AND</code>、<code class="eh kt ku kv kw b">OR</code>来改变堆栈。我们可以通过显式地将数据推送到堆栈上，或者通过交换或复制元素来直接操作堆栈。我们有像<code class="eh kt ku kv kw b">LOOP</code>或<code class="eh kt ku kv kw b">IF</code>这样的控制流结构。我们可以执行一些加密操作，如哈希或检查签名，我们可以通过启动令牌传输或创建帐户来与区块链进行交互。迈克尔逊有很多不同的操作。</p><h1 id="bb48" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">类型</h1><p id="45d5" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">迈克尔逊和EVM的第二个主要区别是迈克尔逊数据元素是类型化的。</p><p id="84cc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从广义上讲，类型是一条信息，它限制了用给定的数据值可以做的事情。</p><p id="501e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果值<code class="eh kt ku kv kw b">1</code>的类型为<code class="eh kt ku kv kw b">int</code>(表示整数)，那么我们知道可以安全地对其执行数字加法，但是不能安全地执行列表索引。</p><p id="ade0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于类型为<code class="eh kt ku kv kw b">string</code>的值<code class="eh kt ku kv kw b">"foobar"</code>，情况正好相反。向列表中添加一个数字<code class="eh kt ku kv kw b">1 + "foobar"</code>并没有很好的定义，因为加法是对整数的运算(在大多数语言中，一些语言重载了<code class="eh kt ku kv kw b">+</code>操作符，当它的参数是数字时表示数字加法，当它的参数是字符串时表示连接)</p><p id="8bea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">类型是有用的，因为它们允许迈克尔逊解释器排除可能有问题行为的程序。例如，对于自然数类型<code class="eh kt ku kv kw b">nat</code>，试图从较小的<code class="eh kt ku kv kw b">nat</code>中减去较大的<code class="eh kt ku kv kw b">nat</code>，如<code class="eh kt ku kv kw b">4 - 5</code>，将会导致错误。然后，程序员可以在测试过程中确定这个错误是否是不希望的操作、不正确的参数或者值的类型签名是否应该被改变的结果。重要的是，这个错误在早期就发生了，并阻止了程序的运行，而不是让可能的bug在测试中被忽视，从而导致后来的产品问题。</p><p id="b44f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一般来说，类型允许程序员向机器更详细地传达他们的意图，并允许机器在执行偏离这些意图时向程序员传达。</p><h1 id="8727" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">如何设置迈克尔逊环境</h1><p id="0b63" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">好了，现在我们已经介绍了一点迈克尔逊工作原理，让我们用一些代码来实践一下。</p><h1 id="d0bb" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">安装Tezos客户端</h1><p id="3f11" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">使用Michelson最简单的方法是使用docker安装Tezos客户端。在您的终端中键入以下命令:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="3719" class="lj jq ht kw b fv lk ll l lm ln">$ wget https://gitlab.com/tezos/tezos/raw/alphanet/scripts/alphanet.sh </span><span id="5332" class="lj jq ht kw b fv lo ll l lm ln">$ chmod +x ./alphanet.sh </span><span id="a3ac" class="lj jq ht kw b fv lo ll l lm ln">$ ./alphanet.sh start</span></pre><p id="0e45" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这应该会产生一些输出，您现在可以忽略它们。重要的是，打包在Tezos客户机中的是一个迈克尔逊运行时，我们可以用它来测试我们的程序。</p><p id="8d34" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">或者，您可以按照<a class="ae ks" href="http://tezos.gitlab.io/zeronet/introduction/howtoget.html" rel="noopener ugc nofollow" target="_blank"> Tezos文档</a>中的说明从源代码构建Tezos</p><h1 id="41f6" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">你好，泰佐斯</h1><p id="001c" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">打开您最喜欢的编辑器，在您放置<code class="eh kt ku kv kw b">alphanet.sh</code>脚本的同一个目录中编写下面的程序<code class="eh kt ku kv kw b">helloTezos.tz</code>。</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="7d06" class="lj jq ht kw b fv lk ll l lm ln"># helloTezos.tz<br/>parameter unit; <br/>storage string; <br/>code {DROP; <br/>      PUSH string "Hello Tezos!"; <br/>      NIL operation; PAIR;};</span></pre><p id="cd46" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，我们要检查脚本的类型是否正确:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="19fb" class="lj jq ht kw b fv lk ll l lm ln">$ ./alphanet.sh client typecheck script container:helloTezos.tz</span></pre><p id="4770" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通过添加<code class="eh kt ku kv kw b">--details</code>标志，我们可以看到typechecker发出的更多信息:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="abd6" class="lj jq ht kw b fv lk ll l lm ln">$ ./alphanet.sh client typecheck script container:helloTezos.tz --details</span></pre><p id="b2b5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个程序应该进行类型检查，但如果没有，可能的原因是文件复制不正确，或者自该文档发布以来，迈克尔逊语义发生了重大变化。</p><h1 id="c0cb" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">运行脚本</h1><p id="6489" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">现在我们知道了程序类型检查，我们将运行它。告诉tezos客户机运行Michelson程序(在沙箱中)的命令是:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="f581" class="lj jq ht kw b fv lk ll l lm ln">$ ./alphanet.sh client run script &lt;path&gt; on storage &lt;data&gt; and input &lt;data&gt;</span></pre><p id="0d96" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">其中<code class="eh kt ku kv kw b">&lt;path&gt;</code>是程序源的路径(因为我们使用docker，所以会在前面加上<code class="eh kt ku kv kw b">container:</code>),<code class="eh kt ku kv kw b">&lt;data&gt;</code>是一些迈克尔逊值。</p><p id="834c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将在下面讨论<code class="eh kt ku kv kw b">storage</code>和<code class="eh kt ku kv kw b">input</code>的含义。现在，尝试运行:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="b3c0" class="lj jq ht kw b fv lk ll l lm ln">$ ./alphanet.sh client run script container:helloTezos.tz on storage '""' and input Unit</span></pre><p id="7790" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这应该会返回:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="a874" class="lj jq ht kw b fv lk ll l lm ln">storage "Hello Tezos!" emitted operations</span></pre><p id="4221" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">恭喜你，你刚刚在迈克尔逊运行了你的第一个智能合同！</p><h1 id="fa61" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">迈克尔逊契约召集公约</h1><p id="2ba9" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">现在让我们来详细了解一下合同是如何运作的:</p><p id="72dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所有迈克尔逊智能契约都是带有两个参数的函数，一个输入参数和一个存储值，并返回一对操作列表和一个存储值。存储值实际上是一个返回值，操作列表就像是一个延续，例如，如果这个契约被另一个契约调用。</p><p id="f310" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有许多不同的方法来记录类型签名，但下面是合同的迈克尔逊类型签名的样子:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="12c5" class="lj jq ht kw b fv lk ll l lm ln">lambda (pair 'parameter 'storage) (pair (list operation) 'storage)</span></pre><p id="07e1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">就个人而言，我更喜欢Haskell的类型符号，但两种签名是等效的:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="31a8" class="lj jq ht kw b fv lk ll l lm ln">contract :: (Parameter p, Storage s) -&gt; ([Operation], Storage s)</span></pre><h1 id="72ce" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">helloTezos初始和返回类型</h1><p id="f373" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">我们再来看看<code class="eh kt ku kv kw b">helloTezos.tz</code>:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="acd9" class="lj jq ht kw b fv lk ll l lm ln"># helloTezos.tz<br/>parameter unit; <br/>storage string; <br/>code {DROP; <br/>      PUSH string "Hello Tezos!"; <br/>      NIL operation; PAIR;};</span></pre><p id="daae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh kt ku kv kw b">parameter unit</code>和<code class="eh kt ku kv kw b">storage string</code>行指定了契约的两个参数的类型。如果我们将上面的签名具体化为一般类型的迈克尔逊合同，用<code class="eh kt ku kv kw b">'parameter</code>作为<code class="eh kt ku kv kw b">unit</code>和<code class="eh kt ku kv kw b">'storage</code>作为<code class="eh kt ku kv kw b">string</code>，我们得到我们具体的<code class="eh kt ku kv kw b">helloTezos.tz</code>合同的类型:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="3da9" class="lj jq ht kw b fv lk ll l lm ln">lambda (pair unit string) (pair (list operation) string)</span></pre><p id="c63d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">迈克尔逊契约的初始堆栈是它的参数对<code class="eh kt ku kv kw b">(pair 'parameter 'storage)</code>，所以<code class="eh kt ku kv kw b">helloTezos.tz</code>从一个类型的堆栈开始:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="e66c" class="lj jq ht kw b fv lk ll l lm ln">:: (pair unit string) : []</span></pre><p id="c23b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在命令行中，我们运行</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="1910" class="lj jq ht kw b fv lk ll l lm ln">$ ./alphanet.sh client run script container:helloTezos.tz on storage '""' and input Unit</span></pre><p id="8584" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh kt ku kv kw b">'""'</code>是空字符串<code class="eh kt ku kv kw b">""</code>的命令行语法，<code class="eh kt ku kv kw b">Unit</code>是<code class="eh kt ku kv kw b">unit</code>类型的单个居民的数据构造器。请注意，输入和参数在这里是同义词。所以我们的初始堆栈有具体的值:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="beb6" class="lj jq ht kw b fv lk ll l lm ln">(Pair Unit "") : []</span></pre><p id="defe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它有类型</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="1c2b" class="lj jq ht kw b fv lk ll l lm ln">:: (pair unit string) : []</span></pre><p id="49fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh kt ku kv kw b">Pair</code>和<code class="eh kt ku kv kw b">pair</code>的区别在于<code class="eh kt ku kv kw b">Pair</code>是数据构造器<code class="eh kt ku kv kw b">pair</code>是类型。Michelson中的数据构造函数以大写字母开头，而类型都是小写的。</p><p id="3743" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们有了初始值和返回类型，我们可以把契约的执行看作是一系列操作，把初始值转换成与返回类型匹配的返回值。</p><p id="f4ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">换句话说，我们从</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="6577" class="lj jq ht kw b fv lk ll l lm ln">(Pair Unit "") : [] :: (pair unit string) : []</span></pre><p id="fe08" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们想以此结束</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="19cc" class="lj jq ht kw b fv lk ll l lm ln">??? :: (pair (list operation) string) : []</span></pre><h1 id="e11a" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">helloTezos处决</h1><p id="ecdf" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">幸运的是，我们的合同很短，只有4个操作，所以我们可以在这里完成这个转换的步骤。操作写在<code class="eh kt ku kv kw b">helloTezos.tz</code>的<code class="eh kt ku kv kw b">code</code>标题之后:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="3dcb" class="lj jq ht kw b fv lk ll l lm ln"># helloTezos.tz <br/>code {DROP; <br/>      PUSH string "Hello Tezos!"; <br/>      NIL operation; PAIR;};</span></pre><p id="7642" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果我们记下这个操作序列以及上一节中的初始值和类型，我们就可以得到迈克尔逊堆栈机器的完整状态:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="acb9" class="lj jq ht kw b fv lk ll l lm ln">STATE <br/>code DROP; PUSH string "Hello Tezos!"; NIL operation; PAIR; <br/>stack (Pair Unit "") : [] <br/>type :: (pair unit string) : []</span></pre><h1 id="969c" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">滴</h1><p id="d6b4" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated"><code class="eh kt ku kv kw b">DROP</code>操作移除(或“丢弃”)堆栈的顶部元素，并具有以下定义(根据迈克尔逊规范稍微重新安排)</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="410b" class="lj jq ht kw b fv lk ll l lm ln">code DROP <br/>stack _ : S =&gt; S <br/>type :: _ : 'A -&gt; 'A</span></pre><p id="5b28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">其中<code class="eh kt ku kv kw b">_</code>是匹配任何操作、值或类型的通配符</p><p id="da58" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">把这个应用到我们的州，我们的新州是:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="e10b" class="lj jq ht kw b fv lk ll l lm ln">STATE <br/>code PUSH string "Hello Tezos!"; NIL operation; PAIR; <br/>stack [] <br/>type :: []</span></pre><h1 id="ecd9" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">推</h1><p id="e414" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated"><code class="eh kt ku kv kw b">PUSH</code>操作将一个特定类型的值添加到堆栈顶部，定义如下:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="06bf" class="lj jq ht kw b fv lk ll l lm ln">code PUSH 'a (x :: 'a) <br/>stack S =&gt; x : S <br/>type 'A -&gt; 'a : 'A</span></pre><p id="36a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的具体指令是<code class="eh kt ku kv kw b">PUSH string "Hello Tezos!"</code>，所以转换具体化为:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="491d" class="lj jq ht kw b fv lk ll l lm ln">code PUSH string ("Hello Tezos!" :: string) <br/>stack S =&gt; "Hello Tezos!" : S <br/>type 'A -&gt; string : 'A</span></pre><p id="0a17" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当应用时，它给我们一个新的状态:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="c667" class="lj jq ht kw b fv lk ll l lm ln">STATE <br/>code NIL operation; PAIR; <br/>stack "Hello Tezos!" : [] <br/>type :: string : []</span></pre><h1 id="c52d" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">无</h1><p id="5a18" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated"><code class="eh kt ku kv kw b">NIL</code>操作将某一类型的空列表添加到堆栈顶部，定义如下:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="48fe" class="lj jq ht kw b fv lk ll l lm ln">code NIL 'a <br/>stack S =&gt; {} : S <br/>type 'A -&gt; list 'a : 'A</span></pre><p id="2182" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当应用时，它给我们一个新的状态:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="b4ab" class="lj jq ht kw b fv lk ll l lm ln">STATE <br/>code PAIR; <br/>stack {} : "Hello Tezos!" : [] <br/>type :: list operation : string : []</span></pre><h1 id="d888" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">一副</h1><p id="a2bc" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated"><code class="eh kt ku kv kw b">PAIR</code>操作移除栈顶的两个元素，将它们组合成一对，并将这一对推到栈上。它有以下定义:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="2b08" class="lj jq ht kw b fv lk ll l lm ln">code PAIR <br/>stack a : b : S =&gt; (Pair a b) : S <br/>type 'a : 'b : 'A -&gt; pair 'a 'b : 'A</span></pre><p id="d787" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当应用时，它给我们一个新的状态:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="d6c0" class="lj jq ht kw b fv lk ll l lm ln">STATE <br/>code <br/>stack (Pair {} "Hello Tezos!") : [] <br/>type :: pair (list operation) string : []</span></pre><h1 id="e32f" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">结束</h1><p id="4cab" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">我们现在没有操作了，我们的栈有类型<code class="eh kt ku kv kw b">pair (list operation) string : []</code>，这正是我们想要的。由于该类型与我们预期的返回类型相匹配，所以契约返回我们的<code class="eh kt ku kv kw b">(pair 'operations 'storage)</code>中的值:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="addf" class="lj jq ht kw b fv lk ll l lm ln">storage <br/>  "Hello Tezos!" <br/>emitted operations</span></pre><h1 id="bd43" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">结论</h1><p id="3cb3" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">这结束了我们的迈克尔逊教程的第一部分。你现在应该知道了</p><ul class=""><li id="8aa1" class="lp lq ht is b it iu ix iy jb lr jf ls jj lt jn lu lv lw lx dt translated">堆垛机的基本工作原理</li><li id="153c" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">如何安装Tezos客户端</li><li id="8dbc" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">如何编写和执行一个简单的迈克尔逊合同</li><li id="2214" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx dt translated">什么是迈克尔逊类型，值和操作，以及每一个简单的例子</li></ul><p id="919d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在第二部分中，我们将编写更多的契约并检查它们的执行(尽管不太严格)，引入更多的操作、类型和数据构造函数。</p><h1 id="a1d4" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">读者练习</h1><p id="75de" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated"><strong class="is hu">练习1: </strong>修改我们的<code class="eh kt ku kv kw b">helloTezos.tz</code>文件以输出<code class="eh kt ku kv kw b">"Hello World!"</code>而不是<code class="eh kt ku kv kw b">"Hello Tezos</code>。调用这个文件<code class="eh kt ku kv kw b">helloWorld.tz</code></p><p id="9bfa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">练习2: </strong>现在修改我们的<code class="eh kt ku kv kw b">helloTezos.tz</code>文件，将一个字符串参数作为输入和输出<code class="eh kt ku kv kw b">"Hello &lt;input&gt;".</code>调用这个文件<code class="eh kt ku kv kw b">helloInput.tz</code>你需要知道两个额外的操作:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="7577" class="lj jq ht kw b fv lk ll l lm ln">code CAR # select left-hand of pair <br/>stack (Pair a _) : S =&gt; a : S<br/>type pair 'a 'b : 'A -&gt; 'a : 'A</span><span id="e1d9" class="lj jq ht kw b fv lo ll l lm ln">code CONCAT # string concatenate <br/>stack a : b =&gt; a ^ b : S <br/>type string : string : 'A -&gt; string: 'A <br/>  where a ^ b concatenates the end of a to the beginning of b</span></pre><p id="60e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">练习3: </strong>做与练习2相同的事情，除了现在契约将一个单元作为其输入参数，并输出连接到其初始存储的<code class="eh kt ku kv kw b">"Hello "</code>。所以跑步<code class="eh kt ku kv kw b">$./alphanet.sh client run script container:hellotezos.tz on storage '"bar"' and input 'Unit'</code></p><p id="a80a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">应该输出“你好吧”。把这个文件叫做<code class="eh kt ku kv kw b">helloStorage.tz</code></p><p id="83d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您需要知道一个额外的操作:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="dcaf" class="lj jq ht kw b fv lk ll l lm ln">code CDR # select right-hand of pair <br/>stack (Pair _ b) : S =&gt; b : S <br/>type pair 'a 'b : 'A -&gt; 'b : 'A</span></pre><p id="a041" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">练习4: </strong>写一个连接输入字符串和存储字符串以及输出的契约<code class="eh kt ku kv kw b">"Hello &lt;input&gt;&lt;storage&gt;"</code>。调用这个文件<code class="eh kt ku kv kw b">helloInputAndStorage.tz</code></p><p id="d238" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你需要知道:</p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="609d" class="lj jq ht kw b fv lk ll l lm ln">code DUP # Duplicate the top of the stack<br/>stack x : S =&gt; x : x : S<br/>type :: 'a : 'A -&gt; 'a : 'a : 'A</span><span id="fdba" class="lj jq ht kw b fv lo ll l lm ln">code DIP ops # Runs code protecting the top of the stack<br/>stack x : S =&gt; x : S' <br/>  where ops / S =&gt; S' <br/>type :: 'b : 'A -&gt; 'b : 'C <br/> iff ops :: [ 'A -&gt; 'C ]</span></pre><p id="c217" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你也可以用<code class="eh kt ku kv kw b">SWAP</code>代替<code class="eh kt ku kv kw b">DIP</code></p><pre class="ky kz la lb fq lf kw lg lh aw li dt"><span id="a1bf" class="lj jq ht kw b fv lk ll l lm ln">SWAP # Exchange the top two elements of the stack<br/>stack x : y : S =&gt; y : x : S <br/>type :: 'a : 'b : 'A -&gt; 'b : 'a : 'A</span></pre></div><div class="ab cl md me hb mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hm hn ho hp hq"><p id="bb76" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jo">原载于</em><a class="ae ks" href="https://gitlab.com/camlcase-dev/michelson-tutorial/tree/master/01" rel="noopener ugc nofollow" target="_blank"><em class="jo">https://git lab . com/caml case-dev/Michel son-tutorial/tree/master/01</em></a></p><blockquote class="mk"><p id="d837" class="ml mm ht bd mn mo mp mq mr ms mt jn ek translated"><a class="ae ks" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mv mw mx my mz lc fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mu"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="ky kz la lb fq lc fe ff paragraph-image"><a href="http://bit.ly/2G71Sp7"><div class="fe ff na"><img src="../Images/449450761cd76f44f9ae574333f9e9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKX2mtg7p1lOs7JmosPLsA.png"/></div></a><figcaption class="nb nc fg fe ff nd ne bd b be z ek"><a class="ae ks" href="http://bit.ly/2G71Sp7" rel="noopener ugc nofollow" target="_blank"><strong class="bd nf">Click to read today’s top story</strong></a></figcaption></figure></div></div>    
</body>
</html>