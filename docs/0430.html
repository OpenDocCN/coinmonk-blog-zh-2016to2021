<html>
<head>
<title>What is a Hash?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是哈希？</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-laymans-explanation-to-what-is-a-hash-a45c680edd41?source=collection_archive---------7-----------------------#2018-05-03">https://medium.com/coinmonks/a-laymans-explanation-to-what-is-a-hash-a45c680edd41?source=collection_archive---------7-----------------------#2018-05-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="2c8c" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">…简单解释</h2></div><p id="7193" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">什么是哈希？</strong> <br/>一个<strong class="jk hu">散列</strong>是接受任意一组数据/比特(可以是单个字符、一段视频或整个国会图书馆)并使用算法将输入转换成固定大小的数据/比特输出的结果，通常是十六进制数。</p><p id="e85b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因此，不管放入散列的信息量有多少，您总是会得到相同长度的唯一散列。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff ke"><img src="../Images/f0d646b59d5c4e130f82025c12c306ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*xyMyRxGQdYvc93LkJVNPZg.jpeg"/></div><figcaption class="km kn fg fe ff ko kp bd b be z ek">Anything goes in and fixed-length hash comes out.</figcaption></figure><p id="4de5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">更深入地说，这种算法是单向函数，它在一个方向接收数据，在另一个方向输出非常独特的十六进制数字符串。输入数据中的一个变化会导致非常不同的输出字符串。</p><p id="b87f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">您很难从hash的输入中猜出它的输出。更不可能从固定大小的输出中猜出输入。</p><p id="4679" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">相同的数据将总是具有相同的唯一散列。然而，在处理大型数据集时，冲突是不可避免的。当两个输入具有相同的散列时，这将导致<strong class="jk hu">冲突</strong>。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/5f75659b594015a84963b96e4397d7b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*h9oa_5cXSzj_JBjvlH7_tQ.jpeg"/></div><figcaption class="km kn fg fe ff ko kp bd b be z ek">Not enough room for all the pigeons.</figcaption></figure><p id="bec3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为什么会发生碰撞？这是由<a class="ae kr" href="https://io9.gizmodo.com/why-the-pigeonhole-principle-is-one-of-maths-most-power-1601025172" rel="noopener ugc nofollow" target="_blank"> <strong class="jk hu">鸽巢原理</strong> </a> <strong class="jk hu">解释的。</strong>简单解释，鸽笼原理定义为试图将<strong class="jk hu"> </strong> n + 1个物品(或鸽子)放入n个空间(鸽笼)。从逻辑上讲，至少会有一个实例，其中两个项目(或鸽子)在同一个空间。试着用3张碎纸(n + 1)和2个废纸篓(n)来做这件事。你会发现至少有一个废纸篓里有两张纸。</p><p id="1513" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">所以，每个哈希都有串通。然而，良好的散列算法使得很难发现这种冲突，也称为<strong class="jk hu">冲突阻力</strong>。<strong class="jk hu">抗合谋</strong>不代表没有碰撞，只是说它们很难被发现。</p><p id="d93e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">有些人试图用<a class="ae kr" href="https://en.wikipedia.org/wiki/Brute-force_attack" rel="noopener ugc nofollow" target="_blank"> <strong class="jk hu">蛮力攻击</strong> </a>破解哈希算法，这基本上是计算机做出真正快速的猜测。这种类型的攻击称为<a class="ae kr" href="https://learncryptography.com/hash-functions/hash-collision-attack" rel="noopener ugc nofollow" target="_blank"> <strong class="jk hu">哈希碰撞攻击</strong> </a>。随着计算变得越来越快，越来越便宜，旧哈希被成功攻击的风险变得越来越大，就像<a class="ae kr" href="https://www.theregister.co.uk/2017/02/23/google_first_sha1_collision/" rel="noopener ugc nofollow" target="_blank">谷歌研究人员在2017年为SHA-1哈希算法发现的那样</a>。</p></div></div>    
</body>
</html>