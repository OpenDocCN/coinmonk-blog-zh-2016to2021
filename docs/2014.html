<html>
<head>
<title>Solidity 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实度101</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-101-eec816744e95?source=collection_archive---------3-----------------------#2019-01-26">https://medium.com/coinmonks/solidity-101-eec816744e95?source=collection_archive---------3-----------------------#2019-01-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="8a85" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated"><em class="ji">在这篇文章中了解可靠性，作者Brenn Hill是一名高级软件工程师，拥有北卡罗来纳大学信息科学硕士学位。他努力与企业合作，以确保技术项目获得良好的投资回报，并解决关键的业务问题。</em></h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/9abac8dd5a4e2a9bbfadb33fc85ddaef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLpvpR0VvHm2QoP3o_hZJw.png"/></div></div></figure><h1 id="904f" class="jv jw ht bd jx jy jz ka kb kc kd ke kf iz kg ja kh jc ki jd kj jf kk jg kl km dt translated">坚实度101</h1><p id="488a" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">Solidity是一种由以太坊基金会推出的静态类型编程语言，它使得在以太坊区块链之上创建分散式应用成为可能，既可以用于创建另一个加密货币令牌，也可以用于区块链可能扮演重要角色的任何其他用例。</p><p id="4aff" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">以太坊在其平台上运行智能合约；这些应用程序使用区块链技术来执行所需的操作，使用户能够创建自己的区块链，并发行自己的替代加密货币。这是通过在<strong class="kp hu"> Solidity </strong>中编码实现的，Solidity【】用于编写将在以太坊区块链上执行的智能合同，并执行编程的任务。</p><p id="850d" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">受C++、Python和JavaScript的影响，Solidity于2014年8月提出，由以太坊项目的solidity团队开发。完整的应用程序部署在区块链上，包括智能合同、前端接口和其他模块；这被称为<strong class="kp hu"> DApp </strong>或<strong class="kp hu">分散式应用。</strong></p><p id="8f03" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">Solidity也称为面向契约的语言，因为契约类似于面向对象语言中的类。Solidity语言松散地基于ECMAScript(JavaScript)；因此，预先了解这一点将有助于理解坚固性。以下是在Solidity中开发、测试和部署智能合约所需的一些工具:</p><p id="7edc" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><strong class="kp hu"> TestNet </strong>:选择要工作的TestNet，指定要使用的网络ID。</p><p id="a502" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><strong class="kp hu">编译器</strong>:选择需要的编译器，比如<code class="eh lo lp lq lr b">solc</code>，是solidity编译器；它包含在大多数节点中，也可以作为独立的软件包使用。</p><p id="c900" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><strong class="kp hu"> Web3.js </strong>:帮助以太坊网络和我们的DApp通过HTTP或IPC网络连接的库。</p><p id="cc9f" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><strong class="kp hu">框架</strong>:从可用于合同编制和部署等任务的框架中选择一个框架非常重要。使用的一些框架是Truffle、Embark、Dapple等。</p><h2 id="5615" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">坚实的基础</h2><p id="0b7b" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">如果你经常编程，你应该已经知道代码编辑器或者集成开发环境。对于已经存在的各种ide，有一个集成列表；除此之外，以太坊基金会还发布了一个基于浏览器的IDE，集成了编译器和Solidity运行时环境，没有用于编写和测试智能合约的服务器组件。可以在<a class="ae mg" href="http://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank">remix.ethereum.org</a>找到。</p><h2 id="8287" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">使用编译器</h2><p id="69de" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">对于小型和学习型的DApps项目，建议在以太坊基金会基于浏览器的编译器上进行工作:<strong class="kp hu"> Remix </strong>。另一种方法是在你的机器上安装Solidity编译器。使用以下命令可从<code class="eh lo lp lq lr b">npm</code>安装<code class="eh lo lp lq lr b">solc</code>:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="1814" class="ls jw ht lr b fv ml mm l mn mo"><strong class="lr hu">npm install -g solc</strong></span></pre><p id="59cb" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">Solidity也可以通过克隆GitHub链接上的Git库从源代码构建，该链接位于<a class="ae mg" href="https://github.com/ethereum/solidity.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ethereum/solidity.git</a>。</p><h1 id="27d8" class="jv jw ht bd jx jy jz ka kb kc kd ke kf iz kg ja kh jc ki jd kj jf kk jg kl km dt translated">可靠性编程</h1><p id="8be1" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">在本节中，我们将讨论Solidity源文件的结构和元素；我们将讨论布局，结构，数据类型，它的类型，单位，控制，表达式和其他方面的可靠性。实体文件的格式扩展名为<code class="eh lo lp lq lr b">.sol</code>。</p><h2 id="4a7c" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">布置实体文件</h2><p id="1ff0" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">Solidity正在经历积极的发展，并且有许多来自一个庞大社区的定期变化和建议；因此，在源文件的开头指定实体文件的版本以避免任何冲突是很重要的。这是通过Pragma版本实现的。这是在solidity文件的开头定义的，这样任何想要运行该文件的人都知道以前的版本。看一下这段代码:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="cbe6" class="ls jw ht lr b fv ml mm l mn mo"><strong class="lr hu">pragma solidity ^0.4.24;</strong></span></pre><p id="e6c2" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">通过指定版本号，特定的源文件将使用比指定版本号更早或更晚的版本进行编译。</p><h2 id="4f94" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">导入文件</h2><p id="9a89" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">与ECMAScript类似，Solidity文件使用如下的<code class="eh lo lp lq lr b">import</code>语句声明:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="28e5" class="ls jw ht lr b fv ml mm l mn mo"><strong class="lr hu">import “filename.sol”;</strong></span></pre><p id="15d7" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">前面的语句将把所有符号从<code class="eh lo lp lq lr b">filename.sol</code>文件作为全局语句导入到当前文件中。导入文件时也支持路径，所以可以使用类似于JavaScript的<code class="eh lo lp lq lr b">/</code>、<code class="eh lo lp lq lr b">.</code>或<code class="eh lo lp lq lr b">..</code>。</p><h2 id="ed1d" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">评论</h2><p id="2b13" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">使用单行(<code class="eh lo lp lq lr b">//</code>)注释和多行(<code class="eh lo lp lq lr b">/* … */</code>)注释，尽管除此之外还有另一种类型的注释样式，称为<strong class="kp hu"> Natspec注释</strong>，这也是可能的；在这种类型的注释中，我们要么使用<code class="eh lo lp lq lr b">///</code>要么使用<code class="eh lo lp lq lr b">/** … */</code>，它们只在早期的函数声明或语句中使用。</p><p id="0ea5" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">Natspec是natural specification的缩写；根据最新的solidity版本(0.4.24 ),这些注释不适用于变量，即使变量是公共的。下面是一小段代码，其中包含这类注释的示例:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="2d31" class="ls jw ht lr b fv ml mm l mn mo">pragma solidity ^0.4.19;</span><span id="6ea4" class="ls jw ht lr b fv mp mm l mn mo">/// @title A simulator for Batman, Gotham’s Hero</span><span id="ebf6" class="ls jw ht lr b fv mp mm l mn mo">/// @author DC-man</span><span id="7f93" class="ls jw ht lr b fv mp mm l mn mo">/// @notice You can use this contract for only the most basic simulation</span><span id="9e68" class="ls jw ht lr b fv mp mm l mn mo">/// @dev All function calls are currently implement without side effects</span><span id="3a95" class="ls jw ht lr b fv mp mm l mn mo">contract Batman {</span><span id="6a59" class="ls jw ht lr b fv mp mm l mn mo">  /// @author Samanyu Chopra</span><span id="65ee" class="ls jw ht lr b fv mp mm l mn mo">  /// @notice Determine if Bugs will accept `(_weapons)` to kill</span><span id="44b4" class="ls jw ht lr b fv mp mm l mn mo">  /// @dev String comparison may be inefficient</span><span id="76f6" class="ls jw ht lr b fv mp mm l mn mo">  /// @param _weapons The name weapons to save in the repo (English)</span><span id="6a04" class="ls jw ht lr b fv mp mm l mn mo">  /// @return true if Batman will keep it, false otherwise</span><span id="37b4" class="ls jw ht lr b fv mp mm l mn mo">  function doesKeep(string _weapons) external pure returns (bool) {</span><span id="a225" class="ls jw ht lr b fv mp mm l mn mo">  return keccak256(_weapons) == keccak256(“Shotgun”);</span><span id="a37b" class="ls jw ht lr b fv mp mm l mn mo">  }</span><span id="9328" class="ls jw ht lr b fv mp mm l mn mo">}</span></pre><h2 id="5445" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">标签</h2><p id="2911" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">它们在Natspec注释中使用；每个标签都有基于其用法的自己的上下文，如下表所示:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mq"><img src="../Images/9ca3d27ab567b9b1d0a48b6ae6895a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPQIgB_76FWYR2ncpQEeoQ.png"/></div></div></figure><h1 id="2c34" class="jv jw ht bd jx jy jz ka kb kc kd ke kf iz kg ja kh jc ki jd kj jf kk jg kl km dt translated">合同的结构</h1><p id="3a75" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">Solidity中的每个契约都类似于类的概念。契约可以从其他契约继承，方式类似于类。合同可以包含以下声明:</p><p id="102b" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">状态变量</p><p id="8103" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">功能</p><p id="1f58" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">功能修饰符</p><p id="1ecb" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">事件</p><p id="8487" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">结构类型</p><p id="b566" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">枚举类型</p><h2 id="35f6" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">状态变量</h2><p id="6dc1" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">这些是永久存储在合同存储中的值，例如:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="548e" class="ls jw ht lr b fv ml mm l mn mo">pragma solidity ^0.4.24;</span><span id="9135" class="ls jw ht lr b fv mp mm l mn mo">contract Gotham {</span><span id="b3a7" class="ls jw ht lr b fv mp mm l mn mo">uint storedData; // State variable</span><span id="88d6" class="ls jw ht lr b fv mp mm l mn mo">// …</span><span id="141e" class="ls jw ht lr b fv mp mm l mn mo">}</span></pre><h2 id="5388" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">功能</h2><p id="7c33" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">函数可以在内部或外部调用，例如:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="0aa2" class="ls jw ht lr b fv ml mm l mn mo">pragma solidity ^0.4.24;</span><span id="62a5" class="ls jw ht lr b fv mp mm l mn mo">contract Gotham {</span><span id="f258" class="ls jw ht lr b fv mp mm l mn mo">  function joker() public Bat { // Function</span><span id="cffa" class="ls jw ht lr b fv mp mm l mn mo">  // …</span><span id="3e54" class="ls jw ht lr b fv mp mm l mn mo">  }</span><span id="eab8" class="ls jw ht lr b fv mp mm l mn mo">}</span></pre><h2 id="3667" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">功能修饰符</h2><p id="c295" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">函数修饰符可以用来修改声明中函数的语义。也就是说，它们用于改变函数的行为。例如，它们用于在执行功能之前自动检查条件，或者它们可以根据需要在给定的时间范围内解锁功能。它们可以被衍生合同覆盖，如下所示:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="175c" class="ls jw ht lr b fv ml mm l mn mo">pragma solidity ^0.4.24;</span><span id="fdc9" class="ls jw ht lr b fv mp mm l mn mo">contract Gotham {</span><span id="a110" class="ls jw ht lr b fv mp mm l mn mo">  address public weapons;</span><span id="d12a" class="ls jw ht lr b fv mp mm l mn mo">modifier Bank() { // Modifier</span><span id="62e6" class="ls jw ht lr b fv mp mm l mn mo">  require(</span><span id="6304" class="ls jw ht lr b fv mp mm l mn mo">    msg.sender == coins,</span><span id="42ea" class="ls jw ht lr b fv mp mm l mn mo">    “Only coins can call this.”</span><span id="e0a6" class="ls jw ht lr b fv mp mm l mn mo">  );</span><span id="ac31" class="ls jw ht lr b fv mp mm l mn mo">  _;</span><span id="32eb" class="ls jw ht lr b fv mp mm l mn mo">}</span><span id="51d2" class="ls jw ht lr b fv mp mm l mn mo">  function abort() public coinsbuyer { // Modifier usage</span><span id="b6a2" class="ls jw ht lr b fv mp mm l mn mo">// …</span><span id="5ca7" class="ls jw ht lr b fv mp mm l mn mo">  }</span><span id="477c" class="ls jw ht lr b fv mp mm l mn mo">}</span></pre><h2 id="3565" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">事件</h2><p id="d9f3" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">事件允许通过DApp的前端方便地使用EVM。事件可以被听到和维护。看一下这段代码:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="4129" class="ls jw ht lr b fv ml mm l mn mo">pragma solidity ^0.4.24;</span><span id="2d25" class="ls jw ht lr b fv mp mm l mn mo">contract Attendance {</span><span id="e5f9" class="ls jw ht lr b fv mp mm l mn mo">    event Mark_attendance(string name, uint ID); // Event</span><span id="b946" class="ls jw ht lr b fv mp mm l mn mo">  function roll_call() public marking {</span><span id="8b2c" class="ls jw ht lr b fv mp mm l mn mo">          // …</span><span id="6885" class="ls jw ht lr b fv mp mm l mn mo">              emit Mark_attendance(Name, ID); //Triggering event</span><span id="42c1" class="ls jw ht lr b fv mp mm l mn mo">     }</span><span id="c09b" class="ls jw ht lr b fv mp mm l mn mo">}</span></pre><h2 id="189a" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">类型</h2><p id="bca9" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">在Solidity中，每个变量的类型需要在编译时指定。通过组合复杂类型，也可以在Solidity中创建复杂类型。Solidity中有两类数据类型:<strong class="kp hu">值类型</strong>和<strong class="kp hu">引用类型</strong>。</p><h2 id="c31d" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">值类型</h2><p id="3177" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">值类型被称为<strong class="kp hu">值类型</strong>，因为这些类型的变量在其自己分配的内存中保存数据。</p><h2 id="c34a" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">布尔代数学体系的</h2><p id="7a20" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">这种类型的数据有两个值，true或false，例如:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="a7d8" class="ls jw ht lr b fv ml mm l mn mo">bool b = false;</span></pre><p id="483a" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">前面的语句将<code class="eh lo lp lq lr b">false </code>分配给布尔数据类型<code class="eh lo lp lq lr b">b</code>。</p><h2 id="5c98" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">整数</h2><p id="de49" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">该值类型分配整数。整数有两个子类型，即<code class="eh lo lp lq lr b">int</code>和<code class="eh lo lp lq lr b">uint</code>，分别是有符号整数和无符号整数类型。内存大小是在编译时分配的；使用<code class="eh lo lp lq lr b">int8</code>或<code class="eh lo lp lq lr b">int256</code>指定，其中数字代表内存中分配的大小。仅使用<code class="eh lo lp lq lr b">int</code>或<code class="eh lo lp lq lr b">uint</code>分配内存，默认分配最大的内存大小。</p><h2 id="e3b0" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">地址</h2><p id="5f74" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">该值类型包含一个20字节的值，这是以太坊地址的大小(40个十六进制字符或160位)。看看这个:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="7d27" class="ls jw ht lr b fv ml mm l mn mo">address a = 0xe2793a1b9a149253341cA268057a9EFA42965F83</span></pre><p id="a458" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">此类型有几个成员可用于与协定交互。这些成员如下:</p><p id="18c2" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">balance</code></p><p id="e2fa" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">transfer</code></p><p id="8f57" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">send</code></p><p id="61da" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">call</code></p><p id="6ca5" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">callcode</code></p><p id="eed7" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">delegatecall</code></p><p id="0c86" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">balance </code>以卫为单位返回地址余额，例如:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="1530" class="ls jw ht lr b fv ml mm l mn mo">address a = 0xe2793a1b9a149253341cA268057a9EFA42965F83;</span><span id="2309" class="ls jw ht lr b fv mp mm l mn mo">uint bal = a.balance;</span></pre><p id="7783" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">transfer</code>用于从一个地址转移到另一个地址，例如:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="4ac2" class="ls jw ht lr b fv ml mm l mn mo">address a = 0xe2793a1b9a149253341cA268057a9EFA42965F83;</span><span id="a1e3" class="ls jw ht lr b fv mp mm l mn mo">address b = 0x126B3adF2556C7e8B4C3197035D0E4cbec1dBa83;</span><span id="9885" class="ls jw ht lr b fv mp mm l mn mo">if (a.balance &gt; b.balance) b.transfer(6);</span></pre><p id="8b85" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">当我们使用<code class="eh lo lp lq lr b">transfer</code>或<code class="eh lo lp lq lr b">send</code>构件时，消耗的气体量几乎相同。<code class="eh lo lp lq lr b">transfer</code>从Solidity 0.4.13引入，因为send不发送任何气体，也不传播异常。<code class="eh lo lp lq lr b">Transfer</code>被认为是从一个地址向另一个地址发送以太网的安全方式，因为它会抛出错误并允许某人传播错误。</p><p id="047a" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">call</code>、<code class="eh lo lp lq lr b">callcode</code>和<code class="eh lo lp lq lr b">delegatecall</code>用于与没有<strong class="kp hu">应用二进制接口</strong> ( <strong class="kp hu"> ABI </strong>)的函数进行交互。<code class="eh lo lp lq lr b">call</code>返回一个布尔值，表明函数是成功运行还是在EVM中终止。</p><p id="2d4e" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">当<code class="eh lo lp lq lr b">a</code>调用<code class="eh lo lp lq lr b">b</code>时，代码在<code class="eh lo lp lq lr b">b</code>的上下文中运行，并使用<code class="eh lo lp lq lr b">b</code>的存储。另一方面，当<code class="eh lo lp lq lr b">a</code>调用<code class="eh lo lp lq lr b">b</code>上的code时，代码在<code class="eh lo lp lq lr b">a</code>的上下文中运行，使用<code class="eh lo lp lq lr b">a</code>的存储，但使用<code class="eh lo lp lq lr b">a</code>的and存储。</p><p id="2fb4" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">delegatecall</code>函数用于根据需要委托一个合同使用另一个合同的存储。</p><h2 id="e24f" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">数组值类型</h2><p id="bfbc" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">Solidity有一个固定和动态的数组值类型。在固定大小的字节数组中，关键字的范围从<code class="eh lo lp lq lr b">bytes1</code>到<code class="eh lo lp lq lr b">bytes32</code>。另一方面，在动态大小的字节数组中，关键字可以包含字节或字符串。<code class="eh lo lp lq lr b">bytes</code>用于原始字节数据，<code class="eh lo lp lq lr b">strings</code>用于在<code class="eh lo lp lq lr b">UTF-8</code>中编码的字符串。</p><p id="e501" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">length</code>是返回固定大小字节数组或动态大小字节数组的长度的成员。</p><p id="7acc" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">固定大小数组初始化为<code class="eh lo lp lq lr b">test[10]</code>，动态大小数组初始化为<code class="eh lo lp lq lr b">test2[</code>。</p><h2 id="0a77" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">逐字的</h2><p id="2296" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">文字用于表示固定值；使用了多种类型的文字；它们如下:</p><p id="de42" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">整数文字</p><p id="ed66" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">字符串文字</p><p id="db0d" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">十六进制文字</p><p id="f488" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">地址文字</p><p id="4816" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">整数文字由从0到9的数字序列组成。八进制文字和以0开头的文字无效，因为以太坊中的地址是以0开头的。看看这个:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="ac9b" class="ls jw ht lr b fv ml mm l mn mo">int a = 11;</span></pre><p id="f28d" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">字符串文字用一对双引号(<code class="eh lo lp lq lr b">“…”</code>)或单引号(<code class="eh lo lp lq lr b">‘…’</code>)声明，例如:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="c8ca" class="ls jw ht lr b fv ml mm l mn mo">Test = ‘Batman’;</span><span id="1848" class="ls jw ht lr b fv mp mm l mn mo">Test2 = “Batman”;</span></pre><p id="e94e" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">十六进制文字以关键字<code class="eh lo lp lq lr b">hex</code>为前缀，并用双引号(<code class="eh lo lp lq lr b">hex”69ed75"</code>)或单引号(<code class="eh lo lp lq lr b">hex’69ed75'</code>)括起来。</p><p id="c847" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">通过地址校验和测试的十六进制文字属于<code class="eh lo lp lq lr b">address</code>类型文字，例如:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="c1fd" class="ls jw ht lr b fv ml mm l mn mo">0xe2793a1b9a149253341cA268057a9EFA42965F83;</span><span id="b5e4" class="ls jw ht lr b fv mp mm l mn mo">0x126B3adF2556C7e8B4C3197035D0E4cbec1dBa83;</span></pre><h2 id="85e2" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">枚举</h2><p id="1f72" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">枚举允许在Solidity中创建用户定义的类型。枚举可以与所有整数类型相互转换。下面是Solidity中的一个枚举示例:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="3d38" class="ls jw ht lr b fv ml mm l mn mo">enum Action {jump, fly, ride, fight};</span></pre><h2 id="6c0b" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">功能</h2><p id="a37c" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">有两种类型的函数:内部函数和外部函数。只能从当前协定内部调用内部函数。外部函数可以通过外部函数调用来调用。</p><h2 id="f7e0" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">功能修饰符</h2><p id="052b" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">对于基于实体的函数，有各种可用的修改器，但不要求必须使用。看看这些:</p><p id="9956" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">pure</code></p><p id="7673" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">constant</code></p><p id="b587" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">view</code></p><p id="3522" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">payable</code></p><p id="bff6" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><code class="eh lo lp lq lr b">pure</code>功能不能从存储器中读取或写入；他们只是根据内容返回一个值。<code class="eh lo lp lq lr b">constant</code>修饰符函数不能以任何方式写入存储器。尽管后固化版本0.4.17 <code class="eh lo lp lq lr b">constant</code>已被弃用，以让位给<code class="eh lo lp lq lr b">pure</code>和<code class="eh lo lp lq lr b">view</code>功能，<code class="eh lo lp lq lr b">view</code>的作用与<code class="eh lo lp lq lr b">constant</code>类似，因为其功能不会以任何方式改变存储。<code class="eh lo lp lq lr b">payable</code>允许函数在被调用时接收乙醚。</p><p id="d8e3" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">一个函数中可以使用多个修饰符，方法是用空格分隔每个修饰符；它们按照书写的顺序进行评估。</p><h2 id="ce1a" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">参考类型</h2><p id="aac5" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">这些都是通过引用传递的；由于它们所构成的内存分配，这些内存非常重。</p><h2 id="9ac7" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">结构</h2><p id="c79b" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">结构是在逻辑组下声明的复合数据类型。结构用于定义新的类型。结构不可能包含自己类型的成员，尽管结构可以是映射成员的值类型。下面是一个结构示例:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="8854" class="ls jw ht lr b fv ml mm l mn mo">struct Gotham {</span><span id="e95d" class="ls jw ht lr b fv mp mm l mn mo">  address Batcave;</span><span id="891c" class="ls jw ht lr b fv mp mm l mn mo">  uint cars;</span><span id="569d" class="ls jw ht lr b fv mp mm l mn mo">  uint batcomputer;</span><span id="f1c1" class="ls jw ht lr b fv mp mm l mn mo">  uint enemies;</span><span id="0358" class="ls jw ht lr b fv mp mm l mn mo">  string gordon;</span><span id="4cdd" class="ls jw ht lr b fv mp mm l mn mo">  address twoface;</span><span id="10c7" class="ls jw ht lr b fv mp mm l mn mo">}</span></pre><h2 id="c065" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">数据单元</h2><p id="2a67" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">这指定了特定数据类型的存储位置。它与数组和结构一起工作。使用<code class="eh lo lp lq lr b">storage</code>或<code class="eh lo lp lq lr b">memory</code>关键字指定数据位置。还有第三个数据位置<code class="eh lo lp lq lr b">calldata</code>，不可修改，不可持久。外部功能的参数使用<code class="eh lo lp lq lr b">calldata</code>存储器。默认情况下，功能参数保存在<code class="eh lo lp lq lr b">memory</code>；其他局部变量利用<code class="eh lo lp lq lr b">storage</code>。</p><h2 id="f1a3" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">绘图</h2><p id="ec99" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">映射用于键到值的映射。映射可以被视为哈希表，这些哈希表被虚拟地初始化，使得每个可能的键都存在并且被映射到一个默认值。默认值为全零。密钥从不存储在映射中，只有<code class="eh lo lp lq lr b">keccak256</code>哈希用于值查找。映射的定义与任何其他变量类型一样。看看这个代码:</p><pre class="jk jl jm jn fq mh lr mi mj aw mk dt"><span id="c745" class="ls jw ht lr b fv ml mm l mn mo">contract Gotham {</span><span id="f8d0" class="ls jw ht lr b fv mp mm l mn mo">  struct Batman {</span><span id="9db3" class="ls jw ht lr b fv mp mm l mn mo">    string friends;</span><span id="97f0" class="ls jw ht lr b fv mp mm l mn mo">    string foes;</span><span id="ed4a" class="ls jw ht lr b fv mp mm l mn mo">    int funds;</span><span id="8cd2" class="ls jw ht lr b fv mp mm l mn mo">    string fox;</span><span id="6cef" class="ls jw ht lr b fv mp mm l mn mo"> }</span><span id="cd00" class="ls jw ht lr b fv mp mm l mn mo">  mapping (address =&gt; Batman) Catwoman;</span><span id="99ef" class="ls jw ht lr b fv mp mm l mn mo">  address[] public Batman_address;</span><span id="5d7b" class="ls jw ht lr b fv mp mm l mn mo">}</span></pre><p id="78ab" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated">上面的代码示例显示猫女被初始化为一个映射。</p><h2 id="8ab2" class="ls jw ht bd jx lt lu lv kb lw lx ly kf kw lz ma kh la mb mc kj le md me kl mf dt translated">单位和全局变量</h2><p id="a9b5" class="pw-post-body-paragraph kn ko ht kp b kq kr iu ks kt ku ix kv kw kx ky kz la lb lc ld le lf lg lh li hm dt translated">任何实值智能契约都可以调用全局变量。它们主要用于返回关于区块链博物馆的信息。其中一些变量也可以执行各种功能。时间单位和乙醚也是全球通用的。没有后缀的以太货币数字被认为是魏。也可以使用与时间相关的单位，就像货币一样，它们之间可以转换。</p><p id="7ad3" class="pw-post-body-paragraph kn ko ht kp b kq lj iu ks kt lk ix kv kw ll ky kz la lm lc ld le ln lg lh li hm dt translated"><em class="mr">如果你觉得这篇文章很有趣，你可以探索</em> <a class="ae mg" href="https://www.amazon.com/Blockchain-Developers-Guide-applications-technologies/dp/178995472X" rel="noopener ugc nofollow" target="_blank"> <em class="mr">区块链开发者指南</em> </a> <em class="mr">使用区块链构建真实世界的项目，如智能合约部署平台、博彩应用、钱包服务等等。</em> <a class="ae mg" href="https://www.packtpub.com/big-data-and-business-intelligence/blockchain-developers-guide" rel="noopener ugc nofollow" target="_blank"> <em class="mr">区块链开发者指南</em> </a> <em class="mr">带你穿越区块链技术的电气化世界，帮助你构建高效的去中心化应用。</em></p><blockquote class="ms"><p id="b0b9" class="mt mu ht bd mv mw mx my mz na nb li ek translated"><a class="ae mg" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nd ne nf ng nh jo fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nc"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>