<html>
<head>
<title>Protect Your Solidity Smart Contracts From Reentrancy Attacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护您的可靠性智能合同免受重入攻击</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21?source=collection_archive---------0-----------------------#2019-04-24">https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21?source=collection_archive---------0-----------------------#2019-04-24</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/5b6e31806de1c8e0e8c4d3cc1849057b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PzBBvAFM9S-DJI3HU68kbQ.jpeg"/></div></div></figure><p id="201c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在使用Solidity开发智能契约时，您需要警惕的最具破坏性的攻击之一是重入攻击。它们之所以具有破坏性，有两个原因:它们可以完全耗尽你的智能契约的以太，如果你不小心的话，它们可以潜入你的代码。</p><p id="dcfe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当您创建一个函数，在它解决任何影响之前对另一个不受信任的契约进行外部调用时，就可能发生可重入攻击。如果攻击者可以控制不受信任的协定，他们就可以递归调用原始函数，重复原本在解决影响后不会运行的交互。</p><p id="eccb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这个最简单的例子是当一个契约使用一个余额变量进行内部核算并公开一个取款函数时。如果易受攻击的合同在其将余额设置为零之前转移资金，攻击者可以重复递归调用取款函数，并耗尽整个合同。</p><p id="f5f6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看一个例子:</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="8735" class="ki kj ht ke b fv kk kl l km kn">function withdraw() external {<br/>    uint256 amount = balances[msg.sender];<br/>    require(msg.sender.call.value(amount)());<br/>    balances[msg.sender] = 0;<br/>}</span></pre><p id="fc95" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">攻击者利用这个函数所需要的只是将一些余额映射到他们的智能契约地址，并创建一个调用withdraw的后备函数。</p><p id="c12b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<code class="eh ko kp kq ke b">msg.sender.call.value(amount)()</code>转移正确数量的资金后，攻击者的回退函数再次调用<code class="eh ko kp kq ke b">withdraw</code>，在<code class="eh ko kp kq ke b">balances[msg.sender] = 0</code>可以停止进一步转移之前转移更多的资金。这种情况会持续下去，直到没有剩余的以太网，或者执行达到最大堆栈大小。</p><p id="5b2b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">通常，易受攻击的函数会使用<code class="eh ko kp kq ke b">transfer</code>、<code class="eh ko kp kq ke b">send</code>或<code class="eh ko kp kq ke b">call</code>进行外部调用。我们将在防止重入攻击一节中讨论这些函数之间的区别。</p><h1 id="94d0" class="kr kj ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">重入攻击的类型</h1><p id="4d34" class="pw-post-body-paragraph jb jc ht jd b je lo jg jh ji lp jk jl jm lq jo jp jq lr js jt ju ls jw jx jy hm dt translated">重入攻击主要有两种类型:单函数重入和跨函数重入。</p><h2 id="5487" class="ki kj ht bd ks lt lu lv kw lw lx ly la jm lz ma le jq mb mc li ju md me lm mf dt translated"><strong class="ak">单函数重入攻击</strong></h2><p id="1863" class="pw-post-body-paragraph jb jc ht jd b je lo jg jh ji lp jk jl jm lq jo jp jq lr js jt ju ls jw jx jy hm dt translated">这种类型的攻击是最简单、最容易防范的。当易受攻击的函数与攻击者试图递归调用的函数相同时，就会发生这种情况。</p><p id="6281" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们前面的代码示例是一个单函数重入攻击。</p><h2 id="b587" class="ki kj ht bd ks lt lu lv kw lw lx ly la jm lz ma le jq mb mc li ju md me lm mf dt translated"><strong class="ak">跨函数重入攻击</strong></h2><p id="98b2" class="pw-post-body-paragraph jb jc ht jd b je lo jg jh ji lp jk jl jm lq jo jp jq lr js jt ju ls jw jx jy hm dt translated">这些攻击更难检测。当易受攻击的函数与另一个对攻击者有预期效果的函数共享状态时，就可能发生跨函数可重入攻击。</p><p id="39bf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这最容易用一个例子来解释:</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="6fec" class="ki kj ht ke b fv kk kl l km kn">function transfer(address to, uint amount) external {<br/>    if (balances[msg.sender] &gt;= amount) {<br/>        balances[to] += amount;<br/>        balances[msg.sender] -= amount;<br/>    }<br/>}</span><span id="b18d" class="ki kj ht ke b fv mg kl l km kn">function withdraw() external {<br/>    uint256 amount = balances[msg.sender];<br/>    require(msg.sender.call.value(amount)());<br/>    balances[msg.sender] = 0;<br/>}</span></pre><p id="a0c8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在本例中，<code class="eh ko kp kq ke b">withdraw</code>调用攻击者的回退函数，与单函数重入攻击相同。</p><p id="63ca" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">不同之处在于回退函数调用<code class="eh ko kp kq ke b">transfer</code>而不是递归调用<code class="eh ko kp kq ke b">withdraw</code>。因为在这个调用之前余额没有被设置为0，<code class="eh ko kp kq ke b">transfer</code>函数可以转移一个已经花掉的余额。</p><h1 id="c06d" class="kr kj ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">可重入攻击能有多糟糕？</h1><p id="84f7" class="pw-post-body-paragraph jb jc ht jd b je lo jg jh ji lp jk jl jm lq jo jp jq lr js jt ju ls jw jx jy hm dt translated">问问2016年投资道的人就知道了。DAO黑客攻击是以太坊历史上最引人注目的重入攻击之一。一个攻击者设法从它身上吸走了大约360万乙醚。</p><p id="8525" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">DAO有一个易受攻击的函数，该函数意在分裂出一个子DAO。攻击者使用这个函数递归地将资金从原始DAO转移到他们控制的子DAO。</p><p id="a7e9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">黑客的破坏如此严重，以太坊基金会不得不求助于一个有争议的硬分叉来收回投资者的资金。大多数人支持hard fork，但社区的一部分人认为它违反了加密货币的核心原则——即不变性——并继续使用旧链，导致了以太坊经典的创建。</p><p id="91ab" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这里阅读更多关于DAO黑客的信息:<a class="ae mh" href="http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/" rel="noopener ugc nofollow" target="_blank">http://hacking distributed . com/2016/06/18/analysis-of-the-DAO-exploit/</a></p><h1 id="b36e" class="kr kj ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">防止重入攻击</h1><p id="daef" class="pw-post-body-paragraph jb jc ht jd b je lo jg jh ji lp jk jl jm lq jo jp jq lr js jt ju ls jw jx jy hm dt translated">您应该遵循一些最佳实践来保护您的智能契约免受重入攻击。</p><h2 id="d7b2" class="ki kj ht bd ks lt lu lv kw lw lx ly la jm lz ma le jq mb mc li ju md me lm mf dt translated">发送、转移和呼叫</h2><p id="9009" class="pw-post-body-paragraph jb jc ht jd b je lo jg jh ji lp jk jl jm lq jo jp jq lr js jt ju ls jw jx jy hm dt translated">因为大多数重入攻击涉及<code class="eh ko kp kq ke b">send</code>、<code class="eh ko kp kq ke b">transfer</code>或<code class="eh ko kp kq ke b">call</code>函数，所以理解它们之间的区别很重要。</p><p id="4095" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh ko kp kq ke b">send</code>和<code class="eh ko kp kq ke b">transfer</code>功能被认为更安全，因为它们被限制在2,300 gas。gas限制防止了昂贵的外部函数回调目标协定。一个陷阱是当合同使用<code class="eh ko kp kq ke b">msg.sender.call(ethAmount).gas(gasAmount)</code>为发送或转移设置自定义的气体量时。</p><p id="3d77" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">不幸的是,<code class="eh ko kp kq ke b">call</code>函数更容易受到攻击。</p><p id="6dc0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当外部函数调用预计执行复杂操作时，您通常希望使用<code class="eh ko kp kq ke b">call</code>函数，因为它会转发所有剩余气体。这为攻击者在单个函数重入攻击中调用原始函数，或者在跨函数重入攻击中调用不同于原始契约的函数打开了方便之门。</p><p id="6f4d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">尽可能使用<code class="eh ko kp kq ke b">send</code>或<code class="eh ko kp kq ke b">transfer</code>代替<code class="eh ko kp kq ke b">call</code>来限制您的安全风险。</p><h2 id="bf10" class="ki kj ht bd ks lt lu lv kw lw lx ly la jm lz ma le jq mb mc li ju md me lm mf dt translated"><strong class="ak">标记不可信函数</strong></h2><p id="10de" class="pw-post-body-paragraph jb jc ht jd b je lo jg jh ji lp jk jl jm lq jo jp jq lr js jt ju ls jw jx jy hm dt translated">为了防止重入攻击，识别函数何时不受信任是很重要的。Consensys最佳实践建议您命名函数和变量，以表明它们是否不受信任。</p><p id="952b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如:</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="398f" class="ki kj ht ke b fv kk kl l km kn">function untrustedWithdraw() public {<br/>    uint256 amount = balances[msg.sender];<br/>    require(msg.sender.call.value(amount)());<br/>    balances[msg.sender] = 0;<br/>}</span></pre><p id="a089" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">重要的是要记住，如果一个函数调用另一个不可信的函数，它也是不可信的。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="a05b" class="ki kj ht ke b fv kk kl l km kn">function untrustedSettleBalance() external {<br/>    untrustedWithdraw();<br/>}</span></pre><h2 id="97b7" class="ki kj ht bd ks lt lu lv kw lw lx ly la jm lz ma le jq mb mc li ju md me lm mf dt translated"><strong class="ak">检查-效果-交互</strong> <strong class="ak">模式</strong></h2><p id="98ed" class="pw-post-body-paragraph jb jc ht jd b je lo jg jh ji lp jk jl jm lq jo jp jq lr js jt ju ls jw jx jy hm dt translated">防止重入攻击的最可靠的方法是使用checks-effects-interactions模式。</p><p id="bea2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这种模式定义了构建函数的顺序。</p><p id="7f7c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先在函数开始时执行任何检查，通常是<code class="eh ko kp kq ke b">assert</code>和<code class="eh ko kp kq ke b">require</code>语句。</p><p id="d16e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果检查通过，那么该函数应该解决对契约状态的所有影响。</p><p id="1cf2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">只有在解决了所有状态更改之后，该函数才应该与其他契约进行交互。通过最后调用外部函数，即使攻击者对原始函数进行递归调用，他们也无法滥用契约状态。</p><p id="04a9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们使用checks-effects-interactions模式重写易受攻击的取款函数。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="b304" class="ki kj ht ke b fv kk kl l km kn">function withdraw() external {<br/>    uint256 amount = balances[msg.sender];<br/>    balances[msg.sender] = 0;<br/>    require(msg.sender.call.value(amount)());<br/>}</span></pre><p id="1014" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因为我们在进行外部调用之前将余额(一种效果)清零，所以攻击者进行的递归调用不会被欺骗而认为还有余额。</p><h2 id="544c" class="ki kj ht bd ks lt lu lv kw lw lx ly la jm lz ma le jq mb mc li ju md me lm mf dt translated"><strong class="ak">互斥</strong></h2><p id="2625" class="pw-post-body-paragraph jb jc ht jd b je lo jg jh ji lp jk jl jm lq jo jp jq lr js jt ju ls jw jx jy hm dt translated">在更复杂的情况下，比如防止跨函数重入攻击，可能有必要使用互斥。</p><p id="3ae9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">互斥锁锁定契约状态。只有锁的所有者可以修改状态。</p><p id="cc62" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看一个简单的互斥实现。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="3430" class="ki kj ht ke b fv kk kl l km kn">function transfer(address to, uint amount) external {<br/>    require(!lock);<br/>    lock = true;</span><span id="3bb2" class="ki kj ht ke b fv mg kl l km kn">    if (balances[msg.sender] &gt;= amount) {<br/>        balances[to] += amount;<br/>        balances[msg.sender] -= amount;<br/>    }</span><span id="eec9" class="ki kj ht ke b fv mg kl l km kn">    lock = false;<br/>}</span><span id="fa7e" class="ki kj ht ke b fv mg kl l km kn">function withdraw() external {<br/>    require(!lock);<br/>    lock = true;</span><span id="0f8d" class="ki kj ht ke b fv mg kl l km kn">    uint256 amount = balances[msg.sender];<br/>    require(msg.sender.call.value(amount)());<br/>    balances[msg.sender] = 0;</span><span id="7e6f" class="ki kj ht ke b fv mg kl l km kn">    lock = false;<br/>}</span></pre><p id="3b27" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">通过使用这个锁，攻击者不能再通过递归调用来利用<code class="eh ko kp kq ke b">withdraw</code>函数。攻击者也不能利用对<code class="eh ko kp kq ke b">transfer</code>的调用进行跨函数重入攻击。当<code class="eh ko kp kq ke b">lock</code>为<code class="eh ko kp kq ke b">true</code>时，所有状态修改发生，防止任何检查锁的功能被无序调用。</p><p id="6940" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您必须小心实现互斥体，以确保总是有释放锁的方法。如果攻击者可以锁定您的合同并阻止它的发布，您的合同就会失效。</p><p id="3d25" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">OpenZeppelin有自己的互斥实现，您可以使用它，名为<code class="eh ko kp kq ke b">ReentrancyGuard</code>。这个库提供了一个修饰符，你可以把它应用到任何一个叫做<code class="eh ko kp kq ke b">nonReentrant</code>的函数上，这个函数用一个互斥体来保护这个函数。</p><p id="f8fb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这里查看OpenZeppelin <code class="eh ko kp kq ke b">ReentrancyGuard</code>库的源代码:<a class="ae mh" href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/utils/ReentrancyGuard.sol" rel="noopener ugc nofollow" target="_blank">https://github . com/open zeppelin/open zeppelin-solidity/blob/master/contracts/utils/reentrancy guard . sol</a></p><p id="3b16" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请记住，<code class="eh ko kp kq ke b">nonReentrant</code>函数应该是外部的。如果另一个函数调用<code class="eh ko kp kq ke b">nonReentrant</code>函数，它将不再受保护。</p><h1 id="e747" class="kr kj ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">可重入攻击的未来</h1><p id="7570" class="pw-post-body-paragraph jb jc ht jd b je lo jg jh ji lp jk jl jm lq jo jp jq lr js jt ju ls jw jx jy hm dt translated">未来的更新总是有引入更多攻击机会的风险。君士坦丁堡的更新被推迟了，因为在EIP 1283中发现了一个缺陷，该缺陷使用某些T3操作引入了一种新的重入攻击。如果将此更新部署到mainnet，甚至发送和传输功能也会受到攻击。</p><p id="01c3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">攻击将变得越来越高级，并涉及功能和契约之间更复杂的交互来影响状态。为了保持领先地位，我们能做的最好的事情就是保持交互尽可能简单，并采用最佳实践，例如使用transfer或send而不是call，并使用checks-effects-interactions模式来构建我们的功能。</p><blockquote class="mi"><p id="0c2f" class="mj mk ht bd ml mm mn mo mp mq mr jy ek translated">加入Coinmonks <a class="ae mh" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae mh" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae mh" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="ki kj ht bd ks lt ms lv kw lw mt ly la jm mu ma le jq mv mc li ju mw me lm mf dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="mx my ht jd b je lo ji lp jm mz jq na ju nb jy nc nd ne nf dt translated"><a class="ae mh" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae mh" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated"><a class="ae mh" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae mh" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="f33b" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated"><a class="ae mh" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae mh" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated">开发人员的最佳加密API</li><li id="f1dd" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated"><a class="ae mh" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae mh" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="b359" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated">最佳<a class="ae mh" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated">杠杆代币的终极指南</li><li id="95d1" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated"><a class="ae mh" href="https://coincodecap.com/best-vpns-for-crypto-trading" rel="noopener ugc nofollow" target="_blank">加密交易的最佳VPNs】</a></li><li id="918f" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated"><a class="ae mh" href="https://coincodecap.com/huobi-crypto-trading-signals" rel="noopener ugc nofollow" target="_blank">火币加密交易信号</a> | <a class="ae mh" rel="noopener" href="/coinmonks/hitbtc-review-c5143c5d53c2"> HitBTC审核</a></li><li id="58f1" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated"><a class="ae mh" href="https://coincodecap.com/traderwagon-review" rel="noopener ugc nofollow" target="_blank"> TraderWagon回顾</a> | <a class="ae mh" href="https://coincodecap.com/kraken-vs-gemini-vs-bityard" rel="noopener ugc nofollow" target="_blank">北海巨妖vs双子vs比特亚德</a></li><li id="ad10" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated"><a class="ae mh" href="https://coincodecap.com/ftx-futures-trading" rel="noopener ugc nofollow" target="_blank">如何在FTX交易所交易期货</a></li><li id="71f4" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated"><a class="ae mh" href="https://coincodecap.com/okex-kucoin" rel="noopener ugc nofollow" target="_blank"> OKEx vs KuCoin </a> | <a class="ae mh" href="https://coincodecap.com/celsius-alternatives" rel="noopener ugc nofollow" target="_blank">摄氏替代品</a> | <a class="ae mh" href="https://coincodecap.com/buy-vechain" rel="noopener ugc nofollow" target="_blank">如何购买VeChain </a></li><li id="e6a8" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated"><a class="ae mh" href="https://coincodecap.com/3commas-vs-pionex-vs-cryptohopper" rel="noopener ugc nofollow" target="_blank">3 commas vs . Pionex vs . crypto hopper</a></li><li id="0539" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated"><a class="ae mh" href="https://coincodecap.com/cornix-trading-bot" rel="noopener ugc nofollow" target="_blank">如何使用Cornix交易机器人</a></li><li id="7ed0" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated"><a class="ae mh" href="https://coincodecap.com/bitget-review" rel="noopener ugc nofollow" target="_blank"> Bitget回顾</a>|<a class="ae mh" href="https://coincodecap.com/gemini-vs-blockfi" rel="noopener ugc nofollow" target="_blank">Gemini vs block fi</a>cmd |<a class="ae mh" href="https://coincodecap.com/okex-futures-trading" rel="noopener ugc nofollow" target="_blank">OKEx期货交易</a></li><li id="60b3" class="mx my ht jd b je ng ji nh jm ni jq nj ju nk jy nc nd ne nf dt translated"><a class="ae mh" href="https://coincodecap.com/buy-crypto-with-credit-card" rel="noopener ugc nofollow" target="_blank">用信用卡购买密码的10个最佳地点</a></li></ul></div></div>    
</body>
</html>