<html>
<head>
<title>Solidity v0.6.0 is here! Things you should know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity v0.6.0来了！你应该知道的事情</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-v0-6-0-is-here-things-you-should-know-7d4ab5bca5f1?source=collection_archive---------1-----------------------#2019-12-18">https://medium.com/coinmonks/solidity-v0-6-0-is-here-things-you-should-know-7d4ab5bca5f1?source=collection_archive---------1-----------------------#2019-12-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="c9a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Solidity已经发布了Solidity编译器和语言的主要突破性版本，即v0.6.0。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/e05d74ec86154379e03f25a77a0c7c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dExIkxZhJAp0YSfwUx_Zqw.png"/></div></div></figure><p id="ffa8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">作为智能合约开发者和区块链爱好者，人们应该了解它们，因为它将改变我们开发智能合约的方式。这些变化基本上是受现有语言的启发而引入的，目的是让事情变得更清晰，对开发人员更友好。我在这里列举了一些例子:</p><h1 id="5fab" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">遗产</h1><p id="88f2" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated"><strong class="is hu">虚拟&amp;覆盖关键字</strong></p><p id="1604" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">可以通过将基本函数标记为“虚拟”来覆盖它们。覆盖函数必须在函数头中使用“override”关键字。对于多重继承，您必须指定定义相同功能且尚未被另一个基础协定覆盖的所有基础协定。</p><pre class="jp jq jr js fq ld le lf lg aw lh dt"><span id="e671" class="li kb ht le b fv lj lk l ll lm"><strong class="le hu">pragma solidity</strong> &gt;=0.5.0 &lt;0.7.0;<br/><br/><strong class="le hu">contract</strong> Base1<br/>{<br/>    <strong class="le hu">function</strong> foo() virtual <strong class="le hu">public</strong> {}<br/>}<br/><br/><strong class="le hu">contract</strong> Base2<br/>{<br/>    <strong class="le hu">function</strong> foo() virtual <strong class="le hu">public</strong> {}<br/>}<br/><br/><strong class="le hu">contract</strong> Inherited <strong class="le hu">is</strong> Base1, Base2<br/>{<br/>    <em class="ln">// Derives from multiple bases defining foo(), so we must explicitly</em><br/>    <em class="ln">// override it</em><br/>    <strong class="le hu">function</strong> foo() <strong class="le hu">public</strong> override(Base1, Base2) {}<br/>}</span></pre><p id="2a0e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">抽象合同</strong></p><p id="a6a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当合同中至少有一项功能没有实现时，需要将合同标记为"抽象的"。如果协定从抽象协定继承，并且没有通过重写实现所有未实现的功能，则也需要将其标记为抽象。即使实现了所有的功能，契约也可能被标记为抽象的。</p><pre class="jp jq jr js fq ld le lf lg aw lh dt"><span id="d082" class="li kb ht le b fv lj lk l ll lm"><strong class="le hu">pragma solidity</strong> ^0.6.0;</span><span id="0236" class="li kb ht le b fv lo lk l ll lm"><strong class="le hu">abstract</strong> <strong class="le hu">contract</strong> Feline {</span><span id="1d3d" class="li kb ht le b fv lo lk l ll lm"><strong class="le hu">function</strong> utterance() <strong class="le hu">public</strong> virtual <strong class="le hu">returns</strong> (bytes32);</span><span id="9cb7" class="li kb ht le b fv lo lk l ll lm">}</span><span id="53bb" class="li kb ht le b fv lo lk l ll lm"><strong class="le hu">contract</strong> Cat <strong class="le hu">is</strong> Feline {</span><span id="ba38" class="li kb ht le b fv lo lk l ll lm"><strong class="le hu">function</strong> utterance() <strong class="le hu">public</strong> override <strong class="le hu">returns</strong> (bytes32) { <br/>   <strong class="le hu">return</strong> "miaow"; <br/>}</span><span id="aca2" class="li kb ht le b fv lo lk l ll lm">}</span></pre><h1 id="669b" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">排列</h1><p id="78fb" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated"><strong class="is hu">。长度构件</strong></p><p id="bb1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对阵列长度的成员访问现在始终是只读的，即使对于存储阵列也是如此。不再可能通过为存储阵列的长度指定新值来调整其大小。</p><pre class="jp jq jr js fq ld le lf lg aw lh dt"><span id="815e" class="li kb ht le b fv lj lk l ll lm">Array.length = 5 // Incorrect<br/>Array.length++ // Incorrect</span><span id="8f6a" class="li kb ht le b fv lo lk l ll lm">array.push() // Correct<br/>array.push(value) // Correct</span></pre><p id="b4e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">数组切片</strong></p><p id="ce62" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">阵列切片是阵列连续部分的视图。它们被写成“x[start:end]”,其中start和end是产生uint256类型(或可隐式转换为uint 256类型)的表达式。切片的第一个元素是x[start]，最后一个元素是x[end - 1]。</p><p id="e3d7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果start大于end，或者end大于数组的长度，则会引发异常。</p><p id="7cbb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">start和end都是可选的:start默认为0，end默认为数组的长度。</p><p id="0102" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="ln">到目前为止，数组切片只针对calldata数组实现。</em></p><pre class="jp jq jr js fq ld le lf lg aw lh dt"><span id="2952" class="li kb ht le b fv lj lk l ll lm"><em class="ln">/// Forward call to "setOwner(address)" that is implemented by client</em><br/>    <em class="ln">/// after doing basic validation on the address argument.</em><br/>    <strong class="le hu">function</strong> forward(bytes calldata _payload) <strong class="le hu">external</strong> {<br/>        bytes4 sig = abi.decode(_payload[:4], (bytes4));<br/>        <strong class="le hu">if</strong> (sig == bytes4(keccak256("setOwner(address)"))) {<br/>            address owner = abi.decode(_payload[4:], (address));<br/>            require(owner != address(0), "Address of owner cannot be zero.");<br/>        }<br/>        (bool status,) = client.delegatecall(_payload);<br/>        require(status, "Forwarded call failed.");<br/>    }</span></pre><h1 id="927d" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">撤退</h1><p id="7f09" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">传统分为使用fallback关键字定义的新fallback函数和使用receive关键字定义的receive ether函数。这两个函数不能有参数，不能返回任何内容，并且必须具有外部可见性</p><p id="bf02" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">接收乙醚功能</strong></p><p id="5b67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它在普通以太网传输上执行(例如通过。发送()或。transfer())。如果不存在这样的函数，但是存在应付回退函数，则回退函数将在普通以太网传输中被调用。如果receive Ether和payable fallback函数都不存在，则协定无法通过常规事务接收Ether并引发异常。</p><p id="8971" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">回退功能</strong></p><p id="03eb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果没有其他函数与给定的函数签名匹配，或者如果根本没有提供数据，并且没有receive Ether函数，则在调用协定时执行该函数。回退函数总是接收数据，但是为了也接收数据，它必须被标记为payable。</p><pre class="jp jq jr js fq ld le lf lg aw lh dt"><span id="8ef8" class="li kb ht le b fv lj lk l ll lm"><strong class="le hu">pragma solidity</strong> ^0.6.0;<br/><br/><strong class="le hu">contract</strong> Test {<br/>    <em class="ln">// This function is called for all messages sent to</em><br/>    <em class="ln">// this contract (there is no other function).</em><br/>    <em class="ln">// Sending Ether to this contract will cause an exception,</em><br/>    <em class="ln">// because the fallback function does not have the `payable`</em><br/>    <em class="ln">// modifier.</em><br/>    fallback() <strong class="le hu">external</strong> { x = 1; }<br/>    uint x;<br/>}<br/><br/><strong class="le hu">contract</strong> TestPayable {<br/>    <em class="ln">// This function is called for all messages sent to</em><br/>    <em class="ln">// this contract, except plain Ether transfers</em><br/>    <em class="ln">// (there is no other function except the receive function).</em><br/>    <em class="ln">// Any call with non-empty calldata to this contract will execute</em><br/>    <em class="ln">// the fallback function (even if Ether is sent along with the call).</em><br/>    fallback() <strong class="le hu">external</strong> <strong class="le hu">payable</strong> { x = 1; y = msg.value; }<br/><br/>    <em class="ln">// This function is called for plain Ether transfers, i.e.</em><br/>    <em class="ln">// for every call with empty calldata.</em><br/>    receive() <strong class="le hu">external</strong> <strong class="le hu">payable</strong> { x = 2; y = msg.value; }<br/>    uint x;<br/>    uint y;<br/>}</span></pre><h1 id="db94" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">异常处理</h1><p id="9546" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated"><strong class="is hu">试/抓</strong></p><p id="e27c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Solidity现在支持try/catch-statement形式的异常处理，但只支持外部函数调用和契约创建调用。表达式内部的错误不会被捕获，只会在外部调用本身内部发生恢复。目前对该特性的支持非常有限且有条件。更多详情，见<a class="ae lp" href="https://solidity.readthedocs.io/en/latest/control-structures.html#try-catch" rel="noopener ugc nofollow" target="_blank">本文档</a>。</p><pre class="jp jq jr js fq ld le lf lg aw lh dt"><span id="d94f" class="li kb ht le b fv lj lk l ll lm"><strong class="le hu">pragma solidity</strong> ^0.6.0;<br/><br/><strong class="le hu">interface</strong> DataFeed { <strong class="le hu">function</strong> getData(address token) <strong class="le hu">external</strong> <strong class="le hu">returns</strong> (uint value); }<br/><br/><strong class="le hu">contract</strong> FeedConsumer {<br/>    DataFeed feed;<br/>    uint errorCount;<br/>    <strong class="le hu">function</strong> rate(address token) <strong class="le hu">public</strong> <strong class="le hu">returns</strong> (uint value, bool success) {<br/>        <em class="ln">// Permanently disable the mechanism if there are</em><br/>        <em class="ln">// more than 10 errors.</em><br/>        require(errorCount &lt; 10);<br/>        try feed.getData(token) <strong class="le hu">returns</strong> (uint v) {<br/>            <strong class="le hu">return</strong> (v, <strong class="le hu">true</strong>);<br/>        } catch Error(string <strong class="le hu">memory</strong> <em class="ln">/*reason*/</em>) {<br/>            <em class="ln">// This is executed in case</em><br/>            <em class="ln">// revert was called inside getData</em><br/>            <em class="ln">// and a reason string was provided.</em><br/>            errorCount++;<br/>            <strong class="le hu">return</strong> (0, <strong class="le hu">false</strong>);<br/>        } catch (bytes <strong class="le hu">memory</strong> <em class="ln">/*lowLevelData*/</em>) {<br/>            <em class="ln">// This is executed in case revert() was used</em><br/>            <em class="ln">// or there was a failing assertion, division</em><br/>            <em class="ln">// by zero, etc. inside getData.</em><br/>            errorCount++;<br/>            <strong class="le hu">return</strong> (0, <strong class="le hu">false</strong>);<br/>        }<br/>    }<br/>}</span></pre><h1 id="acbf" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">文件级声明</h1><p id="055b" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">“struct”和“enum”类型现在可以在文件级声明。</p><pre class="jp jq jr js fq ld le lf lg aw lh dt"><span id="458a" class="li kb ht le b fv lj lk l ll lm">pragma solidity ^0.6.0;</span><span id="089d" class="li kb ht le b fv lo lk l ll lm">enum Status {Added, Removed}</span><span id="a927" class="li kb ht le b fv lo lk l ll lm">struct Employee {<br/>    uint256 id;<br/>    string name;<br/>    Status s;<br/>}</span><span id="ee3f" class="li kb ht le b fv lo lk l ll lm">contract NameRegister {<br/>    mapping(uint256 =&gt; Employee) public nameReg;<br/>    <br/>    function add(uint256 id, string memory name) public {<br/>        nameReg[id] = Employee(id, name, Status.Added);<br/>    }<br/>}</span><span id="124c" class="li kb ht le b fv lo lk l ll lm">contract SalaryRegister {<br/>    mapping(uint256 =&gt; Employee) public salaryReg;<br/>    <br/>    function add(uint256 id, string memory name) public {<br/>        salaryReg[id] = Employee(id, name, Status.Added);<br/>    }<br/>}</span></pre><p id="078a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">参考文献:</strong></p><p id="af67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">完整的变更日志:<a class="ae lp" href="https://github.com/ethereum/solidity/releases/tag/v0.6.0" rel="noopener ugc nofollow" target="_blank">https://github.com/ethereum/solidity/releases/tag/v0.6.0</a></p><p id="977f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于所有重大变更的文档:<a class="ae lp" href="https://solidity.readthedocs.io/en/latest/060-breaking-changes.html" rel="noopener ugc nofollow" target="_blank">https://solidity . readthedocs . io/en/latest/060-breaking-changes . html</a></p><blockquote class="lq"><p id="dbf7" class="lr ls ht bd lt lu lv lw lx ly lz jn ek translated"><a class="ae lp" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mb mc md me mf jt fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ma"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="jp jq jr js fq jt fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff mg"><img src="../Images/a06b758bdcc47dca7c2504f298674d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_s6JsD3P0hVj32E7t9EtGg.jpeg"/></div></a></figure></div></div>    
</body>
</html>