<html>
<head>
<title>Merkle Trees in 3 Minutes or Less</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Merkle Trees在3分钟或更短时间内完成</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/merkle-made-palatable-94e6662f4caf?source=collection_archive---------2-----------------------#2018-04-18">https://medium.com/coinmonks/merkle-made-palatable-94e6662f4caf?source=collection_archive---------2-----------------------#2018-04-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="49ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因为区块链仍然是一个新兴的生态系统，仍然有许多事情阻碍它的广泛采用。在这些因素中，有一个是对组成这些项目的核心技术概念的固有理解。与对加密货币和/或区块链技术持怀疑态度的人进行至少一次对话几乎是一种通行权利，但当被追问时，他们会因为不知情的论点崩溃而承认。因此，我的目标是简化一些更复杂的术语和概念。通过这种方式，它们可以成为日常话语的一部分，我们可以开始清除围绕这项新技术的一些污名。</p><p id="ae01" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好的，让我们从默克尔树开始。</p><p id="afb9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Merkle树是用于以有效的方式验证大量数据的结构。他们不仅能够验证从对等网络(如比特币或以太坊)中的其他对等方接收的数据未被更改，还能够验证发送的数据块是合法的。然而，Merkle根可以理解为包含在单个块中的所有事务的签名。例如，在比特币中，Merkle根可以在块头中找到(连同前一个块的散列、时间戳和随机数)。Merkle根是如何确定的，它的目的是什么，以及它与Merkle树的关系是什么，这些都是我希望阐明的基本问题。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/fb1ae74f2043927672d88d0575c1f786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8EAtYhktHxIn8FKcvdSixw.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Figure 1: Bitcoin Block Header Simplified</figcaption></figure><p id="f05b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了理解Merkle树是如何工作的，首先要理解什么是加密哈希函数(CFH)。</p><p id="acf2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从广义上讲，哈希函数接受某个输入，并返回一个输出(哈希)，通常是字母数字字符串的形式。</p><p id="55f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里有一个CFH的五个基本要素的快速总结(这里不会深入讨论):</p><p id="2ab5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">1)散列必须容易(通过计算)从函数中获得</p><p id="3f39" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2)从散列向后工作以获得原始输入在计算上必须是不可行的</p><p id="ad71" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3)它必须是确定性的—相同的输入必须给出相同的散列</p><p id="2ccf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">4)输入中的微小变化会产生完全不同的散列(参见图2)</p><p id="15c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">5)并且找到产生相同散列的两个消息也必须是不可行的</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff ke"><img src="../Images/8b76b5f014f35ab89039fe5a4e7b1ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BnDDUPgU8pzpTtCLUtoqlA.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Figure 2: Cryptographic Hash Function</figcaption></figure><p id="4693" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在你对CHF有了一个了解，Merkle树的复杂性变得更容易理解了。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff kf"><img src="../Images/d2862e8a9d4b05412a8b53ace58eb8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QrjOvNjk9MzU9-cOjGp2vQ.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Figure 3: The Merkle Tree and Merkle Root</figcaption></figure><p id="944c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">创建Merkle树的第一步是获取块中包含的事务，并通过CHF获取它们的散列。在此之后，所有这些事务散列被彼此配对并再次散列。这个过程不断发生，直到只剩下一个散列:这就是Merkle根。通过成对散列，Merkle树有效地使事务防篡改，因为对先前事务的任何改变将沿着树向上传播，沿途改变每个散列，这将不可避免地改变Merkle根(参见CHF的支柱4)。为了验证一个交易，你所要做的就是跟踪它在树上的分支。</p><p id="4b9d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我希望您现在能够理解加密哈希函数的基础，它与Merkle树和Merkel根的关系，以及它们与区块链技术的整体联系。</p><p id="b4b7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">哦，希望你喜欢这个快速总结(和非常明显的企图拖延任何和所有期末考试的努力)。</p><p id="bd53" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">更多即将到来。</p></div></div>    
</body>
</html>