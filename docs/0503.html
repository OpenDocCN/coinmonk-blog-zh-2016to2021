<html>
<head>
<title>BatchNoOverflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BatchNoOverflow</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/batchnooverflow-670f9ae06f54?source=collection_archive---------7-----------------------#2018-05-13">https://medium.com/coinmonks/batchnooverflow-670f9ae06f54?source=collection_archive---------7-----------------------#2018-05-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/d4403f874c28e60e65964285aa135978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjiRXMttbNwiXQ1H0x0kYQ.png"/></div></div></figure><p id="1fef" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">2018年4月22日，<a class="jz ka gr" href="https://medium.com/u/76bcf8c698ec?source=post_page-----670f9ae06f54--------------------------------" rel="noopener" target="_blank"> PeckShield </a>的团队在<strong class="jd hu"> BEC </strong>令牌合约中发现了一个bug。这个漏洞允许零余额的攻击者向他们想要的任何人支付大量的钱。这将完全稀释任何代币的价值，当你意识到你心爱的代币一文不值的时候，哈克曼早就走了。</p><h2 id="0a31" class="kb kc ht bd kd ke kf kg kh ki kj kk kl jm km kn ko jq kp kq kr ju ks kt ku kv dt translated">充满</h2><p id="8de3" class="pw-post-body-paragraph jb jc ht jd b je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt ju la jw jx jy hm dt translated">在编程中，数字不可能变得无限大，在某一点上，如果你继续增加一个数字，它将溢出并“重置”为零。在这个合同的例子中，这个神奇的数字是1.1579209e+77，这是一个很大的数字。从加密的角度来看，只会有2.1e+7个比特币。</p><p id="3215" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果程序员不小心，这可能会被利用，因此，即使是以太坊网站上最简单的令牌示例也会添加溢出检查。让我们看一下有问题的合同。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lb"><img src="../Images/271a100118e1374e8a472ae5432485ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFaUiFWDx61-5mvHYGhgXg.png"/></div></div></figure><p id="1275" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">攻击者会调用这个函数，并向它提供一个地址列表(<strong class="jd hu"><em class="lg">_接收者</em> </strong>)和支付给每个接收者的金额(<strong class="jd hu"><em class="lg">_值</em> </strong>)。<strong class="jd hu"> <em class="lg"> _value </em> </strong>然而要唤醒BatchOverflow bug必须满足一个标准，如果乘以提供的<strong class="jd hu"> <em class="lg"> _receivers </em> </strong>的数量，就必须等于我前面提到的那个幻数。</p><p id="fa5d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果<strong class="jd hu"> <em class="lg"> _value </em> </strong>满足上述要求，则从发送方余额中减去的<strong class="jd hu"> <em class="lg">总金额</em> </strong>为零。这将允许攻击者在<em class="lg">线12 </em>处通过大门，这是为了确保您的余额能够支付账单。所有这一切的结果是，攻击者创建了大量的令牌，并将这些令牌存入一个帐户(可能是他们自己的帐户)。</p><h2 id="57a5" class="kb kc ht bd kd ke kf kg kh ki kj kk kl jm km kn ko jq kp kq kr ju ks kt ku kv dt translated">修复</h2><p id="6422" class="pw-post-body-paragraph jb jc ht jd b je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt ju la jw jx jy hm dt translated">通常人们会使用像Zeppelin这样的公司构建的库和样板文件，它们经过了彻底的测试，以确保这样的事情不会成为你合同中的一个问题。然而，这个bug可以通过一个非常简单的代码修复来解决。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lh"><img src="../Images/9ab383b739827ecf503922074ec0c8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zGLXRsVXD4n5TexwnE36nw.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">almost there</figcaption></figure><p id="794f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一个可能的解决方法是添加另一个测试来检查发送者在减去<strong class="jd hu"> <em class="lg">金额</em> </strong>后的余额是否小于他的当前余额。如果发生溢出，余额将是相同的，使其成为无效交易。然而，这仍然不能解决问题。如果攻击者有一个小的余额，比方说10个<em class="lg">什么的，</em>攻击者可以设计<strong class="jd hu"> <em class="lg"> _value </em> </strong>溢出到比他们当前持有的余额小的某个数量，从而通过这个门。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/7c5b223d6fa5ea2bd41949059d7ee353.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*m7PRPEyhddcE_fIHI5KpiQ.png"/></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">maybe better</figcaption></figure><p id="2a4c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">也许更好的解决办法是简单地检查将要转移的总额<strong class="jd hu"> <em class="lg">是否大于或等于<strong class="jd hu"> <em class="lg"> _value </em> </strong>。如果发生溢出，该测试将不会通过。对于攻击者来说，要通过这个门，他们至少需要这个神奇数字的20分之一，这仍然是一个非常大的数字，如果不利用另一个漏洞，很可能无法获得。</em></strong></p><h2 id="c208" class="kb kc ht bd kd ke kf kg kh ki kj kk kl jm km kn ko jq kp kq kr ju ks kt ku kv dt translated">结论</h2><p id="1f00" class="pw-post-body-paragraph jb jc ht jd b je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt ju la jw jx jy hm dt translated">在构建智能合同时，利用可用的工具。像整数溢出这样的简单错误可能会破坏您的项目。</p></div><div class="ab cl ln lo hb lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hm hn ho hp hq"><p id="0903" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">来玩这个简单的例子看看这个简单的例子<a class="ae lu" href="https://github.com/phzietsman/batchOverflow" rel="noopener ugc nofollow" target="_blank">https://github.com/phzietsman/batchOverflow</a></p></div></div>    
</body>
</html>