<html>
<head>
<title>Solidity: who the heck is msg.sender?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谁是msg.sender？</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-who-the-heck-is-msg-sender-de68d3e98454?source=collection_archive---------0-----------------------#2021-03-15">https://medium.com/coinmonks/solidity-who-the-heck-is-msg-sender-de68d3e98454?source=collection_archive---------0-----------------------#2021-03-15</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="9514" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里我们将简要讨论<code class="eh jo jp jq jr b">msg.sender</code>机制是如何工作的。像往常一样，我们将试验一些你可以在浏览器中运行的小块Solidity</p><figure class="jt ju jv jw fq jx fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff js"><img src="../Images/c04a625ab7cf6d16a894701d3749ec5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lqrFZ5_mSnuwP4ef"/></div></div></figure><p id="1dd6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">区块链的核心是向块链添加事务块的机制:这是由矿工执行的保持以太坊虚拟机(EVM)状态一致的工作；矿工们竞相向区块追加交易。</p><p id="1d70" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">EVM的状态是块中收集的所有交易的执行效果:在某种程度上，以太坊(以及一般的区块链)是一个<em class="ke">分布式日志文件</em>，它收集智能合约执行的操作的结果。另一种方法是将区块链视为一个全球共享的事务数据库。</p><p id="299b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">智能契约上的操作是由一个简单的机制触发的，该机制将gas发送到一个地址，如果该地址是一个智能契约，它将产生一个方法调用，该方法的名称在事务有效负载中被散列。下面是如何使用参数1调用智能契约上的方法<code class="eh jo jp jq jr b">store(uint256)</code>的示例:</p><figure class="jt ju jv jw fq jx fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff kg"><img src="../Images/47387dba0c35d7f439d0b6ce9c2f1fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWggUKJ9vnmV138XvNGmHQ.png"/></div></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">The method store(uint256) and its invocation with parameter 1, notice the input and decoded input</figcaption></figure><p id="5a01" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在包含方法调用的事务中，真正发生的是方法签名，<code class="eh jo jp jq jr b">store(uint256)</code>用<a class="ae kf" href="https://en.wikipedia.org/wiki/SHA-3" rel="noopener ugc nofollow" target="_blank"> keccak256 </a>散列，前4个字节与参数打包在一起；这个字节序列是上面事务中输入字段的内容。更复杂的参数(如字符串、数组等..)以一种合理的方式打包，方法是将它们序列化并与函数hash连接在一起。</p><p id="dd45" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">深入的分析可以在<a class="ae kf" rel="noopener" href="/linum-labs/a-technical-primer-on-using-encoded-function-calls-50e2b9939223">这里</a>找到，但是，为了本文的清晰起见，这种打包的意义是有一个函数名和所有参数的紧凑表示，这是你在<a class="ae kf" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a>中的事务的输入字段中找到的，你也可以在检查器中找到它的解码。</p><h1 id="be36" class="kl km ht bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">交易的发送方</h1><p id="af43" class="pw-post-body-paragraph iq ir ht is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hm dt translated">在每个交易的字段中，在Remix中，您可能会注意到交易的原始帐户来自哪个字段。在Remix中，很容易注意到这个字段的内容与左边的字段Account完全匹配(见下图)</p><figure class="jt ju jv jw fq jx fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff lo"><img src="../Images/522a14be789148499d61dc2c22ed9104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dLSiwrgoxrwAYx8B9AhxjQ.png"/></div></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">As you may expect the account on the left matches the field from in the transaction receipt</figcaption></figure><p id="3ff1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这种机制非常简单，但是在以太坊规范中，有两种不同的功能可供交易发送者访问:<code class="eh jo jp jq jr b">msg.sender</code>和<code class="eh jo jp jq jr b">tx.origin</code>。几个简单的函数允许您检查两个函数是否返回完全相同的值。</p><figure class="jt ju jv jw fq jx fe ff paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="fe ff lp"><img src="../Images/66dc8b1a985819ffa59c354ea56b0d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAoF62Y4KWPs4OfxAUyQaQ.png"/></div></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">inspectOrigin and inspectSender return the same value: the account used to call them</figcaption></figure><p id="adf7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">他们是多余的吗？完全不是，有区别，可以在小节中强调。</p><h1 id="bbc4" class="kl km ht bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">一个简单的智能合同来显示差异</h1><p id="8b7e" class="pw-post-body-paragraph iq ir ht is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hm dt translated">两者的区别在于，<code class="eh jo jp jq jr b">msg.sender</code>包含发起呼叫的地址，而<code class="eh jo jp jq jr b">tx.origin</code>包含交易的发起者。为了阐明这两个变量的工作方式，你可以使用下面这段代码，准备好在Remix中进行测试。</p><figure class="jt ju jv jw fq jx"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="b37e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该源代码包含两个不同的契约，一个名为<code class="eh jo jp jq jr b">Storage</code>，另一个名为<code class="eh jo jp jq jr b">Caller</code>，包含字段<code class="eh jo jp jq jr b">StorageObject</code>中的<code class="eh jo jp jq jr b">Storage</code>实例。</p><p id="ef70" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh jo jp jq jr b">Storage</code>的实例是在<code class="eh jo jp jq jr b">Caller</code>的构造函数中创建的(第28行)。</p><p id="d189" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">两个契约包含相同的函数，这些函数将返回<code class="eh jo jp jq jr b">msg.sender</code>的内容和<code class="eh jo jp jq jr b">tx.origin</code>的内容。但是真正能说明区别的是两个方法(第34和42行):它们将从<code class="eh jo jp jq jr b">Storage</code>实例的角度返回<code class="eh jo jp jq jr b">msg.sender</code>和<code class="eh jo jp jq jr b">tx.origin</code>的内容。</p><p id="efcb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">像往常一样，这个测试比描述它的文字更能说明问题:</p><figure class="jt ju jv jw fq jx fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/7fe8e84535bb037d3bb62271a0142798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*dNg5Q9L_SjJwCQ_ySDojGQ.png"/></div></figure><p id="4dc0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你在这里可以看到:<code class="eh jo jp jq jr b">tx.origin</code>在两个契约中包含相同的值，带有函数<code class="eh jo jp jq jr b">inspectOrigin</code>的存储和带有函数<code class="eh jo jp jq jr b">inspectInspectOrigin</code>的<code class="eh jo jp jq jr b">Caller</code>，因为对于两者来说，调用的发起者都是账户<code class="eh jo jp jq jr b">0x5B38...C4</code>。您可能会注意到<code class="eh jo jp jq jr b">inspectSender</code>和<code class="eh jo jp jq jr b">inspectInspectSender</code>结果的不同，它们都返回<code class="eh jo jp jq jr b">msg.sender</code>，但是分别对于<code class="eh jo jp jq jr b">Caller</code>和<code class="eh jo jp jq jr b">Storage</code>来说，结果是不同的，正如所料。对于<code class="eh jo jp jq jr b">Caller</code>,<code class="eh jo jp jq jr b">msg.sender</code>(功能<code class="eh jo jp jq jr b">inspectSender</code>)同样是账户<code class="eh jo jp jq jr b">0x5B38...C4</code>，而对于智能合约<code class="eh jo jp jq jr b">Storage</code>是地址<code class="eh jo jp jq jr b">0x9d7f...99</code>，其中<em class="ke">是智能合约</em> <code class="eh jo jp jq jr b">Caller</code>的地址。</p><p id="5174" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">文档(你可以在这里找到它<a class="ae kf" href="https://docs.soliditylang.org/en/v0.5.3/miscellaneous.html?highlight=tx.origin#global-variables" rel="noopener ugc nofollow" target="_blank"/>)很简单，但是检查在引擎盖下到底发生了什么总是很有趣。</p><blockquote class="lt"><p id="3382" class="lu lv ht bd lw lx ly lz ma mb mc jn ek translated">加入T21电报集团，学习加密交易和投资</p></blockquote><h2 id="52d4" class="md km ht bd kn me mf mg kr mh mi mj kv jb mk ml kz jf mm mn ld jj mo mp lh mq dt translated">另外，阅读</h2><ul class=""><li id="b1b5" class="mr ms ht is b it lj ix lk jb mt jf mu jj mv jn mw mx my mz dt translated">最好的<a class="ae kf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="14b5" class="mr ms ht is b it na ix nb jb nc jf nd jj ne jn mw mx my mz dt translated"><a class="ae kf" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度比特币交易所</a></li><li id="1e00" class="mr ms ht is b it na ix nb jb nc jf nd jj ne jn mw mx my mz dt translated"><a class="ae kf" rel="noopener" href="/coinmonks/bitcoin-savings-account-e65b13f92451">比特币储蓄账户</a></li><li id="149b" class="mr ms ht is b it na ix nb jb nc jf nd jj ne jn mw mx my mz dt translated">最好的<a class="ae kf" rel="noopener" href="/coinmonks/best-crypto-tax-tool-for-my-money-72d4b430816b">加密税务软件</a></li><li id="09b6" class="mr ms ht is b it na ix nb jb nc jf nd jj ne jn mw mx my mz dt translated"><a class="ae kf" href="https://blog.coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">电网交易</a> | <a class="ae kf" rel="noopener" href="/coinmonks/blockfi-review-53096053c097">区块链审核</a></li><li id="d29e" class="mr ms ht is b it na ix nb jb nc jf nd jj ne jn mw mx my mz dt translated"><a class="ae kf" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a></li></ul></div></div>    
</body>
</html>