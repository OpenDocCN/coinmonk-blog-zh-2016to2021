<html>
<head>
<title>Hyperledger Burrow v0.19.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hyperledger Burrow v0.19.0</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/hyperledger-burrow-v0-19-0-633a143a5047?source=collection_archive---------7-----------------------#2018-07-22">https://medium.com/coinmonks/hyperledger-burrow-v0-19-0-633a143a5047?source=collection_archive---------7-----------------------#2018-07-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/6d48ab921f316d0e58257003faecdcf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H64kJdpV2OouIi78oXqe7w.jpeg"/></div></div></figure><div class=""/><p id="7081" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae jz" href="https://www.hyperledger.org/projects/hyperledger-burrow" rel="noopener ugc nofollow" target="_blank">由Monax和Intel联合提出的Hyperledger Burrow </a>于2017年4月被技术指导委员会接受进入Hyperledger孵化器。Burrow，自2014年以来被称为ErisDB，是由Monax创建的，正如Burrow继续使用的<a class="ae jz" href="https://github.com/tendermint/tendermint" rel="noopener ugc nofollow" target="_blank"> Tendermint </a>共识引擎一样。ErisDB在成为Hyperledger项目的一部分时更改了名称和许可证，成为唯一一个获得Apache许可的以太坊虚拟机实现。</p><p id="d83b" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">陋居的目的是在企业网络中实现智能契约(通常用<a class="ae jz" href="https://github.com/ethereum/solidity" rel="noopener ugc nofollow" target="_blank"> Solidity </a>编写)。陋居是一个节点(客户端)，它在与以太坊虚拟机(EVM)兼容的授权区块链上执行智能合约。</p><p id="2b50" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">EVM可以被视为一台大型分散式计算机，包含数百万个被称为“帐户”的对象，这些对象具有维护内部数据库、执行代码和相互通信的能力。EVM运行一个图灵完全软件。</p><p id="8d36" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Burrow作为一个节点由三个主要组件构建而成:共识引擎、许可以太坊虚拟机和rpc网关(远程过程调用)。</p><figure class="kb kc kd ke fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff ka"><img src="../Images/6846396a12710ad3b8312b7f3b8e5f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*yYwChfDr2jm9rF5RTg2zJQ.jpeg"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Burrow Architecture. Source: <a class="ae jz" href="https://www.hyperledger.org/wp-content/uploads/2017/06/HIP_Burrowv2.pdf" rel="noopener ugc nofollow" target="_blank">Hyperledger</a></figcaption></figure><p id="fdc8" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">更具体地说，钻地包括:</p><ul class=""><li id="d812" class="kj kk ie jd b je jf ji jj jm kl jq km ju kn jy ko kp kq kr dt translated">共识引擎(Consensus Engine):使用拜占庭容错Tendermint协议对交易进行排序和最终确定。Tendermint协议通过一组已知的验证器提供高事务性能，并防止区块链分叉。</li><li id="28ba" class="kj kk ie jd b je ks ji kt jm ku jq kv ju kw jy ko kp kq kr dt translated"><strong class="jd if">应用区块链接口</strong> ( <a class="ae jz" href="https://github.com/tendermint/abci" rel="noopener ugc nofollow" target="_blank"> ABCI </a>):该接口使事务能够以任何编程语言处理。ABCI允许共识引擎独立于智能合同的实现。</li><li id="c3de" class="kj kk ie jd b je ks ji kt jm ku jq kv ju kw jy ko kp kq kr dt translated"><strong class="jd if">智能合同应用</strong>:方便复杂业务逻辑的集成。按照共识引擎最终确定事务的顺序，对事务进行验证并将其应用于应用程序的状态。在给定帐户上调用智能合约代码的事务将触发该帐户的代码在被许可的虚拟机中的执行。</li><li id="2e34" class="kj kk ie jd b je ks ji kt jm ku jq kv ju kw jy ko kp kq kr dt translated"><strong class="jd if">许可的以太坊虚拟机</strong>:该虚拟机是根据以太坊的操作代码规范构建的，并确保授予适当的权限。权限是通过安全的本机函数应用的，并且是所有智能协定代码的基础。</li><li id="22aa" class="kj kk ie jd b je ks ji kt jm ku jq kv ju kw jy ko kp kq kr dt translated"><strong class="jd if">应用程序二进制接口</strong> (ABI):交易需要以区块链节点可以处理的二进制格式制定。当前的工具提供编译、实现和链接solidity智能合约的功能，并制定交易以在链上调用智能合约。</li><li id="66be" class="kj kk ie jd b je ks ji kt jm ku jq kv ju kw jy ko kp kq kr dt translated"><strong class="jd if"> API网关</strong>:网关为系统集成和用户界面提供接口。Burrow支持REST和JSON-RPC终端，客户可以通过广播事务或查询应用程序的当前状态，与区块链网络和应用程序状态进行交互。Websocket通信(双向通信通道)允许您订阅事件，这尤其有价值，因为共识引擎和智能合约应用程序可以在大约一秒的一个时间段内交付明确的最终交易结果。</li></ul><p id="e3bd" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">更多关于超账钻地的信息可以在https://github.com/hyperledger/burrow<a class="ae jz" href="https://github.com/hyperledger/burrow" rel="noopener ugc nofollow" target="_blank">的</a>找到</p></div><div class="ab cl kx ky hb kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hm hn ho hp hq"><p id="f708" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="le">一台完整的图灵机就是一台可以模拟任何其他机器的机器。例如，如果你有两台机器，一台是图灵完全的，另一台不是，你需要它们执行你以前没有经验的新任务，你将不得不以两种不同的方式去做。对于不完整的图灵机，您将需要加载和安装一组新的代码，以赋予机器执行所需任务的能力。对于完整的图灵机，你只需要提供机器的指令(例如“实现目标x，不违反规则a、b或c”)，机器就会让你参考它以前存在的代码库，并会适当地安排自己执行必要的任务。</em></p><p id="cb94" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="le">在分布式计算中，远程过程调用(RPC)是指计算机程序使一个过程(子例程)在不同的地址空间(通常在共享网络上的另一台计算机上)执行，该过程被编码为如同普通(本地)过程调用一样，而无需程序员显式编码远程交互的细节。(</em> <a class="ae jz" href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener ugc nofollow" target="_blank"> <em class="le">维基百科</em> </a> <em class="le">)。</em></p><p id="35e5" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="le">在计算机软件中，应用二进制接口(ABI)是两个二进制程序模块之间的接口；通常，这些模块中的一个是库或操作系统工具，另一个是用户正在运行的程序。(</em><a class="ae jz" href="https://en.wikipedia.org/wiki/Application_binary_interface" rel="noopener ugc nofollow" target="_blank"><em class="le"/></a><em class="le">)。</em></p></div></div>    
</body>
</html>