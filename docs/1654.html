<html>
<head>
<title>Hyperledger, Ethereum and Quorum Nonce Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超分类帐、以太坊和法定随机数管理</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/hyperledger-and-ethereum-nonce-management-890029d481b?source=collection_archive---------0-----------------------#2018-10-15">https://medium.com/coinmonks/hyperledger-and-ethereum-nonce-management-890029d481b?source=collection_archive---------0-----------------------#2018-10-15</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/5cb94ac0d5fe7aa59f71d4481c381087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hIEH_TCghQe9hpBU"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">“Matrix movie still” by <a class="ae jf" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="09b6" class="jg jh ht bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">什么是现时？</h1><p id="a473" class="pw-post-body-paragraph ke kf ht kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hm dt translated">nonce是一个任意的，<strong class="kg hu"> <em class="lc">唯一的</em> </strong>数，用来防止重放攻击。包括随机数在内的整个交易都用发送者的私钥进行了加密签名，从而向挖掘者证明交易的发送者拥有私钥。</p><h1 id="22b7" class="jg jh ht bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">为什么随机数需要是唯一的？</h1><p id="354b" class="pw-post-body-paragraph ke kf ht kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hm dt translated">随机数的唯一性可以防止重放攻击。一个简单的重放攻击的例子是，如果你发送3 ETH到ACME公司购买火箭动力的滚轴溜冰鞋。然后，ACME Corp的销售人员通过<a class="ae jf" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" rel="noopener ugc nofollow" target="_blank">中间人攻击</a>拦截你的交易，并将相同的第三次ETH交易广播5次，试图从你那里获得500%的ETH。nonce将<strong class="kg hu">防止</strong>这种情况，因为5个事务中只有1个将被挖掘。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div class="fe ff ld"><img src="../Images/142396c0ade25a959e12581234cea9b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*5MVwFzmngY_I8Gmb_F-m3g.jpeg"/></div></figure><h1 id="7b59" class="jg jh ht bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">矿工如何知道nonce是否是唯一的？</h1><p id="5927" class="pw-post-body-paragraph ke kf ht kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hm dt translated">这是底层架构变得真正有趣的地方。如果矿工需要跟踪每个账户地址曾经使用过的每个随机数，那么这将占用大量的存储空间。另外，<strong class="kg hu">超级分类帐结构</strong>和<strong class="kg hu">超级分类帐锯齿</strong>实际上确实存储了<strong class="kg hu">随机</strong>随机数，<strong class="kg hu">但是</strong>它们通过将使用的散列与当前有效证书相关联来缓解存储问题。这样，他们可以在颁发新证书时清除所有随机数。参见下面<a class="ae jf" href="https://sawtooth.hyperledger.org/docs/core/releases/1.0.1/app_developers_guide/python_sdk.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kg hu"> Hyperledger锯齿Python SDK </strong> </a>中的随机nonce示例代码。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div class="fe ff li"><img src="../Images/58889f6e05563f9126329c78dc7ca729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*SKD6E50Pv7aQfsNvnBpRyA.png"/></div></figure><p id="fb8b" class="pw-post-body-paragraph ke kf ht kg b kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb hm dt translated">以太坊和Quorum不需要存储随机数，因为它们不是随机的。随机数是来自发送地址的事务计数。这完全消除了存储随机数<strong class="kg hu">的需要，并且</strong>消除了<a class="ae jf" href="https://en.wikipedia.org/wiki/Double-spending" rel="noopener ugc nofollow" target="_blank"> <strong class="kg hu">双花费</strong> </a>的任何可能性。这些优势带来了一系列新的问题，因为随机数必须是连续的，不能跳过数字。参见下面的<a class="ae jf" href="https://web3py.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="kg hu">web 3 Python SDK</strong></a>示例代码。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/8d82c07106a541ee943b5ecb670a86e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*Z02Z5W1lB3wFvamCzZC-bQ.png"/></div></figure><h1 id="a02a" class="jg jh ht bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">以太坊的现时问题</h1><p id="be97" class="pw-post-body-paragraph ke kf ht kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hm dt translated">当我们试图在短时间内从同一个地址发送几笔交易时，问题就出现了。在<a class="ae jf" href="https://web3py.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="kg hu">web 3 Python SDK</strong></a><strong class="kg hu"/>中，我们调用<strong class="kg hu"> getTransactionCount </strong>方法来获取下一个nonce，但该方法是<strong class="kg hu"> </strong>通过IPC、Websockets或HTTP从我们的提供者获取计数(我使用<a class="ae jf" href="https://infura.io/" rel="noopener ugc nofollow" target="_blank"> Infura </a>作为HTTP的提供者)。提供者计数更新得不是很快。即使当我们用block _ identifier = '<strong class="kg hu">pending</strong>'调用<strong class="kg hu"> getTransactionCount </strong>时，我们仍然得到默认的block_identifier=' <strong class="kg hu">最新的</strong>计数。block_identifier设置为“待定”的调用仍然返回“最新”计数，这是一个<a class="ae jf" href="https://github.com/ethereum/go-ethereum/issues/2880" rel="noopener ugc nofollow" target="_blank">已知问题</a>。当我尝试使用来自<strong class="kg hu"> getTransactionCount </strong>方法的nonce发送多个事务时，问题如下所示。<strong class="kg hu"> </strong>它们都使用nonce <strong class="kg hu"> 121 </strong>，所以我们的脚本引发了一个错误，只有第一个事务通过。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lp"><img src="../Images/c73dca4db37fe038a2fa03c0925511bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0iMAlk_QcwHJSwFxzKs8w.png"/></div></div></figure><h1 id="b022" class="jg jh ht bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">nonce事务管理器解决方案</h1><p id="1102" class="pw-post-body-paragraph ke kf ht kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hm dt translated">我使用<a class="ae jf" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kg hu"> Redis </strong> </a>重写了相同的python脚本，以存储当前nonce并通过我的python脚本增加nonce，不再依赖于我们的提供者的<strong class="kg hu"> getTransactionCount </strong>方法。您可以看到，它在不到5秒的时间内发送了10个事务，没有任何问题。注意<strong class="kg hu">getTransactionCount</strong>nonce<strong class="kg hu"/>保持在151，但是我们没有问题，因为我们的Redis nonce正确地递增。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lq"><img src="../Images/1e988237d352ed4ff64f258b7bee4864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzA-tbjkn0LDnAWZp6ogaQ.png"/></div></div></figure><h1 id="ec6d" class="jg jh ht bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">托管随机数问题</h1><p id="fe74" class="pw-post-body-paragraph ke kf ht kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hm dt translated">如果我们由于一个错误而跳过了一个随机数，那么之后的所有事务都将被排队，但不会被处理<em class="lc">(有时会被丢弃)</em>，直到被跳过的随机数被使用。我在Redis CLI上将nonce计数增加1，然后对5个事务运行相同的python脚本。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lr"><img src="../Images/5dc4cf992c7581f2b9310e1fa5471fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q5tFSyGK8t5EC7yCrJP51Q.png"/></div></div></figure><p id="7f9d" class="pw-post-body-paragraph ke kf ht kg b kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb hm dt translated">您可以在下面看到，以“96e09bc”结尾的第一个事务在Etherscan上甚至没有显示为“pending”。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ls"><img src="../Images/c2428787ae4937241d691666f799879c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ImkXkNdI0W6FD3GmEnRJkw.png"/></div></div></figure><p id="5069" class="pw-post-body-paragraph ke kf ht kg b kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb hm dt translated">现在，我们运行nonce 161，它得到处理，但之前的5个事务已被丢弃，因此我们将再次运行最后5个事务。我以前也见过排队的事务自己处理，就在跳过的nonce被处理之后。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lt"><img src="../Images/9702f9ad4b24dacd32804aa0d9206065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQn3qpRKDLPze1ZIxyHQNQ.png"/></div></div></figure><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lu"><img src="../Images/e953c4ff64f549976bb89c2017128bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OR4MCConP3SfpSo2uk-rwA.png"/></div></div></figure><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lv"><img src="../Images/e0ac6424ca9e189eb84307045237adf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6p_Wu4KfldUXT9TTBLhfWA.png"/></div></div></figure><h1 id="592f" class="jg jh ht bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">重复交易记录？</h1><p id="1853" class="pw-post-body-paragraph ke kf ht kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hm dt translated">我重试了nonce 162，以表明您通常会通过提供者从SDK获得一个“nonce太低”的错误，但即使您不这样做，也只有1个具有该nonce的事务会得到处理。如果您在多个事务中使用相同的nonce，就没有必要担心重复。</p><figure class="le lf lg lh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lw"><img src="../Images/6ab63f7247fcaeaa136624c97ac76f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2-ORSWIccYpsXwEiFdvlA.png"/></div></div></figure><h1 id="98eb" class="jg jh ht bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">结论</h1><p id="44df" class="pw-post-body-paragraph ke kf ht kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hm dt translated">无论你是在<strong class="kg hu">企业</strong>环境中使用Hyperledger、Ethereum还是Quorum，随机数管理系统都是必须的。我在这篇文章中的简单Redis演示说明了基本概念，但没有涵盖使用单个地址的多个客户端，在这种情况下，您可能希望使用<strong class="kg hu"> Redis分布式锁定</strong>，如<a class="ae jf" href="https://redis.io/topics/distlock" rel="noopener ugc nofollow" target="_blank"> <strong class="kg hu"> Redlock </strong> </a>。</p><p id="e2b6" class="pw-post-body-paragraph ke kf ht kg b kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb hm dt translated">虽然我不是区块链项目的顾问，但我一直在研究一个<strong class="kg hu">企业事务管理系统</strong>，该系统将包括事务跟踪、分析、警报，甚至自动<strong class="kg hu">随机数</strong>重置和重试。</p><p id="15e2" class="pw-post-body-paragraph ke kf ht kg b kh lj kj kk kl lk kn ko kp ll kr ks kt lm kv kw kx ln kz la lb hm dt translated">你觉得这篇文章怎么样？如果你喜欢它或者学到了什么，请留下你的掌声！<a class="ae jf" href="https://darkblock.io/" rel="noopener ugc nofollow" target="_blank"> DarkBlock.io </a>是一家区块链企业发展公司，我们一直在接纳新客户。通过<a class="ae jf" href="mailto:sheffield@darkblock.io" rel="noopener ugc nofollow" target="_blank"> sheffield@darkblock.io </a>联系我或访问我们的网站<a class="ae jf" href="https://darkblock.io/" rel="noopener ugc nofollow" target="_blank"> DarkBlock.io </a>！</p><blockquote class="lx"><p id="9e10" class="ly lz ht bd ma mb mc md me mf mg lb ek translated"><a class="ae jf" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mi mj mk ml mm iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mh"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>