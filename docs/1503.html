<html>
<head>
<title>Integration tests with web3, Ganache CLI and Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与web3、Ganache CLI和Jest的集成测试</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/integration-tests-with-web3-ganache-cli-and-jest-f342b5f7af46?source=collection_archive---------3-----------------------#2018-09-15">https://medium.com/coinmonks/integration-tests-with-web3-ganache-cli-and-jest-f342b5f7af46?source=collection_archive---------3-----------------------#2018-09-15</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/a38af86a70fe25a488911f03530d9f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZRPFvbZ7_IdJxY-6TeaxQ.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by Louis Reed</figcaption></figure><p id="cc71" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">写得好的一组测试在交付一个可靠的软件中起着至关重要的作用。一套好的测试套件可以确保应用程序按预期运行，并显著减少bug的数量。说起来容易做起来难。实现这个目标的步骤之一是坚持不同测试级别的界限。在本文中，我想把重点放在依赖于web3的分散式应用程序的集成测试上。对于集成测试，我可以牺牲执行速度来获得应用程序不同组件无缝协作的信心。</p><p id="1cdf" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">上一次，我在黑盒测试中将web3注入到窗口对象中时，提出了一个模仿web3 的更加<a class="ae kd" href="https://michalzalecki.com/integration-tests-and-mocking-web3-apps/" rel="noopener ugc nofollow" target="_blank"> E2E的解决方案。这种技术需要连接到以太坊节点，并在本地运行Ganache。当您关心自动化测试的能力时，这是一个很好的解决方案。虽然这不是银弹。</a></p><p id="3d66" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">最近，我在浏览器上进行智能合约部署。为负责该功能的组件运行健壮的E2E测试用例太慢了。幸运的是，Ganache CLI还提供了对自动挖掘后续块的提供程序的编程访问。我们可以使用它来快速启动ganache实例，并防止在测试重新运行之间共享区块链状态。</p><h1 id="312b" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">Ganache CLI提供程序</h1><p id="4c06" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">为了交换所选测试套件的提供者，我们使用Jest的模拟特性。让我们为web3提供者getter创建一个单独的模块。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="bc63" class="lq kf ht lm b fv lr ls l lt lu"><em class="lv">// web3Provider.ts</em><br/><strong class="lm hu">import</strong> Web3 <strong class="lm hu">from</strong> "web3";<br/><br/><strong class="lm hu">export</strong> <strong class="lm hu">function</strong> provider() {<br/>  <strong class="lm hu">return</strong> Web3.givenProvider;<br/>}</span></pre><p id="009f" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">然后我们可以使用这个模块来实例化一个web3。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="5462" class="lq kf ht lm b fv lr ls l lt lu"><em class="lv">// web3.ts</em><br/><strong class="lm hu">import</strong> Web3 <strong class="lm hu">from</strong> "web3";<br/><strong class="lm hu">import</strong> { provider } <strong class="lm hu">from</strong> "./web3Provider";<br/><br/><strong class="lm hu">export</strong> <strong class="lm hu">const</strong> web3 <strong class="lm hu">=</strong> <strong class="lm hu">new</strong> Web3(provider());</span></pre><p id="b94c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们用于测试的提供者的实现略有不同。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="1bbb" class="lq kf ht lm b fv lr ls l lt lu"><em class="lv">// someModule.spec.ts</em><br/>jest.mock("./web3Provider", () <strong class="lm hu">=&gt;</strong> {<br/>  <strong class="lm hu">function</strong> provider() {<br/>    <strong class="lm hu">return</strong> require("ganache-cli").provider();<br/>  }<br/>  <strong class="lm hu">return</strong> { provider };<br/>});</span></pre><p id="87d6" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在我们嘲笑提供者的测试案例中，所有事务都将在ganache上运行。这样，我们每次测试应用程序时都有一个新的区块链实例。</p><h1 id="868d" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">跳过慢速测试</h1><p id="adb2" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">尽管自动化Ganache启动并使其成为测试用例的一部分比作为单独的应用程序运行有所改进，但这仍然需要几秒钟的时间。这超出了我对运行我的单元测试感到舒服的程度。我想到了一个解决这个问题的方法。</p><p id="3090" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们用slow description包装运行缓慢的测试，而不是直接使用Jest的description。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="1bd4" class="lq kf ht lm b fv lr ls l lt lu">describe("BettorAgreement", () <strong class="lm hu">=&gt;</strong> {<br/>  slowDescribe("deploy", () <strong class="lm hu">=&gt;</strong> {<br/>    it("deploys a contract", <strong class="lm hu">async</strong> () <strong class="lm hu">=&gt;</strong> {<br/>      <strong class="lm hu">const</strong> [account] <strong class="lm hu">=</strong> <strong class="lm hu">await</strong> web3.eth.getAccounts();<br/>      <strong class="lm hu">const</strong> contract <strong class="lm hu">=</strong> <strong class="lm hu">await</strong> deploy("1000000", { from: account, gas: 3000000 });<br/>      expect(contract.options.address).toContain("0x");<br/>    });<br/>  });<br/>});</span></pre><p id="2b6a" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">如果<code class="eh lw lx ly lm b">ALLOW_SLOW</code>环境变量等于假，我们完全跳过给定的测试集。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="2be1" class="lq kf ht lm b fv lr ls l lt lu"><strong class="lm hu">function</strong> allowSlow() {<br/>  <strong class="lm hu">return</strong> `${process.env.ALLOW_SLOW}`.toLowerCase() <strong class="lm hu">!==</strong> "false";<br/>}<br/><br/><strong class="lm hu">export</strong> <strong class="lm hu">function</strong> slowDescribe(msg: <strong class="lm hu">string</strong>, handler: jest.EmptyFunction) {<br/>  <strong class="lm hu">if</strong> (allowSlow()) {<br/>    describe(msg, handler);<br/>  } <strong class="lm hu">else</strong> {<br/>    describe.skip(msg, handler);<br/>  }<br/>}</span></pre><p id="c7a3" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我有点反对仅仅为了在测试中进行一些黑客攻击而修改“生产”代码。一个月后，没有人会记得这种实施背后的意图是什么。尽管如此，您可以在提供者内部检查allowSlow的结果，并打赌UglifyJS可以从包中删除死代码。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="6a25" class="lq kf ht lm b fv lr ls l lt lu"><em class="lv">// web3Provider.ts</em><br/><strong class="lm hu">import</strong> Web3 <strong class="lm hu">from</strong> "web3";<br/><br/><strong class="lm hu">export</strong> <strong class="lm hu">function</strong> provider() {<br/>  <strong class="lm hu">if</strong> (allowSlow()) <strong class="lm hu">return</strong> require("ganache-cli").provider();<br/>  <strong class="lm hu">return</strong> Web3.givenProvider;<br/>}</span></pre><h1 id="207a" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">结论</h1><p id="783c" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">JavaScript的动态特性给了我们模仿和修补测试代码和实际实现的灵活性。记住，你的测试服也是你必须维护的代码，过度工程化是有代价的，所以尽量保持简单。</p><blockquote class="lz"><p id="91b1" class="ma mb ht bd mc md me mf mg mh mi kc ek translated"><a class="ae kd" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="mk ml mm mn mo iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mj"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div><div class="ab cl mp mq hb mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hm hn ho hp hq"><p id="771f" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><em class="lv">原载于2018年9月15日</em><a class="ae kd" href="https://michalzalecki.com/integration-tests-with-web3-ganache-cli-and-jest/" rel="noopener ugc nofollow" target="_blank"><em class="lv">【michalzalecki.com</em></a><em class="lv">。</em></p></div></div>    
</body>
</html>