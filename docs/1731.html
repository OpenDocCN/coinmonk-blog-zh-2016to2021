<html>
<head>
<title>Part 8: Implementing Blockchain and Cryptocurrency with PoW consensus algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第8部分:用PoW共识算法实现区块链和加密货币</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/part-8-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-74e839158f1b?source=collection_archive---------0-----------------------#2018-10-31">https://medium.com/coinmonks/part-8-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-74e839158f1b?source=collection_archive---------0-----------------------#2018-10-31</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="7159" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在node.js中使用工作共识算法证明，小规模、易于理解、全面、逐步实施区块链和加密货币</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/ca1a2e2c4224dbbeb2b00eaca6e45a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*4tiX8RcB0DnrDZZ0l8yxGw.jpeg"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Source: <a class="ae ka" href="https://en.bitcoinwiki.org/wiki/Proof-of-work" rel="noopener ugc nofollow" target="_blank">Bitcoin Wiki</a></figcaption></figure><p id="e240" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<a class="ae ka" rel="noopener" href="/coinmonks/part-7-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-bf9a16063ec1">前一篇</a>中，我们创建事务和事务池。我们还在p2p服务器类中使用了事务池，并向网络广播事务。</p><p id="0613" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这一部分中，我们将创建miner类。</p><p id="0962" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">miner类将使用我们到目前为止创建的所有功能。我们还将在这篇文章中为矿工创造采矿奖励。</p><p id="63d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但在此之前，我们需要添加一个端点。</p><p id="3ab7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们创建一个get请求来公开个人的公钥，我们将以JSON格式发送wallets公钥。这将允许用户看到他们自己的公钥，并决定与谁共享。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="5297" class="kg kh ht kc b fv ki kj l kk kl">// get public key</span><span id="bc00" class="kg kh ht kc b fv km kj l kk kl">app.get('/public-key',(req,res)=&gt;{</span><span id="a255" class="kg kh ht kc b fv km kj l kk kl">res.json({publicKey: wallet.publicKey});</span><span id="6daa" class="kg kh ht kc b fv km kj l kk kl">})</span></pre><p id="c629" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您通过在<code class="eh kn ko kp kc b">‘/public-key’</code>端点上发出get请求，在postman上测试它。</p><p id="081d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好了，接下来我们将把miner类添加到我们的项目中。在区块链中，挖掘器的主要作用是从池中提取一些事务，并执行创建块的计算工作，然后将该块存储到链中。</p><p id="65f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在让我们问一个问题，是什么激励矿工做所有需要的计算工作来处理这些交易并把它们合并到区块链中。</p><p id="2e9c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">答案是奖励。</p><p id="29b4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将实施最快的矿工将获得添加块的奖励。</p><p id="900f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在实现这个奖励事务逻辑之前，让我们创建miner类。</p><p id="a6e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">向app目录添加一个新文件，命名为<code class="eh kn ko kp kc b">miner.js</code></p><p id="fc88" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这个文件中，我们将合并到目前为止我们已经构建的所有内容。这个文件是我们项目的核心。</p><p id="25f2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">创建一个名为Miner的新类。这个类将有一个区块链，一个事务池，一个p2p服务器和一个钱包作为依赖。当我们在app/index.js中传递创建应用实例时，我们将传递这些依赖项</p><p id="6393" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们需要一个函数来开始挖掘。所以让我们添加一个叫做<code class="eh kn ko kp kc b">mine()</code>的函数。</p><p id="e815" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这个挖掘函数中，我们将首先从事务池中收集所有有效的事务。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="642e" class="kg kh ht kc b fv ki kj l kk kl">const validTransactions = this.transactionPool.validTransactions();</span></pre><p id="ac22" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kq">我们稍后会实现</em> <code class="eh kn ko kp kc b"><em class="kq">validTransactions()</em></code> <em class="kq">函数。</em></p><p id="0c2f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后我们将在这个数组中添加一个奖励交易。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="a66b" class="kg kh ht kc b fv ki kj l kk kl">validTransactions.push(Transaction.rewardTransaction(this.wallet,Wallet.blockchainWallet()));</span></pre><p id="4516" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kq">我们稍后还将实现</em> <code class="eh kn ko kp kc b"><em class="kq">rewardTransaction() </em></code> <em class="kq">功能。</em></p><p id="8a11" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，我们将使用这些事务创建一个块，对其进行签名并添加到链中。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="7863" class="kg kh ht kc b fv ki kj l kk kl">const block = this.blockchain.addBlock(validTransactions);</span></pre><p id="24c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">创建一个块并将其添加到我们的链中后，我们将向网络广播该链。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="4ed9" class="kg kh ht kc b fv ki kj l kk kl">this.p2pServer.syncChain();</span></pre><p id="f3e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我们创建了一个块并广播它时，我们需要为新的传入事务清理池</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="8dcc" class="kg kh ht kc b fv ki kj l kk kl">this.transactionPool.clear();</span></pre><p id="4818" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一旦我们清除了池，我们需要告诉其他矿工实现他们的池，以防止其他矿工在他们开采的下一个块中添加旧事务。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="25cb" class="kg kh ht kc b fv ki kj l kk kl">this.p2pServer.broadcastClearTransactions();</span></pre><p id="5e11" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，我们将返回块。</p><p id="d730" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我们继续之前，让我们在<code class="eh kn ko kp kc b">transactionPool </code>类中实现<code class="eh kn ko kp kc b">validTransaction </code>函数。在这个函数中，我们将检查输入金额是否等于输出金额的总和，还将检查签名是否有效。</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="e793" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，让我们实现<code class="eh kn ko kp kc b">rewardTransaction()</code>功能。奖励交易类似于任何其他交易，但是不同之处在于奖励交易只有一个输出。此外，交易不是由任何矿工而是由区块链本身发送的，因此我们需要为区块链创建一个单独的钱包来创建这些奖励交易。</p><p id="3455" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将首先创建一个常数，它将是赢家矿工将收到的货币金额。让我们在config.js文件中添加这个常量。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="071b" class="kg kh ht kc b fv ki kj l kk kl">const MINING_REWARD = 50;</span></pre><p id="751f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最终config.js文件</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="5aae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们将在transaction.js文件中创建<code class="eh kn ko kp kc b">rewardTransaction</code>函数。</p><p id="e613" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从<code class="eh kn ko kp kc b">config.js</code>文件中导入矿工奖励常数。</p><p id="0c2a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在创建<code class="eh kn ko kp kc b">rewardTransaction</code>函数之前，让我们对代码做一些修改，以便我们可以重用该函数。以前我们是手动添加输出，现在我们将创建一个函数来完成。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="916e" class="kg kh ht kc b fv ki kj l kk kl">static transactionWithOutputs(senderWallet,outputs){<br/>        const transaction = new this();<br/>        transaction.outputs.push(...outputs);<br/>        Transaction.signTransaction(transaction,senderWallet);<br/>        return transaction;<br/>    }</span></pre><p id="45c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们可以在<code class="eh kn ko kp kc b">newTransaction</code>函数中使用这个函数。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="8fe3" class="kg kh ht kc b fv ki kj l kk kl">static newTransaction(senderWallet,recipient,amount){</span><span id="0fbc" class="kg kh ht kc b fv km kj l kk kl">if(amount &gt; senderWallet.balance){<br/>            console.log(`Amount : ${amount} exceeds the balance`);<br/>            return;<br/>        }<br/>        // call to the helper function that creates and signs the<br/>        // transaction outputs<br/>        return Transaction.transactionWithOutputs(senderWallet,[<br/>            {amount:  senderWallet.balance -amount,<br/>             address: senderWallet.publicKey},<br/>            {amount:  amount,address: recipient}<br/>        ])<br/>}</span></pre><p id="cedc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，让我们创建rewardTransaction()函数</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="b315" class="kg kh ht kc b fv ki kj l kk kl">static rewardTransaction(minerWallet,blockchainWallet){<br/>        return Transaction.transactionWithOutputs(<br/>            blockchainWallet,[{<br/>            amount: MINING_REWARD,<br/>            address: minerWallet.publicKey<br/>        }]);<br/>    }</span></pre><p id="40ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里我们已经传递了一个blockchainWallet，接下来我们将创建它。为什么我们需要一个区块链钱包？</p><p id="25e4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">嗯，区块链钱包是一种特殊的钱包，它会生成签名来确认和认证奖励交易。矿工自己不能成为交易的签字人。相反，区块链本身就是负责批准奖励的机构。</p><p id="41b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在wallet/index.js中创建函数blockchainWallet()，该函数将生成并返回一个新的wallet对象。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="b671" class="kg kh ht kc b fv ki kj l kk kl">static blockchainWallet(){</span><span id="70a0" class="kg kh ht kc b fv km kj l kk kl">const blockchainWallet = new this();</span><span id="aad1" class="kg kh ht kc b fv km kj l kk kl">blockchainWallet.address = 'blockchain-wallet';</span><span id="4104" class="kg kh ht kc b fv km kj l kk kl">return blockchainWallet;</span><span id="d893" class="kg kh ht kc b fv km kj l kk kl">}</span></pre><p id="8d51" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">继续，我们仍然需要在事务池中实现clear函数。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="db00" class="kg kh ht kc b fv ki kj l kk kl">clear(){</span><span id="2ffc" class="kg kh ht kc b fv km kj l kk kl">this.transactions = [];</span><span id="06a1" class="kg kh ht kc b fv km kj l kk kl">}</span></pre><p id="943d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们还将实现broadcastClearTransaction函数。为此，我们可以在p2p-server类中添加一个新的消息类型。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="0d8b" class="kg kh ht kc b fv ki kj l kk kl">const MESSAGE_TYPE = {</span><span id="b9f5" class="kg kh ht kc b fv km kj l kk kl">chain: 'CHAIN',</span><span id="9dae" class="kg kh ht kc b fv km kj l kk kl">transaction: 'TRANSACTION',</span><span id="9d0c" class="kg kh ht kc b fv km kj l kk kl">clear_transactions: 'CLEAR_TRANSACTIONS'</span><span id="3c90" class="kg kh ht kc b fv km kj l kk kl">}</span></pre><p id="59ed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，我们将创建一个broadcastClearTransaction函数，它将这个消息发送到连接的套接字。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="8188" class="kg kh ht kc b fv ki kj l kk kl">broadcastClearTransactions(){</span><span id="72a3" class="kg kh ht kc b fv km kj l kk kl">this.sockets.forEach(socket =&gt; {</span><span id="2fe6" class="kg kh ht kc b fv km kj l kk kl">socket.send(JSON.stringify({</span><span id="d928" class="kg kh ht kc b fv km kj l kk kl">type: MESSAGE_TYPE.clear_transactions</span><span id="0eab" class="kg kh ht kc b fv km kj l kk kl">}))</span><span id="4f74" class="kg kh ht kc b fv km kj l kk kl">})</span><span id="7d58" class="kg kh ht kc b fv km kj l kk kl">}</span></pre><p id="5ef2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">此外，我们必须处理这条消息，所以让我们向messageHandler()函数添加另一个开关案例。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="06ce" class="kg kh ht kc b fv ki kj l kk kl">case MESSAGE_TYPE.clear_transactions:</span><span id="759a" class="kg kh ht kc b fv km kj l kk kl">/**</span><span id="b3da" class="kg kh ht kc b fv km kj l kk kl">* clear the transactionpool</span><span id="400c" class="kg kh ht kc b fv km kj l kk kl">*/</span><span id="0564" class="kg kh ht kc b fv km kj l kk kl">this.transactionPool.clear();</span><span id="32ba" class="kg kh ht kc b fv km kj l kk kl">break;</span></pre><p id="ad74" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好吧。</p><p id="fb8a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我们继续之前，让我们测试我们的代码。添加以下测试案例</p><p id="e620" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kq"> transactionPool.test.js </em></p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="44b4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kq"> transaction.test.js </em></p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="637a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在你将有28个测试用例通过。</p><p id="fca6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">太棒了。</p><p id="2daf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">继续前进</p><p id="e1d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将创建一个挖掘端点来启动挖掘过程。</p><p id="0168" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在app/index.js中创建一个miner实例。</p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="1b84" class="kg kh ht kc b fv ki kj l kk kl">const Miner = require('./miner');<br/> <br/>  .<br/>  .<br/>  .</span><span id="ace7" class="kg kh ht kc b fv km kj l kk kl">const miner = new Miner(<br/>               blockchain,<br/>               transactionPool,<br/>               wallet,<br/>               p2pserver<br/>);</span></pre><p id="a137" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们将创建一个post请求<code class="eh kn ko kp kc b">'/mine-transactions'</code></p><pre class="jp jq jr js fq kb kc kd ke aw kf dt"><span id="1507" class="kg kh ht kc b fv ki kj l kk kl">app.get('/mine-transactions',(req,res)=&gt;{</span><span id="dceb" class="kg kh ht kc b fv km kj l kk kl">   const block = miner.mine();</span><span id="0a71" class="kg kh ht kc b fv km kj l kk kl">   console.log(`New block added: ${block.toString()}`);</span><span id="2189" class="kg kh ht kc b fv km kj l kk kl">   res.redirect('/blocks');</span><span id="77a7" class="kg kh ht kc b fv km kj l kk kl">})</span></pre><p id="5027" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通过启动应用程序的几个实例来探索这个新功能。然后在每个实例之间发送几个事务，之后让其中一个实例调用这个<code class="eh kn ko kp kc b">/mine-transaction</code>端点，以便从事务池中获取事务，并将其作为数据包含在区块链中。</p><p id="93f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，您可以检查是否每个人都收到了包含这些交易的更新区块链。通过调用<code class="eh kn ko kp kc b">/blocks</code>端点。我们还可以确保实例的事务池是空的，以查看广播清除事务是否按预期工作。通过呼叫<code class="eh kn ko kp kc b">/transctions</code>端点。</p><p id="568d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">太好了！</p><p id="7637" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在下一篇文章中，我们将在我们的加密货币中实现平衡。</p></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><p id="dc6c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kq">感谢您的阅读。</em> <strong class="is hu"> <em class="kq">在下一部分中，我们将实现计算和更新余额的功能。</em> </strong> <em class="kq">希望你喜欢编码。如果你发现这很有帮助，请鼓掌。</em> </p><p id="4ed5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你对区块链、以太坊或整个世界有任何问题，请发表评论。:)</p><blockquote class="la"><p id="fd47" class="lb lc ht bd ld le lf lg lh li lj jn ek translated"><a class="ae ka" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ll lm ln lo lp jt fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lk"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>