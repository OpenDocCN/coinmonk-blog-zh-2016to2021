<html>
<head>
<title>Create Blockchain in Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Haskell中创建区块链</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/create-blockchain-in-haskell-e65df30878bc?source=collection_archive---------4-----------------------#2018-05-16">https://medium.com/coinmonks/create-blockchain-in-haskell-e65df30878bc?source=collection_archive---------4-----------------------#2018-05-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="22cc" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">在Haskell中滚动自己的区块链</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/2e8d66adc0bc6e5a7cd0f7964db492d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*umQkGp5gmlS5as5NQOi4VQ.jpeg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek"><a class="ae jy" href="https://koukia.ca/create-a-private-ethereum-consorium-blockchain-in-azure-3667185276b5" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><blockquote class="jz ka kb"><p id="c45a" class="kc kd ke kf b kg kh iu ki kj kk ix kl km kn ko kp kq kr ks kt ku kv kw kx ky hm dt translated"><strong class="kf hu"> <em class="ht">归属</em> </strong> <em class="ht"> —这是</em> <a class="ae jy" href="https://twitter.com/TheMichaelBurge" rel="noopener ugc nofollow" target="_blank"> <em class="ht">迈克尔·伯格的</em> </a> <em class="ht">博文<br/> </em> <a class="ae jy" href="https://www.michaelburge.us/2017/08/17/rolling-your-own-blockchain.html" rel="noopener ugc nofollow" target="_blank">在Haskell中滚动自己的区块链</a>的转载作品</p></blockquote><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="https://cryptofi.co/"><div class="fe ff kz"><img src="../Images/8eb99069c498a3c388e6b629c28eb400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*48iQrDOfp0En9N1bYAgW7g.png"/></div></a><figcaption class="ju jv fg fe ff jw jx bd b be z ek"><strong class="bd la">Create Crypto Invoices</strong></figcaption></figure><p id="29be" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><a class="ae jy" href="https://cryptofi.co/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf hu"> Cryptofi —创建加密发票，跟踪您的加密支付</strong> </a></p><p id="aca8" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><a class="ae jy" href="https://coinmonks.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf hu">使用Coinmonks作业门户</strong> </a>查找加密作业</p><p id="a566" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/coinnmonks-crypto-writers-telegram-group-f56b4621af0a"> <strong class="kf hu"> <em class="ke">加入Coinmonks投稿人电报组。</em></strong>T34】</a></p><p id="751e" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/monks-need-your-help-7440418d67ec"> <strong class="kf hu"> <em class="ke">捐投投僧</em> </strong> </a></p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="https://coinmonks.com"><div class="fe ff le"><img src="../Images/24325228c537a09e28d6e4d8a7d100b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*2rvJnCn8s5msnFHnqh1LMw.png"/></div></a><figcaption class="ju jv fg fe ff jw jx bd b be z ek"><strong class="bd la">Click to find blockchain Jobs</strong></figcaption></figure><p id="02a4" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">比特币和以太坊提供了一种去中心化的处理货币、合同和所有权令牌的方式。从技术的角度来看，它们有许多可移动的部分，并提供了演示编程语言的好方法。</p><p id="c1f5" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">本文将开发一个简单的类似区块链的数据结构，用Haskell来演示这些:</p><ul class=""><li id="0d07" class="lf lg ht kf b kg kh kj kk lb lh lc li ld lj ky lk ll lm ln dt translated">编写二进制序列化程序和反序列化程序</li><li id="4f8d" class="lf lg ht kf b kg lo kj lp lb lq lc lr ld ls ky lk ll lm ln dt translated">使用加密原语计算哈希</li><li id="0f53" class="lf lg ht kf b kg lo kj lp lb lq lc lr ld ls ky lk ll lm ln dt translated">根据计算时间自动调整挖掘器的难度。</li></ul><p id="15d8" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">我们将把它命名为Haskoin。请注意，在未来的文章之前，它不会有任何网络或钱包安全。</p><h1 id="9ea7" class="lt lu ht bd lv lw lx ly lz ma mb mc md iz me ja mf jc mg jd mh jf mi jg mj mk dt translated">什么是区块链？</h1><p id="c314" class="pw-post-body-paragraph kc kd ht kf b kg ml iu ki kj mm ix kl lb mn ko kp lc mo ks kt ld mp kw kx ky hm dt translated">编写任何软件应用程序的第一步总是要弄清楚你的数据结构。无论是Haskell、Perl、C还是SQL都是如此。我们将把主要类型和typeclass实例放在它们自己的模块中:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="29fd" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">{-# LANGUAGE GeneralizedNewtypeDeriving, NoImplicitPrelude, DeriveTraversable, DeriveDataTypeable, StandaloneDeriving, TypeSynonymInstances, FlexibleInstances #-}</strong><br/><br/><strong class="mr hu">module</strong> Haskoin.Types <strong class="mr hu">where</strong><br/><br/><strong class="mr hu">import</strong> Protolude<br/><strong class="mr hu">import</strong> Crypto.Hash<br/><br/><strong class="mr hu">import</strong> Control.Comonad.Cofree<br/><strong class="mr hu">import</strong> Data.Data<br/><strong class="mr hu">import</strong> <strong class="mr hu">qualified</strong> Data.Vector <strong class="mr hu">as</strong> V<br/><br/><strong class="mr hu">newtype</strong> <strong class="mr hu">Account</strong> <strong class="mr hu">=</strong> <strong class="mr hu">Account</strong> <strong class="mr hu">Integer</strong> <strong class="mr hu">deriving</strong> (<strong class="mr hu">Eq</strong>, <strong class="mr hu">Show</strong>, <strong class="mr hu">Num</strong>)<br/><br/><strong class="mr hu">data</strong> <strong class="mr hu">Transaction</strong> <strong class="mr hu">=</strong> <strong class="mr hu">Transaction</strong> {<br/>  _from   <strong class="mr hu">::</strong> <strong class="mr hu">Account</strong>,<br/>  _to     <strong class="mr hu">::</strong> <strong class="mr hu">Account</strong>,<br/>  _amount <strong class="mr hu">::</strong> <strong class="mr hu">Integer</strong><br/>  } <strong class="mr hu">deriving</strong> (<strong class="mr hu">Eq</strong>, <strong class="mr hu">Show</strong>)<br/><br/><strong class="mr hu">newtype</strong> <strong class="mr hu">BlockF</strong> a <strong class="mr hu">=</strong> <strong class="mr hu">Block</strong> (<strong class="mr hu">V.Vector</strong> a) <strong class="mr hu">deriving</strong> (<strong class="mr hu">Eq</strong>, <strong class="mr hu">Show</strong>, <strong class="mr hu">Foldable</strong>, <strong class="mr hu">Traversable</strong>, <strong class="mr hu">Functor</strong>, <strong class="mr hu">Monoid</strong>)<br/><strong class="mr hu">type</strong> <strong class="mr hu">Block</strong> <strong class="mr hu">=</strong> <strong class="mr hu">BlockF</strong> <strong class="mr hu">Transaction</strong><br/><br/><strong class="mr hu">type</strong> <strong class="mr hu">HaskoinHash</strong> <strong class="mr hu">=</strong> <strong class="mr hu">Digest</strong> <strong class="mr hu">SHA1</strong><br/><br/><strong class="mr hu">data</strong> <strong class="mr hu">BlockHeader</strong> <strong class="mr hu">=</strong> <strong class="mr hu">BlockHeader</strong> {<br/>  _miner       <strong class="mr hu">::</strong> <strong class="mr hu">Account</strong>,<br/>  _parentHash  <strong class="mr hu">::</strong> <strong class="mr hu">HaskoinHash</strong><br/>  } <strong class="mr hu">deriving</strong> (<strong class="mr hu">Eq</strong>, <strong class="mr hu">Show</strong>)<br/><br/><strong class="mr hu">data</strong> <strong class="mr hu">MerkleF</strong> a <strong class="mr hu">=</strong> <strong class="mr hu">Genesis</strong><br/>               <strong class="mr hu">|</strong> <strong class="mr hu">Node</strong> <strong class="mr hu">BlockHeader</strong> a<br/>               <strong class="mr hu">deriving</strong> (<strong class="mr hu">Eq</strong>, <strong class="mr hu">Show</strong>, <strong class="mr hu">Functor</strong>, <strong class="mr hu">Traversable</strong>, <strong class="mr hu">Foldable</strong>)<br/><br/><strong class="mr hu">type</strong> <strong class="mr hu">Blockchain</strong> <strong class="mr hu">=</strong> <strong class="mr hu">Cofree</strong> <strong class="mr hu">MerkleF</strong> <strong class="mr hu">Block</strong></span></pre><p id="45a0" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><code class="eh na nb nc mr b">MerkleF</code>是一种高阶Merkle树类型，它将一个层添加到其他类型上。<code class="eh na nb nc mr b">Cofree MerkleF Block</code>做了两件事:它递归地应用<code class="eh na nb nc mr b">MerkleF</code>为Merkle树的所有深度生成一个类型，并为树中的每个节点附加一个<code class="eh na nb nc mr b">Block</code>类型的注释。</p><p id="9c27" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">当使用<code class="eh na nb nc mr b">Cofree</code>时，<code class="eh na nb nc mr b">anno :&lt; xf</code>将构造这些注释值中的一个。</p><p id="a7de" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">查看每个节点都知道其父节点的“倒置”树比查看每个节点都知道其子节点的树更有用。如果每个节点都知道它的子节点，那么在末尾添加一个新块就需要改变树中的每个节点。所以<code class="eh na nb nc mr b">MerkleF</code>产生的是一条链，而不是一棵树。</p><p id="cfbd" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><code class="eh na nb nc mr b"><a class="ae jy" href="https://hackage.haskell.org/package/protolude" rel="noopener ugc nofollow" target="_blank">Protolude</a></code>是我最近在中等规模的项目中使用的<code class="eh na nb nc mr b">Prelude</code>的替代品。<code class="eh na nb nc mr b">Prelude</code>有很多向后兼容的问题，所以很多人用<code class="eh na nb nc mr b">NoImplicitPrelude</code>语言扩展关闭它，并导入一个自定义的。</p><p id="ff97" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">为什么我们选择这个奇怪的<code class="eh na nb nc mr b">MerkleF</code>类型而不是下面这个简单的？</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="bad4" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">newtype</strong> <strong class="mr hu">Block</strong> <strong class="mr hu">=</strong> <strong class="mr hu">Block</strong> (<strong class="mr hu">V.Vector</strong> <strong class="mr hu">Transaction</strong>)<br/><strong class="mr hu">data</strong> <strong class="mr hu">Blockchain</strong> <strong class="mr hu">=</strong> <strong class="mr hu">Genesis</strong> <strong class="mr hu">Block</strong><br/>                <strong class="mr hu">|</strong> <strong class="mr hu">Node</strong> <strong class="mr hu">Block</strong> <strong class="mr hu">BlockHeader</strong> <strong class="mr hu">Blockchain</strong></span></pre><p id="5827" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">主要原因是获得那些<code class="eh na nb nc mr b">Functor</code>、<code class="eh na nb nc mr b">Traversable</code>和<code class="eh na nb nc mr b">Foldable</code>实例，因为我们可以使用它们来处理Merkle树，而无需编写任何代码。例如，给定一个区块链</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="1af3" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">import</strong> <strong class="mr hu">qualified</strong> Data.Vector <strong class="mr hu">as</strong> V<br/><br/><strong class="mr hu">let</strong> genesis_block <strong class="mr hu">=</strong> <strong class="mr hu">Block</strong> (<strong class="mr hu">V.</strong>fromList <strong class="mr hu">[]</strong>)<br/><strong class="mr hu">let</strong> block1 <strong class="mr hu">=</strong> <strong class="mr hu">Block</strong> (<strong class="mr hu">V.</strong>fromList [<strong class="mr hu">Transaction</strong> 0 1 1000])<br/><strong class="mr hu">let</strong> genesis_chain <strong class="mr hu">=</strong> genesis_block <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Genesis</strong><br/><strong class="mr hu">let</strong> chain1 <strong class="mr hu">=</strong> block1 <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> (<strong class="mr hu">BlockHeader</strong> { _miner <strong class="mr hu">=</strong> 0, _parentHash <strong class="mr hu">=</strong> undefined }) genesis_chain<br/><strong class="mr hu">let</strong> chain2 <strong class="mr hu">=</strong> block1 <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> (<strong class="mr hu">BlockHeader</strong> { _miner <strong class="mr hu">=</strong> 0, _parentHash <strong class="mr hu">=</strong> undefined }) chain1</span></pre><p id="6491" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">，您可以通过以下方式获得它的所有事务:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="a98a" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">let</strong> txns <strong class="mr hu">=</strong> toList <strong class="mr hu">$</strong> mconcat <strong class="mr hu">$</strong> toList chain2<br/><em class="ke">-- [Transaction {_from = Account 0, _to = Account 1, _amount = 1000},Transaction {_from = Account 0, _to = Account 1, _amount = 1000}]</em><br/><strong class="mr hu">let</strong> totalVolume <strong class="mr hu">=</strong> sum <strong class="mr hu">$</strong> map _amount txns<br/><em class="ke">-- 2000</em></span></pre><p id="0e01" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">我使用<code class="eh na nb nc mr b">stack ghci</code>输入一个交互式提示来测试上面的内容。</p><p id="cb46" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">Real区块链在报头中有很多有用的东西，比如时间戳或者nonce值。我们可以在需要时将它们添加到<code class="eh na nb nc mr b">BlockHeader</code>中。</p><h1 id="9ed1" class="lt lu ht bd lv lw lx ly lz ma mb mc md iz me ja mf jc mg jd mh jf mi jg mj mk dt translated">构建链</h1><p id="5ee3" class="pw-post-body-paragraph kc kd ht kf b kg ml iu ki kj mm ix kl lb mn ko kp lc mo ks kt ld mp kw kx ky hm dt translated">一堆难以使用的抽象类型本身并不是很有用。我们需要一种方法来挖掘新的区块来做任何有趣的事情。换句话说，我们想要定义<code class="eh na nb nc mr b">mineOn</code>和<code class="eh na nb nc mr b">makeGenesis</code>:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="4b4c" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">module</strong> Haskoin.Mining <strong class="mr hu">where</strong><br/><br/><strong class="mr hu">type</strong> <strong class="mr hu">TransactionPool</strong> <strong class="mr hu">=</strong> <strong class="mr hu">IO</strong> [<strong class="mr hu">Transaction</strong>]<br/><br/>mineOn <strong class="mr hu">::</strong> <strong class="mr hu">TransactionPool</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">Account</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">Blockchain</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">IO</strong> <strong class="mr hu">Blockchain</strong><br/>mineOn pendingTransactions minerAccount root <strong class="mr hu">=</strong> undefined<br/><br/>makeGenesis <strong class="mr hu">::</strong> <strong class="mr hu">IO</strong> <strong class="mr hu">Blockchain</strong><br/>makeGenesis <strong class="mr hu">=</strong> undefined</span></pre><p id="d23e" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">genesis块非常简单，因为它没有头:</p><p id="309e" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><code class="eh na nb nc mr b">makeGenesis <strong class="kf hu">=</strong> return <strong class="kf hu">$</strong> <strong class="kf hu">Block</strong> (<strong class="kf hu">V.</strong>fromList <strong class="kf hu">[]</strong>) <strong class="kf hu">:&lt;</strong> <strong class="kf hu">Genesis</strong></code></p><p id="d98f" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">如果我们知道如何计算父节点的散列，我们就可以很容易地编写<code class="eh na nb nc mr b">mineOn</code>,没有任何困难、事务限制或安全性:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="8f93" class="mv lu ht mr b fv mw mx l my mz">mineOn <strong class="mr hu">::</strong> <strong class="mr hu">TransactionPool</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">Account</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">Blockchain</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">IO</strong> <strong class="mr hu">Blockchain</strong><br/>mineOn pendingTransactions minerAccount parent <strong class="mr hu">=</strong> <strong class="mr hu">do</strong><br/>  ts <strong class="mr hu">&lt;-</strong> pendingTransactions<br/>  <strong class="mr hu">let</strong> block <strong class="mr hu">=</strong> <strong class="mr hu">Block</strong> (<strong class="mr hu">V.</strong>fromList ts)<br/>  <strong class="mr hu">let</strong> header <strong class="mr hu">=</strong> <strong class="mr hu">BlockHeader</strong> {<br/>        _miner <strong class="mr hu">=</strong> minerAccount,<br/>        _parentHash <strong class="mr hu">=</strong> hash parent<br/>        }<br/>  return <strong class="mr hu">$</strong> block <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> header parent<br/><br/>hash <strong class="mr hu">::</strong> <strong class="mr hu">Blockchain</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">HaskoinHash</strong><br/>hash <strong class="mr hu">=</strong> undefined</span></pre><p id="b585" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><code class="eh na nb nc mr b">Crypto.Hash</code>有很多方法来散列一些东西，我们之前已经选择了<code class="eh na nb nc mr b">type HaskoinHash = Digest SHA1</code>。但是为了使用它，我们需要一些实际的字节来散列。这意味着我们需要一种方法来序列化和反序列化一个<code class="eh na nb nc mr b">Blockchain</code>。一个常用的库是<code class="eh na nb nc mr b"><a class="ae jy" href="https://hackage.haskell.org/package/binary" rel="noopener ugc nofollow" target="_blank">binary</a></code>，它提供了一个<code class="eh na nb nc mr b">Binary</code>类型类，我们将为我们的类型实现它。</p><p id="20ae" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">手工写实例并不难，但是使用怪异递归类型的一个好处是编译器可以为我们生成<code class="eh na nb nc mr b">Binary</code>实例。下面是序列化和反序列化我们需要的每种类型的完整代码:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="6f8c" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">{-# LANGUAGE StandaloneDeriving, TypeSynonymInstances, FlexibleInstances, UndecidableInstances, DeriveGeneric, GeneralizedNewtypeDeriving #-}</strong><br/><br/><strong class="mr hu">module</strong> Haskoin.Serialization <strong class="mr hu">where</strong><br/><br/><strong class="mr hu">import</strong> Haskoin.Types<br/><strong class="mr hu">import</strong> Control.Comonad.Cofree<br/><strong class="mr hu">import</strong> Crypto.Hash<br/><strong class="mr hu">import</strong> Data.Binary<br/><strong class="mr hu">import</strong> Data.Binary.Get<br/><strong class="mr hu">import</strong> Data.ByteArray<br/><strong class="mr hu">import</strong> <strong class="mr hu">qualified</strong> Data.ByteString <strong class="mr hu">as</strong> BS<br/><strong class="mr hu">import</strong> <strong class="mr hu">qualified</strong> Data.ByteString.Lazy <strong class="mr hu">as</strong> BSL<br/><strong class="mr hu">import</strong> Data.Vector.Binary<br/><strong class="mr hu">import</strong> GHC.Generics<br/><br/><strong class="mr hu">instance</strong> (<strong class="mr hu">Binary</strong> (f (<strong class="mr hu">Cofree</strong> f a)), <strong class="mr hu">Binary</strong> a) <strong class="mr hu">=&gt;</strong> <strong class="mr hu">Binary</strong> (<strong class="mr hu">Cofree</strong> f a) <strong class="mr hu">where</strong><br/><strong class="mr hu">instance</strong> (<strong class="mr hu">Binary</strong> a) <strong class="mr hu">=&gt;</strong> <strong class="mr hu">Binary</strong> (<strong class="mr hu">MerkleF</strong> a) <strong class="mr hu">where</strong><br/><strong class="mr hu">instance</strong> <strong class="mr hu">Binary</strong> <strong class="mr hu">BlockHeader</strong> <strong class="mr hu">where</strong><br/><strong class="mr hu">instance</strong> <strong class="mr hu">Binary</strong> <strong class="mr hu">Transaction</strong> <strong class="mr hu">where</strong><br/><strong class="mr hu">deriving</strong> <strong class="mr hu">instance</strong> <strong class="mr hu">Binary</strong> <strong class="mr hu">Account</strong><br/><strong class="mr hu">deriving</strong> <strong class="mr hu">instance</strong> <strong class="mr hu">Binary</strong> <strong class="mr hu">Block</strong><br/><br/><strong class="mr hu">deriving</strong> <strong class="mr hu">instance</strong> <strong class="mr hu">Generic</strong> (<strong class="mr hu">Cofree</strong> f a)<br/><strong class="mr hu">deriving</strong> <strong class="mr hu">instance</strong> <strong class="mr hu">Generic</strong> (<strong class="mr hu">MerkleF</strong> a)<br/><strong class="mr hu">deriving</strong> <strong class="mr hu">instance</strong> <strong class="mr hu">Generic</strong> <strong class="mr hu">BlockHeader</strong><br/><strong class="mr hu">deriving</strong> <strong class="mr hu">instance</strong> <strong class="mr hu">Generic</strong> <strong class="mr hu">Transaction</strong><br/><strong class="mr hu">instance</strong> <strong class="mr hu">Binary</strong> <strong class="mr hu">HaskoinHash</strong> <strong class="mr hu">where</strong><br/>  get <strong class="mr hu">=</strong> <strong class="mr hu">do</strong><br/>    mDigest <strong class="mr hu">&lt;-</strong> digestFromByteString <strong class="mr hu">&lt;$&gt;</strong> (get <strong class="mr hu">::</strong> <strong class="mr hu">Get</strong> <strong class="mr hu">BS.ByteString</strong>)<br/>    <strong class="mr hu">case</strong> mDigest <strong class="mr hu">of</strong><br/>      <strong class="mr hu">Nothing</strong> <strong class="mr hu">-&gt;</strong> fail "Not a valid digest"<br/>      <strong class="mr hu">Just</strong> digest <strong class="mr hu">-&gt;</strong> return digest<br/>  put digest <strong class="mr hu">=</strong> put <strong class="mr hu">$</strong> (convert digest <strong class="mr hu">::</strong> <strong class="mr hu">BS.ByteString</strong>)<br/><br/>deserialize <strong class="mr hu">::</strong> <strong class="mr hu">BSL.ByteString</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">Blockchain</strong><br/>deserialize <strong class="mr hu">=</strong> decode<br/><br/>serialize <strong class="mr hu">::</strong> <strong class="mr hu">Blockchain</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">BSL.ByteString</strong><br/>serialize <strong class="mr hu">=</strong> encode</span></pre><p id="d3bf" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">我只包括了<code class="eh na nb nc mr b">deserialize</code>和<code class="eh na nb nc mr b">serialize</code>以使这个模块的最终结果更加清晰。让我们放弃他们，支持<code class="eh na nb nc mr b">Data.Binary</code>中的<code class="eh na nb nc mr b">decode</code>和<code class="eh na nb nc mr b">encode</code>。</p><p id="2c90" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated"><code class="eh na nb nc mr b">Generic</code>是一种将值转换成非常轻量级的“语法树”的方法，可以被序列化器(JSON、XML、Binary等)使用。)和许多其他typeclasses来提供有用的默认定义。Haskell wiki有一个很好的概述。<code class="eh na nb nc mr b">binary</code>使用这些<code class="eh na nb nc mr b">Generic</code>实例来定义可以处理任何事情的序列化器。</p><p id="d64e" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">我们不得不为<code class="eh na nb nc mr b">HaskoinHash</code>手工编写一个<code class="eh na nb nc mr b">Binary</code>实例，因为<code class="eh na nb nc mr b">Crypto.Hash</code>库中的<code class="eh na nb nc mr b">Digest SHA1</code>没有提供它或<code class="eh na nb nc mr b">Generic</code>实例。没关系——无论如何，摘要基本上都是字节串，所以只有几行。</p><p id="fd3d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">下面是如何使用它们来实现<code class="eh na nb nc mr b">mineOn</code>:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="1a41" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">import</strong> Crypto.Hash(hashlazy)<br/><br/>mineOn <strong class="mr hu">::</strong> <strong class="mr hu">TransactionPool</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">Account</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">Blockchain</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">IO</strong> <strong class="mr hu">Blockchain</strong><br/>mineOn pendingTransactions minerAccount parent <strong class="mr hu">=</strong> <strong class="mr hu">do</strong><br/>  ts <strong class="mr hu">&lt;-</strong> pendingTransactions<br/>  <strong class="mr hu">let</strong> block <strong class="mr hu">=</strong> <strong class="mr hu">Block</strong> (<strong class="mr hu">V.</strong>fromList ts)<br/>  <strong class="mr hu">let</strong> header <strong class="mr hu">=</strong> <strong class="mr hu">BlockHeader</strong> {<br/>        _miner <strong class="mr hu">=</strong> minerAccount,<br/>        _parentHash <strong class="mr hu">=</strong> hashlazy <strong class="mr hu">$</strong> encode parent<br/>        }<br/>  return <strong class="mr hu">$</strong> block <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> header parent</span></pre><p id="203d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">下面是如何测试这是否真的有效:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="8e79" class="mv lu ht mr b fv mw mx l my mz">testMining <strong class="mr hu">::</strong> <strong class="mr hu">IO</strong> <strong class="mr hu">Blockchain</strong><br/>testMining <strong class="mr hu">=</strong> <strong class="mr hu">do</strong><br/>  <strong class="mr hu">let</strong> txnPool <strong class="mr hu">=</strong> return <strong class="mr hu">[]</strong><br/>  chain <strong class="mr hu">&lt;-</strong> makeGenesis<br/>  chain <strong class="mr hu">&lt;-</strong> mineOn txnPool 0 chain<br/>  chain <strong class="mr hu">&lt;-</strong> mineOn txnPool 0 chain<br/>  chain <strong class="mr hu">&lt;-</strong> mineOn txnPool 0 chain<br/>  chain <strong class="mr hu">&lt;-</strong> mineOn txnPool 0 chain<br/>  chain <strong class="mr hu">&lt;-</strong> mineOn txnPool 0 chain<br/>  return chain<br/><br/><em class="ke">-- GHCI</em><br/><strong class="mr hu">&gt;</strong> chain <strong class="mr hu">&lt;-</strong> testMining<br/><strong class="mr hu">Block</strong> <strong class="mr hu">[]</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> (<strong class="mr hu">BlockHeader</strong> {_miner <strong class="mr hu">=</strong> <strong class="mr hu">Account</strong> 0, _parentHash <strong class="mr hu">=</strong> efb3febc87c41fffb673a81ed14a6fb4f736df79}) (<br/>  <strong class="mr hu">Block</strong> <strong class="mr hu">[]</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> (<strong class="mr hu">BlockHeader</strong> {_miner <strong class="mr hu">=</strong> <strong class="mr hu">Account</strong> 0, _parentHash <strong class="mr hu">=</strong> 2accb557297850656de70bfc3e13ea92a4ddac29}) (<br/>    <strong class="mr hu">Block</strong> <strong class="mr hu">[]</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> (<strong class="mr hu">BlockHeader</strong> {_miner <strong class="mr hu">=</strong> <strong class="mr hu">Account</strong> 0, _parentHash <strong class="mr hu">=</strong> f51e30233feb41a228706d1357892d16af69c03b}) (<br/>      <strong class="mr hu">Block</strong> <strong class="mr hu">[]</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> (<strong class="mr hu">BlockHeader</strong> {_miner <strong class="mr hu">=</strong> <strong class="mr hu">Account</strong> 0, _parentHash <strong class="mr hu">=</strong> 0072e83ae8e9e22d5711fd832d350f5a279c1c12}) (<br/>        <strong class="mr hu">Block</strong> <strong class="mr hu">[]</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> (<strong class="mr hu">BlockHeader</strong> {_miner <strong class="mr hu">=</strong> <strong class="mr hu">Account</strong> 0, _parentHash <strong class="mr hu">=</strong> c259e771b237769cb6bce9a5ab734c576a6da3e1}) (<br/>          <strong class="mr hu">Block</strong> <strong class="mr hu">[]</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Genesis</strong>)))))<br/><strong class="mr hu">&gt;</strong> encode chain<br/>"\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\DC4\239\179\254\188\135\196\US\255\182s\168\RS\209Jo\180\247\&amp;6\223y\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\DC4*\204\181W)xPem\231\v\252&gt;\DC3\234\146\164\221\172)\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\DC4\245\RS0#?\235A\162(pm\DC3W\137-\SYN\175i\192;\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\DC4\NULr\232:\232\233\226-W\DC1\253\131-5\SIZ'\156\FS\DC2\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\DC4\194Y\231q\178\&amp;7v\156\182\188\233\165\171sLWjm\163\225\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL"<br/><strong class="mr hu">&gt;</strong> (decode <strong class="mr hu">$</strong> encode chain) <strong class="mr hu">::</strong> <strong class="mr hu">Blockchain</strong><br/><strong class="mr hu">Block</strong> <strong class="mr hu">[]</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> (<strong class="mr hu">BlockHeader</strong> {_miner <strong class="mr hu">=</strong> <strong class="mr hu">Account</strong> 0, _parentHash <strong class="mr hu">=</strong> efb3febc87c41fffb673a81ed14a6fb4f736df79}) (<br/>  <strong class="mr hu">Block</strong> <strong class="mr hu">[]</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> (<strong class="mr hu">BlockHeader</strong> {_miner <strong class="mr hu">=</strong> <strong class="mr hu">Account</strong> 0, _parentHash <strong class="mr hu">=</strong> 2accb557297850656de70bfc3e13ea92a4ddac29}) (<br/>    <strong class="mr hu">Block</strong> <strong class="mr hu">[]</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> (<strong class="mr hu">BlockHeader</strong> {_miner <strong class="mr hu">=</strong> <strong class="mr hu">Account</strong> 0, _parentHash <strong class="mr hu">=</strong> f51e30233feb41a228706d1357892d16af69c03b}) (<br/>      <strong class="mr hu">Block</strong> <strong class="mr hu">[]</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> (<strong class="mr hu">BlockHeader</strong> {_miner <strong class="mr hu">=</strong> <strong class="mr hu">Account</strong> 0, _parentHash <strong class="mr hu">=</strong> 0072e83ae8e9e22d5711fd832d350f5a279c1c12}) (<br/>        <strong class="mr hu">Block</strong> <strong class="mr hu">[]</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> (<strong class="mr hu">BlockHeader</strong> {_miner <strong class="mr hu">=</strong> <strong class="mr hu">Account</strong> 0, _parentHash <strong class="mr hu">=</strong> c259e771b237769cb6bce9a5ab734c576a6da3e1}) (<br/>          <strong class="mr hu">Block</strong> <strong class="mr hu">[]</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Genesis</strong>)))))</span></pre><p id="8411" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">如果你在家测试序列化代码，你可能更喜欢使用<code class="eh na nb nc mr b">base16-bytestring</code>库来十六进制编码你的<code class="eh na nb nc mr b">ByteString</code>:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="c388" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">&gt;</strong> <strong class="mr hu">import</strong> <strong class="mr hu">qualified</strong> Data.ByteString.Base16.Lazy <strong class="mr hu">as</strong> BSL<br/><strong class="mr hu">&gt;</strong> chain <strong class="mr hu">&lt;-</strong> testMining<br/><strong class="mr hu">&gt;</strong> <strong class="mr hu">BSL.</strong>encode <strong class="mr hu">$</strong> encode chain<br/>00000000000000000100000000000000000000000014efb3febc87c41fffb673a81ed14a6fb4f736df79000000000000000001000000000000000000000000142accb557297850656de70bfc3e13ea92a4ddac2900000000000000000100000000000000000000000014f51e30233feb41a228706d1357892d16af69c03b000000000000000001000000000000000000000000140072e83ae8e9e22d5711fd832d350f5a279c1c1200000000000000000100000000000000000000000014c259e771b237769cb6bce9a5ab734c576a6da3e1000000000000000000</span></pre><p id="a807" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">请注意，对于试图理解我们的序列化/反序列化代码的C程序员来说，这可能是一场噩梦，因为字节争论隐藏在许多真正通用的代码中。如果你想产生一个规范供人们使用(总是一个好主意)，你可能会想手工滚动你的序列化代码，使其自文档化。</p><h1 id="0c5f" class="lt lu ht bd lv lw lx ly lz ma mb mc md iz me ja mf jc mg jd mh jf mi jg mj mk dt translated">采矿</h1><p id="0e69" class="pw-post-body-paragraph kc kd ht kf b kg ml iu ki kj mm ix kl lb mn ko kp lc mo ks kt ld mp kw kx ky hm dt translated">这个所谓的区块链有几个与采矿相关的问题:</p><ol class=""><li id="2482" class="lf lg ht kf b kg kh kj kk lb lh lc li ld lj ky nd ll lm ln dt translated">人们可以有负结余，所以人们可以创建一个“替罪羊账户”,他们可以从中转移无限量的资金。</li><li id="8078" class="lf lg ht kf b kg lo kj lp lb lq lc lr ld ls ky nd ll lm ln dt translated">没有事务限制，所以有人可能会创建一个巨大的块，让我们的矿工耗尽内存。</li><li id="8976" class="lf lg ht kf b kg lo kj lp lb lq lc lr ld ls ky nd ll lm ln dt translated">我们总是开采空的街区，所以没人能转移钱。</li><li id="32a3" class="lf lg ht kf b kg lo kj lp lb lq lc lr ld ls ky nd ll lm ln dt translated">没有困难，所以矿工们没有证明他们做过任何工作。</li></ol><p id="e024" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">我说这些都是挖掘问题，因为矿工运行的代码会处理它们。</p><p id="3ac3" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">#3我们就等<strong class="kf hu">联网</strong>解决。剩下的我们现在可以做。</p><p id="4d04" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">为了解决第一个问题，我们需要任何有交易的人的账户余额。让我们继续计算所有可能的账户余额:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="99f1" class="mv lu ht mr b fv mw mx l my mz">blockReward <strong class="mr hu">=</strong> 1000<br/><br/>balances <strong class="mr hu">::</strong> <strong class="mr hu">Blockchain</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">M.Map</strong> <strong class="mr hu">Account</strong> <strong class="mr hu">Integer</strong><br/>balances bc <strong class="mr hu">=</strong><br/>  <strong class="mr hu">let</strong> txns <strong class="mr hu">=</strong> toList <strong class="mr hu">$</strong> mconcat <strong class="mr hu">$</strong> toList bc<br/>      debits <strong class="mr hu">=</strong> map (<strong class="mr hu">\Transaction</strong>{ _from <strong class="mr hu">=</strong> acc, _amount <strong class="mr hu">=</strong> amount} <strong class="mr hu">-&gt;</strong> (acc, <strong class="mr hu">-</strong>amount)) txns<br/>      credits <strong class="mr hu">=</strong> map (<strong class="mr hu">\Transaction</strong>{ _to <strong class="mr hu">=</strong> acc, _amount <strong class="mr hu">=</strong> amount} <strong class="mr hu">-&gt;</strong> (acc, amount)) txns<br/>      minings <strong class="mr hu">=</strong> map (<strong class="mr hu">\</strong>h <strong class="mr hu">-&gt;</strong> (_minerAccount h, blockReward)) <strong class="mr hu">$</strong> headers bc<br/>  <strong class="mr hu">in</strong> <strong class="mr hu">M.</strong>fromListWith (<strong class="mr hu">+</strong>) <strong class="mr hu">$</strong> debits <strong class="mr hu">++</strong> credits <strong class="mr hu">++</strong> minings</span></pre><p id="3e58" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">一旦我们有了父区块链，我们就知道如何过滤掉无效的事务:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="8395" class="mv lu ht mr b fv mw mx l my mz">validTransactions <strong class="mr hu">::</strong> <strong class="mr hu">Blockchain</strong> <strong class="mr hu">-&gt;</strong> [<strong class="mr hu">Transaction</strong>] <strong class="mr hu">-&gt;</strong> [<strong class="mr hu">Transaction</strong>]<br/>validTransactions bc txns <strong class="mr hu">=</strong><br/>  <strong class="mr hu">let</strong> accounts <strong class="mr hu">=</strong> balances bc<br/>      validTxn txn <strong class="mr hu">=</strong> <strong class="mr hu">case</strong> <strong class="mr hu">M.</strong>lookup (_from txn) accounts <strong class="mr hu">of</strong><br/>        <strong class="mr hu">Nothing</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">False</strong><br/>        <strong class="mr hu">Just</strong> balance <strong class="mr hu">-&gt;</strong> balance <strong class="mr hu">&gt;=</strong> _amount txn<br/>  <strong class="mr hu">in</strong> filter validTxn txns</span></pre><p id="da95" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">为了解决#2，我将让当前矿工选择他想要放入他的块中的交易。这意味着我将在顶部放置一个常量<code class="eh na nb nc mr b">globalTransactionLimit = 1000</code>，我们将在挖掘时使用它，但我们不会使用它来验证过去的块。</p><p id="3833" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">为了解决第4个问题，我们需要在我们的<code class="eh na nb nc mr b">BlockHeader</code>中添加一个nonce字段，挖掘器可以增加这个字段，直到找到一个好的hash。我们将使它成为一个任意大的整数，以避免没有nonce值产生足够困难的散列的情况。因为我们想调整我们的难度，所以块需要大致相同的时间来挖掘，我们将在头中存储一个时间戳。</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="64a5" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">import</strong> Data.Time.Clock.POSIX<br/><br/><em class="ke">-- Add new fields</em><br/><strong class="mr hu">data</strong> <strong class="mr hu">BlockHeader</strong> <strong class="mr hu">=</strong> <strong class="mr hu">BlockHeader</strong> {<br/>  _miner       <strong class="mr hu">::</strong> <strong class="mr hu">Account</strong>,<br/>  _parentHash  <strong class="mr hu">::</strong> <strong class="mr hu">HaskoinHash</strong>,<br/>  _nonce       <strong class="mr hu">::</strong> <strong class="mr hu">Integer</strong>,<br/>  _minedAt     <strong class="mr hu">::</strong> <strong class="mr hu">POSIXTime</strong><br/>  } <strong class="mr hu">deriving</strong> (<strong class="mr hu">Eq</strong>, <strong class="mr hu">Show</strong>)<br/><br/><em class="ke">-- Add serializers for POSIXTime</em><br/><strong class="mr hu">instance</strong> <strong class="mr hu">Binary</strong> <strong class="mr hu">POSIXTime</strong> <strong class="mr hu">where</strong><br/>  get <strong class="mr hu">=</strong> fromInteger <strong class="mr hu">&lt;$&gt;</strong> (get <strong class="mr hu">::</strong> <strong class="mr hu">Get</strong> <strong class="mr hu">Integer</strong>)<br/>  put x <strong class="mr hu">=</strong> put <strong class="mr hu">$</strong> (round x <strong class="mr hu">::</strong> <strong class="mr hu">Integer</strong>)<br/><br/>globalTransactionLimit <strong class="mr hu">=</strong> 1000<br/><br/>mineOn <strong class="mr hu">::</strong> <strong class="mr hu">TransactionPool</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">Account</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">Blockchain</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">IO</strong> <strong class="mr hu">Blockchain</strong><br/>mineOn pendingTransactions minerAccount parent <strong class="mr hu">=</strong> <strong class="mr hu">do</strong><br/>  ts <strong class="mr hu">&lt;-</strong> pendingTransactions<br/>  ts <strong class="mr hu">&lt;-</strong> return <strong class="mr hu">$</strong> validTransactions parent ts<br/>  ts <strong class="mr hu">&lt;-</strong> return <strong class="mr hu">$</strong> take globalTransactionLimit ts<br/>  loop ts 0<br/>  <strong class="mr hu">where</strong><br/>    validChain bc <strong class="mr hu">=</strong> difficulty bc <strong class="mr hu">&lt;</strong> desiredDifficulty parent<br/>    loop ts nonce <strong class="mr hu">=</strong> <strong class="mr hu">do</strong><br/>      now <strong class="mr hu">&lt;-</strong> getPOSIXTime<br/>      <strong class="mr hu">let</strong> header <strong class="mr hu">=</strong> <strong class="mr hu">BlockHeader</strong> {<br/>            _miner <strong class="mr hu">=</strong> minerAccount,<br/>            _parentHash <strong class="mr hu">=</strong> hashlazy <strong class="mr hu">$</strong> encode parent,<br/>            _nonce <strong class="mr hu">=</strong> nonce,<br/>            _minedAt <strong class="mr hu">=</strong> now<br/>            }<br/>          block <strong class="mr hu">=</strong> <strong class="mr hu">Block</strong> (<strong class="mr hu">V.</strong>fromList ts)<br/>          candidate <strong class="mr hu">=</strong> block <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> header parent<br/>      <strong class="mr hu">if</strong> validChain candidate<br/>        <strong class="mr hu">then</strong> return candidate<br/>        <strong class="mr hu">else</strong> loop ts (nonce<strong class="mr hu">+</strong>1)<br/><br/>difficulty <strong class="mr hu">::</strong> <strong class="mr hu">Blockchain</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">Integer</strong><br/>difficulty <strong class="mr hu">=</strong> undefined<br/><br/>desiredDifficulty <strong class="mr hu">::</strong> <strong class="mr hu">BlockChain</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">Integer</strong><br/>desiredDifficulty <strong class="mr hu">=</strong> undefined</span></pre><p id="4315" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">我们输入<code class="eh na nb nc mr b">loop</code>,不断增加计数器的值并获取时间，直到我们找到一个难度合适的候选人。一个<code class="eh na nb nc mr b">Blockchain</code>的实际困难只是它的hash转换成一个整数:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="ec5f" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">import</strong> Crypto.Number.Serialize(os2ip)<br/><br/>difficulty <strong class="mr hu">::</strong> <strong class="mr hu">Blockchain</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">Integer</strong><br/>difficulty bc <strong class="mr hu">=</strong> os2ip <strong class="mr hu">$</strong> (hashlazy <strong class="mr hu">$</strong> encode bc <strong class="mr hu">::</strong> <strong class="mr hu">HaskoinHash</strong>)</span></pre><p id="4001" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">我们怎么知道什么是正确的困难？首先，我们将计算最后100个数据块的平均数据块间隔时间:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="a7a4" class="mv lu ht mr b fv mw mx l my mz">numBlocksToCalculateDifficulty <strong class="mr hu">=</strong> 100<br/><br/>blockTimeAverage <strong class="mr hu">::</strong> <strong class="mr hu">BlockChain</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">NominalDiffTime</strong><br/>blockTimeAverage bc <strong class="mr hu">=</strong> average <strong class="mr hu">$</strong> zipWith (<strong class="mr hu">-</strong>) times (tail times)<br/>  <strong class="mr hu">where</strong><br/>    times <strong class="mr hu">=</strong> take numBlocksToCalculateDifficulty <strong class="mr hu">$</strong> map _minedAt <strong class="mr hu">$</strong> headers bc<br/><br/>headers <strong class="mr hu">::</strong> <strong class="mr hu">BlockChain</strong> <strong class="mr hu">-&gt;</strong> [<strong class="mr hu">BlockHeader</strong>]<br/>headers <strong class="mr hu">Genesis</strong> <strong class="mr hu">=</strong> <strong class="mr hu">[]</strong><br/>headers (<strong class="mr hu">_</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> x next) <strong class="mr hu">=</strong> x <strong class="mr hu">:</strong> headers next<br/><br/>average <strong class="mr hu">::</strong> (<strong class="mr hu">Foldable</strong> f, <strong class="mr hu">Num</strong> a, <strong class="mr hu">Fractional</strong> a, <strong class="mr hu">Eq</strong> a) <strong class="mr hu">=&gt;</strong> f a <strong class="mr hu">-&gt;</strong> a<br/>average xs <strong class="mr hu">=</strong> sum xs <strong class="mr hu">/</strong> (<strong class="mr hu">if</strong> d <strong class="mr hu">==</strong> 0 <strong class="mr hu">then</strong> 1 <strong class="mr hu">else</strong> d) <strong class="mr hu">where</strong> d <strong class="mr hu">=</strong> fromIntegral <strong class="mr hu">$</strong> length xs</span></pre><p id="337a" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">让我们设定10秒的目标时间。假设<code class="eh na nb nc mr b">blockTimeAverage bc</code>给出2秒，那么我们希望块的时间是5倍:<code class="eh na nb nc mr b">adjustmentFactor = targetTime / blockTimeAverage bc</code> = 5。这意味着我们只想接受最初接受的块中的<code class="eh na nb nc mr b">1/5</code>。</p><p id="1fc3" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">由于哈希是均匀分布的，所以原来哈希的<code class="eh na nb nc mr b">1/5</code>比<code class="eh na nb nc mr b">originalDifficulty / 5</code>少，这将是我们新的难点。<a class="ae jy" href="https://bitcoin.stackexchange.com/questions/855/what-keeps-the-average-block-time-at-10-minutes" rel="noopener ugc nofollow" target="_blank">比特币就是这么干的</a> : <code class="eh na nb nc mr b">difficulty = oldDifficulty * (2 weeks) / (time for past 2015 blocks)</code>。</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="ae57" class="mv lu ht mr b fv mw mx l my mz">genesisBlockDifficulty <strong class="mr hu">=</strong> 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF<br/>targetTime <strong class="mr hu">=</strong> 10<br/><br/><em class="ke">-- BEWARE: O(n * k), where k = numBlocksToCalculateDifficulty</em><br/>desiredDifficulty <strong class="mr hu">::</strong> <strong class="mr hu">Blockchain</strong> <strong class="mr hu">-&gt;</strong> <strong class="mr hu">Integer</strong><br/>desiredDifficulty x <strong class="mr hu">=</strong> round <strong class="mr hu">$</strong> loop x<br/>  <strong class="mr hu">where</strong><br/>    loop (<strong class="mr hu">_</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Genesis</strong>) <strong class="mr hu">=</strong> genesisBlockDifficulty<br/>    loop x<strong class="mr hu">@</strong>(<strong class="mr hu">_</strong> <strong class="mr hu">:&lt;</strong> <strong class="mr hu">Node</strong> <strong class="mr hu">_</strong> xs) <strong class="mr hu">=</strong> oldDifficulty <strong class="mr hu">/</strong> adjustmentFactor<br/>      <strong class="mr hu">where</strong><br/>        oldDifficulty <strong class="mr hu">=</strong> loop xs<br/>        adjustmentFactor <strong class="mr hu">=</strong> min 4.0 <strong class="mr hu">$</strong> targetTime `safeDiv` blockTimeAverage x</span></pre><p id="226e" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">以下是使用这些计算得出的一些最近的开采时间:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="fa64" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">&gt;</strong> exampleChain <strong class="mr hu">&lt;-</strong> testMining<br/><strong class="mr hu">&gt;</strong> exampleChain <strong class="mr hu">&lt;-</strong> mineOn (return <strong class="mr hu">[]</strong>) 0 exampleChain <em class="ke">-- Repeat a bunch of times</em><br/><strong class="mr hu">&gt;</strong> mapM_ print <strong class="mr hu">$</strong> map blockTimeAverage <strong class="mr hu">$</strong> chains exampleChain<br/>6.61261425s<br/>6.73220925s<br/>7.97893375s<br/>12.96145975s<br/>10.923974s<br/>9.59857375s<br/>7.1819445s<br/>2.2767425s<br/>3.2307515s<br/>7.215131s<br/>15.98277575s</span></pre><p id="07b5" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">他们在10s左右徘徊是因为<code class="eh na nb nc mr b">targetTime = 10</code>。</p><h1 id="9ef5" class="lt lu ht bd lv lw lx ly lz ma mb mc md iz me ja mf jc mg jd mh jf mi jg mj mk dt translated">坚持</h1><p id="3cb8" class="pw-post-body-paragraph kc kd ht kf b kg ml iu ki kj mm ix kl lb mn ko kp lc mo ks kt ld mp kw kx ky hm dt translated">我们将把区块链保存在磁盘上，并给人们3个工具:</p><ul class=""><li id="9a44" class="lf lg ht kf b kg kh kj kk lb lh lc li ld lj ky lk ll lm ln dt translated">挖掘区块和创建新链的工具</li><li id="3849" class="lf lg ht kf b kg lo kj lp lb lq lc lr ld ls ky lk ll lm ln dt translated">列出账户余额的工具</li></ul><p id="1d4d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">第一个工具是矿工:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="f0d2" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">{-# LANGUAGE NoImplicitPrelude, OverloadedStrings #-}</strong><br/><br/><strong class="mr hu">module</strong> Haskoin.Cli.Mine <strong class="mr hu">where</strong><br/><br/><strong class="mr hu">import</strong> Haskoin.Mining<br/><strong class="mr hu">import</strong> Haskoin.Serialization<br/><strong class="mr hu">import</strong> Haskoin.Types<br/><br/><strong class="mr hu">import</strong> Protolude<br/><strong class="mr hu">import</strong> System.Environment<br/><strong class="mr hu">import</strong> Data.Binary<br/><strong class="mr hu">import</strong> <strong class="mr hu">qualified</strong> Data.ByteString.Lazy <strong class="mr hu">as</strong> BSL<br/><strong class="mr hu">import</strong> System.Directory<br/><strong class="mr hu">import</strong> Prelude(read)<br/><br/>defaultChainFile <strong class="mr hu">=</strong> "main.chain"<br/>defaultAccount <strong class="mr hu">=</strong> "10"<br/><br/>main <strong class="mr hu">::</strong> <strong class="mr hu">IO</strong> ()<br/>main <strong class="mr hu">=</strong> <strong class="mr hu">do</strong><br/>  args <strong class="mr hu">&lt;-</strong> getArgs<br/>  <strong class="mr hu">let</strong> (filename, accountS) <strong class="mr hu">=</strong> <strong class="mr hu">case</strong> args <strong class="mr hu">of</strong><br/>        <strong class="mr hu">[]</strong> <strong class="mr hu">-&gt;</strong> (defaultChainFile, defaultAccount)<br/>        [filename] <strong class="mr hu">-&gt;</strong> (filename, defaultAccount)<br/>        [filename, account] <strong class="mr hu">-&gt;</strong> (filename, account)<br/>        <strong class="mr hu">_</strong> <strong class="mr hu">-&gt;</strong> panic "Usage: mine [filename] [account]"<br/>      swapFile <strong class="mr hu">=</strong> filename <strong class="mr hu">++</strong> ".tmp"<br/>      txnPool <strong class="mr hu">=</strong> return <strong class="mr hu">[]</strong><br/>      account <strong class="mr hu">=</strong> <strong class="mr hu">Account</strong> <strong class="mr hu">$</strong> read accountS<br/>  forever <strong class="mr hu">$</strong> <strong class="mr hu">do</strong><br/>    chain <strong class="mr hu">&lt;-</strong> loadOrCreate filename makeGenesis <strong class="mr hu">::</strong> <strong class="mr hu">IO</strong> <strong class="mr hu">Blockchain</strong><br/>    newChain <strong class="mr hu">&lt;-</strong> mineOn txnPool account chain<br/>    encodeFile swapFile newChain<br/>    copyFile swapFile filename<br/>    print "Block mined and saved!"<br/><br/>loadOrCreate <strong class="mr hu">::</strong> <strong class="mr hu">Binary</strong> a <strong class="mr hu">=&gt;</strong> <strong class="mr hu">FilePath</strong> <strong class="mr hu">-&gt;</strong> (<strong class="mr hu">IO</strong> a) <strong class="mr hu">-&gt;</strong> <strong class="mr hu">IO</strong> a<br/>loadOrCreate filename init <strong class="mr hu">=</strong> <strong class="mr hu">do</strong><br/>  exists <strong class="mr hu">&lt;-</strong> doesFileExist filename<br/>  <strong class="mr hu">if</strong> exists<br/>    <strong class="mr hu">then</strong> decodeFile filename<br/>    <strong class="mr hu">else</strong> <strong class="mr hu">do</strong><br/>      x <strong class="mr hu">&lt;-</strong> init<br/>      encodeFile filename x<br/>      return x</span></pre><p id="5921" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">第二个打印所有的账户余额</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="b96a" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">{-# LANGUAGE NoImplicitPrelude, OverloadedStrings #-}</strong><br/><br/><strong class="mr hu">module</strong> Haskoin.Cli.ListBalances <strong class="mr hu">where</strong><br/><br/><strong class="mr hu">import</strong> Haskoin.Mining<br/><strong class="mr hu">import</strong> Haskoin.Serialization<br/><strong class="mr hu">import</strong> Haskoin.Types<br/><br/><strong class="mr hu">import</strong> Protolude<br/><strong class="mr hu">import</strong> System.Environment<br/><strong class="mr hu">import</strong> Data.Binary<br/><strong class="mr hu">import</strong> <strong class="mr hu">qualified</strong> Data.Map <strong class="mr hu">as</strong> M<br/><strong class="mr hu">import</strong> <strong class="mr hu">qualified</strong> Data.ByteString.Lazy <strong class="mr hu">as</strong> BSL<br/><br/>defaultChainFile <strong class="mr hu">=</strong> "main.chain"<br/><br/>main <strong class="mr hu">::</strong> <strong class="mr hu">IO</strong> ()<br/>main <strong class="mr hu">=</strong> <strong class="mr hu">do</strong><br/>  args <strong class="mr hu">&lt;-</strong> getArgs<br/>  <strong class="mr hu">let</strong> (filename) <strong class="mr hu">=</strong> <strong class="mr hu">case</strong> args <strong class="mr hu">of</strong><br/>        <strong class="mr hu">[]</strong> <strong class="mr hu">-&gt;</strong> (defaultChainFile)<br/>        [filename] <strong class="mr hu">-&gt;</strong> (filename)<br/>        <strong class="mr hu">_</strong> <strong class="mr hu">-&gt;</strong> panic "Usage: list-balances [filename]"<br/>  chain <strong class="mr hu">&lt;-</strong> decodeFile filename <strong class="mr hu">::</strong> <strong class="mr hu">IO</strong> <strong class="mr hu">Blockchain</strong><br/>  forM_ (<strong class="mr hu">M.</strong>toAscList <strong class="mr hu">$</strong> balances chain) <strong class="mr hu">$</strong> <strong class="mr hu">\</strong>(account, balance) <strong class="mr hu">-&gt;</strong> <strong class="mr hu">do</strong><br/>    print (account, balance)</span></pre><p id="1380" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">这是它的输出:</p><pre class="jj jk jl jm fq mq mr ms mt aw mu dt"><span id="5481" class="mv lu ht mr b fv mw mx l my mz"><strong class="mr hu">$</strong> stack exec list<strong class="mr hu">-</strong>balances<br/>(<strong class="mr hu">Account</strong> 10,23000)</span></pre><p id="f780" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">显然，我已经开采了23个区块来测试<code class="eh na nb nc mr b">stack exec mine</code>。</p><h1 id="6ba4" class="lt lu ht bd lv lw lx ly lz ma mb mc md iz me ja mf jc mg jd mh jf mi jg mj mk dt translated">结论</h1><p id="1a21" class="pw-post-body-paragraph kc kd ht kf b kg ml iu ki kj mm ix kl lb mn ko kp lc mo ks kt ld mp kw kx ky hm dt translated">我们开发了一个简单的区块链数据结构。你可以在<a class="ae jy" href="https://github.com/MichaelBurge/haskoin" rel="noopener ugc nofollow" target="_blank"> Github </a>上浏览资源库。</p><p id="036c" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">未来与Haskoin相关的文章可能涵盖</p><ul class=""><li id="b3bf" class="lf lg ht kf b kg kh kj kk lb lh lc li ld lj ky lk ll lm ln dt translated">使用网络和并发原语建立对等网络。</li><li id="ce1b" class="lf lg ht kf b kg lo kj lp lb lq lc lr ld ls ky lk ll lm ln dt translated">保护钱包中的帐户，这样其他人就无法从您的帐户中转出资金。</li><li id="a20f" class="lf lg ht kf b kg lo kj lp lb lq lc lr ld ls ky lk ll lm ln dt translated">建立一个“区块链探险家”网站</li><li id="9c3b" class="lf lg ht kf b kg lo kj lp lb lq lc lr ld ls ky lk ll lm ln dt translated">GPU-加速我们的散列</li><li id="7bf7" class="lf lg ht kf b kg lo kj lp lb lq lc lr ld ls ky lk ll lm ln dt translated">FPGA-加速我们的哈希运算</li></ul><p id="b2b3" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl lb kn ko kp lc kr ks kt ld kv kw kx ky hm dt translated">未来的加密货币相关文章可能涵盖:</p><ul class=""><li id="cec5" class="lf lg ht kf b kg kh kj kk lb lh lc li ld lj ky lk ll lm ln dt translated">您可能听说过工作证明和利益证明。那么证据证明呢——矿工们竞相用适当的逻辑证明新的定理？</li><li id="1d1c" class="lf lg ht kf b kg lo kj lp lb lq lc lr ld ls ky lk ll lm ln dt translated">添加图灵完全脚本语言</li><li id="be9c" class="lf lg ht kf b kg lo kj lp lb lq lc lr ld ls ky lk ll lm ln dt translated">解析命令行选项的更好方法</li><li id="ba3f" class="lf lg ht kf b kg lo kj lp lb lq lc lr ld ls ky lk ll lm ln dt translated">建设比特币交易所</li></ul></div></div>    
</body>
</html>