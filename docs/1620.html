<html>
<head>
<title>Deploy Smart Contract with Web3js &amp; Account Private Key, No Truffle— Solidity Tutorial 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Web3js和帐户私钥部署智能合约，没有块菌—可靠性教程2</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/deploy-smart-contract-with-web3js-account-private-key-no-truffle-solidity-tutorial-2-5926fface340?source=collection_archive---------1-----------------------#2018-10-07">https://medium.com/coinmonks/deploy-smart-contract-with-web3js-account-private-key-no-truffle-solidity-tutorial-2-5926fface340?source=collection_archive---------1-----------------------#2018-10-07</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/606594ea3a93dcdc65307e713998ec3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vkgHiTkGjbf6dI57lZ4DiA.jpeg"/></div></div></figure><p id="7218" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在你读完我的<a class="ae jz" rel="noopener" href="/coinmonks/build-smart-contract-without-truffle-just-solcjs-solidity-tutorial-1-4434f98dbb18"> Solidity教程1 </a>之后，你就可以编译。将源代码解析到JSON文件中。/build/contracts/ folder。今天这个主题将涉及如何使用Web3js v0.20.7 (v1有一些不向后兼容的更改)将编译好的智能合约部署到以太坊区块链。</p><blockquote class="ka"><p id="7d41" class="kb kc ht bd kd ke kf kg kh ki kj jy ek translated"><a class="ae jz" href="https://coincodecap.com" rel="noopener ugc nofollow" target="_blank">发现并回顾最佳区块链软件</a></p></blockquote><p id="98ee" class="pw-post-body-paragraph jb jc ht jd b je kk jg jh ji kl jk jl jm km jo jp jq kn js jt ju ko jw jx jy hm dt translated">以下是我在教程2中的要点源代码:</p><figure class="kp kq kr ks fq iu"><div class="bz el l di"><div class="kt ku l"/></div></figure><p id="f48a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你需要包含一些包来部署一个智能合约到以太坊区块链。</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="e669" class="la lb ht kw b fv lc ld l le lf"><em class="lg">const</em> Web3 = require('web3');<br/><em class="lg">const</em> Tx = require('ethereumjs-tx');</span></pre><p id="ce76" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> ethereumjs-tx </strong>用于生成交易净荷数据。</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="0271" class="la lb ht kw b fv lc ld l le lf"><em class="lg">let</em> accounts = [<br/>{<br/>  // Ganache Default Accounts, do not use it for your production<br/>  // Develop 1<br/>  address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',<br/>  key: 'c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3'},</span><span id="a723" class="la lb ht kw b fv lh ld l le lf">...<br/>];</span></pre><p id="b077" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是我将用于将智能合同部署到区块链的客户列表。示例代码使用从Ganache生成的帐户作为我的私有测试网络。您可以将其替换为您的帐户钱包无地址和私钥，以部署智能合同。</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="9b4b" class="la lb ht kw b fv lc ld l le lf"><em class="lg">let</em> selectedHost = 'http://127.0.0.1:7545';</span></pre><p id="86d5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果要像Ropsten一样部署到主网&amp;测试网，请更改<strong class="jd hu">所选主机</strong>设置。我更喜欢使用<a class="ae jz" href="https://infura.io" rel="noopener ugc nofollow" target="_blank"> <strong class="jd hu"> Infura </strong> </a>进行部署，这样可以节省我设置自己的节点的时间。</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="18bf" class="la lb ht kw b fv lc ld l le lf"><em class="lg">let</em> gasPrice = web3.eth.gasPrice;<br/><em class="lg">let</em> gasPriceHex = web3.toHex(gasPrice);<br/><em class="lg">let</em> gasLimitHex = web3.toHex(6000000);<br/><em class="lg">let</em> nonce =  web3.eth.getTransactionCount(accounts[selectedAccountIndex].address, "pending");<br/><em class="lg">let</em> nonceHex = web3.toHex(nonce);</span></pre><p id="780a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> nonce </strong>是用于智能合约部署的帐户的交易计数，其值始终为last nonce + 1。<strong class="jd hu">汽油价格</strong> &amp; <strong class="jd hu">汽油限制</strong>是可选的。矿工将根据天然气价格确定将交易插入下一区块的优先级。</p><p id="48f9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<strong class="jd hu"> deployContract() </strong>函数中，我们需要从编译后的JSON文件中检索<strong class="jd hu"> abi </strong> &amp; <strong class="jd hu">字节码</strong>数据，以实例化部署用的契约对象，如下所示</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="0acb" class="la lb ht kw b fv lc ld l le lf">// Retrieve the ABI<br/><em class="lg">let</em> abi = jsonOutput['contracts'][contract][path.parse(contract).name]['abi'];</span><span id="584d" class="la lb ht kw b fv lh ld l le lf">// Retrieve the byte code<br/><em class="lg">let</em> bytecode = jsonOutput['contracts'][contract][path.parse(contract).name]['evm']['bytecode']['object'];</span><span id="48f6" class="la lb ht kw b fv lh ld l le lf"><em class="lg">let</em> tokenContract = web3.eth.contract(abi);</span></pre><p id="61c4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">之后，我们将向契约对象提供字节代码数据，以生成有效负载数据，并作为事务提交。</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="f899" class="la lb ht kw b fv lc ld l le lf">contractData = tokenContract.new.getData({<br/>  data: '0x' + bytecode<br/>});</span></pre><p id="caa5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果智能协定构造函数有输入参数，您可以像这样提供参数</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="5bec" class="la lb ht kw b fv lc ld l le lf">contractData = tokenContract.new.getData( param1, param2, ..., {<br/>  data: '0x' + bytecode<br/>});</span></pre><p id="d0e1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦有效载荷数据准备好了，就是我们用有效载荷数据、汽油价格、汽油限制&amp; nonce实例化事务对象的时候了。之后，我们需要用我们的私钥签名。</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="d100" class="la lb ht kw b fv lc ld l le lf"><em class="lg">let</em> rawTx = {<br/>  nonce: nonceHex,<br/>  gasPrice: gasPriceHex,<br/>  gasLimit: gasLimitHex,<br/>  data: contractData,<br/>  from: accounts[selectedAccountIndex].address<br/>};</span><span id="67b6" class="la lb ht kw b fv lh ld l le lf">// Get the account private key, need to use it to sign the transaction later.</span><span id="daa1" class="la lb ht kw b fv lh ld l le lf"><em class="lg">let</em> privateKey = new Buffer(accounts[selectedAccountIndex].key, 'hex')</span><span id="ef6a" class="la lb ht kw b fv lh ld l le lf"><em class="lg">let</em> tx = new Tx(rawTx);</span><span id="90a9" class="la lb ht kw b fv lh ld l le lf">// Sign the transaction<br/>tx.sign(privateKey);<br/><em class="lg">let</em> serializedTx = tx.serialize();</span></pre><p id="6097" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后一步，我们需要将签署的交易数据提交给区块链，以便进行合同创建/部署。</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="31c5" class="la lb ht kw b fv lc ld l le lf">web3.eth.sendRawTransaction('0x' + serializedTx.toString('hex'), (<em class="lg">err</em>, <em class="lg">hash</em>) <em class="lg">=&gt;</em> {</span><span id="a596" class="la lb ht kw b fv lh ld l le lf">...</span><span id="c069" class="la lb ht kw b fv lh ld l le lf">});</span></pre><p id="66eb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果<strong class="jd hu"> sendRawTransaction() </strong>成功，将返回一个事务哈希。我们需要使用事务哈希来检查事务是否被确认并成功挖掘到块中。</p><p id="45dc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦交易被确认，<strong class="jd hu"> getTransactionReceipt() </strong>将返回包含新合同地址的<strong class="jd hu">收据</strong>对象。</p><pre class="kp kq kr ks fq kv kw kx ky aw kz dt"><span id="6b06" class="la lb ht kw b fv lc ld l le lf">receipt = web3.eth.getTransactionReceipt(hash);</span><span id="f3d9" class="la lb ht kw b fv lh ld l le lf">...<br/><em class="lg">console</em>.log('Contract address: ' + receipt.contractAddress);</span></pre><p id="3565" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">希望本教程可以帮助你了解不使用Truffle部署智能合约的替代方法。</p></div></div>    
</body>
</html>