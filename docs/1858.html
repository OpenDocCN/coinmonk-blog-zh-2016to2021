<html>
<head>
<title>Chain replication: how to build an effective KV-storage (part 2/2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链式复制:如何构建高效的KV存储(下)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/chain-replication-how-to-build-an-effective-kv-storage-part-2-2-6c55eb9c63fd?source=collection_archive---------0-----------------------#2018-12-05">https://medium.com/coinmonks/chain-replication-how-to-build-an-effective-kv-storage-part-2-2-6c55eb9c63fd?source=collection_archive---------0-----------------------#2018-12-05</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="6c3f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们继续探索链复制用法的例子。基本术语和架构在<a class="ae jo" rel="noopener" href="/coinmonks/chain-replication-how-to-build-an-effective-kv-storage-part-1-2-b0ce10d5afc3">第一部分</a>中给出，我强烈建议在开始阅读第二部分之前阅读它。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/8dd65fccf56cb47474cedd1f6b94bd56.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*XjfI6UlB3yZ3NyRL-H64xg.jpeg"/></div></div></figure><p id="fe20" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本文中，我们将考虑:</p><ul class=""><li id="0876" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">Hibari —用Erlang写的分布式容错存储。</li><li id="7b27" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">HyperDex —分布式键值存储，通过第二属性和快速范围搜索进行快速搜索。</li><li id="ee59" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">连锁反应——因果+一致性和地理复制。</li><li id="67fc" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">如何构建一个没有外部集群管理过程的分布式系统？</li></ul><h1 id="811b" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">5.希巴里</h1><p id="7e5b" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">Hibari是用Erlang写的分布式容错KV-storage。它使用CR(基本方法),因此实现了很强的一致性。Hibari在测试中显示了高吞吐量，在2U机架式服务器上每秒钟可以更新数千次。</p><h2 id="4a2d" class="ls kq ht bd kr lt lu lv kv lw lx ly kz jb lz ma ld jf mb mc lh jj md me ll mf dt translated">5.1架构</h2><p id="aa91" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">Hibari使用一致散列法进行数据放置。存储由物理和逻辑块组成，其中物理块可以是linux服务器或EC2实例或任何虚拟机，而逻辑块是操作中使用的实际存储实例。每个逻辑块都是某个链的一部分。在下面的示例中，我们配置了一个群集，每个物理块放置2个逻辑断点，链长度为2。请注意，链节点放置在不同的物理砖块上，以增加容错能力。</p><p id="2b91" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">主进程(参见第一部分)被称为<em class="mg">管理服务器</em>。数据存储在表中(表只是作为名称空间)，每个表至少存储在一个链中，每个链只存储一个表。客户机从管理服务器接收每个链的头和尾，因此它们确切地知道将它们的请求发送到哪个逻辑块。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mh"><img src="../Images/c22ddd70a697e0e46acbf0c326a09c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gU6fmKSO-1ENgQ4EoM-Lg.png"/></div></div></figure><h2 id="d610" class="ls kq ht bd kr lt lu lv kv lw lx ly kz jb lz ma ld jf mb mc lh jj md me ll mf dt translated">5.2散列法</h2><p id="e2a0" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">Hibari使用元组{T，K}来确定哪个链存储表T中的密钥K:它将密钥K映射到[0.1，1.0]区间上(使用MD5)，该区间被划分为多个区域，每个区域代表某个链。根据不同的标准(例如，链条的重量)，区域可以有不同的宽度。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mi"><img src="../Images/42e3460af6e6e820534c1c741c5466ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_1KyBOCeIAkCnpNFqHq6PA.png"/></div></div></figure><p id="e91f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，更强大的物理砖块上的链可以被分配更宽的间隔(以处理更多命中)。</p><h1 id="adb7" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">6.超指数</h1><p id="1a10" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">HyperDex项目的目标不仅仅是构建一个分布式KV-storage，而是构建一个具有按秒属性快速搜索和按范围快速搜索的KV-storage(BigTable、Cassandra、Dynamo等系统无法做到这一点——它们必须为这种查询遍历所有节点)。HyperDex使用<em class="mg">超空间哈希</em>来实现。</p><h2 id="516f" class="ls kq ht bd kr lt lu lv kv lw lx ly kz jb lz ma ld jf mb mc lh jj md me ll mf dt translated">6.1架构</h2><p id="93bd" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">超空间哈希的想法并不新鲜——它只是一个n维空间，其中每个属性对应一个坐标轴。例如，对于对象(名字、姓氏、电话号码),空格可以这样显示:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mj"><img src="../Images/d202fe4bc7b115ab409af5e3460d0d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aHK_5Zxerw-nB68WAvlNMg.png"/></div></div></figure><p id="4849" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">灰色超平面穿过姓氏= Smith的所有键，黄色-名字= John的所有键。查询“GET phone-number WHERE first-name = John AND second-name = Smith”的结果是灰色和黄色超平面的交集。这意味着具有k个属性的查询返回(n — k)维子空间。</p><p id="9611" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">搜索空间被分成n维不相交的区域，并且每个区域被分配给一个节点(因此来自该区域的所有对象都被存储在该节点上)。这在对象和节点之间创建了一个散列。</p><p id="cc77" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">搜索查询(甚至范围一)确定结果超平面的区域，因此查询将只通过那些区域，而不是通过所有节点。</p><p id="8d1c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这种方法有一个问题——所需节点的数量随着属性的数量呈指数增长k: O(2 ^ k)。为了处理它，HyperDex将多维空间分割成具有较低维度和较小属性子集的子空间:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mk"><img src="../Images/4c6e4fdf101cb86d1ff807639da90431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KE9oMKT30hBXbnDw_Pm2jw.png"/></div></div></figure><h2 id="dcc6" class="ls kq ht bd kr lt lu lv kv lw lx ly kz jb lz ma ld jf mb mc lh jj md me ll mf dt translated">6.2复制</h2><p id="53a3" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">作者开发了一种基于链复制的新方法来提供强一致性，称为<em class="mg">值相关链</em>，其中每个下一个节点由相应属性的散列来确定。例如，一个键(“John”、“Smith”)将首先被散列到<em class="mg">键空间</em>(这给了我们一个链头，称为<em class="mg">点头</em>)，然后“John”的散列给出相应轴上的坐标，等等。(见下图)。</p><p id="6db2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所有更新都通过强制线性化的点引导。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff ml"><img src="../Images/bb00de1268f8bd536a66804fc4c8bdef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Igg0kVtpyt71Hkkld1iB_w.png"/></div></div></figure><p id="129e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果一个更新导致一个区域改变，那么首先在旧版本之后立即写入新版本(参见更新u2)，然后一旦从尾部接收到ACK，从先前节点到旧版本的链路将被改变(参见更新u3)。为了防止并发更新(r1和r2)破坏一致性，点领导者将版本控制和其他元数据添加到请求中，以便节点在接收到r2时可以确定它们必须等待r1首先到达。</p><h1 id="6558" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">7.连锁反应</h1><p id="96fa" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">ChainReaction使用因果+一致性模型，这是因果一致性模型加上副本不需要仲裁器收敛的要求。具有所有因果相关关键字版本的元数据被添加到所有请求中，以提供因果+一致性，ChainReactions允许我们在几个数据中心进行地理复制，这是CRAQ的进一步发展。</p><h2 id="e5eb" class="ls kq ht bd kr lt lu lv kv lw lx ly kz jb lz ma ld jf mb mc lh jj md me ll mf dt translated">7.1架构</h2><p id="614e" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">它基于FAWN架构，略有改动:</p><ul class=""><li id="9565" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">每个数据中心都有<em class="mg">数据服务器</em>——后端(存储数据，提供复制)创建DHT环。</li><li id="ed48" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated"><em class="mg">客户端代理</em> —前端(将请求重定向到适当的节点)。</li></ul><p id="b139" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每个密钥被复制到R个后续节点上，从而创建了一个链。读请求由尾部处理，写请求由头部处理。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mm"><img src="../Images/39e385128165451746580ed842c09ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_422v9CPb_SClmdlXk9GQ.png"/></div></div></figure><h2 id="3172" class="ls kq ht bd kr lt lu lv kv lw lx ly kz jb lz ma ld jf mb mc lh jj md me ll mf dt translated">7.2单一数据中心</h2><p id="d251" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">必须注意一个非常重要的属性——如果节点<em class="mg"> k </em>与一些客户端请求是因果一致的，那么在<em class="mg"> k </em>之前的所有节点也是因果一致的(根据链复制的设计)。这意味着如果我们知道已经在节点<em class="mg"> k </em>上观察到请求<em class="mg"> Req </em>，那么所有与因果相关的读取请求(属于<em class="mg"> Req </em>)只能在节点【head，..，k】。在尾巴已经执行了Req 之后，就没有这种限制了。</p><p id="02f2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们将数据中心中由tail处理的所有写请求<em class="mg"> d </em>表示为<strong class="is hu"> DC写稳定(d)。</strong></p><p id="903f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每个客户端维护一个列表(<em class="mg">元数据</em>)，该列表包含它已经请求的所有关键字，格式如下:<em class="mg"> (keyN，version，chainIndex) </em>，其中chainIndex是一个标识符，它捕获节点的链位置，该节点处理并回复客户端对元数据所涉及的关键字的最后请求。<strong class="is hu">客户端仅存储那些客户端未知的键的元数据，不管它们是否是DC写稳定的(d)。</strong></p><p id="23d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 7.2.1执行写操作</strong></p><p id="53c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们注意到，一旦对key <em class="mg"> keyN </em>的写请求变为DC写稳定(d ),任何其他读请求都不能返回先前版本的keyN 。</p><p id="f120" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">自上一次写入以来已对其执行读取请求的所有键的列表被添加到下一次写入请求中。客户端代理在接收到写请求时，对相应链尾部的每个键执行阻塞读请求(等待相同或更新版本的确认，换句话说，提供因果一致性)。一旦接收到所有确认，客户端代理就向相应链的头发送写请求。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mn"><img src="../Images/cfb134a98354b0d94eca82e66ff87f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBpjoNgC0bnLtjkBroM_Qg.png"/></div></div></figure><p id="b498" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一旦新值被保存在第一个<em class="mg"> k </em>节点上，客户端代理就向客户端发送通知，并且在剩余链节点上的更新以懒惰模式继续<em class="mg">(懒惰传播</em> ) —因此，优先级被给予第一个<em class="mg"> k </em>节点上的写请求。客户端更新chainIndex(到<em class="mg"> k </em>)并删除发送的键的元数据——因为现在我们知道它们是DC写稳定的(d)。一旦tail处理了请求，它就向链节点发送一个通知，以便它们将值标记为稳定，并向客户端发送一个通知，以便它可以更新密钥的版本。</p><p id="c953" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 7.2.2执行读取操作</strong></p><p id="d8b7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">客户端代理通过向<em class="mg"> nodeIndex = rand(1，chainIndex) </em>发送读取请求来执行负载分配。在响应中，节点发送该值和该值的版本。客户端代理检查响应并向客户端发送数据，此外:</p><ul class=""><li id="fd2a" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">如果版本稳定，那么<em class="mg"> chainIndex =链的长度</em></li><li id="32a9" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">或者版本是否更新— <em class="mg"> chainIndex = index </em></li><li id="b62c" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">否则，chainIndex保持不变。</li></ul><p id="ad74" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 7.2.3应对故障</strong></p><p id="3ea9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">与链复制基本方法中的方式相同，但在某些情况下，chainIndex在客户端变得无效(例如，当节点已从链中移除时)，这种情况很容易检测到(在节点上缺少具有这种版本的这种密钥)，并且为了处理它们，请求仅被路由到头部。</p><h2 id="224a" class="ls kq ht bd kr lt lu lv kv lw lx ly kz jb lz ma ld jf mb mc lh jj md me ll mf dt translated">7.3.多个数据中心(地理复制)</h2><p id="0be6" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">我们将使用来自单DC设置的算法，并做最小的修改。首先，在元数据中，我们需要大小为N的版本向量，而不是标量版本和标量链接索引。</p><p id="52f6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">此外，我们将以类似于DC写稳定(d)的方式来表示全局写稳定:如果写请求<em class="mg"> Req </em>在所有数据中心的所有尾部上执行，则称其为全局写稳定。我们还将在所有DC中添加一个新组件— <em class="mg"> remote_proxy </em>，它负责从其他DC接收更新，或者向其他DC发送更新。</p><p id="397e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 7.3.1执行写操作(在服务器的<em class="mg">上)</em></strong></p><p id="62a4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它以与单DC设置相同的方式启动—执行阻塞读取并更新前<em class="mg"> k </em>节点上的值。然后client-proxy向客户端发送一个带有版本向量的响应，其中所有位置都是0，但ith的值为k。最后还有一个额外的操作是将更新发送到remote_proxy，它累积几个更新，然后发送它们。</p><p id="b1f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里我们可以观察到两个问题:</p><ul class=""><li id="8c78" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">解决从不同DC发出的不同操作之间的依赖性<br/>每个remote_proxy维护一个称为<em class="mg"> rvp </em>的大小为N的本地版本向量，该向量存储发送和接收操作的计数器，并且它在所有更新中被发送到其他DC。这样，当远程代理从另一个远程代理接收到更新时，它将本地rvp与远程rvp进行比较，如果本地计数器小于远程，则操作被阻塞，直到接收到错过的更新。</li><li id="2d3f" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">解析给定操作在其他DC中的依赖关系？布隆过滤器被用来实现这一点。客户端代理为每个读/写请求的响应中的每个密钥发送一个布隆过滤器(称为<em class="mg">回复过滤器)</em>。这些过滤器由客户端存储在<em class="mg">访问对象</em>字段中，并且作为所有过滤器的结果过滤器(称为<em class="mg">依赖性过滤器</em>)由客户端作为每个读/写请求中的元数据的一部分发送。和以前一样，过滤器在请求完成后被删除。回复和依赖过滤器与rvp一起发送到其他DC。<br/>远程DC在接收到所有数据时检查回复过滤器中的设置位是否与依赖性过滤器中的设置位相同。如果是，那么这样的请求可能是因果相关的。(它们只是潜在相关，因为bloom filter没有给出100%的可能性)。</li></ul><p id="058a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 7.3.2执行读取操作</strong></p><p id="72d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它与单DC设置中一样执行，但使用矢量链索引而不是标量。在DC中有可能缺少密钥(因为操作是异步的)—在这种情况下，我们要么等待它，要么将请求重定向到另一个DC。</p><p id="118b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 7.3.3冲突解决</strong></p><p id="0ed7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于元数据的原因，与因果相关的请求以正确的顺序执行(尽管有时我们会阻塞这个过程)。不幸的是，不同DC中的并发更新会导致冲突。为了解决这种冲突，建议在每次更新时使用对<em class="mg"> (c，s) </em>的最后写入获胜策略，其中<em class="mg"> c </em>是client_proxy上的挂钟，而<em class="mg"> s </em>是DC的id。</p><p id="8ad8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 7.3.4故障处理</strong></p><p id="5cd5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">类似于单DC设置。</p><h1 id="8680" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">8.在可伸缩复制协议的设计中利用分片</h1><p id="1455" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">这项研究的目标是开发一个具有分片和复制功能的分布式系统<strong class="is hu">，而不需要</strong>使用任何外部主进程进行集群监控/重新配置。</p><p id="c30e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">作者认为当前方法存在以下局限性:</p><p id="2e1b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">复制:</p><ul class=""><li id="a624" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">主/备份—当主服务器被错误地标记为有故障时，会导致不一致的状态。</li><li id="8d13" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">仲裁交集—在重新配置期间可能导致不一致的状态。</li></ul><p id="30dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">高度一致性:</p><ul class=""><li id="23d7" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">现代协议依赖于多数表决算法(如Paxos)，其中需要2 * N + 1个节点来容忍N个节点的故障。</li></ul><p id="a100" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">故障检测:</p><ul class=""><li id="985a" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">P/B和CR假设对故障停止节点进行理想检测，但这在实践中是不现实的。</li><li id="6aae" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">ZooKeeper也有同样的问题——当有很多客户端时，客户端需要太多时间(&gt; 1秒)来重新加载配置。</li></ul><p id="371d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">被称为“弹性复制”的所提出的算法没有提到的限制，并且还提供以下好处:</p><ul class=""><li id="9318" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">一致性强。</li><li id="10c3" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">有N + 1容忍N个故障就够了。</li><li id="2a07" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">重新配置而不失去一致性。</li><li id="ddee" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">不需要多数表决算法。</li></ul><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mo"><img src="../Images/53482c76921342c4c88e91981e9123e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1hL79mAytA-33L0-1bKXg.png"/></div></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">For example, new configuration doesn’t have a faulty replica:summary</figcaption></figure><h2 id="3493" class="ls kq ht bd kr lt lu lv kv lw lx ly kz jb lz ma ld jf mb mc lh jj md me ll mf dt translated">8.1副本</h2><p id="6c13" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">我们在每个分片上定义了一系列配置:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/cf1dcd488658bd32b449817ed3e8fc30.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*SwckflfXQkQC4iu38sqs0g.png"/></div></figure><p id="9191" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">例如，新配置没有错误的副本:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/83d22cb9b31d370eb962d26cf81337a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*QdCzBk0eltPDzSPk0FZWMQ.png"/></div></figure><p id="dd03" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">配置序列中的每个元素都有:</p><ul class=""><li id="4495" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">副本—一组副本。</li><li id="79c7" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">orderer —具有特殊角色的特殊副本的id(见下文)。</li></ul><p id="7d0f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每个碎片被表示为一个副本的集合(因此我们不区分“碎片”和“副本”)</p><p id="9f61" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每个副本存储以下数据:</p><ul class=""><li id="8d97" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">配置—当前副本的配置id。</li><li id="1b8f" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">订购者—哪个副本是此配置的订购者。</li><li id="5b5a" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">模式—复制副本的模式，可以是以下三种模式之一:待定(所有复制副本来自非C1)、活动(所有复制副本来自C1)、不可变。</li><li id="e6b1" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">历史记录—对副本数据的操作序列(可能只是滑动状态)。</li><li id="5a6a" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">稳定-此复本提交的历史前缀的最大长度。显而易见的是:</li></ul><p id="a3f3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">订购者副本的主要工作是向其他副本发送请求，并维护副本中最长的前缀。</p><h2 id="9448" class="ls kq ht bd kr lt lu lv kv lw lx ly kz jb lz ma ld jf mb mc lh jj md me ll mf dt translated">8.2碎片</h2><p id="6112" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">碎片被组合在一起，形成称为<em class="mg">松紧带</em>的环。每个碎片只属于一个弹力带。每个碎片的前身扮演一个特殊的角色，被称为<em class="mg">序列器</em>。如果出现故障，定序器会为其后继者生成新的配置。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/0a31ddccfe613e9eb559f31e7ecd1b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*IRXOPZymLnBWDi0ida6iHA.png"/></div></figure><p id="2135" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">必须满足两个要求:</p><ul class=""><li id="bd2a" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">在每个弹性带中至少有一个具有一个活动副本的碎片。</li><li id="54f3" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">在每个弹性带中至少有一个碎片是无缺陷的复制品。</li></ul><p id="1d3d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后一个要求似乎很强，但是，它相当于一个“传统的”要求“绝不能有错误的主过程”。</p><h2 id="e7c2" class="ls kq ht bd kr lt lu lv kv lw lx ly kz jb lz ma ld jf mb mc lh jj md me ll mf dt translated">8.3链式复制</h2><p id="cf77" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hm dt translated">正如您所看到的，复制品形成了一个链(基本方法),其中订购者是头，但是，有一个小的区别:</p><ul class=""><li id="3e27" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">CR从链中删除一个有故障的节点，而ER只是创建一个新的链。</li><li id="9757" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">在CR中，读请求由尾部提供服务，在ER的情况下，它们必须从头开始遍历整个链(以提供强一致性)。</li></ul><h2 id="7822" class="ls kq ht bd kr lt lu lv kv lw lx ly kz jb lz ma ld jf mb mc lh jj md me ll mf dt translated">8.4出现故障时的重新配置</h2><ul class=""><li id="5b87" class="kb kc ht is b it ln ix lo jb mu jf mv jj mw jn kg kh ki kj dt translated">复制品不仅由同一碎片的复制品来监控，而且由定序器的复制品来监控。</li><li id="378a" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">一旦检测到故障，就会向副本服务器发送通知。</li><li id="2b3f" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">定序器发布新的配置(没有错误的副本)。</li><li id="ba53" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">一个新的复制品被创建，它将自己的状态与弹性带同步。</li><li id="1862" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">定序器使用新的副本发布新的配置。</li></ul><h1 id="8207" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">参考</h1><ul class=""><li id="4860" class="kb kc ht is b it ln ix lo jb mu jf mv jj mw jn kg kh ki kj dt translated"><a class="ae jo" href="https://https//dl.acm.org/citation.cfm?id=1863515dl.acm.org/citation.cfm?id=1863515" rel="noopener ugc nofollow" target="_blank">希巴里</a></li><li id="3b55" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated"><a class="ae jo" href="https://hyperdex.orgerdex.org/" rel="noopener ugc nofollow" target="_blank">hyperdex.orgerdex.org</a></li><li id="08d0" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated"><a class="ae jo" href="https://www.cs.cornell.edu/people/egs/papers/hyperdex-sigcomm.pdf" rel="noopener ugc nofollow" target="_blank"> HyperDex:一个分布式的、可搜索的键值存储</a></li><li id="6d69" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated"><a class="ae jo" href="https://dl.acm.org/citation.cfm?id=2465361" rel="noopener ugc nofollow" target="_blank">连锁反应</a></li><li id="a1e5" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated"><a class="ae jo" href="https://ymsir.com/papers/sharding-socc.pdf" rel="noopener ugc nofollow" target="_blank">在可扩展复制协议的设计中利用分片技术</a></li></ul><blockquote class="mx"><p id="ed4d" class="my mz ht bd na nb nc nd ne nf ng jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="ni nj nk nl nm ju fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nh"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="jq jr js jt fq ju fe ff paragraph-image"><a href="http://bit.ly/2G71Sp7"><div class="fe ff nn"><img src="../Images/449450761cd76f44f9ae574333f9e9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKX2mtg7p1lOs7JmosPLsA.png"/></div></a><figcaption class="mp mq fg fe ff mr ms bd b be z ek"><a class="ae jo" href="http://bit.ly/2G71Sp7" rel="noopener ugc nofollow" target="_blank"><strong class="bd no">Click to read today’s top story</strong></a></figcaption></figure></div></div>    
</body>
</html>