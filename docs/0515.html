<html>
<head>
<title>Attackers can steal all of Ether in ROC (Rasputin Online Coin) token smart contract (CVE-2018–10944)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">攻击者可以窃取ROC (Rasputin Online Coin)令牌智能合约(CVE-2018–10944)中的所有乙醚</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/attackers-can-steal-all-of-ether-in-roc-rasputin-online-coin-token-smart-contract-ae928b4a935a?source=collection_archive---------10-----------------------#2018-05-14">https://medium.com/coinmonks/attackers-can-steal-all-of-ether-in-roc-rasputin-online-coin-token-smart-contract-ae928b4a935a?source=collection_archive---------10-----------------------#2018-05-14</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><h1 id="7ede" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">摘要</h1><p id="ab2f" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我发现了一个ROC(又名Rasputin Online Coin)智能合约的漏洞，一个以太坊ERC20令牌(<a class="ae km" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-10944" rel="noopener ugc nofollow" target="_blank"><strong class="jq hu">CVE-2018–10944</strong></a>)<a class="ae km" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-10944" rel="noopener ugc nofollow" target="_blank">【1】</a>。<em class="kn"> request_dividend() </em>函数有一个类似于<strong class="jq hu">重入攻击</strong>的严重bug。攻击者可以多次调用该函数来不断窃取以太，直到耗尽所有契约的以太。</p><h1 id="c414" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">细节</h1><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ko"><img src="../Images/3af838ac8f27a91e6a516b589cb37726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNZP3CtxsyrjYCa-n7n1NA.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Figure 1. Source code of the request_dividend() function</figcaption></figure><p id="4508" class="pw-post-body-paragraph jo jp ht jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hm dt translated">图1显示了<em class="kn"> request_dividend() </em>函数<a class="ae km" href="https://etherscan.io/address/0x1bcbc54166f6ba149934870b60506199b6c9db6d#code" rel="noopener ugc nofollow" target="_blank">【2】</a>的源代码。首先，这个函数使用作为函数参数的<code class="eh lj lk ll lm b">token_holder</code>的余额来计算<code class="eh lj lk ll lm b">holder_token_balance</code>和<code class="eh lj lk ll lm b">holder_profit</code>。然后，它向<code class="eh lj lk ll lm b">token_holder</code>发送和<code class="eh lj lk ll lm b">holder_profit</code>一样多的乙醚。然而，在传输前后,<code class="eh lj lk ll lm b">token_holder</code>的平衡不会降低。这意味着我们可以一次又一次地向<code class="eh lj lk ll lm b">token_holder</code>发送相同数量的乙醚，直到合同中的乙醚全部耗尽。而且，<em class="kn"> request_dividend() </em>函数被声明为public，没有权限检查，所以任何人都可以调用这个函数，将契约的以太发送到任何地址。</p><h2 id="c6d2" class="ln ir ht bd is lo lp lq iw lr ls lt ja jz lu lv je kd lw lx ji kh ly lz jm ma dt translated">攻击者能做什么？</h2><p id="76e3" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">攻击者可以通过反复调用<em class="kn"> request_dividend() </em>函数来获取所有的契约以太。他们所要做的就是购买一些ROC令牌，并使用他们的帐户地址调用<em class="kn"> request_dividend() </em>函数。攻击者可以通过无限调用该函数来获取所有的契约以太。</p><h2 id="7556" class="ln ir ht bd is lo lp lq iw lr ls lt ja jz lu lv je kd lw lx ji kh ly lz jm ma dt translated">为什么会这样？</h2><p id="d03f" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我不确定他们为什么这样实现<em class="kn"> request_dividend() </em>函数。在我看来，这里有两个错误。</p><p id="a609" class="pw-post-body-paragraph jo jp ht jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hm dt translated">首先，<em class="kn"> request_dividend() </em>函数不检查之前有多少乙醚被转移到特定地址。因此，request_dividend()函数发送相同数量的以太网，即使多次使用相同的地址调用它。与<strong class="jq hu">重入攻击</strong>类似，因<a class="ae km" href="https://blog.ethereum.org/2016/06/17/critical-update-re-dao-vulnerability/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hu">道攻击</strong>【3】</a>而广为人知。一种解决方法是在函数的某处减少<code class="eh lj lk ll lm b">token_holder</code>的平衡。在DAO攻击之后，开发人员通常会在传输之前插入减少帐户余额的代码。</p><p id="dfa2" class="pw-post-body-paragraph jo jp ht jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hm dt translated">第二，<em class="kn"> request_dividend() </em>函数中没有权限检查。它被声明为public，也没有对<code class="eh lj lk ll lm b">msg.sender</code>的检查。因此，任何人都可以用任何地址调用该函数。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff mb"><img src="../Images/36d1973b75e9e593fe16909c82192104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lFvZ0TPsiIMTfNqzZIxP0w.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Figure 2. fallback function of the contract</figcaption></figure><p id="ea86" class="pw-post-body-paragraph jo jp ht jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hm dt translated">图2显示了契约的回退功能。在回退函数中，当<code class="eh lj lk ll lm b">msg.sender</code>为<code class="eh lj lk ll lm b">owner</code>时，执行<em class="kn"/><em class="kn">request _ dividend()</em>函数。从这段代码中，我猜测开发人员打算设计只有所有者才能调用的<em class="kn"> request_dividend() </em>函数。但是，他们忘记了函数的可见性，比如<em class="kn">内部的</em>，以及权限检查，所以导致了一个严重的bug。</p><h1 id="4ca7" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">毁坏</h1><p id="7a01" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">幸运的是，这个智能契约没有任何以太，因此没有攻击者可以窃取的以太。然而，攻击者不断地监视合同，然后只要有人向合同发送以太网，他们就可以窃取以太网。可悲的是，但幸运的是，ROC令牌不是有前途的令牌(它还没有在任何交易所上市)，所以我预计不会有用户向ROC令牌的智能合约发送以太网。</p><h1 id="8479" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">报告</h1><p id="1908" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我曾试图向Rasputin在线硬币的管理员报告此事。但是他们的<a class="ae km" href="https://ico.rasputinonline.com/" rel="noopener ugc nofollow" target="_blank"> ICO官网</a>宕机了，我找不到负责智能合约的邮箱。我在<a class="ae km" href="https://www.rasputinmansion.com/" rel="noopener ugc nofollow" target="_blank"><em class="kn">https://www.rasputinmansion.com/</em></a><em class="kn"/>找到了一封邮件<em class="kn">livesupport@verotel.com</em>发了一封邮件但是没有回应。因此，我建议不要购买这个令牌，直到它是固定的。</p><h1 id="e122" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">结论</h1><p id="6673" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">开发人员在实现传递以太的函数时应该小心，因为一个小错误可能会导致严重的问题，比如这个bug和DAO攻击。他们应该考虑谁是函数的调用者，并仔细检查帐户的余额和重复传输的可能性。最后，购买没有完全验证的加密硬币是很危险的。</p><h1 id="b6ea" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">参考</h1><ul class=""><li id="7b24" class="mc md ht jq b jr js jv jw jz me kd mf kh mg kl mh mi mj mk dt translated">[1]<a class="ae km" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-10944" rel="noopener ugc nofollow" target="_blank">http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-10944 </a></li><li id="261f" class="mc md ht jq b jr ml jv mm jz mn kd mo kh mp kl mh mi mj mk dt translated">[2]<a class="ae km" href="https://etherscan.io/address/0x1bcbc54166f6ba149934870b60506199b6c9db6d#code" rel="noopener ugc nofollow" target="_blank">https://ethers can . io/address/0x 1 bcbc 54166 f 6 ba 149934870 b 60506199 b 6 c 9 db 6d # code</a></li><li id="ebdc" class="mc md ht jq b jr ml jv mm jz mn kd mo kh mp kl mh mi mj mk dt translated">[3]<a class="ae km" href="https://blog.ethereum.org/2016/06/17/critical-update-re-dao-vulnerability/" rel="noopener ugc nofollow" target="_blank">https://blog . ether eum . org/2016/06/17/critical-update-re-Dao-vulnerability/</a></li></ul></div></div>    
</body>
</html>