<html>
<head>
<title>Math in Solidity (Part 5: Exponent and Logarithm)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实的数学(第五部分:指数和对数)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/math-in-solidity-part-5-exponent-and-logarithm-9aef8515136e?source=collection_archive---------0-----------------------#2020-04-02">https://medium.com/coinmonks/math-in-solidity-part-5-exponent-and-logarithm-9aef8515136e?source=collection_archive---------0-----------------------#2020-04-02</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="92bc" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">本文是关于扎实做数学系列文章的第五篇。这次的题目是:指数和对数。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/c0b1297abb16f4bf29a2e3d56d11fd47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*So3HRpMLOQwd-rxeI8rHjQ.jpeg"/></div></div></figure><h1 id="a042" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">介绍</h1><p id="1658" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">几个世纪以来，对数被用来简化计算。在电子计算器普及之前，计算尺，基于对数的机械计算器，是工程师职业的象征。</p><p id="2f6f" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">对数函数与指数函数(对数函数的反函数)一起允许将乘法转换为加法，更重要的是，将指数转换为乘法。由于以下两条规则，这是可能的:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/8ce56400c9563429a7c9dd8c8686db9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*a92EPKVtOcfGSyEyNugIXA.png"/></div></figure><p id="2a1c" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">对这些方程的左右部分求幂后，我们得到:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/d7a44ef80e3a2d18a40dfb7784c4f311.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*QlLjNP7TLw-mDjs-FO5FgA.png"/></div></figure><p id="b998" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">注意，这些公式适用于任意正基数<strong class="ko hu"> <em class="lp"> b </em> </strong>除此之外，我们可以选择便于实现的基数。</p><p id="e969" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">在本文中，我们将展示如何在Solidity中高效实现以2为底的对数和指数函数，如何将这些以2为底的函数转化为相应的自然函数(base <strong class="ko hu"> <em class="lp"> e </em> </strong>)，以及这些函数在DeFi应用中的真实用例。</p><p id="57ac" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">所以本文的重点是<strong class="ko hu">指数和对数</strong>。</p><h1 id="8c59" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">对数</h1><p id="72b5" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">让我们从二进制(以2为底)对数开始。<strong class="ko hu"> <em class="lp"> x </em> </strong>的二进制对数，就是值<strong class="ko hu"> <em class="lp"> y </em> </strong>这样:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/0dce57d8685953724009a0b96a5d1b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:242/format:webp/1*wVQEDuf-Z4Sj9fPKG7Ddqg.png"/></div></figure><p id="e54f" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">显然，<strong class="ko hu"> <em class="lp"> x </em> </strong>的值必须为正，y  才能存在。</p><p id="7a6a" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">注意，如果</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/e794673c9623b460361f27fd4beb04f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*gKJI7g6ka42C6wSrLurbPw.png"/></div></figure><p id="7d9b" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">然后</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/5954e2061ce8b8613a66db8a19461c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*7xHMPV3bwbjhJjJPE9PVVQ.png"/></div></figure><p id="1e11" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">所以<strong class="ko hu"> <em class="lp"> n </em> </strong>是<strong class="ko hu"> <em class="lp"> x </em> </strong>的二进制对数的整数部分。因此，我们的第一个问题是:</p><h2 id="0d84" class="lt jv ht bd jw lu lv lw ka lx ly lz ke kv ma mb kg kz mc md ki ld me mf kk mg dt translated">Solidity中二进制对数的整数部分怎么算？</h2><blockquote class="mh mi mj"><p id="3f15" class="km kn lp ko b kp li iu kr ks lj ix ku mk lk kx ky ml ll lb lc mm lm lf lg lh hm dt translated">剧透:右移计数。</p></blockquote><p id="f13c" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">以下是适用于正整数<strong class="ko hu"> <em class="lp"> x </em> </strong>的简单方法:</p><pre class="jj jk jl jm fq mn mo mp mq aw mr dt"><span id="4adb" class="lt jv ht mo b fv ms mt l mu mv">for (n = 0; x &gt; 1; x &gt;&gt;= 1) n += 1;</span></pre><p id="4f3b" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">虽然这种方法简单明了，但由于其气体消耗为O(n ),因此相当昂贵。以下是适用于256位正整数<strong class="ko hu"> <em class="lp"> x </em> </strong>的改进版本:</p><pre class="jj jk jl jm fq mn mo mp mq aw mr dt"><span id="7464" class="lt jv ht mo b fv ms mt l mu mv">if (x &gt;= 2**128) { x &gt;&gt;= 128; n += 128; }<br/>if (x &gt;= 2**64) { x &gt;&gt;= 64; n += 64; }<br/>if (x &gt;= 2**32) { x &gt;&gt;= 32; n += 32; }<br/>if (x &gt;= 2**16) { x &gt;&gt;= 16; n += 16; }<br/>if (x &gt;= 2**8) { x &gt;&gt;= 8; n += 8; }<br/>if (x &gt;= 2**4) { x &gt;&gt;= 4; n += 4; }<br/>if (x &gt;= 2**2) { x &gt;&gt;= 2; n += 2; }<br/>if (x &gt;= 2**1) { /* x &gt;&gt;= 1; */ n += 1; }</span></pre><p id="00f7" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">这种改进的实现在最坏的情况下消耗大约600汽油:比原始的、未优化的实现少25倍。</p><p id="8314" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">到目前为止还不错，但是</p><h2 id="967a" class="lt jv ht bd jw lu lv lw ka lx ly lz ke kv ma mb kg kz mc md ki ld me mf kk mg dt translated">如果X是分数呢？</h2><blockquote class="mh mi mj"><p id="7c5a" class="km kn lp ko b kp li iu kr ks lj ix ku mk lk kx ky ml ll lb lc mm lm lf lg lh hm dt translated">剧透:加指数就行。</p></blockquote><p id="5878" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">在Solidity语言的核心中没有分数，但是有几种方法可以模拟这样的数字。让我们考虑其中的两种方式:二进制定点和二进制浮点。两种方式都是这样表示小数<strong class="ko hu"> <em class="lp"> x </em> </strong>:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/0219b1ab59e933a9246131a5ef2ea483.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*4hGQ_P9cj1l9WVbHMJ6ZWg.png"/></div></figure><p id="3857" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">其中<strong class="ko hu"> <em class="lp"> m </em> </strong>和<strong class="ko hu"> <em class="lp"> e </em> </strong>为整数。数值<strong class="ko hu"> <em class="lp"> m </em> </strong>称为尾数<strong class="ko hu"> <em class="lp"> e </em> </strong>称为指数。二进制定点数和浮点数之间的区别在于，对于定点数，指数是预定义的常数，通常为负，因此只需存储尾数；而对于浮点数，指数是可变的，因此它必须与尾数一起存储。</p><p id="8d98" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">现在让我们注意到</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mx"><img src="../Images/5f0529cfde77c5fd33e8132b52abfdbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-2_-AL339VY9JXoNdciMg.png"/></div></div></figure><p id="d09a" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">因此，二进制定点数或浮点数的二进制对数可以计算为尾数的二进制对数加上指数。只要指数是整数，同样的公式也适用于对数的整数部分。</p><p id="ccb2" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">现在，当我们知道如何为整数部分融资时，</p><h2 id="c9f6" class="lt jv ht bd jw lu lv lw ka lx ly lz ke kv ma mb kg kz mc md ki ld me mf kk mg dt translated">二进制对数的小数部分呢？</h2><blockquote class="mh mi mj"><p id="c645" class="km kn lp ko b kp li iu kr ks lj ix ku mk lk kx ky ml ll lb lc mm lm lf lg lh hm dt translated">剧透:方形和半方形。</p></blockquote><p id="ae0c" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">设<strong class="ko hu"> <em class="lp"> n </em> </strong>为<strong class="ko hu"> <em class="lp"> x </em> </strong>的二进制对数的整数部分，那么对数的小数部分可以这样计算:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff my"><img src="../Images/1f2d45980f8924ea6e6a8ca7c0174701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*u2vh2FG6f876w4mc75VWQA.png"/></div></figure><p id="1e33" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">注意，只要</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/e794673c9623b460361f27fd4beb04f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*gKJI7g6ka42C6wSrLurbPw.png"/></div></figure><p id="b6d8" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">然后</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/34b3f254ea8d6e7b453dc155f4051ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*33Tiad0JuA5YvjCdGQ8ISw.png"/></div></figure><p id="4705" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">因此，计算二进制对数的小数部分可以推导为计算1(包括1)和2(不包括2)之间的数的二进制对数。为了进行这种计算，我们将使用以下两条规则:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/df7075e2d709fb0d91a0d34bc967f396.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*S_JE6VT3JcTaMXIibJoxpw.png"/></div></figure><p id="e0a6" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">下面是编写的代码，好像Solidity本身支持小数:</p><pre class="jj jk jl jm fq mn mo mp mq aw mr dt"><span id="4f3f" class="lt jv ht mo b fv ms mt l mu mv">for (delta = 1; delta &gt;= precision; delta /= 2) {<br/>  if (x &gt;= 2) { result += delta; x /= 2; }<br/>  x *= x;<br/>}</span></pre><p id="efc9" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">在每次迭代中，我们应用前面的规则:将<code class="eh na nb nc mo b">x</code>的值平方，将<code class="eh na nb nc mo b">delta</code>的值减半。如果在某一点上<code class="eh na nb nc mo b">x</code>的值变得大于或等于2，那么我们应用后一个规则:将<code class="eh na nb nc mo b">delta</code>加到<code class="eh na nb nc mo b">result</code>，并将<code class="eh na nb nc mo b">x</code>的值减半。我们重复循环，直到<code class="eh na nb nc mo b">delta</code>下降到期望的<code class="eh na nb nc mo b">precision</code>以下，因为继续计算不会给<code class="eh na nb nc mo b">result</code>增加任何显著的值。</p><p id="c26c" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">不幸的是，Solidity本身并不支持分数，所以真正的代码应该是这样的:</p><pre class="jj jk jl jm fq mn mo mp mq aw mr dt"><span id="cb2a" class="lt jv ht mo b fv ms mt l mu mv">for (delta = ONE;<br/>     gte (delta, precision);<br/>     delta = div (delta, TWO)) {<br/>  if (gte (x, TWO)) {<br/>    result = add (resukt, delta);<br/>    x = div (x, TWO);<br/>  }<br/>  x = mul (x, x);<br/>}</span></pre><p id="a174" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">其中<code class="eh na nb nc mo b">ONE</code>、<code class="eh na nb nc mo b">TWO</code>、<code class="eh na nb nc mo b">add</code>、<code class="eh na nb nc mo b">mul</code>、<code class="eh na nb nc mo b">div</code>和<code class="eh na nb nc mo b">gte</code>是常数和函数，模拟某种分数和对其进行的算术运算，以确保可靠性。</p><p id="0b79" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">幸运的是，<a class="ae nd" href="https://github.com/abdk-consulting/abdk-libraries-solidity" rel="noopener ugc nofollow" target="_blank"> ABDK库</a>已经准备好使用二进制对数实现64.64位二进制定点四倍精度二进制浮点数。</p><p id="fbbd" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">现在，当我们知道如何计算二进制对数时，</p><h2 id="3ad8" class="lt jv ht bd jw lu lv lw ka lx ly lz ke kv ma mb kg kz mc md ki ld me mf kk mg dt translated">自然对数和普通对数呢？</h2><blockquote class="mh mi mj"><p id="2e2c" class="km kn lp ko b kp li iu kr ks lj ix ku mk lk kx ky ml ll lb lc mm lm lf lg lh hm dt translated">剧透:魔幻因素。</p></blockquote><p id="5d87" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">为了计算自然对数(基数<strong class="ko hu"> <em class="lp"> e </em> </strong>)和普通对数(基数为10)，我们可以使用以下规则:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/35639859ebb6d4a9f39d96ceb17140fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*5hjQwcg9b-Mugl2T5HQqIg.png"/></div></figure><p id="3dad" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">因此，</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/65705701deb0d2ad5dc916b4f604dd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*UtoHDEcZlOQGHRBmv_zTDA.png"/></div></figure><p id="83f8" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">这里</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ng"><img src="../Images/234836c2745c83e7d2c179332974c9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZBLdFVNlVw9sNuhF3wgd4w.png"/></div></div></figure><p id="cb10" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">是可以硬编码到实现中的神奇因素，不需要在运行时计算。</p><p id="2fd3" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">现在，当我们完成对数，让我们切换到</p><h1 id="d92a" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">指数</h1><p id="e658" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">同样，让我们从以2为底的幂运算开始，即计算</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/02c629a949cfa7d296b5a9fa406c1a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:234/format:webp/1*Z0sJKw4R5doE67lz-gzEsA.png"/></div></figure><p id="55d0" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">坚固性有<code class="eh na nb nc mo b">**</code>运算符，所以显而易见的解决方案是:</p><pre class="jj jk jl jm fq mn mo mp mq aw mr dt"><span id="e912" class="lt jv ht mo b fv ms mt l mu mv">y = 2**x</span></pre><p id="cc37" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">但是，这只适用于那些同时为整数和非负的<strong class="ko hu"> <em class="lp"> x </em> </strong>的值。此外，这不是最有效的方法，因为使用移位操作会稍微便宜一些:</p><pre class="jj jk jl jm fq mn mo mp mq aw mr dt"><span id="ebd5" class="lt jv ht mo b fv ms mt l mu mv">y = 1 &lt;&lt; x</span></pre><p id="99a6" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">这种移动也有助于负值的<strong class="ko hu"> <em class="lp"> x </em> </strong>:</p><pre class="jj jk jl jm fq mn mo mp mq aw mr dt"><span id="c016" class="lt jv ht mo b fv ms mt l mu mv">y = x &gt;= 0 ? 1 &lt;&lt; x : 1 &gt;&gt; -x</span></pre><p id="e202" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">由于Solidity本身不支持分数，任何负x都会导致零结果，没有太大意义。然而，如果我们用1的定点表示代替这里的整数1，这段代码会变得更合理。</p><p id="d09e" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">对于二进制浮点数就更简单了，如上式<strong class="ko hu"> <em class="lp"> y </em> </strong>是尾数等于1，指数等于<strong class="ko hu"> <em class="lp"> x </em> </strong>的二进制浮点数。</p><p id="6250" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">到目前为止还不错，但是</p><h2 id="4af9" class="lt jv ht bd jw lu lv lw ka lx ly lz ke kv ma mb kg kz mc md ki ld me mf kk mg dt translated">如果x是分数呢？</h2><blockquote class="mh mi mj"><p id="f79a" class="km kn lp ko b kp li iu kr ks lj ix ku mk lk kx ky ml ll lb lc mm lm lf lg lh hm dt translated">剧透:乘以魔法因素。</p></blockquote><p id="2a35" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">让我们把一个<strong class="ko hu"> <em class="lp"> x </em> </strong>的小数值拆分成整数部分<strong class="ko hu"> <em class="lp"> n </em> </strong>和小数部分<strong class="ko hu"> <em class="lp"> f </em> </strong>:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ni"><img src="../Images/77830f561af440da0ca9b1179c34c92b.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*R2HrMDWSSPNp40dvnLyP5A.png"/></div></figure><p id="0152" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">然后</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nj"><img src="../Images/67e4f6c07929cc77b5568c967d2cf87c.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*hhnt6CCkDupORAWvnhVCIA.png"/></div></figure><p id="2bec" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">设<strong class="ko hu"> <em class="lp"> f </em> </strong>为二进制分数:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff nk"><img src="../Images/9d4a3ef451c740d679202bbeb2f682ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SbfF3jUe_uEdskRuPRdndg.png"/></div></div></figure><p id="1454" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">然后</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/911e5c9284ac1a18dda026c728b44938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*xgYBTjs5Vz-DJQhmltsNWQ.png"/></div></figure><p id="f14a" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">请注意:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff nm"><img src="../Images/f90b4b9247fdc5ed54fb183b33933b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_KvAcZYOFZKjEL-GocusUQ.png"/></div></div></figure><p id="24ca" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">神奇的因素，</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/3a08c900a08454c7337b3227e6dc690f.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*Yego5EASzHzf8rDgQ0HD9g.png"/></div></figure><p id="a55a" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">可以预先计算，不需要在运行时计算:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff no"><img src="../Images/e2aee88ecb99fd171ffc0fe8b62054c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPzp5lNibrsSqkVfVI_vlw.png"/></div></div></figure><p id="c45a" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">这很好，但是</p><h2 id="d24b" class="lt jv ht bd jw lu lv lw ka lx ly lz ke kv ma mb kg kz mc md ki ld me mf kk mg dt translated">我们应该预先计算多少个魔法因子？</h2><blockquote class="mh mi mj"><p id="a657" class="km kn lp ko b kp li iu kr ks lj ix ku mk lk kx ky ml ll lb lc mm lm lf lg lh hm dt translated">剧透:尽可能多的精度。</p></blockquote><p id="bdb9" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">对于二进制定点数来说，答案是显而易见的，因为点之后的二进制位数是固定的。所以。如果定点在小数部分有64位，那么我们需要64个魔因子。</p><p id="6e7c" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">对于二进制浮点数，事情要复杂一些，因为尾数<strong class="ko hu"> <em class="lp"> m </em> </strong>可以通过大的负指数<strong class="ko hu"> <em class="lp"> e </em> </strong>向右移位。因此，这种浮点数的二进制表示如下:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/72d759228e50d9d22378dbbeaf08a451.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*oDX-SLgx7mPKyiVIZMF0wg.png"/></div></figure><p id="febe" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">幸运的是，对于0和1之间的任何<strong class="ko hu"> <em class="lp"> f </em> </strong>，事实确实如此</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff np"><img src="../Images/436a4074dc591ce2c7d14d3f4def780e.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*Lw1pPzPgVMMvACw9iyWFYA.png"/></div></figure><p id="d5fa" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">所以如果<strong class="ko hu"> <em class="lp"> f </em> </strong>是上面显示的二进制表示的数，那么</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nq"><img src="../Images/f77af29d719c755b37635a4bb80d73ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*-cdbaORCPN7LYChzBgY7aQ.png"/></div></figure><p id="aaab" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">因此，如果期望的结果精度是<strong class="ko hu"> <em class="lp"> M </em> </strong>位，那么我们可以忽略<strong class="ko hu"><em class="lp">【f】</em></strong>的二进制表示的那些位，这些位位于点之后比<strong class="ko hu"> <em class="lp"> M </em> </strong>二进制位更远的位置。这样，我们最多需要预先计算好的<strong class="ko hu"> <em class="lp"> M </em> </strong>个幻数来计算指数。</p><p id="d7a1" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">可以在<a class="ae nd" href="https://github.com/abdk-consulting/abdk-libraries-solidity" rel="noopener ugc nofollow" target="_blank"> ABDK库</a>源代码中找到二进制定点数和浮点数的以2为底的指数函数的现成实现。</p><p id="f1fe" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">以2为底的指数很好，但是</p><h2 id="4ea1" class="lt jv ht bd jw lu lv lw ka lx ly lz ke kv ma mb kg kz mc md ki ld me mf kk mg dt translated">任意底的指数呢？</h2><blockquote class="mh mi mj"><p id="e24e" class="km kn lp ko b kp li iu kr ks lj ix ku mk lk kx ky ml ll lb lc mm lm lf lg lh hm dt translated">剧透:用对数。</p></blockquote><p id="2aa8" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">我们知道，对于任意正的<strong class="ko hu"> <em class="lp"> x </em> </strong>和任意负的<strong class="ko hu"> <em class="lp"> b </em> </strong>除了一个以外，以下是正确的:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nr"><img src="../Images/17d095d2396791b190676002de372c03.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/format:webp/1*pbjPgvMdekgAfo9T13J_RQ.png"/></div></figure><p id="9abf" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">所以，对于任意的<strong class="ko hu"> <em class="lp"> y </em> </strong>:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ns"><img src="../Images/d97892120d8ae0a66d3a00b0d5fa0f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*WOvQKEihbLVo6v4TAsjroA.png"/></div></figure><p id="ad07" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">对于<strong class="ko hu"> <em class="lp"> b </em> </strong> =2这就给了我们:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nt"><img src="../Images/f1c3d6a1a7c410b3966fc42e9e53090f.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*Q4VX0wvgVXrFDwdwda7gtg.png"/></div></figure><p id="182a" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">由于我们已经知道如何计算以2为底的对数和指数函数，我们可以计算任意底的指数函数。</p><p id="68ee" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">此公式可用于有效计算连续复利:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff nu"><img src="../Images/fee24d4f5d6c8c982c8207e7c4983d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*3yjsmVggRBZEOfkySOrZvA.png"/></div></div></figure><p id="5436" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">这里<strong class="ko hu"> <em class="lp"> r </em> </strong>是单个时间单位的利率，<strong class="ko hu"> <em class="lp"> t </em> </strong>是计算复利的时间间隔的长度。请注意，在固定利率的情况下，值</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nv"><img src="../Images/183f5ad49839a55ab0f33bb49632db45.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*QRIhe7CNN7wlSXIyi9aIrw.png"/></div></figure><p id="e6a7" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">可以只计算一次，可能是离线的，然后重用，这将使这个公式更加有效。</p><h1 id="88f2" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">结论</h1><p id="c99a" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">在本文中，我们展示了如何有效地计算二进制定点数和浮点数的以2为底的对数和指数函数。</p><p id="f5b5" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">我们还描述了如何通过底数为2的函数实现任意底数的对数和指数函数。</p><p id="67c2" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">我们展示了使用对数和指数函数有效实现的连续复利计算的真实用例。</p><p id="6aa1" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">我们的下一篇文章将展示对数和指数在DeFi应用中的更多用例，下一个主题将是:<strong class="ko hu"> Bancor公式</strong>。</p></div><div class="ab cl nw nx hb ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="hm hn ho hp hq"><p id="1812" class="pw-post-body-paragraph km kn ht ko b kp li iu kr ks lj ix ku kv lk kx ky kz ll lb lc ld lm lf lg lh hm dt translated">本系列的其他文章:</p><ul class=""><li id="8503" class="od oe ht ko b kp li ks lj kv of kz og ld oh lh oi oj ok ol dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/math-in-solidity-part-1-numbers-384c8377f26d">第1部分:数字</a></li><li id="765e" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/math-in-solidity-part-2-overflow-3cd7283714b4">第二部分:溢出</a></li><li id="69e9" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1">第3部分:百分比和比例</a></li><li id="f2bb" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/math-in-solidity-part-4-compound-interest-512d9e13041b">第四部分:复利</a></li></ul><blockquote class="or"><p id="7499" class="os ot ht bd ou ov ow ox oy oz pa lh ek translated">加入Coinmonks <a class="ae nd" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae nd" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae nd" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="lt jv ht bd jw lu pb lw ka lx pc lz ke kv pd mb kg kz pe md ki ld pf mf kk mg dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="od oe ht ko b kp kq ks kt kv pg kz ph ld pi lh oi oj ok ol dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae nd" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae nd" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/top-3-telegram-channels-for-crypto-traders-in-2021-8385f4411ff4">密码电报信号</a> | <a class="ae nd" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f566" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/binance-trading-bots-d0d57bb62c4c">币安交易机器人</a> | <a class="ae nd" rel="noopener" href="/coinmonks/okex-review-6b369304110f"> OKEx评论</a> | <a class="ae nd" href="https://coincodecap.com/atani-review" rel="noopener ugc nofollow" target="_blank">阿塔尼评论</a></li><li id="3b1f" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/best-crypto-signals-telegram-5785cdbc4b2b">最佳加密交易信号电报</a> | <a class="ae nd" rel="noopener" href="/coinmonks/moonxbt-review-6e4ab26d037"> MoonXBT评论</a></li><li id="c44c" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated">如何在Bitbns上购买柴犬(SHIB)币？ | <a class="ae nd" href="https://coincodecap.com/buy-floki-inu-token" rel="noopener ugc nofollow" target="_blank">买弗洛基</a></li><li id="af80" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" href="https://coincodecap.com/coinflex-review" rel="noopener ugc nofollow" target="_blank"> CoinFLEX评论</a> | <a class="ae nd" href="https://coincodecap.com/aex-exchange-review" rel="noopener ugc nofollow" target="_blank"> AEX交易所评论</a> | <a class="ae nd" href="https://coincodecap.com/upbit-review" rel="noopener ugc nofollow" target="_blank"> UPbit评论</a></li><li id="29b5" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" href="https://coincodecap.com/best-cryptocurrency-blogs" rel="noopener ugc nofollow" target="_blank">十大最佳加密货币博客</a> | <a class="ae nd" href="https://coincodecap.com/youhodler-review" rel="noopener ugc nofollow" target="_blank"> YouHodler评论</a></li><li id="f196" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" href="https://coincodecap.com/ascendex-margin-trading" rel="noopener ugc nofollow" target="_blank"> AscendEx保证金交易</a> | <a class="ae nd" href="https://coincodecap.com/bitfinex-staking" rel="noopener ugc nofollow" target="_blank"> Bitfinex赌注</a></li><li id="3cd8" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" href="https://coincodecap.com/best-cardano-wallets" rel="noopener ugc nofollow" target="_blank">最好的卡达诺钱包</a> | <a class="ae nd" href="https://coincodecap.com/bingbon-copy-trading" rel="noopener ugc nofollow" target="_blank"> Bingbon副本交易</a></li><li id="f33b" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae nd" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">面向开发人员的最佳加密API</a></li><li id="b359" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated">最佳<a class="ae nd" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae nd" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="od oe ht ko b kp om ks on kv oo kz op ld oq lh oi oj ok ol dt translated">杠杆代币的终极指南</li></ul></div></div>    
</body>
</html>