<html>
<head>
<title>Integration tests and mocking web3 apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集成测试和模仿web3应用</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/integration-tests-and-mocking-web3-apps-b1b1651af85f?source=collection_archive---------5-----------------------#2018-05-26">https://medium.com/coinmonks/integration-tests-and-mocking-web3-apps-b1b1651af85f?source=collection_archive---------5-----------------------#2018-05-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/c24a03261f16a79086dcbe370bdefbbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*9R_v_Or94y13poN8.jpg"/></div><figcaption class="ix iy fg fe ff iz ja bd b be z ek"><a class="ae jb" href="https://twitter.com/web3foundation" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="79b0" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">分散式应用程序带来了一系列新的挑战。其中之一是测试。事务生命周期比老派的POST请求/响应流程更复杂，并且错误通常没有什么帮助。尽管开发人员的体验越来越好，但这也让我们看到了测试的重要性。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="dce7" class="kj kk ht kf b fv kl km l kn ko">Error: VM Exception while processing transaction: revert</span></pre><p id="0221" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">是新的</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="7d40" class="kj kk ht kf b fv kl km l kn ko">Uncaught TypeError: undefined is not a function</span></pre><p id="7d84" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">从开发人员的角度来看，从Web 2.0后端切换到Ethereum dApps时最显著的变化是，您不能期望响应中立即出现“请求”返回值。在您发送事务后，事务哈希就可用了，但这并不意味着事务会成功，甚至不意味着矿工会将它包括到区块链中。这就是React/Redux应用程序中处理事务的方式。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="ae97" class="kj kk ht kf b fv kl km l kn ko"><strong class="kf hu">this</strong>.props.addTransaction({ id });<br/>AwesomeContract.methods.awesomeMethod(web3.utils.asciiToHex(values.awesomeString))<br/>  .send({ from: account })<br/>  .on("transactionHash", txhash <strong class="kf hu">=&gt;</strong> <strong class="kf hu">this</strong>.props.setTransactionHash({ id, txhash }))<br/>  .on("receipt", receipt <strong class="kf hu">=&gt;</strong> <strong class="kf hu">this</strong>.props.setTransactionReceipt({ id, receipt }))<br/>  .on("error", error <strong class="kf hu">=&gt;</strong> <strong class="kf hu">this</strong>.props.setTransactionError({ id, error }))<br/>  .on("confirmation", confirmation <strong class="kf hu">=&gt;</strong> <strong class="kf hu">this</strong>.props.setTransactionConfirmation({ id, confirmation }));</span></pre><p id="333c" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">测试每个函数来处理事务的特定状态是非常容易的。如果您在reducers中实现处理事务的业务逻辑，那就更是如此。</p><p id="c94a" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">测试整个流程是一个相当大的挑战，需要大量的模仿来使它成为一个快速完成的单元测试。这就是为什么我更喜欢用集成测试来测试它。</p><p id="cad4" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">最近，我喜欢使用Cypress进行测试，这是一种非常好的、没有麻烦的开发体验。Cypress正在运行chrome的一个实例，当然，它缺少window对象上的web3实例。无论您使用哪种集成测试工具，无法访问MetaMask或Mist都将是一个常见的问题。我的解决方案是注入web3实例，它不需要任何用户操作来签署事务。通过附加到<code class="eh kp kq kr kf b">window:before:load</code>事件，我们可以在应用程序代码运行之前修改窗口对象。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="a570" class="kj kk ht kf b fv kl km l kn ko"><strong class="kf hu">import</strong> Web3 from "web3";<br/><strong class="kf hu">import</strong> PrivateKeyProvider from "truffle-privatekey-provider";<br/><br/>cy.on("window:before:load", (win) <strong class="kf hu">=&gt;</strong> {<br/>  <strong class="kf hu">const</strong> provider <strong class="kf hu">=</strong> <strong class="kf hu">new</strong> PrivateKeyProvider(Cypress.env("ETH_PRIV_KEY"), Cypress.env("ETH_PROVIDER"));<br/>  win.web3 <strong class="kf hu">=</strong> <strong class="kf hu">new</strong> Web3(provider); <em class="ks">// eslint-disable-line no-param-reassign</em><br/>});</span></pre><p id="f9e0" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">有几种方法可以在Cypress 中使用<a class="ae jb" href="https://docs.cypress.io/guides/guides/environment-variables.html" rel="noopener ugc nofollow" target="_blank">环境变量。不要让<code class="eh kp kq kr kf b">truffle-privatekey-provider</code>的名字欺骗了你。这不是一个松露依赖包。</a></p><p id="7075" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated">在测试中使用PrivateKeyProvider的可能性并没有到此为止。您还可以通过直接从测试场景代码中进行事务来测试您的应用程序UI如何对“另一个用户”触发的事件做出反应。我希望这给你一些如何测试你的dApp的见解。</p></div><div class="ab cl kt ku hb kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hm hn ho hp hq"><p id="a9f4" class="pw-post-body-paragraph jc jd ht je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hm dt translated"><em class="ks">原载于2018年5月26日</em><a class="ae jb" href="https://michalzalecki.com/integration-tests-and-mocking-web3-apps/" rel="noopener ugc nofollow" target="_blank"><em class="ks">michalzalecki.com</em></a><em class="ks">。</em></p></div></div>    
</body>
</html>