<html>
<head>
<title>Pathfinder- web app that shows optimal path</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探路者-显示最佳路径的网络应用程序</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/pathfinder-web-app-that-shows-optimal-path-9c7030849f69?source=collection_archive---------1-----------------------#2018-12-09">https://medium.com/coinmonks/pathfinder-web-app-that-shows-optimal-path-9c7030849f69?source=collection_archive---------1-----------------------#2018-12-09</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/fd97e7814d36c1280b771815b943f388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Fg2RrLGsY_5pzYM_bde9g.jpeg"/></div></div></figure><p id="7dbd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> <em class="jz">大纲- </em> </strong> <a class="ae ka" href="https://simple.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank"> <em class="jz">旅行推销员问题</em> </a> <em class="jz">是一类非常特殊的问题。在这里，一个推销员必须在N个城市之间旅行。他不关心这样做的顺序，只要他在旅行中访问每一个，并在他开始的地方结束。每个城市都通过城市或者节点与另一个城市相连，通过</em> <a class="ae ka" href="https://simple.wikipedia.org/wiki/Airplane" rel="noopener ugc nofollow" target="_blank"> <em class="jz">飞机</em> </a> <em class="jz">，或者通过</em> <a class="ae ka" href="https://simple.wikipedia.org/wiki/Road" rel="noopener ugc nofollow" target="_blank"> <em class="jz">公路</em> </a> <em class="jz">或者</em> <a class="ae ka" href="https://simple.wikipedia.org/wiki/Railway" rel="noopener ugc nofollow" target="_blank"> <em class="jz">铁路</em> </a> <em class="jz">。这是一种困难的优化问题。我们可以从下面给出的图中看出其复杂性- </em></p><figure class="kc kd ke kf fq iu fe ff paragraph-image"><div class="fe ff kb"><img src="../Images/c1530a35804f22108c626e3b6f84f91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*nQ_koAyz1qYBCbB4-Gj2KQ.png"/></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek">Time Complexities of Travelling Salesman Problem</figcaption></figure><p id="0005" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">显然，使用强力方法解决这个问题需要O(n！)时间，采用动态规划法，其时间复杂度为O(n *2^n).所以很难优化这个问题。对于近似优化，我使用了遗传算法，这是一种近似算法。</p><p id="f665" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> <em class="jz">目标- </em> </strong>构建web应用程序，显示访问者/用户输入的一组目的地的最佳路径。我给了下面这个项目的Github链接-</p><p id="cb16" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">Github-</strong><a class="ae ka" href="https://github.com/HACKERSHUBH/Path-Finder" rel="noopener ugc nofollow" target="_blank">https://github.com/HACKERSHUBH/Path-Finder</a></p><p id="1863" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">先决条件- </strong> <em class="jz"> HTML、CSS、Javascript </em></p><blockquote class="kk kl km"><p id="dae0" class="jb jc jz jd b je jf jg jh ji jj jk jl kn jn jo jp ko jr js jt kp jv jw jx jy hm dt translated">我用两种方式开发了这个项目——静态目的地方式和动态目的地方式</p></blockquote><p id="ab33" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt kq translated"><span class="l kr ks kt bm ku kv kw kx ky di"> S </span> <em class="jz">静态目的地方式</em>——Python脚本，采用城市/地标/游览地的数据集，预测覆盖数据集中所有城市的最佳路径。</p><p id="0f2b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt kq translated"><span class="l kr ks kt bm ku kv kw kx ky di"> D </span></p><h1 id="99c6" class="kz la ht bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">我们开始吧！</h1><p id="906d" class="pw-post-body-paragraph jb jc ht jd b je lx jg jh ji ly jk jl jm lz jo jp jq ma js jt ju mb jw jx jy hm dt translated">首先，我想向你们展示这个项目的工作演示。</p><figure class="kc kd ke kf fq iu"><div class="bz el l di"><div class="mc md l"/></div></figure><h1 id="257a" class="kz la ht bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">实现上面的问题——</h1><p id="20f1" class="pw-post-body-paragraph jb jc ht jd b je lx jg jh ji ly jk jl jm lz jo jp jq ma js jt ju mb jw jx jy hm dt translated">目录结构看起来像这样-</p><figure class="kc kd ke kf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff me"><img src="../Images/dc3533d9725bd75f4679bee5df72b2ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cScWSUpu5x4XiJMUElcPFQ.png"/></div></div></figure><p id="6a2f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt kq translated">遗传算法对于寻找复杂搜索问题的解决方案是很棒的。由于它们能够在大量的参数组合中进行搜索，找到最佳匹配，因此它们被用于创造高质量的产品。他们可以搜索不同的材料和设计组合，找到两者的完美结合，从而打造出更坚固、更轻便、整体更好的最终产品。遗传算法是基于自然界中观察到的自然选择的进化过程。</p><h2 id="3a79" class="mf la ht bd lb mg mh mi lf mj mk ml lj jm mm mn ln jq mo mp lr ju mq mr lv ms dt translated"><strong class="ak"> <em class="mt">遗传算法的基本参数- </em> </strong></h2><p id="593e" class="pw-post-body-paragraph jb jc ht jd b je lx jg jh ji ly jk jl jm lz jo jp jq ma js jt ju mb jw jx jy hm dt translated">遗传算法的基本过程是:</p><ol class=""><li id="365c" class="mu mv ht jd b je jf ji jj jm mw jq mx ju my jy mz na nb nc dt translated"><em class="jz">初始化</em> —创建初始群体。这个群体通常是随机产生的，可以是任何期望的大小，从几个个体到几千个个体。</li><li id="1050" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><em class="jz">评估</em> —然后对群体中的每个成员进行评估，我们计算出该个体的“适合度”。适应性值是根据它与我们期望的要求的符合程度来计算的。这些要求可能很简单，“更快的算法更好”，或者更复杂，“更强的材料更好，但不应该太重”。</li><li id="3163" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><em class="jz">选择</em> —我们希望不断提高我们人口的整体健康水平。选择有助于我们做到这一点，通过丢弃不好的设计，只保留种群中最好的个体。有一些不同的选择方法，但基本思想是相同的，使我们的下一代更有可能选择更适合的个体。</li><li id="6afc" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><em class="jz">交叉</em> —在交叉过程中，我们通过组合所选个体的各个方面来创建新的个体。我们可以认为这是在模仿自然界中的性行为。希望通过结合两个或更多个体的某些特征，我们将创造出一个更“健康”的后代，它将继承父母双方的最佳特征。</li><li id="e963" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><em class="jz">突变</em>——我们需要在我们的种群遗传基因中加入一点随机性，否则我们可以创造的每一种解决方案组合都将存在于我们的初始种群中。突变通常是通过对个体基因组进行非常小的随机改变来实现的。</li><li id="c5a8" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated"><em class="jz">重复！</em> —现在我们有了下一代，我们可以从第二步重新开始，直到达到终止条件。</li></ol><h2 id="d1c7" class="mf la ht bd lb mg mh mi lf mj mk ml lj jm mm mn ln jq mo mp lr ju mq mr lv ms dt translated">结束</h2><p id="6229" class="pw-post-body-paragraph jb jc ht jd b je lx jg jh ji ly jk jl jm lz jo jp jq ma js jt ju mb jw jx jy hm dt translated">有几个原因可以解释为什么你想要终止你的遗传算法继续寻找解决方案。最可能的原因是您的算法已经找到了一个足够好的解决方案，并且满足预定义的最低标准。提供终止的原因可以是诸如时间或金钱的约束，或者我们可以预先定义算法运行的迭代次数。</p><p id="1e12" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">解决上述问题时，有两条重要的规则要记住:</p><ol class=""><li id="36d4" class="mu mv ht jd b je jf ji jj jm mw jq mx ju my jy mz na nb nc dt translated">每个城市只需要被访问一次</li><li id="a5c4" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy mz na nb nc dt translated">我们必须回到出发城市，所以我们的总距离需要相应地计算</li></ol><h2 id="bb04" class="mf la ht bd lb mg mh mi lf mj mk ml lj jm mm mn ln jq mo mp lr ju mq mr lv ms dt translated">方法</h2><p id="b548" class="pw-post-body-paragraph jb jc ht jd b je lx jg jh ji ly jk jl jm lz jo jp jq ma js jt ju mb jw jx jy hm dt translated">让我们从几个定义开始，在TSP的上下文中重新表述:</p><ul class=""><li id="0ce6" class="mu mv ht jd b je jf ji jj jm mw jq mx ju my jy ni na nb nc dt translated"><strong class="jd hu">基因:</strong>一个城市(用(x，y)坐标表示)</li><li id="2229" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy ni na nb nc dt translated"><strong class="jd hu">个体(又名“染色体”):</strong>满足上述条件的单一途径</li><li id="38d5" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy ni na nb nc dt translated"><strong class="jd hu">人口:</strong>可能路线的集合(即个体的集合)</li><li id="58a6" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy ni na nb nc dt translated"><strong class="jd hu"> Parents: </strong>两个路由组合在一起创建一个新路由</li><li id="c4f6" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy ni na nb nc dt translated"><strong class="jd hu">交配池:</strong>用来创造我们下一个种群(从而创造下一代路线)的亲代集合</li><li id="6ff6" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy ni na nb nc dt translated"><strong class="jd hu"> Fitness: </strong>一个告诉我们每条路线有多好的函数(在我们的例子中，距离有多短)</li><li id="31b7" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy ni na nb nc dt translated"><strong class="jd hu">变异:</strong>通过随机交换路线上的两个城市，在我们的人口中引入变异的一种方式</li><li id="ceba" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy ni na nb nc dt translated">精英主义:将最优秀的个体带入下一代的一种方式</li></ul><p id="3b1b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于用户是在标记的帮助下在谷歌地图上选择目的地点，所以我们需要距离矩阵。</p><figure class="kc kd ke kf fq iu"><div class="bz el l di"><div class="nj md l"/></div></figure><p id="85df" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果用户想要他们的当前位置，那么他们必须点击网站上提供的“位置”按钮。我也使用不同类型的旅行方式，比如-</p><ul class=""><li id="4c3b" class="mu mv ht jd b je jf ji jj jm mw jq mx ju my jy ni na nb nc dt translated"><em class="jz">汽车</em></li><li id="e2a3" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy ni na nb nc dt translated"><em class="jz">自行车</em></li></ul><p id="1f13" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我也在使用用户是否必须在旅行期间覆盖高速公路，所以也有高速公路启用或禁用模式。然后，我为不同类型的出行模式创建持续时间数据数组。这个的代码是-</p><figure class="kc kd ke kf fq iu"><div class="bz el l di"><div class="nj md l"/></div></figure><p id="0076" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在来了<strong class="jd hu">遗传算法</strong>带参数的代码——</p><figure class="kc kd ke kf fq iu"><div class="bz el l di"><div class="nj md l"/></div></figure><blockquote class="kk kl km"><p id="2673" class="jb jc jz jd b je jf jg jh ji jj jk jl kn jn jo jp ko jr js jt kp jv jw jx jy hm dt translated">现在我们将变异、交叉应用于当前种群，并返回后代种群。之后，我们在每次迭代中寻找最适合的个体，我们应用锦标赛选择，然后选择最适合的个体指数。</p></blockquote><figure class="kc kd ke kf fq iu"><div class="bz el l di"><div class="nj md l"/></div></figure><p id="a7fe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这就完成了求解旅行商问题的遗传算法代码。虽然它是一种寻找最短路径的近似算法，但是与其他方法相比，它的时间复杂度非常低。</p><h1 id="d529" class="kz la ht bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">参考文献-</h1><ul class=""><li id="21d2" class="mu mv ht jd b je lx ji ly jm nk jq nl ju nm jy ni na nb nc dt translated"><a class="ae ka" href="http://www.theprojectspot.com/tutorial-post/applying-a-genetic-algorithm-to-the-travelling-salesman-problem/5" rel="noopener ugc nofollow" target="_blank">http://www . the projectspot . com/tutorial-post/applying-a-genetic-algorithm-to-traveling-salesman-problem/5</a></li><li id="94c5" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy ni na nb nc dt translated"><a class="ae ka" href="https://www.hindawi.com/journals/cin/2017/7430125/" rel="noopener ugc nofollow" target="_blank">https://www.hindawi.com/journals/cin/2017/7430125/</a></li><li id="b3de" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy ni na nb nc dt translated"><a class="ae ka" href="https://www.cs.indiana.edu/~vgucht/Genetic_Algorithms_for_the_Travelling_Salesman+Problem.pdf" rel="noopener ugc nofollow" target="_blank">https://www . cs . Indiana . edu/~ vgucht/Genetic _ Algorithms _ for _ the _ traveling _ Salesman+problem . pdf</a></li><li id="3958" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy ni na nb nc dt translated"><a class="ae ka" href="https://link.springer.com/article/10.1023/A:1006529012972" rel="noopener ugc nofollow" target="_blank">https://link.springer.com/article/10.1023/A:1006529012972</a></li><li id="11da" class="mu mv ht jd b je nd ji ne jm nf jq ng ju nh jy ni na nb nc dt translated">https://en.wikipedia.org/wiki/Travelling_salesman_problem<a class="ae ka" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank"/></li></ul><blockquote class="nn"><p id="6bed" class="no np ht bd nq nr ns nt nu nv nw jy ek translated"><a class="ae ka" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="ny nz oa ob oc iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nx"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="kc kd ke kf fq iu fe ff paragraph-image"><a href="http://bit.ly/2G71Sp7"><div class="fe ff od"><img src="../Images/449450761cd76f44f9ae574333f9e9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKX2mtg7p1lOs7JmosPLsA.png"/></div></a><figcaption class="kg kh fg fe ff ki kj bd b be z ek"><a class="ae ka" href="http://bit.ly/2G71Sp7" rel="noopener ugc nofollow" target="_blank"><strong class="bd oe">Click to read today’s top story</strong></a></figcaption></figure></div></div>    
</body>
</html>