<html>
<head>
<title>Hands-on Your first ZK application!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">亲手操作您的第一个ZK应用程序！</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/hands-on-your-first-zk-application-70fe3a0c0d82?source=collection_archive---------1-----------------------#2020-02-06">https://medium.com/coinmonks/hands-on-your-first-zk-application-70fe3a0c0d82?source=collection_archive---------1-----------------------#2020-02-06</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><blockquote class="iq"><p id="2732" class="ir is ht bd it iu iv iw ix iy iz ja ek translated">我们开始吧！</p></blockquote><figure class="jc jd je jf jg jh fe ff paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="fe ff jb"><img src="../Images/9778a81f33137faf6a77597ec12757cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w_mUWcelKQqleP6g.jpeg"/></div></div><figcaption class="jo jp fg fe ff jq jr bd b be z ek">Photo by <a class="ae js" href="https://unsplash.com/@clemono2" rel="noopener ugc nofollow" target="_blank">Clem Onojeghuo</a> on <a class="ae js" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5320" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">在过去的一年里，zkp的应用有了很大的增长。Zk rollup于2018年底提出，目前由<a class="ae js" href="https://github.com/matter-labs" rel="noopener ugc nofollow" target="_blank"> Matter Labs </a>开发。Matter Labs两个月前(2019/12)刚刚发布了<a class="ae js" href="https://github.com/matter-labs/zksync" rel="noopener ugc nofollow" target="_blank"> ZK同步</a>，解决了生成证明时的延迟问题。另外，我<a class="ae js" href="https://github.com/iden3" rel="noopener ugc nofollow" target="_blank"> den3 </a>和<a class="ae js" href="https://github.com/ConsenSys/liszt" rel="noopener ugc nofollow" target="_blank"> ConsenSys </a>也有自己的zk rollup项目。以太坊研究论坛中的一项名为<a class="ae js" href="https://ethresear.ch/t/account-based-anonymous-rollup/6657/1" rel="noopener ugc nofollow" target="_blank">基于账户的匿名汇总</a>的提议基于zk汇总的思想，也实现了匿名。<a class="ae js" href="https://github.com/barryWhiteHat/semaphore" rel="noopener ugc nofollow" target="_blank">信号量</a>是基于零知识证明的信号系统。发送者可以广播任意字符串而不暴露他/她的身份。<a class="ae js" href="https://github.com/kobigurk/semaphore" rel="noopener ugc nofollow" target="_blank"> Semaphorejs </a>是Semaphore的升级版，完成了从前端网页到后端服务的整个概念。Zk-STARKs还是很新的，刚出版不到两年，他们去年初和0x合作推出了基于zk-STARKs的<a class="ae js" href="https://www.starkdex.io/" rel="noopener ugc nofollow" target="_blank">去中心化交易所</a>。</p><p id="4e93" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">学术方面，去年下半年发表了很多论文。使用黑暗编译器可以使SNARKs透明(没有可信设置)。一些SNARKs可以有通用和可更新的可信设置(MARLIN、SONIC、PLONK等。).递归的SNARKs也是一个惊人的。这个领域发展如此之快，很难跟上。<a class="ae js" rel="noopener" href="/coinmonks/comparing-general-purpose-zk-snarks-51ce124c60bd">这里</a>是一个很棒的关于不同SNARKs比较的帖子。<a class="ae js" href="https://nakamoto.com/cambrian-explosion-of-crypto-proofs/" rel="noopener ugc nofollow" target="_blank">另一篇</a>要想对伊莱·本·萨松的所有zkp作一个概述，你必须读一读！</p><p id="f4b5" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">这里不谈什么数学，只介绍实现所需的基础。我们在本文中使用由iden3开发的语言<a class="ae js" href="https://github.com/iden3/circom" rel="noopener ugc nofollow" target="_blank"> circom </a>来帮助编写算术电路。有了circom，实现零知识证明程序就更容易了。先介绍一些基本概念。</p></div><div class="ab cl kq kr hb ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hm hn ho hp hq"><h1 id="c03b" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">算术电路</h1><p id="7523" class="pw-post-body-paragraph jt ju ht jv b jw lv jy jz ka lw kc kd ke lx kg kh ki ly kk kl km lz ko kp ja hm dt translated">零知识计划的实施不同于其他计划。首先，你要解决的问题需要转化为电路。(其实问题转化成多项式然后是电路)。例如，多项式x + x +5会变成这样的电路</p><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="8cfe" class="mj ky ht mf b fv mk ml l mm mn">sym_1 = x * x // sym_1 = x² <br/>sym_2 = sym_1 * x // sym_2 = x³ <br/>y = sym_2 + x // y = x³ + x <br/>~out = y + 5</span></pre><p id="ccd1" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">Circom编译器将逻辑转换成电路。你不需要自己处理电路。如果您需要散列或签名函数，您可以在<a class="ae js" href="https://github.com/iden3/circomlib" rel="noopener ugc nofollow" target="_blank"> circomlib </a>中找到它们。</p><h1 id="3a02" class="kx ky ht bd kz la mo lc ld le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu dt translated">生成/验证证据</h1><p id="58ea" class="pw-post-body-paragraph jt ju ht jv b jw lv jy jz ka lw kc kd ke lx kg kh ki ly kk kl km lz ko kp ja hm dt translated">在运行zkp程序之前，我们需要创建一个可信的设置。创建可信设置需要电路和一些随机数。一旦设置完成，将会生成一个<strong class="jv hu">验证密钥</strong>和一个<strong class="jv hu">验证密钥</strong>。顾名思义，生成证明需要一个，验证需要一个。(这两个密钥不同于ECC中的公钥/私钥)。</p><blockquote class="mt mu mv"><p id="88ce" class="jt ju mw jv b jw jx jy jz ka kb kc kd mx kf kg kh my kj kk kl mz kn ko kp ja hm dt translated">为生产生成可信设置需要更多的知识，请参考ZCash的<a class="ae js" href="https://z.cash/technology/paramgen/" rel="noopener ugc nofollow" target="_blank">仪式</a>了解更多细节。</p></blockquote><figure class="ma mb mc md fq jh fe ff paragraph-image"><div class="fe ff na"><img src="../Images/8f0a897a05aa8e812ebfc0f6e162bd4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*aTAdiXwYr-STeqUz"/></div></figure><p id="45f7" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">一旦证明密钥和验证密钥被创建，然后生成证明！</p><p id="bcb4" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">有两种投入，公共投入和私人投入。比如A转账给B但不想透露余额，那么A的余额就是私入，也叫<strong class="jv hu">见证</strong>。公共输入可以是A和B的地址或数量，这完全取决于你的设计。</p><p id="1941" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">然后，证明者通过<strong class="jv hu">证明密钥</strong>、<strong class="jv hu">公共输入</strong>和<strong class="jv hu">见证</strong>生成证明。</p><figure class="ma mb mc md fq jh fe ff paragraph-image"><div class="fe ff na"><img src="../Images/1123f9441b7b96b6d8cc4a033f003234.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*KcZiZIH7z464wRQh"/></div></figure><p id="f633" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">最后一步，验证！</p><p id="7b37" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">验证者通过<strong class="jv hu">公共输入</strong>、<strong class="jv hu">证明</strong>和<strong class="jv hu">验证密钥</strong>来验证证明。</p><figure class="ma mb mc md fq jh fe ff paragraph-image"><div class="fe ff na"><img src="../Images/766177980a6ab1e9e424a2f447a83c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*yVT05bONGxwjlZqn"/></div></figure><p id="1640" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated"><strong class="jv hu">公共输入、见证(私有输入)、证明密钥、验证密钥、电路、证明</strong>及其关系<strong class="jv hu"> </strong>是本节需要了解的内容！</p></div><div class="ab cl kq kr hb ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hm hn ho hp hq"><h1 id="2c0d" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">Circom 101</h1><p id="0b90" class="pw-post-body-paragraph jt ju ht jv b jw lv jy jz ka lw kc kd ke lx kg kh ki ly kk kl km lz ko kp ja hm dt translated">首先介绍一下circom的语法。根据文档，circom使用js和c的语法，所以，有基本的操作/数据类型，像for，while，&gt;&gt;，array。</p><p id="ef48" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">这里有一个用circom写的例子。<br/>假设x，y是我们的秘密(也就是证人)不想公开x，y，但是需要证明<strong class="jv hu"> (x * y) + z == out </strong> (z，out是公开输入)。假设out = 30，z = 10，你会知道(x * y) = 20，但是你不会知道x和y各是什么。</p><figure class="ma mb mc md fq jh"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="7522" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">这里介绍一下circom中的关键词。<strong class="jv hu"> <br/>信号</strong>:该变量将被转换成电路，具有以下特性:<br/>。<strong class="jv hu">私有</strong>:私有输入(见证)。默认为公共<br/> <strong class="jv hu">模板</strong>:函数声明的关键字，像Solidity中的<em class="mw">函数</em>或者golang中的<em class="mw"> func </em>。<br/> <strong class="jv hu">组件</strong>:文件中没有任何说明。它是一个变量类型，但赋值是一个函数。可以用关键字<strong class="jv hu"> signal </strong>给函数内部的变量赋值。你也可以想象组件变量是类对象，信号是类中的公共成员。</p><p id="bab6" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">有额外的操作符来操作信号变量。<br/> <strong class="jv hu"> &lt; ==，== &gt; </strong>:这两个运算符用来连接信号，同时隐含一个约束。<br/><strong class="jv hu">↓、→ </strong>:这些运算符给信号赋值，但不产生任何约束。<br/> ===:这个操作符定义了一个约束。</p><p id="4a24" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">因此，<strong class="jv hu"> &lt; == </strong> : <strong class="jv hu">，← </strong> + <strong class="jv hu"> === </strong></p><p id="4316" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">这些是你开始前需要知道的关键词。这里是安装circom/snarkjs的<a class="ae js" href="https://iden3.io/blog/circom-and-snarkjs-tutorial2.html" rel="noopener ugc nofollow" target="_blank">教程</a>，我们在接下来的章节中需要它。</p><h1 id="8404" class="kx ky ht bd kz la mo lc ld le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu dt translated">Circom命令</h1><p id="f24c" class="pw-post-body-paragraph jt ju ht jv b jw lv jy jz ka lw kc kd ke lx kg kh ki ly kk kl km lz ko kp ja hm dt translated"><strong class="jv hu">步骤1。</strong>编译电路文件。<strong class="jv hu"> <em class="mw"> circuit.json </em> </strong>会在这一步之后生成。</p><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="e122" class="mj ky ht mf b fv mk ml l mm mn"><strong class="mf hu"><em class="mw">circom sample1.circom</em></strong></span></pre><p id="c602" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated"><strong class="jv hu">步骤二。</strong>创建可信设置。将生成<strong class="jv hu"><em class="mw">proving _ key . JSON</em></strong>和<strong class="jv hu"> verification_key.json </strong>。(使用协议“groth”)</p><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="7093" class="mj ky ht mf b fv mk ml l mm mn"><strong class="mf hu"><em class="mw">snarkjs setup — protocol groth</em></strong></span></pre><p id="171d" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated"><strong class="jv hu">第三步。</strong>生成见证。这一步需要输入，所以把你的输入放在如下json格式的<strong class="jv hu"> <em class="mw"> input.json </em> </strong>中。</p><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="3796" class="mj ky ht mf b fv mk ml l mm mn">// input.json<br/>{“x”:3, “y”:5, “z”: 100}</span></pre><p id="9996" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">生成见证。<strong class="jv hu"> <em class="mw"> witness.json </em> </strong>就会生成。</p><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="27ad" class="mj ky ht mf b fv mk ml l mm mn"><strong class="mf hu"><em class="mw">snarkjs calculatewitness</em></strong></span></pre><p id="2402" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated"><strong class="jv hu">最后一步，</strong>生成证明。一旦完成，就会生成<strong class="jv hu"> <em class="mw"> proof.json </em> </strong>、<strong class="jv hu"> <em class="mw"> public.json </em> </strong>。公共输入将在<strong class="jv hu"> public.json </strong>中。</p><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="8c79" class="mj ky ht mf b fv mk ml l mm mn">// public.json<br/>{<br/>  “115”, // → out<br/>  “100” // → z:100<br/>}</span></pre><p id="124d" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">生成证明</p><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="8b13" class="mj ky ht mf b fv mk ml l mm mn"><strong class="mf hu"><em class="mw">snarkjs proof</em></strong></span></pre><p id="1f6f" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">调用“验证”进行验证。</p><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="1119" class="mj ky ht mf b fv mk ml l mm mn">snarkjs verify</span></pre><p id="91ec" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">以上是生成证明的基本命令。下面是一个高级示例，用来理解如何实际使用circom编写zkp程序。</p></div><div class="ab cl kq kr hb ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hm hn ho hp hq"><h1 id="c7a2" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">例子</h1><p id="9b35" class="pw-post-body-paragraph jt ju ht jv b jw lv jy jz ka lw kc kd ke lx kg kh ki ly kk kl km lz ko kp ja hm dt translated">在这里，我们来实现zk rollup！</p><figure class="ma mb mc md fq jh fe ff paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="fe ff nd"><img src="../Images/350ee59477fda0810d51523d1669e3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9v7io5Jy5GsW8Pz0"/></div></div><figcaption class="jo jp fg fe ff jq jr bd b be z ek">Photo by <a class="ae js" href="https://unsplash.com/@blackpoetry" rel="noopener ugc nofollow" target="_blank">pixpoetry</a> on <a class="ae js" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="48bb" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">zk汇总是第2层解决方案，它不像其他第2层解决方案。zk汇总将所有数据放在链上，并通过zk-SNARKs验证。因此，没有复杂的挑战游戏。在zk汇总中，用户的地址被记录在smart contract的merkle树中，使用索引(3个字节)来表示用户的地址(地址的原始大小是20个字节)。通过减少数据量来增加TPS，详情请参看<a class="ae js" rel="noopener" href="/coinmonks/zk-rollup-optimistic-rollup-70c01295231b">我之前的帖子</a>。</p><p id="0a77" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">为了使例子易于理解，省略了许多细节。(本例基于<a class="ae js" href="https://keen-noyce-c29dfa.netlify.com/#6" rel="noopener ugc nofollow" target="_blank">zkcroll教程</a>)</p><p id="cd25" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">首先，有一个merkle树来记录帐户。账户内容包含(<strong class="jv hu">公钥</strong>、<strong class="jv hu">余额</strong>)。每笔交易的内容为(<strong class="jv hu">发送方索引</strong>、<strong class="jv hu">接收方索引</strong>、<strong class="jv hu">金额</strong>)。流程如下</p><p id="757d" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">1检查发送方账户是否在树中(检查是否存在)<br/> 2验证发送方签名<br/> 3更新发送方余额并验证中间merkle根<br/> 4更新接收方余额并更新merkle根</p></div><div class="ab cl kq kr hb ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hm hn ho hp hq"><h1 id="0865" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">0.变量声明</h1><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="73cc" class="mj ky ht mf b fv mk ml l mm mn">  // account tree<br/>  signal input account_root;<br/>  signal private input account_pubkey[2];<br/>  signal private input account_balance;  </span><span id="22d3" class="mj ky ht mf b fv ne ml l mm mn">  // new account root after sender's balance is updated<br/>  signal private input new_sender_account_root;  </span><span id="08f6" class="mj ky ht mf b fv ne ml l mm mn">  // tx<br/>  signal private input tx_sender_pubkey[2]<br/>  signal private input tx_sender_balance<br/>  signal private input tx_amount<br/>  signal private input tx_sender_sig_r[2]<br/>  signal private input tx_sender_sig_s<br/>  signal private input tx_sender_path_element[levels]<br/>  signal private input tx_sender_path_idx[levels]<br/>  signal private input tx_receiver_pubkey[2]<br/>  signal private input tx_receiver_balance<br/>  signal private input tx_receiver_path_element[levels]<br/>  signal private input tx_receiver_path_idx[levels]<br/>  <br/>  // output new merkle root<br/>  signal output new_root;</span></pre><p id="9712" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">在这种情况下，几乎所有的变量都是私有的，从公钥、余额、签名等，只有merkle根和更新的merkle根是公共的。path_element是构造merkle根的中间值，path_idx是一个索引数组，用于存储merkle树中每一层的索引(它是一个二叉树，所以只有左或右，0表示左，1表示右。最终的路径就像一个二进制字符串，001011)</p><h1 id="5f85" class="kx ky ht bd kz la mo lc ld le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu dt translated">1.检查发件人是否存在</h1><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="d704" class="mj ky ht mf b fv mk ml l mm mn">  //__1. verify sender account existence<br/> <strong class="mf hu">component </strong>senderLeaf = <strong class="mf hu"><em class="mw">HashedLeaf</em></strong>();<br/> senderLeaf.pubkey[0] &lt;== tx_sender_pubkey[0];<br/> senderLeaf.pubkey[1] &lt;== tx_sender_pubkey[1];<br/> senderLeaf.balance &lt;== account_balance; </span><span id="0265" class="mj ky ht mf b fv ne ml l mm mn"><strong class="mf hu"> component </strong>senderExistence = <strong class="mf hu"><em class="mw">GetMerkleRoot</em></strong>(levels);<br/> senderExistence.leaf &lt;== senderLeaf.out; </span><span id="1780" class="mj ky ht mf b fv ne ml l mm mn"> for (var i=0; i&lt;levels; i++) {<br/>     senderExistence.path_index[i] &lt;== tx_sender_path_idx[i];<br/>     senderExistence.path_elements[i] &lt;== tx_sender_path_element[i];<br/> }</span><span id="20e4" class="mj ky ht mf b fv ne ml l mm mn"> senderExistence.out === account_root;</span></pre><p id="252b" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">我们可以在这里看到<strong class="jv hu">组件</strong>是如何工作的，<strong class="jv hu"> <em class="mw">组件senderLeaf = hashedlaf()；</em> </strong> <em class="mw">。</em><strong class="jv hu"><em class="mw"/></strong><em class="mw">hashedlaf()</em>被分配给<em class="mw">senderelaf</em>，使用&lt; ==将公钥和余额分配给<em class="mw">hashedlaf()</em>中的值(<em class="mw"> pubkey[0]、pubkey[1]、balance </em>这些都是信号类型)，并生成电路。哈希值将是<em class="mw"> senderLeaft.out </em>。</p><p id="f138" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">这个片段很简单，散列发送者的公钥并进行平衡，用merkle树的中间值进行计算，然后得到merkle根(<em class="mw"> senderExistence.out </em>)。检查计算出的merkle根与输入的相同(<em class="mw"> account_root </em>)。</p><p id="206d" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">为简单起见，跳过merkle树和hash函数的实现，可以检查实现<a class="ae js" href="https://github.com/KimiWu123/Samples/blob/master/circom/rollupSample/rollup.circom#L75" rel="noopener ugc nofollow" target="_blank"> HashedLeaf </a>和<a class="ae js" href="https://github.com/KimiWu123/Samples/blob/master/circom/rollupSample/rollup.circom#L43" rel="noopener ugc nofollow" target="_blank"> GetMerkleRoot </a>。</p><h1 id="780a" class="kx ky ht bd kz la mo lc ld le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu dt translated">2.检查发件人的签名</h1><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="3898" class="mj ky ht mf b fv mk ml l mm mn">  //__2. verify signature<br/>  <strong class="mf hu">component </strong>msgHasher = <strong class="mf hu"><em class="mw">MessageHash</em></strong>(5);<br/>  msgHasher.ins[0] &lt;== tx_sender_pubkey[0];<br/>  msgHasher.ins[1] &lt;== tx_sender_pubkey[1];<br/>  msgHasher.ins[2] &lt;== tx_receiver_pubkey[0];<br/>  msgHasher.ins[3] &lt;== tx_receiver_pubkey[1];<br/>  msgHasher.ins[4] &lt;== tx_amount<br/>      <br/>  <strong class="mf hu">component </strong>sigVerifier = <strong class="mf hu"><em class="mw">EdDSAMiMCSpongeVerifier</em></strong>(); <br/>  sigVerifier.enabled &lt;== 1;<br/>  sigVerifier.Ax &lt;== tx_sender_pubkey[0];<br/>  sigVerifier.Ay &lt;== tx_sender_pubkey[1];<br/>  sigVerifier.R8x &lt;== tx_sender_sig_r[0];<br/>  sigVerifier.R8y &lt;== tx_sender_sig_r[1];<br/>  sigVerifier.S &lt;== tx_sender_sig_s;<br/>  sigVerifier.M &lt;== msgHasher.out;</span></pre><p id="d66b" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">就像区块链交易一样，需要签名来证明你是汇款人。在这个代码片段中，我们首先对消息进行哈希处理，然后对哈希处理后的消息进行签名。我把所有东西都封装到函数中，所以和第一部分非常相似，只是调用了不同的函数。</p><blockquote class="mt mu mv"><p id="2d62" class="jt ju mw jv b jw jx jy jz ka kb kc kd mx kf kg kh my kj kk kl mz kn ko kp ja hm dt translated">SNARKs中的签名方案是EdDSA，而不是ECDSA。</p></blockquote><h1 id="6089" class="kx ky ht bd kz la mo lc ld le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu dt translated">3.更新发件人的平衡，并检查新的Merkle根</h1><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="58be" class="mj ky ht mf b fv mk ml l mm mn"> //__3. Check the root of new tree is equivalent<br/> <strong class="mf hu">component </strong>newAccLeaf = <strong class="mf hu"><em class="mw">HashedLeaf</em></strong>();<br/> newAccLeaf.pubkey[0] &lt;== tx_sender_pubkey[0];<br/> newAccLeaf.pubkey[1] &lt;== tx_sender_pubkey[1];<br/> newAccLeaf.balance &lt;== account_balance - tx_amount;<br/> <br/> <strong class="mf hu">component </strong>newTreeExistence = <strong class="mf hu"><em class="mw">GetMerkleRoot</em></strong>(levels);<br/> newTreeExistence.leaf &lt;== newAccLeaf.out;<br/> for (var i=0; i&lt;levels; i++) {<br/>   newTreeExistence.path_index[i] &lt;== tx_sender_path_idx[i];<br/>   newTreeExistence.path_elements[i] &lt;== tx_sender_path_element[i];<br/> } newTreeExistence.out === new_sender_account_root;</span></pre><p id="b94a" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">前两步是从发送方检查信息。在这些检查之后，我们更新发送者的余额并计算新的merkle根。<strong class="jv hu">最后一行，<em class="mw">new tree existence . out = = = new _ sender _ account _ root；</em> </strong>，是检查计算出的merkle根和输入的一个(<em class="mw"> new_sender_account_root </em>)是否相同。通过这种检查，防止用户的虚假/错误输入。</p><h1 id="b843" class="kx ky ht bd kz la mo lc ld le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu dt translated">4.更新接收方的余额和Merkle根</h1><pre class="ma mb mc md fq me mf mg mh aw mi dt"><span id="a9e6" class="mj ky ht mf b fv mk ml l mm mn"> //__5. update the root of account tree<br/> <strong class="mf hu">component </strong>newReceiverLeaf = <strong class="mf hu"><em class="mw">HashedLeaf</em></strong>();<br/> newReceiverLeaf.pubkey[0] &lt;== tx_receiver_pubkey[0];<br/> newReceiverLeaf.pubkey[1] &lt;== tx_receiver_pubkey[1];<br/> newReceiverLeaf.balance &lt;== tx_receiver_balance + tx_amount;<br/> <br/> <strong class="mf hu">component </strong>newReceiverTreeExistence = <strong class="mf hu"><em class="mw">GetMerkleRoot</em></strong>(levels);<br/> newReceiverTreeExistence.leaf &lt;== newReceiverLeaf.out;<br/> for (var i=0; i&lt;levels; i++) {<br/>  newReceiverTreeExistence.path_index[i]&lt;==tx_receiver_path_idx[i];<br/>  newReceiverTreeExistence.path_elements[i] <br/>  &lt;==tx_receiver_path_element[i];<br/> }<br/> <br/> new_root &lt;== newReceiverTreeExistence.out;</span></pre><p id="41ad" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">最后一步，更新接收者的余额，计算新的merkle根并输出新的merkle根。一旦电路被制造出来，它就像一个黑盒子。如果输入正确的值，输出也一定是正确的。因此，用户很容易检查这些值，以防止恶意中间人。这就是为什么我们需要在电路的末端输出一些东西(在我们的例子中是merkle根)。</p><p id="8493" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">zk rollup聚合许多上述事务，并生成一个证明以减少数据大小。为了使示例易于理解，这里只处理一个事务。<a class="ae js" href="https://github.com/KimiWu123/Samples/blob/master/circom/rollupSample/rollup.circom" rel="noopener ugc nofollow" target="_blank">这里的</a>是完整示例代码的链接，<a class="ae js" href="https://github.com/KimiWu123/Samples/tree/master/circom" rel="noopener ugc nofollow" target="_blank">其他常见示例</a>。</p><h1 id="9125" class="kx ky ht bd kz la mo lc ld le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu dt translated"><strong class="ak">结论</strong></h1><p id="66f2" class="pw-post-body-paragraph jt ju ht jv b jw lv jy jz ka lw kc kd ke lx kg kh ki ly kk kl km lz ko kp ja hm dt translated">Circom是一个非常新的语言，现在支持的库不多，很多功能需要我们自己实现。幸运的是，iden3实现了许多哈希、签名函数和其他哈希或merkle树函数，这些函数可以在Semaphore或其他zk rollup实现中找到。调用不同的函数来完成你的应用，就像搭积木一样。从实现的角度来看，这并不困难(尽管缺少文档，但阅读源代码是必需的)。对我们的工程师来说，最困难的部分是在实现之前，我们需要了解许多密码学知识。</p><p id="52fe" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">另外，哈希函数的选择也很重要。如何降低电路的复杂度，同时又保证足够的安全性，是另一个课题。</p><p id="7fa5" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated">除了circom，ZoKrates也是另一种帮助编写算术电路的语言。这两个工具都可以生成智能合约，可以验证零知识证明。然后，对于dapp开发者来说，只要继承这个契约，构建自己的业务逻辑。如何生成可验证的契约以及如何与契约进行交互不是这篇文章的范围，可能会有另一篇文章来解释它。就在我写完这篇文章之前，Matter Labs刚刚发布了另一种实现电路的语言<a class="ae js" rel="noopener" href="/matter-labs/release-of-zinc-v0-1-8d949aa9a2f2"> Zinc </a>。</p><p id="7a33" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated"><em class="mw">欢迎任何需要纠正的反馈或错误。</em></p><p id="3827" class="pw-post-body-paragraph jt ju ht jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ja hm dt translated"><em class="mw">感谢</em> <a class="ae js" href="https://medium.com/u/5c031577a87d?source=post_page-----d7ac1fa8bbd3----------------------" rel="noopener"> <em class="mw">梁志成</em> </a> <em class="mw">的点评</em></p><blockquote class="iq"><p id="d56e" class="ir is ht bd it iu nf ng nh ni nj ja ek translated"><a class="ae js" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="jc jd je jf jg jh fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nk"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="ma mb mc md fq jh fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff nl"><img src="../Images/0ac758d7122ac1c2860cc155daf2c5d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*sfsGJhpBk0-yxJur_WuGoQ.png"/></div></a></figure></div></div>    
</body>
</html>