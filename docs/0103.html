<html>
<head>
<title>The Bitcoin Blockchain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比特币区块链</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/the-bitcoin-blockchain-a3eb996f7140?source=collection_archive---------2-----------------------#2018-02-16">https://medium.com/coinmonks/the-bitcoin-blockchain-a3eb996f7140?source=collection_archive---------2-----------------------#2018-02-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="a817" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">我相信你以前听说过“区块链”这个词，它是当今最热门的词汇之一。在本帖中，我们将解释什么是比特币区块链，以及它的内部工作原理。</h2></div><p id="be92" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt ke translated">比特币区块链(Bitcoin Blockchain)是一种数据结构，用于在一系列反向链接的区块中存储交易。每个块内部都有一个事务列表，每个块都链接到它的“父”块。它可以存储在文件或简单的数据库中。块的结构由块标题和事务列表组成。</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="fe ff kn"><img src="../Images/cc7024de54cffe4e6f3ab7fbc4052bd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kAUMg4UCZYXHDuMHoBoog.jpeg"/></div></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">Blocks linked through previous hash block saved on the block header</figcaption></figure><h1 id="c6da" class="ld le ht bd lf lg lh li lj lk ll lm ln iz lo ja lp jc lq jd lr jf ls jg lt lu dt translated"><strong class="ak">块头</strong></h1><p id="5e91" class="pw-post-body-paragraph ji jj ht jk b jl lv iu jn jo lw ix jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">块头有一个唯一的标识符，称为块头哈希，在块头中我们可以找到三个主要部分:</p><ul class=""><li id="0c57" class="ma mb ht jk b jl jm jo jp jr mc jv md jz me kd mf mg mh mi dt translated"><strong class="jk hu">前一块哈希</strong></li><li id="2807" class="ma mb ht jk b jl mj jo mk jr ml jv mm jz mn kd mf mg mh mi dt translated"><strong class="jk hu">时间戳、难度和随机数(挖掘信息在另一篇文章中讨论)</strong></li><li id="1b32" class="ma mb ht jk b jl mj jo mk jr ml jv mm jz mn kd mf mg mh mi dt translated"><strong class="jk hu">默克尔树根</strong></li></ul><h2 id="a65f" class="mo le ht bd lf mp mq mr lj ms mt mu ln jr mv mw lp jv mx my lr jz mz na lt nb dt translated"><strong class="ak">块头散列</strong></h2><p id="a8e5" class="pw-post-body-paragraph ji jj ht jk b jl lv iu jn jo lw ix jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">每个块都由一个散列号<strong class="jk hu">唯一且明确地标识</strong>。这个数字是通过使用SHA256算法对块头进行双重哈希运算获得的。<strong class="jk hu">报头散列不存储在块结构</strong>中，而是在通过网络接收块时由每个节点计算。它可能存储在单独的元数据数据库中，用于索引和更快的检索目的。</p><p id="e9e7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">区块的另一种识别形式是“<strong class="jk hu">区块高度</strong>”。每块积木都是由“<strong class="jk hu"><em class="nc">”</em></strong>”堆叠而成，因此“<em class="nc">高度</em>”的计数加1。这意味着从块#0(起源块)开始，每个新块增加总高度。截止2018年2月最后记录的块高为<a class="ae nd" href="https://blockchain.info/block-height/509415" rel="noopener ugc nofollow" target="_blank"> 509415 </a>。区块高度是第二种识别方式，尽管在某些情况下它不能作为唯一的标识符，因为可能会有两个或多个区块在同一时间竞争相同的高度。最终这种情况(分叉)会得到解决，高度只增加一个块。</p><h2 id="6c82" class="mo le ht bd lf mp mq mr lj ms mt mu ln jr mv mw lp jv mx my lr jz mz na lt nb dt translated"><strong class="ak">前一块哈希</strong></h2><p id="0976" class="pw-post-body-paragraph ji jj ht jk b jl lv iu jn jo lw ix jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">每个块都有一个<strong class="jk hu">先前块散列</strong> <strong class="jk hu">来标识其父块</strong>。块只能有一个父块，但是当几乎同时发现块时，一个块可能有多个子块。最终情况(fork)得到解决，每个块只剩下一个子块。</p><p id="ee4d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">前一个块哈希是块中非常重要的一部分，因为它将与其他信息一起哈希以获得当前块哈希。这意味着父亲的<strong class="jk hu"> ' <em class="nc">身份</em> ' </strong>被嵌入到孩子的<strong class="jk hu"> ' <em class="nc">身份</em> ' </strong>中，正因为如此，对父亲哈希的任何改变都意味着对孩子哈希的修改，也意味着对孙子哈希的修改，以此类推。这确保了一旦一个块后面有许多代，在不强制重新计算所有后续块的情况下，它不能被改变。这是区块链不变性的基础，因为这样做，将需要非常高的计算能力几乎<em class="nc">‘不可能’</em>才能得到。在另一篇文章中，我们将分析这种几乎不可能的力量，以及在51%的攻击或量子计算机力量下破解它的方法。</p><h2 id="fee2" class="mo le ht bd lf mp mq mr lj ms mt mu ln jr mv mw lp jv mx my lr jz mz na lt nb dt translated"><strong class="ak"> Merkle树</strong></h2><p id="c811" class="pw-post-body-paragraph ji jj ht jk b jl lv iu jn jo lw ix jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated">Merkle树是一种二叉树，其叶子上包含加密散列。术语'<em class="nc">树</em>'在计算机科学中用于描述分支数据结构。比特币区块链中的每个区块都包含一个使用Merkle树的区块中所有交易的摘要。</p><p id="0b22" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">比特币中的Merkle树是通过递归散列一对节点直到只有一个散列来构建的:<strong class="jk hu">Merkle根</strong>。请注意，在这种情况下，节点意味着我们在叶级别对事务进行哈希处理，而在任何其他父级别，我们都在对事务进行哈希处理。别担心，看下一张图，它会帮助你理解:</p><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="fe ff ne"><img src="../Images/55c298dd735b8f5c54cf8426082c20e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3tacutxrkIH_7oHvXH0Ow.jpeg"/></div></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">Hashing with SHA256 a pair of transactions to get the parent node.</figcaption></figure><figure class="ko kp kq kr fq ks fe ff paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="fe ff nf"><img src="../Images/7cb2d980c18c3c68153503cd1e291ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1zhrUT4TKEjXbLQvrjHYA.jpeg"/></div></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">The Merkle tree can be expanded to many transactions as needed.</figcaption></figure><p id="5042" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">每个叶子是事务数据上SHA256 的<strong class="jk hu">双重散列。最终结果(Merkle根)存储在块头中。由于Merkle树是一个二叉树，它需要偶数个节点，如果我们有奇数个节点，我们添加一个重复的事务，然后<em class="nc">瞧！</em>偶数个节点！</strong></p><p id="1dd9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这是一个<strong class="jk hu">非常有效的数据结构</strong>来检查一个值是否在里面，在这个例子中检查树中是否有一个事务。通过提供一组散列，节点可以证明事务与报头中的Merkle根相关，因此被包括在树中(事务列表)。这种方法被称为“<strong class="jk hu"> <em class="nc"> Merkle认证路径</em> </strong>”，SPV节点使用它来验证块是否有交易。正如我们在<a class="ae nd" rel="noopener" href="/@sheinix/the-bitcoin-network-6713cb8713d">另一篇文章</a>中看到的，SPV节点存储块头，它实际上包含Merkle根。然后，它将向所有节点询问一组符合“<em class="nc">认证路径</em>的散列，并用它们来证明某个事务在符合已知Merkle根的Merkle树内。比特币节点可以产生10-12个哈希的路径，以证明一个交易是在一个超过1000个交易的树中。</p><p id="c29a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><em class="nc">这是比特币区块链的基础知识。现在，你可以更好地理解我们说区块链是为了什么。</em></p><p id="0962" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">下次见！</p><h1 id="c874" class="ld le ht bd lf lg lh li lj lk ll lm ln iz lo ja lp jc lq jd lr jf ls jg lt lu dt translated">行动呼吁</h1><p id="751a" class="pw-post-body-paragraph ji jj ht jk b jl lv iu jn jo lw ix jq jr lx jt ju jv ly jx jy jz lz kb kc kd hm dt translated"><a class="ae nd" href="https://mailchi.mp/fe27d17793e9/cryptolitics" rel="noopener ugc nofollow" target="_blank">如果您想了解更多关于区块链的信息，请加入我们的每周简讯，了解加密领域的所有新闻。</a></p><blockquote class="ng"><p id="0326" class="nh ni ht bd nj nk nl nm nn no np kd ek translated"><a class="ae nd" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nr ns nt nu nv ks fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nq"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>