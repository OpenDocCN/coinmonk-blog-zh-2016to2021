<html>
<head>
<title>SUPPORT VECTOR MACHINES (SVM)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">支持向量机(SVM)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/support-vector-machines-svm-b2b433419d73?source=collection_archive---------6-----------------------#2018-06-29">https://medium.com/coinmonks/support-vector-machines-svm-b2b433419d73?source=collection_archive---------6-----------------------#2018-06-29</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/825eb813e918a701ae2526868e3a4b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mn7PtMiMME5rEpMa0hT47w.png"/></div></div></figure><div class=""/><p id="b1d9" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">支持向量机(SVM)是一种受监督的机器学习算法，可用于分类和回归目的。支持向量机更常用于分类问题，因此，这是我们在这篇文章中要关注的。</p><p id="b90a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在该算法中，我们将每个数据项绘制为n维空间中的一个点(其中n是您拥有的特征的数量)，每个特征的值是特定坐标的值。然后，我们通过找到能够很好地区分两类的<strong class="jd if">最优</strong> <strong class="jd if">超平面</strong>来执行分类。</p><p id="3a92" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if"> <em class="jz">超平面</em> </strong>对于一维数据是点，对于二维数据是线，对于三维数据是面，以此类推。</p><h2 id="980f" class="ka kb ie bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku dt translated">最优超平面</h2><figure class="kw kx ky kz fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff kv"><img src="../Images/12923e588f80b59c99238606716ad69e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q0sVisqoTO9LLfJIPjtjWQ.png"/></div></div></figure><p id="442f" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在图中，明显存在两个类别。一类用蓝色圆圈表示，另一类用红色方块表示。现在我们必须找到一条线来区分这两个类。正如你所看到的，这两个类之间有很多线，那么在这种情况下什么是<strong class="jd if"> <em class="jz">最优线</em> </strong>？</p><p id="5304" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">因此，我们的目标应该是找到尽可能远离所有点的直线。T15】</strong></p><figure class="kw kx ky kz fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff la"><img src="../Images/9aef01416ff2ea53bfde5fe2dba33797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oa9AIfsUTl5HyskLDFxcAg.png"/></div></div></figure><p id="7ba9" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">SVM算法的操作是基于找到给予训练样本最大最小距离的超平面。在SVM的理论中，这个距离两次获得了重要的名称<strong class="jd if">裕度</strong>。因此，最佳分离超平面<em class="jz">最大化</em>训练数据的余量。</p><p id="13a6" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，在上述情况下，寻找最佳超平面的任务很简单，因为数据点是线性可分离的。但是如果数据点不是<strong class="jd if"> <em class="jz">线性分离</em> </strong>呢？在这种情况下，我们如何找到最佳超平面。</p><h2 id="1802" class="ka kb ie bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku dt translated">如果数据点不是线性分离的怎么办？</h2><figure class="kw kx ky kz fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lb"><img src="../Images/172543615e896f7888df6e61be80535e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9UUTWIohVU6bcwgaR0FHxg.png"/></div></div></figure><p id="f6a5" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">考虑下面的情况，我们的目标是找到一个超平面(在这种情况下是直线),将这两个类分开。如你所见，这两个类之间没有分界线。SVM可以解决这个问题。我们可以引入一个新的特征z=x + y，并绘制z特征。</p><figure class="kw kx ky kz fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lc"><img src="../Images/75980eab63eb144e7789b8586f43ce24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BB5Tb9Q_BBRiyZGpNpQ_g.png"/></div></div></figure><p id="a21b" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在SVM，这两个阶层之间很容易有一个线性超平面。但是，另一个亟待解决的问题是，我们是否需要手动添加这个功能来获得一个超平面。不，SVM有一种手法叫做<a class="ae ld" href="https://en.wikipedia.org/wiki/Kernel_method" rel="noopener ugc nofollow" target="_blank"> <strong class="jd if">内核</strong> </a> <strong class="jd if">绝招</strong>。这些函数将低维输入空间转换到高维空间，即将不可分问题转换为可分问题，这些函数称为核。它主要用于非线性分离问题。</p><h2 id="660d" class="ka kb ie bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku dt translated">核</h2><p id="bb97" class="pw-post-body-paragraph jb jc ie jd b je le jg jh ji lf jk jl jm lg jo jp jq lh js jt ju li jw jx jy hm dt translated">SVM算法实际上是使用内核来实现的。在线性SVM中超平面的学习是通过使用一些线性代数来转换问题来完成的，这超出了SVM简介的范围。</p><h2 id="09b2" class="ka kb ie bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku dt translated">SVM核的例子</h2><p id="0f92" class="pw-post-body-paragraph jb jc ie jd b je le jg jh ji lf jk jl jm lg jo jp jq lh js jt ju li jw jx jy hm dt translated"><strong class="jd if">多项式内核</strong></p><p id="4a89" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">它在图像处理中很流行。</p><p id="e2ff" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">等式是:</p><figure class="kw kx ky kz fq hv fe ff paragraph-image"><div class="fe ff lj"><img src="../Images/d84fb51ff42e72ff94d12af900daeac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/0*VUzUj_1Wnqvnd0oy.png"/></div></figure><p id="b4f8" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">其中d是多项式的次数。</p><p id="9217" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">高斯核</strong></p><p id="ff4d" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">它是通用内核；当没有关于数据的先验知识时使用。等式是:</p><figure class="kw kx ky kz fq hv fe ff paragraph-image"><div class="fe ff lk"><img src="../Images/c546a4d1b0e0f092182583e94498f0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/0*lrEiJ547OQiTMhDL.png"/></div></figure><p id="dbd5" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">拉普拉斯RBF核</strong></p><p id="e862" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">它是通用内核；当没有关于数据的先验知识时使用。</p><p id="493f" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">等式是:</p><figure class="kw kx ky kz fq hv fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/47e93d05a469e19772c791add6f8dd50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*PxnzlRwJK1JmLPD-GCZOdg.png"/></div></figure><p id="2563" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你可以在这里 获得更多关于不同内核<a class="ae ld" href="https://data-flair.training/blogs/svm-kernel-functions/" rel="noopener ugc nofollow" target="_blank"> <em class="jz">的信息。</em></a></p><p id="eca8" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">SVM调谐参数</strong></p><p id="0dad" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可以使用sklearn在python中实现SVM。你可以在这里 找到更多关于SVM <a class="ae ld" href="http://scikit-learn.org/stable/modules/svm.html" rel="noopener ugc nofollow" target="_blank"> <em class="jz">的执行情况。</em></a></p><pre class="kw kx ky kz fq lm ln lo lp aw lq dt"><span id="b7a1" class="ka kb ie ln b fv lr ls l lt lu">sklearn.svm.SVC(<em class="jz">C=1.0</em>, <em class="jz">kernel='rbf'</em>, <em class="jz">degree=3</em>, <em class="jz">gamma=0.0</em>, <em class="jz">coef0=0.0</em>, <em class="jz">shrinking=True</em>, <em class="jz">probability=False</em>,<em class="jz">tol=0.001</em>, <em class="jz">cache_size=200</em>, <em class="jz">class_weight=None</em>, <em class="jz">verbose=False</em>, <em class="jz">max_iter=-1</em>, <em class="jz">random_state=None</em>)</span></pre><p id="f833" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我所说的参数是:-</p><p id="2196" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">内核</strong></p><p id="674e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们有各种内核选项，如<strong class="jd if">、【线性】、【rbf】、</strong>等。这里<strong class="jd if">【RBF】</strong><strong class="jd if">【poly】</strong>用于非线性超平面。</p><p id="d391" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">伽玛</strong></p><p id="20b2" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">“rbf”、“poly”和“sigmoid”的核系数。gamma值越高，将尝试按照训练数据集精确拟合，即泛化误差，并导致过拟合问题。</p><p id="f419" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if"> C </strong></p><p id="e5f4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">误差项的惩罚参数C。它还控制平滑决策边界和正确分类训练点之间的折衷。</p><h1 id="7193" class="lv kb ie bd kc lw lx ly kg lz ma mb kk mc md me kn mf mg mh kq mi mj mk kt ml dt translated">SVM的利与弊</h1><p id="dc25" class="pw-post-body-paragraph jb jc ie jd b je le jg jh ji lf jk jl jm lg jo jp jq lh js jt ju li jw jx jy hm dt translated"><strong class="jd if">优点:</strong></p><ul class=""><li id="828b" class="mm mn ie jd b je jf ji jj jm mo jq mp ju mq jy mr ms mt mu dt translated">它工作得很好，有清晰的分离界限</li><li id="30b2" class="mm mn ie jd b je mv ji mw jm mx jq my ju mz jy mr ms mt mu dt translated">在高维空间是有效的。</li><li id="940c" class="mm mn ie jd b je mv ji mw jm mx jq my ju mz jy mr ms mt mu dt translated">这在维数大于样本数的情况下是有效的。</li><li id="ad7c" class="mm mn ie jd b je mv ji mw jm mx jq my ju mz jy mr ms mt mu dt translated">它在决策函数中使用训练点的子集(称为支持向量)，因此它也是内存高效的。</li></ul><p id="6593" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">缺点:</strong></p><ul class=""><li id="9d80" class="mm mn ie jd b je jf ji jj jm mo jq mp ju mq jy mr ms mt mu dt translated">当我们有大的数据集时，它表现不好，因为所需的训练时间更长</li><li id="aaf8" class="mm mn ie jd b je mv ji mw jm mx jq my ju mz jy mr ms mt mu dt translated">当数据集有更多噪声时，即目标类重叠时，它的性能也不是很好</li><li id="3855" class="mm mn ie jd b je mv ji mw jm mx jq my ju mz jy mr ms mt mu dt translated">SVM没有直接提供概率估计，这些是通过昂贵的五重交叉验证计算出来的。它是Python scikit-learn库的相关SVC方法。</li></ul><p id="1e21" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">结论</strong></p><p id="3687" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我没有涉及SVM背后的数学。要了解更多，你可以学习<strong class="jd if">吴恩达的</strong> <a class="ae ld" href="http://cs229.stanford.edu/notes/cs229-notes3.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="jz">讲义</em> </a>。可能需要一些时间来理解推导过程。</p><p id="1489" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">也可以访问SVM  的<a class="ae ld" href="http://scikit-learn.org/stable/modules/svm.html" rel="noopener ugc nofollow" target="_blank"> <em class="jz"> sklearn文档，了解更多算法在python中的实现。如果你有任何疑问，可以在评论区发表。继续学习！！！</em></a></p></div></div>    
</body>
</html>