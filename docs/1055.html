<html>
<head>
<title>A guide to perform web queries in DAPP (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在DAPP中执行web查询的指南(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-guide-to-perform-web-queries-in-dapp-35683a386044?source=collection_archive---------5-----------------------#2018-07-16">https://medium.com/coinmonks/a-guide-to-perform-web-queries-in-dapp-35683a386044?source=collection_archive---------5-----------------------#2018-07-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="16b9" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">智能合约本身不提供<a class="ae ji" href="https://ethereum.stackexchange.com/questions/301/why-cant-contracts-make-api-calls" rel="noopener ugc nofollow" target="_blank"> web查询功能</a>。</h2></div><p id="830d" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jl hu"> <em class="kf">“以太坊区块链被设计成完全决定论的。</em></strong><em class="kf">这意味着，如果我把整个网络的历史，然后在我的电脑上重放，我应该总是以正确的状态结束。</em></p><p id="3d14" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><em class="kf">由于</em> <strong class="jl hu"> <em class="kf">互联网是不确定的，会随着时间而变化，那么每次我重放网络上的所有事务时，都会收到不同的答案。</em>T13】</strong></p><p id="f2c8" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><em class="kf">确定性很重要，这样节点才能达成共识。如果有一个合同要求在这个问题上的投票数，这个值可能会随时间或甚至随地点的不同而不同，导致将来的节点或无法访问这个站点的节点对网络的状态得出不同的结论，从而打破共识。</em></p><p id="b71a" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jl hu"> <em class="kf">通过要求每一个数据输入都是通过外部事务发起的，我们可以确定区块链本身包含了验证自身所需的所有信息</em> </strong> <em class="kf">。</em> <strong class="jl hu"> <em class="kf">通过使用单个契约级Oracle(</em></strong><a class="ae ji" href="https://oraclize.it" rel="noopener ugc nofollow" target="_blank"><strong class="jl hu"><em class="kf">https://oraclize . it</em></strong></a><strong class="jl hu"><em class="kf">)而不是网络或共识级特征，我们确保只有一个规范结果。</em> </strong></p><p id="7b80" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">相反，我们可以使用oraclize。</p><p id="ae7e" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">它可以发出HTTP GET和HTTP POST请求，检索IPFS数据，并利用aws实例在区块链上进行计算</p><p id="41e5" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">大多数信息都包含在文档中，但我将在这里做一个总结。</p></div><div class="ab cl kg kh hb ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hm hn ho hp hq"><h1 id="b973" class="kn ko ht bd kp kq kr ks kt ku kv kw kx iz ky ja kz jc la jd lb jf lc jg ld le dt translated">它是如何工作的？</h1><p id="cd14" class="pw-post-body-paragraph jj jk ht jl b jm lf iu jo jp lg ix jr js lh ju jv jw li jy jz ka lj kc kd ke hm dt translated"><a class="ae ji" href="https://docs.oraclize.it/#background" rel="noopener ugc nofollow" target="_blank">https://docs.oraclize.it/#background</a><br/>一种解决方案是<strong class="jl hu">接受来自不止一个不可信或部分可信方</strong>和<strong class="jl hu">的数据输入，然后仅在他们中的许多人已经提供了相同的答案或在某些约束条件下的答案</strong>之后才执行数据相关动作。这种类型的系统可以被认为是一个分散的oracle系统。不幸的是，这种方法有严重的局限性:</p><ul class=""><li id="07c6" class="lk ll ht jl b jm jn jp jq js lm jw ln ka lo ke lp lq lr ls dt translated">它<strong class="jl hu">需要一个关于数据格式的预定义标准</strong></li><li id="6b83" class="lk ll ht jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated">它本质上是低效的:所有参与方都需要付费，而且对于每一个请求，在得到足够多的答案之前都需要时间。</li></ul><p id="85c3" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">Oraclize开发的解决方案是<strong class="jl hu">证明从原始数据源获取的数据是真实的，未经篡改的</strong>。这是通过将返回的数据与一个称为真实性证明的文档一起提供来实现的。真实性证明可以建立在不同的技术之上，例如可审计的虚拟机和可信的执行环境。</p><p id="34dc" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">本文档的<a class="ae ji" href="https://docs.oraclize.it/#ethereum-quick-start-authenticity-proofs" rel="noopener ugc nofollow" target="_blank">真实性证明</a>部分提供了对Oraclize真实性证明的更详细概述。</p><p id="0b83" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">该解决方案很好地解决了Oracle问题:</p><ul class=""><li id="5231" class="lk ll ht jl b jm jn jp jq js lm jw ln ka lo ke lp lq lr ls dt translated"><strong class="jl hu">区块链应用的开发者和这类应用的用户不必信任Oraclize安全模型得到维护。</strong></li><li id="1366" class="lk ll ht jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated">数据提供商不必为了与区块链协议兼容而修改他们的服务。智能合约可以直接从网站或API访问数据。</li></ul><p id="2f4e" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">Oraclize引擎可以很容易地与不同区块链协议的私有和公共实例集成。</p><p id="8f0b" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">在构建服务时，Oraclize团队已经意识到真实性证明的概念比最初预想的具有更广泛的适用性。例如，Oraclize随机数据源甚至可以被传统的赌博应用程序使用，以确保用户操作的持续公平性</p></div><div class="ab cl kg kh hb ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hm hn ho hp hq"><h1 id="6217" class="kn ko ht bd kp kq kr ks kt ku kv kw kx iz ky ja kz jc la jd lb jf lc jg ld le dt translated">一般概念</h1><h1 id="71db" class="kn ko ht bd kp kq ly ks kt ku lz kw kx iz ma ja kz jc mb jd lb jf mc jg ld le dt translated">数据源类型</h1><p id="1f2d" class="pw-post-body-paragraph jj jk ht jl b jm lf iu jo jp lg ix jr js lh ju jv jw li jy jz ka lj kc kd ke hm dt translated"><a class="ae ji" href="http://docs.oraclize.it/#general-concepts-data-source-types" rel="noopener ugc nofollow" target="_blank">http://docs.oraclize.it/#general-concepts-data-source-types</a></p><ul class=""><li id="3e32" class="lk ll ht jl b jm jn jp jq js lm jw ln ka lo ke lp lq lr ls dt translated"><strong class="jl hu"> URL </strong>:允许访问任何网页或HTTP API端点</li><li id="b080" class="lk ll ht jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated"><strong class="jl hu"> WolframAlpha </strong>:支持对WolframAlpha计算引擎的本地访问</li><li id="6dac" class="lk ll ht jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated"><strong class="jl hu"> IPFS </strong>:提供对存储在IPFS文件中的任何内容的访问</li><li id="0334" class="lk ll ht jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated"><strong class="jl hu"> random </strong>:提供来自运行在Ledger Nano S上的安全应用程序的未经篡改的随机字节。</li><li id="2b6d" class="lk ll ht jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated"><strong class="jl hu">计算</strong>:提供任意计算的结果</li></ul><p id="cda3" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">此外，还有一些元数据源，如:</p><ul class=""><li id="7e80" class="lk ll ht jl b jm jn jp jq js lm jw ln ka lo ke lp lq lr ls dt translated"><strong class="jl hu">嵌套</strong>:支持不同类型的数据源或使用同一数据源的多个请求的组合，返回唯一的结果</li><li id="4f86" class="lk ll ht jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated"><strong class="jl hu">身份</strong>:返回查询</li><li id="aa49" class="lk ll ht jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated"><strong class="jl hu"> decrypt </strong>:它解密一个加密成Oraclize私钥的字符串</li></ul><h2 id="e478" class="md ko ht bd kp me mf mg kt mh mi mj kx js mk ml kz jw mm mn lb ka mo mp ld mq dt translated">统一资源定位器</h2><p id="6191" class="pw-post-body-paragraph jj jk ht jl b jm lf iu jo jp lg ix jr js lh ju jv jw li jy jz ka lj kc kd ke hm dt translated">URL数据源类型允许访问Internet上的任何API或网页。它<strong class="jl hu">支持HTTP GET和HTTP POST请求</strong>。</p><p id="d071" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jl hu">如果查询中只指定了一个参数，服务将默认执行HTTP GET请求</strong>。</p><p id="8bb1" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jl hu">如果指定了第二个参数，那么服务将执行HTTP POST请求，将第二个参数作为数据</strong>发布。</p><p id="7815" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">注意，如果第二个参数是有效的JSON，那么它将被这样发布。</p><p id="4e30" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">URL数据源类型支持TLSNotary证明和Android证明。</p><p id="0a10" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">通过利用计算数据源类型，可以构建更高级的HTTP功能，如基本身份验证或OAuth。</p><h2 id="c3d4" class="md ko ht bd kp me mf mg kt mh mi mj kx js mk ml kz jw mm mn lb ka mo mp ld mq dt translated">IPFS</h2><p id="0a14" class="pw-post-body-paragraph jj jk ht jl b jm lf iu jo jp lg ix jr js lh ju jv jw li jy jz ka lj kc kd ke hm dt translated">IPFS数据源类型可用于检索IPFS网络上的文件内容。</p><p id="8b09" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jl hu">该数据源期望查询中的IPFS多重散列作为唯一参数。</strong></p><p id="b480" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">例如，文件qmt 78 zsubmus 4 z 925 wzfrqq 1 qhaj 56 dqatfymuf 7 f 8 ff 5 o将返回“hello world\n”。</p><p id="ef0f" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jl hu">如果Oraclize未能在<em class="kf"> 20 </em>秒内获取IPFS内容，请求将失败。</strong></p><h2 id="7e15" class="md ko ht bd kp me mf mg kt mh mi mj kx js mk ml kz jw mm mn lb ka mo mp ld mq dt translated">计算</h2><p id="dc4c" class="pw-post-body-paragraph jj jk ht jl b jm lf iu jo jp lg ix jr js lh ju jv jw li jy jz ka lj kc kd ke hm dt translated"><strong class="jl hu">计算数据源通过利用沙盒亚马逊Web服务虚拟机，支持应用程序或脚本的可审计执行。</strong></p><p id="a380" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">应用程序必须在标准输出上打印计算结果，作为退出前的最后一行。结果可以是<strong class="jl hu">最长2500个字符</strong>。</p><p id="64e8" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">执行上下文必须由一个<a class="ae ji" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>来描述，其中构建和运行它应该直接启动主应用程序。</p><p id="f806" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jl hu">目前Oraclize只提供一种类型的可审计实例:t2.micro实例</strong>。</p><p id="c888" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">Dockerfile初始化和应用程序执行应尽快终止，因为<strong class="jl hu">执行时间上限为5分钟</strong>。(用于计算ds的当前Docker版本是1.12.1)</p><p id="c5bb" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">开发人员可以通过创建一个归档文件并将其上传到IPFS，将应用程序二进制文件或脚本、其依赖关系和docker文件发送到Oraclize。</p><p id="ef94" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">该查询期望将该档案的IPFS多重散列作为第一个参数，而下面的参数将作为环境变量传递给执行环境，使应用程序可以访问它们。</p><h1 id="6964" class="kn ko ht bd kp kq ly ks kt ku lz kw kx iz ma ja kz jc mb jd lb jf mc jg ld le dt translated">解析助手</h1><div class="mr ms fm fo mt mu"><a href="http://docs.oraclize.it/#general-concepts-query" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab ej"><div class="mw ab mx cl cj my"><h2 class="bd hu fv z el mz eo ep na er et hs dt translated">组织文档</h2><div class="nb l"><h3 class="bd b fv z el mz eo ep na er et ek translated">在区块链空间中，oracle是提供数据的一方。需要这样的数字是因为…</h3></div><div class="nc l"><p class="bd b gc z el mz eo ep na er et ek translated">docs.oraclize.it</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni nj mu"/></div></div></a></div><p id="0573" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">Oraclize提供了XML、JSON、XHTML和一个二进制解析器助手。示例:</p><ul class=""><li id="6e7a" class="lk ll ht jl b jm jn jp jq js lm jw ln ka lo ke lp lq lr ls dt translated"><strong class="jl hu"> JSON解析</strong>:从北海巨妖API中提取last-price字段，查询JSON(https://API . kraken . com/0/public/Ticker？pair = ETHUSD). result . xethzusd . c . 0</li><li id="3e54" class="lk ll ht jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated"><strong class="jl hu"> XML解析器:</strong>只需从您选择的API调用中传递XML字符串</li><li id="ec76" class="lk ll ht jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated"><strong class="jl hu"> HTML解析器</strong> : helper对于HTML抓取很有用。所需的<a class="ae ji" href="https://en.wikipedia.org/wiki/XPath" rel="noopener ugc nofollow" target="_blank"> XPATH </a>可以指定为XPATH的参数(..)如例所示:html(https://Twitter . com/oraclizeit/status/671316655893561344)。XPath(//*[包含(@class，' tweet-text '))]/text())。</li><li id="b9e8" class="lk ll ht jl b jm lt jp lu js lv jw lw ka lx ke lp lq lr ls dt translated"><strong class="jl hu">二进制助手</strong>:使用slice(offset，length)操作符来提取二进制中间结果的一部分会很有用。第一个参数是预期的偏移量，而第二个参数是返回切片的长度。比如二进制(https://www . sk . ee/crls/este id/este id 2015 . CRL)。slice(0，300)返回链接证书吊销列表中第一个证书的原始字节。</li></ul></div><div class="ab cl kg kh hb ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hm hn ho hp hq"><h1 id="cbb2" class="kn ko ht bd kp kq kr ks kt ku kv kw kx iz ky ja kz jc la jd lb jf lc jg ld le dt translated">连接到区块链</h1><p id="6f8e" class="pw-post-body-paragraph jj jk ht jl b jm lf iu jo jp lg ix jr js lh ju jv jw li jy jz ka lj kc kd ke hm dt translated">公共链</p><ul class=""><li id="c078" class="lk ll ht jl b jm jn jp jq js lm jw ln ka lo ke lp lq lr ls dt translated">Oraclize与最广泛使用的公共区块链协议进行了本机集成，如<strong class="jl hu">以太坊</strong>、<strong class="jl hu">比特币</strong>、<strong class="jl hu">根茎网</strong>主网和测试网。</li></ul><p id="bc01" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">基于以太坊的私有链</p><ul class=""><li id="7ad3" class="lk ll ht jl b jm jn jp jq js lm jw ln ka lo ke lp lq lr ls dt translated">基于以太坊的私有连锁店目前可以通过使用<strong class="jl hu">以太坊桥</strong>与Oraclize集成。包括Monax等以太坊的叉子。关于如何使用以太坊桥的更多信息将在<a class="ae ji" href="http://docs.oraclize.it/#development-tools" rel="noopener ugc nofollow" target="_blank">开发工具</a>部分提供，或者参考描述如何与testrpc一起使用的<a class="ae ji" href="https://ethereum.stackexchange.com/a/11389/5819" rel="noopener ugc nofollow" target="_blank"> StackExchange答案</a>。</li></ul></div><div class="ab cl kg kh hb ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hm hn ho hp hq"><h1 id="788e" class="kn ko ht bd kp kq kr ks kt ku kv kw kx iz ky ja kz jc la jd lb jf lc jg ld le dt translated">例子</h1><p id="db91" class="pw-post-body-paragraph jj jk ht jl b jm lf iu jo jp lg ix jr js lh ju jv jw li jy jz ka lj kc kd ke hm dt translated">使用oraclize运行ipfs的dockerfile:</p><p id="0ad2" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><a class="ae ji" href="https://docs.oraclize.it/#data-sources-computation" rel="noopener ugc nofollow" target="_blank">https://docs.oraclize.it/#data-sources-computation</a></p><p id="03d9" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">查询kraken ticker:</p><p id="f6d2" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><a class="ae ji" href="https://github.com/oraclize/ethereum-examples/blob/master/solidity/KrakenPriceTicker.sol" rel="noopener ugc nofollow" target="_blank">https://github.com/oraclize/ethereum-</a></p><p id="ef19" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><a class="ae ji" href="https://github.com/oraclize/ethereum-examples/blob/master/solidity/KrakenPriceTicker.sol" rel="noopener ugc nofollow" target="_blank">examples/blob/master/solidity/krakenpriceticker . sol</a></p><h1 id="63b7" class="kn ko ht bd kp kq ly ks kt ku lz kw kx iz ma ja kz jc mb jd lb jf mc jg ld le dt translated"><a class="ae ji" href="http://docs.oraclize.it/#ethereum-advanced-topics-encrypted-queries" rel="noopener ugc nofollow" target="_blank">加密查询</a></h1><p id="6434" class="pw-post-body-paragraph jj jk ht jl b jm lf iu jo jp lg ix jr js lh ju jv jw li jy jz ka lj kc kd ke hm dt translated">某些情况下，如公共区块链上的智能合同，可能需要一定程度的隐私来保护数据免受公众审查。</p><p id="b5bb" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">开发人员可以通过用Oraclize公钥加密查询的一部分(或全部)来进行加密的Oraclize查询。</p><p id="ce54" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">希望在公共网络中部署区块链应用程序的开发人员可能会对加密查询功能感兴趣。</p><p id="10e1" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">例如，如果一个应用程序利用来自一个经过身份验证的API的数据，那么将API密钥透露给监控公共链的任何人都是危险的。</p><p id="943b" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">Oraclize因此提供了<strong class="jl hu">加密包含在对Oraclize的公钥的查询中的参数的可能性:</strong>044992 e 9473 b 7d 90 ca 54d 2886 c 7 addd 14 a 61109 af 202 f1 c 95 e 218 b 0c 99 EB 060 c 7134 c 4 AE 46345d 0383 AC 996185762 f 04997 D6 FD 6 c 393 c 86 e 4325 c 469741 e 66 e 6。</p><p id="8d45" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><strong class="jl hu">只有Oraclize能够使用配对的私有密钥</strong>解密请求。</p><h1 id="acca" class="kn ko ht bd kp kq ly ks kt ku lz kw kx iz ma ja kz jc mb jd lb jf mc jg ld le dt translated">费用</h1><p id="f67c" class="pw-post-body-paragraph jj jk ht jl b jm lf iu jo jp lg ix jr js lh ju jv jw li jy jz ka lj kc kd ke hm dt translated">最新<a class="ae ji" href="http://docs.oraclize.it/#pricing" rel="noopener ugc nofollow" target="_blank">价格</a>:</p><figure class="nl nm nn no fq np fe ff paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="fe ff nk"><img src="../Images/7a941574f955015672f60d2ce62af519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7Gv527z4nKJn8K9Y"/></div></div></figure><p id="7e45" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">为了简化开发，Oraclize <strong class="jl hu">对使用默认gas参数</strong>完成的第一次数据请求不收取合同费用。<strong class="jl hu">连续的请求将要求合同支付Oraclize费用和支付回调交易所需的其他费用</strong>。<a class="ae ji" href="http://docs.oraclize.it/#general-concepts-query" rel="noopener ugc nofollow" target="_blank">解析助手</a></p><p id="7c89" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">两者都自动从合同余额中扣除。如果合同在他的余额中没有足够的资金，请求将失败，Oraclize不会返回任何数据。</p><p id="c6dd" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><a class="ae ji" rel="noopener" href="/@thebestchef/a-guide-to-perform-web-queries-in-dapp-part-2-98a519399d57">在DAPP中执行web查询的指南(第2部分)</a> <br/> <a class="ae ji" rel="noopener" href="/@thebestchef/a-guide-to-perform-web-queries-in-dapp-part-3-de27ceb5343a">在DAPP中执行web查询的指南(第3部分)</a></p></div></div>    
</body>
</html>