<html>
<head>
<title>Contract to Contract Communication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合同对合同通信</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/contract-to-contract-communication-a98a708960ef?source=collection_archive---------0-----------------------#2017-11-06">https://medium.com/coinmonks/contract-to-contract-communication-a98a708960ef?source=collection_archive---------0-----------------------#2017-11-06</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/3314c1b5cb261265cbccf182da1e9dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3z9P1QkNmEHPpjPguLCIUA.png"/></div></div></figure><p id="5abc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这篇文章建立在上一篇文章<a class="ae jz" rel="noopener" href="/@austin_48503/deploying-a-smart-contract-to-ethereum-86daed0ff69">中部署的<strong class="jd hu">简单</strong>合同的基础上，将智能合同部署到以太坊</a>。</p></div><div class="ab cl ka kb hb kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hm hn ho hp hq"><p id="5db1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">合同对合同的通信是任何区块链舰队的重要组成部分。正如在<a class="ae jz" href="https://concurrence.io/abstract/contractlineage/" rel="noopener ugc nofollow" target="_blank">合同谱系章节</a>中所讨论的，以太坊上的复杂项目应该使用一组更小的微服务来构建，以避免复杂性。</p><p id="27ec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们还将探索智能合约的其他一些特性，如所有权和事件。</p><p id="fe05" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们分析第二个契约，我们称之为<strong class="jd hu">调整器</strong>，它将与我们的<strong class="jd hu">简单</strong>契约接口:</p><figure class="kh ki kj kk fq iu"><div class="bz el l di"><div class="kl km l"/></div></figure><p id="d90e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">调整器</strong>契约具有<strong class="jd hu"> adjustTo() </strong>功能，该功能将添加到<strong class="jd hu">简单</strong>契约的计数中，以将其调整为<strong class="jd hu">_目标</strong>值。</p><p id="45de" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">还有一个<strong class="jd hu">所有者</strong> <em class="kn">地址</em>的概念。这是在合同部署中设置的，当调用<strong class="jd hu"> adjustTo() </strong>时，我们检查以确保<strong class="jd hu">消息发送者</strong>是<strong class="jd hu">所有者</strong>。</p><p id="f4d4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">还有一个名为<strong class="jd hu"> Adjusted </strong>的<em class="kn">事件</em>，当<strong class="jd hu"> adjustTo() </strong>函数改变<strong class="jd hu">计数</strong>时，该事件被触发。事件仅在链外可见，但它们对于调试、触发链外动作，甚至相对廉价的存储非常有用。</p><p id="ce3c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以用以下代码编译<strong class="jd hu">调节器</strong>:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="7086" class="kt ku ht kp b fv kv kw l kx ky">node compile Adjuster</span></pre><p id="9ded" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们还需要加入一个<strong class="jd hu"> dependencies.js </strong>来包含<strong class="jd hu"> Simple.sol </strong>:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="85c4" class="kt ku ht kp b fv kv kw l kx ky">const fs = require('fs'); <br/>module.exports = {   <br/> 'Simple.sol': fs.readFileSync('Simple/Simple.sol', 'utf8') <br/>}</span></pre><p id="6fe1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后我们用以下工具展开<strong class="jd hu">调节器</strong>:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="1265" class="kt ku ht kp b fv kv kw l kx ky">node deploy Adjuster</span></pre><p id="c2cf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这份合同比上一份稍微大一点，所以部署成本稍微高一点:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="7300" class="kt ku ht kp b fv kv kw l kx ky">==ETHER COST: 0.005155854000000001 $1.8045489000000006</span></pre><p id="60a1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">调节器</strong>rops ten上的地址:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="9b01" class="kt ku ht kp b fv kv kw l kx ky">0x34dcf6e1fb7dc453f514a5c4760595af5e2e2ea9</span></pre><p id="7f38" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们编写几个脚本来与这个契约进行交互。首先，我们希望一个名为<strong class="jd hu"> getOwner.js </strong>的脚本能够看到<strong class="jd hu">的所有者</strong>是谁:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="35fc" class="kt ku ht kp b fv kv kw l kx ky">module.exports = (contract,params,args)=&gt;{  <br/> contract.methods.owner().call().then((owner)=&gt;{     <br/>   console.log("OWNER:"+owner)   <br/> }) <br/>}</span><span id="a92f" class="kt ku ht kp b fv kz kw l kx ky">node contract getOwner Adjuster</span><span id="9e75" class="kt ku ht kp b fv kz kw l kx ky">OWNER:0xA3EEBd575245E0bd51aa46B87b1fFc6A1689965a</span></pre><p id="3ef3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在testnet上查看我们的本地帐户，这是我们的第二个帐户，或索引1:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="fd6f" class="kt ku ht kp b fv kv kw l kx ky">&gt; eth.accounts </span><span id="0238" class="kt ku ht kp b fv kz kw l kx ky">["0x4ffd642a057ce33579a3ca638347b402b909f6d6", "0xa3eebd575245e0bd51aa46b87b1ffc6a1689965a"]</span></pre><p id="5156" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">另一个需要的脚本是<strong class="jd hu"> adjustTo.js </strong>。这允许我们只使用<strong class="jd hu"> add() </strong>函数将<strong class="jd hu">简单</strong>契约的<strong class="jd hu">计数</strong>调整到一个特定的数字，只要我们是<strong class="jd hu">调整器</strong>契约的所有者。</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="4ea4" class="kt ku ht kp b fv kv kw l kx ky">module.exports = (contract,params,args)=&gt;{   <br/> console.log("**== adjusting Simple contract at "+args[5]+" to "+args[6]+" using account "+params.accounts[args[7]])   <br/> return contract.methods.adjustTo(args[5],args[6]).send({     <br/>  from: params.accounts[args[7]],     <br/>  gas: params.gas,     <br/>  gasPrice:params.gasPrice   <br/> }) <br/>}<br/></span></pre><p id="f265" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们回到上一节中的<strong class="jd hu">简单的</strong>契约函数来获得当前的<strong class="jd hu">计数</strong>:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="d1c5" class="kt ku ht kp b fv kv kw l kx ky">node contract getCount Simple</span><span id="87f0" class="kt ku ht kp b fv kz kw l kx ky">COUNT:0</span></pre><p id="f3d8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，让我们使用帐户索引1(即<strong class="jd hu">调整者</strong>的<strong class="jd hu">所有者</strong>)使用<strong class="jd hu">简单</strong>契约的地址将其调整为128:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="e204" class="kt ku ht kp b fv kv kw l kx ky">node contract adjustTo Adjuster null 0xD68eF7611913d0AfF3627a92F5e502696887D626 128 1</span></pre><p id="ea1c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，如果我们得到一个<strong class="jd hu">计数</strong>，我们将看到:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="f623" class="kt ku ht kp b fv kv kw l kx ky">COUNT:128</span></pre><p id="8481" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们编写一个快速脚本来读取事件链外:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="2eed" class="kt ku ht kp b fv kv kw l kx ky">module.exports = (contract,params,args)=&gt;{  <br/> contract.getPastEvents('Adjusted', {       <br/>   fromBlock: params.blockNumber,       <br/>   toBlock: 'latest'   <br/> }, function(error, events){     <br/>   console.log(events);   <br/> }) <br/>}</span></pre><p id="b461" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果我们现在运行它，我们应该会看到到目前为止所有契约交互:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="eebe" class="kt ku ht kp b fv kv kw l kx ky">{   <br/> address: '0x34DCF6E1fB7DC453F514a5C4760595af5e2E2Ea9',   <br/> transactionHash: '0xcdc8bb4b1fe7267bf4ded620c7501befb749301b7c42a4b1cb3cb5738dad4c13',   <br/> returnValues:    <br/>  Result {      <br/>   '0': '0xD68eF7611913d0AfF3627a92F5e502696887D626',      <br/>   '1': '128',      <br/>   '2': '128',      <br/>   _contractAddress: '0xD68eF7611913d0AfF3627a92F5e502696887D626',<br/>   _target: '128',      <br/>   _amount: '128' <br/>  },   <br/>  event: 'Adjusted',   <br/>  signature: '0xafa2c40f4442ec5731ad257412e46d0e88b0d8f8398f575db15a4c9192d19e29' }</span></pre><p id="3030" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以看到，如果最初的<strong class="jd hu">计数</strong>为0，而<strong class="jd hu">_目标</strong>为128，那么达到_ <strong class="jd hu">目标</strong>所需的<strong class="jd hu">_数量</strong>为128。</p><p id="ac23" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">彻底地测试每一个条件，并尝试用任何东西来达到你的合同总是好的，因为一个好的黑客也会这样做。显然，这个契约的安全性并不重要，因为简单的T21契约已经完全开放供操纵，但它有助于说明简单的测试方法。对于生产层面的合同，随着开源和广泛的审计，我们将需要有一整套的测试。</p><p id="b54f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，让我们确保当我们<strong class="jd hu"> add() </strong>超过255时，它会正确溢出。</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="1e52" class="kt ku ht kp b fv kv kw l kx ky">node contract adjustTo Adjuster null 0xD68eF7611913d0AfF3627a92F5e502696887D626 16 1</span><span id="295b" class="kt ku ht kp b fv kz kw l kx ky">COUNT:16</span></pre><p id="ecea" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们还要确保不能使用非所有者帐户运行<strong class="jd hu"> adjustTo() </strong>函数。我们将使用帐户索引0而不是1来模拟一个试图运行<strong class="jd hu"> adjustTo() </strong>函数的外国帐户:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="6f2a" class="kt ku ht kp b fv kv kw l kx ky">node contract adjustTo Adjuster null 0xD68eF7611913d0AfF3627a92F5e502696887D626 32 0</span></pre><p id="ffc3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">计数</strong>保持不变:</p><pre class="kh ki kj kk fq ko kp kq kr aw ks dt"><span id="bf54" class="kt ku ht kp b fv kv kw l kx ky">COUNT:16</span></pre><p id="2a91" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关于契约到契约的通信，最后要提到的是，当一个契约访问另一个契约的函数时，被访问契约上的<strong class="jd hu"> msg.sender </strong>是访问契约的，而不是触发交互的帐户。这意味着我们可以安全地编码，其中只有特定的契约可以被允许在另一个契约上运行某些功能。这一点以后会很重要。</p><blockquote class="la"><p id="2860" class="lb lc ht bd ld le lf lg lh li lj jy ek translated"><a class="ae jz" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ll lm ln lo lp iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff lk"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><p id="7752" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="kn">注意:按照同样的思路，</em><a class="ae jz" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7.md" rel="noopener ugc nofollow" target="_blank"><em class="kn">delegate call</em></a><em class="kn">是一个“将发送者和值从父作用域传播到子作用域”的操作码。</em></p><p id="77dc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是从<a class="ae jz" href="https://concurrence.io/exploration/contracttocontract/" rel="noopener ugc nofollow" target="_blank">合同到</a>合同勘探的摘录。</p><p id="3f7e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请访问<a class="ae jz" href="https://concurrence.io" rel="noopener ugc nofollow" target="_blank"> https://concurrence.io </a>了解有关并发Oracle网络的更多信息。</p><figure class="kh ki kj kk fq iu"><div class="bz el l di"><div class="lq km l"/></div></figure></div></div>    
</body>
</html>