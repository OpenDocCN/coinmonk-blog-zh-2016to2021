<html>
<head>
<title>Advanced smart contract security verification in Remix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Remix中的高级智能合约安全验证</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/advanced-smart-contract-security-verification-in-remix-9630b43695e5?source=collection_archive---------2-----------------------#2020-01-28">https://medium.com/coinmonks/advanced-smart-contract-security-verification-in-remix-9630b43695e5?source=collection_archive---------2-----------------------#2020-01-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="9a3c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jo"/><a class="ae jp" href="https://remix.ethereum.org" rel="noopener ugc nofollow" target="_blank"><em class="jo">Remix</em></a><em class="jo">开发环境通过</em><a class="ae jp" rel="noopener" href="/coinmonks/advanced-smart-contract-security-verification-in-remix-9630b43695e5"><em class="jo">MythX</em></a><em class="jo">插件为用户提供了一种便捷而强大的检查智能合约正确性的方式。在本文中，我将解释基础知识，并提供几个例子，包括现实世界中智能合约的安全性测试。</em></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/7a98dfa8b5a5fe159b79c31f4743e0cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bF2a_nN2OhQKEoBjUo1yaQ.jpeg"/></div></div></figure><p id="ef73" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">智能契约是不可变的(或者至少<a class="ae jp" rel="noopener" href="/consensys-diligence/upgradeability-is-a-bug-dba0203152ce">假设如此</a>，在将契约部署到mainnet之前确保程序的正确性<em class="jo">是绝对必要的。安全审计和全面的测试套件有助于确保代码没有错误。当谈到自动化测试时，编写全面的单元测试是一个很好的开始，但是这样的测试不能确保代码在所有的T21环境下都能正确运行。这就是诸如符号分析和输入模糊化等程序分析技术可以提供额外信心的地方。</em></p><p id="04e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用<a class="ae jp" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a>中的“MythX”标签，你可以使用灰盒模糊和符号分析来检查代码中的<em class="jo">断言</em>。换句话说，MythX security analyzer会全力以赴，打破您对代码的假设，并提醒您注意意外的错误。</p><p id="c4f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们从一个基本的例子开始来说明这是如何工作的。通过在代码中添加断言，你<em class="jo">断言</em>当到达特定的程序位置时，某个表达式<em class="jo">总是</em>评估为“真”。考虑以下代码:</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="5583" class="kh ki ht kd b fv kj kk l kl km">pragma solidity ^0.5.0;</span><span id="3f86" class="kh ki ht kd b fv kn kk l kl km">contract Primality {<br/>    <br/>    uint256 public largePrime = 973013;<br/>    <br/>    uint256 x;<br/>    uint256 y;<br/>    <br/>    function setX(uint256 _x) external {<br/>        x = _x;<br/>    }<br/> <br/>    function setY(uint256 _y) external {<br/>        y = _y;<br/>    }<br/>    <br/>    function checkSomething() external view {<br/>        require(x &gt; 1 &amp;&amp; x &lt; largePrime);<br/>        require(y &gt; 1 &amp;&amp; y &lt; largePrime);<br/>        assert(x*y != largePrime);<br/>    }<br/>}</span></pre><p id="8f56" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<code class="eh ko kp kq kd b">checkSomething()</code>中，我们断言<code class="eh ko kp kq kd b">uint256 largePrime</code>是质数(即它只能被1和它自己整除)。我们将此表述为:</p><ul class=""><li id="2ac9" class="kr ks ht is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz dt translated"><em class="jo">不存在大于1小于largePrime且其乘积与largePrime的值匹配的数字对x，y。</em></li></ul><p id="655f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">可以用MythX来检验上述论断是否正确。它使用两种方法:尝试许多可能的输入来确定异常是否可以被触发(<a class="ae jp" rel="noopener" href="/consensys-diligence/finding-vulnerabilities-in-smart-contracts-175c56affe2">模糊化</a>)，并使用SMT解算器检查到达失败状态的执行路径是否可行(<a class="ae jp" rel="noopener" href="/@joran.honig/introduction-to-mythril-classic-and-symbolic-execution-ef59339f259b">符号分析</a>)。</p><p id="da45" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jp" href="https://docs.mythx.io/en/latest/tools/remix/index.html" rel="noopener ugc nofollow" target="_blank">打开Remix </a>中的MythX选项卡，将上述代码复制/粘贴到一个新文件中，然后单击“分析”按钮。几分钟后，结果应该显示在“报告”选项卡中，包括一个标题为“断言违规”的问题。</p><p id="ec29" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您可以通过单击问题标题来突出显示受影响的代码行。单击标题左边的箭头会显示更详细的描述，最重要的是，MythX找到的例子违反了我们的断言。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff la"><img src="../Images/583c3b9af7acf4b77cb03b6b59dbd79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wdYHAUQcp1i6nF_KR3AXrg.png"/></div></div></figure><p id="cf1f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这种情况下，第21行显示了触发断言冲突的函数调用序列:</p><ol class=""><li id="dc91" class="kr ks ht is b it iu ix iy jb kt jf ku jj kv jn lb kx ky kz dt translated"><em class="jo">合同创建</em></li><li id="12bd" class="kr ks ht is b it lc ix ld jb le jf lf jj lg jn lb kx ky kz dt translated"><em class="jo">塞提(953) </em></li><li id="fd3f" class="kr ks ht is b it lc ix ld jb le jf lf jj lg jn lb kx ky kz dt translated"><em class="jo"> setX(1021) </em></li><li id="d2c5" class="kr ks ht is b it lc ix ld jb le jf lf jj lg jn lb kx ky kz dt translated"><em class="jo"> checkSomething() </em></li></ol><p id="6e65" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了验证MythX提供的例子是正确的，您可以将契约部署到JavaScript VM，并以触发异常的相同顺序执行函数调用。</p><p id="b640" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要使用MythX，您不需要确切地知道它是如何工作的，但是有一些关于分析服务的事实需要了解:</p><ul class=""><li id="cc82" class="kr ks ht is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz dt translated">从构造函数设置的初始状态开始，MythX探索事务序列(调用函数<em class="jo"> setY() </em>，然后是函数<em class="jo"> setX() </em>等等)。</li><li id="21b8" class="kr ks ht is b it lc ix ld jb le jf lf jj lg jn kw kx ky kz dt translated">在上面的例子中，MythX分解了一个数字。这对于非常大的数量来说是行不通的。可用于解决复杂数学和逻辑问题的计算机取决于使用哪种<a class="ae jp" href="https://blog.mythx.io/features/mythx-full-mode-security-analysis-explained/" rel="noopener ugc nofollow" target="_blank">分析模式</a>。</li><li id="161c" class="kr ks ht is b it lc ix ld jb le jf lf jj lg jn kw kx ky kz dt translated">MythX为它检测到的每个断言违规生成两个示例，但是可能存在其他情况，所以您应该在应用修复后重新运行MythX。</li></ul><h2 id="329e" class="kh ki ht bd lh li lj lk ll lm ln lo lp jb lq lr ls jf lt lu lv jj lw lx ly lz dt translated">编写正确性检查</h2><p id="8fc9" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hm dt translated">断言语句可以用来发现微妙的漏洞。一个很好的方法就是在智能合同战争游戏中作弊。大多数可靠性黑客挑战定义了玩家需要达到的特定目标。如果您将代码复制/粘贴到MythX中，并断言目标<em class="jo"> </em>的否定，这将激励MythX找到挑战的解决方案。</p><p id="1b25" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了证明这一点，我们将使用MythX解决以太战士战争游戏的<a class="ae jp" href="https://ethernaut.openzeppelin.com/level/0xe83cf387ddfd13a2db5493d014ba5b328589fb5f" rel="noopener ugc nofollow" target="_blank">第17关。该挑战的目标是通过将布尔状态变量设置为<em class="jo">真</em>来解锁“注册商”智能合同。简单地看一下代码，没有显示出任何实现这一点的明显方法(除非你在审计Solidity代码方面有点经验)。</a></p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="1376" class="kh ki ht kd b fv kj kk l kl km">pragma solidity ^0.4.23;</span><span id="c326" class="kh ki ht kd b fv kn kk l kl km">// A Locked Name Registrar<br/>contract Locked {</span><span id="1f12" class="kh ki ht kd b fv kn kk l kl km">    bool public unlocked = false;  // registrar locked, no name updates<br/>    <br/>    struct NameRecord { // map hashes to addresses<br/>        bytes32 name; // <br/>        address mappedAddress;<br/>    }</span><span id="3e5b" class="kh ki ht kd b fv kn kk l kl km">    mapping(address =&gt; NameRecord) public registeredNameRecord; //    records who registered names <br/>    mapping(bytes32 =&gt; address) public resolve; // resolves hashes to addresses<br/>    <br/>    function register(bytes32 _name, address _mappedAddress) public {<br/>        // set up the new NameRecord<br/>        NameRecord newRecord;<br/>        newRecord.name = _name;<br/>        newRecord.mappedAddress = _mappedAddress;</span><span id="903b" class="kh ki ht kd b fv kn kk l kl km">        resolve[_name] = _mappedAddress;<br/>        registeredNameRecord[msg.sender] = newRecord;</span><span id="2285" class="kh ki ht kd b fv kn kk l kl km">        require(unlocked); // only allow registrations if contract is unlocked<br/>    }<br/>}</span></pre><p id="1c32" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从安全审计员的角度考虑这一挑战，安全审计员希望确保一旦部署，合同将永远锁定。审计员可以断言如下:</p><ul class=""><li id="c997" class="kr ks ht is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz dt translated"><em class="jo">布尔变量“解锁”的值必须始终为假。</em></li></ul><p id="31ed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们可以通过向断言<code class="eh ko kp kq kd b">unlocked == false</code>的契约添加一个新函数来轻松检查这一点。将质询代码复制到Remix中，并将以下函数添加到合同类中:</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="c6cf" class="kh ki ht kd b fv kj kk l kl km">function getSolution() public {<br/>    assert(!unlocked);<br/>}</span></pre><p id="a2b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">做一个快速的MythX分析。分析完成后，您应该会在报告选项卡中看到一个标题为“断言违规”的问题。展开问题，找到MythX产生的例子(transaction 2中的“decoded calldata”)。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mf"><img src="../Images/0fdca34a6b1e4f3b2acc85cfe560b310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wWCmCJiBLPyEmt1h.jpg"/></div></div></figure><p id="749d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">函数参数相当长，会在右边被截断。将整行复制到文本编辑器中进行查看。通过对输出进行一些重新格式化，您可以在Remix中运行示例，并验证<code class="eh ko kp kq kd b">unlocked</code>确实被设置为<code class="eh ko kp kq kd b">true</code>:</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="11da" class="kh ki ht kd b fv kj kk l kl km">register(0x0000000000000000000000000000000000000000000000000000000000000006,0x0000000000000000000000000000000000000000)</span></pre><p id="53df" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为什么会这样？原来，函数<code class="eh ko kp kq kd b">register</code> <a class="ae jp" href="https://swcregistry.io/docs/SWC-109" rel="noopener ugc nofollow" target="_blank">将用户提供的值写入指向存储的未初始化结构</a>。这导致对存储槽0的写入，该存储槽恰好包含我们想要更改的布尔值(在Remix JavaScript VM中重放该操作以验证解决方案)。</p><p id="fa5d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">值得注意的是，断言违规可能有各种根本原因，包括整数溢出和下溢、写入意外的内存位置、忘记修饰符等等。只要有<em class="jo">某种</em>方法来打破断言，MythX就有可能找到它并显示实现它的步骤。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><a href="https://mythx.io/?utm_source=content&amp;utm_medium=medium"><div class="fe ff mg"><img src="../Images/5b74ac7b8709c1d9a4c472bdadf64ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c_Khj-jcI6x_HF4Lc_HLCQ.png"/></div></a></figure><h2 id="4152" class="kh ki ht bd lh li lj lk ll lm ln lo lp jb lq lr ls jf lt lu lv jj lw lx ly lz dt translated">函数前置条件和后置条件</h2><p id="7f74" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hm dt translated">前面的例子展示了检查一种特定类型的属性的断言，这种属性被称为<em class="jo">契约不变量</em>(下面将详细介绍)。除了检查全局不变量的有效性，通常还需要检查特定函数的行为，在这种情况下会使用函数前置条件和后置条件。</p><p id="7c01" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在最近与<a class="ae jp" href="https://diligence.consensys.net" rel="noopener ugc nofollow" target="_blank"> ConsenSys Diligence </a>对<a class="ae jp" href="https://0x.org" rel="noopener ugc nofollow" target="_blank"> 0x </a>智能合约进行安全审计期间，我们测试了一个对定点有符号整数实施算术运算的库。在其他事情中，我们希望确保算术函数不会上溢和下溢。</p><p id="ba18" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面是<code class="eh ko kp kq kd b">_add()</code>函数的<a class="ae jp" href="https://github.com/0xProject/0x-monorepo/blob/ac75053f697bbadb1d748ded31ad3946c4d47e1a/contracts/staking/contracts/src/libs/LibFixedMath.sol" rel="noopener ugc nofollow" target="_blank">原始版本</a>，它接受两个有符号整数参数并返回和，据说在溢出时恢复。</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="5183" class="kh ki ht kd b fv kj kk l kl km">contract FixedMath {</span><span id="63d5" class="kh ki ht kd b fv kn kk l kl km">/// <a class="ae jp" href="http://twitter.com/dev" rel="noopener ugc nofollow" target="_blank">@dev</a> Adds two numbers, reverting on overflow.<br/>    function _add(int256 a, int256 b) public pure returns (int256 c) {<br/>        c = a + b;<br/>        if (c &gt; 0 &amp;&amp; a &lt; 0 &amp;&amp; b &lt; 0) {<br/>            revert();<br/>        }<br/>        if (c &lt; 0 &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) {<br/>            revert();<br/>        }<br/>    }    <br/>}</span></pre><p id="f196" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">很难看出这个函数是否真的捕捉到了所有可能的溢出和下溢，所以这是用MythX“欺骗”的一个很好的选择。我们可以定义以下两个属性:</p><ul class=""><li id="9754" class="kr ks ht is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz dt translated"><em class="jo">和a ≥ 0，b &gt; 0必须总是正数；</em></li><li id="dc0c" class="kr ks ht is b it lc ix ld jb le jf lf jj lg jn kw kx ky kz dt translated"><em class="jo">a≤0，b &lt; 0之和必须永远是负数。</em></li></ul><p id="4653" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了不触及原始契约，我们创建了一个从我们的<em class="jo"> FixedMath </em>继承的包装契约，并覆盖目标函数来插入检查。上述属性被转换成如下断言:</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="dae8" class="kh ki ht kd b fv kj kk l kl km">contract VerifyFixedMath is FixedMath {</span><span id="8b11" class="kh ki ht kd b fv kn kk l kl km">    // The sum of two positive numbers or zero and a positive number must be a positive number</span><span id="dd3d" class="kh ki ht kd b fv kn kk l kl km">    function EnsureAddNoOverflow(int256 a, int256 b) public pure returns (int256) {<br/>   <br/>        // Preconditions</span><span id="daa0" class="kh ki ht kd b fv kn kk l kl km">        require(a &gt;= 0);<br/>        require(b &gt; 0);</span><span id="7793" class="kh ki ht kd b fv kn kk l kl km">        // Postcondition</span><span id="c2ed" class="kh ki ht kd b fv kn kk l kl km">        assert(_add(a, b) &gt; 0);<br/>    }</span><span id="9aba" class="kh ki ht kd b fv kn kk l kl km">    // The sum of two negative numbers or zero and a negative number must be a negative number</span><span id="ea2b" class="kh ki ht kd b fv kn kk l kl km">    function EnsureAddNoUnderflow(int256 a, int256 b) public pure returns (int256) {</span><span id="4cc3" class="kh ki ht kd b fv kn kk l kl km">        // Preconditions</span><span id="11c3" class="kh ki ht kd b fv kn kk l kl km">        require(a &lt;= 0);<br/>        require(b &lt; 0);</span><span id="c3a2" class="kh ki ht kd b fv kn kk l kl km">        // Postcondition</span><span id="e299" class="kh ki ht kd b fv kn kk l kl km">        assert(_add(a, b) &lt; 0);<br/>    }</span><span id="409f" class="kh ki ht kd b fv kn kk l kl km">}</span></pre><p id="3828" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行一个快速的MythX检查发现了一种整数下溢的情况:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mh"><img src="../Images/33c1fab3ddd944f5949a2593a10f7abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lAt7OIzI26DparHVOO6xaQ.png"/></div></div></figure><p id="a11a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">同样，为了查看函数参数，将解码后的调用数据从MythX选项卡复制到文本编辑器中。您应该得到以下内容:</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="bd28" class="kh ki ht kd b fv kj kk l kl km">EnsureAddNoUnderflow(-57896044618658097711785492504343953926634992332820282019728792003956564819968, -57896044618658097711785492504343953926634992332820282019728792003956564819968)</span></pre><p id="9fae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">事实证明，将最小的负数与其自身相加会导致下溢，结果为零(该问题在审计过程中得到了修复)。</p><h2 id="09ae" class="kh ki ht bd lh li lj lk ll lm ln lo lp jb lq lr ls jf lt lu lv jj lw lx ly lz dt translated">契约不变量</h2><p id="10f4" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hm dt translated">契约(或全局)不变量是应该始终成立的断言。例如，您可能希望确保:</p><ul class=""><li id="4e06" class="kr ks ht is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz dt translated"><em class="jo">“所有者”状态变量的值从不改变；</em></li><li id="7021" class="kr ks ht is b it lc ix ld jb le jf lf jj lg jn kw kx ky kz dt translated"><em class="jo">总令牌供应是恒定的(在不可铸造的令牌中)；</em></li><li id="c658" class="kr ks ht is b it lc ix ld jb le jf lf jj lg jn kw kx ky kz dt translated"><em class="jo">ERC 20代币的所有余额总和始终与总供应量相匹配。</em></li></ul><p id="aa51" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对简单不变量的检查可以挖掘出非常有趣和反直觉的错误。OpenZeppelin的Vera Bogdanich Espina的一篇文章包含了一个很好的例子。这篇文章讨论了自动验证器如何发现MakerDAO契约中的一个关键漏洞。</p><p id="17bb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个错误本身并不简单，如果你想完全理解发生了什么，我推荐你阅读<a class="ae jp" href="https://blog.openzeppelin.com/technical-description-of-makerdao-governance-critical-vulnerability-facce6bf5d5e/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin的详细文章</a>。简而言之，该漏洞允许攻击者从他们选择的提案中删除投票，并无限期锁定其他用户的MKR令牌。在她的博客文章中，Vera提供了一个易受攻击合同的简化版本:</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="095e" class="kh ki ht kd b fv kj kk l kl km">contract SimpleDSChief {<br/>    mapping(bytes32=&gt;address) public slates;<br/>    mapping(address=&gt;bytes32) public votes;<br/>    mapping(address=&gt;uint256) public approvals;<br/>    mapping(address=&gt;uint256) public deposits;</span><span id="1f31" class="kh ki ht kd b fv kn kk l kl km">function lock(uint wad) public {<br/>        deposits[msg.sender] = add(deposits[msg.sender], wad);<br/>        addWeight(wad, votes[msg.sender]);<br/>    }</span><span id="68b0" class="kh ki ht kd b fv kn kk l kl km">function free(uint wad) public {<br/>        deposits[msg.sender] = sub(deposits[msg.sender], wad);<br/>        subWeight(wad, votes[msg.sender]);<br/>    }</span><span id="48e7" class="kh ki ht kd b fv kn kk l kl km">function voteYays(address yay) public returns (bytes32){<br/>        bytes32 slate = etch(yay);<br/>        voteSlate(slate);</span><span id="2829" class="kh ki ht kd b fv kn kk l kl km">        return slate;<br/>    }</span><span id="3487" class="kh ki ht kd b fv kn kk l kl km">function etch(address yay) public returns (bytes32 slate) {<br/>        bytes32 hash = keccak256(abi.encodePacked(yay));</span><span id="35ef" class="kh ki ht kd b fv kn kk l kl km">        slates[hash] = yay;</span><span id="24c5" class="kh ki ht kd b fv kn kk l kl km">        return hash;<br/>    }<br/>    <br/>    function voteSlate(bytes32 slate) public {<br/>        uint weight = deposits[msg.sender];<br/>        subWeight(weight, votes[msg.sender]);<br/>        votes[msg.sender] = slate;<br/>        addWeight(weight, votes[msg.sender]);<br/>    }</span><span id="6b69" class="kh ki ht kd b fv kn kk l kl km">function addWeight(uint weight, bytes32 slate) internal {<br/>        address yay = slates[slate];<br/>        approvals[yay] = add(approvals[yay], weight);<br/>    }</span><span id="00dc" class="kh ki ht kd b fv kn kk l kl km">function subWeight(uint weight, bytes32 slate) internal {<br/>        address yay = slates[slate];<br/>        approvals[yay] = sub(approvals[yay], weight);<br/>    }</span><span id="78ca" class="kh ki ht kd b fv kn kk l kl km">function add(uint x, uint y) internal pure returns (uint z) {<br/>        require((z = x + y) &gt;= x);<br/>    }</span><span id="61ed" class="kh ki ht kd b fv kn kk l kl km">function sub(uint x, uint y) internal pure returns (uint z) {<br/>        require((z = x - y) &lt;= x);<br/>    }<br/>}</span></pre><p id="563a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们希望MythX在这里回答的问题是，合同是否总是确保用户的投票被计算在内。为此，我们定义了Vera建议的全局不变量:</p><ul class=""><li id="53fa" class="kr ks ht is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz dt translated"><em class="jo">用户投票的期权总批准权重必须至少等于该用户的保证金。</em></li></ul><p id="9569" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们再次创建一个包装器契约，并将断言放入一个修饰符中，然后该修饰符应用于所有公共函数。通过这种方式，我们可以确保不变量始终适用于非回复状态转换。</p><pre class="jr js jt ju fq kc kd ke kf aw kg dt"><span id="7aef" class="kh ki ht kd b fv kj kk l kl km">contract VerifySimpleDSChief is SimpleDSChief {</span><span id="1494" class="kh ki ht kd b fv kn kk l kl km">modifier checkInvariants {</span><span id="4aff" class="kh ki ht kd b fv kn kk l kl km">        _;</span><span id="7507" class="kh ki ht kd b fv kn kk l kl km">        bytes32 senderSlate = votes[msg.sender];<br/>        address option = slates[senderSlate];<br/>        uint256 senderDeposit = deposits[msg.sender];<br/>         <br/>        assert(approvals[option] &gt;= senderDeposit);<br/>    }<br/>    <br/>    function lockForActor(address addr, uint amount) internal {<br/>        deposits[addr] = amount;<br/>        addWeight(amount, votes[addr]);<br/>    }<br/>    <br/>    constructor() public checkInvariants {<br/>        <br/>        // set up the initial state with some deposits<br/>        <br/>        lockForActor(msg.sender, 1);<br/>        lockForActor(0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF, 1);<br/>        lockForActor(0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa, 1);<br/>    }</span><span id="8f38" class="kh ki ht kd b fv kn kk l kl km">function voteYays(address yay) public checkInvariants returns (bytes32) {<br/>        return super.voteYays(yay);<br/>    }</span><span id="49fb" class="kh ki ht kd b fv kn kk l kl km">function etch(address yay) public checkInvariants returns (bytes32 slate) {<br/>        return super.etch(yay);<br/>    }<br/>    <br/>    function voteSlate(bytes32 slate) public checkInvariants {<br/>        super.voteSlate(slate);<br/>    }<br/>    <br/>    function lock(uint wad) public checkInvariants {<br/>        super.lock(wad);<br/>    }<br/>    <br/>    function free(uint wad) public checkInvariants {<br/>        super.free(wad);<br/>    }<br/>}</span></pre><p id="154b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这一次，如果我们用MythX检查这一点，我们将遇到“快速”分析预设的限制:当您检查契约不变量时，总会有假阴性的残余风险，因为fuzzer和symbolic analyser都将一些存储变量建模为具体值，并且只能研究有限数量的事务。在“快速”分析模式下，工具的时间预算为120秒，这对于探索长事务序列来说是不够的。更多的计算时间意味着“更深入”的分析和更小的剩余风险(无耻的插一句:这就是为什么审计员和安全意识强的开发人员应该注册我们令人敬畏的订阅计划😀).</p><p id="6b8a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">处理一个“完整的”分析大约需要30分钟。当您从Remix请求一个完整的分析时，您将获得一个到MythX仪表板的链接，在那里您可以跟踪分析的进度并查看结果。在SimpleDSChief的情况下，分析发现我们的不变量的一个可能的反例:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mi"><img src="../Images/9e91b7124da77659a77e1582ea1e6d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5HmRlCbNahNlQzv0INxVA.png"/></div></div></figure><p id="90bc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">本质上，这个例子显示了一个用户取消他们自己的投票权重。</p><ol class=""><li id="57f9" class="kr ks ht is b it iu ix iy jb kt jf ku jj kv jn lb kx ky kz dt translated">用户调用<code class="eh ko kp kq kd b">voteSlate(bytes32)</code>，为还没有被蚀刻的石板投票(即<code class="eh ko kp kq kd b">slates[hash]</code>保存零地址)；</li><li id="7972" class="kr ks ht is b it lc ix ld jb le jf lf jj lg jn lb kx ky kz dt translated">在先前调用中投票的石板现在通过调用<code class="eh ko kp kq kd b">etch(addr)</code>来蚀刻，其中<code class="eh ko kp kq kd b">keccak256(addr)</code>等于先前调用中传递的散列；</li><li id="1a92" class="kr ks ht is b it lc ix ld jb le jf lf jj lg jn lb kx ky kz dt translated"><code class="eh ko kp kq kd b">slates[votes[msg.sender]]</code>现在指向一个不同的(非零)地址。<code class="eh ko kp kq kd b">approvals[slates[votes[msg.sender]]] == 0</code>导致断言失败。</li></ol><p id="25b4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里的关键观察是检查一个简单的不变量(“用户的投票必须总是被计算在内”)暴露了一个奇怪的异常情况，这个情况很容易被人忽略。在实践中，定义和检查一组完整的不变量提供了更大的信心，即没有遗漏任何边缘情况。</p><h1 id="dd74" class="mj ki ht bd lh mk ml mm ll mn mo mp lp mq mr ms ls mt mu mv lv mw mx my ly mz dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="a5ac" class="pw-post-body-paragraph iq ir ht is b it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn hm dt translated">MythX将模糊化、符号分析和静态检查集成到一个易于使用的界面中，应该成为每个Solidity开发人员和审计人员工具箱的一部分。通过检查全局和功能性安全属性，您可以发现细微的错误，并对代码的正确运行更有信心:</p><ul class=""><li id="c418" class="kr ks ht is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz dt translated">通过向函数添加前置条件和后置条件，可以验证函数是否总是按预期运行；</li><li id="4a9d" class="kr ks ht is b it lc ix ld jb le jf lf jj lg jn kw kx ky kz dt translated">契约不变量允许您确保某些条件在执行过程中始终成立。</li></ul><p id="7002" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">查看<a class="ae jp" href="https://docs.mythx.io/en/latest/tools/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>以获得关于为Remix、Truffle、VS代码和其他环境设置MythX的说明。在<a class="ae jp" href="https://dashboard.mythx.io/#/" rel="noopener ugc nofollow" target="_blank"> MythX仪表盘</a>上注册一个免费账户。<em class="jo">你可以在这里</em>  <em class="jo">阅读MythX评论</em> <a class="ae jp" href="https://coincodecap.com/product/mythx-8" rel="noopener ugc nofollow" target="_blank"> <em class="jo">。</em></a></p><h1 id="17cb" class="mj ki ht bd lh mk ml mm ll mn mo mp lp mq mr ms ls mt mu mv lv mw mx my ly mz dt translated">您可能还喜欢:</h1><ul class=""><li id="e298" class="kr ks ht is b it ma ix mb jb na jf nb jj nc jn kw kx ky kz dt translated"><a class="ae jp" rel="noopener" href="/consensys-diligence/detecting-the-top-4-critical-smart-contract-vulnerabilities-with-mythx-9c568d7db7a6">使用MythX检测一般性错误</a></li><li id="a905" class="kr ks ht is b it lc ix ld jb le jf lf jj lg jn kw kx ky kz dt translated"><a class="ae jp" rel="noopener" href="/consensys-diligence/checking-custom-correctness-properties-of-smart-contracts-using-mythx-25cbac5d7852">使用AssertionFailed事件检查自定义属性</a></li><li id="47a8" class="kr ks ht is b it lc ix ld jb le jf lf jj lg jn kw kx ky kz dt translated"><a class="ae jp" href="https://github.com/b-mueller/awesome-mythx-smart-contract-security-tools" rel="noopener ugc nofollow" target="_blank">牛逼的MythX工具</a></li></ul><blockquote class="nd"><p id="826a" class="ne nf ht bd ng nh ni nj nk nl nm jn ek translated"><a class="ae jp" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="no np nq nr ns jv fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nn"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff nt"><img src="../Images/a06b758bdcc47dca7c2504f298674d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_s6JsD3P0hVj32E7t9EtGg.jpeg"/></div></a></figure></div></div>    
</body>
</html>