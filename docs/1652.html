<html>
<head>
<title>Express uPort as javascript — Relay transaction to 3rd party Dapp.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将uPort表示为javascript —将交易转发给第三方Dapp。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/express-uport-as-javascript-relay-transaction-to-3rd-party-dapp-12fd226acc2f?source=collection_archive---------4-----------------------#2018-10-14">https://medium.com/coinmonks/express-uport-as-javascript-relay-transaction-to-3rd-party-dapp-12fd226acc2f?source=collection_archive---------4-----------------------#2018-10-14</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="78a2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">uPort是著名的以太坊项目。在我看来，uPort是区块链最成功的自我主权身份平台。所以我觉得了解它的策略对我们的事业是有帮助的。</p><p id="07ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我将uPort契约和IPFS或其他对象表示为javascript。然后我模拟如何工作。老实说，我不确定我的理解是否正确，尽管我尽可能地注意到了准确性，参考了<a class="ae jo" href="http://blockchainlab.com/pdf/uPort_whitepaper_DRAFT20161020.pdf" rel="noopener ugc nofollow" target="_blank">白皮书</a>和<a class="ae jo" href="https://github.com/uport-project/uport-identity" rel="noopener ugc nofollow" target="_blank"> Github </a>和<a class="ae jo" href="https://developer.uport.me/gettingstarted" rel="noopener ugc nofollow" target="_blank">官方文件</a>。请检查文件以获得准确的信息。</p><p id="c559" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这一次，我将重点讨论事务中继。请参考下图中的红色部分。</p><p id="4515" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">uPort为不懂以太坊的用户提供了很好的功能。用户可以发送无资金交易。Sensui服务器替代基金天然气。在这种情况下，事务被中继TxRelay契约。TxRelay契约也称为IdentityManager契约。</p><p id="34dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Github上的代码:<a class="ae jo" href="https://github.com/tak1827/uport-contract-js/tree/relay-tx-to-3rdparty-dapp" rel="noopener ugc nofollow" target="_blank"> uport-contract-js </a></p><p id="cdbc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">预发布:<a class="ae jo" rel="noopener" href="/coinmonks/express-uport-as-javascript-set-ipfs-hash-to-registry-contract-600c2dbf8404">将uPort表示为javascript —将IPFS哈希设置为注册管理机构合同</a></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/8cf1e58ba1e381b5f6f7486a2fbdf18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9AuFNkJEllNt-Aes4razw.png"/></div></div></figure></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h2 id="4e3a" class="ki kj ht bd kk kl km kn ko kp kq kr ks jb kt ku kv jf kw kx ky jj kz la lb lc dt translated">分成6个步骤</h2><p id="0694" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hm dt translated">我把整个过程分成6个步骤。让我从第一步跳到第四步来解释。请参考<a class="ae jo" rel="noopener" href="/coinmonks/express-uport-as-javascript-set-ipfs-hash-to-registry-contract-600c2dbf8404">上一篇</a>。</p><p id="4077" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">另一方面，让我简单解释一下这个流程的用例。我们假设第三方作为公共许可证(证明)的颁发者，然后用户将IPFS哈希设置到第三方合同以进行许可证认证。许可证托管在IPFS。</p><ol class=""><li id="b2e4" class="li lj ht is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq dt translated"><em class="lr">创建用户对象。</em></li><li id="9400" class="li lj ht is b it ls ix lt jb lu jf lv jj lw jn ln lo lp lq dt translated"><em class="lr">创建代理作为身份</em></li><li id="b720" class="li lj ht is b it ls ix lt jb lu jf lv jj lw jn ln lo lp lq dt translated"><em class="lr">生成JWT </em></li><li id="28b6" class="li lj ht is b it ls ix lt jb lu jf lv jj lw jn ln lo lp lq dt translated"><em class="lr">增加IPFS认证</em></li><li id="5d7e" class="li lj ht is b it ls ix lt jb lu jf lv jj lw jn ln lo lp lq dt translated"><em class="lr">为txRelay </em>创建签名</li><li id="dfb9" class="li lj ht is b it ls ix lt jb lu jf lv jj lw jn ln lo lp lq dt translated"><em class="lr"> Sned交易</em></li></ol></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h2 id="f47d" class="ki kj ht bd kk kl km kn ko kp kq kr ks jb kt ku kv jf kw kx ky jj kz la lb lc dt translated"><em class="lx"> 5。为txRelay </em>创建签名</h2><p id="0118" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hm dt translated">在之前的帖子中，为了保持简单，我没有签名发送交易。此时，我创建签名，因为TxRelay契约在调用IdentityManager之前验证事务。</p><p id="2c78" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，我生成私钥并检索公钥。公钥用于TxRelay合同上的签名验证。</p><p id="0035" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意，“lsitOwner”为空。此列表用于发送交易的委托。发送者和用户在这个时间是一样的，所以我让它为空。如果您想委托某人，您需要将发送者地址添加到TxRelay契约的白名单中。</p><p id="78d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请查看“data.className”。“第三方应用程序”是我新创建的第三方合同。内容与我之前在博客上创建的用户注册合同相同。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="8223" class="ki kj ht lz b fv md me l mf mg">// Generate private key for txRelay <br/>user.txRelayKey = randomBytes(32);</span><span id="a2f6" class="ki kj ht lz b fv mh me l mf mg">// Retrieve pub key and set as claimedSender<br/>// This is used for signature verification<br/>const claimedSender = privateToPublic(user.txRelayKey).toString('hex');</span><span id="c04c" class="ki kj ht lz b fv mh me l mf mg">// Empty because Tx sender is owner.<br/>// User can delegate another user as sender.<br/>const listOwner = '';</span><span id="404e" class="ki kj ht lz b fv mh me l mf mg">// Nonce is for preventing from replay attack.<br/>const nonce = TR.getNonce(claimedSender);</span><span id="b53e" class="ki kj ht lz b fv mh me l mf mg">// Data to sign<br/>const data = { <br/>  claimedSender,<br/>  sender: user.address,<br/>  identity: user.proxy,<br/>  className: 'ThirdPartyDapp', // Contract name called by proxy<br/>  methodName: 'set', // Function name called by proxy<br/>  data: {<br/>    identifier: MIM.address,<br/>    subject: user.subjects[0],<br/>    value: hash<br/>  }<br/>};</span></pre><p id="c74f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，我计算hash witch格式定义为<a class="ae jo" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-191.md" rel="noopener ugc nofollow" target="_blank"> EIP191 </a>。uPort使用这种格式。然后，使用私钥对哈希进行签名。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="4f58" class="ki kj ht lz b fv md me l mf mg">// Calculate EIP191 format hash<br/>const eip191Hash = calculateEIP191Hash(<br/>  listOwner, nonce, MIM.address, JSON.stringify(data)<br/>)</span><span id="56a6" class="ki kj ht lz b fv mh me l mf mg">const sig = ecsign(eip191Hash, user.txRelayKey, 1);</span></pre></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h2 id="968f" class="ki kj ht bd kk kl km kn ko kp kq kr ks jb kt ku kv jf kw kx ky jj kz la lb lc dt translated"><em class="lx"> 6。Sned交易</em></h2><p id="a98c" class="pw-post-body-paragraph iq ir ht is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hm dt translated">用户向Sensui服务器发送交易以获得资金。但是我没有在代码中使用gas概念，所以我跳过了融资过程。</p><p id="4f87" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">用户调用带有签名的relayMetaTx契约。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="5e61" class="ki kj ht lz b fv md me l mf mg">user.run(function() {</span><span id="bdcc" class="ki kj ht lz b fv mh me l mf mg">  // User send transaction with no fund. <br/>  // Then, funded by Sensui server.</span><span id="fe50" class="ki kj ht lz b fv mh me l mf mg">  // Send transaction to txRelay contract<br/>  TR.relayMetaTx(<br/>    sig.v, sig.r, sig.s, MIM, data, listOwner<br/>  );<br/>});</span></pre><p id="073e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">“relayMetaTx”验证签名，比较传递的公钥和从签名中恢复的公钥。如果签名有效，则调用IdentityManager的forwardTo函数。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="3e9b" class="ki kj ht lz b fv md me l mf mg">relayMetaTx(<br/>    sigV,<br/>    sigR,<br/>    sigS,<br/>    destination, <br/>    data, <br/>    listOwner<br/>) {</span><span id="46e2" class="ki kj ht lz b fv mh me l mf mg">  Assert(listOwner === '' || this.whitelist[listOwner][msg.sender],<br/>    `Not allowed listOwner: ${listOwner}`<br/>  )</span><span id="23be" class="ki kj ht lz b fv mh me l mf mg">  // Get claimedSender property of data<br/>  const claimedSender = this.getAddress(data);</span><span id="006e" class="ki kj ht lz b fv mh me l mf mg">  // EIP 191<br/>  // 0x19 :: version :: relay :: whitelistOwner :: <br/>  // nonce :: destination :: data<br/>  const h = calculateEIP191Hash(<br/>    listOwner, <br/>    this.nonce[claimedSender],<br/>    destination.address,<br/>    JSON.stringify(data)<br/>  )</span><span id="7987" class="ki kj ht lz b fv mh me l mf mg">  // Recover public key from signature<br/>  const addressFromSig = ecrecover(<br/>    h, sigV, sigR, sigS, 1).toString('hex');</span><span id="240c" class="ki kj ht lz b fv mh me l mf mg">  // Verify signature<br/>  Assert(claimedSender === addressFromSig,<br/>    `claimedSender don't correspond to addressFromSig`<br/>  )</span><span id="966a" class="ki kj ht lz b fv mh me l mf mg">  setSender(this.address);// Set sunder as TxRelay</span><span id="cc61" class="ki kj ht lz b fv mh me l mf mg">  // Increment nonce<br/>  this.nonce[claimedSender]++;<br/>    <br/>  // Specify forwardTo for simplification<br/>  Assert(<br/>    destination.forwardTo(<br/>      data.sender,<br/>      data.identity,<br/>      data.className,<br/>      data.methodName,<br/>      data.data<br/>    )<br/>  );<br/>}</span></pre><p id="9f3b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">说实话，IdentityManager和以前的博客不一样。新的一个被称为MetaIdentityManager，旨在从TxRelay协定中调用。MetaIdentityManager仅接受来自TxRelay的事务。</p><pre class="jq jr js jt fq ly lz ma mb aw mc dt"><span id="a766" class="ki kj ht lz b fv md me l mf mg">forwardTo(sender, identity, className, methodName, data) {<br/>  this.onlyAuthorized();// Only accept tx from txRelay<br/>  this.onlyOwner(identity, sender);</span><span id="5ba9" class="ki kj ht lz b fv mh me l mf mg">  setSender(this.address);// Set sender as IdentityManager</span><span id="1a0e" class="ki kj ht lz b fv mh me l mf mg">  // Forward to proxy<br/>  identity.forward(className, methodName, data);</span><span id="fd4e" class="ki kj ht lz b fv mh me l mf mg">  return true;<br/>}</span></pre><p id="a9a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">转发的事务由“ThiredPartyDapp”合同处理，与以前的博客相同。</p><blockquote class="mi"><p id="cf3a" class="mj mk ht bd ml mm mn mo mp mq mr jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="mt mu mv mw mx ju fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ms"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>