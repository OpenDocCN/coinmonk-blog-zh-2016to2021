<html>
<head>
<title>Part 3: Implementing Blockchain and Cryptocurrency with PoW consensus algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第3部分:用PoW共识算法实现区块链和加密货币</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/part-3-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-d9b8cb928e3e?source=collection_archive---------0-----------------------#2018-10-26">https://medium.com/coinmonks/part-3-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-d9b8cb928e3e?source=collection_archive---------0-----------------------#2018-10-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="d0c0" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">在node.js中使用工作共识算法证明，小规模、易于理解、全面、逐步实施区块链和加密货币</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ji"><img src="../Images/ca1a2e2c4224dbbeb2b00eaca6e45a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*4tiX8RcB0DnrDZZ0l8yxGw.jpeg"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek">Source: <a class="ae ju" href="https://en.bitcoinwiki.org/wiki/Proof-of-work" rel="noopener ugc nofollow" target="_blank">Bitcoin Wiki</a></figcaption></figure><p id="4133" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">在<a class="ae ju" rel="noopener" href="/coinmonks/implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-in-node-js-part-2-4524d0bf36a1">之前的文章</a>中，我们开始编写我们的区块链，并创建了我们的block类和区块链类。在本帖中，我们将通过添加多个贡献者或多个矿工的能力来扩展我们的区块链。此外，我们需要一个API来与我们的区块链交互，因此我们也将制作一个express应用程序。</p><p id="0d14" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">为了增加对多个贡献者的支持，我们需要添加某种形式的验证。网络中的每个矿工可能在某个时间点有不同的链。为了实现一个共同的状态，我们需要验证我们收到的其他矿工的新链。在比特币中，使用的是最长链规则。其中，有效的链，即所有块都有效并且具有最大块数的链被认为是有效链。因此，所有矿工将他们的链替换为最长的链。</p><p id="37c2" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">我们将把这个功能添加到我们的区块链中。</p><p id="df89" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">我们将在区块链类中创建一个<code class="eh kr ks kt ku b">isValidChain(chain)</code>静态函数，它告诉我们这个链是否有效。在这个函数中，我们重新计算块的散列，并将其与块的给定散列进行比较。这将检查该块是否已被篡改。</p><p id="7c66" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">在添加这个函数之前，我们需要一种方法来找到给定块实例的块的散列。让我们将此功能添加到block类中。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="kv kw l"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek">Handover a block, and I’ll hash it</figcaption></figure><p id="9db4" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">现在我们可以在我们的<code class="eh kr ks kt ku b">isValidChain()</code>函数中使用这个函数。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="kv kw l"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek">chain valid ? yes : no ;</figcaption></figure><p id="9459" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">继续前进。当我们收到一个有效的比我们的更长的新链时，我们必须使用那个链并丢弃我们的链，更正式地说，我们必须用新的更长的链替换我们的链。让我们添加这个功能。</p><p id="f559" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">在区块链类中创建一个函数<code class="eh kr ks kt ku b">replaceChain(chain)</code>。这会将当前区块链对象的新链分配给作为参数接收的新链。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="kv kw l"/></div></figure><p id="8a23" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">下面是更新后的block.js和blockchain.js文件的样子。</p><p id="f679" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">街区</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="kv kw l"/></div></figure><p id="4d4c" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">区块链</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="kv kw l"/></div></figure><p id="d343" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">接下来，我们将测试我们的<code class="eh kr ks kt ku b">isValidChain()</code>函数。我们将在一个有效的链、一个无效的链、一个无效的genesis块上测试这个函数。让我们将以下测试案例添加到blockchain.test.js文件中。为了测试这个函数，我们将在<code class="eh kr ks kt ku b">beforeEach </code>函数中创建一个新链，并将其命名为<code class="eh kr ks kt ku b">blockchain2</code>。我们将使用这个链与当前链进行比较。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="kv kw l"/></div></figure><p id="ed6b" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">为了测试<code class="eh kr ks kt ku b">replaceChain()</code>函数，让我们添加一些测试案例，看看我们的区块链是否替换了有效的较长链并拒绝了无效的较小链。将以下测试案例添加到blockchain.test.js</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="kv kw l"/></div></figure><p id="6c62" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">我们更新后的blockchain.test.js文件将如下所示</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="kv kw l"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek">The blockchain test file</figcaption></figure><p id="2f82" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">如果您运行这些测试，我们将有9个通过测试的案例。</p><p id="4b00" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">太好了。</p><p id="0144" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">让我们继续围绕我们已经创建的这个区块链系统创建一个web API。这些API将允许用户通过每个HTTP请求与区块链进行交互，由于我们很快就会有多链验证，我们将有多个minorss更新一个在整个网络上分散的区块链中共享的minor。</p><p id="e0d1" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">在我们有我们的web API之前，让我们组织我们的项目，因为我们将很快在我们的项目中添加更多的文件。</p><p id="cf68" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">创建一个名为区块链的新目录，并将块和区块链文件与测试文件一起移动到该目录中。</p><p id="12ad" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">我们的文件项目结构应该如下所示</p><pre class="jj jk jl jm fq kx ku ky kz aw la dt"><span id="e4e2" class="lb lc ht ku b fv ld le l lf lg">blockchain/<br/>     blockchain.js<br/>     blockchain.test.js<br/>     block.js<br/>     block.test.js</span></pre><p id="335e" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">由于我们有同名的blockchain.js文件和文件夹区块链，我们可以将blockchain.js重命名为index.js，并将blockchain.test.js重命名为index.test.js</p><pre class="jj jk jl jm fq kx ku ky kz aw la dt"><span id="51e3" class="lb lc ht ku b fv ld le l lf lg">blockchain.js  =&gt; index.js<br/>blockchain.test.js =&gt; index.test.js</span></pre><p id="fe73" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated"><em class="lh">不要忘记将名称区块链改为测试文件中导入的索引。</em></p><p id="18f0" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">现在让我们为我们的应用程序创建一个单独的<code class="eh kr ks kt ku b">app</code>文件夹。让我们在这个文件夹中创建一个新的<code class="eh kr ks kt ku b">index.js </code>文件。</p><p id="44b0" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">为了制作我们的API，我们将使用express模块。让我们安装它。</p><pre class="jj jk jl jm fq kx ku ky kz aw la dt"><span id="b0bd" class="lb lc ht ku b fv ld le l lf lg">npm i express --save</span></pre><p id="49af" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">为了在post请求中操作数据，我们需要一个bodyparser模块。所以把那个也装上。</p><pre class="jj jk jl jm fq kx ku ky kz aw la dt"><span id="c63b" class="lb lc ht ku b fv ld le l lf lg">npm i body-parser --save</span></pre><p id="bc9d" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">我们将有多个用户运行我们的应用程序。为了在我们自己的机器上测试这个应用程序，我们需要在每次运行新实例时在不同的端口上运行这个应用程序。因此，我们必须在每次运行新的应用程序时提供一个新的端口。</p><p id="3b37" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">我们将使用环境变量来实现这一点。我们可以从终端传递端口，并将其分配给运行应用程序的端口。默认情况下，我们将在端口3000上运行我们的应用程序。</p><pre class="jj jk jl jm fq kx ku ky kz aw la dt"><span id="2ed3" class="lb lc ht ku b fv ld le l lf lg">const HTTP_PORT = process.env.HTTP_PORT || 3001;</span><span id="da28" class="lb lc ht ku b fv li le l lf lg">// we can run our app something like the following to run on a<br/>// different port</span><span id="c3e2" class="lb lc ht ku b fv li le l lf lg">HTTP_PORT = 3002 npm run dev</span></pre><p id="649d" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">我们还需要这个API中的区块链实例来发送和接收块数据。</p><pre class="jj jk jl jm fq kx ku ky kz aw la dt"><span id="f2a0" class="lb lc ht ku b fv ld le l lf lg">const Blockchain = require('../blockchain');<br/>const blockchain = new Blockchain();</span></pre><p id="0057" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">我们还需要向我们的应用程序添加一个启动脚本。在package.json文件中，添加一个脚本来运行app目录中的index.js文件。</p><pre class="jj jk jl jm fq kx ku ky kz aw la dt"><span id="7f1e" class="lb lc ht ku b fv ld le l lf lg">"dev": "nodemon ./app"</span></pre><p id="dcda" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">我们为应用添加了一些基本的端点:</p><p id="45e9" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">Get <code class="eh kr ks kt ku b"> /blocks</code> —将链发送给用户。</p><p id="a68d" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">Post <code class="eh kr ks kt ku b">/mine</code> —在创建新块的请求中发送数据。</p><p id="2b68" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">让我们创建我们的应用程序。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="kv kw l"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek">Plain simple APIs</figcaption></figure><p id="abcc" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">太棒了。让我们在《邮差》中尝试一下。</p><p id="1764" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">发出get请求会给整个链。在我们的例子中，我们只有一个创世纪块。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff lj"><img src="../Images/58c3b80fc4da6f8ce12842e82d9baeaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*0bSH0bGwvBH67Q-Ke-PYtQ.png"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek">Get request sends the entire chain</figcaption></figure><p id="cc4b" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">发出post请求将会生成一个新的块。因此，我们还需要传入一些数据。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff lk"><img src="../Images/13ed924bb5b8c6ded0557d2061f4e57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnGdIXw8AWg-axw86bYCSg.png"/></div></div><figcaption class="jq jr fg fe ff js jt bd b be z ek">Post request with data</figcaption></figure><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff lp"><img src="../Images/9b13dd7d24f228057606d4f56d0def04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jRWtu-C3uNa55tWRDYJjuA.png"/></div></div><figcaption class="jq jr fg fe ff js jt bd b be z ek">The response has a new chain added to the blockchain</figcaption></figure><p id="e8cd" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">酷毙了。</p><p id="d9a2" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">到目前为止，我们已经创建了一个区块链，添加了多个验证功能，还在我们的区块链上制作了API，以便使用postman与它进行交互。</p><p id="f71e" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">在下一篇文章中，我们将使用web套接字创建一个p2p服务器。</p><p id="f7e9" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated"><a class="ae ju" rel="noopener" href="/coinmonks/part-4-implementing-blockchain-and-cryptocurrency-with-pow-consensus-algorithm-9201eb7e8a41">第四部分:用PoW共识算法实现区块链和加密货币</a></p></div><div class="ab cl lq lr hb ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hm hn ho hp hq"><p id="023b" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated"><em class="lh">感谢您的阅读。</em> <strong class="jx hu"> <em class="lh">在下一部分中，我们将创建一个p2p服务器，它将用于广播事务和链，以便每个节点都有一个同步链</em> </strong> <em class="lh">。希望你喜欢编码。如果你发现这很有帮助，请鼓掌。</em>T13】</p><p id="4ed5" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">如果你对区块链、以太坊或整个世界有任何疑问，请发表评论。:)</p><blockquote class="lx"><p id="4237" class="ly lz ht bd ma mb mc md me mf mg kq ek translated"><a class="ae ju" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="mi mj mk ml mm jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mh"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>