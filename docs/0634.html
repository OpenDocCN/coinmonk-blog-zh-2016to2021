<html>
<head>
<title>Ethernaut “Privacy” problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太网“隐私”问题</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethernaut-privacy-problem-7106562caee2?source=collection_archive---------3-----------------------#2018-05-28">https://medium.com/coinmonks/ethernaut-privacy-problem-7106562caee2?source=collection_archive---------3-----------------------#2018-05-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/eb5ad4899c3e9f0a99a1af55cb1b2c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*td8z-tlZSp7tAC5U0gthaA.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Bugs…I hate these guys</figcaption></figure><p id="d9e8" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这是Zeppelin Solutions的好朋友们在ether naut上撰写的一系列文章中的第五个例子，这些文章打破了令人敬畏的可靠性安全编码挑战。</p><p id="1e6e" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">现有的一系列问题非常有趣，说明了智能合约中常见的安全陷阱，因此，如果您感觉陷入了一个特定的挑战，并且只想了解解决方案的方式和原因，那么这篇文章以及我以相同术语发表的其他文章都适合您。</p><p id="7e35" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这一次将应对以下挑战:</p><figure class="kf kg kh ki fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ke"><img src="../Images/cc3a3efd9225135a4863a50770f54569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5kA0u7hwc9J02YyQTV4oQ.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">The “Privacy” Contract</figcaption></figure><blockquote class="kj kk kl"><p id="8834" class="jf jg km jh b ji jj jk jl jm jn jo jp kn jr js jt ko jv jw jx kp jz ka kb kc hm dt translated">这份合同的创建者足够小心地保护其存储的敏感区域。</p><p id="744f" class="jf jg km jh b ji jj jk jl jm jn jo jp kn jr js jt ko jv jw jx kp jz ka kb kc hm dt translated">解锁此合约以击败关卡。</p></blockquote><h1 id="24f6" class="kq kr ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">让我们检查一下合同🔍</h1><pre class="kf kg kh ki fq lo lp lq lr aw ls dt"><span id="7ef6" class="lt kr ht lp b fv lu lv l lw lx">bool public locked = true; <br/>uint256 public constant ID = block.timestamp; <br/>uint8 private flattening = 10; <br/>uint8 private denomination = 255; <br/>uint16 private awkwardness = uint16(now); <br/>bytes32[3] private data;</span></pre><p id="8bed" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">首先，合同声明了一堆存储变量和一些破坏者，只有“锁定的”(我们需要更改的)和“数据”(我们需要读取的)才是真正重要的，其余的都是来捣乱的。</p><pre class="kf kg kh ki fq lo lp lq lr aw ls dt"><span id="2522" class="lt kr ht lp b fv lu lv l lw lx">function Privacy(bytes32[3] _data) public { <br/>   data = _data;<br/>}<br/>   <br/>function unlock(bytes16 _key) public {     <br/>    require(_key == bytes16(data[2]));     <br/>    locked = false;  <br/>}</span></pre><p id="85ea" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><em class="km">构造器</em>是神秘数据最初被传递给契约的地方，找到更多关于此信息的一个选项是窥探创建此契约的事务的<strong class="jh hu">输入参数</strong>，并从那里获得相关信息。</p><p id="e49a" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><em class="km">解锁</em>功能是我们与此合同的唯一交互点，在这里我们只需要传递正确的字节序列16来解锁合同，并将此视为一次胜利。</p><h1 id="5ef0" class="kq kr ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">我们的方法🏃</h1><p id="8c03" class="pw-post-body-paragraph jf jg ht jh b ji ly jk jl jm lz jo jp jq ma js jt ju mb jw jx jy mc ka kb kc hm dt translated">这个问题和解决方案实际上与我之前提到的挑战<a class="ae kd" rel="noopener" href="/coinmonks/ethernaut-vault-problem-b2675393650b">金库问题</a>非常相似。这基本上是那个挑战的一个加强版，我们被迫知道更多一点关于存储变量的索引方式以及不同类型的转换是如何工作的。</p><p id="62fe" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">首先要知道的是，没有什么可以阻止我们窥探合同存储变量(甚至是私有变量！)非常容易，比如web 3 . eth . get storage at(/contract . address//var index/)</p><p id="bac2" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">存储变量在定义时被索引，换句话说，在这种特殊情况下，契约中首次定义的“锁定”变量将在web 3 . eth . get storage at(/contract . address/，0)中可用</p><p id="d52c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">虽然这是真的，但考虑到存储优化，事情会变得更加复杂！说明这一点的最好方法是获取所有可用的数据，看看我们得到了什么！</p><pre class="kf kg kh ki fq lo lp lq lr aw ls dt"><span id="f8f0" class="lt kr ht lp b fv lu lv l lw lx">let data = []</span><span id="50f3" class="lt kr ht lp b fv md lv l lw lx">let callbackFNConstructor = (index) =&gt; (error, contractData) =&gt; {</span><span id="7b77" class="lt kr ht lp b fv md lv l lw lx">  data[index] = contractData</span><span id="ced5" class="lt kr ht lp b fv md lv l lw lx">}</span><span id="e9ce" class="lt kr ht lp b fv md lv l lw lx">for(var i = 0; i &lt; 6; i++){</span><span id="f875" class="lt kr ht lp b fv md lv l lw lx">web3.eth.getStorageAt(contract.address, i, callbackFNConstructor(i))</span><span id="7bbb" class="lt kr ht lp b fv md lv l lw lx">}</span></pre><p id="e215" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在上面的web控制台中运行代码将获取目标契约中定义的前6个存储变量。</p><p id="5d5a" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">您应该看到这样的内容:</p><figure class="kf kg kh ki fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff me"><img src="../Images/07fa55258fc2e018c40865c818e377da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tl-8gWrBSRf4I6o6_Q2SQA.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Dat is storage data</figcaption></figure><p id="7f1b" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">但是嘿，这太奇怪了！此合同中定义了6个存储变量，而我们的数据阵列只有4个变量的信息。此外，定义的第一个变量是一个简单的布尔值，因此我们希望第一个结果类似于:</p><pre class="kf kg kh ki fq lo lp lq lr aw ls dt"><span id="c345" class="lt kr ht lp b fv lu lv l lw lx">"0x0000...001"</span></pre><p id="d95c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">相反，我们得到的比我们在第一个位置讨价还价的要多得多。</p><p id="bb83" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这一切都与存储优化有关，它遵循非常简单的规则。</p><ol class=""><li id="ae62" class="mf mg ht jh b ji jj jm jn jq mh ju mi jy mj kc mk ml mm mn dt translated">为存储变量留出的每个索引允许256位。</li><li id="6257" class="mf mg ht jh b ji mo jm mp jq mq ju mr jy ms kc mk ml mm mn dt translated">变量按照它们在契约中定义的顺序进行索引。</li><li id="8743" class="mf mg ht jh b ji mo jm mp jq mq ju mr jy ms kc mk ml mm mn dt translated">如果变量在&lt; 256 bits to represent, leftover space will be shared with subsequent variables <strong class="jh hu">下，如果它们符合</strong>。</li><li id="a713" class="mf mg ht jh b ji mo jm mp jq mq ju mr jy ms kc mk ml mm mn dt translated">常量不使用这种类型的存储。</li></ol><p id="afae" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">回顾我们的存储变量，我们可以看到索引是这样的。</p><pre class="kf kg kh ki fq lo lp lq lr aw ls dt"><span id="ef39" class="lt kr ht lp b fv lu lv l lw lx">bool public locked = true;  //rightmost bits of index[0]<br/>uint256 public constant ID = block.timestamp; //Not indexed<br/>uint8 private flattening = 10; //rightmost bits of index[0] - 2 <br/>uint8 private denomination = 255; //rightmost bits of index[0] - 4<br/>uint16 private awkwardness = uint16(now); //bits of index[0] -6<br/>bytes32[3] private data; //indexes 1,2,3 occupied by each piece</span></pre><p id="fd22" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">有了这个索引规则，我们实际上可以理解我们的<em class="km">数据[0] </em>结果:</p><figure class="kf kg kh ki fq iu fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/5a0fede3c2acb4a6db458ae2aa7418e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*95wruZ4T005mQpZje_vUog.png"/></div></figure><p id="a757" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">从十六进制</p><p id="9b09" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">01 =真</p><p id="297c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">0a = 10</p><p id="7763" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">ff = 255</p><p id="776d" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">c6a6 = "A被强制为16位'现在' "</p><p id="34d5" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">既然我们已经知道在我们取出的存储数据中什么代表什么，就很容易为我们的黑客获取相关信息:<strong class="jh hu"> <em class="km">数据【3】</em></strong>(相当于契约中的数据【2】)</p><h1 id="d6c9" class="kq kr ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">可变强制🛠</h1><pre class="kf kg kh ki fq lo lp lq lr aw ls dt"><span id="1d4f" class="lt kr ht lp b fv lu lv l lw lx">function unlock(bytes16 _key) public {     <br/>    require(_key == bytes16(data[2]));     <br/>    locked = false;  <br/>}</span></pre><p id="a085" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">unlock函数将我们的“key”与一个被强制转换为bytes16的data[2]相匹配。现在我们知道了数据[2]是什么，解决这个问题是轻而易举的，我们只需要从字节32 = &gt;字节16理解强制是如何工作的。</p><p id="b448" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">如果你有不错的编程经验，类型强制的概念应该不会陌生，但基本上是这样的:</p><pre class="kf kg kh ki fq lo lp lq lr aw ls dt"><span id="e194" class="lt kr ht lp b fv lu lv l lw lx">int datumA = 5; /This is 5/<br/>uint datumB = uint(datumA);  /This is 5/</span></pre><p id="ada6" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">datumB现在不能为负，该类型与数组索引和许多其他有用的东西有关。很简单吧？让我们看另一个例子:</p><pre class="kf kg kh ki fq lo lp lq lr aw ls dt"><span id="63c6" class="lt kr ht lp b fv lu lv l lw lx">int datumA = -5; /This is -5/<br/>uint datumB = (datumA);  /This is 115792089237316195423570985008687907853269984665640564039457584007913129639931/</span></pre><p id="d61e" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">WTF对吧？这都与你强制的类型的位表示有关。从某种意义上说，强制打破了统计类型语言的基本规则，一种处理强制的元规则出现了。不同的语言和不同的类型会有不同的结果(你应该能够将非数字字符串强制转换成uints吗？终究都是比特……)</p><p id="5ef1" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在任何情况下，理解支配强制的规则的最好方法是<a class="ae kd" href="https://solidity.readthedocs.io/" rel="noopener ugc nofollow" target="_blank">阅读文档</a>或<a class="ae kd" href="http://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank">玩弄强制直到你明白为止</a>(或者两者都做)</p><p id="a777" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我跑题了，我们对bytes32 =&gt; bytes16感兴趣，这样我们就可以知道bytes16类型的键作为输入参数发送，这个特殊的强制非常简单。</p><p id="e74d" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">你只需要取字节32数据的前半部分，那将是你新的字节16类型的数据。用它作为输入参数调用unlock方法应该可以清除最后一个障碍。</p><h1 id="cdf0" class="kq kr ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated"><strong class="ak">结论</strong></h1><p id="8fa6" class="pw-post-body-paragraph jf jg ht jh b ji ly jk jl jm lz jo jp jq ma js jt ju mb jw jx jy mc ka kb kc hm dt translated">就像保险库问题一样，这个挑战强调了在区块链中我们的私有变量(或任何真正的东西)是多么的不私有。胜利屏幕包括一个链接，链接到<a class="ae kd" rel="noopener" href="/aigang-network/how-to-read-ethereum-contract-storage-44252c8af925"> Darius关于snooping contract的存储的文章</a>,其中有更多关于更复杂数据类型的例子，我在vault问题中也链接过这些例子，所以如果你对这个话题仍然感兴趣，请务必阅读一下。</p></div></div>    
</body>
</html>