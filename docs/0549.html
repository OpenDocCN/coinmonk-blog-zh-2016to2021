<html>
<head>
<title>DSLs for Ethereum Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊合约的DSL</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/dsls-for-ethereum-contracts-380136177abd?source=collection_archive---------13-----------------------#2018-05-16">https://medium.com/coinmonks/dsls-for-ethereum-contracts-380136177abd?source=collection_archive---------13-----------------------#2018-05-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="fea4" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated"><a class="ae ji" rel="noopener" href="/coinmonks/write-your-next-ethereum-contract-in-pyramid-scheme-6b6e4deadf2f"> Pyramid </a>是一种使用面向语言编程编写智能合同的语言。人们可以开发新的编程语言，与其他所有语言进行互操作。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/68927cd50d6c0d351770b452ba1f63a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mDBQEmRAwomAiDZ_."/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae ji" href="https://twitter.com/PyramidLang" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><blockquote class="jz ka kb"><p id="030c" class="kc kd ke kf b kg kh iu ki kj kk ix kl km kn ko kp kq kr ks kt ku kv kw kx ky hm dt translated"><strong class="kf hu">署名</strong> —这是<a class="ae ji" href="https://twitter.com/TheMichaelBurge" rel="noopener ugc nofollow" target="_blank">迈克尔·伯格的</a>博客文章<a class="ae ji" href="https://www.michaelburge.us/2018/05/15/ethereum-chess-engine.html" rel="noopener ugc nofollow" target="_blank">以太坊合约的DSLs】的转载作品</a></p></blockquote><p id="61a2" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><a class="ae ji" href="https://coinmonks.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf hu">使用Coinmonks作业门户</strong> </a>查找加密作业</p><p id="a566" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><a class="ae ji" rel="noopener" href="/coinmonks/coinnmonks-crypto-writers-telegram-group-f56b4621af0a"> <strong class="kf hu"> <em class="ke">加入Coinmonks投稿人电报组。</em> </strong> </a></p><p id="751e" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><a class="ae ji" rel="noopener" href="/coinmonks/monks-need-your-help-7440418d67ec"> <strong class="kf hu"> <em class="ke">捐造僧侣</em> </strong> </a></p><p id="7db9" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">一个好的智能合同语言是一个10亿美元的问题。</p><p id="a25e" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">为什么？看看最近一些黑客攻击中损失的金额:</p><ul class=""><li id="b3fb" class="lc ld ht kf b kg kh kj kk kz le la lf lb lg ky lh li lj lk dt translated"><a class="ae ji" rel="noopener" href="/chain-cloud-company-blog/parity-multisig-hack-again-b46771eaa838">平价——3亿美元</a></li><li id="bafd" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated"><a class="ae ji" href="https://www.coindesk.com/understanding-dao-hack-journalists/" rel="noopener ugc nofollow" target="_blank">道——5千万美元</a></li><li id="5a1f" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated">100万美元</li></ul><p id="39f0" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">作为回应，人们如何改变他们的开发过程？</p><p id="6ae0" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">以太坊倾向于一般用途的<a class="ae ji" href="https://github.com/Z3Prover/z3" rel="noopener ugc nofollow" target="_blank"> SMT解算器</a>，部分设计的<a class="ae ji" href="https://coq.inria.fr/" rel="noopener ugc nofollow" target="_blank">定理证明器</a>。<a class="ae ji" href="https://www.cardano.org/en/home/" rel="noopener ugc nofollow" target="_blank"> Cardano </a>的目标是更多的前期设计，严重依赖于<a class="ae ji" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank">基于类型的工具</a>和<a class="ae ji" href="http://www.kframework.org/index.php/Main_Page" rel="noopener ugc nofollow" target="_blank"> K框架</a>。</p><p id="82ad" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">在本文中，我提出了面向语言的编程作为替代。专家为建模、令牌或原子跨链交换创建专门的语言。合同开发人员用它们来描述合同的相关部分。</p><p id="89ee" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">专家知道撰写安全合同的规则。然而，这些规则并没有得到始终如一的遵守。合同开发人员不是专家，即使是专家也可能在审查大量代码时出错。</p><p id="9be8" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">专用语言始终如一地应用安全规则，并减少了需要审查的代码量。</p><p id="4ac6" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><a class="ae ji" rel="noopener" href="/coinmonks/write-your-next-ethereum-contract-in-pyramid-scheme-6b6e4deadf2f"> Pyramid </a>是一种使用面向语言编程编写智能合同的语言。人们可以开发新的编程语言，与其他所有语言进行互操作。</p><p id="e1d4" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">作为技术演示，我开发了一个C编译器，并移植了一个<a class="ae ji" href="https://www.michaelburge.us/2017/09/10/injecting-shellcode-to-speed-up-amazon-redshift.html" rel="noopener ugc nofollow" target="_blank"> C象棋引擎</a>来运行在以太坊的虚拟机(EVM)上。合同开发人员并不期望使用C，但它是一种几乎所有程序员都知道的简单实用的语言。</p><p id="01e8" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">最后，我给对使用这种语言感兴趣的人一个关于金字塔的状态更新。</p><h1 id="3255" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">金字塔建模语言</h1><p id="efba" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">有了智能合约，“代码就是法律”。但是谁能读懂并信任1000行微妙的代码呢？</p><p id="6d06" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">首先，通常不清楚合同“正确”的含义。人们是在丢了钱之后才知道有问题，而不是之前。</p><p id="74ef" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">我提出了一种描述安全属性的语言，其中每个需求都适合一条tweet。我将这种语言应用于以太坊的ERC-20令牌标准。</p><p id="fdc0" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">代币是可交易的虚拟货币。举例来说，有许多游戏玩家或以太坊矿工拥有显卡，他们可以将显卡租给人工智能研究人员:一个令牌可以换取GPU时间。</p><p id="10c9" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">以太坊或卡尔达诺有他们自己的基础货币<strong class="kf hu">以太</strong>和<strong class="kf hu">阿达</strong>，所以你可能会奇怪为什么人们发行新货币而不是兑换基础货币。有三个常见的原因:</p><ul class=""><li id="9d43" class="lc ld ht kf b kg kh kj kk kz le la lf lb lg ky lh li lj lk dt translated">扩散:人们想要投资一个想法，而不是个人行为。先锋指数基金允许你投资于“美国经济”，而无需审查公司的商业计划，而代币允许你投资于“GPU市场”，而无需租赁数据中心的空间和采购显卡。</li><li id="65ea" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated"><strong class="kf hu">承诺</strong>:由于代币只能用于特定目的，投资者作为一个整体只能通过创造真正的生产性需求来退出。这使得这个想法更有可能成功。</li><li id="7422" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated"><strong class="kf hu">限制</strong>:一些代币需要额外的交易限制。例如:允许用户用信用卡或银行转账购买代币，或者检查用户是否是合格的投资者。</li></ul><p id="4e9e" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">因为扩散、承诺和限制都适用于我们假设的GPU市场，所以一个新的令牌将是有用的。为了能在交易所交易，它实现了ERC-20接口:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="318c" class="ms lr ht mo b fv mt mu l mv mw">contract ERC20Interface {<br/>    <strong class="mo hu">function</strong> totalSupply() <strong class="mo hu">public</strong> constant returns (uint);<br/>    <strong class="mo hu">function</strong> balanceOf(address tokenOwner) <strong class="mo hu">public</strong> constant returns (uint balance);<br/>    <strong class="mo hu">function</strong> allowance(address tokenOwner, address spender) <strong class="mo hu">public</strong> constant returns (uint remaining);<br/>    <strong class="mo hu">function</strong> transfer(address to, uint tokens) <strong class="mo hu">public</strong> returns (bool success);<br/>    <strong class="mo hu">function</strong> approve(address spender, uint tokens) <strong class="mo hu">public</strong> returns (bool success);<br/>    <strong class="mo hu">function</strong> transferFrom(address <strong class="mo hu">from</strong>, address to, uint tokens) <strong class="mo hu">public</strong> returns (bool success);<br/>    event Transfer(address indexed <strong class="mo hu">from</strong>, address indexed to, uint tokens);<br/>    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);<br/>}</span></pre><p id="722a" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">坚固性准确地描述了这些方法的数据流。但是这并没有告诉你这些方法是做什么的。为此，我们需要法律。</p><p id="e474" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">我将使用假想的<strong class="kf hu">金字塔建模语言</strong> (PML)来描述实现该接口的契约所具有的属性。这里有一个:</p><h1 id="f87a" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">1.地址持有令牌</h1><p id="5c45" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated"><code class="eh mx my mz mo b">@totalSupply <strong class="kf hu">=</strong> sum(@balanceOf $address, $address)</code></p><p id="f365" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">该定律规定，如果你将每个用户持有的所有令牌相加，你将得到<code class="eh mx my mz mo b">totalSupply()</code>。</p><p id="0fa5" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">并不是每个ERC-20合同都满足这条定律:如果在你购买后可以出售之前有两周的“持有期”，开发商可能会在<code class="eh mx my mz mo b">totalSupply</code>中包括未授予的令牌，但只在用户的<code class="eh mx my mz mo b">balanceOf</code>中计算已授予的令牌。</p><p id="ab1c" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">但是，如果您的特定合同是真的，您可以只用一行声明，您的合同不能通过将令牌隐藏在用户余额之外的东西中来铸造或销毁令牌。</p><p id="279f" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">PML <strong class="kf hu">公式</strong>有3类自由变量:</p><ul class=""><li id="0f6e" class="lc ld ht kf b kg kh kj kk kz le la lf lb lg ky lh li lj lk dt translated"><code class="eh mx my mz mo b">@</code>符号表示该标识符引用了一个契约方法。</li><li id="921d" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated">一个<code class="eh mx my mz mo b">$</code>符号可以用任何<strong class="kf hu">值</strong>替换，生成一个新的公式。</li><li id="d42e" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated">未标记的变量代表建模语言中的术语。</li></ul><p id="edef" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">没有<code class="eh mx my mz mo b">$</code>符号的公式被称为<strong class="kf hu">表达式</strong>。一些表达式——比如涉及<code class="eh mx my mz mo b">=</code>操作符的表达式——是<strong class="kf hu">命题</strong>。定律是一个公式，经过<code class="eh mx my mz mo b">$</code>-替换后，它被简化为命题。</p><p id="c917" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><code class="eh mx my mz mo b">sum</code>特殊形式将<code class="eh mx my mz mo b">$address</code>的所有可能值代入公式<code class="eh mx my mz mo b">@balanceOf $address</code>并对结果求和。</p><p id="7fb7" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">这是另一条定律:</p><h1 id="73b9" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">2.转移不会改变总供给</h1><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="53b6" class="ms lr ht mo b fv mt mu l mv mw">@totalSupply <strong class="mo hu">=</strong> @transfer $_ $_<br/>               @totalSupply</span></pre><p id="b395" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">契约的初始状态是任意的。<code class="eh mx my mz mo b">=</code>从这个初始状态“分叉宇宙”，并在每个状态中比较两个不同的动作。</p><p id="8c1f" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">在左边，我们调用契约的<code class="eh mx my mz mo b">totalSupply</code>方法。在右边，我们首先用任意两个参数调用<code class="eh mx my mz mo b">transfer</code>，然后调用<code class="eh mx my mz mo b">totalSupply</code>。<code class="eh mx my mz mo b">=</code>要求<code class="eh mx my mz mo b">totalSupply</code>返回的值相同。</p><p id="6093" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">一系列表达式计算出最后一个表达式。定律必须适用于所有可能的初始状态和对<code class="eh mx my mz mo b">$</code>变量的赋值。</p><p id="9691" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">并不是每一个ERC-20都满足这个属性:有些代币会对代币中的每一笔交易“征税”。然而，大多数是这样的，重要的是要知道这两条线是否适用于您最喜欢的令牌。</p><p id="a7c2" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">这个属性还有更强的版本:</p><h1 id="6ce8" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">3.初始化后，总供应量不变</h1><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="637e" class="ms lr ht mo b fv mt mu l mv mw">@initialize _<br/>$result <strong class="mo hu">=</strong> @totalSupply<br/>_<br/>$result <strong class="mo hu">=</strong> @totalSupply</span></pre><p id="dcae" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><code class="eh mx my mz mo b">initialize</code>方法不是ERC-20标准的一部分，但一些合同无论如何都会有。该法律接着规定“在契约被初始化之后，没有可能改变令牌的<code class="eh mx my mz mo b">totalSupply</code>”。<code class="eh mx my mz mo b">_</code>代表“任何方法调用序列”。</p><p id="22f0" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">因为<code class="eh mx my mz mo b">totalSupply</code>是无符号的，所以它满足<code class="eh mx my mz mo b">@totalSupply &gt;= 0</code>。这使得属性#3排除了产生大量令牌的整数溢出错误。PoWHCoin hack就是一个例子。</p><p id="4083" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">每个<code class="eh mx my mz mo b">=</code>对<code class="eh mx my mz mo b">totalSupply</code>进行约束。如果电源发生变化，不可能给出两个不同的值，因此两个约束中的一个会被违反。</p><p id="26cb" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">性质1、2和3是普遍性质:它们适用于所有可能的情况。有些法律在成立之前是有条件的。我们可以用<code class="eh mx my mz mo b">if</code>来限制它们:</p><h1 id="cd45" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">4.委托转移不会改变总供给</h1><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="da5f" class="ms lr ht mo b fv mt mu l mv mw">@totalSupply <strong class="mo hu">=</strong> <strong class="mo hu">if</strong> @allowance $owner $spender <strong class="mo hu">&gt;=</strong> $amount<br/>                  { @transferFrom $owner $_ $amount ; @totalSupply }<br/>                  @totalSupply</span></pre><p id="6cb5" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">委托转移允许用户授予其他用户或合同使用其代币的权限。拥有数千个代币的加密货币交易所可能需要这种许可才能进行交易。</p><p id="f482" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">这个规律主要检查<code class="eh mx my mz mo b">transferFrom</code>没有抛出异常，因为<code class="eh mx my mz mo b">=</code>的左边没有抛出异常。</p><p id="fa2e" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><code class="eh mx my mz mo b">if</code>表达式的第一行是<strong class="kf hu">条件</strong>。其他线路为<strong class="kf hu">顺向</strong>和<strong class="kf hu">替代</strong>。</p><p id="23d5" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><code class="eh mx my mz mo b">{ X ; Y }</code>是顺序执行两条语句的不区分缩进的语法。</p><p id="1b9b" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">属性4不是很有用，因为它不精确。我主要用它来介绍语法。下面是<code class="eh mx my mz mo b">transfer</code>更精确的规格:</p><h1 id="f3ae" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">5.如果转账改变了用户的余额，他们发送或接收。</h1><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="3707" class="ms lr ht mo b fv mt mu l mv mw">$balance <strong class="mo hu">=</strong> @balanceOf $addr<br/>@{$from}transfer $to $amount<br/>$newBalance <strong class="mo hu">=</strong> @balanceOf $addr<br/><strong class="mo hu">if</strong> $newBalance <strong class="mo hu">=</strong> $balance<br/>   _<br/>   ($addr <strong class="mo hu">=</strong> $from <strong class="mo hu">&amp;</strong> $balance<strong class="mo hu">-</strong>$newbalance <strong class="mo hu">=</strong> $amount) <strong class="mo hu">|</strong><br/>   ($addr <strong class="mo hu">=</strong> $to   <strong class="mo hu">&amp;</strong> $newBalance<strong class="mo hu">-</strong>$balance <strong class="mo hu">=</strong> $amount)</span></pre><p id="d816" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">这里有两个附加的语法:</p><ol class=""><li id="4349" class="lc ld ht kf b kg kh kj kk kz le la lf lb lg ky na li lj lk dt translated"><code class="eh mx my mz mo b">@{$from}transfer</code>语法将<code class="eh mx my mz mo b">$from</code>约束到调用<code class="eh mx my mz mo b">transfer</code>的地址。</li><li id="303f" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky na li lj lk dt translated"><code class="eh mx my mz mo b">&amp;</code>和<code class="eh mx my mz mo b">|</code>运算符组合了多个命题。</li></ol><h1 id="3e3e" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">使用PML</h1><p id="5ea8" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">这种建模语言只用几行字就能表达很多东西。但是你能用规范做什么呢？</p><ul class=""><li id="f352" class="lc ld ht kf b kg kh kj kk kz le la lf lb lg ky lh li lj lk dt translated"><strong class="kf hu">沟通</strong>:安全审计员和代币投资者可以使用这种语言来谈论合同，而无需改变开发过程。无需编写额外的代码。</li><li id="94d7" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated"><strong class="kf hu">测试生成</strong>:用随机或开发者选择的值替换<code class="eh mx my mz mo b">$</code>变量，并测试属性是否成立。在生成地址和加密哈希时必须小心。</li><li id="f124" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated"><strong class="kf hu">模型检查</strong>:规格可以发送给Z3这样的模型检查器。如果契约本身也可以转换成Z3，那么就有可能正式证明契约的安全性。</li></ul><p id="baba" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">自定义语言可以比实现更有效地传达意图，并允许专用工具检查意图。</p><p id="0bbb" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">Pyramid的目标是让专家创建像这种建模语言一样的专用语言。DSL可以是规范、可执行代码或测试框架。</p><p id="2cbd" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">在下一节中，我将展示我如何创建一种新语言的具体细节。</p><h1 id="2b68" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">c编译器</h1><p id="312e" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">金字塔建立在<a class="ae ji" href="http://racket-lang.org/" rel="noopener ugc nofollow" target="_blank">球拍</a>上。因为Racket专注于语言开发，所以有用于实现<a class="ae ji" href="https://docs.racket-lang.org/turnstile/index.html" rel="noopener ugc nofollow" target="_blank">类型系统</a>、<a class="ae ji" href="https://docs.racket-lang.org/redex/" rel="noopener ugc nofollow" target="_blank">语义工程</a>、<a class="ae ji" href="http://docs.racket-lang.org/brag/" rel="noopener ugc nofollow" target="_blank">解析</a>和<a class="ae ji" href="https://emina.github.io/rosette/" rel="noopener ugc nofollow" target="_blank">程序合成和验证</a>的库。</p><p id="ea63" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">使用金字塔作为代码生成器，任何人都可以创建高级智能合同语言。</p><p id="302d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">Pyramid的旗舰语言是Scheme方言，但是在这一节中，我创建了一个C编译器，它可以编译我在<a class="ae ji" href="https://www.michaelburge.us/2017/09/10/injecting-shellcode-to-speed-up-amazon-redshift.html" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中写的<a class="ae ji" href="https://github.com/MichaelBurge/ceagle/blob/master/test-support/chess-engine.c" rel="noopener ugc nofollow" target="_blank">象棋引擎</a>。引擎成功计算出一盘棋<code class="eh mx my mz mo b"><a class="ae ji" href="https://chessprogramming.wikispaces.com/Perft+Results?responseToken=0b5319559f293333b682ffb8f4b744c78" rel="noopener ugc nofollow" target="_blank">perft</a></code>。</p><p id="1989" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">我的实现基于Matthew Butterick的<a class="ae ji" href="https://beautifulracket.com/" rel="noopener ugc nofollow" target="_blank"> Beautiful球拍</a>，因此感兴趣的读者可以使用他写得很好的书作为指南。Matthew是一名律师和网页设计师，他使用面向语言的编程出版了像<a class="ae ji" href="http://practicaltypography.com/" rel="noopener ugc nofollow" target="_blank">实用排版</a>和<a class="ae ji" href="http://typographyforlawyers.com/" rel="noopener ugc nofollow" target="_blank">律师排版</a>这样的书籍。</p><h1 id="e7d9" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">概观</h1><p id="7359" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">自定义语言从第一行开始:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="0fc6" class="ms lr ht mo b fv mt mu l mv mw"><strong class="mo hu">#lang ceagle<br/></strong><br/><strong class="mo hu">typedef</strong> <strong class="mo hu">unsigned</strong> __bits 64 <strong class="mo hu">uint64_t</strong>;<br/><strong class="mo hu">typedef</strong> <strong class="mo hu">unsigned</strong> <strong class="mo hu">int</strong> bool;<br/><br/>...</span></pre><p id="b15d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">每种基于金字塔的语言都有一条<code class="eh mx my mz mo b">#lang</code>线。<code class="eh mx my mz mo b">ceagle</code>是球拍<a class="ae ji" href="https://docs.racket-lang.org/reference/collects.html" rel="noopener ugc nofollow" target="_blank">集合</a>的名称，描述了如何阅读和解释文件的其余部分。</p><p id="365d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">只有第一行有预定义的语法，其他的都可以完全定制。</p><p id="7f36" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">C编译器有以下几个编译阶段:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="b79f" class="ms lr ht mo b fv mt mu l mv mw">          <strong class="mo hu">Stage</strong>          |                        <strong class="mo hu">Output</strong></span><span id="7eb0" class="ms lr ht mo b fv nb mu l mv mw"><a class="ae ji" href="https://github.com/MichaelBurge/ceagle/blob/master/lexer.rkt" rel="noopener ugc nofollow" target="_blank">Lexer</a>                    |          Token sequence/<a class="ae ji" href="https://en.wikipedia.org/wiki/The_lexer_hack" rel="noopener ugc nofollow" target="_blank">type information</a></span><span id="b72c" class="ms lr ht mo b fv nb mu l mv mw"><a class="ae ji" href="https://github.com/MichaelBurge/ceagle/blob/master/parser.rkt" rel="noopener ugc nofollow" target="_blank">Parser</a>                   |            Parse Tree</span><span id="f6e9" class="ms lr ht mo b fv nb mu l mv mw"><a class="ae ji" href="https://github.com/MichaelBurge/ceagle/blob/master/expander.rkt" rel="noopener ugc nofollow" target="_blank">Expander</a>                 |            Syntax Tree</span><span id="292f" class="ms lr ht mo b fv nb mu l mv mw"><a class="ae ji" href="https://github.com/MichaelBurge/ceagle/blob/master/simplifier.rkt" rel="noopener ugc nofollow" target="_blank">Simplifier</a>               |            Syntax Tree</span><span id="6b28" class="ms lr ht mo b fv nb mu l mv mw"><a class="ae ji" href="https://github.com/MichaelBurge/ceagle/blob/master/compiler.rkt" rel="noopener ugc nofollow" target="_blank">Compiler</a>                 |            Pyramid Syntax Tree</span><span id="c962" class="ms lr ht mo b fv nb mu l mv mw"><a class="ae ji" href="https://github.com/MichaelBurge/ceagle/blob/master/builtins.pmd" rel="noopener ugc nofollow" target="_blank">Macros</a>                   |            Pyramid Syntax</span></pre><p id="b606" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">解析器使用<a class="ae ji" href="http://docs.racket-lang.org/brag/" rel="noopener ugc nofollow" target="_blank"> brag </a> DSL来定义<a class="ae ji" href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form" rel="noopener ugc nofollow" target="_blank"> BNF </a>语法。</p><p id="ec5d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">有趣的工作发生在<code class="eh mx my mz mo b">Compiler</code>和<code class="eh mx my mz mo b">Macros</code>模块中。</p><p id="02c2" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">自定义金字塔语言的扩展器将源代码的语法转换成一个<strong class="kf hu">翻译单元</strong>——一个包含依赖关系、特定于语言的解析树和特定于语言的AST等元数据的方案包。</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="0fb2" class="ms lr ht mo b fv mt mu l mv mw">(<strong class="mo hu">struct</strong> translation-unit ([ language        : Symbol            ]<br/>                          [ source-code     : Sexp              ]<br/>                          [ abstract-syntax : Any               ]<br/>                          [ pyramid-ast     : Pyramid           ]<br/>                          [ dependencies    : translation-units ]<br/>                          ))</span></pre><p id="ad9d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">金字塔和Ceagle是在<a class="ae ji" href="https://docs.racket-lang.org/ts-guide/" rel="noopener ugc nofollow" target="_blank">类型球拍</a>中实现的，所以上面的<code class="eh mx my mz mo b">struct</code>包含了类型注释。</p><p id="3fed" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">翻译单元按<code class="eh mx my mz mo b">dependencies</code>进行拓扑排序。翻译单元导出每个定义。</p><p id="e3e5" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">定制语言有两个组件:阅读器和扩展器。Ceagle的阅读器运行词法分析器和语法分析器阶段来创建一个<a class="ae ji" href="https://docs.racket-lang.org/guide/stx-obj.html" rel="noopener ugc nofollow" target="_blank">语法对象</a>；而扩展器是一个宏，它在这个语法上运行扩展器、简化器和编译器阶段，以形成一个翻译单元。</p><p id="6934" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">自定义语言导出一个<code class="eh mx my mz mo b">make-translation-unit</code>函数。<code class="eh mx my mz mo b">execute?</code>参数让它们以不同的方式处理入口点模块:Ceagle在最后调用<code class="eh mx my mz mo b">main</code>函数。</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="a0bb" class="ms lr ht mo b fv mt mu l mv mw"><em class="ke">; Ceagle's Expander</em><br/>(<strong class="mo hu">define-syntax</strong> (<strong class="mo hu">c-module-begin</strong> stx)<br/>  (<strong class="mo hu">syntax-case</strong> stx ()<br/>    [(<strong class="mo hu">_</strong> parse-tree) <em class="ke">; Starting with the parse tree as input...</em><br/>     <strong class="mo hu">#`</strong>(<strong class="mo hu">#</strong>%module-begin <em class="ke">; Declare a new module...</em><br/>        <strong class="mo hu">#,@</strong>(<strong class="mo hu">require-stxs</strong> <strong class="mo hu">#</strong>'parse-tree) <em class="ke">; ... that depends on other modules</em><br/>        (<strong class="mo hu">provide</strong> make-translation-unit) <em class="ke">; ... and which exports this function</em><br/><br/>        (<strong class="mo hu">define</strong> (<strong class="mo hu">make-translation-unit</strong> execute?)<br/>          (<strong class="mo hu">define</strong> abstract-syntax (<strong class="mo hu">expand-translation-unit</strong> parse-tree))<br/>          (<strong class="mo hu">define</strong> compiled (<strong class="mo hu">compile-translation-unit</strong> abstract-syntax execute?))<br/>          (<strong class="mo hu">translation-unit</strong> 'ceagle<br/>                            (<strong class="mo hu">quote</strong> parse-tree)<br/>                            abstract-syntax<br/>                            compiled<br/>                            dependencies <em class="ke">; Created from require-stxs</em><br/>                            )))]))</span></pre><p id="cd81" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><code class="eh mx my mz mo b">expand-translation-unit</code>和<code class="eh mx my mz mo b">compile-translation-unit</code>是指一个<a class="ae ji" href="https://en.wikipedia.org/wiki/Translation_unit_(programming)" rel="noopener ugc nofollow" target="_blank"> C平移单元</a>，不是金字塔<code class="eh mx my mz mo b">translation-unit</code>。</p><p id="e1ed" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">C的<code class="eh mx my mz mo b">#include</code>只适用于C源代码，但是Ceagle有一个非标准的<code class="eh mx my mz mo b">#require</code>，允许它导入任何基于金字塔的语言，并保证它们只被编译一次。这些是通过上面的<code class="eh mx my mz mo b">require-stxs</code>从解析树中提取的。</p><p id="fb70" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">大部分有趣的作品都在<code class="eh mx my mz mo b">compile-translation-unit</code>里。上面提到的《漂亮的球拍》一书更详细地涵盖了之前的所有内容。</p><p id="d720" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">为了编译一个翻译单元，我将提供编译所有4类抽象语法的规则:</p><ul class=""><li id="b752" class="lc ld ht kf b kg kh kj kk kz le la lf lb lg ky lh li lj lk dt translated">声明</li><li id="09b8" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated">声明</li><li id="ab0f" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated">公式</li><li id="5ba9" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated">类型</li></ul><p id="dc32" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">类型模块定义了Ceagle中使用的所有类型，我在下面复制了重要的类型。</p><h1 id="77f1" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">声明</h1><p id="0ff5" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">C翻译单元由顶级声明:<code class="eh mx my mz mo b">typedef</code>、全局变量和函数定义组成。entrypoint模块应该另外定义一个名为<code class="eh mx my mz mo b">main</code>的函数。</p><p id="0520" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">以下是这些的定义:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="e15b" class="ms lr ht mo b fv mt mu l mv mw"><em class="ke">; Top-level declarations</em><br/>(<strong class="mo hu">struct</strong> c-unit      ([ decls : c-declarations        ]))<br/>(<strong class="mo hu">struct</strong> c-decl-type ([ name  : Symbol                ]<br/>                     [ type  : c-type                ]))<br/>(<strong class="mo hu">struct</strong> c-decl-var  ([ name  : Symbol                ]<br/>                     [ type  : c-type                ]<br/>                     [ init  : (<strong class="mo hu">Option</strong> c-expression) ]))<br/>(<strong class="mo hu">struct</strong> c-decl-func ([ name  : Symbol                ]<br/>                     [ sig   : c-signature           ]<br/>                     [ body  : c-statement           ]))<br/>(<strong class="mo hu">define-type</strong> c-declaration  (<strong class="mo hu">U</strong> c-decl-var c-decl-type c-decl-func))<br/>(<strong class="mo hu">define-type</strong> c-declarations (<strong class="mo hu">Listof</strong> c-declaration))</span></pre><p id="cfce" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">为了减少括号的数量，我喜欢定义我的单数类型<code class="eh mx my mz mo b">c-declaration</code>的复数版本<code class="eh mx my mz mo b">c-declarations</code>。在本文中，我将只明确定义单数版本。</p><h2 id="eb41" class="ms lr ht bd ls nc nd ne lw nf ng nh ma kz ni nj mc la nk nl me lb nm nn mg no dt translated">键入别名</h2><p id="98a0" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">通过记住表中的<code class="eh mx my mz mo b">name</code>和<code class="eh mx my mz mo b">type</code>关联来实现<code class="eh mx my mz mo b">typedef</code>，以供翻译单元的其余部分使用。因为它也必须返回金字塔语法，所以它返回一个空的<code class="eh mx my mz mo b">begin</code>形式:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="7e28" class="ms lr ht mo b fv mt mu l mv mw">(<strong class="mo hu">:</strong> compile-decl-type (<strong class="mo hu">-&gt;</strong> c-decl-type Pyramid))<br/>(<strong class="mo hu">define</strong> (<strong class="mo hu">compile-decl-type</strong> x)<br/>  (<strong class="mo hu">destruct</strong> c-decl-type x)<br/>  (<strong class="mo hu">register-type!</strong> x-name x-type #f)<br/>  (<strong class="mo hu">pyr-begin</strong> (list)))</span></pre><p id="34d1" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><code class="eh mx my mz mo b">destruct</code>宏为<code class="eh mx my mz mo b">struct</code>中的每个字段定义一个变量。所以<code class="eh mx my mz mo b">x-name</code>指的是<code class="eh mx my mz mo b">(c-decl-type-name x)</code>。</p><p id="a236" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">有关如何进行类型检查的更多详细信息，请参见<code class="eh mx my mz mo b">Types</code>部分。</p><h2 id="2e6d" class="ms lr ht bd ls nc nd ne lw nf ng nh ma kz ni nj mc la nk nl me lb nm nn mg no dt translated">变量声明</h2><p id="6424" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated"><code class="eh mx my mz mo b">c-decl-var</code>是一个变量声明<code class="eh mx my mz mo b">int x = 5;</code>。有两个部分:</p><ol class=""><li id="36ac" class="lc ld ht kf b kg kh kj kk kz le la lf lb lg ky na li lj lk dt translated">记住<code class="eh mx my mz mo b">x</code>的类型是表格中的<code class="eh mx my mz mo b">int</code></li><li id="8d4c" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky na li lj lk dt translated">将声明编译成形式<code class="eh mx my mz mo b">(define x initializer)</code>，其中<code class="eh mx my mz mo b">initializer</code>或者是给定的表达式，或者是取决于类型的默认值。</li></ol><p id="da7b" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">从概念上讲，变量都是指向<code class="eh mx my mz mo b">sizeof(type)</code>字节的指针。然而，值没有同一性，所以每种类型都有一个<code class="eh mx my mz mo b">variable-definer</code>宏，它为一个值分配一个新的内存位置。</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="1357" class="ms lr ht mo b fv mt mu l mv mw">(<strong class="mo hu">:</strong> compile-decl-var (<strong class="mo hu">-&gt;</strong> c-decl-var Pyramid))<br/>(<strong class="mo hu">define</strong> (<strong class="mo hu">compile-decl-var</strong> x)<br/>  (<strong class="mo hu">destruct</strong> c-decl-var x)<br/>  (<strong class="mo hu">register-variable!</strong> x-name x-type)<br/>  (<strong class="mo hu">make-macro-application</strong> <strong class="mo hu">#`</strong>(<strong class="mo hu">#,</strong>(<strong class="mo hu">variable-definer</strong> x-type)<br/>                             <strong class="mo hu">#,</strong>x-name<br/>                             <strong class="mo hu">#,</strong>(<strong class="mo hu">shrink-pyramid</strong><br/>                                (<strong class="mo hu">if</strong> x-init<br/>                                    (<strong class="mo hu">compile-expression</strong> x-init 'rvalue)<br/>                                    (<strong class="mo hu">compile-default-initializer</strong> x-type))))))<br/><br/>(<strong class="mo hu">:</strong> variable-definer (<strong class="mo hu">-&gt;</strong> c-type PyramidQ))<br/>(<strong class="mo hu">define</strong> (<strong class="mo hu">variable-definer</strong> ty)<br/>  <em class="ke">; Handles typedefs</em><br/>  (<strong class="mo hu">define</strong> real-type (<strong class="mo hu">resolve-type</strong> ty))<br/>  (<strong class="mo hu">match</strong> real-type<br/>    [(<strong class="mo hu">struct</strong> c-type-fixed   _) <strong class="mo hu">#</strong>'%c-define-fixnum ]<br/>    [(<strong class="mo hu">struct</strong> c-type-struct  _) <strong class="mo hu">#</strong>'%c-define-struct ]<br/>    [(<strong class="mo hu">struct</strong> c-type-pointer _) <strong class="mo hu">#</strong>'%c-define-pointer]<br/>    [(<strong class="mo hu">struct</strong> c-type-union   _) <strong class="mo hu">#</strong>'%c-define-union  ]<br/>    ))</span></pre><p id="3584" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">宏期望并返回语法，因此<code class="eh mx my mz mo b">shrink-pyramid</code>函数反转编译器的扩展阶段，将AST转换回语法。</p><p id="fa7c" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">对于<code class="eh mx my mz mo b">int x = 5</code>的情况，编译器发出一个<code class="eh mx my mz mo b">%c-define-fixnum</code>宏的使用。这是用金字塔写的，看起来很像一个普通的球拍宏:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="5e46" class="ms lr ht mo b fv mt mu l mv mw">(<strong class="mo hu">define-syntax</strong> (<strong class="mo hu">%c-define-fixnum</strong> stx)<br/>  (<strong class="mo hu">syntax-case</strong> stx ()<br/>    [(<strong class="mo hu">_</strong> name init) <strong class="mo hu">#'</strong>(<strong class="mo hu">begin</strong> (<strong class="mo hu">define</strong> name (<strong class="mo hu">let</strong> ([ ptr (<strong class="mo hu">%c-allocate-fixnum</strong>) ])<br/>                                           (<strong class="mo hu">%c-word-write!</strong> ptr init)<br/>                                           ptr))<br/>                            (<strong class="mo hu">%c-noinline</strong> name))]<br/>    ))<br/><br/><em class="ke">; %#-mem-alloc is a Pyramid Standard Library primitive</em><br/>(<strong class="mo hu">defmacro</strong> (<strong class="mo hu">%c-allocate-fixnum</strong>)<br/>  <strong class="mo hu">`</strong>(<strong class="mo hu">%#</strong>-mem-alloc %<strong class="mo hu">#</strong>-WORD))</span></pre><p id="11c7" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><code class="eh mx my mz mo b">%c-noinline</code>扩展为<code class="eh mx my mz mo b">(set! name name)</code>并阻止金字塔优化器尝试内联变量:这在编译器的未来版本中是不必要的。</p><h2 id="7139" class="ms lr ht bd ls nc nd ne lw nf ng nh ma kz ni nj mc la nk nl me lb nm nn mg no dt translated">函数声明</h2><p id="73e9" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">一个函数声明看起来像<code class="eh mx my mz mo b">int main() { return 0; }</code>。一个函数有几个要求:</p><ul class=""><li id="403a" class="lc ld ht kf b kg kh kj kk kz le la lf lb lg ky lh li lj lk dt translated">函数名和签名需要记住以备后用。</li><li id="5e18" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated">函数内部定义的变量不应该逸出主体。</li><li id="a201" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated">参数以右值的形式传递，所以新的变量需要从中初始化。</li><li id="d1ba" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated">一条<code class="eh mx my mz mo b">return</code>语句用给定值完成当前函数调用。</li><li id="2439" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated">函数应该是普通的lambdas，这样它们就可以和其他金字塔程序一起使用。</li></ul><p id="bf2f" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">把所有这些放在一起，我们得到这个:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="0733" class="ms lr ht mo b fv mt mu l mv mw">(<strong class="mo hu">:</strong> compile-decl-func (<strong class="mo hu">-&gt;</strong> c-decl-func Pyramid))<br/>(<strong class="mo hu">define</strong> (<strong class="mo hu">compile-decl-func</strong> x)<br/>  (<strong class="mo hu">destruct</strong> c-decl-func x)<br/>  (<strong class="mo hu">destruct</strong> c-signature x-sig)<br/>  (<strong class="mo hu">:</strong> sigvar-init (<strong class="mo hu">-&gt;</strong> c-sigvar VariableName))<br/>  (<strong class="mo hu">define</strong> (<strong class="mo hu">sigvar-init</strong> v) (<strong class="mo hu">symbol-append</strong> (<strong class="mo hu">c-sigvar-name</strong> v)<br/>                                         '-init))<br/>  (<strong class="mo hu">:</strong> vars VariableNames)<br/>  (<strong class="mo hu">define</strong> vars (map sigvar-init x-sig-args))<br/>  (<strong class="mo hu">register-variable!</strong> x-name x-sig)<br/>  (<strong class="mo hu">declare-variable-scope</strong><br/>   <em class="ke">; (define) a new local variable for each function parameter.</em><br/>   (<strong class="mo hu">define</strong> args (<strong class="mo hu">for/list</strong> : Pyramids ([ arg x-sig-args ])<br/>                  (<strong class="mo hu">define</strong> arg-name (<strong class="mo hu">c-sigvar-name</strong> arg))<br/>                  (<strong class="mo hu">define</strong> arg-type (<strong class="mo hu">c-sigvar-type</strong> arg))<br/>                  (<strong class="mo hu">register-variable!</strong> arg-name arg-type)<br/>                  (<strong class="mo hu">make-macro-application</strong> <strong class="mo hu">#`</strong>(<strong class="mo hu">#,</strong>(<strong class="mo hu">variable-definer</strong> arg-type)<br/>                                             <strong class="mo hu">#,</strong>arg-name<br/>                                             <strong class="mo hu">#,</strong>(<strong class="mo hu">sigvar-init</strong> arg)))))<br/>   <em class="ke">; (define) the function to be a Scheme lambda.</em><br/>   (<strong class="mo hu">pyr-definition</strong> x-name<br/>                   (<strong class="mo hu">pyr-lambda</strong> vars<br/>                               <em class="ke">; quasiquote-pyramid is a macro like Lisp's</em><br/>                               <em class="ke">; quasiquote that switches between abstract and</em><br/>                               <em class="ke">; concrete Pyramid syntax</em><br/>                               (<strong class="mo hu">quasiquote-pyramid</strong><br/>                                <strong class="mo hu">`</strong>(<strong class="mo hu">begin</strong> <strong class="mo hu">,@</strong>args<br/>                                        <strong class="mo hu">,</strong>(<strong class="mo hu">with-returnpoint</strong><br/>                                           (<strong class="mo hu">compile-statement</strong> x-body))))))))<br/><br/>(<strong class="mo hu">define-syntax-rule</strong> (<strong class="mo hu">declare-variable-scope</strong> xs <strong class="mo hu">...</strong>)<br/>  <em class="ke">; Parameterize lets you temporarily modify a global variable.</em><br/>  <em class="ke">; The symbol table is restored when execution exits the body,</em><br/>  <em class="ke">; even if an exception occurs.</em><br/>  (<strong class="mo hu">parameterize</strong> ([ *variables* (<strong class="mo hu">hash-copy</strong> (<strong class="mo hu">*variables*</strong>)) ])<br/>    xs <strong class="mo hu">...</strong>))</span></pre><p id="238d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">由于金字塔是Scheme方言，所以支持Scheme的<code class="eh mx my mz mo b">call/cc</code>。<code class="eh mx my mz mo b">return</code>语句只是用给定的值调用名为<code class="eh mx my mz mo b">return</code>的延续。</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="8be5" class="ms lr ht mo b fv mt mu l mv mw">(<strong class="mo hu">:</strong> with-returnpoint (<strong class="mo hu">-&gt;</strong> Pyramid Pyramid))<br/>(<strong class="mo hu">define</strong> (<strong class="mo hu">with-returnpoint</strong> exp)<br/>  (<strong class="mo hu">with-escapepoint</strong> 'return exp))<br/><br/>(<strong class="mo hu">:</strong> with-escapepoint (<strong class="mo hu">-&gt;</strong> Symbol Pyramid Pyramid))<br/>(<strong class="mo hu">define</strong> (<strong class="mo hu">with-escapepoint</strong> name exp)<br/>  (<strong class="mo hu">expand-pyramid</strong> <strong class="mo hu">#`</strong>(call/cc (λ (<strong class="mo hu">#,</strong>name) <strong class="mo hu">#,</strong>(<strong class="mo hu">shrink-pyramid</strong> exp)))))</span></pre><p id="72d3" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><code class="eh mx my mz mo b">break</code>和<code class="eh mx my mz mo b">continue</code>也被实现为延续。<code class="eh mx my mz mo b">goto</code>语句不能像这样作为延续来实现，因为它允许你跳转到你还没有访问过的标签。</p><p id="ec63" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">这包括申报。由于我刚刚提到了<code class="eh mx my mz mo b">break</code>、<code class="eh mx my mz mo b">continue</code>和<code class="eh mx my mz mo b">goto</code>，接下来我将介绍语句。</p><h1 id="ac65" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">声明</h1><p id="2aaf" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">有4类陈述:</p><ul class=""><li id="d224" class="lc ld ht kf b kg kh kj kk kz le la lf lb lg ky lh li lj lk dt translated"><strong class="kf hu">标签</strong>是可以跳转的地方。c直接支持标签，但是大多数程序员不知道<code class="eh mx my mz mo b">switch</code>语句的<code class="eh mx my mz mo b">case</code>和<code class="eh mx my mz mo b">default</code>子句被认为是标签。C switch语句不等同于级联if/else语句:</li></ul><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="330e" class="ms lr ht mo b fv mt mu l mv mw"><strong class="mo hu">int</strong> foo(<strong class="mo hu">int</strong> x){<br/>  <strong class="mo hu">switch</strong> (x) <strong class="mo hu">while</strong> (1)<br/>     <strong class="mo hu">case</strong> 0: <strong class="mo hu">while</strong> (1)<br/>     <strong class="mo hu">case</strong> 1: <strong class="mo hu">while</strong> (1)<br/>     <strong class="mo hu">case</strong> 2: <strong class="mo hu">return</strong> x;<br/>}</span></pre><p id="7a8f" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">在这个例子中，<code class="eh mx my mz mo b">x=2</code>的值将导致开关执行<code class="eh mx my mz mo b">return</code>，跳过三个<code class="eh mx my mz mo b">while</code>循环。这不容易翻译成级联的if/else语句。</p><ul class=""><li id="a1da" class="lc ld ht kf b kg kh kj kk kz le la lf lb lg ky lh li lj lk dt translated"><strong class="kf hu">作用域</strong>允许你在体内定义变量。很多还允许你<code class="eh mx my mz mo b">break</code>或者<code class="eh mx my mz mo b">continue</code>。</li><li id="9fe0" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated"><strong class="kf hu">延续</strong>使用方案延续中止周围的作用域。</li><li id="95ab" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated"><strong class="kf hu">表达式</strong>可以作为语句使用。</li></ul><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="d9e5" class="ms lr ht mo b fv mt mu l mv mw"><em class="ke">; Statements</em><br/><em class="ke">;; Labels</em><br/>(<strong class="mo hu">struct</strong> c-labeled              ([ name        : Symbol             ]<br/>                                [ body        : c-statement      ]))<br/>(<strong class="mo hu">struct</strong> c-labeled-case         ([ expected    : c-expression       ]<br/>                                [ body        : c-statement      ]))<br/>(<strong class="mo hu">struct</strong> c-labeled-default      ([ body        : c-statement      ]))<br/>(<strong class="mo hu">struct</strong> c-goto                 ([ target      : Symbol           ]))<br/><br/><em class="ke">;; Scopes</em><br/>(<strong class="mo hu">struct</strong> c-if                   ([ pred        : c-expression      ]<br/>                                [ consequent  : c-statement       ]<br/>                                [ alternative : c-statement     ]))<br/>(<strong class="mo hu">struct</strong> c-block                ([ body        : c-statements    ]))<br/>(<strong class="mo hu">struct</strong> c-switch               ([ actual      : c-expression      ]<br/>                                [ body        : c-statement     ]))<br/>(<strong class="mo hu">struct</strong> c-for                  ([ init        : c-decl-vars       ]<br/>                                [ pred        : (<strong class="mo hu">Option</strong> c-expression) ]<br/>                                [ post        : (<strong class="mo hu">Option</strong> c-expression) ]<br/>                                [ body        : c-statement      ]))<br/>(<strong class="mo hu">struct</strong> c-while                ([ pred        : c-expression       ]<br/>                                [ body        : c-statement      ]))<br/>(<strong class="mo hu">struct</strong> c-do-while             ([ pred        : c-expression      ]<br/>                                [ body        : c-statement     ]))<br/><em class="ke">;; Continuations</em><br/>(<strong class="mo hu">struct</strong> c-return               ([ val         : (<strong class="mo hu">Option</strong> c-expression) ]))<br/>(<strong class="mo hu">struct</strong> c-break                (                                 ))<br/>(<strong class="mo hu">struct</strong> c-continue             (                                 ))<br/><br/><em class="ke">;; Expressions</em><br/>(<strong class="mo hu">struct</strong> c-expression-statement ([ exp         : c-expression    ]))<br/><br/>(<strong class="mo hu">define-type</strong> c-statement (<strong class="mo hu">U</strong> c-labeled <strong class="mo hu">...</strong> c-continue))</span></pre><p id="b0e3" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><strong class="kf hu">标签</strong>中的每个条目都被实现为内嵌汇编标签和<code class="eh mx my mz mo b">jump</code>指令。一个<code class="eh mx my mz mo b">switch</code>语句为它的<code class="eh mx my mz mo b">case</code>和<code class="eh mx my mz mo b">default</code>标签发出一个跳转表。</p><p id="c240" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">C <code class="eh mx my mz mo b">if</code>语句编译成Scheme <code class="eh mx my mz mo b">if</code>表达式:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="5aee" class="ms lr ht mo b fv mt mu l mv mw">(<strong class="mo hu">:</strong> compile-if (<strong class="mo hu">-&gt;</strong> c-if Pyramid))<br/>(<strong class="mo hu">define</strong> (<strong class="mo hu">compile-if</strong> x)<br/>  (<strong class="mo hu">destruct</strong> c-if x)<br/>  (<strong class="mo hu">pyr-if</strong> (<strong class="mo hu">compile-expression</strong> x-pred 'rvalue)<br/>          (<strong class="mo hu">compile-statement</strong>  x-consequent)<br/>          (<strong class="mo hu">compile-statement</strong>  x-alternative)<br/>          ))</span></pre><p id="2d50" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">使用<code class="eh mx my mz mo b">break</code>和<code class="eh mx my mz mo b">continue</code>的延续来执行<code class="eh mx my mz mo b">for</code>、<code class="eh mx my mz mo b">while</code>和<code class="eh mx my mz mo b">do while</code>循环，这些循环也用于检查循环条件:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="0931" class="ms lr ht mo b fv mt mu l mv mw">(<strong class="mo hu">:</strong> compile-for (<strong class="mo hu">-&gt;</strong> c-for Pyramid))<br/>(<strong class="mo hu">define</strong> (<strong class="mo hu">compile-for</strong> x)<br/>  (<strong class="mo hu">destruct</strong> c-for x)<br/>  (<strong class="mo hu">define</strong> init (map compile-declaration x-init))<br/>  (<strong class="mo hu">define</strong> post (<strong class="mo hu">if</strong> x-post<br/>                   (<strong class="mo hu">compile-expression</strong> x-post 'rvalue)<br/>                   (<strong class="mo hu">expand-pyramid</strong> <strong class="mo hu">#'</strong>(<strong class="mo hu">begin</strong>))))<br/>  (<strong class="mo hu">define</strong> pred (<strong class="mo hu">if</strong> x-pred<br/>                   (<strong class="mo hu">compile-expression</strong> x-pred 'rvalue)<br/>                   (<strong class="mo hu">expand-pyramid</strong> <strong class="mo hu">#'</strong>#t)))<br/><br/>  (<strong class="mo hu">with-breakpoint</strong><br/>    (<strong class="mo hu">quasiquote-pyramid</strong><br/>     <strong class="mo hu">`</strong>(<strong class="mo hu">begin</strong> <strong class="mo hu">,@</strong>init<br/>             (<strong class="mo hu">%c-loop-forever</strong><br/>              <strong class="mo hu">,</strong>(<strong class="mo hu">with-continuepoint</strong><br/>                 (<strong class="mo hu">quasiquote-pyramid</strong><br/>                  <strong class="mo hu">`</strong>(<strong class="mo hu">if</strong> <strong class="mo hu">,</strong>pred<br/>                       (<strong class="mo hu">begin</strong> <strong class="mo hu">,</strong>(<strong class="mo hu">compile-statement</strong> x-body)<br/>                              <strong class="mo hu">,</strong>post<br/>                              (<strong class="mo hu">continue</strong> 0))<br/>                       (<strong class="mo hu">break</strong> 0)))))))))</span></pre><p id="508d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">C块类似于Scheme <code class="eh mx my mz mo b">begin</code>，但是它需要隐藏任何局部声明的变量。所以我们把它包装在一个立即调用的lambda中:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="87eb" class="ms lr ht mo b fv mt mu l mv mw">(<strong class="mo hu">:</strong> compile-block (<strong class="mo hu">-&gt;</strong> c-block Pyramid))<br/>(<strong class="mo hu">define</strong> (<strong class="mo hu">compile-block</strong> x)<br/>  (<strong class="mo hu">quasiquote-pyramid</strong><br/>   <strong class="mo hu">`</strong>((λ ()<br/>       <strong class="mo hu">,</strong>(<strong class="mo hu">compile-c-sequence</strong> (<strong class="mo hu">c-block-body</strong> x))<br/>       ))))</span></pre><p id="1b43" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">这确实意味着块之间的<code class="eh mx my mz mo b">goto</code>可能错误编译，因为<code class="eh mx my mz mo b">λ</code>创建了需要释放的新的延续帧。解决方案是将所有变量定义提升到函数的开头，并使用<code class="eh mx my mz mo b">set!</code>来初始化它们，但是由于我在示例程序中没有使用跨块gotos，所以我选择保持简单。</p><p id="eb73" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">最后，表达式语句的编译就像它包装的表达式一样。</p><p id="48fe" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">语句非常清晰地映射到Scheme上。表达式需要考虑更多的细节。</p><h1 id="67d8" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">公式</h1><p id="86b5" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">每一个表达式都可以编译成两种模式:<code class="eh mx my mz mo b">rvalue</code>(“结果值”)或者<code class="eh mx my mz mo b">lvalue</code>(“位置值”)。</p><p id="92ce" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">变量由位置值和结果值组成。位置是变量在内存中的存储地址，而结果是地址的内容。</p><p id="4488" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">可编译为位置值的表达式允许像<code class="eh mx my mz mo b">+=</code>这样的赋值运算符修改该位置的值。可编译为结果值的表达式可以被读取，但不一定被写入。</p><p id="8dbc" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">对于可变地址和去引用，位置和结果值满足以下两个定律:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="9935" class="ms lr ht mo b fv mt mu l mv mw">compile "&amp;x" 'rvalue = compile "x" 'lvalue<br/>compile "*x" 'lvalue = compile "x" 'rvalue</span></pre><p id="8742" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">Ceagle试图将左值和右值放入一个32字节的单词中。<code class="eh mx my mz mo b">struct</code>值在内存中分配并表示为指针，即使在右值上下文中也是如此。但是,<code class="eh mx my mz mo b">struct</code>左值引用原始结构，而<code class="eh mx my mz mo b">struct</code>右值被复制，因此它们不可互换。</p><p id="6941" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">一个32字节的<code class="eh mx my mz mo b">c-type-fixed</code>会有一个32字节的结果值，但是为了高效，它的相关地址可能会被限制在3或4个字节。</p><p id="b656" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">因为<code class="eh mx my mz mo b">rvalue</code>没有身份，所以必须复制它们才能创建<code class="eh mx my mz mo b">lvalue</code>。</p><p id="c0ed" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">以下是所有的C表达式:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="2a40" class="ms lr ht mo b fv mt mu l mv mw"><em class="ke">; Expressions</em><br/>(<strong class="mo hu">struct</strong> c-const         ([ value       : CValue                 ]<br/>                         [ signed?     : Boolean                ]))<br/>(<strong class="mo hu">struct</strong> c-variable      ([ name        : Symbol                 ]))<br/>(<strong class="mo hu">struct</strong> c-ternary       ([ pred        : c-expression           ]<br/>                         [ consequent  : c-expression           ]<br/>                         [ alternative : c-expression           ]))<br/>(<strong class="mo hu">struct</strong> c-binop         ([ op          : Symbol                 ]<br/>                         [ left        : c-expression           ]<br/>                         [ right       : c-expression           ]))<br/>(<strong class="mo hu">struct</strong> c-unop          ([ op          : Symbol                 ]<br/>                         [ exp         : c-expression           ]))<br/>(<strong class="mo hu">struct</strong> c-function-call ([ func        : c-expression           ]<br/>                         [ args        : c-expressions          ]))<br/>(<strong class="mo hu">struct</strong> c-field-access  ([ source      : c-expression           ]<br/>                         [ name        : Symbol                 ]))<br/>(<strong class="mo hu">struct</strong> c-cast          ([ type        : c-type                 ]<br/>                         [ exp         : c-expression           ]))<br/>(<strong class="mo hu">struct</strong> c-sizeof        ([ value       : (<strong class="mo hu">U</strong> c-type c-expression)]))<br/>(<strong class="mo hu">struct</strong> c-array-access  ([ array       : c-expression           ]<br/>                         [ index       : c-expression           ]))<br/>(<strong class="mo hu">struct</strong> c-expression-sequence ([ exps  : c-expressions          ]))<br/>(<strong class="mo hu">struct</strong> c-expression-array    ([ exps  : c-expressions          ]))<br/><br/>(<strong class="mo hu">define-type</strong> c-expression (<strong class="mo hu">U</strong> c-const <strong class="mo hu">...</strong> c-expression-array))<br/>(<strong class="mo hu">define-type</strong> CValue       (<strong class="mo hu">U</strong> Integer String Char))</span></pre><p id="a02d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">我不同意字符串表示的C标准:字符串是<code class="eh mx my mz mo b">length :: data</code>，而不是<code class="eh mx my mz mo b">data :: 0</code>。</p><p id="5e01" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">左值上下文中的<code class="eh mx my mz mo b">c-variable</code>是变量的内存地址，右值上下文中的<code class="eh mx my mz mo b">c-variable</code>是变量值的副本。</p><p id="24f3" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">左值上下文中的<code class="eh mx my mz mo b">c-field-access</code>或<code class="eh mx my mz mo b">c-array-access</code>是从基的偏移内存地址，右值上下文中的是该内存地址的值。</p><p id="9c9b" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">其他表达式大部分都是从这些表达式递归而来的。</p><h1 id="a3ae" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">类型</h1><p id="501d" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">打字检查很简单。当遇到类型时，编译器会记住它们，并使用以前记住的类型信息对表达式进行类型检查。</p><p id="2baf" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">如果无法对表达式进行类型检查，则会引发错误。</p><p id="ec8b" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">以下是所有可能的类型:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="231a" class="ms lr ht mo b fv mt mu l mv mw">(<strong class="mo hu">struct</strong> c-type-fixed        ([ signed?   : Boolean              ]<br/>                             [ bytes     : Size                 ]))<br/>(<strong class="mo hu">struct</strong> c-type-struct-field ([ name      : (<strong class="mo hu">Option</strong> Symbol)      ]<br/>                             [ type      : c-type               ]))<br/>(<strong class="mo hu">struct</strong> c-type-struct       ([ name      : (<strong class="mo hu">Maybe</strong> Symbol)       ]<br/>                             [ fs        : c-type-struct-fields ]))<br/>(<strong class="mo hu">struct</strong> c-type-union        ([ name      : (<strong class="mo hu">Maybe</strong> Symbol)       ]<br/>                             [ fs        : c-type-struct-fields ]))<br/>(<strong class="mo hu">struct</strong> c-type-alias        ([ name      : Symbol               ]<br/>                             [ typespace : c-typespace          ]))<br/>(<strong class="mo hu">struct</strong> c-type-pointer      ([ type      : c-type               ]))<br/>(<strong class="mo hu">struct</strong> c-type-void         (                                    ))<br/>(<strong class="mo hu">struct</strong> c-signature         ([ ret  : c-type                    ]<br/>                             [ args : c-sigvars                 ]))</span></pre><p id="65ac" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><code class="eh mx my mz mo b">c-type-alias</code>的<code class="eh mx my mz mo b">typespace</code>成员用于消除<code class="eh mx my mz mo b">x</code>、<code class="eh mx my mz mo b">struct x</code>、<code class="eh mx my mz mo b">union x</code>的歧义。这些都可以指不同的类型，即使每个都有<code class="eh mx my mz mo b">x</code>代替<code class="eh mx my mz mo b">name</code>。</p><p id="c710" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">因为Ethereum有256位字，所以Ceagle有一个非标准的<code class="eh mx my mz mo b">__bits N</code>标记，较小的标准类型可以根据以下方面来定义:</p><p id="dfad" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><code class="eh mx my mz mo b"><strong class="kf hu">typedef</strong> <strong class="kf hu">signed</strong> __bits 128 <strong class="kf hu">short</strong>;</code></p><p id="701a" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">仅支持小于32字节的整数类型。较小的整数也存储为256位字，但编译器在每次算术运算后根据需要对其进行符号扩展:</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="2845" class="ms lr ht mo b fv mt mu l mv mw">(<strong class="mo hu">defmacro</strong> (<strong class="mo hu">%c-restrict-bytes</strong> x num-bytes signed?)<br/>  (<strong class="mo hu">if</strong> signed?<br/>      <strong class="mo hu">`</strong>(<strong class="mo hu">%#</strong>-sign-extend <strong class="mo hu">,</strong>x <strong class="mo hu">,</strong>num-bytes)<br/>      <strong class="mo hu">`</strong>(<strong class="mo hu">%#</strong>-zero-extend <strong class="mo hu">,</strong>x <strong class="mo hu">,</strong>num-bytes)))</span></pre><h1 id="40cf" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">未来的工作</h1><p id="6fed" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">本文使用金字塔在以太网上实现了C编程语言。</p><p id="1470" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">金字塔还需要最后一个主要技术组件，才能被一般开发者使用。期待本系列的下一篇文章:</p><p id="15c4" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><strong class="kf hu">“我如何让我的语言快了10，000倍…通过推迟所有优化直到这篇文章”</strong></p><p id="73b0" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">除此之外，下面的表格总结了我对未来工作的一些想法:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff np"><img src="../Images/17b4def9cbfd2b68559dbeb91f9d06d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*xK_FGCgplWVe1W8A9PCw7g.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae ji" href="https://www.michaelburge.us/2018/05/15/ethereum-chess-engine.html" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="5070" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated"><code class="eh mx my mz mo b">Required</code>表示“我是世界上唯一有能力做这件事的人，其他任何人都有必要开始使用金字塔”。</p><p id="c95d" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">优化器和文档是不言自明的，我将描述其他项目:</p><h1 id="f21a" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">坚固的ABI</h1><p id="38ec" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">以太坊工具通过对函数名和签名以及数据进行编码，对契约进行“方法调用”。如果Pyramid有一个实现这个的库，那么像Metamask这样的工具可以调用Pyramid契约。</p><p id="7770" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">ERC-20接口的直接翻译是</p><pre class="jk jl jm jn fq mn mo mp mq aw mr dt"><span id="a5d2" class="ms lr ht mo b fv mt mu l mv mw">(<strong class="mo hu">exports</strong><br/>  (<strong class="mo hu">totalSupply</strong>  (                        ) -&gt; uint)<br/>  (<strong class="mo hu">balanceOf</strong>    ([ tokenOwner : address ]) -&gt; uint)<br/>  (<strong class="mo hu">allowance</strong>    ([ tokenOwner : address ]<br/>                 [ spender    : address ]) -&gt; uint)<br/>  (<strong class="mo hu">transfer</strong>     ([ to         : address ]<br/>                 [ tokens     : uint    ]) -&gt; bool)<br/>  (<strong class="mo hu">approve</strong>      ([ spender    : address ]<br/>                 [ tokens     : uint    ]) -&gt; bool)<br/>  (<strong class="mo hu">transferFrom</strong> ([ from       : address ]<br/>                 [ to         : address ]<br/>                 [ tokens     : uint    ]) -&gt; bool))</span></pre><p id="1c2f" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">。这将:</p><ul class=""><li id="205a" class="lc ld ht kf b kg kh kj kk kz le la lf lb lg ky lh li lj lk dt translated">使用名称和签名为适当的金字塔函数生成调度表。</li><li id="d8e0" class="lc ld ht kf b kg ll kj lm kz ln la lo lb lp ky lh li lj lk dt translated">使用实性ABI和声明的签名转换函数的输入和输出。</li></ul><p id="f0f1" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">重要的是，<code class="eh mx my mz mo b">exports</code>将是一个宏，而不是一个内置的语言特性。因此，人们可以在不需要改变编译器的情况下试验替代ABI。</p><h1 id="e2d8" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">卡尔达诺后端</h1><p id="4e91" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">金字塔的代码生成器目前针对以太坊虚拟机。支持Cardano的LLVM衍生产品IELE应该不会太难。这将允许金字塔开发者编写适用于Cardano或以太坊的智能合同。</p><p id="5cab" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">这仅指部署到这些区块链。<strong class="kf hu">原子跨链交易</strong>是卡尔达诺和以太坊之间沟通所必需的不同特性。</p><h1 id="1d13" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">类型系统</h1><p id="4c84" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">Ceagle的一个问题是它的类型系统与其他类型系统不兼容。如果许多语言都有不兼容的类型系统，语言界限就会变得尴尬。</p><p id="7cad" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">最近的一篇论文介绍了一种将类型系统实现为宏的技术，这种宏将语法属性附加到它们转换的代码上。当实现更复杂的类型系统时，他们能够在更简单的类型系统上构建(一直到System F——类似于Haskell或ML)。</p><p id="e698" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">这种技术应该使得跨语言边界透明地调用不同类型系统的语言变得更加容易。</p><h1 id="0dde" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">多合同图书馆</h1><p id="bd94" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">许多以太坊应用都是契约网络。一个游戏可能有一个代币交易契约、一个高级接口、一个实现游戏规则的契约和一个存储玩家数据的契约。</p><p id="097a" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">Pyramid已经允许您手动编写这些代码，但是使用Racket的<a class="ae ji" href="https://docs.racket-lang.org/guide/units.html" rel="noopener ugc nofollow" target="_blank"> Units </a>这样的抽象将契约与声明的接口安全地链接在一起会更方便。</p><p id="0f55" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">在保留其安全属性的同时安全地升级契约是一个常见的问题。</p><h1 id="1405" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">合同测试</h1><p id="a734" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">测试库是用来检查合同是否没有错误的主要工具。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nq"><img src="../Images/a62ea944ed2fa9bbab666839d2bb5204.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*vzc0EllON9jK5j6jpueuFQ.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae ji" href="https://www.michaelburge.us/2018/05/15/ethereum-chess-engine.html" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="8fae" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">像PML这样的建模语言可以用来生成随机的测试用例，或者输入到Z3这样的模型检查器中。一些有限的检查也可以只用强类型契约接口来完成。</p><p id="61c7" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">与正式的IR语义一起，依赖类型语言可以发出端到端的验证代码。</p><h1 id="0fe3" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">图书馆管理</h1><p id="5ae6" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">金字塔要么用球拍的<code class="eh mx my mz mo b"><a class="ae ji" href="https://docs.racket-lang.org/raco/" rel="noopener ugc nofollow" target="_blank">raco</a></code>要么用<a class="ae ji" href="https://nixos.org/nix/" rel="noopener ugc nofollow" target="_blank"> Nix </a>包管理器来处理库。</p><p id="c05c" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">Nix承诺可复制的构建，因此任何人都可以验证契约是否被正确部署。在构建过程中重新测试合同可能是有意义的。</p><h1 id="055e" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">形式信息检索语义学</h1><p id="3e9e" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">程序的意义是什么？</p><p id="8d71" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">通常将较大的语言定义为简单语言的简化。这使得识别编译器错误更加容易。</p><p id="7ec8" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">像<a class="ae ji" href="https://redex.racket-lang.org/index.html" rel="noopener ugc nofollow" target="_blank"> PLT Redex </a>这样的工具可以用来指定这些语义，这也使得未来的正式验证工作更加容易。</p><h1 id="066f" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">LLL的坚固性</h1><p id="3321" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">目前大多数以太坊开发者使用Solidity。由于Pyramid允许人们开发库形式的语言，我可以为Pyramid编写一个Solidity库，允许现有的合同开发者使用它，而不需要改变他们现有的任何代码。</p><p id="10b5" class="pw-post-body-paragraph kc kd ht kf b kg kh iu ki kj kk ix kl kz kn ko kp la kr ks kt lb kv kw kx ky hm dt translated">还有一个由“低级Lisp”开发人员组成的小社区，他们已经表达了对Pyramid的兴趣。</p><h1 id="6a6f" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh dt translated">结论</h1><p id="f88a" class="pw-post-body-paragraph kc kd ht kf b kg mi iu ki kj mj ix kl kz mk ko kp la ml ks kt lb mm kw kx ky hm dt translated">在本文中，我介绍了面向语言编程作为智能契约编程的替代方法。如果你有兴趣，我推荐你在Twitter上关注我，订阅邮件列表，或者加入金字塔不和频道。网站的侧边栏上有链接。</p></div></div>    
</body>
</html>