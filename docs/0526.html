<html>
<head>
<title>An analysis of a couple Ethereum honeypot contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一对以太坊蜜罐契约的分析</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/an-analysis-of-a-couple-ethereum-honeypot-contracts-5c07c95b0a8d?source=collection_archive---------2-----------------------#2018-05-15">https://medium.com/coinmonks/an-analysis-of-a-couple-ethereum-honeypot-contracts-5c07c95b0a8d?source=collection_archive---------2-----------------------#2018-05-15</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="2b25" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://etherscan.io" rel="noopener ugc nofollow" target="_blank">以太扫描</a>是一个以太坊区块链浏览器，除了其他功能外，它允许开发者提交他们部署的智能合约的代码。这个特性的主要好处是它允许用户通过阅读它们的源代码来检查契约做了什么。以太网扫描确保代码与部署的智能合同相匹配。</p><p id="1b96" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">已核实的合同清单很长。在撰写本文时，Etherscan提供了26055份合同的源代码，可以在这里<a class="ae jo" href="https://etherscan.io/contractsVerified" rel="noopener ugc nofollow" target="_blank">浏览</a>。</p><p id="2d9a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在一个慵懒的周日下午，我决定随便浏览一下，看看人们在运行什么样的合同，了解一下人们使用区块链的目的，以及这些合同写得有多好，有多安全。我发现的大多数合同都实现了代币、众卖、多签名钱包、庞氏骗局和..蜜罐！</p><p id="b7a1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">蜜罐合同是我最感兴趣的发现。这种合同持有以太，而<em class="jp">假装</em>不安全地这样做。简而言之，它们是诈骗合同，试图欺骗你，让你认为你可以窃取他们持有的以太，而事实上你所能做的就是<em class="jp">失去</em>以太。</p><p id="9120" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">他们遵循的一个常见模式是，为了取回他们持有的以太，你必须先送他们一些你自己的以太。当然，如果你尝试这样做，你会大吃一惊:智能合约耗尽了你的精力，你会发现智能合约并不像你想象的那样。</p><p id="88d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这篇文章中，我将分析我遇到的几个蜜罐合同，并解释它们看起来是做什么的，但实际上是做什么的。</p><h2 id="9d02" class="jq jr ht bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk dt translated">不是真的不安全的非彩票</h2><p id="3032" class="pw-post-body-paragraph iq ir ht is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hm dt translated">我将经历的第一个合同实现了一种彩票，显然，这种彩票非常不安全，而且很容易在保证中奖的情况下被窃取。我遇到过几个这样的例子。我找到的最后一个实例部署在地址0x 8685631276 cfcf 17 a 973d 92 f 6 DC 11645 e 5158 c0c，其源代码可以在这里阅读<a class="ae jo" href="https://etherscan.io/address/0x8685631276cfcf17a973d92f6dc11645e5158c0c#code" rel="noopener ugc nofollow" target="_blank">。为了方便起见，我复制了下面的代码。你能找到诱饵吗？你能告诉为什么，如果你试图利用它，你实际上会失去以太吗？</a></p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="6117" class="jq jr ht kv b fv kz la l lb lc">pragma solidity ^0.4.23;</span><span id="e6a9" class="jq jr ht kv b fv ld la l lb lc">// CryptoRoulette<br/>//<br/>// Guess the number secretly stored in the blockchain and win the whole contract balance!<br/>// A new number is randomly chosen after each try.<br/>//<br/>// To play, call the play() method with the guessed number (1-16).  Bet price: 0.2 ether</span><span id="13c7" class="jq jr ht kv b fv ld la l lb lc">contract CryptoRoulette {<br/>    uint256 private secretNumber;<br/>    uint256 public lastPlayed;<br/>    uint256 public betPrice = 0.001 ether;<br/>    address public ownerAddr;</span><span id="c224" class="jq jr ht kv b fv ld la l lb lc">    struct Game {<br/>        address player;<br/>        uint256 number;<br/>    }<br/>    Game[] public gamesPlayed;</span><span id="9850" class="jq jr ht kv b fv ld la l lb lc">    constructor() public {<br/>        ownerAddr = msg.sender;<br/>        shuffle();<br/>    }</span><span id="09f9" class="jq jr ht kv b fv ld la l lb lc">    function shuffle() internal {<br/>        // randomly set secretNumber with a value between 1 and 10<br/>        secretNumber = 6;<br/>    }</span><span id="c067" class="jq jr ht kv b fv ld la l lb lc">    function play(uint256 number) payable public {<br/>        require(msg.value &gt;= betPrice &amp;&amp; number &lt;= 10);<br/>        Game game;<br/>        game.player = msg.sender;<br/>        game.number = number;<br/>        gamesPlayed.push(game);</span><span id="e829" class="jq jr ht kv b fv ld la l lb lc">        if (number == secretNumber) {<br/>            // win!<br/>            msg.sender.transfer(this.balance);<br/>        }</span><span id="bbd8" class="jq jr ht kv b fv ld la l lb lc">        //shuffle();<br/>        lastPlayed = now;<br/>    }</span><span id="c81d" class="jq jr ht kv b fv ld la l lb lc">    function kill() public {<br/>        if (msg.sender == ownerAddr &amp;&amp; now &gt; lastPlayed + 6 hours) {<br/>            suicide(msg.sender);<br/>        }<br/>    }</span><span id="388e" class="jq jr ht kv b fv ld la l lb lc">    function() public payable { }<br/>}</span></pre><p id="6bad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">很容易看出<code class="eh le lf lg kv b">shuffle()</code>方法将<code class="eh le lf lg kv b">secretNumber</code>设置为6。因此，如果你打电话给<code class="eh le lf lg kv b">play(6)</code>并发送0.001以太，你将总是赢得你的以太加上合同的余额，即0.015以太。轻松赚钱，对吧？不对。</p><p id="848e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有什么诀窍？仔细看看<code class="eh le lf lg kv b">play()</code>是如何实现的。它声明了一个变量<code class="eh le lf lg kv b">Game game</code>，但是没有初始化它。因此，它将默认为指向协定存储空间的槽0的指针。然后，它将您的地址存储在其第一个成员(存储槽0)中，并将提交的号码存储在第二个成员(映射到存储槽1)中。因此，在实践中，这将最终用攻击者账户的地址覆盖合同的<code class="eh le lf lg kv b">secretNumber</code>，用提交的号码覆盖<code class="eh le lf lg kv b">lastPlayed</code>。</p><p id="8ee2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，它会比较<code class="eh le lf lg kv b">secretNumber</code>，现在是你的帐户地址，与你提交的号码。由于您只能提交小于10的数字，因此只有您的帐户地址在0x0到0x0a的范围内，您才能获胜。(不要试图强行在这么小的范围内搜索一个帐户！根本不可行。)</p><p id="aa97" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以，比较会失败，契约会保留你的以太。当然，攻击者可以随时调用<code class="eh le lf lg kv b">kill()</code>来取回以太。</p><h2 id="3aeb" class="jq jr ht bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk dt translated">不是真的不安全的非谜语</h2><p id="6a13" class="pw-post-body-paragraph iq ir ht is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hm dt translated">这是<a class="ae jo" href="https://etherscan.io/address/0x3CAF97B4D97276d75185aaF1DCf3A2A8755AFe27#codepragma" rel="noopener ugc nofollow" target="_blank">另一个好玩的</a>。这让我挠头了一会儿。然而，有一个巨大的漏洞，那就是这份合同马上就要搞出一些肮脏的事情。但是我们不要想太多。</p><p id="897c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是它的代码。你能发现所谓的弱点吗？您能告诉我为什么漏洞利用不起作用吗？我刚才说的赠品是什么？</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="c046" class="jq jr ht kv b fv kz la l lb lc">contract G_GAME<br/>{<br/>    function Play(string _response)<br/>    external<br/>    payable<br/>    {<br/>        require(msg.sender == tx.origin);<br/>        if(responseHash == keccak256(_response) &amp;&amp; msg.value&gt;1 ether)<br/>        {<br/>            msg.sender.transfer(this.balance);<br/>        }<br/>    }<br/>    <br/>    string public question;<br/>    address questionSender;<br/>    bytes32 responseHash;<br/> <br/>    function StartGame(string _question,string _response)<br/>    public<br/>    payable<br/>    {<br/>        if(responseHash==0x0)<br/>        {<br/>            responseHash = keccak256(_response);<br/>            question = _question;<br/>            questionSender = msg.sender;<br/>        }<br/>    }<br/>    <br/>    function StopGame()<br/>    public<br/>    payable<br/>    {<br/>       require(msg.sender==questionSender);<br/>       msg.sender.transfer(this.balance);<br/>    }<br/>    <br/>    function NewQuestion(string _question, bytes32 _responseHash)<br/>    public<br/>    payable<br/>    {<br/>        require(msg.sender==questionSender);<br/>        question = _question;<br/>        responseHash = _responseHash;<br/>    }<br/>    <br/>    function() public payable{}<br/>}</span></pre><p id="69d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该代码据说实现了一个谜语。它提出了一个问题，如果你能说出答案是什么，它大概会把它的余额发给你，目前是1以太多一点。当然，要产生一个答案，你必须先发送一个以太，如果你是正确的，你会得到它。代码看起来不错，但是有一个卑鄙的伎俩:注意<code class="eh le lf lg kv b">NewQuestion</code>如何允许<code class="eh le lf lg kv b">questionSender</code>提交一个与<code class="eh le lf lg kv b">_question</code>不匹配的散列。所以，只要这个函数没有被使用，我们应该没问题。</p><p id="4024" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们能说出问题和答案是什么吗？如果您在etherscan 上阅读合同的<a class="ae jo" href="https://etherscan.io/address/0x3CAF97B4D97276d75185aaF1DCf3A2A8755AFe27" rel="noopener ugc nofollow" target="_blank">交易历史，似乎第</a><a class="ae jo" href="https://etherscan.io/tx/0xa31f023b306fd48facbf5ce54a9c5690edbf1ad90caa676785f431ae49a1ab69" rel="noopener ugc nofollow" target="_blank">次交易</a>提出了问题。如果你点击etherscan上的“转换成UT8”按钮就更明显了。这就揭示了问题"<em class="jp">我很容易进入，却很难走出我。我是什么？</em>”，以及答案<em class="jp">麻烦</em>。</p><p id="e1d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">根据etherscan，由于该事务被调用，因此在创建合同后，<code class="eh le lf lg kv b">responseHash</code>将为零，并将变为<code class="eh le lf lg kv b">keccak265("TroublE")</code>。然后，有第三个事务装载了契约中的一个以太。所以，很明显，我们可以打电话给<code class="eh le lf lg kv b">Play("TroublE")</code>，派一个以太去取回两个以太。好得难以置信？大概吧。让我们确认一下。</p><p id="de1f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们可以通过检查智能合约的状态来确保我们将合约的以太网。它的变量不是<code class="eh le lf lg kv b">public</code>，但是仍然只需要几个额外的笔划就可以通过查询区块链来检索它们的值。<code class="eh le lf lg kv b">questionSender</code>和<code class="eh le lf lg kv b">responseHash</code>是第二个和第三个变量，因此它们将占用智能合约存储空间上的槽1和槽2。让我们检索它们的值。</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="53b6" class="jq jr ht kv b fv kz la l lb lc">web3.eth.getStorageAt(‘0x3caf97b4d97276d75185aaf1dcf3a2a8755afe27’, 1, console.log);</span></pre><p id="fde3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">结果是` 0x0..0765951 ab 946 F3 a6f 0379680 a6b 05 FB 807d 52 ba 09 `。这对攻击者来说意味着麻烦(双关语),因为设置问题的交易来自一个以<code class="eh le lf lg kv b">0x21d2</code>开头的账户。出事了。</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="213a" class="jq jr ht kv b fv kz la l lb lc">web3.eth.getStorageAt(‘0x3caf97b4d97276d75185aaf1dcf3a2a8755afe27’, 2, console.log);</span></pre><p id="00d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">结果是` 0xc3fa7df9bf24…`。这是“麻烦”的散列吗？</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="79c7" class="jq jr ht kv b fv kz la l lb lc">web3.sha3('TroublE');</span></pre><p id="3044" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该调用返回<code class="eh le lf lg kv b">0x92a930d5...</code>，因此结果是，如果我们调用<code class="eh le lf lg kv b">Play("TroublE")</code>并发送1 ether，我们实际上会丢失它。但是哈希值怎么可能不匹配呢？</p><p id="9236" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意，如果<code class="eh le lf lg kv b">responseHash</code>已经设置，那么<code class="eh le lf lg kv b">StartGame</code>什么也不做。显然，第二个事务没有改变契约的状态，所以它一定是在这个事务之前就已经设置好了。但是如果这是合同创建后的第一个事务，那么<code class="eh le lf lg kv b">responseHash</code>怎么可能已经初始化了呢？</p><p id="3571" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在绞尽脑汁之后，我发现了最近一篇关于蜜罐合约的有趣帖子，解释了当T0为零时，Etherscan不会显示合约之间的交易。其他区块链探险者如以太链<em class="jp">做</em>展示他们。毫无疑问，etherchain揭示了合同历史中的<a class="ae jo" href="https://www.etherchain.org/account/3caf97b4d97276d75185aaf1dcf3a2a8755afe27" rel="noopener ugc nofollow" target="_blank">几个额外的交易</a>，其中在<code class="eh le lf lg kv b">0x765951..</code>的合同通过一个零值交易修改了<code class="eh le lf lg kv b">responseHash</code>。</p><p id="a22d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以让我们检查一下这些交易。也许以太还能被偷？为了追踪发生了什么，我们需要解码这些电话。我们可以从Etherscan 得到合约的ABI <a class="ae jo" href="https://etherscan.io/address/0x3CAF97B4D97276d75185aaF1DCf3A2A8755AFe27#code" rel="noopener ugc nofollow" target="_blank">，从Etherchain的“奇偶痕迹”得到内部交易数据(</a><a class="ae jo" href="https://www.etherchain.org/tx/4581ff1f1242b21c16f4f8bf0b0de19153c95d1461b9105543629d005e18c956/parityTrace" rel="noopener ugc nofollow" target="_blank">第一</a>、<a class="ae jo" href="http://a5b368a448ae104747db475797aa6157e5db0729e3d90f46c0250061596cccf7" rel="noopener ugc nofollow" target="_blank">第二</a>)。这就是我们将交易解码为人类可读格式所需的全部内容。</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="860b" class="jq jr ht kv b fv kz la l lb lc">const abiDecoder = require('abi-decoder');<br/>const Web3 = require('web3');<br/>const web3 = new Web3();</span><span id="2f52" class="jq jr ht kv b fv ld la l lb lc">const abi = [{“constant”:false,”inputs”:[{“name”:”_question”,”type”:”string”},{“name”:”_response”,”type”:”string”}],”name”:”StartGame”,”outputs”:[],”payable”:true,”stateMutability”:”payable”,”type”:”function”},{“constant”:false,”inputs”:[{“name”:”_question”,”type”:”string”},{“name”:”_responseHash”,”type”:”bytes32"}],”name”:”NewQuestion”,”outputs”:[],”payable”:true,”stateMutability”:”payable”,”type”:”function”},{“constant”:true,”inputs”:[],”name”:”question”,”outputs”:[{“name”:””,”type”:”string”}],”payable”:false,”stateMutability”:”view”,”type”:”function”},{“constant”:false,”inputs”:[{“name”:”_response”,”type”:”string”}],”name”:”Play”,”outputs”:[],”payable”:true,”stateMutability”:”payable”,”type”:”function”},{“constant”:false,”inputs”:[],”name”:”StopGame”,”outputs”:[],”payable”:true,”stateMutability”:”payable”,”type”:”function”},{“payable”:true,”stateMutability”:”payable”,”type”:”fallback”}];</span><span id="e984" class="jq jr ht kv b fv ld la l lb lc">const data1 = '0x1f1c827f000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000464920616d2076657279206561737920746f2067657420696e746f2c627574206974206973206861726420746f20676574206f7574206f66206d652e205768617420616d20493f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000754726f75626c4500000000000000000000000000000000000000000000000000';</span><span id="cc90" class="jq jr ht kv b fv ld la l lb lc">const data2 = '0x3e3ee8590000000000000000000000000000000000000000000000000000000000000040c3fa7df9bf247d144f6933776e672e599a5ed406cd0a15a9f2da09055b8f906700000000000000000000000000000000000000000000000000000000000000464920616d2076657279206561737920746f2067657420696e746f2c627574206974206973206861726420746f20676574206f7574206f66206d652e205768617420616d20493f0000000000000000000000000000000000000000000000000000';</span><span id="df0e" class="jq jr ht kv b fv ld la l lb lc">abiDecoder.addABI(abi);<br/>console.log(abiDecoder.decodeMethod(data1));<br/>console.log(abiDecoder.decodeMethod(data2));</span></pre><p id="202d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行这段代码，我们得到以下结果:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="cfcc" class="jq jr ht kv b fv kz la l lb lc">{ name: ‘StartGame’,<br/>  params: [ { name: ‘_question’,<br/>              value: ‘I am very easy to get into,but it is hard to get out of me. What am I?’,<br/>              type: ‘string’ },<br/>            { name: ‘_response’,<br/>              value: ‘TroublE’,<br/>              type: ‘string’ }<br/>  ]<br/>}<br/>{ name: ‘NewQuestion’,<br/>  params: [ { name: ‘_question’,<br/>              value: ‘I am very easy to get into,but it is hard to get out of me. What am I?’,<br/>              type: ‘string’ },<br/>            { name: ‘_responseHash’,<br/>              value: ‘0xc3fa7df9bf247d144f6933776e672e599a5ed406cd0a15a9f2da09055b8f9067’,<br/>              type: ‘bytes32’ }<br/>  ]<br/>}</span></pre><p id="ca72" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们了解到第一个事务将答案设置为<code class="eh le lf lg kv b">keccak256("TroublE")</code>，但是第二个事务将答案设置为一个哈希值，我们不知道这个哈希值的原始数据！同样，很容易忽略第二个调用没有使用<code class="eh le lf lg kv b">_question</code>来计算散列；相反，它被设置为一个任意值，该值与前面调用中提供的字符串不匹配，尽管问题匹配。</p><p id="6753" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以，除非我们能找到产生给定散列的值，可能通过字典攻击或暴力搜索，否则我们就没运气了。而且，考虑到这个蜜罐有多复杂，我认为尝试暴力破解对我们来说不会有太好的效果。</p><p id="5810" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">解开这个蜜罐需要相当大的努力。它的创建者最终指望攻击者信任以太扫描数据，这些数据并不包含全貌。</p><h2 id="7e22" class="jq jr ht bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk dt translated">赠品</h2><p id="7aa6" class="pw-post-body-paragraph iq ir ht is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hm dt translated">我说这份合同包含了一个它的创造者在耍花招的确凿证据。这是这条线:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="b6de" class="jq jr ht kv b fv kz la l lb lc">require(msg.sender == tx.origin);</span></pre><p id="0a8b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这一行实现的是，它防止契约调用<code class="eh le lf lg kv b">Play</code>。这是因为<code class="eh le lf lg kv b">tx.origin</code>始终是一个“外部账户”，而不是一个智能合约。为什么这对攻击者有用？一种安全攻击契约的方法是从“攻击契约”中调用它们，如果它没有从攻击中获得以太网，则恢复执行:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="4522" class="jq jr ht kv b fv kz la l lb lc">function attack() {<br/>    uint intialBalance = this.balance;<br/>    attack_contract();<br/>    require (this.balance &gt; initialBalance);<br/>}</span></pre><p id="f556" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这样，除非攻击者的合同余额增加，否则交易完全失败。蜜罐的创造者希望防止攻击者使用这种伎俩来保护自己。</p><h2 id="3a4f" class="jq jr ht bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk dt translated">结论</h2><p id="b5fa" class="pw-post-body-paragraph iq ir ht is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hm dt translated">蜜罐对我来说是一个道德灰色地带。欺骗那些想从合同中偷窃的人可以吗？我不这么认为。但是我对此没有强烈的感觉。最后，如果你被骗了，那是因为你一开始就在寻找可以窃取的智能合约。</p><p id="7e6e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这些骗局利用了一些人的贪婪，这些人足够聪明，能够发现合同中明显的漏洞，但却没有足够的知识来发现潜在的陷阱是什么。</p><p id="18d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你想更深入地了解智能合约安全，可以看看这个叫做<a class="ae jo" href="https://capturetheether.com/" rel="noopener ugc nofollow" target="_blank">占领以太</a>的神奇战争游戏。这是一种锻炼你的技能和训练你的眼睛发现可疑代码的有趣方式。</p></div></div>    
</body>
</html>