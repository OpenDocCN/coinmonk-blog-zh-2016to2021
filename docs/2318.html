<html>
<head>
<title>A Time Ordered Index of Time Ordered Immutable Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时序不可变数据的时序索引</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-time-ordered-index-of-time-ordered-immutable-data-e28ced3417cc?source=collection_archive---------0-----------------------#2019-07-17">https://medium.com/coinmonks/a-time-ordered-index-of-time-ordered-immutable-data-e28ced3417cc?source=collection_archive---------0-----------------------#2019-07-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="ae63" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">以太坊区块链索引历险记</h2></div><p id="a5e9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你有没有注意到，获得以太坊账户历史的唯一方法是访问一个完全集中的、数据库驱动的、<em class="ke">老式的</em> web-2.0网站？</p><p id="e09c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">每次我使用这些网站(我一直都在使用)，我都会对自己说:<em class="ke">他们在监视我。他们把我的IP地址附在我的地址上，将来，他们会疯狂地侵犯我的隐私…但是我需要他们… </em></p><p id="9755" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">最近，我们演示了一个基于TrueBlocks的完全去中心化的区块链探索者。点击这里查看。我们的浏览器(运行在商业级硬件上)的核心是Ethrerum地址索引。本文讨论了我们如何建立索引，我们遇到的困难，以及为什么共享它比你想象的要复杂得多——特别是如果你想避免成为一个过时的、过时的、注定要侵犯人们隐私的网站。</p><h2 id="727e" class="kg kh ht bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la dt translated">时间排序数据的问题是</h2><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff lb"><img src="../Images/2a58f1fead6640e7d47a6314ccf91f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nuHSybAfXsrGWnNR5Acr7g.png"/></div></div><figcaption class="ln lo fg fe ff lp lq bd b be z ek">A blockchain is a time-ordered, otherwise unsorted, list of transactions. Addresses appear throughout the data structure in an arbitrary, all-but-random order. Scanning this list for a particular address is slow, slow, slow, slow, slow!</figcaption></figure><p id="0c78" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">众所周知，区块链不是数据库。区块链是按时间顺序排列的事务日志。每个事务在发生时都被记录在链上，并且以相同的顺序存储在磁盘上(至少在概念上是这样)。数据的时间排序特性使得用一个简短的、不可变的散列来完全表示每个块(以及该块之前的所有块的历史)成为可能。按时间排序的日志和不可变的、以哈希命名的数据就像数学和诗歌一样结合在一起。</p><p id="a884" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">使用以太坊节点的RPC接口，TrueBlocks检索每个出现的块，请求该块中的每个事务，然后请求这些事务中的每个收据、每个日志和每个跟踪。我们解析所有这些数据，提取任何可能出现在<em class="ke">中的</em>地址——我们将在后面的帖子中介绍这个过程——并给出这个地址集合，在<code class="eh lr ls lt lu b">address</code>中的<code class="eh lr ls lt lu b">block_number</code>内按<code class="eh lr ls lt lu b">transaction_index</code>排序，然后将排序后的列表写入磁盘。</p><p id="14e9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我们不走得更远——简单地创建每个块的地址出现的排序列表——与单独扫描时间排序日志相比，这实际上会产生显著的加速。当然，我们希望做得比这更好。例如，我们可以生成更大的、合并的、排序的列表，这比单个块的搜索要快得多。</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff lv"><img src="../Images/c65b0e50ff395a830dde2847b011db91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aBem4Q-8ACbf3w1d8wUUsQ.png"/></div></div><figcaption class="ln lo fg fe ff lp lq bd b be z ek">A sorted list is way faster to search, but if one inserts data one changes its hash</figcaption></figure><p id="aff6" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们的铲运机正是这样做的。它跟踪它看到的外观总数，一旦有一定数量的记录(目前为500，000)，就将它们组合起来，按地址排序，并将排序后的索引存储在一个更大的文件中。</p><p id="1821" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这大大提高了后续地址搜索的速度——当然是这样——这是数据库索引的本质。</p><p id="691f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在前8，120，000个块中，我们的过程已经创建了大约3，000个这样的排序列表(我们称之为“块”)。每个块包含大约500，000条外观记录。一个出场记录是<code class="eh lr ls lt lu b">&lt;address,block_number,tx_id&gt;</code>。</p><p id="fbfb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">您可能会问，为什么我们不简单地将索引存储在老式的web 2.0数据库中，并使用老式的web 2.0 API分发查询该索引的结果呢？我会试着解释为什么这不是我们想要做的。抓紧你的帽子。</p><h2 id="5e9a" class="kg kh ht bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la dt translated">为什么不构建一个Web 2.0 API来分发索引呢？</h2><p id="4164" class="pw-post-body-paragraph ji jj ht jk b jl lw iu jn jo lx ix jq jr ly jt ju jv lz jx jy jz ma kb kc kd hm dt translated">权力下放。</p><h2 id="2e38" class="kg kh ht bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la dt translated">Web 2.0有什么问题？</h2><p id="5b26" class="pw-post-body-paragraph ji jj ht jk b jl lw iu jn jo lx ix jq jr ly jt ju jv lz jx jy jz ma kb kc kd hm dt translated">web 2.0为什么很烂？让我来列举一些方式:侵犯隐私、未经验证的数据、脆弱性、单点故障、数据/用户可捕获性、用户锁定、侵犯隐私、富人越来越富的问题。名单很长。但是，最糟糕的问题——也是一个很难解释的问题——是如果我们想要建立一个去中心化的世界，web 2.0并没有按照我们需要的方式扩展。</p><p id="9d8e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">事实上，当前老式的web 2.0区块链探索者将带领我们离真正去中心化的世界越来越远。</p><p id="1d85" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">web 2.0区块链探索者的架构是首先从链中提取所有数据，放入web规模的数据库，索引数据十种方式到周日，最后交付的不是数据的索引，而是底层数据本身。这与分散数据是直接对立的。</p><p id="4ee3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这种服务的提供商实际上是在对用户说:</p><p id="1bd2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt mb translated">不要担心你那可爱的小脑袋会自己得到数据，我们会帮你得到的。做我们的客人。专注于构建您的应用程序。我们保证天气会好的。你可以信任我们。</p><p id="e59f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">但这与我们想要的方向恰恰相反。</p><p id="e392" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">该模型产生的提取数据的大小持续增长(可能呈指数增长)，因此，交付该数据的成本也将增长。显然，这将迫使这些数据提供商从他们的用户身上赚钱。在我看来，这将导致我上面提到的一系列问题，特别是用户锁定和隐私侵犯。</p><p id="a3ba" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们可以做得更好。</p><h2 id="14f8" class="kg kh ht bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la dt translated">认识到不可变数据的重要性</h2><p id="26e9" class="pw-post-body-paragraph ji jj ht jk b jl lw iu jn jo lx ix jq jr ly jt ju jv lz jx jy jz ma kb kc kd hm dt translated">区块链的数据是不可变的。我们不仅需要接受这个事实，而且应该接受它。没有其他办法。不可变数据不喜欢被索引。每次向不可变列表中插入新记录时，都会改变存储数据时生成的散列(例如在IPFS)。因此，似乎不能同时拥有不可变数据和排序索引。</p><p id="ce00" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要解决这个问题，只需停止向列表中添加条目(TrueBlocks通过创建按时间排序的分类帐的按帐户排序的索引的按时间排序的块来完成)。通过这种方式，我们可以在不可变数据和易于搜索的索引数据库之间找到一个平衡点。事实证明，这足以构建一个足以支持一整套应用程序的API，包括完全分散的区块链探索者:</p><figure class="lc ld le lf fq lg fe ff paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="fe ff mk"><img src="../Images/dd204133bc60c548169ecbb350cd03bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJiiQS-TpfCRV5mWBUqOzQ.png"/></div></div><figcaption class="ln lo fg fe ff lp lq bd b be z ek">The TrueBlocks Decentralized Blockchain Explorer</figcaption></figure><h2 id="c2f9" class="kg kh ht bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la dt translated">那么TrueBlocks传递的是什么呢？</h2><p id="bd84" class="pw-post-body-paragraph ji jj ht jk b jl lw iu jn jo lx ix jq jr ly jt ju jv lz jx jy jz ma kb kc kd hm dt translated">我们已经在最近的两篇文章中讨论过这个问题(这里的<a class="ae kf" rel="noopener" href="/@tjayrush/mother-may-i-f0ab967814fc"/>和这里的<a class="ae kf" rel="noopener" href="/@tjayrush/indexing-addresses-on-the-ethereum-blockchain-5c0806161eb9"/>)，所以我不会深入讨论这个问题，但是基本上TrueBlocks正在构建一个系统，该系统创建整个区块链中地址出现的部分索引。这些部分索引(我们称之为块)存储在单独的文件中，每次记录数超过500，000时就进行分区。</p><p id="d3a7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们随意地选择了这个记录数，但选择它是因为我们希望平衡磁盘上块的大小(每个大约8MB)、生成新块所花费的时间以及生成的文件数(大约3000个块乘以8120000个块)。</p><p id="b0a1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">产生新的组块所需的时间需要一点解释。</p><p id="f08c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我们的索引远远落后于链的顶端，我们可以同时并行处理许多块。一旦我们赶上了小费，事情就变了。</p><p id="aeeb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当我们试图赶上时，我们尽可能快地行动，事实上，我们很容易地刮过整个链条，在大约一天半的时间内赶上。(过去这需要三个多星期，但最近我们在<code class="eh lr ls lt lu b">go</code>中重写了scraper，现在利用并行性大大加快了这个过程。谢谢，<a class="ml mm gr" href="https://medium.com/u/9accc392b07d?source=post_page-----e28ced3417cc--------------------------------" rel="noopener" target="_blank">内特拉什</a>！)当我们玩catch up时，生成每个新的索引块大约需要45秒。(3000块每块45秒→135000秒→2250分钟→ 37.5小时→ 1.56天。)</p><p id="2ecf" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一旦我们赶上了，故事就完全变了。现在，该进程几乎所有的时间都在等待新的块。按照目前的使用率，以太坊链每块产生大约450个不同的地址。(如果一个地址出现在不同的事务中，它可以在一个块中出现多次，但每个事务只能出现一次。)为了累积500，000条记录来构建新的块，我们需要大约1，111个块。大约每14秒出现一个块→每分钟4.285个块→ 259.30分钟产生1111个块→大约四个半小时产生一个新块。</p><p id="24ba" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">非常重要的是，组块是不可变的，永远不会改变，可以发布到IPFS，与整个社区共享，永远不变！</p><h2 id="dad6" class="kg kh ht bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la dt translated">那么，说真的，TrueBlocks传递的是什么？</h2><p id="7bee" class="pw-post-body-paragraph ji jj ht jk b jl lw iu jn jo lx ix jq jr ly jt ju jv lz jx jy jz ma kb kc kd hm dt translated">我们将提供一个API，它既可以在本地运行的节点上运行，也可以在docker下远程运行在dAppNode之类的节点上，甚至可以远程运行在一个老式的web 2.0数据库驱动的网站上。</p><p id="ba43" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在这三种情况下，当用户说，<em class="ke">我可以拥有账户0x1234上的所有交易吗… </em>时，API不会交付用户想要的JSON数据。相反，我们的API将把散列传递给用户需要直接搜索节点以获得他们想要的数据的索引块。</p><p id="119b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">用户对TrueBlocks API: </strong> <code class="eh lr ls lt lu b">curl <a class="ae kf" href="http://endpoint/list_transactions/address" rel="noopener ugc nofollow" target="_blank">http://endpoint/list_transactions/address</a></code></p><blockquote class="mn mo mp"><p id="6a37" class="ji jj ke jk b jl jm iu jn jo jp ix jq mq js jt ju mr jw jx jy ms ka kb kc kd hm dt translated">一个简单的API查询，返回一些意外的结果。</p></blockquote><p id="430d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu"> API给用户:</strong> <code class="eh lr ls lt lu b">[ { “hash”: “QmXREJnqJ…”, “range”: “6517955–6519510” }, { “hash”: “QmQMBTt…”, “range”: “8102894–8104450” } ]</code></p><blockquote class="mn mo mp"><p id="34f8" class="ji jj ke jk b jl jm iu jn jo jp ix jq mq js jt ju mr jw jx jy ms ka kb kc kd hm dt translated">API返回用户需要搜索的索引块的哈希值。在大多数情况下，这是一个非常短的列表，因为普通用户只是周期性地进行交互，然后是短时间的突发。一个普通用户，查询他自己的账户，可能会得到五六个散列。</p><p id="3963" class="ji jj ke jk b jl jm iu jn jo jp ix jq mq js jt ju mr jw jx jy ms ka kb kc kd hm dt translated">对于链的大量用户，如流行的dApps或exchanges，列表会大得多(但不会大于3000个条目)。这正是我们想要的，因为普通用户不应该为重度用户承担负担。</p></blockquote><p id="7a64" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">IPFS用户:</strong> <code class="eh lr ls lt lu b">for each hash { ipfs get ${hash} -o ${range}.bin ; pin ${hash} }</code></p><blockquote class="mn mo mp"><p id="37a6" class="ji jj ke jk b jl jm iu jn jo jp ix jq mq js jt ju mr jw jx jy ms ka kb kc kd hm dt translated">用户将块本地带到他们自己的机器上。从现在开始不可能抓住他们了。他们拥有查找该帐户历史记录所需的所有数据，而且这些数据永远不会改变。只要他们自己留着，就永远不会被俘虏。</p><p id="f05c" class="ji jj ke jk b jl jm iu jn jo jp ix jq mq js jt ju mr jw jx jy ms ka kb kc kd hm dt translated">上面这条线的<code class="eh lr ls lt lu b"><em class="ht">pin ${hash}</em></code>部分实现了这一点。默认情况下，我们希望用户在本地复制索引块(这也将提高搜索速度)，然后固定他们自己的块。</p><p id="fe5c" class="ji jj ke jk b jl jm iu jn jo jp ix jq mq js jt ju mr jw jx jy ms ka kb kc kd hm dt translated">这使得在整个系统范围内对IPFS的相同数据块的后续查询更快，因为更容易找到该文件的更多副本。这样，每个人都按其使用比例分担携带指数的负担，系统的有效性随着用户数量的增加而增加(即网络效应)。重度使用者应该承担更多的负担。较轻的用户自然承担较少的负担，这在我看来是公平的。</p></blockquote><p id="36da" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="jk hu">用户至chi fra:</strong>T4】</p><blockquote class="mn mo mp"><p id="b004" class="ji jj ke jk b jl jm iu jn jo jp ix jq mq js jt ju mr jw jx jy ms ka kb kc kd hm dt translated">Chifra读取本地缓存的索引块，并将记录导出到JSON、TXT或CSV。它通过读取索引块、提取该地址的外观、查询节点的事务细节、 <strong class="jk hu"> <em class="ht">缓存返回的数据</em> </strong> <em class="ht">然后将数据导出到屏幕或文件中来实现这一点。</em> <strong class="jk hu"> <em class="ht">缓存</em> </strong> <em class="ht">很重要，因为查询节点和解析JSON结果可能会非常慢，而从本地二进制缓存中读取却非常快。</em></p></blockquote><h2 id="edbc" class="kg kh ht bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la dt translated">结果</h2><p id="e915" class="pw-post-body-paragraph ji jj ht jk b jl lw iu jn jo lx ix jq jr ly jt ju jv lz jx jy jz ma kb kc kd hm dt translated">TrueBlock共享以太坊区块链上地址出现索引的散列。这些索引从节点“释放”数据，使得以完全分散的方式构建有用、快速、响应迅速的应用程序成为可能。</p><p id="cd31" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通过共享不可变IPFS文件的散列，我们有目的地放弃了收回它们的能力。我们永远不能说，<em class="ke">我们抓住了你。如果您希望继续使用我们的数据，您必须向我们付费(否则我们将通过侵犯您的隐私来收取费用)。</em></p><p id="cd02" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们故意放弃这种能力<strong class="jk hu">因为我们相信如果区块链上的数据不像开源软件代码那样完全自由和开放，这个系统最终会失败。</strong></p><p id="2bc3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在接下来的几个月里，我们将推出、记录和撰写大量关于我们工作的文章。我们将于八月份去柏林，所以如果你想讨论我们的工作，请联系我们。如果我们能买到票，我们也会在DevCon。</p><h2 id="b8e8" class="kg kh ht bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la dt translated">支持我们的工作</h2><p id="ce05" class="pw-post-body-paragraph ji jj ht jk b jl lw iu jn jo lx ix jq jr ly jt ju jv lz jx jy jz ma kb kc kd hm dt translated">我们对你的想法很感兴趣。请为我们鼓掌，发关于我们的微博，并在下面发表你的评论。考虑支持我们的工作。给我们发个小(或大)投稿到0xb 97073 b 754660 bb 356 dfe 12 f 78 AE 366d 77 DBC 80 f。</p><p id="937d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Thomas Rush拥有软件公司TrueBlocks，LLC，其主要项目也称为TrueBlocks，这是一个软件库和应用程序的集合，支持对以太坊区块链进行实时、逐块智能合约监控和分析。通过网站联系他。</p><blockquote class="mt"><p id="126a" class="mu mv ht bd mw mx my mz na nb nc kd ek translated"><a class="ae kf" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ne nf ng nh ni lg fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nd"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>