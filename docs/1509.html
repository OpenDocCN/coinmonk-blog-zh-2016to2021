<html>
<head>
<title>Ethernaut Lvl 17 Locked Walkthrough: How to properly use (and abuse) structs in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ethernaut Lvl 17锁定演练:如何正确使用(和滥用)Solidity中的结构</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethernaut-lvl-17-locked-walkthrough-how-to-properly-use-structs-in-solidity-f9900c8843e2?source=collection_archive---------3-----------------------#2018-09-17">https://medium.com/coinmonks/ethernaut-lvl-17-locked-walkthrough-how-to-properly-use-structs-in-solidity-f9900c8843e2?source=collection_archive---------3-----------------------#2018-09-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="e203" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">这是一部<a class="ae ji" rel="noopener" href="/@nicolezhu">深度系列</a>围绕<a class="ae ji" href="https://openzeppelin.org/" rel="noopener ugc nofollow" target="_blank">齐柏林</a>团队的<a class="ae ji" href="https://ethernaut.zeppelin.solutions/" rel="noopener ugc nofollow" target="_blank">智能合约安全拼图</a>。我会给你直接的资源和你需要的关键概念来100%自己解决这些难题。</h2></div><p id="47d0" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">这个级别要求您通过滥用一个启动不良的结构来解锁注册器。</p></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="1878" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">使用结构时的最佳实践</h1><p id="35ef" class="pw-post-body-paragraph jj jk ht jl b jm le iu jo jp lf ix jr js lg ju jv jw lh jy jz ka li kc kd ke hm dt translated">像在面向对象编程中一样，您可以通过<code class="eh lj lk ll lm b">structs</code>创建复合数据类型。</p><p id="1b26" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">结构可以包含函数和其他复杂的数据类型，如映射和数组。这些数组和映射甚至可以包含更多的结构。但是，结构不能直接包含其他结构(除非它们是映射或数组中的值)。</p><p id="bed3" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">让我们逐步了解在使用结构时应该做什么和不应该做什么:</p><h2 id="669f" class="ln kn ht bd ko lo lp lq ks lr ls lt kw js lu lv ky jw lw lx la ka ly lz lc ma dt translated">如何初始化结构</h2><p id="b1c2" class="pw-post-body-paragraph jj jk ht jl b jm le iu jo jp lf ix jr js lg ju jv jw lh jy jz ka li kc kd ke hm dt translated">下面是<em class="mb"> </em> <a class="ae ji" href="https://solidity.readthedocs.io/en/v0.4.24/types.html" rel="noopener ugc nofollow" target="_blank"> <em class="mb">实体文档</em> </a> <em class="mb"> </em>中关于如何声明结构的一个例子:</p><pre class="mc md me mf fq mg lm mh mi aw mj dt"><span id="c446" class="ln kn ht lm b fv mk ml l mm mn"><strong class="lm hu">struct</strong> Funder {<br/>    address addr;<br/>    uint amount;<br/>}<br/><br/><strong class="lm hu">struct</strong> StructOfStructs {<br/>    ...<br/>    mapping (uint =&gt; Funder) funders;<br/>}</span></pre><p id="41b5" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">初始化结构有多种语法。</p><ol class=""><li id="5fbc" class="mo mp ht jl b jm jn jp jq js mq jw mr ka ms ke mt mu mv mw dt translated">您可以直接将值传递给struct对象:</li></ol><pre class="mc md me mf fq mg lm mh mi aw mj dt"><span id="f1ee" class="ln kn ht lm b fv mk ml l mm mn">... = Funder(msg.sender, msg.value);</span></pre><p id="7109" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">2.或者，您可以使用对象表示法将值传递到struct对象中，以获得更好的可读性:</p><pre class="mc md me mf fq mg lm mh mi aw mj dt"><span id="face" class="ln kn ht lm b fv mk ml l mm mn">... = <!-- -->Funder({addr: msg.sender, amount: msg.value})</span></pre><h2 id="0390" class="ln kn ht bd ko lo lp lq ks lr ls lt kw js lu lv ky jw lw lx la ka ly lz lc ma dt translated">常见使用模式(内存与存储)</h2><p id="31a1" class="pw-post-body-paragraph jj jk ht jl b jm le iu jo jp lf ix jr js lg ju jv jw lh jy jz ka li kc kd ke hm dt translated">在契约中可以有单个全局声明的struct对象，但这违背了创建新数据类型的目的。</p><p id="450e" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">更常见的是，你将使用一个数组或一个映射来保存一个结构集合。例如，让我们创建一个<code class="eh lj lk ll lm b">array of Funders</code>和一个<code class="eh lj lk ll lm b">mapping of Funders</code>。</p><h2 id="d986" class="ln kn ht bd ko lo lp lq ks lr ls lt kw js lu lv ky jw lw lx la ka ly lz lc ma dt translated"><strong class="ak">一系列资助者:</strong></h2><pre class="mc md me mf fq mg lm mh mi aw mj dt"><span id="97fa" class="ln kn ht lm b fv mk ml l mm mn">Funders[] public funders;</span><span id="dd0d" class="ln kn ht lm b fv mx ml l mm mn">function ... {<br/>    Funder <strong class="lm hu">memory</strong> f;<br/>    f.address = ...;<br/>    f.amount = ...;<br/>    funders.push(f);<br/>}</span></pre><p id="7f04" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">重要的是要知道:结构声明默认为存储。在创建或复制结构时，你应该总是使用一个<code class="eh lj lk ll lm b">memory</code>修饰符。不建议在函数内部使用结构进行任何临时计算。</p><h2 id="4713" class="ln kn ht bd ko lo lp lq ks lr ls lt kw js lu lv ky jw lw lx la ka ly lz lc ma dt translated"><strong class="ak">出资人映射:</strong></h2><pre class="mc md me mf fq mg lm mh mi aw mj dt"><span id="fac8" class="ln kn ht lm b fv mk ml l mm mn">mapping (uint =&gt; Funder) funders;<!-- --> </span><span id="1e06" class="ln kn ht lm b fv mx ml l mm mn">function ... {<br/>    funders[index] = Funder(...);<br/>}</span></pre><blockquote class="my"><p id="c911" class="mz na ht bd nb nc nd ne nf ng nh ke ek translated">重要的是要知道:当你直接将一个内存结构保存到一个状态变量中时，这个内存结构会被自动强制存储。</p></blockquote></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><p id="d7c9" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">下面是创建新结构时不要做的事情的示例。</p><h2 id="d4ff" class="ln kn ht bd ko lo lp lq ks lr ls lt kw js lu lv ky jw lw lx la ka ly lz lc ma dt translated">坏例子1</h2><p id="dead" class="pw-post-body-paragraph jj jk ht jl b jm le iu jo jp lf ix jr js lg ju jv jw lh jy jz ka li kc kd ke hm dt translated">您不应该在函数中声明新的存储结构，因为它会覆盖其他全局存储的变量。要通过这个以太等级，记住这一点很重要。</p><pre class="mc md me mf fq mg lm mh mi aw mj dt"><span id="6635" class="ln kn ht lm b fv mk ml l mm mn">// Do NOT do this<br/>function badFunction{<br/>    Funder f;         //this defaults to storage<br/>    f.address = ...;<br/>    f.amount = ...;<br/>    funders.push(f);  //this will fail<br/>}</span></pre><h2 id="8a8c" class="ln kn ht bd ko lo lp lq ks lr ls lt kw js lu lv ky jw lw lx la ka ly lz lc ma dt translated"><strong class="ak">坏例子2 </strong></h2><p id="3cf2" class="pw-post-body-paragraph jj jk ht jl b jm le iu jo jp lf ix jr js lg ju jv jw lh jy jz ka li kc kd ke hm dt translated">您不能隐式地将内存转换为存储。下面将引发一个编译错误:</p><pre class="mc md me mf fq mg lm mh mi aw mj dt"><span id="c357" class="ln kn ht lm b fv mk ml l mm mn">// Do NOT do this<br/>function badFunction{<br/>    Funder storage f = Funder(...);<br/>}</span><span id="afae" class="ln kn ht lm b fv mx ml l mm mn">// Do NOT do this<br/>function badFunction(Funder _funder){<br/>    Funder storage f = _funder;<br/>}</span></pre><p id="5cf2" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">请注意，函数输入参数也是内存，而不是存储引用指针。</p></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><figure class="mc md me mf fq nj fe ff paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="fe ff ni"><img src="../Images/9647abcd1a2059a2922b6838dad1046d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XG22wD7qLDCoISfVIxvGKQ.png"/></div></div></figure><h1 id="2426" class="km kn ht bd ko kp nq kr ks kt nr kv kw iz ns ja ky jc nt jd la jf nu jg lc ld dt translated">详细演练</h1><p id="ae2f" class="pw-post-body-paragraph jj jk ht jl b jm le iu jo jp lf ix jr js lg ju jv jw lh jy jz ka li kc kd ke hm dt translated">这个级别要求你将Locked.sol中的<code class="eh lj lk ll lm b">unlocked</code>全局变量从<code class="eh lj lk ll lm b">false</code>改为<code class="eh lj lk ll lm b">true</code>。</p><p id="247c" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">请注意，契约将<code class="eh lj lk ll lm b">unlocked</code>存储在其<em class="mb">的第一个</em>存储槽中。下一个项目是一个<code class="eh lj lk ll lm b">bytes32 name</code>，所以你知道<code class="eh lj lk ll lm b">unlocked</code>占据了整个第一个槽。false的字节码是<code class="eh lj lk ll lm b">0x00</code>，所以<code class="eh lj lk ll lm b">unlocked</code>在契约的存储槽中看起来像这样:</p><pre class="mc md me mf fq mg lm mh mi aw mj dt"><span id="4b59" class="ln kn ht lm b fv mk ml l mm mn">0x0000000000000000000000000000000000000000000000000000000000000000</span></pre><p id="ebe2" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">注意，当在公共<code class="eh lj lk ll lm b">register()</code>函数中实现一个结构时，这个级别犯了一个大忌:</p><pre class="mc md me mf fq mg lm mh mi aw mj dt"><span id="a33a" class="ln kn ht lm b fv mk ml l mm mn">function register(_name...){<br/>    NameRecord newRecord;     //storage declaration<br/>    newRecord.name = _name;<br/>    newRecord.mappedAddress = _mappedAddress;<br/>...</span></pre><p id="d5cd" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated"><code class="eh lj lk ll lm b">newRecord</code>默认存储！并且保存在newRecord中的任何数据都将覆盖存储器中现有的槽1和2。</p><p id="2d5b" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">方便起见，<code class="eh lj lk ll lm b">unlocked</code>当前存储在槽1中。让我们通过公共<code class="eh lj lk ll lm b">register</code>函数传递一个伪装成<code class="eh lj lk ll lm b">_name</code>变量的<code class="eh lj lk ll lm b">true</code> bool来覆盖<code class="eh lj lk ll lm b">unlocked</code>。</p><ol class=""><li id="a642" class="mo mp ht jl b jm jn jp jq js mq jw mr ka ms ke mt mu mv mw dt translated">将<code class="eh lj lk ll lm b">true</code>转换为<code class="eh lj lk ll lm b">bytes32</code>变量:</li></ol><pre class="mc md me mf fq mg lm mh mi aw mj dt"><span id="2a33" class="ln kn ht lm b fv mk ml l mm mn">0x0000000000000000000000000000000000000000000000000000000000000001</span></pre><p id="31a7" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">2.在Remix中，用你的<code class="eh lj lk ll lm b">bytes32 true</code>和一个任意的契约地址调用register。记得根据混音要求在你的值周围加上引号。</p><p id="606b" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">3.忽略Metamask警告信息，分配额外的气体。</p><p id="b2d7" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hm dt translated">4.再次检查您的<code class="eh lj lk ll lm b">0x01</code>值是否已覆盖<code class="eh lj lk ll lm b">unlocked</code>为真。在控制台中，检查以下情况是否属实:</p><pre class="mc md me mf fq mg lm mh mi aw mj dt"><span id="95ff" class="ln kn ht lm b fv mk ml l mm mn">await contract.unlocked();</span></pre></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="c35c" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">关键安全要点</h1><ul class=""><li id="ce87" class="mo mp ht jl b jm le jp lf js nv jw nw ka nx ke ny mu mv mw dt translated"><strong class="jl hu">结构声明默认为存储。在函数内部创建或复制结构时，你应该总是使用一个修饰符。不要在函数内计算中使用结构。</strong></li><li id="3de2" class="mo mp ht jl b jm nz jp oa js ob jw oc ka od ke ny mu mv mw dt translated">您不应该在函数中声明新的存储结构，因为它会覆盖其他全局存储的变量。</li></ul><h2 id="8905" class="ln kn ht bd ko lo lp lq ks lr ls lt kw js lu lv ky jw lw lx la ka ly lz lc ma dt translated">了解有关结构的更多信息</h2><p id="5199" class="pw-post-body-paragraph jj jk ht jl b jm le iu jo jp lf ix jr js lg ju jv jw lh jy jz ka li kc kd ke hm dt translated">查看<a class="ae ji" href="https://github.com/nczhu/soliditykoans" rel="noopener ugc nofollow" target="_blank"> Solidity Koans </a>(受Ruby Koans启发)并通过测试来练习使用Solidity中的结构！</p></div><div class="ab cl kf kg hb kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hm hn ho hp hq"><h1 id="fd2d" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld dt translated">更多级别</h1><div class="oe of fm fo og oh"><a rel="noopener follow" target="_blank" href="/coinmonks/ethernaut-lvl-16-preservation-walkthrough-how-to-inject-malicious-contracts-with-delegatecall-81e071f98a12"><div class="oi ab ej"><div class="oj ab ok cl cj ol"><h2 class="bd hu fv z el om eo ep on er et hs dt translated">Ethernaut Lvl 16保留演练:如何用delegatecall注入恶意契约</h2><div class="oo l"><h3 class="bd b fv z el om eo ep on er et ek translated">这是一个围绕齐柏林团队的智能合同安全难题的深入系列。我会给你直接的资源…</h3></div><div class="op l"><p class="bd b gc z el om eo ep on er et ek translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov no oh"/></div></div></a></div><div class="oe of fm fo og oh"><a rel="noopener follow" target="_blank" href="/coinmonks/ethernaut-lvl-18-recovery-walkthrough-how-to-retrieve-lost-contract-addresses-in-2-ways-aba54ab167d3"><div class="oi ab ej"><div class="oj ab ok cl cj ol"><h2 class="bd hu fv z el om eo ep on er et hs dt translated">Ethernaut Lvl 18恢复演练:如何检索丢失的合同地址(两种方式)</h2><div class="oo l"><h3 class="bd b fv z el om eo ep on er et ek translated">Solidity开发人员丢失新创建的合同地址是一个常见的错误。这变得令人沮丧…</h3></div><div class="op l"><p class="bd b gc z el om eo ep on er et ek translated">medium.com</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov no oh"/></div></div></a></div><blockquote class="my"><p id="e6de" class="mz na ht bd nb nc nd ne nf ng nh ke ek translated"><a class="ae ji" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="oy oz pa pb pc nj fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ox"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>