<html>
<head>
<title>My first ERC20 token</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的第一个20元代币</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/my-first-erc20-token-7d5d16632818?source=collection_archive---------2-----------------------#2021-11-28">https://medium.com/coinmonks/my-first-erc20-token-7d5d16632818?source=collection_archive---------2-----------------------#2021-11-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><h1 id="6731" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">介绍</h1><p id="79b2" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我开发的令牌是一个名为$MTK的ERC20令牌，实现了EIP-20令牌标准:<a class="ae km" href="https://eips.ethereum.org/EIPS/eip-20." rel="noopener ugc nofollow" target="_blank">https://eips.ethereum.org/EIPS/eip-20.</a></p><p id="6d40" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">我们可以说ERC20是以太坊改进提案EIP-20的标准实现，但是这个定义在形式上可能不正确。</p><p id="ea2d" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">无论如何，重要的是，ERC20标准可能是以太坊上最常用的可替换令牌标准，以太坊区块链上开发的大多数令牌都是ERC20令牌(例如$LINK、$USDT、$SHIB、$BAT等等)。</p><p id="a1b0" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">世界“可替换”意味着任何$MTK代币与任何其他$MTK代币具有相同的价值。这与标准法定货币的情况相同，例如1欧元硬币与流通中的所有1欧元硬币具有相同的价值。</p><p id="ca6a" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在接下来的部分中，我将分析智能合约的源代码，这些智能合约实现了ERC20令牌$MTK的所有功能。智能合同是用Solidity编程语言编写的，几乎所有的功能都继承自OpenZeppelin库，因此将对该库的源代码进行分析。</p><p id="b850" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">OpenZeppelin网站:【https://openzeppelin.com/ T2】</p><p id="ff11" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">最后，我们将在本地区块链上部署智能合约进行测试，并从一个钱包到另一个钱包进行$MTK的交易。</p><p id="fa2d" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">令牌源代码可以在Github Repo上找到:【https://github.com/lucadidomenico/myERC20Token T4】</p><h1 id="d7e3" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">ERC20.sol和IERC20.sol</h1><p id="5895" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">ERC20令牌标准的实现包含在OpenZeppelin的ERC20.sol和IERC20.sol源文件中。</p><p id="9771" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">具体来说，IERC20.sol接口定义了ERC20函数，而ERC20.sol实现了这些函数。</p><p id="7bd0" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">IERC20.sol:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="7c4b" class="lb ir ht kx b fv lc ld l le lf">pragma solidity ^0.8.0;</span><span id="f715" class="lb ir ht kx b fv lg ld l le lf">interface IERC20 {<br/>    // returns the amount of token in circulation.<br/>    function totalSupply() external view returns (uint256);</span><span id="ef48" class="lb ir ht kx b fv lg ld l le lf">    //returns the balance of an account, i.e. the amount of token the account owns.<br/>    function balanceOf(address account) external view returns (uint256);</span><span id="96e8" class="lb ir ht kx b fv lg ld l le lf">    //send amount of token to the recipient address<br/>    function transfer(address recipient, uint256 amount) external returns (bool);</span><span id="a15b" class="lb ir ht kx b fv lg ld l le lf">    //returns how much the owner of the token has allowed another account to transfer the token he owns. (ignore for now)<br/>    function allowance(address owner, address spender) external view returns (uint256);</span><span id="4af4" class="lb ir ht kx b fv lg ld l le lf">    //the owner of tokens allows another account to transfer the token he owns by amount (ignore for now)<br/>    function approve(address spender, uint256 amount) external returns (bool);</span><span id="0c44" class="lb ir ht kx b fv lg ld l le lf">    //transfer token from one account to another. The owner of the token is not the calling address (ignore for now)<br/>    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span><span id="d155" class="lb ir ht kx b fv lg ld l le lf">    // event emitted during a transfer (ignore for now)<br/>    event Transfer(address indexed from, address indexed to, uint256 value);<br/>    <br/>    // event emitted during an approval (ignore for now)<br/>    event Approval(address indexed owner, address indexed spender, uint256 value);</span><span id="f286" class="lb ir ht kx b fv lg ld l le lf">}</span></pre><p id="6839" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">ERC20.sol:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="7bd9" class="lb ir ht kx b fv lc ld l le lf">// SPDX-License-Identifier: MIT<br/>pragma solidity ^0.8.0;<br/>import "./IERC20.sol";<br/>import "./extensions/IERC20Metadata.sol";<br/>import "../../utils/Context.sol";</span><span id="ff2d" class="lb ir ht kx b fv lg ld l le lf">contract ERC20 is Context, IERC20, IERC20Metadata {</span><span id="c9f5" class="lb ir ht kx b fv lg ld l le lf">[ . . . ]</span></pre><p id="5e19" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">以下三个函数也是ERC20的一部分，但没有在IERC20.sol中声明:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="1da0" class="lb ir ht kx b fv lc ld l le lf">// returns the name of the token i.e. MyToken<br/>function name() public view virtual override returns (string memory);</span><span id="f9bb" class="lb ir ht kx b fv lg ld l le lf">// return the symbol of the token i.e. MTK<br/>function symbol() public view virtual override returns (string memory);</span><span id="bbbf" class="lb ir ht kx b fv lg ld l le lf">// Returns the number of decimals used to get its user representation (see below).<br/>function decimals() public view virtual override returns (uint8);</span></pre><p id="6621" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">我不知道为什么OpenZeppelin决定不在IERC20.sol中声明这3个函数，而是直接在ERC20.sol智能契约中定义它们的具体原因。</p><p id="64ea" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">您可以在这里找到源代码:</p><ul class=""><li id="d240" class="lh li ht jq b jr kn jv ko jz lj kd lk kh ll kl lm ln lo lp dt translated">ierc 20 . sol:<a class="ae km" href="https://github.com/lucadidomenico/myERC20Token/blob/master/node_modules/%40openzeppelin/contracts/token/ERC20/IERC20.sol#L1" rel="noopener ugc nofollow" target="_blank">https://github . com/lucadidomenico/myer C20 token/blob/master/node _ modules/% 40 open zeppelin/contracts/token/ERC 20/ierc 20 . sol # L1</a></li><li id="6887" class="lh li ht jq b jr lq jv lr jz ls kd lt kh lu kl lm ln lo lp dt translated">ERC 20 . sol:<a class="ae km" href="https://github.com/lucadidomenico/myERC20Token/blob/master/node_modules/%40openzeppelin/contracts/token/ERC20/ERC20.sol#L1" rel="noopener ugc nofollow" target="_blank">https://github . com/lucadidomenico/myer C20 token/blob/master/node _ modules/% 40 open zeppelin/contracts/token/ERC 20/ERC 20 . sol # L1</a></li></ul><h2 id="2b6a" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">铸造。</h2><p id="0695" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">_mint()函数是在ERC20.sol的第251行定义的。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="0774" class="lb ir ht kx b fv lc ld l le lf">function _mint(address account, uint256 amount) internal virtual {<br/>[ . . . ]<br/>    _totalSupply += amount;<br/>    _balances[account] += amount;<br/>[ . . . ]<br/>}</span></pre><p id="0d2e" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">_mint函数创建新的代币“数量”,并增加总供应量。它将新令牌分配给调用该函数的“帐户”。此功能有助于保持总供应量与铸币账户余额(按金额增加)之间的同步，并且在增加ERC20代币的总金额时应始终使用。</p><h2 id="099e" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">燃烧。</h2><p id="6c17" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在ERC20.sol的第274行定义了_burn()函数。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="51a2" class="lb ir ht kx b fv lc ld l le lf">function _burn(address account, uint256 amount) internal virtual {<br/>[ . . . ]<br/>    uint256 accountBalance = _balances[account];<br/>    unchecked {<br/>        _balances[account] = accountBalance - amount;<br/>    }<br/>    _totalSupply -= amount;<br/>[ . . . ]<br/>}</span></pre><p id="c956" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">_burn()函数与_mint()函数正好相反。事实上，这是为了减少代币的总供应量。代币金额将从帐户余额中扣除。当开发人员执行此操作时，通常会导致剩余令牌的价格上涨。铸币则相反，通常会降低代币的价格。</p><h2 id="3ec9" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">在账户之间转移代币。</h2><p id="1ffd" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">值得注意的是，当在账户之间转移代币时，在区块链上发生的唯一交易是合约调用。事实上，当将令牌从一个帐户转移到另一个帐户时(通过使用transfer()或transferFrom())，令牌合约所做的只是更新其自己的内部变量“_balances”，该变量包含每个帐户拥有的令牌数量。这显示在下面的代码片段中。</p><p id="c7e8" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">ERC20.sol:35</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="257a" class="lb ir ht kx b fv lc ld l le lf">mapping(address =&gt; uint256) private _balances;</span></pre><p id="d63e" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">“_balances”变量包含每个地址拥有的令牌数量，以无符号整数表示。</p><p id="9c46" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">ERC20 smartcontract的transfer()函数更新了这种映射，如以下代码所示。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="db67" class="lb ir ht kx b fv lc ld l le lf">function _transfer(address sender, address recipient, uint256 amount    ) internal virtual {<br/>[ . . . ]<br/>    uint256 senderBalance = _balances[sender];<br/>    require(senderBalance &gt;= amount, "ERC20: transfer amount exceeds balance");<br/>    unchecked {<br/>        _balances[sender] = senderBalance - amount;<br/>    }<br/>    _balances[recipient] += amount;<br/>[ . . . ]</span></pre><p id="9946" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">这是在ERC20.sol的第220行实现的transfer()函数。</p><h2 id="95ca" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">关于小数的一个注记。</h2><p id="4003" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">您可能已经注意到了ERC20.sol中定义的以下函数:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="2b75" class="lb ir ht kx b fv lc ld l le lf">function decimals() public view virtual override returns (uint8) {<br/>    return 18;<br/>}</span></pre><p id="5636" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">它的目的是什么？</p><p id="86a5" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">不幸的是，solidity语言和EVM不支持浮点数数据类型:这意味着智能合约中的所有算术运算都发生在整数类型之间。但是如果要转1.5 token呢？这在可靠性上是不可能的，因此EIP-20令牌标准提供了小数属性，该属性定义了令牌必须考虑多少个0。</p><p id="cc27" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">例如，假设一个EOA人想向另一个EOA人转让1.5个代币。在钱包的用户界面中，它指定1.5个代币作为要转移的金额，但实际上转移的代币金额是1.5 *小数。为了能够转移1.5代币，小数必须至少为1，因为该数字只有一个小数位。</p><p id="66f6" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在OpenZeppelin中，小数默认设置为18，因此在传输1.5令牌时，实际上计算是在1.5*10 ⁸ = 15000000000000000上进行的。</p><p id="b96b" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">更多信息:(https://docs . open zeppelin . com/contracts/4 . x/ERC 20 # a-note-on-decimals)</p><h1 id="adeb" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">OpenZeppelin扩展。</h1><p id="c482" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在部署智能合约之后，扩展为令牌管理提供了有用的实用工具。扩展是用Solidity语言实现的智能契约，是OpenZeppein库的一部分。我使用了这些扩展来为我的令牌提供以下功能:</p><ul class=""><li id="a565" class="lh li ht jq b jr kn jv ko jz lj kd lk kh ll kl lm ln lo lp dt translated">动态铸造新代币；</li><li id="c9a0" class="lh li ht jq b jr lq jv lr jz ls kd lt kh lu kl lm ln lo lp dt translated">疯狂燃烧的令牌；</li><li id="2e67" class="lh li ht jq b jr lq jv lr jz ls kd lt kh lu kl lm ln lo lp dt translated">动态暂停所有令牌的操作。</li></ul><p id="6692" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">除了暂停，铸造和刻录功能已经在ERC20.sol智能合约中实现，那么为什么要在另一个合约中实现它们呢？因为ERC20.sol中的函数是<em class="mi">内部的</em>，所以在部署契约后不能调用它们。为了让一个函数被一个事务调用，这个函数必须被声明为<em class="mi"> public </em>。</p><h2 id="c91f" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">铸造</h2><p id="bef1" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">ERC 20 preset inter pauser . sol契约提供了public mint()函数，角色为MINTER_ROLE的帐户可以调用该函数来增加令牌的总供应量。</p><p id="ca4f" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">ERC 20 presetmentimpauser . sol:51</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="9c33" class="lb ir ht kx b fv lc ld l le lf">function mint(address to, uint256 amount) public virtual {<br/>    require(hasRole(MINTER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have minter role to mint");<br/>    _mint(to, amount);<br/>}</span></pre><p id="1081" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">网址:<a class="ae km" href="https://github.com/lucadidomenico/myERC20Token/blob/master/contracts/MyTokenERC20.sol#L1" rel="noopener ugc nofollow" target="_blank">https://github . com/lucadidomenico/myerc 20 token/blob/master/contracts/mytokenerc 20 . sol # L1</a></p><p id="b4f6" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">public mint()函数调用ERC20.sol的internal _mint()函数。</p><h2 id="842b" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">燃烧的</h2><p id="6f14" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">ERC20Burnable.sol契约提供了public burn()函数，角色为BURNER_ROLE的帐户可以调用该函数，以减少令牌的总供应量。</p><p id="acc9" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">ERC20Burnable.sol:19</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="9a19" class="lb ir ht kx b fv lc ld l le lf">function burn(uint256 amount) public virtual {<br/>    _burn(_msgSender(), amount);<br/>}</span></pre><p id="dc8d" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">URL:<a class="ae km" href="https://github.com/lucadidomenico/myERC20Token/blob/master/node_modules/%40openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol#L1" rel="noopener ugc nofollow" target="_blank">https://github . com/lucadidomenico/myer C20 token/blob/master/node _ modules/% 40 open zeppelin/contracts/token/er C20/extensions/er C20 burnable . sol # L1</a></p><h2 id="74ed" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">暂停</h2><p id="72b9" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">通过从ERC20Pausable.sol继承，ERC 20 preset inter pauser . sol契约提供了暂停所有令牌传输的pause()函数，直到调用unpause()为止。这对于在评估期结束前阻止交易，或者在出现重大错误时使用紧急开关冻结所有令牌传输等情况非常有用。</p><p id="5c2c" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">ERC 20 presetmentimpauser . sol:65</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="297f" class="lb ir ht kx b fv lc ld l le lf">function pause() public virtual {<br/>    require(hasRole(PAUSER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have pauser role to pause");<br/>    _pause();<br/>}</span></pre><p id="b77c" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">ERC 20 presetmentimpauser . sol:79</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="d16d" class="lb ir ht kx b fv lc ld l le lf">function unpause() public virtual {<br/>    require(hasRole(PAUSER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have pauser role to unpause");<br/>    _unpause();<br/>}</span></pre><p id="fbfd" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">契约Pausable.sol定义了_pause变量:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="4814" class="lb ir ht kx b fv lc ld l le lf">bool private _paused;</span></pre><p id="c697" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">它最初在构造函数中被设置为“false”。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="5634" class="lb ir ht kx b fv lc ld l le lf">constructor() {<br/>    _paused = false;<br/>}</span></pre><p id="7657" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">并通过调用公共函数“pause()”和“unpause()”进行更新。</p><p id="2063" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">Pausable.sol:74</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="d126" class="lb ir ht kx b fv lc ld l le lf">function _pause() internal virtual whenNotPaused {<br/>    _paused = true;<br/>    emit Paused(_msgSender());<br/>}</span></pre><p id="7c90" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">Pausable.sol:86</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="eac4" class="lb ir ht kx b fv lc ld l le lf">function _unpause() internal virtual whenPaused {<br/>    _paused = false;<br/>    emit Unpaused(_msgSender());<br/>}</span></pre><h1 id="e54e" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">访问控制</h1><p id="99ae" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在myERC20Token中，使用OpenZeppelin库的AccessControl.sol智能契约实现了基于角色的访问控制机制(<a class="ae km" href="https://en.wikipedia.org/wiki/Role-based_access_control" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Role-based_access_control</a>)。</p><p id="1849" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">角色授权帐户调用令牌智能合约中的特定功能。帐户可以有0个或多个角色。</p><h2 id="bfeb" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">定义角色。</h2><p id="c635" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">MyTokenERC20实现中定义了三个角色:</p><ul class=""><li id="1356" class="lh li ht jq b jr kn jv ko jz lj kd lk kh ll kl lm ln lo lp dt translated">燃烧器角色</li><li id="c5b1" class="lh li ht jq b jr lq jv lr jz ls kd lt kh lu kl lm ln lo lp dt translated">Minter角色</li><li id="7bcc" class="lh li ht jq b jr lq jv lr jz ls kd lt kh lu kl lm ln lo lp dt translated">Pauser角色</li></ul><p id="eda6" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在ERC 20 preset inter Pauser . sol智能契约的第26行和第27行定义了Minter和Pauser角色。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="c3d7" class="lb ir ht kx b fv lc ld l le lf">bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");<br/>bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");</span></pre><p id="325b" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">Burner角色在MyTokenERC20.sol智能契约的第9行定义。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="964a" class="lb ir ht kx b fv lc ld l le lf">bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");</span></pre><h2 id="2bd3" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">使用角色。</h2><p id="8716" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">使用第49–54行定义的“_roles”映射和“RoleData”结构将角色保存在AccessControl.sol智能协定中。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="658a" class="lb ir ht kx b fv lc ld l le lf">[ . . . ]<br/>abstract contract AccessControl is Context, IAccessControl, ERC165 {<br/>    struct RoleData {<br/>        mapping(address =&gt; bool) members;<br/>        bytes32 adminRole;<br/>    }<br/>    mapping(bytes32 =&gt; RoleData) private _roles;<br/>[ . . . ]</span></pre><p id="f80d" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在上面的代码中，“RoleData”结构包含一个地址和一个布尔值之间的映射。AccessControl智能协定的“_roles”成员是角色和拥有该角色的帐户之间的映射。给定一个帐户和一个角色，您可以通过查看“RoleData”的“members”字段来测试该帐户是否具有该角色。这就是“hasRole”函数在AccessControl.sol的第83行所做的事情。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="d766" class="lb ir ht kx b fv lc ld l le lf">function hasRole(bytes32 role, address account) public view override returns (bool) {<br/>    return _roles[role].members[account];<br/>}</span></pre><p id="4985" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">最后，“RoleData”中的字段“adminRole”包含该角色的管理角色。事实上，在OpenZeppelin的访问控制机制实现中，对于每个角色都有一个admin角色:具有admin角色的帐户拥有向所有帐户授予或撤销该角色的权限。</p><p id="768e" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">例如:假设BURNER_ROLE角色的管理角色称为BURNER_ADMIN_ROLE。帐户A具有BURNER_ADMIN_ROLE角色。因此，帐户A可以向令牌的任何帐户授予和撤销BURNER_ROLE角色，包括他自己。</p><h2 id="bbe7" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">授予和撤销角色。</h2><p id="950c" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在上一节中，我们已经遇到了AccessControl.sol的函数grantRole()和revokeRole()。顾名思义，这些函数分别用于向帐户授予角色和撤销角色。请记住，只有该角色的管理员角色才能授予或撤销其他帐户的角色。然而，也可以在智能合同创建期间分配角色，即在构建器中；在这种情况下，使用了internal : _setupRole()函数。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="9547" class="lb ir ht kx b fv lc ld l le lf">constructor(string memory name, string memory symbol) ERC20(name, symbol) {<br/>    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());<br/>    _setupRole(MINTER_ROLE, _msgSender());<br/>    _setupRole(PAUSER_ROLE, _msgSender());<br/>}</span></pre><p id="6bda" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">ERC 20 preset inter PAUSER智能合同的构建者将DEFAULT_ADMIN_ROLE、MINTER_ROLE和PAUSER_ROLE分配给合同的创建者。然后调用AccessControl.sol的_setupRole()函数</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="6174" class="lb ir ht kx b fv lc ld l le lf">function _setupRole(bytes32 role, address account) internal virtual {<br/>    _grantRole(role, account);<br/>}</span></pre><p id="da6f" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">该函数又调用internal _grantRole()函数。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="c960" class="lb ir ht kx b fv lc ld l le lf">function _grantRole(bytes32 role, address account) private {<br/>    if (!hasRole(role, account)) {<br/>        _roles[role].members[account] = true;<br/>        emit RoleGranted(role, account, _msgSender());<br/>    }<br/>}</span></pre><h2 id="22b6" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">检查帐户的角色以授权smart contract上的操作。</h2><p id="02db" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">为了检查帐户是否具有执行特定操作的角色，使用了require()函数。它有两种用途:</p><ul class=""><li id="4f6f" class="lh li ht jq b jr kn jv ko jz lj kd lk kh ll kl lm ln lo lp dt translated">通过在特权函数的函数体内直接调用require()；</li><li id="2a39" class="lh li ht jq b jr lq jv lr jz ls kd lt kh lu kl lm ln lo lp dt translated">通过在修饰符中定义require()语句并在特权函数中包含修饰符。</li></ul><p id="6a0a" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">我更喜欢“修饰”的方式，因为我认为这样更不容易出错。</p><p id="5168" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">MyTokenERC20.sol:16</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="f02a" class="lb ir ht kx b fv lc ld l le lf">function burn(uint256 value) public onlyRole(BURNER_ROLE) override {<br/>    super._burn(msg.sender, value);<br/>}</span></pre><p id="3010" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在OpenZeppelin库中，两种方法都被使用。具体来说，ERC 20 preset inter pauser . sol使用第一种方法，而AccessControl.sol使用第二种方法，如下面的代码片段所示。</p><p id="dad1" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">ERC 20 presetmentimpauser . sol:51</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="883a" class="lb ir ht kx b fv lc ld l le lf">function mint(address to, uint256 amount) public virtual {<br/>    require(hasRole(MINTER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have minter role to mint");<br/>    _mint(to, amount);<br/>}</span></pre><p id="b761" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">ERC 20 presetmentimpauser . sol:65</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="bba9" class="lb ir ht kx b fv lc ld l le lf">function pause() public virtual {<br/>    require(hasRole(PAUSER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have pauser role to pause");<br/>    _pause();<br/>}</span></pre><p id="41fe" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">ERC 20 presetmentimpauser . sol:79</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="337a" class="lb ir ht kx b fv lc ld l le lf">function unpause() public virtual {<br/>    require(hasRole(PAUSER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have pauser role to unpause");<br/>    _unpause();<br/>}</span></pre><p id="cdd3" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">访问控制. sol:129</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="560c" class="lb ir ht kx b fv lc ld l le lf">function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {<br/>    _grantRole(role, account);<br/>}</span></pre><p id="4de0" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">访问控制. sol:142</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="5781" class="lb ir ht kx b fv lc ld l le lf">function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {<br/>    _revokeRole(role, account);<br/>}</span></pre><h2 id="d675" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">关于TimeLock的注意事项。</h2><p id="e3ad" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">请注意，OpenZeppelin还提供了一种时间锁机制来执行安全策略，特别是可以使用这种机制来防止管理员执行恶意任务。但是我没有在myERC20Token中实现这个机制，因为…</p><p id="0126" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">例如，合法项目可以使用timelock安全机制来防止“拉地毯”骗局。</p><p id="0b7f" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">网址:<a class="ae km" href="https://youtu.be/VlIcoKJsIP8?t=349" rel="noopener ugc nofollow" target="_blank">https://youtu.be/VlIcoKJsIP8?t=349</a></p><h1 id="b737" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">MyTokenERC20.sol</h1><p id="4d42" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我个人实现的基础契约是MyERC20Token.sol，由几行代码组成，因为我们已经看到了所有的功能都是在OpenZeppelin库中实现的，该契约包括了这些功能。</p><p id="03a9" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">具体来说，该文件包括ERC 20 preset interpauser . sol协定，该协定又包括ERC 20 . sol。ERC 20 preset interpauser . sol还包括AccessControlEnumerable、ERC20Burnable和ERC20Pausable，这些智能协定提供了前面几节中介绍的功能。</p><p id="0aa7" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">下面是MyTokenERC20.sol的源代码。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="ea95" class="lb ir ht kx b fv lc ld l le lf">// contracts/MyTokenERC20.sol<br/>// SPDX-License-Identifier: MIT<br/>pragma solidity ^0.8.0;</span><span id="d30a" class="lb ir ht kx b fv lg ld l le lf">import "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol";</span><span id="a4b8" class="lb ir ht kx b fv lg ld l le lf">contract MyTokenERC20 is ERC20PresetMinterPauser {</span><span id="cab9" class="lb ir ht kx b fv lg ld l le lf">    bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");</span><span id="d3f0" class="lb ir ht kx b fv lg ld l le lf">constructor(uint256 initialSupply) ERC20PresetMinterPauser("MyToken", "MTK") {<br/>        _mint(msg.sender, initialSupply);<br/>        grantRole(BURNER_ROLE, msg.sender);<br/>    }</span><span id="e72c" class="lb ir ht kx b fv lg ld l le lf">    function burn(uint256 value) public onlyRole(BURNER_ROLE) override {<br/>        super._burn(msg.sender, value);<br/>    }</span><span id="e12e" class="lb ir ht kx b fv lg ld l le lf">    fallback() external payable { revert(); }<br/>}</span></pre><p id="bd8a" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">源代码可以在这里找到:<a class="ae km" href="https://github.com/lucadidomenico/myERC20Token/blob/master/contracts/MyTokenERC20.sol" rel="noopener ugc nofollow" target="_blank">https://github . com/lucadidomenico/myerc 20 token/blob/master/contracts/mytokenerc 20 . sol</a></p><h2 id="103d" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">合同分析。</h2><p id="4591" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">MyERC20Token.sol在第9行定义了BURNER_ROLE角色。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="fea4" class="lb ir ht kx b fv lc ld l le lf">bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");</span></pre><p id="042b" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">拥有此角色的帐户可以刻录代币，从而减少流通中的代币总数。</p><p id="1a30" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">我的令牌的构造者在第11行。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="3a03" class="lb ir ht kx b fv lc ld l le lf">constructor(uint256 initialSupply) ERC20PresetMinterPauser("MyToken", "MTK") {<br/>    _mint(msg.sender, initialSupply);<br/>    grantRole(BURNER_ROLE, msg.sender);<br/>}</span></pre><p id="6c62" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">我们将部署的令牌称为“MyToken ”,符号为MTK。构造函数将BURNER_ROLE分配给智能合约的创建者(即msg.sender)。构造函数接受一个参数，这是令牌的总供应量，用uint256 <a class="ae km" href="https://docs.openzeppelin.com/contracts/4.x/erc20-supply#fixed-supply)." rel="noopener ugc nofollow" target="_blank">表示。</a>为了分配初始供应量，使用了合同ERC20.sol提供的_mint()函数。</p><p id="97ad" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">契约在第16行定义了burn()函数。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="e9a8" class="lb ir ht kx b fv lc ld l le lf">function burn(uint256 value) public onlyRole(BURNER_ROLE) override {<br/>    super._burn(msg.sender, value);<br/>}</span></pre><p id="0523" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">具有BURNER_ROLE角色的帐户可以“刻录”令牌。为了检查调用函数burn()的帐户是否具有正确的角色，它使用了“onlyRole”修饰符。帐户从其余额中燃烧令牌，因此当燃烧令牌时，帐户余额必须&gt; =燃烧的令牌数量，并且ERC20.sol的_burn()函数中的第280行中的这一行进行检查:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="460f" class="lb ir ht kx b fv lc ld l le lf">require(accountBalance &gt;= amount, "ERC20: burn amount exceeds balance");</span></pre><p id="98fd" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">最后，契约在第21行实现了fallback()函数。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="f2f4" class="lb ir ht kx b fv lc ld l le lf">// REJECT any incoming ether<br/>fallback() external payable { revert(); }</span></pre><p id="91cf" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">Solidity中的fallback()函数是在事务中没有数据或声明的函数名的情况下调用的函数。在这种情况下，我实现了这个函数，以防止在智能契约中永远锁定以太。例如，如果一个帐户要向另一个帐户发送以太网，但错误地在目的地址中插入了合同的地址，以太网将被永远锁定，没有人可以从合同中撤销它们，因为合同不提供任何“撤销”功能。为了防止这种情况，fallback()函数调用revert()，从而取消事务并保存调用者的乙醚。</p><h2 id="adf5" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">在区块链以太坊部署myERC20Token</h2><p id="e202" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">智能合约可以部署在不同的网络上。主以太网被称为“mainnet ”,在那里你使用真正的以太网，所以是真正的货币。为了测试智能合约，开发者可以使用其他以太坊测试网络。“Ropsten”是以太坊上的主要测试网络，它提供了一个与主区块链工作方式相同的环境。另一个有效的测试方法是使用“ganache”区块链，这是一个运行在本地主机上的以太坊区块链。</p><p id="aeb3" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">出于演示目的，我将在“ganache”上部署myERC20Token，您可以从以下URL下载:</p><div class="mj mk fm fo ml mm"><a href="https://www.trufflesuite.com/ganache" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab ej"><div class="mo ab mp cl cj mq"><h2 class="bd hu fv z el mr eo ep ms er et hs dt translated">加纳切|松露套房</h2><div class="mt l"><h3 class="bd b fv z el mr eo ep ms er et ek translated">部署契约，开发您的分散式应用程序(dapps ),并对智能契约进行测试。可作为…</h3></div><div class="mu l"><p class="bd b gc z el mr eo ep ms er et ek translated">www.trufflesuite.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na nb mm"/></div></div></a></div><p id="41ef" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">下载完成后，运行ganache二进制文件。它显示以下页面:</p><figure class="ks kt ku kv fq nd fe ff paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="fe ff nc"><img src="../Images/02f5610be4fba09e3077468b47a0164d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nW0wKv8ul6-jFKnEg_dK2A.png"/></div></div></figure><p id="e0b3" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">单击“Quickstart Ethereum”按钮，ganache将实例化一个新的区块链，它运行在本地主机的7545端口上。</p><figure class="ks kt ku kv fq nd fe ff paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="fe ff nj"><img src="../Images/419ee0e7b7ace96eb8630014d9a26701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MIMAqALfuc6RSXjOFQc3w.png"/></div></div></figure><p id="539d" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在上面的截图中，你可以看到ganache创建了10个新钱包，每个钱包都有100 ETH的余额。</p><p id="1b35" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">“ganache”软件是“truffle suite”的一部分，后者本质上是一个node.js框架，帮助开发人员部署智能合约，并通过使用web3.js JavaScript库与它们进行交互。</p><p id="1bd0" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">松露网站:</p><div class="mj mk fm fo ml mm"><a href="https://www.trufflesuite.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab ej"><div class="mo ab mp cl cj mq"><h2 class="bd hu fv z el mr eo ep ms er et hs dt translated">智能合约的绝佳工具| Truffle套件</h2><div class="mt l"><h3 class="bd b fv z el mr eo ep ms er et ek translated">智能合同使SWEETER成为世界一流的开发环境、测试框架和资产管道，适用于…</h3></div><div class="mu l"><p class="bd b gc z el mr eo ep ms er et ek translated">www.trufflesuite.com</p></div></div><div class="mv l"><div class="nk l mx my mz mv na nb mm"/></div></div></a></div><p id="8f49" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">为了部署令牌，从github repo(<a class="ae km" href="https://github.com/lucadidomenico/myERC20Token" rel="noopener ugc nofollow" target="_blank">https://github.com/lucadidomenico/myERC20Token</a>)克隆令牌源代码，并在repo目录中运行以下命令:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="a464" class="lb ir ht kx b fv lc ld l le lf">$ npm install<br/>$ truffle deploy --network ganache</span></pre><p id="6067" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">truffle的输出显示了有关事务的信息:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="5594" class="lb ir ht kx b fv lc ld l le lf">Compiling your contracts...<br/>===========================<br/>&gt; Everything is up to date, there is nothing to compile.</span><span id="c7ed" class="lb ir ht kx b fv lg ld l le lf">Starting migrations...<br/>======================<br/>&gt; Network name:    'ganache'<br/>&gt; Network id:      5777<br/>&gt; Block gas limit: 6721975 (0x6691b7)</span><span id="4be6" class="lb ir ht kx b fv lg ld l le lf">1_initial_migration.js<br/>======================</span><span id="1d03" class="lb ir ht kx b fv lg ld l le lf">Replacing 'Migrations'<br/>   ----------------------<br/>   &gt; transaction hash:    0xcc061045784b2b6dc332035b6d01bdcdbfe12313e12472369949d48b9f4597bd<br/>   &gt; Blocks: 0            Seconds: 0<br/>   &gt; contract address:    0xF1FF9a87e6a270A88C5651222053C9B7C93d3799<br/>   &gt; block number:        1<br/>   &gt; block timestamp:     1638093841<br/>   &gt; account:             0x4526fC5171752CC3eA6A3173E75625553cbC8D1f<br/>   &gt; balance:             99.9969218<br/>   &gt; gas used:            153910 (0x25936)<br/>   &gt; gas price:           20 gwei<br/>   &gt; value sent:          0 ETH<br/>   &gt; total cost:          0.0030782 ETH</span><span id="4553" class="lb ir ht kx b fv lg ld l le lf">&gt; Saving migration to chain.<br/>   &gt; Saving artifacts<br/>   -------------------------------------<br/>   &gt; Total cost:           0.0030782 ETH</span><span id="ecc4" class="lb ir ht kx b fv lg ld l le lf">2_deploy_all.js<br/>===============</span><span id="7a66" class="lb ir ht kx b fv lg ld l le lf">Replacing 'MyTokenERC20'<br/>   ------------------------<br/>   &gt; transaction hash:    0x44dd2e171a86b3e6fde7ff8980d6b3b7d6f4a6dbe44f792a3b2eb2fc823c6ef1<br/>   &gt; Blocks: 0            Seconds: 0<br/>   &gt; contract address:    0x3c0acBad62C03443953c521FBe16375777A1dF80<br/>   &gt; block number:        3<br/>   &gt; block timestamp:     1638093841<br/>   &gt; account:             0x4526fC5171752CC3eA6A3173E75625553cbC8D1f<br/>   &gt; balance:             99.95611126<br/>   &gt; gas used:            1998237 (0x1e7d9d)<br/>   &gt; gas price:           20 gwei<br/>   &gt; value sent:          0 ETH<br/>   &gt; total cost:          0.03996474 ETH</span><span id="43c1" class="lb ir ht kx b fv lg ld l le lf">&gt; Saving migration to chain.<br/>   &gt; Saving artifacts<br/>   -------------------------------------<br/>   &gt; Total cost:          0.03996474 ETH</span><span id="66cc" class="lb ir ht kx b fv lg ld l le lf">Summary<br/>=======<br/>&gt; Total deployments:   2<br/>&gt; Final cost:          0.04304294 ETH</span></pre><p id="c0e4" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">两笔交易花费的ETH为0.04304294 ETH。</p><p id="dd52" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">我们可以看到部署了2个合同:迁移和MyTokenERC20。</p><p id="acd1" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">迁移是由truffle提供的一个智能合约，帮助管理所有其他智能合约的部署。Migrations.sol智能合同具有以下源代码:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="3d81" class="lb ir ht kx b fv lc ld l le lf">// SPDX-License-Identifier: MIT<br/>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span><span id="3803" class="lb ir ht kx b fv lg ld l le lf">contract Migrations {<br/>    address public owner = msg.sender;<br/>    uint public last_completed_migration;</span><span id="0b7a" class="lb ir ht kx b fv lg ld l le lf">modifier restricted() {<br/>        require(<br/>        msg.sender == owner,<br/>        "This function is restricted to the contract's owner"<br/>        );<br/>        _;<br/>    }</span><span id="427b" class="lb ir ht kx b fv lg ld l le lf">function setCompleted(uint completed) public restricted {<br/>        last_completed_migration = completed;<br/>    }<br/>}</span></pre><p id="c2cc" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">有关迁移的更多信息，请参见truffle的文档:<a class="ae km" href="https://www.trufflesuite.com/docs/truffle/getting-started/running-migrations" rel="noopener ugc nofollow" target="_blank">https://www . truffle suite . com/docs/truffle/getting-started/running-migrations</a></p><p id="46a3" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">基本上，当您使用“truffle deploy”命令部署智能合约时，您首先要对迁移智能合约进行事务处理，如上面的屏幕截图所示。</p><figure class="ks kt ku kv fq nd fe ff paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="fe ff nl"><img src="../Images/4eebdcafd0c2327b85220cb4951f3e52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjN5IyK95ThRNhisUX9lAA.png"/></div></div></figure><h2 id="98cf" class="lb ir ht bd is lv lw lx iw ly lz ma ja jz mb mc je kd md me ji kh mf mg jm mh dt translated">与智能合同交互</h2><p id="1601" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">为了使用web3.js与部署的智能合约进行交互，请运行以下命令:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="3c38" class="lb ir ht kx b fv lc ld l le lf">$ truffle console --network ganache</span></pre><p id="4fd1" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">这将打开一个控制台，您可以在其中使用web3.js发布JavaScript代码。例如，现在我将从一个帐户(收到10 ⁸ MyTokenERC20总供应量的帐户)转移1000个令牌到另一个帐户。该帐户在“帐户”数组中可用:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="fd29" class="lb ir ht kx b fv lc ld l le lf">truffle(ganache)&gt; accounts<br/>[ '0x4526fC5171752CC3eA6A3173E75625553cbC8D1f',<br/>  '0xB4545da269dF6835507D58B14f10B451885c42Ed',<br/>  '0x8b40A9E295a87b95336dC2426BC6b473FC86884C',<br/>  '0xB33BC04b589F7c3D0d5E70eB3aaC9702e35ca93e',<br/>  '0x59b68A348eb5cF437ef8DDA473bAaD3C1EF6488C',<br/>  '0x8843d4e156e3E30FFa951488A6F918fD3028d1C3',<br/>  '0xEa7d08C13e5041a8fe0A9dce562dA41B1DDC66b7',<br/>  '0xF69eE5d9F65F130fB4805E881014B6E429ca0EAC',<br/>  '0x44936B4aeBc137b1CC4D9fF2389cc15606D2E4D3',<br/>  '0x69A8432E6720d4B4a642b6e7217DaB741F5e0133' ]</span></pre><p id="b074" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">为了与MyTokenERC20智能合约进行交互，我们需要一个实例。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="2ccc" class="lb ir ht kx b fv lc ld l le lf">truffle(ganache)&gt; var mytoken = await MyTokenERC20.deployed()<br/>undefined</span></pre><p id="ce21" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">如果我们在mytoken上调用balanceOf() ERC20方法，我们可以看到帐户的余额。</p><p id="acee" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">账户余额[0]:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="2dd2" class="lb ir ht kx b fv lc ld l le lf">truffle(ganache)&gt; mytoken.balanceOf(accounts[0]).then(a =&gt; a.toString())<br/>'10000000000000000000000000'</span></pre><p id="7425" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">帐户余额[1]:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="7858" class="lb ir ht kx b fv lc ld l le lf">truffle(ganache)&gt; mytoken.balanceOf(accounts[1]).then(a =&gt; a.toNumber())<br/>'0'</span></pre><p id="dadc" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">现在，我们从帐户[0]向帐户[1]发送1000个令牌:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="7e6b" class="lb ir ht kx b fv lc ld l le lf">truffle(ganache)&gt; mytoken.transfer(accounts[1], 1000)<br/>{ tx:<br/>   '0xc0027840e5b740220e0a4de6f818284a7e9820f2e65701f512e6b605af1d37e7',<br/>  receipt:<br/>   { transactionHash:<br/>      '0xc0027840e5b740220e0a4de6f818284a7e9820f2e65701f512e6b605af1d37e7',<br/>     transactionIndex: 0,<br/>     blockHash:<br/>      '0x98d5711d55ac91d5a1db685f2d42d6b85ada8015d212ad84c05f4ed54ab439c8',<br/>     blockNumber: 5,<br/>     from: '0x4526fc5171752cc3ea6a3173e75625553cbc8d1f',<br/>     to: '0x3c0acbad62c03443953c521fbe16375777a1df80',<br/>     gasUsed: 52354,<br/>     cumulativeGasUsed: 52354,<br/>     contractAddress: null,<br/>     logs: [ [Object] ],<br/>     status: true,<br/>     logsBloom:<br/>      '0x00000000000000000000000000000800000000000000000000000801000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000001000000012000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000004000000000',<br/>     rawLogs: [ [Object] ] },<br/>  logs:<br/>   [ { logIndex: 0,<br/>       transactionIndex: 0,<br/>       transactionHash:<br/>        '0xc0027840e5b740220e0a4de6f818284a7e9820f2e65701f512e6b605af1d37e7',<br/>       blockHash:<br/>        '0x98d5711d55ac91d5a1db685f2d42d6b85ada8015d212ad84c05f4ed54ab439c8',<br/>       blockNumber: 5,<br/>       address: '0x3c0acBad62C03443953c521FBe16375777A1dF80',<br/>       type: 'mined',<br/>       id: 'log_ca948418',<br/>       event: 'Transfer',<br/>       args: [Result] } ] }</span></pre><p id="1b6d" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">事务细节在“tx”对象中返回。交易成功，余额现已更新。</p><p id="e6f4" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">账户余额[0]:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="15c5" class="lb ir ht kx b fv lc ld l le lf">truffle(ganache)&gt; mytoken.balanceOf(accounts[0]).then(a =&gt; a.toString())<br/>'9999999999999999999999000'</span></pre><p id="bf4f" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">帐户余额[1]:</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="ce34" class="lb ir ht kx b fv lc ld l le lf">truffle(ganache)&gt; mytoken.balanceOf(accounts[1]).then(a =&gt; a.toString())<br/>'1000'</span></pre><blockquote class="nm"><p id="0131" class="nn no ht bd np nq nr ns nt nu nv kl ek translated">加入Coinmonks <a class="ae km" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae km" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h2 id="6048" class="lb ir ht bd is lv nw lx iw ly nx ma ja jz ny mc je kd nz me ji kh oa mg jm mh dt translated">也阅读</h2><div class="mj mk fm fo ml mm"><a rel="noopener follow" target="_blank" href="/coinmonks/leveraged-token-3f5257808b22"><div class="mn ab ej"><div class="mo ab mp cl cj mq"><h2 class="bd hu fv z el mr eo ep ms er et hs dt translated">杠杆代币[多头代币]终极指南</h2><div class="mt l"><h3 class="bd b fv z el mr eo ep ms er et ek translated">杠杆化令牌是具有杠杆化风险敞口的ERC20令牌，不考虑保证金、要求、管理…</h3></div><div class="mu l"><p class="bd b gc z el mr eo ep ms er et ek translated">medium.com</p></div></div><div class="mv l"><div class="ob l mx my mz mv na nb mm"/></div></div></a></div><div class="mj mk fm fo ml mm"><a href="https://blog.coincodecap.com/crypto-exchange" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab ej"><div class="mo ab mp cl cj mq"><h2 class="bd hu fv z el mr eo ep ms er et hs dt translated">最佳加密交易所| 2021年十大加密货币交易所</h2><div class="mt l"><h3 class="bd b fv z el mr eo ep ms er et ek translated">加密货币交易所的加密交易需要了解市场，这可以帮助你获得利润。之前…</h3></div><div class="mu l"><p class="bd b gc z el mr eo ep ms er et ek translated">blog.coincodecap.com</p></div></div><div class="mv l"><div class="oc l mx my mz mv na nb mm"/></div></div></a></div><div class="mj mk fm fo ml mm"><a href="https://blog.coincodecap.com/best-swap-platforms" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab ej"><div class="mo ab mp cl cj mq"><h2 class="bd hu fv z el mr eo ep ms er et hs dt translated">2021年最佳加密交换平台| CoinCodeCap</h2><div class="mt l"><h3 class="bd b fv z el mr eo ep ms er et ek translated">如果我们看看今天的场景，许多加密货币交换平台提供了广泛的功能和深度…</h3></div><div class="mu l"><p class="bd b gc z el mr eo ep ms er et ek translated">blog.coincodecap.com</p></div></div><div class="mv l"><div class="od l mx my mz mv na nb mm"/></div></div></a></div><div class="mj mk fm fo ml mm"><a rel="noopener follow" target="_blank" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa"><div class="mn ab ej"><div class="mo ab mp cl cj mq"><h2 class="bd hu fv z el mr eo ep ms er et hs dt translated">2021年最佳加密借贷平台| 6大比特币借贷平台</h2><div class="mt l"><h3 class="bd b fv z el mr eo ep ms er et ek translated">获得比特币和其他加密货币的最佳贷款利率</h3></div><div class="mu l"><p class="bd b gc z el mr eo ep ms er et ek translated">medium.com</p></div></div><div class="mv l"><div class="oe l mx my mz mv na nb mm"/></div></div></a></div><div class="mj mk fm fo ml mm"><a rel="noopener follow" target="_blank" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a"><div class="mn ab ej"><div class="mo ab mp cl cj mq"><h2 class="bd hu fv z el mr eo ep ms er et hs dt translated">2021年最佳免费加密交易机器人</h2><div class="mt l"><h3 class="bd b fv z el mr eo ep ms er et ek translated">2021年币安、比特币基地、库币和其他密码交易所的最佳密码交易机器人。四进制，位间隙…</h3></div><div class="mu l"><p class="bd b gc z el mr eo ep ms er et ek translated">medium.com</p></div></div><div class="mv l"><div class="of l mx my mz mv na nb mm"/></div></div></a></div><div class="mj mk fm fo ml mm"><a rel="noopener follow" target="_blank" href="/coinmonks/best-crypto-signals-telegram-5785cdbc4b2b"><div class="mn ab ej"><div class="mo ab mp cl cj mq"><h2 class="bd hu fv z el mr eo ep ms er et hs dt translated">最佳4个加密交易信号电报通道</h2><div class="mt l"><h3 class="bd b fv z el mr eo ep ms er et ek translated">这是乏味的找到正确的加密交易信号提供商。因此，在本文中，我们将讨论最好的…</h3></div><div class="mu l"><p class="bd b gc z el mr eo ep ms er et ek translated">medium.com</p></div></div><div class="mv l"><div class="og l mx my mz mv na nb mm"/></div></div></a></div><div class="mj mk fm fo ml mm"><a href="https://blog.coincodecap.com/bitsgap-review" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab ej"><div class="mo ab mp cl cj mq"><h2 class="bd hu fv z el mr eo ep ms er et hs dt translated">获取信号、交易机器人和套利</h2><div class="mt l"><h3 class="bd b fv z el mr eo ep ms er et ek translated">在本文中，我们将回顾Bitsgap，这是一个满足您所有交易需求的一站式加密交易平台。它…</h3></div><div class="mu l"><p class="bd b gc z el mr eo ep ms er et ek translated">blog.coincodecap.com</p></div></div><div class="mv l"><div class="oh l mx my mz mv na nb mm"/></div></div></a></div><div class="mj mk fm fo ml mm"><a href="https://blog.coincodecap.com/best-telegram-channels" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab ej"><div class="mo ab mp cl cj mq"><h2 class="bd hu fv z el mr eo ep ms er et hs dt translated">40个最佳电报频道，用于加密、电影、表演和演讲| CoinCodeCap</h2><div class="mt l"><h3 class="bd b fv z el mr eo ep ms er et ek translated">随着我们周围无限的信息，我们很难筛选和了解有价值的信息。电报有…</h3></div><div class="mu l"><p class="bd b gc z el mr eo ep ms er et ek translated">blog.coincodecap.com</p></div></div><div class="mv l"><div class="oi l mx my mz mv na nb mm"/></div></div></a></div></div></div>    
</body>
</html>