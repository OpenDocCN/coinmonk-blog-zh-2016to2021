<html>
<head>
<title>Ethernaut Alien Codex Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太外星人法典解决方案</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethernaut-alien-codex-solution-74e3b0ca592e?source=collection_archive---------3-----------------------#2018-11-22">https://medium.com/coinmonks/ethernaut-alien-codex-solution-74e3b0ca592e?source=collection_archive---------3-----------------------#2018-11-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="7323" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://ethernaut.zeppelin.solutions/level/0x73048cec9010e92c298b016966bde1cc47299df5" rel="noopener ugc nofollow" target="_blank">外星人法典</a>是<a class="jp jq gr" href="https://medium.com/u/60cd0f45aab?source=post_page-----74e3b0ca592e--------------------------------" rel="noopener" target="_blank">妮可朱</a>设计的以太20级。本文提出了我的解决方案。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="fe ff jr"><img src="../Images/541a1e601d8b525ffab46887294f0830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*78MsT1bDstHf67lj.jpg"/></div></div></figure><p id="a7ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">剧透警报。如果你想自己解决，请不要阅读下面的内容。下面的文本包含完整的解决方案。</strong></p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="kd ke l"/></div></figure><p id="2b4a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">关卡的目标是声明契约的所有权。AlienCodex是从Ownable继承的，因此为了做到这一点，我们希望用我们的地址覆盖契约存储中的<code class="eh kf kg kh ki b">_owner</code>变量。<br/>整个解决方案可以分为两部分。首先，我们必须以某种方式将<code class="eh kf kg kh ki b">contract</code>变量设置为true来访问契约方法，因为它们受到<code class="eh kf kg kh ki b">contacted</code>修饰符的保护。</p><h1 id="050a" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">将联系人设置为True</h1><p id="dc5b" class="pw-post-body-paragraph iq ir ht is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hm dt translated">方法<code class="eh kf kg kh ki b">make_contact</code>将<code class="eh kf kg kh ki b">contact</code>设置为真，但是有一个检查<code class="eh kf kg kh ki b">assert(_firstContactMessage.length &gt; 2**200);</code>。显而易见的解决方案是传递长度大于<code class="eh kf kg kh ki b">2 ** 200</code>的<code class="eh kf kg kh ki b">bytes32[]</code>数组。问题是数组的大小是如此之大，以至于没有机器有足够的内存来存储它。如果您尝试这样做，它会使您的本地节点崩溃。<br/>能做些什么？有人可能会问。一如既往的细节魔鬼。Solidity此时不会生成验证有效载荷大小与声明长度的代码。换句话说，当你调用solidity方法时，你传递的是数组大小，而不是实际有效载荷。</p><p id="ce31" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们滥用它。</p><p id="83a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://solidity.readthedocs.io/en/latest/abi-spec.html" rel="noopener ugc nofollow" target="_blank">约定ABI </a>规范定义了我们应该如何为约定调用编码数据。在我们的例子<code class="eh kf kg kh ki b">make_contact(bytes32[] _firstContactMessage)</code>中，我们有一个带有一个动态参数的函数。根据规范，数据参数将具有以下结构:</p><ul class=""><li id="efe6" class="lm ln ht is b it iu ix iy jb lo jf lp jj lq jn lr ls lt lu dt translated">函数签名的4字节哈希</li><li id="b0ef" class="lm ln ht is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu dt translated">bytes32[]数据部分的位置</li><li id="7f4c" class="lm ln ht is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu dt translated">bytes32[]数组的长度</li><li id="efaf" class="lm ln ht is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu dt translated">实际数据。</li></ul><p id="0e06" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们计算所有的值。<br/>函数签名的散列将是<code class="eh kf kg kh ki b">web3.sha3('make_contact(bytes32[])')</code>，这导致<code class="eh kf kg kh ki b">0x1d3d4c0b6dd3cffa8438b3336ac6e7cd0df521df3bef5370f94efed6411c1a65</code>。我们要取前4个字节，所以<code class="eh kf kg kh ki b">0x1d3d4c0b</code>我们想要的结果。<br/>数据的位置从签名的散列值偏移，在我们的例子中，它只有32个字节，因为ABI规范中的长度是32个字节—<code class="eh kf kg kh ki b">0x0000000000000000000000000000000000000000000000000000000000000020</code>。<br/>数组的长度必须大于<code class="eh kf kg kh ki b">2**200</code>让我们用<code class="eh kf kg kh ki b">0x1000000000000000000000000000000000000000000000000000000000000000</code>吧。实际的数据实际上什么都没有，因为我们违背了承诺，不会为数组提供任何数据。</p><p id="fb13" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最终数据将是</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="kd ke l"/></div></figure><p id="6dd3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，我们可以调用<code class="eh kf kg kh ki b">make_contact</code>方法将<code class="eh kf kg kh ki b">contact</code>设置为true——</p><p id="37e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh kf kg kh ki b">sendTransaction({to: contract.address, data: data, from: player, gas: 900000});</code>。</p><p id="9b03" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh kf kg kh ki b">await contract.contact()</code>的结果应该变为<code class="eh kf kg kh ki b">true</code>。</p><h1 id="d560" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">用玩家变量覆盖所有者</h1><p id="0cad" class="pw-post-body-paragraph iq ir ht is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hm dt translated">由于<code class="eh kf kg kh ki b">contact</code>没有被设置为<code class="eh kf kg kh ki b">true</code>，我们可以访问所有被<code class="eh kf kg kh ki b">contacted</code>修饰符保护的方法。<br/>似乎没有办法修改<code class="eh kf kg kh ki b">_owner</code>变量，因为不存在分配它的代码。但是请记住，所有状态变量都位于同一个存储连续体上，可能会成为写入错误的受害者。<br/> <code class="eh kf kg kh ki b">revise</code>功能可以将任何存储槽设置为我们提供的任何值。正是我们需要的。不幸的是，如果我们用index &gt; = length调用它，它会失败。<br/>方法<code class="eh kf kg kh ki b">retract</code>没有检查int下溢。通过调用它，我们将把<code class="eh kf kg kh ki b">codex</code>的长度从<code class="eh kf kg kh ki b">0</code>改为<code class="eh kf kg kh ki b">2**256 - 1</code>。EVM的存储大小正好是<code class="eh kf kg kh ki b">2**256-1</code>个槽的<code class="eh kf kg kh ki b">32</code>字节。本质上，通过将<code class="eh kf kg kh ki b">codex</code>的长度设置为EVM存储的长度，我们获得了修改整个EVM存储的任何插槽的能力。<br/>我们必须计算出<code class="eh kf kg kh ki b">_owner</code>变量在存储器上的位置以及偏移量索引，以便用<code class="eh kf kg kh ki b">revise</code>方法对其进行修改。<br/> <code class="eh kf kg kh ki b">_owner</code>变量位于合约<a class="ae jo" href="https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/" rel="noopener ugc nofollow" target="_blank">存储</a>的0 slo。Codex数组长度位于1个存储槽。这是因为EVM优化存储和地址类型占用20字节，bool占用1字节，所以它们都适合一个32字节槽。<br/>现在我们必须为<code class="eh kf kg kh ki b">revise</code>方法计算索引<code class="eh kf kg kh ki b">i</code>。根据分配规则，位于<code class="eh kf kg kh ki b">keccak256(bytes32(1))</code>的EVM存储器上的<code class="eh kf kg kh ki b">codex</code>阵列的开始。因此我们的目标位置将是<code class="eh kf kg kh ki b">index = 2 ** 256 - uint(one);</code>。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="kd ke l"/></div></figure><p id="5577" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行后计算结果是<code class="eh kf kg kh ki b">35707666377435648211887908874984608119992236509074197713628505308453184860938</code>。<br/>现在我们终于可以调用<code class="eh kf kg kh ki b">revise</code>方法了。</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="kd ke l"/></div></figure><p id="2d62" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此<code class="eh kf kg kh ki b">await contract.owner();</code>应该改成你的地址。成功！</p><h1 id="ffc3" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">结论</h1><p id="00f7" class="pw-post-body-paragraph iq ir ht is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hm dt translated">该级别向我们展示了如何滥用契约ABI来为契约调用中的动态数组参数提供假长度，以及如何滥用存储的动态数组来用所需数据覆盖契约存储内的任何片段。</p></div><div class="ab cl ma mb hb mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hm hn ho hp hq"><h2 id="6d50" class="mh kk ht bd kl mi mj mk kp ml mm mn kt jb mo mp kx jf mq mr lb jj ms mt lf mu dt translated">如果这篇文章有帮助，请点击拍手👏按钮下面几下，以示支持！⬇⬇</h2><h1 id="cac5" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">社会的</h1><ul class=""><li id="b6e3" class="lm ln ht is b it lh ix li jb mv jf mw jj mx jn lr ls lt lu dt translated">在<a class="ae jo" href="https://www.linkedin.com/in/ylv-io/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系。</li><li id="53ab" class="lm ln ht is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu dt translated">在<a class="ae jo" href="https://twitter.com/ylv_io" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我。</li></ul><h1 id="7d7f" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">阅读更多</h1><div class="my mz fm fo na nb"><a href="https://hackernoon.com/how-to-create-and-deploy-your-own-eos-token-1f4c9cc0eca1" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab ej"><div class="nd ab ne cl cj nf"><h2 class="bd hu fv z el ng eo ep nh er et hs dt translated">如何创建和部署您自己的EOS令牌</h2><div class="ni l"><h3 class="bd b fv z el ng eo ep nh er et ek translated">我们将弄清楚什么是EOS令牌，以及您如何自己创建和部署它。</h3></div><div class="nj l"><p class="bd b gc z el ng eo ep nh er et ek translated">hackernoon.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np kb nb"/></div></div></a></div><div class="my mz fm fo na nb"><a href="https://hackernoon.com/how-much-does-it-costs-to-run-dapp-in-2018-87ee11fe1d5d" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab ej"><div class="nd ab ne cl cj nf"><h2 class="bd hu fv z el ng eo ep nh er et hs dt translated">2018年办DApp要花多少钱</h2><div class="ni l"><h3 class="bd b fv z el ng eo ep nh er et ek translated">你认为你的AWS或网站的数字海洋账单正在杀死你吗？</h3></div><div class="nj l"><p class="bd b gc z el ng eo ep nh er et ek translated">hackernoon.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np kb nb"/></div></div></a></div></div><div class="ab cl ma mb hb mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hm hn ho hp hq"><p id="2141" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="nr">最初发表于</em> <a class="ae jo" href="https://ylv.io/p/8bada813-7700-4d34-ad30-04d19a71b802/" rel="noopener ugc nofollow" target="_blank"> <em class="nr"> ylv.io </em> </a> <em class="nr">。</em></p><blockquote class="ns"><p id="f1d3" class="nt nu ht bd nv nw nx ny nz oa ob jn ek translated"><a class="ae jo" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="od oe of og oh jw fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff oc"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>