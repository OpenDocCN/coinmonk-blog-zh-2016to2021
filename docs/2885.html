<html>
<head>
<title>Arrays and Maps in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实体中的数组和映射</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/array-and-map-in-solidity-a579b311d74b?source=collection_archive---------0-----------------------#2020-04-01">https://medium.com/coinmonks/array-and-map-in-solidity-a579b311d74b?source=collection_archive---------0-----------------------#2020-04-01</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/9818675b885a2ebcd6df525bb9163362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*4DgMmkpqsMPF8Akl8AMsUg.png"/></div></figure><blockquote class="ix"><p id="8e15" class="iy iz ht bd ja jb jc jd je jf jg jh ek translated">数组允许我们表示一个数据集合，但是更有用的是将数组看作一个相同类型的变量的集合，这些变量的键具有基于它们被添加的顺序的顺序。</p></blockquote><p id="fae2" class="pw-post-body-paragraph ji jj ht jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke jh hm dt translated">不是声明单独的变量，比如数字1，数字2，数字3，…..，和number99，你可以声明一个数组变量如<em class="kf"> numbers </em>并用numbers[0]，numbers[1]，…，numbers[99]来表示单个变量。</p><p id="2414" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">理解了数组在JAVASCRIPT和PHP中的工作原理后，我打算在solidity中快速浏览一遍，但令我最惊讶的是，在solidity区块链世界中，情况完全不同:)。我决定写一下<em class="kf">数组</em>和<em class="kf">贴图</em>，因为它们看起来都很相似，可以一起使用。</p><p id="88b4" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">与javascript不同，在JavaScript中，我们可以有一个整数数组以及字符串或任何其他数据类型，我们的数组必须有相同数据类型的变量，这可以在如下声明它时强制执行:</p><pre class="kl km kn ko fq kp kq kr ks aw kt dt"><span id="199c" class="ku kv ht kq b fv kw kx l ky kz">uint[] myArray; //declaring an array of integer variables</span></pre><p id="f6f8" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">在我全面深入solidity中的数组之前，我想澄清solidity中有两种类型的数组，它们是<em class="kf">存储数组</em>和<em class="kf">内存数组。</em></p><blockquote class="la lb lc"><p id="5807" class="ji jj kf jk b jl kg jn jo jp kh jr js ld ki jv jw le kj jz ka lf kk kd ke jh hm dt translated">想在Coinmonks上发表文章，请点击这里。 </p></blockquote><h2 id="38b4" class="ku kv ht bd lh li lj lk ll lm ln lo lp jt lq lr ls jx lt lu lv kb lw lx ly lz dt translated"><strong class="ak">存储阵列</strong>:</h2><p id="aee8" class="pw-post-body-paragraph ji jj ht jk b jl ma jn jo jp mb jr js jt mc jv jw jx md jz ka kb me kd ke jh hm dt translated">这些是在执行函数后存储在区块链中的数组，你可以像普通变量一样声明它们，而不需要像下面这样的契约:</p><figure class="kl km kn ko fq iu"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="ff34" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">其中<em class="kf">单元/布尔/地址</em>是变量类型，后面是<em class="kf"> [] </em>，然后是数组的名称，可以是任意名称。</p><p id="538d" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated"><strong class="jk hu">存储阵列的操作:</strong></p><p id="7c62" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">要向数组中添加新元素，我们需要引用数组并使用。push(value)，我们也可以通过引用像<code class="eh mh mi mj kq b">myArray[0] = ‘new value’;</code>这样的元素键来更新数组位置，我们也可以通过简单地使用<code class="eh mh mi mj kq b">myArray[0]</code>来获得特定的数组元素位置，其中<code class="eh mh mi mj kq b">0</code>是数组元素的索引或键</p><figure class="kl km kn ko fq iu"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="394d" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">我们还可以使用for循环来访问数组的元素，就像在javascript中访问数组一样(也在上面的代码片段中)。要删除数组中的一个元素，我们将使用<code class="eh mh mi mj kq b">delete myArray[1]</code>，其中1是数组键，请注意，这不会影响数组长度，只会将数组中第一个或第二个元素的索引处的数组值重置为数据类型的默认值。即如果是uint类型则为0，如果是bool类型则为false。当我们试图访问一个不存在的数组键时，我们会遇到一个错误。</p><h2 id="ecbf" class="ku kv ht bd lh li lj lk ll lm ln lo lp jt lq lr ls jx lt lu lv kb lw lx ly lz dt translated">内存阵列:</h2><p id="313a" class="pw-post-body-paragraph ji jj ht jk b jl ma jn jo jp mb jr js jt mc jv jw jx md jz ka kb me kd ke jh hm dt translated">调用函数后，这些数组不会存储到区块链中，您只能在如下所示的函数中声明它们:</p><figure class="kl km kn ko fq iu"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="2a42" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">其中<code class="eh mh mi mj kq b">unit[]</code>是变量的类型，<code class="eh mh mi mj kq b">memory</code>关键字声明它有一个内存数组，后跟一个可接受的名字，它必须等同于<code class="eh mh mi mj kq b">new unit[](10)</code>类型，其中<code class="eh mh mi mj kq b">unit[]</code>必须再次是变量类型，数组中的元素数在括号<code class="eh mh mi mj kq b">()</code>中。</p><p id="0f37" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated"><strong class="jk hu">存储器阵列的操作:</strong></p><p id="81ae" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">为了增加内存数组的值，我们不能使用<code class="eh mh mi mj kq b">.push()</code>方法，因为我们需要使用索引符号，比如<code class="eh mh mi mj kq b">newArray[0] = 1</code>、<code class="eh mh mi mj kq b">newArray[1] = 1</code>等。我们可以从内存阵列中读取值、更新值、删除值，就像存储阵列一样。</p><p id="e5ac" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated"><strong class="jk hu">将数组作为函数参数传递:</strong></p><p id="41dc" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">我们可以在solidity中传递一个数组作为函数参数，函数的可视性决定了数组名前的关键字应该是<code class="eh mh mi mj kq b">calldata</code>还是<code class="eh mh mi mj kq b">memory</code>。如果函数可见性是<code class="eh mh mi mj kq b">external</code>，我们使用<code class="eh mh mi mj kq b">calldata</code>，如果函数可见性是公共和内部的，我们使用<code class="eh mh mi mj kq b">memory</code>。请参见下面的示例:</p><figure class="kl km kn ko fq iu"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="821a" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">似乎我们已经在一个数组中涵盖了我们需要做的所有事情，那么<code class="eh mh mi mj kq b">mapping</code>怎么样？</p><blockquote class="ix"><p id="63ab" class="iy iz ht bd ja jb mk ml mm mn mo jh ek translated">Map类似于一个数组，其中包含一些相似的变量，使用键查找，这意味着您引用的是一个对象的值，而不是一个整数。</p></blockquote><p id="e2bf" class="pw-post-body-paragraph ji jj ht jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke jh hm dt translated">基本上，映射相当于其他编程语言中的字典或地图。这是从关键到价值的存储。标准数组是一个索引查找表，例如，如果数组中有10个元素，则索引为0-9，它看起来像下面的整数数组:</p><pre class="kl km kn ko fq kp kq kr ks aw kt dt"><span id="97ae" class="ku kv ht kq b fv kw kx l ky kz">[0] 555<br/>[1] 123<br/>...<br/>[8] 22<br/>[9] 5</span></pre><p id="a940" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated"><code class="eh mh mi mj kq b">map</code>的工作方式略有不同，最简单的描述方式是它使用键查找。因此，如果这是一个地址到整数的映射，那么它看起来会像这样:</p><pre class="kl km kn ko fq kp kq kr ks aw kt dt"><span id="281c" class="ku kv ht kq b fv kw kx l ky kz">[0x000000000000000A] 555<br/>[0x0000000000000004] 123<br/>....<br/>[0x0000000000000006] 22<br/>[0x0000000000000003] 6</span></pre><p id="0819" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">所以基本上，你引用的是一个对象的值，而不是一个整数。这些键也不必按顺序排列。它由两个主要部分组成:一个<code class="eh mh mi mj kq b">_KeyType</code>和一个<code class="eh mh mi mj kq b">_ValueType</code>；它们以下面的语法出现:</p><p id="9ea3" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated"><code class="eh mh mi mj kq b">mapping (_KeyType =&gt; _ValueType) mapName</code>。</p><p id="5311" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">把<code class="eh mh mi mj kq b">_KeyType</code>想象成你将通过一个函数返回所需值的键，或<code class="eh mh mi mj kq b">_ValueType</code>。默认情况下，一个映射最初是空的，所以一个新的<code class="eh mh mi mj kq b">_KeyType</code>首先需要被映射到一个<code class="eh mh mi mj kq b">_ValueType</code>。</p><p id="afbb" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">可能是</p><pre class="kl km kn ko fq kp kq kr ks aw kt dt"><span id="776d" class="ku kv ht kq b fv kw kx l ky kz">mapping(string =&gt; string) mapName;</span></pre><p id="5c9b" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">或者</p><pre class="kl km kn ko fq kp kq kr ks aw kt dt"><span id="ef29" class="ku kv ht kq b fv kw kx l ky kz">mapping(int =&gt; bool) mapName;</span></pre><p id="c400" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated"><strong class="jk hu">地图操作:</strong></p><p id="478a" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">我们可以在如下函数中操作地图:</p><figure class="kl km kn ko fq iu"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="c0bf" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">我们在这里给地图<code class="eh mh mi mj kq b">balances[msg.sender] = 100</code>赋值，把它等同于一个值。我们也通过<code class="eh mh mi mj kq b">balances[msg.sender]</code>读取该值，而不分配任何值。当我们使用一个不存在的键从map中读取一个值时，它将返回默认的数据值，用于在声明值类型时初始化值类型，这与javascript中的<code class="eh mh mi mj kq b">undefined</code>不同。</p><p id="664d" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated"><strong class="jk hu">分配一个数组作为贴图值:</strong></p><p id="0fa8" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">我们可以将一个数组作为值类型分配给一个映射，并且可以像访问下面这样的数组一样访问它们:</p><figure class="kl km kn ko fq iu"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="e6e0" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated"><strong class="jk hu">指定另一个地图作为地图值:</strong></p><p id="0a1a" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">我们还可以将另一个地图指定为地图值，并像访问地图一样访问它们，如下所示:</p><figure class="kl km kn ko fq iu"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="86f5" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">我们也可以将一个Struct赋值为map值类型，有时当您想要迭代一个map并在map上做其他事情时，我建议您在需要时查看下面的参考资料:</p><div class="mp mq fm fo mr ms"><a href="https://ethereum.stackexchange.com/questions/12145/how-to-loop-through-mapping-in-solidity" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">如何在solidity中循环通过贴图？</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">感谢为以太坊栈交换贡献一个答案！请务必回答问题。提供详细信息…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">ethereum.stackexchange.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng iv ms"/></div></div></a></div><div class="mp mq fm fo mr ms"><a href="https://stackoverflow.com/questions/48898355/soldity-iterate-through-address-mapping" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">Soldity:遍历地址映射</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">如果你想要更一般的东西，你可以使用一个库。我在下面附上了我正在使用的一个。它可能会使用…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">stackoverflow.com</p></div></div><div class="nb l"><div class="nh l nd ne nf nb ng iv ms"/></div></div></a></div><div class="mp mq fm fo mr ms"><a href="https://stackoverflow.com/questions/46466792/how-mapping-works-in-solidity-and-is-mapping-analogous-to-another-concept-in-ot" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">映射是如何在实体中工作的，映射是否类似于其他流行的…</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">感谢贡献一个堆栈溢出的答案！请务必回答问题。提供详细信息并分享…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">stackoverflow.com</p></div></div><div class="nb l"><div class="ni l nd ne nf nb ng iv ms"/></div></div></a></div><p id="6bb5" class="pw-post-body-paragraph ji jj ht jk b jl kg jn jo jp kh jr js jt ki jv jw jx kj jz ka kb kk kd ke jh hm dt translated">如果你走到这一步，你是可爱的，谢谢你的阅读。</p><blockquote class="ix"><p id="3c92" class="iy iz ht bd ja jb mk ml mm mn mo jh ek translated">加入Coinmonks <a class="ae lg" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae lg" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae lg" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="ku kv ht bd lh li nj lk ll lm nk lo lp jt nl lr ls jx nm lu lv kb nn lx ly lz dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="no np ht jk b jl ma jp mb jt nq jx nr kb ns jh nt nu nv nw dt translated"><a class="ae lg" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae lg" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated"><a class="ae lg" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">电网交易</a> | <a class="ae lg" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="f33b" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated"><a class="ae lg" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae lg" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated"><a class="ae lg" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">面向开发人员的最佳加密API</a></li><li id="f1dd" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated"><a class="ae lg" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae lg" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="b359" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated">最佳<a class="ae lg" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated">杠杆代币的终极指南</li><li id="95d1" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated"><a class="ae lg" href="https://coincodecap.com/best-vpns-for-crypto-trading" rel="noopener ugc nofollow" target="_blank">加密交易的最佳VPN</a></li><li id="918f" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated"><a class="ae lg" href="https://coincodecap.com/huobi-crypto-trading-signals" rel="noopener ugc nofollow" target="_blank">火币的加密交易信号</a> | <a class="ae lg" rel="noopener" href="/coinmonks/hitbtc-review-c5143c5d53c2"> HitBTC审查</a></li><li id="58f1" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated"><a class="ae lg" href="https://coincodecap.com/traderwagon-review" rel="noopener ugc nofollow" target="_blank"> TraderWagon回顾</a> | <a class="ae lg" href="https://coincodecap.com/kraken-vs-gemini-vs-bityard" rel="noopener ugc nofollow" target="_blank">北海巨妖vs双子座vs BitYard </a></li><li id="ad10" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated"><a class="ae lg" href="https://coincodecap.com/ftx-futures-trading" rel="noopener ugc nofollow" target="_blank">如何在FTX交易所交易期货</a></li><li id="71f4" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated"><a class="ae lg" href="https://coincodecap.com/okex-kucoin" rel="noopener ugc nofollow" target="_blank"> OKEx vs KuCoin </a> | <a class="ae lg" href="https://coincodecap.com/celsius-alternatives" rel="noopener ugc nofollow" target="_blank">摄氏替代品</a> | <a class="ae lg" href="https://coincodecap.com/buy-vechain" rel="noopener ugc nofollow" target="_blank">如何购买VeChain </a></li><li id="e6a8" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated"><a class="ae lg" href="https://coincodecap.com/3commas-vs-pionex-vs-cryptohopper" rel="noopener ugc nofollow" target="_blank">3 commas vs . Pionex vs . crypto hopper</a></li><li id="0539" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated"><a class="ae lg" href="https://coincodecap.com/cornix-trading-bot" rel="noopener ugc nofollow" target="_blank">如何使用Cornix交易机器人</a></li><li id="7ed0" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated"><a class="ae lg" href="https://coincodecap.com/bitget-review" rel="noopener ugc nofollow" target="_blank"> Bitget回顾</a> | <a class="ae lg" href="https://coincodecap.com/gemini-vs-blockfi" rel="noopener ugc nofollow" target="_blank">双子座vs BlockFi </a> cmd| <a class="ae lg" href="https://coincodecap.com/okex-futures-trading" rel="noopener ugc nofollow" target="_blank"> OKEx期货交易</a></li><li id="60b3" class="no np ht jk b jl nx jp ny jt nz jx oa kb ob jh nt nu nv nw dt translated"><a class="ae lg" href="https://coincodecap.com/buy-crypto-with-credit-card" rel="noopener ugc nofollow" target="_blank">用信用卡购买密码的10个最佳地点</a></li></ul></div></div>    
</body>
</html>