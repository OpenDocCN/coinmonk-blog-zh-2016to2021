<html>
<head>
<title>ZK Poker — A Simple ZK-SNARK Circuit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ZK扑克——一个简单的ZK-斯纳克电路</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/zk-poker-a-simple-zk-snark-circuit-8ec8d0c5ee52?source=collection_archive---------0-----------------------#2019-01-25">https://medium.com/coinmonks/zk-poker-a-simple-zk-snark-circuit-8ec8d0c5ee52?source=collection_archive---------0-----------------------#2019-01-25</a></blockquote><div><div class="eg hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fj fl is it iu iv ff fg paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="ff fg ir"><img src="../Images/993e0acec22a33f7718070bb1b356b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WcIi4QEeGRC0btw4nImRVQ.jpeg"/></div></div></figure><p id="ab6f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt ka translated">知识证明是我们去中心化的一个重要工具。当我们的平台存储全球透明的数据时，我们如何维护隐私？那些确实在‘链外’工作的扩展解决方案呢？这些解决方案需要通过链内证据来证实。零知识证明在解决这类问题时发挥了作用。</p><p id="a302" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当谈到为ZK电路编写代码时，我们有许多库可供选择。我在<a class="ae kj" href="https://iden3.io/" rel="noopener ugc nofollow" target="_blank">身份3 </a>的团队中发现了<strong class="je hv"> circom </strong>和<strong class="je hv"> snarkjs </strong>。对于这个领域的新手来说，这是一个很好的选择:电路很容易编码，并且可以用简单的命令运行，不需要特殊的环境。</p><p id="d832" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为学习<strong class="je hv"> circom </strong>和<strong class="je hv"> snarkjs </strong>提供的<a class="ae kj" href="https://iden3.io/blog/circom-and-snarkjs-tutorial2.html" rel="noopener ugc nofollow" target="_blank">教程</a>真的很有帮助。看到这个过程在你面前展开，我感到非常满意，这是一次很好的教育经历。本文旨在引导您超越该介绍性教程，并探索<strong class="je hv"> circom </strong>的其他一些方面。这是基于一个简单的，修改版本的扑克，其中零知识证明发挥了作用。</p><h1 id="67a7" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">ZK扑克</h1><p id="6ac0" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">ZK扑克的规则比其他种类的游戏简单一些。</p><ul class=""><li id="6512" class="ln lo hu je b jf jg jj jk jn lp jr lq jv lr jz ls lt lu lv dt translated">发给玩家5张牌，</li><li id="5976" class="ln lo hu je b jf lw jj lx jn ly jr lz jv ma jz ls lt lu lv dt translated">不允许换卡。</li><li id="2b02" class="ln lo hu je b jf lw jj lx jn ly jr lz jv ma jz ls lt lu lv dt translated">排名时，只有对子才算数。顺子、同花、满座等等都被忽略。</li><li id="78df" class="ln lo hu je b jf lw jj lx jn ly jr lz jv ma jz ls lt lu lv dt translated">玩家回合中的选项包括弃牌、观望或加注。</li><li id="0534" class="ln lo hu je b jf lw jj lx jn ly jr lz jv ma jz ls lt lu lv dt translated"><em class="mb">如果手中没有对子，玩家不得叫牌。</em></li></ul><p id="d84f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后一条规则——<em class="mb">不要虚张声势——</em>是由ZK证明强制执行的。投标人可以避免自己的牌被公开，同时仍然向其他玩家证明他们遵守了<em class="mb">不虚张声势</em>规则。我们将忽略游戏的机制(评估赢家，评估出价等)，而只关注将产生ZKP的电路。</p><h1 id="5581" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">该电路</h1><p id="fde0" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">电路的大致轮廓是:</p><ul class=""><li id="b6b4" class="ln lo hu je b jf jg jj jk jn lp jr lq jv lr jz ls lt lu lv dt translated">收集输入:手牌和玩家的叫牌选项</li><li id="29c2" class="ln lo hu je b jf lw jj lx jn ly jr lz jv ma jz ls lt lu lv dt translated">在手中寻找至少一对。</li><li id="07da" class="ln lo hu je b jf lw jj lx jn ly jr lz jv ma jz ls lt lu lv dt translated">评估叫牌的种类(弃牌或玩牌)</li><li id="b911" class="ln lo hu je b jf lw jj lx jn ly jr lz jv ma jz ls lt lu lv dt translated">设置一个约束来检查是否已经做出选择</li><li id="3663" class="ln lo hu je b jf lw jj lx jn ly jr lz jv ma jz ls lt lu lv dt translated">设置一个约束条件，以检查在给定一对的情况下选择是否有效。</li></ul><p id="41d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们一次浏览几行电路代码，看看在每一点上我们能学到什么。</p><h2 id="9c39" class="mc kl hu bd km md me mf kq mg mh mi ku jn mj mk ky jr ml mm lc jv mn mo lg mp dt translated">包含</h2><p id="d75f" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">它从一些<em class="mb">开始，包括</em>规格:</p><pre class="mq mr ms mt fr mu mv mw mx aw my dt"><span id="3028" class="mc kl hu mv b fw mz na l nb nc">include “../node_modules/circomlib/circuits/gates.circom”;<br/>include “../node_modules/circomlib/circuits/comparators.circom”;</span></pre><p id="759e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我应该指出，我的文件夹结构是:</p><p id="0ed9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">&lt;<em class="mb">项目根</em>&gt;\扑克</p><p id="3d2d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以我指定的包含路径适用于这个结构。您需要安装<strong class="je hv"> circomlib </strong>，这是入门<strong class="je hv"> circom </strong> / <strong class="je hv"> snarkjs </strong>教程的附加要求。在项目根文件夹中使用此命令:</p><pre class="mq mr ms mt fr mu mv mw mx aw my dt"><span id="2786" class="mc kl hu mv b fw mz na l nb nc">npm install --save circomlib</span></pre><h2 id="7aa3" class="mc kl hu bd km md me mf kq mg mh mi ku jn mj mk ky jr ml mm lc jv mn mo lg mp dt translated">电路模板</h2><pre class="mq mr ms mt fr mu mv mw mx aw my dt"><span id="2d70" class="mc kl hu mv b fw mz na l nb nc">template Poker() {</span><span id="c5b9" class="mc kl hu mv b fw nd na l nb nc">   ... circuit body ...</span><span id="75ad" class="mc kl hu mv b fw nd na l nb nc">}</span><span id="b0e4" class="mc kl hu mv b fw nd na l nb nc">component main = Poker();</span></pre><p id="c9cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其结构与介绍性教程中的基本相同。它是一个单独的类，入口点是声明的。又好又简单。</p><h2 id="5400" class="mc kl hu bd km md me mf kq mg mh mi ku jn mj mk ky jr ml mm lc jv mn mo lg mp dt translated">声明输入、输出和中间结果</h2><pre class="mq mr ms mt fr mu mv mw mx aw my dt"><span id="fda2" class="mc kl hu mv b fw mz na l nb nc">signal private input cards[5]; // Each 2..14<br/> signal input isSee; // 1 or 0<br/> signal input isFold; // 1 or 0<br/> signal input raise; // int<br/> signal output out; // 1 or 0<br/> <br/> // Intermediate results<br/> signal isBid;<br/> signal isRaise;<br/> signal hasChosen;</span></pre><p id="9284" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">牌的手被声明为一个数组:牌[5]。卡片只是用它们的面值来表示。西装被忽视了。Ace = 14国王= 13；女王= 12；杰克= 11；以此类推，下降到2。这只手是私人输入，表示它必须保密。</p><p id="9772" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，投标选择是公开的，因为它将向其他参与者公开。<em class="mb">折叠</em>和<em class="mb">参见</em>选项表示为布尔值。请注意，这不是(也不能)显式声明的。<strong class="je hv"> Circom </strong>基于javascript，因此变量类型是从数据中推断出来的。(我本应该向支持健壮数据类型的人发出触发警告。)第<em class="mb">次提升</em>输入为整数，为实际提升量。</p><p id="7c30" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">唯一的输出是<em class="mb">出</em>，有效时取1，无效时取0。</p><p id="c663" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">部分中间值声明为<em class="mb">信号。</em>我们以后会看到他们的行动。</p><h2 id="7ce1" class="mc kl hu bd km md me mf kq mg mh mi ku jn mj mk ky jr ml mm lc jv mn mo lg mp dt translated">数对子</h2><p id="9cda" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">这个代码块决定了手是否包含一对。请注意，代码很像普通的javascript。它不包含任何约束声明，也不包含任何信号操作。</p><p id="fb93" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里有一个对电路工作方式的见解。现实生活中的电路可能涉及一些预处理或中间评估，但要小心:这样的代码不属于正式证明的一部分。在设置时，仅烘焙约束条件，并通过验证/检验周期进行确认。一个不诚实的证明者可能会颠覆中间结果来伪造证人。我真的应该更新代码，以便将约束内置到对评估中。</p><p id="69b7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">照现在的情况来看，预处理步骤产生了一个单一的变量<em class="mb">num compars</em>。这将在后续步骤中使用。</p><p id="15a4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的逻辑是一个嵌套循环，依次考虑每张牌，并比较每张随后的牌，看是否有一对。一旦找到一对，我们就添加到<em class="mb">numparis</em>并退出。我们不感兴趣的是它是否真的是同类中的3对或4对，也不关心是否有第二对。出于我们将评估的约束的目的，所有这些可能性都被视为一对。还要注意的是<em class="mb"> break </em>似乎并没有在这个经过裁剪的javascript版本中实现。这段代码只是通过强制迭代器变高来触发退出。</p><pre class="mq mr ms mt fr mu mv mw mx aw my dt"><span id="fd04" class="mc kl hu mv b fw mz na l nb nc"> // Count pairs<br/> var numPairs = 0;<br/> for (var i=0; i&lt;4; i++) {<br/>    for (var j=i+1; j&lt;5; j++) {<br/>       if (cards[i] == cards[j]) {<br/>          numPairs++;<br/>          // break doesn’t work. Just force j and i to exit<br/>          j = 5;<br/>          i = 5;<br/>       }<br/>    }<br/> }</span></pre><h2 id="1b5f" class="mc kl hu bd km md me mf kq mg mh mi ku jn mj mk ky jr ml mm lc jv mn mo lg mp dt translated">限制</h2><p id="3aaa" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">入门教程包括信号操作:<code class="ei ne nf ng mv b">&lt;--, --&gt;, &lt;==, ==&gt;</code>和<code class="ei ne nf ng mv b">===</code>。这段代码中的新内容是<strong class="je hv">组件</strong>。组件是从<strong class="je hv"> circomlib </strong>库中导入的一个类的实例。注意这些调用的方式。组件的输入信号(名为a、b、in等。)使用信号运算符进行赋值。组件的输出信号(通常命名为<em class="mb"> out </em>)可以类似地使用。</p><p id="57d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里，我们使用布尔运算符的组件。查看<a class="ae kj" href="https://github.com/iden3/circomlib" rel="noopener ugc nofollow" target="_blank"> circomlib代码</a>看看有什么可用的。有一个全面的函数库，比如哈希运算、椭圆曲线运算等等。</p><p id="0eeb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们的约束被定义了。有一个约束来检查是否已经做出选择(盖牌、看牌或加注)。还有一种方法是检查是否有对子或者是否选择了弃牌。最后，将<em class="mb">输出</em>信号设置为1。</p><pre class="mq mr ms mt fr mu mv mw mx aw my dt"><span id="fe50" class="mc kl hu mv b fw mz na l nb nc"> // isRaise = (raise != 0)<br/> isRaise &lt;-- (raise &gt; 0);<br/> isBid &lt;-- (isRaise || isSee);</span><span id="8fa9" class="mc kl hu mv b fw nd na l nb nc"> // Constraint: Must be either bid or fold: isBid XOR isFold = 1<br/> hasChosen &lt;-- isBid + isFold — 2*isBid*isFold;<br/> hasChosen === 1;</span><span id="31e1" class="mc kl hu mv b fw nd na l nb nc"> // Constraint: numPairs must be &gt; 0 if isBid = 1<br/> var hasPairs = (numPairs &gt; 0);<br/> component not3 = NOT();<br/> not3.in &lt;-- isBid;</span><span id="3413" class="mc kl hu mv b fw nd na l nb nc"> component or2 = OR();<br/> or2.a &lt;-- hasPairs;<br/> or2.b &lt;-- not3.out;<br/> or2.out === 1;</span><span id="70ac" class="mc kl hu mv b fw nd na l nb nc"> out &lt;-- or2.out;</span></pre><h2 id="9e33" class="mc kl hu bd km md me mf kq mg mh mi ku jn mj mk ky jr ml mm lc jv mn mo lg mp dt translated">运行证明</h2><p id="2564" class="pw-post-body-paragraph jc jd hu je b jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz hn dt translated">初始步骤在入门教程中已经很熟悉了:</p><pre class="mq mr ms mt fr mu mv mw mx aw my dt"><span id="a93c" class="mc kl hu mv b fw mz na l nb nc">circom poker.circom -o poker.json<br/>snarkjs setup -o poker.json</span></pre><p id="87be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下一步需要提供输入。让我们来看一个示例输入文件(<em class="mb"> input.json </em>):</p><pre class="mq mr ms mt fr mu mv mw mx aw my dt"><span id="76ac" class="mc kl hu mv b fw mz na l nb nc">{“cards”: [8, 7, 4, 7, 13], “isFold”: 0, “isSee”: 0, “raise”: 10 }</span></pre><p id="571c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这手牌有一对，所以所有叫牌选项都可用。玩家选择加注10。我们希望这个输入作为有效的输入被传递。手保持私有，而其他输入是公共的。我已经掩饰了玩家进入假手的可能性。也许可以通过散列这手牌来处理，公开散列，从而允许在这手牌结束时进行确认。在现实生活中的零知识证明中，程序的所有这些方面，包括电路代码和设置，都需要事先得到证明者和验证者的同意。验证者将坚持消除任何允许证明者伪造他们的手牌的可能性。</p><p id="df86" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们来完成接下来的步骤，以生成证明:</p><pre class="mq mr ms mt fr mu mv mw mx aw my dt"><span id="063b" class="mc kl hu mv b fw mz na l nb nc">snarkjs calculatewitness -c poker.json<br/>snarkjs proof</span></pre><p id="c1aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">证明生成性能将在O(n)时间内运行，其中n =约束的数量。在这个例子中，我们受到的约束太少，无法看到这种情况发生。见<a class="ae kj" href="https://github.com/DalaiLlaama/snark-example/tree/master/factor-perftest" rel="noopener ugc nofollow" target="_blank">此处</a>有更多约束的测试。</p><p id="b9d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在由验证者运行的验证:</p><pre class="mq mr ms mt fr mu mv mw mx aw my dt"><span id="769c" class="mc kl hu mv b fw mz na l nb nc">PS C:\dev\snarks\poker&gt; snarkjs verify<br/>OK</span></pre><p id="d111" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">…而且很有效！</p><p id="2777" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了精心设计的ZK-斯纳克，信任链又回到了设置。为了从验证步骤中获得“OK”结果，证明者只能做一件事，那就是创建一个满足所有约束的见证。</p><p id="eddd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望你觉得这是有用的。</p><h2 id="2deb" class="mc kl hu bd km md me mf kq mg mh mi ku jn mj mk ky jr ml mm lc jv mn mo lg mp dt translated">完整的电路</h2><pre class="mq mr ms mt fr mu mv mw mx aw my dt"><span id="d653" class="mc kl hu mv b fw mz na l nb nc">include “../node_modules/circomlib/circuits/gates.circom”;<br/>include “../node_modules/circomlib/circuits/comparators.circom”;</span><span id="f898" class="mc kl hu mv b fw nd na l nb nc">template Poker() {<br/> signal private input cards[5]; // Each 2..14<br/> signal input isSee; // 1 or 0<br/> signal input raise; // int<br/> signal input isFold; // 1 or 0<br/> signal output out; // 1 or 0<br/> // Intermediate results<br/> signal isBid;<br/> signal isRaise;<br/> signal hasChosen;</span><span id="e491" class="mc kl hu mv b fw nd na l nb nc"> // Count pairs<br/> var numPairs = 0;<br/> for (var i=0; i&lt;4; i++) {<br/>    for (var j=i+1; j&lt;5; j++) {<br/>       if (cards[i] == cards[j]) {<br/>          numPairs++;<br/>          // break doesn’t work. Just force j and i to exit<br/>          j = 5;<br/>          i = 5;<br/>       }<br/>    }<br/> }<br/> // isRaise = (raise != 0)<br/> isRaise &lt;--(raise &gt; 0);<br/> isBid &lt;--(isRaise || isSee);</span><span id="9bcd" class="mc kl hu mv b fw nd na l nb nc">// Constraint: Must be either bid or fold: isBid XOR isFold = 1<br/> hasChosen &lt;--isBid + isFold — 2*isBid*isFold;<br/> hasChosen === 1;</span><span id="aa3d" class="mc kl hu mv b fw nd na l nb nc"> // Constraint: numPairs must be &gt; 0 if isBid = 1<br/> var hasPairs = (numPairs &gt; 0);<br/> component not3 = NOT();<br/> not3.in &lt;-- isBid;</span><span id="c233" class="mc kl hu mv b fw nd na l nb nc"> component or2 = OR();<br/> or2.a &lt;-- hasPairs;<br/> or2.b &lt;-- not3.out;<br/> or2.out === 1;</span><span id="d332" class="mc kl hu mv b fw nd na l nb nc"> out &lt;-- or2.out;<br/>}</span><span id="9a13" class="mc kl hu mv b fw nd na l nb nc">component main = Poker();</span></pre><p id="8ae3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在<a class="ae kj" href="https://github.com/DalaiLlaama/snark-example/tree/master/poker" rel="noopener ugc nofollow" target="_blank"> github </a>中找到代码</p><figure class="mq mr ms mt fr iv ff fg paragraph-image"><a href="https://cryptofi.co"><div class="ff fg nh"><img src="../Images/e7b1dbc6a532a697c6844fdf0f0bbd30.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*HrFLDXz92JavTZXjhmvU7g.png"/></div></a></figure><blockquote class="ni"><p id="e7a0" class="nj nk hu bd nl nm nn no np nq nr jz el translated"><a class="ae kj" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="nt nu nv nw nx iv ff fg paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="ff fg ns"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>