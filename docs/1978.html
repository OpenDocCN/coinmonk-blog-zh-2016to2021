<html>
<head>
<title>Hyperledger fabric cluster with multiple orderers and kafka</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有多个订购者和kafka的Hyperledger结构集群</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/hyperledger-fabric-setup-with-multiple-peers-and-orderers-with-kafka-542023787a6d?source=collection_archive---------0-----------------------#2019-01-16">https://medium.com/coinmonks/hyperledger-fabric-setup-with-multiple-peers-and-orderers-with-kafka-542023787a6d?source=collection_archive---------0-----------------------#2019-01-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="f76b" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">生产就绪hyperledger结构群</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/068eeeb0caaabb5d8c5433dc2c900321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLgarZ-iMHzxKeejrp1xHQ.png"/></div></div></figure><h1 id="c1ca" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">快乐分类器:)</h1><p id="b99e" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">当你进入hyperldger设置时，你会发现它根本不是一个令人愉快的设置。大量的配置、大量的部署文件，简直就是一场苦战:)。当我进入<code class="eh li lj lk ll b">kubernetes</code>时，我认为这是最难理解和配置的东西。但当我在使用hyperledger时，我觉得它是错误的:)。所以我想写一些关于hyperldger fabric设置的细节。</p><blockquote class="lm"><p id="9e9c" class="ln lo ht bd lp lq lr ls lt lu lv lh ek translated"><a class="ae lw" href="https://coincodecap.com" rel="noopener ugc nofollow" target="_blank">发现并回顾最佳区块链软件</a></p></blockquote><p id="1b71" class="pw-post-body-paragraph km kn ht ko b kp lx iu kr ks ly ix ku kv lz kx ky kz ma lb lc ld mb lf lg lh hm dt translated">我会写一系列关于hyperldger面料的帖子。我将这个博客系列命名为<code class="eh li lj lk ll b">Happyledger</code>:)以下是我将在<code class="eh li lj lk ll b">Happyledger</code>系列中涉及的话题。</p><ol class=""><li id="6501" class="mc md ht ko b kp me ks mf kv mg kz mh ld mi lh mj mk ml mm dt translated">在单节点环境中部署生产就绪的hyperldger集群</li><li id="5d3b" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">在多节点环境上部署生产就绪的hyperldger集群</li><li id="8730" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">在kubernetes上部署生产就绪的hyperldger集群</li><li id="8807" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">编写基于scala的hyperledger客户端应用程序</li><li id="f626" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">编写链代码并在本地环境上测试它们</li></ol><p id="e546" class="pw-post-body-paragraph km kn ht ko b kp me iu kr ks mf ix ku kv ms kx ky kz mt lb lc ld mu lf lg lh hm dt translated">在这篇文章中，我将介绍如何部署生产就绪hlf集群(具有多个对等体、多个订购者和kafka)。所有的部署文件和配置都在<a class="ae lw" href="https://gitlab.com/rahasak-labs/hlf-deployment" rel="noopener ugc nofollow" target="_blank">hlf-deployment</a>git lab repo。请检查存储库并跟随帖子。</p><h1 id="d630" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">服务结构</h1><p id="5f0e" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">我要建立的hyperledger网络包含以下服务。在本文中，这些服务将部署在一台主机上。在下一篇文章中，我将为多主机环境扩展这个设置。</p><ol class=""><li id="e258" class="mc md ht ko b kp me ks mf kv mg kz mh ld mi lh mj mk ml mm dt translated">一个组织(<code class="eh li lj lk ll b">org1.example.com</code></li><li id="a725" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">三个同行(<code class="eh li lj lk ll b">peer0.org1.example.com</code>、<code class="eh li lj lk ll b">peer1.org1.example.com</code>、<code class="eh li lj lk ll b">peer2.org1.example.com</code>)</li><li id="d009" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">一个认证机构(<code class="eh li lj lk ll b">ca.example.com</code>)</li><li id="b9ef" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">三个命令者(<code class="eh li lj lk ll b">orderer0.example.com</code>、<code class="eh li lj lk ll b">orderer1.example.com</code>、<code class="eh li lj lk ll b">orderer2.example.com</code>)</li><li id="23ba" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">三个动物园管理员节点(<code class="eh li lj lk ll b">zookeeper0</code>、<code class="eh li lj lk ll b">zookeeper1</code>、<code class="eh li lj lk ll b">zookeeper2</code>)</li><li id="bc60" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">四个卡夫卡节点(<code class="eh li lj lk ll b">kafka0</code>、<code class="eh li lj lk ll b">kafka1</code>、<code class="eh li lj lk ll b">kafka2</code>、<code class="eh li lj lk ll b">kafka3</code>)</li></ol><p id="d6ad" class="pw-post-body-paragraph km kn ht ko b kp me iu kr ks mf ix ku kv ms kx ky kz mt lb lc ld mu lf lg lh hm dt translated">以下是配置和部署集群的步骤。</p><h1 id="8ca2" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">1.生成配置</h1><h2 id="3e71" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">1.1.设置环境</h2><p id="cc9b" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">为了与hlf一起工作，我们需要有加密证书、genesis块和通道配置。为了生成它们，我们使用了<code class="eh li lj lk ll b">bin</code>目录上的脚本和<code class="eh li lj lk ll b">config</code>目录上的配置(<code class="eh li lj lk ll b">crypto-config.yaml</code>和<code class="eh li lj lk ll b">configtx.yaml</code>)。所以我们需要添加<code class="eh li lj lk ll b">bin</code>目录<code class="eh li lj lk ll b">$PATH</code>，并用<code class="eh li lj lk ll b">config</code>目录设置<code class="eh li lj lk ll b">FABRIC_CFG_PATH</code>(其中<code class="eh li lj lk ll b">configxtx.yaml</code>存在)。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><h2 id="ca29" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">1.2.生成加密材料</h2><p id="905c" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">现在我们需要为我们的<code class="eh li lj lk ll b">orderer</code>、<code class="eh li lj lk ll b">peers</code>和<code class="eh li lj lk ll b">ca</code>生成证书/密钥。我们使用<code class="eh li lj lk ll b">cryptogen</code>脚本来生成它们。该脚本将在<code class="eh li lj lk ll b">crypto</code>目录中生成加密材料。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><h2 id="a7a2" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">1.3.生成生成块</h2><p id="bc50" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">接下来，我们需要为订购者生成genesis块。可以通过使用<code class="eh li lj lk ll b">configtxgen</code>脚本来完成。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><h2 id="c656" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">1.4.生成通道配置事务</h2><p id="5004" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">现在我们需要使用<code class="eh li lj lk ll b">configtxgen</code>脚本生成通道配置事务。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><h2 id="77dc" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">1.5.生成锚点对等事务</h2><p id="fb62" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">最后，我们需要使用<code class="eh li lj lk ll b">configtxgen</code>脚本为每个组织生成锚定对等事务。在这个场景中，我们只有一个组织(<code class="eh li lj lk ll b">org1</code>)。如果有多个组织，我们需要为所有组织执行此步骤(例如<code class="eh li lj lk ll b">org1</code>、<code class="eh li lj lk ll b">org2</code>等)。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="8fbd" class="pw-post-body-paragraph km kn ht ko b kp me iu kr ks mf ix ku kv ms kx ky kz mt lb lc ld mu lf lg lh hm dt translated">现在我们的配置已经准备好了。下一件事是部署docker容器并运行服务。</p><h1 id="bd6b" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">2.部署服务</h1><h2 id="2a31" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">2.1.定义CA证书/密钥</h2><p id="fb2c" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">在启动服务之前，我们需要在<code class="eh li lj lk ll b">deployment/docker-compose-kafka.yaml</code>中定义CA证书和密钥。CA证书和密钥可以在<code class="eh li lj lk ll b">crypto-config/peerOrganizations/org1.example.com/ca</code>目录下找到。用<code class="eh li lj lk ll b">FABRIC_CA_SERVER_CA_CERTFILE</code>变量定义CA证书，用<code class="eh li lj lk ll b">FABRIC_CA_SERVER_CA_KEYFILE</code>变量定义CA密钥，如下所示。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><h2 id="c2f0" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">2.2.启动服务</h2><p id="7c9f" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">现在，我们可以部署与结构服务和cli服务相关的docker容器。在<code class="eh li lj lk ll b">docker-compose-kafka.yaml</code>上需要注意的一点是，在每个对等体中，它定义了<code class="eh li lj lk ll b">CORE_PEER_GOSSIP_BOOTSTRAP</code>地址。在光纤网络中，订购方仅向每个组织中的单个对等方交付数据块(<code class="eh li lj lk ll b">leader peer</code>)。通过进程调用<code class="eh li lj lk ll b">gossip</code>，网络中的其他对等体接收到该块。更多关于布料八卦的信息可以从<a class="ae lw" rel="noopener" href="/kokster/understanding-hyperledger-fabric-gossip-512a217d5d1e">这里</a>找到。</p><p id="474c" class="pw-post-body-paragraph km kn ht ko b kp me iu kr ks mf ix ku kv ms kx ky kz mt lb lc ld mu lf lg lh hm dt translated"><code class="eh li lj lk ll b">CORE_PEER_GOSSIP_BOOTSTRAP</code>用来在组织内部自举流言蜚语。如果您正在使用gossip，那么您通常会将您组织中的所有对等体配置为指向用于引导的一组初始对等体(您可以指定一个用空格分隔的对等体列表)。在这里，我使用了一个对等体作为八卦引导地址。对于<code class="eh li lj lk ll b">peer1</code>和<code class="eh li lj lk ll b">peer2</code>中的一个例子，我已经用<code class="eh li lj lk ll b">peer0</code>作为八卦自举。在<code class="eh li lj lk ll b">peer0</code>中，我使用了<code class="eh li lj lk ll b">peer1</code>作为八卦引导。</p><p id="07dd" class="pw-post-body-paragraph km kn ht ko b kp me iu kr ks mf ix ku kv ms kx ky kz mt lb lc ld mu lf lg lh hm dt translated">在结构中，初始跨组织引导信息通过<code class="eh li lj lk ll b">anchor peer</code>提供。这意味着，最初组织中的对等体将只知道锚对等体。要将一个对等体的八卦终点通知给不同组织中的其他对等体，您需要设置<code class="eh li lj lk ll b">CORE_PEER_GOSSIP_EXTERNALENDPOINT</code>。如果未设置此项，则有关对等方的端点信息将不会广播给其他组织中的对等方。如果简单地说，为了与其他组织的同事闲聊，你需要设置<code class="eh li lj lk ll b">CORE_PEER_GOSSIP_EXTERNALENDPOINT</code>。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="bad2" class="pw-post-body-paragraph km kn ht ko b kp me iu kr ks mf ix ku kv ms kx ky kz mt lb lc ld mu lf lg lh hm dt translated">它将开始跟踪你机器上的容器。</p><ol class=""><li id="a7fc" class="mc md ht ko b kp me ks mf kv mg kz mh ld mi lh mj mk ml mm dt translated">一个<code class="eh li lj lk ll b">ca</code>集装箱</li><li id="ba76" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">三个<code class="eh li lj lk ll b">orderer</code>容器</li><li id="929c" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">三个<code class="eh li lj lk ll b">peer</code>容器</li><li id="348f" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">三个<code class="eh li lj lk ll b">zookeeper</code>容器</li><li id="bbab" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">四个<code class="eh li lj lk ll b">kafka</code>容器</li><li id="1d9a" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated">一个<code class="eh li lj lk ll b">cli</code>集装箱</li></ol><h1 id="b9ae" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">3.设置频道</h1><h2 id="81b4" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">3.1.创建频道</h2><p id="49cc" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">首先，我们需要用以前创建的渠道配置事务创建一个渠道。在这里，我们连接到<code class="eh li lj lk ll b">peer0.org1.example.com</code> docker容器并在其上执行通道创建命令。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="2c4c" class="pw-post-body-paragraph km kn ht ko b kp me iu kr ks mf ix ku kv ms kx ky kz mt lb lc ld mu lf lg lh hm dt translated">接下来，我们需要将我们所有的同行(3个同行)加入这个渠道。</p><h2 id="ecfe" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">3.2.将对等机0加入频道</h2><p id="cd3c" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">现在我们正在连接到<code class="eh li lj lk ll b">peer0.org1.example.com</code> docker容器，并在其上执行channel join命令。这个命令将在<code class="eh li lj lk ll b">peer0.org1.example.com</code> docker容器中生成<code class="eh li lj lk ll b">mychannel.block</code>。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><h2 id="02a7" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">3.3.将mychannel.block复制到其他对等方</h2><p id="6cf0" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">如前所述，当加入<code class="eh li lj lk ll b">peero.org1.example.com</code>对等体时，它生成<code class="eh li lj lk ll b">mychannel.block</code>。我们需要将这个文件复制到<code class="eh li lj lk ll b">peer1.org1.example.com</code>和<code class="eh li lj lk ll b">peer2.org1.example.com</code>容器中。那么只有这些容器可以加入到通道中。我在这里使用<code class="eh li lj lk ll b">docker cp</code>命令来复制文件。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="a852" class="pw-post-body-paragraph km kn ht ko b kp me iu kr ks mf ix ku kv ms kx ky kz mt lb lc ld mu lf lg lh hm dt translated">我们可以使用<code class="eh li lj lk ll b">cli</code>容器来创建通道并将对等体加入到通道中。如果你正在使用它，你不需要复制文件和做上述步骤。请关注这篇文章了解更多信息。</p><h2 id="05e6" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">3.4.将对等1加入通道</h2><p id="26ec" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">现在我们可以将<code class="eh li lj lk ll b">peer1.org1.example.com</code>加入频道。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><h2 id="188f" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">3.5.将peer2加入通道</h2><p id="45f1" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">和以前一样，我可以把<code class="eh li lj lk ll b">peer2.org1.example.com</code>加入频道。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><h1 id="c343" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">4.设置链码</h1><p id="7ffd" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">现在我们需要在所有对等体上安装chaincode。链码位于<code class="eh li lj lk ll b">chaincode</code>目录中。我们使用cli容器来安装链码。Cli容器连接到其中一个对等点(<code class="eh li lj lk ll b">peer0</code>、<code class="eh li lj lk ll b">peer1</code>、<code class="eh li lj lk ll b">peer2</code>)来工作。使用cli容器中的<code class="eh li lj lk ll b">CORE_PEER_ADDRESS</code> env变量连接对等定义。当在对等体中安装链码时，hlf将启动一个单独的docker容器来运行链码。</p><h2 id="4fec" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">4.1.安装在peer0上</h2><p id="ca89" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">为了在<code class="eh li lj lk ll b">peer0</code>CLI容器上安装chaincode，我们需要连接到<code class="eh li lj lk ll b">peer0</code>。在<code class="eh li lj lk ll b">docker-compose-cli.yaml</code>中设置<code class="eh li lj lk ll b">CORE_PEER_ADDRESS=peer0.org1.example.com:7051</code>并重新创建cli。然后执行下面的命令。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><h2 id="0cec" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">4.2.安装在对等1上</h2><p id="0cce" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">设置<code class="eh li lj lk ll b">CORE_PEER_ADDRESS=peer1.org1.example.com:7051</code>并执行以下命令。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><h2 id="c0b4" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">4.3.安装在对等机2上</h2><p id="2ca4" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">设置<code class="eh li lj lk ll b">CORE_PEER_ADDRESS=peer2.org1.example.com:7051</code>并执行以下命令。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><h2 id="725f" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">4.5.实例化链代码</h2><p id="11b5" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">现在我们已经在所有的对等体上安装了chaincode。下一件事是实例化链码。链码仅在通道上实例化一次(不在对等体中)。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="2789" class="pw-post-body-paragraph km kn ht ko b kp me iu kr ks mf ix ku kv ms kx ky kz mt lb lc ld mu lf lg lh hm dt translated">现在我们的网络已经准备好了，chaincode已经启动并在每个对等体上运行。我们可以用运行链码进行交易。</p><h1 id="1a39" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">5.做交易</h1><p id="4dd5" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">hyperldger中有两种类型的事务，<code class="eh li lj lk ll b">invoke</code>和<code class="eh li lj lk ll b">query</code>。下面是进行交易的方法。</p><h2 id="3bfd" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">5.1.调用事务</h2><p id="7ecf" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">通过<code class="eh li lj lk ll b">invoke</code>，chaincode可以修改总账中变量的状态。每个<code class="eh li lj lk ll b">invoke</code>交易将被添加到ledge(它更新分类帐状态)。您可以连接到任何对等体并调用/查询事务。在这里，我连接到<code class="eh li lj lk ll b">peer0</code>(使用cli容器)并执行调用事务。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><h2 id="f63e" class="mv jv ht bd jw mw mx my ka mz na nb ke kv nc nd kg kz ne nf ki ld ng nh kk ni dt translated">5.2.查询交易</h2><p id="d194" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">通过<code class="eh li lj lk ll b">query</code>，chaincode将读取当前状态并发送给用户。此交易记录未添加到分类帐(它未更新分类帐状态)。现在我通过连接到<code class="eh li lj lk ll b">peer2</code>来执行查询</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nj nk l"/></div></figure><h1 id="576b" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">下一步是什么</h1><p id="2520" class="pw-post-body-paragraph km kn ht ko b kp kq iu kr ks kt ix ku kv kw kx ky kz la lb lc ld le lf lg lh hm dt translated">现在您已经在<code class="eh li lj lk ll b">single host environment</code>上用kafka设置了多对等、多订购者的hyperledger集群，并在其上执行交易。我们使用cli容器来执行事务。在下一篇文章中，我将展示如何在<code class="eh li lj lk ll b">multi host environment</code>中部署光纤网络。快乐阅读:)</p><h1 id="e41f" class="ju jv ht bd jw jx jy jz ka kb kc kd ke iz kf ja kg jc kh jd ki jf kj jg kk kl dt translated">参考</h1><ol class=""><li id="33a9" class="mc md ht ko b kp kq ks kt kv nl kz nm ld nn lh mj mk ml mm dt translated"><a class="ae lw" rel="noopener" href="/@mycoralhealth/start-your-own-hyperledger-blockchain-the-easy-way-5758cb4ed2d1">https://medium . com/@ my coral health/start-your-own-hyperledger-区块链-the-easy-way-5758cb4ed2d1 </a></li><li id="228e" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated"><a class="ae lw" rel="noopener" href="/@wahabjawed/extending-hyperledger-fabric-network-adding-a-new-peer-4f52f70a7217">https://medium . com/@ wahabjawed/extending-hyperledger-fabric-network-adding-a-new-peer-4f 52 f 70 a 7217</a></li><li id="2a1f" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated"><a class="ae lw" href="https://hyperledger-fabric.readthedocs.io/en/stable/install_instantiate.html" rel="noopener ugc nofollow" target="_blank">https://hyperledger-fabric . readthedocs . io/en/stable/install _ instantiate . html</a></li><li id="86cd" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated"><a class="ae lw" rel="noopener" href="/swlh/hyperledger-chapter-7-installing-hyperledger-fabric-89430e61b7bb">https://medium . com/swlh/hyperledger-chapter-7-installing-hyperledger-fabric-89430 e 61 b 7 bb</a></li><li id="4bc9" class="mc md ht ko b kp mn ks mo kv mp kz mq ld mr lh mj mk ml mm dt translated"><a class="ae lw" rel="noopener" href="/@itseranga/hyperledger-fabric-cluster-on-multiple-hosts-af093f00436">https://medium . com/@ itseranga/hyperledger-fabric-cluster-on-multi-hosts-af 093 f 00436</a></li></ol><blockquote class="lm"><p id="5fea" class="ln lo ht bd lp lq no np nq nr ns lh ek translated"><a class="ae lw" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="nu nv nw nx ny jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nt"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>