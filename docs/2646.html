<html>
<head>
<title>Formal Verification: Why and How</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">形式验证:为什么和如何</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/formal-verification-why-and-how-a104cd702c25?source=collection_archive---------1-----------------------#2020-01-11">https://medium.com/coinmonks/formal-verification-why-and-how-a104cd702c25?source=collection_archive---------1-----------------------#2020-01-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="979c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">智能合约的安全性仍然是以太坊生态系统中的一个关键挑战。事实上，因为一旦智能合约被利用，代码就是法律，就没有回头路了。这一点非常重要，尤其是如果合同是为了管理大量资本而构建的。我们都记得奇偶校验多签名钱包案件，其中3亿美元丢失，因为有人错误地杀死了主要组件之一(图书馆合同)。因此，调试智能合约肯定是一项非常重要的任务，应该非常小心地完成，因此我们需要一种方法来几乎100%地确保写在solidity智能合约中的内容按预期工作。</p><p id="6221" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">形式验证是这样发挥作用的:如果我们不使用人类自己的信念来测试我们的智能合约，而是使用数学生成的证据，会怎么样？</p><h1 id="b1bd" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">以下是方法:</h1><p id="50a6" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">形式验证的核心是K框架。</p><p id="9e32" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">K框架无非是:</p><blockquote class="kr ks kt"><p id="b09a" class="iq ir ku is b it iu iv iw ix iy iz ja kv jc jd je kw jg jh ji kx jk jl jm jn hm dt translated">一个基于重写的可执行语义框架，其中可以使用<em class="ht">配置</em>、<em class="ht">计算</em>和<em class="ht">规则</em>定义编程语言、类型系统和形式分析工具。</p></blockquote><p id="bb66" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">用更简单的话来说，K Framework是一种专门用于定义语义的语言。语义学描述了计算机程序的行为。例如，当我们说x的构造<strong class="is hu"> x++ </strong>是<em class="ku"> uint256 </em>时，意味着执行它的程序将总是把x的值增加1，除了一个值x = 2 ⁵⁶–1:</p><p id="60ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">多亏了K框架，我们可以为我们的智能合约编写规范。规范是我们的智能契约为了正确运行而必须遵循的一组规则。</p><p id="2c5d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我们的规范完成后，我们使用Z3定理证明器来验证它们。Z3是一个高性能的定理证明器，在这种情况下，它的工作是验证对于任何输入，一个确定的条件是否被遵守。如果我们正确地编写了我们的规范和智能合同，那么验证将会成功，证据将会被接受。</p><p id="6218" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">工作流程如下:</p><figure class="kz la lb lc fq ld fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff ky"><img src="../Images/11955bafbf007f5701b5153a3a428273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6RBEQKd4fTz4kvBkSnAUXA.png"/></div></div></figure><p id="9a6f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是我们怎样才能做到呢？</p><p id="c37b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了正式验证一个契约，你必须验证它的语义</p><p id="36a7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们考虑下面的合同:</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="040b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个契约允许执行<code class="eh lm ln lo lp b">set</code>来改变<code class="eh lm ln lo lp b">value</code>,然后通过将<code class="eh lm ln lo lp b">isSet</code>设置为真来锁定该信息，因此任何执行<code class="eh lm ln lo lp b">set</code>的尝试都会导致<code class="eh lm ln lo lp b">revert</code></p><p id="4974" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Solidity编译器将变量<code class="eh lm ln lo lp b">value</code>存储在槽0中，将变量<code class="eh lm ln lo lp b">isSet</code>存储在槽1中。如果我们想验证set是否按照预期的那样工作(只设置<code class="eh lm ln lo lp b">value</code>一次),我们必须验证:</p><ul class=""><li id="a436" class="lq lr ht is b it iu ix iy jb ls jf lt jj lu jn lv lw lx ly dt translated">如果对于任何可能的输入，将<code class="eh lm ln lo lp b">slot 1</code>设置为false，那么契约将按照预期修改<code class="eh lm ln lo lp b">value</code></li><li id="9836" class="lq lr ht is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly dt translated">如果<code class="eh lm ln lo lp b">slot 1</code>设置为真，对于任何可能的输入，合同总是恢复</li></ul><p id="8cfe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这听起来可能很难做到，但实际上非常简单，有多种选择可以开始正式验证您的智能合同，并且有一些工具允许我们在相对较高的级别执行正式验证。在本文中，我将使用<code class="eh lm ln lo lp b"><a class="ae me" href="https://github.com/dapphub/klab" rel="noopener ugc nofollow" target="_blank">klab</a></code>，这是DappHub提供的一种工具，它带有一种高级规范语言。</p><h1 id="51da" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated"><strong class="ak">让我们开始写代码</strong></h1><p id="0314" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">让我们这样设置我们的环境:</p><pre class="kz la lb lc fq mf lp mg mh aw mi dt"><span id="3190" class="mj jp ht lp b fv mk ml l mm mn">├── dapp<br/>│   ├── out<br/>│   │   └── OneWaySetter.sol.json<br/>│   └── src<br/>│       └── OneWaySetter.sol<br/>└── src<br/>    ├── prelude.smt2.md<br/>    ├── specification.act.md<br/>    └── storage.k.md</span></pre><p id="cd64" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">其中:</p><ul class=""><li id="c053" class="lq lr ht is b it iu ix iy jb ls jf lt jj lu jn lv lw lx ly dt translated">json是一个文件，它告诉Klab在哪里以及应该看什么。</li><li id="88a3" class="lq lr ht is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly dt translated">OneWaySetter.sol是我们的Solidity Smart合约</li><li id="c218" class="lq lr ht is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly dt translated">OneWaySetter.sol.json是我们编译的Solidity智能合约(为了编译您的智能合约，请打开您的终端，转到dapp文件夹<code class="eh lm ln lo lp b">cd dapp</code>并键入</li></ul><pre class="kz la lb lc fq mf lp mg mh aw mi dt"><span id="0e46" class="mj jp ht lp b fv mk ml l mm mn">solc --combined-json=abi,bin,bin-runtime,srcmap,srcmap-runtime,ast src/OneWaySetter.sol &gt; out/OneWaySetter.sol.json</span></pre><ul class=""><li id="0f42" class="lq lr ht is b it iu ix iy jb ls jf lt jj lu jn lv lw lx ly dt translated">specification.act.md是包含我们的规范的地方(Klab高级语言)</li><li id="3e5f" class="lq lr ht is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly dt translated">storage.k.md是用来用一些K语言(低级语义)来完成我们的规范(高级语义)。在这种情况下，该文件将为空。</li><li id="24ab" class="lq lr ht is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly dt translated">prelude.smt2.md是使用Z3定理证明器的低级输入格式编写的，包含我们形式验证的前奏。前奏是可能与我们的智能合同相关的所有事实的集合。</li></ul><h1 id="02df" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated"><strong class="ak">我们的规范。</strong></h1><p id="778f" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">首先，让我们进行配置:</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="078d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于这个例子，我们没有使用任何需要storage.k.md的东西，所以我们将保持它为空。</p><p id="0270" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是我们的前奏(prelude.smt2.md):</p><figure class="kz la lb lc fq ld"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="c546" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，让我们定义我们的规范(specification.act.md):</p><pre class="kz la lb lc fq mf lp mg mh aw mi dt"><span id="ddda" class="mj jp ht lp b fv mk ml l mm mn">```act<br/>behaviour set of OneWaySetter</span><span id="df4a" class="mj jp ht lp b fv mo ml l mm mn">interface set(uint256 Value)</span><span id="ca49" class="mj jp ht lp b fv mo ml l mm mn">types</span><span id="514c" class="mj jp ht lp b fv mo ml l mm mn">   IsSet : bool</span><span id="ed89" class="mj jp ht lp b fv mo ml l mm mn">storage</span><span id="a26c" class="mj jp ht lp b fv mo ml l mm mn">   0 |-&gt; _ =&gt; Value</span><span id="1442" class="mj jp ht lp b fv mo ml l mm mn">   1 |-&gt; IsSet =&gt; 1</span><span id="ea16" class="mj jp ht lp b fv mo ml l mm mn">iff</span><span id="b3ac" class="mj jp ht lp b fv mo ml l mm mn">   VCallValue == 0</span><span id="bc2f" class="mj jp ht lp b fv mo ml l mm mn">   IsSet == 0</span><span id="47eb" class="mj jp ht lp b fv mo ml l mm mn">```</span></pre><p id="3d1a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">我们在这里做的是:</strong></p><p id="1f05" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">类型序言:</p><ul class=""><li id="3a25" class="lq lr ht is b it iu ix iy jb ls jf lt jj lu jn lv lw lx ly dt translated">在<code class="eh lm ln lo lp b">types preamble</code>中，我们声明了规范所需的变量</li></ul><p id="76a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">存储序言:</p><ul class=""><li id="7f72" class="lq lr ht is b it iu ix iy jb ls jf lt jj lu jn lv lw lx ly dt translated">在<code class="eh lm ln lo lp b">storage preamble</code>中，我们指定任何改变契约状态的东西，并将声明的值赋给<code class="eh lm ln lo lp b">types premble</code></li><li id="9919" class="lq lr ht is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly dt translated">设置IsSet表示执行<code class="eh lm ln lo lp b">set</code>前<code class="eh lm ln lo lp b">slot 1</code>的值，并指定执行<code class="eh lm ln lo lp b">slot 1</code>后其值变为1。</li><li id="fd06" class="lq lr ht is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly dt translated">指定<code class="eh lm ln lo lp b">slot 0</code>改变作为输入给定的值。</li></ul><p id="bfad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Iff序言:</p><ul class=""><li id="f012" class="lq lr ht is b it iu ix iy jb ls jf lt jj lu jn lv lw lx ly dt translated">在<code class="eh lm ln lo lp b">iff preamble</code>中我们确定了不引起一个<code class="eh lm ln lo lp b">revert</code>所需的条件</li><li id="9d83" class="lq lr ht is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly dt translated">我们说不应该有以太网随事务<code class="eh lm ln lo lp b">VCallValue == 0</code>一起发送，并且<code class="eh lm ln lo lp b">slot 1</code>必须在<code class="eh lm ln lo lp b">set</code>执行之前<code class="eh lm ln lo lp b">0</code>。</li></ul><p id="1e3b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们可以运行<code class="eh lm ln lo lp b">klab prove-all</code>和:</p><pre class="kz la lb lc fq mf lp mg mh aw mi dt"><span id="5660" class="mj jp ht lp b fv mk ml l mm mn">Doing initial spec build, this may take a while...<br/>[ 'src/OneWaySetter.sol' ]<br/>[ 'src/OneWaySetter.sol' ]<br/>3410388bb51887b48311a94d8f63166ba1ad88dd98b988ece7a0e734622b2801 OneWaySetter__exhaustiveness<br/>51c13b8610bad9cbfd805e52e169b639870b3a24860c265cd82fb2aa6e7a3775 OneWaySetter_set_pass_rough<br/>d9f27f2f84fec78589a6c8bd390748a396250bfe5b0195f0bde7daa0f8eda667 OneWaySetter_set_fail_rough<br/>STARTING proof batch 1.<br/>Academic tradition requires you to cite works you base your article on.<br/>When using programs that use GNU Parallel to process data for publication<br/>please cite:</span><span id="5eee" class="mj jp ht lp b fv mo ml l mm mn">O. Tange (2011): GNU Parallel - The Command-Line Power Tool,<br/>  ;login: The USENIX Magazine, February 2011:42-47.</span><span id="e3f3" class="mj jp ht lp b fv mo ml l mm mn">This helps funding further development; AND IT WON'T COST YOU A CENT.<br/>If you pay 10000 EUR you should feel free to use GNU Parallel without citing.</span><span id="0581" class="mj jp ht lp b fv mo ml l mm mn">To silence this citation notice: run 'parallel --citation'.</span><span id="403e" class="mj jp ht lp b fv mo ml l mm mn">2020-01-11T11:09:38.620Z<br/>2020-01-11T11:09:38.624Z<br/>Using evm-semantics from /home/giulio/klab/evm-semantics/<br/>Proof STARTING: d9f27f2f84fec78589a6c8bd390748a396250bfe5b0195f0bde7daa0f8eda667.k [OneWaySetter_set_fail_rough] (with state logging)<br/>Using evm-semantics from /home/giulio/klab/evm-semantics/<br/>Proof STARTING: 51c13b8610bad9cbfd805e52e169b639870b3a24860c265cd82fb2aa6e7a3775.k [OneWaySetter_set_pass_rough] (with state logging)<br/>Proof <strong class="lp hu">ACCEPT</strong>: 51c13b8610bad9cbfd805e52e169b639870b3a24860c265cd82fb2aa6e7a3775.k [OneWaySetter_set_pass_rough] (with state logging)<br/>2020-01-11T11:10:51.968Z<br/>/home/giulio/klab/bin/klab: riga 2: /home/giulio/klab/bin/../libexec/klab-gas-analyser: File o directory non esistente<br/>2020-01-11T11:10:52.293Z<br/>Using evm-semantics from /home/giulio/klab/evm-semantics/<br/>Proof STARTING: 3410388bb51887b48311a94d8f63166ba1ad88dd98b988ece7a0e734622b2801.k [OneWaySetter__exhaustiveness] (with state logging)<br/>Proof <strong class="lp hu">ACCEPT</strong>: d9f27f2f84fec78589a6c8bd390748a396250bfe5b0195f0bde7daa0f8eda667.k [OneWaySetter_set_fail_rough] (with state logging)<br/>2020-01-11T11:10:54.822Z<br/>Proof <strong class="lp hu">ACCEPT</strong>: 3410388bb51887b48311a94d8f63166ba1ad88dd98b988ece7a0e734622b2801.k [OneWaySetter__exhaustiveness] (with state logging)<br/>2020-01-11T11:11:48.006Z</span></pre><p id="cba4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">正如我们可以看到的，我们的正式验证是成功的，而且做起来非常简单。这告诉我们什么:</p><p id="7076" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">犯错误对人类来说很容易，但对数学来说却不容易，所以我们应该尽可能地信任数学，而不是一个开发者。如果不这样，就会像平价多sig钱包一样结束。</p><p id="7edf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">~干杯</p><div class="mp mq fm fo mr ms"><a href="https://github.com/Giulio2002" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd hu fv z el mx eo ep my er et hs dt translated">Giulio2002 -概述</h2><div class="mz l"><p class="bd b gc z el mx eo ep my er et ek translated">github.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf li ms"/></div></div></a></div><figure class="kz la lb lc fq ld fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff ng"><img src="../Images/0ac758d7122ac1c2860cc155daf2c5d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*sfsGJhpBk0-yxJur_WuGoQ.png"/></div></a></figure><blockquote class="nh"><p id="9d3f" class="ni nj ht bd nk nl nm nn no np nq jn ek translated"><a class="ae me" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ns nt nu nv nw ld fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nr"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>