<html>
<head>
<title>What’s Eating Up My CPU?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么在消耗我的CPU？</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/whats-eating-up-my-cpu-6dde55896f4f?source=collection_archive---------0-----------------------#2018-07-05">https://medium.com/coinmonks/whats-eating-up-my-cpu-6dde55896f4f?source=collection_archive---------0-----------------------#2018-07-05</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="1e7a" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated"><em class="ji">诊断隐藏的流程——阿里巴巴技术团队的最佳实践</em></h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/0a69ce8f59f74e27e34f326c1f50dd06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u45OVuqmS39L59T9F_x-2g.jpeg"/></div></div></figure><p id="93ac" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated"><em class="kr">阿里巴巴技术团队的高级售后工程师罗正在帮助诊断客户的CPU问题，突然问题自行消失了。现在，他讲述了当他开始深入挖掘时所发现的东西，以及为什么向表面以外看是有好处的。</em></p><h1 id="9400" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">“嘿，阿里巴巴，是什么在吞噬我的中央处理器？”</h1><p id="9ad0" class="pw-post-body-paragraph jv jw ht jx b jy lk iu ka kb ll ix kd ke lm kg kh ki ln kk kl km lo ko kp kq hm dt translated">作为一名为阿里巴巴产品的客户提供解决方案的工程师，我最近接待了一位客户，他带来了一个需要我帮助解决的问题。这位客户对计算非常熟悉，因此意识到有什么东西正在消耗他的CPU，但无法确定可能是什么导致了问题。在讲述诊断问题时所学内容之前，请允许我根据客户看到的内容介绍我们的场景。</p><p id="7bb7" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">如下图第三行所示，CPU使用情况的主要统计数据由八个指标组成:用户CPU时间(us)、系统CPU时间(sy)、用户正常CPU时间(ni)、空闲CPU时间(id)、io等待CPU时间(wa)、处理硬件中断的CPU时间(hi)、处理软件中断的CPU时间(si)和窃取时间(st)。理论上，这八个指标的和应该是100%。id和wa一起反映了CPU的空闲时间。它们的总和越小，中央处理器就越忙。对于该客户的服务器，id和wa记录的总和值为0，这意味着CPU使用率为100%，ni占CPU使用率的大部分。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff lp"><img src="../Images/aeb1f79fa404c18810d6b4013ffe6fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*pR0H5g828LGbcLe4zpKVOg.png"/></div></figure><p id="2b86" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">除了第三行显示的总体CPU使用率统计数据外，顶部还按CPU列中的进程计数CPU使用率。所讨论的服务器有16个内核，因此每个进程(多线程)的CPU使用率都可能超过100%。同时，所有进程的CPU使用率总和不能超过1600%(每个内核的平均使用率返回到100%)。</p><p id="ab92" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">这个问题最有趣的部分是，787个进程正在运行，而CPU使用率总和远远低于最大值1600%。</p><h1 id="0561" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">问题消失了……</h1><p id="f422" class="pw-post-body-paragraph jv jw ht jx b jy lk iu ka kb ll ix kd ke lm kg kh ki ln kk kl km lo ko kp kq hm dt translated">正当我准备深入研究这个问题时，服务器重启了。不知何故，重启后，问题就消失了！然而，客户的问题并没有。他坚持要我解释为什么服务器的CPU已经满负荷了。</p><p id="43f9" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">值得注意的是，我们经常把一个未知问题的原因归结于它的“黑箱”。这就是为什么许多客户在努力解释发生的事情时，会将注意力转向虚拟或物理层。在最坏的情况下，客户甚至可能会怀疑阿里巴巴云是否提供了一个受损的产品。</p><p id="a6c2" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">为了满足客户的需求，作为一名技术支持工程师，我的第一反应是弄清楚ni是如何计算的，因为问题本身并没有再次出现，让我去剖析。我希望通过提供一些理论知识，客户能够理解并接受度量标准ni与物理机无关，而纯粹与虚拟机的内部行为相关。</p><h1 id="6d19" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">检查Ni度量</h1><p id="63ba" class="pw-post-body-paragraph jv jw ht jx b jy lk iu ka kb ll ix kd ke lm kg kh ki ln kk kl km lo ko kp kq hm dt translated">在本文的第一部分，我提到ni代表具有高nice值的用户空间进程所占用的CPU。但是什么是好的价值呢？简单地说，nice值代表分配给使用CPU资源的进程的优先级。每个过程都有一个定义好的值。nice值越高，进程使用CPU资源的优先级越低，这导致进程获得的CPU时间越短。度量ni说明了nice值大于0的所有用户空间进程的CPU使用率。</p><p id="bb10" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">通常，0是进程的默认nice值。当进程需要更高的优先级时，我们降低它们的nice值，其他进程可以接受更低的优先级。例如，运行编译器gcc来编译内核可能需要几个小时。作为回应，我们可以增加这个gcc过程的nice值。</p><p id="aa12" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">Linux将真正用户模式下的CPU使用划分为两个部分来显示进程:ni表示nice值大于0的进程，us表示nice值小于0的进程。</p><h1 id="e03c" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">为自己做一个高镍测试</h1><p id="1b94" class="pw-post-body-paragraph jv jw ht jx b jy lk iu ka kb ll ix kd ke lm kg kh ki ln kk kl km lo ko kp kq hm dt translated">让我们通过一个简单的测试来验证上述理论。我们可以使用“for”语句创建一个简单的无限循环程序，并使用objdump查看编译好的汇编程序。这种装配很简单。前两行准备堆栈指针，第三行初始化位于堆栈rbp-0x4的变量，变量在第四和第五行中重复递增。</p><blockquote class="lq lr ls"><p id="d529" class="jv jw kr jx b jy jz iu ka kb kc ix kd lt kf kg kh lu kj kk kl lv kn ko kp kq hm dt translated"><em class="ht">000000000004004 ed&lt;main&gt;:<br/>4004 ed:55 push % RBP<br/>4004 ee:48 89 E5 mov % RSP，% RBP<br/>4004 f1:C7 45 fc 00 00 00 00 movl $ 0x 0，-0x4(%rbp)<br/>4004 F8:83 45 fc 01 addl $ 0x 1，-0x 4(% RBP)</em></p></blockquote><p id="0d10" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">一旦循环进程被分派给一个CPU，该CPU就会满载。下图显示了两种显示，左图显示了nice为0时的场景，右图显示了nice为19时的场景。可以在图表下的NI列中看到流程的良好值。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lw"><img src="../Images/40950d0354e4b2dc7a287ad2d7f552ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3C5dheWnnr8cfR7ARYDdrw.png"/></div></div></figure><p id="0f98" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">CPU使用率是如何划分并分配给每个内核的，如下所示:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lx"><img src="../Images/5b5bd8e2b5e14dacb98f583b3971149c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Ej5sMr_Ik9HnGWV_vgCtg.png"/></div></div></figure><p id="3eae" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">我想帮助客户理解与ni相关的理论和我的结论——这个问题与物理机器无关。顾客并不买账。他强调，在启动机器之前，他已经检查了所有进程的CPU使用情况，并确信没有任何异常迹象。超过100个java进程正在运行，所有进程的CPU使用率都非常低。</p><h1 id="3974" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">输入时间序列魔法</h1><p id="13d4" class="pw-post-body-paragraph jv jw ht jx b jy lk iu ka kb ll ix kd ke lm kg kh ki ln kk kl km lo ko kp kq hm dt translated">在处理系统挂起问题时，我们偶尔会迷失自己。想象一下，一个复杂的系统有成千上万个进程同时运行。如果系统挂起，许多进程就会纠缠在一起。然后，我们需要找出这些过程之间的依赖关系，并确定哪些是麻烦制造者，哪些是受害者。这主要依赖于理清进程如何持有和等待资源。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/7ef5c30fd19a361516b315b1a3d90175.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/1*UIzmobE_E3kH8lwY8KFZcw.gif"/></div></figure><p id="691c" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">可悲的是，这种分析方法不能解决所有问题。为了节省管理成本，系统有选择地维护一小部分资源持有和等待关系。</p><p id="38bc" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">当这种方法不起作用时，另一种方法就会出现。我们可以分析流程进入等待状态的时间顺序。这就是所谓的“时序魔术”。</p><h1 id="f0c1" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">一个采矿项目发现</h1><p id="2b5e" class="pw-post-body-paragraph jv jw ht jx b jy lk iu ka kb ll ix kd ke lm kg kh ki ln kk kl km lo ko kp kq hm dt translated">走投无路的情况下(问题无法再次显示)，时序魔术给了我一条出路。首先，我检查了sar日志，确认CPU负载在4月29日上午6:40达到了100%。我浏览了几乎所有的系统文件，发现了两个配置文件，这两个文件是在一分钟前的早上6:39创建的。存储这两个文件的目录包含两个可疑的库文件:libxmr-stak-c.a和libxmr-stak-backend.a。在网上快速搜索后发现，它们是用于开采Monero硬币的程序。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lz"><img src="../Images/de67af42f44634896450a1affa950b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DC5rhx8JCLBCpkCEYpkv7Q.png"/></div></div></figure><p id="4809" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">当我与客户分享我的发现时，他仍然不相信这两个采矿项目是问题的原因。他重复说，他已经检查了每个进程，并且已经意识到任何可能导致CPU异常运行的可疑情况。顾客的坚持迫使我们进一步调查。</p><h1 id="a8e7" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">隐藏Linux进程的三种常用方法</h1><p id="e633" class="pw-post-body-paragraph jv jw ht jx b jy lk iu ka kb ll ix kd ke lm kg kh ki ln kk kl km lo ko kp kq hm dt translated">假设客户是对的，那么问题是隐藏Linux进程的哪些方法会阻止它们的细节在ps或top输出中显示？有三种常见的方法适用于此:在内核中创建进程时将pid改为0，直接修改ps和top代码，以及在libc中挂钩readdir和opendir函数。(为了实现ps和top，使用了readdir、opendir等libc函数直接访问/proc文件及其子目录。)</p><p id="62b1" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">我突然回忆起另一个同样在早上6:39修改过的文件——LD . so . preload，我第一次检查这个文件的时候，发现里面写了libjdk.so。当时，我想当然地认为这个文件是java相关的，并忽略了它。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ma"><img src="../Images/013c13bbfe7a7958c4eca0f21a2b88b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNnnhe8x_7XDK6zoZhW_Jg.png"/></div></div></figure><h1 id="83e8" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">根源出现了！</h1><p id="87f1" class="pw-post-body-paragraph jv jw ht jx b jy lk iu ka kb ll ix kd ke lm kg kh ki ln kk kl km lo ko kp kq hm dt translated">从那时起，整个问题就开始解开了。早上6:39，有人给ld.so.preload添加了一个库文件，后来启动时，所有进程都是先加载这个库，再加载其他的。结果呢？每当调用外部函数的进程需要在另一个库中实现时，该函数也会在这个预加载的库中实现。这意味着动态链接首先必须使用预加载库中定义的函数。</p><p id="8c28" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">自从我最后一次使用这种方法来编写opengl轨迹，已经过去了很多年。切换到Windows后，这些Linux技能几乎从我的记忆中消失了。使用ld.so.preload，我们可以制作过滤工具，实现过滤、跟踪、参数检查等功能。为了确保进程正常运行，同名过滤函数将最终调用原始函数。</p><p id="c493" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">验证结果显示，所有重新启动的系统进程都将libjdk文件加载到了它们的地址空间中。下图显示了/proc/ <pid> /maps在读取bash时的输出:</pid></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mb"><img src="../Images/88060e3cd1c016cd7fb6c669f6850c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzNo_3vueEgTMVRk4tWfqg.png"/></div></div></figure><h1 id="8a94" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">使用libjdk的小技巧</h1><p id="6a73" class="pw-post-body-paragraph jv jw ht jx b jy lk iu ka kb ll ix kd ke lm kg kh ki ln kk kl km lo ko kp kq hm dt translated">libjdk库与java无关。它很小，很容易拆卸和详细检查，以至于我们甚至可以通过阅读汇编代码来理解它的行为。正如所怀疑的，该库挂接了readdir等函数，并过滤了读取/proc文件夹的结果。因此，客户仅在运行top或ps时收到过滤后的结果。经过一些考虑，我认为不值得深入研究libjdk编译代码。相反，我们可以考虑库文件中包含的字符串，这些字符串可以大致告诉我们库是做什么的。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/fb3cb0d10cb757d57e4444467ef19960.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*-VA1FJHH2PgcBRt2X9QawQ.png"/></div></figure><h1 id="7f5a" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">回顾案例</h1><p id="4547" class="pw-post-body-paragraph jv jw ht jx b jy lk iu ka kb ll ix kd ke lm kg kh ki ln kk kl km lo ko kp kq hm dt translated">最终，这个问题本质上并不具有挑战性，通过收集核心转储，可能在几分钟内就可以解决。然而，问题的突然消失和客户坚持要一个解释，使得寻找问题根源的努力变得非常复杂。</p><p id="3436" class="pw-post-body-paragraph jv jw ht jx b jy jz iu ka kb kc ix kd ke kf kg kh ki kj kk kl km kn ko kp kq hm dt translated">另一方面，如果问题没有消失，我永远不会探索其他方法，如果没有客户的坚持，我也不会把汇编代码当作问题的证据。在这方面，值得承认的是，客户的苛刻要求可能有助于我们提高服务能力。</p></div><div class="ab cl md me hb mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hm hn ho hp hq"><h1 id="9e50" class="ks kt ht bd ku kv mk kx ky kz ml lb lc iz mm ja le jc mn jd lg jf mo jg li lj dt translated">阿里巴巴科技</h1><p id="01dc" class="pw-post-body-paragraph jv jw ht jx b jy lk iu ka kb ll ix kd ke lm kg kh ki ln kk kl km lo ko kp kq hm dt translated">关于阿里巴巴最新技术的第一手深度资料→脸书:<a class="ae mp" href="http://www.facebook.com/AlibabaTechnology" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hu">【阿里巴巴科技】</strong> </a>。Twitter:<a class="ae mp" href="https://twitter.com/AliTech2017" rel="noopener ugc nofollow" target="_blank"><strong class="jx hu">“AlibabaTech”</strong></a>。</p></div></div>    
</body>
</html>