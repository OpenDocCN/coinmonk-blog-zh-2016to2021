<html>
<head>
<title>Formal Verification of Ethereum 2.0 Deposit Contract (Part I)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊2.0存款合同的形式化验证(上)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/formal-verification-of-ethereum-2-0-deposit-contract-part-i-931ffe80b9c1?source=collection_archive---------0-----------------------#2019-06-12">https://medium.com/coinmonks/formal-verification-of-ethereum-2-0-deposit-contract-part-i-931ffe80b9c1?source=collection_archive---------0-----------------------#2019-06-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="51a1" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">在Daejun公园旁边</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/3f2f849977bfbd5075d3f04fec4d492e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0sWh4y0CQsStOmd_.png"/></div></div></figure><p id="8fc4" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">以太坊2.0来了。而且放心，会正式指定验证的！</p><p id="af8b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/blob/master/specs/core/0_beacon-chain.md" rel="noopener ugc nofollow" target="_blank">以太坊2.0 </a>是一种新的分片PoS协议，在其早期阶段(称为阶段0)，与现有的PoW链(称为Eth1链)并行存在。虽然Eth1链由矿工驱动，但新的PoS链(称为信标链)将由验证器驱动。</p><p id="2e5b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在信标链中，验证器的作用是创建(称为建议)和验证(称为证明)新块。信标链的共识协议建立在重要的小工具之上，<a class="ae kq" href="https://arxiv.org/abs/1710.09437" rel="noopener ugc nofollow" target="_blank">卡斯珀·FFG</a>用于最终确定区块，<a class="ae kq" href="https://vitalik.ca/general/2018/12/05/cbc_casper.html" rel="noopener ugc nofollow" target="_blank">LMD·幽灵</a>用于叉子选择规则，RANDAO用于生成随机数。(查看<a class="ae kq" href="https://runtimeverification.com/blog/runtime-verification-completes-formal-verification-of-ethereum-casper-protocol/" rel="noopener ugc nofollow" target="_blank">我们之前的约定</a>卡斯珀FFG 的<a class="ae kq" href="https://github.com/runtimeverification/casper-proofs" rel="noopener ugc nofollow" target="_blank">形式验证和冉道</a>的<a class="ae kq" href="https://github.com/runtimeverification/rdao-smc" rel="noopener ugc nofollow" target="_blank">统计验证。2)共识协议保证(在某些温和的假设下)期望的安全性和活性属性，只要大多数验证者在创建和验证新块时忠实地遵循该协议。</a></p><p id="a83a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">验证器集是动态的，这意味着新的验证器可以加入，现有的验证器可以随着时间的推移退出。要成为(新的)验证者，需要通过向指定的智能合约(称为存款合约)发送交易(通过Eth1网络)来存款一定量的以太作为“股份”。存款合同记录存款的历史，信标链检索该历史以维护动态验证器集。(不过，这种存款过程将在稍后阶段发生变化。)</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff kr"><img src="../Images/04cd4d75f3ee50fa1f207039d8c69c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UBrNAR5H-dznoQnG.jpg"/></div></div></figure><h2 id="e334" class="ks kt ht bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated">存款合同</h2><p id="a585" class="pw-post-body-paragraph ju jv ht jw b jx ln iu jz ka lo ix kc kd lp kf kg kh lq kj kk kl lr kn ko kp hm dt translated">用<a class="ae kq" href="https://vyper.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> Vyper </a>编写的<a class="ae kq" href="https://github.com/ethereum/deposit_contract" rel="noopener ugc nofollow" target="_blank">存款契约</a>采用<a class="ae kq" href="https://en.wikipedia.org/wiki/Merkle_tree" rel="noopener ugc nofollow" target="_blank"> Merkle树</a>数据结构来有效地存储存款历史，其中每当接收到新存款时，该树就被动态<em class="ls">更新(即，从左到右依次递增地添加叶节点)。这里，合同中使用的Merkle树预计非常大。事实上，高度为<code class="eh lt lu lv lw b">32</code>的Merkle树可以存储多达<code class="eh lt lu lv lw b">2^32</code>个存款，在合同的当前版本<a class="ae kq" href="https://github.com/ethereum/eth2.0-specs/blob/12293a91b4333bf419eea7e6b897dd5f988f9e23/deposit_contract/contracts/validator_registration.v.py" rel="noopener ugc nofollow" target="_blank">中实现。由于Merkle树的大小是巨大的，所以每次接收到新的存放时重建整个树是不实际的。</a></em></p><p id="0609" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">为了减少时间和空间需求，从而节省天然气成本，合同实施了<a class="ae kq" href="https://github.com/ethereum/research/blob/master/beacon_chain_impl/progressive_merkle_tree.py" rel="noopener ugc nofollow" target="_blank">增量Merkle树算法</a>。增量算法享受<code class="eh lt lu lv lw b">O(h)</code>时间和空间复杂度来重建(更准确地说，计算根)高度<code class="eh lt lu lv lw b">h</code>的Merkle树，而朴素算法将需要<code class="eh lt lu lv lw b">O(2^h)</code>时间或空间复杂度。具体来说，该算法维护两个长度为<code class="eh lt lu lv lw b">h</code>的数组，更新树的每次重构只需要计算从新叶(即新存放处)开始到根的链，其中链的计算只需要这两个数组，从而在树的高度上实现<em class="ls">线性</em>时间和空间复杂度。</p><p id="f797" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">然而，有效的增量算法导致存款合同实现不直观，并使得确保其正确性变得不容易。考虑到存款合同的极端重要性，需要进行正式验证，这是最终保证合同正确性的唯一已知方法。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/d6a66fcaccc8a50153b870318c408feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*39dHIA4TWpEkt8n-.png"/></div></div></figure><h2 id="691b" class="ks kt ht bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated">增量Merkle树算法的形式化验证</h2><p id="d078" class="pw-post-body-paragraph ju jv ht jw b jx ln iu jz ka lo ix kc kd lp kf kg kh lq kj kk kl lr kn ko kp hm dt translated"><a class="ae kq" href="https://blog.ethereum.org/2019/05/21/ethereum-foundation-spring-2019-update/" rel="noopener ugc nofollow" target="_blank">在以太坊基金会</a>的资助下，我们在<a class="ae kq" href="https://runtimeverification.com/" rel="noopener ugc nofollow" target="_blank">运行时验证</a>开始了存款合同的正式验证，今天我们很高兴地宣布我们实现了第一个里程碑<em class="ls">增量Merkle树算法的正式验证</em>。</p><p id="da22" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">具体来说，我们首先<em class="ls">严格形式化</em>增量Merkle树算法。然后，我们提取了存款合同中使用的算法的伪代码实现，并且<em class="ls">正式证明了</em>伪代码实现的正确性。这意味着存款契约在源代码级别是正确的，也就是说，它将正确地增量计算Merkle树根，前提是没有由Vyper编译器引入的编译时错误或EVM字节码级别的功能正确性错误。(事实上，我们的下一个任务是确保这种字节码级的正确性。)查看<a class="ae kq" href="https://github.com/runtimeverification/verified-smart-contracts/blob/master/deposit/formal-incremental-merkle-tree-algorithm.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="jw hu"> <em class="ls">我们的报告</em> </strong> </a>进行算法的形式化和正确性证明。</p><h2 id="68a0" class="ks kt ht bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated">调查的结果</h2><p id="dc6c" class="pw-post-body-paragraph ju jv ht jw b jx ln iu jz ka lo ix kc kd lp kf kg kh lq kj kk kl lr kn ko kp hm dt translated">在我们的形式化和正确性证明工作过程中，我们发现了存款合同的一个<a class="ae kq" href="https://github.com/ethereum/deposit_contract/issues/26" rel="noopener ugc nofollow" target="_blank">微妙的bug </a>，在最新版本中已经<a class="ae kq" href="https://github.com/ethereum/deposit_contract/commit/e357f3797bd37116564fb1e41605864d6fffb45f" rel="noopener ugc nofollow" target="_blank">修复了</a>，以及几个<a class="ae kq" href="https://github.com/ethereum/deposit_contract/issues?q=is%3Aissue+author%3Adaejunpark" rel="noopener ugc nofollow" target="_blank">重构建议</a>，可以提高代码可读性，降低汽油成本。</p><p id="d844" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">让我们详细说明这个微妙的错误。在我们被要求验证的契约版本中，当Merkle树的所有叶节点都填充了存款数据时，就会触发错误，在这种情况下，契约(具体来说就是<code class="eh lt lu lv lw b">get_deposit_root</code>函数)会错误地计算树的根哈希，从而返回零根哈希(即空Merkle树的根哈希)，而不管叶节点的内容如何。例如，假设我们有一棵高度为2的Merkle树，它有四个叶节点，每个叶节点都填充了某些存款数据，分别为<code class="eh lt lu lv lw b">D1</code>、<code class="eh lt lu lv lw b">D2</code>、<code class="eh lt lu lv lw b">D3</code>和<code class="eh lt lu lv lw b">D4</code>。然后，当树的正确根哈希是<code class="eh lt lu lv lw b">hash(hash(D1,D2),hash(D3,D4))</code>时，<code class="eh lt lu lv lw b">get_deposit_root</code>函数返回<code class="eh lt lu lv lw b">hash(hash(0,0),hash(0,0))</code>，这是不正确的。</p><p id="fb73" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">由于代码的复杂逻辑，在不大量重写代码的情况下正确修复这个bug并不容易，因此我们建议了一个简单的解决方法，强制永远不填充最后一个叶节点，即最多只接受<code class="eh lt lu lv lw b">2^h - 1</code>存放，其中<code class="eh lt lu lv lw b">h</code>是树的高度。然而，我们注意到，在当前设置中触发这种错误行为是不可行的，因为最小存放量是1个乙醚，并且乙醚的总供应量小于比<code class="eh lt lu lv lw b">2^32</code>小得多的<code class="eh lt lu lv lw b">130M</code>，因此填充高度为32的树的所有叶子是不可行的。然而，正如我们所建议的，这个bug已经被契约开发者<a class="ae kq" href="https://github.com/ethereum/deposit_contract/commit/e357f3797bd37116564fb1e41605864d6fffb45f" rel="noopener ugc nofollow" target="_blank">修复了</a>,因为契约可能被用在其他设置中，在这些设置中，可能会触发bug行为并且有可能被利用。更多详情请参见此处的<a class="ae kq" href="https://github.com/ethereum/deposit_contract/issues/26" rel="noopener ugc nofollow" target="_blank">和</a>。</p><p id="2788" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们还想指出，这个bug很难捕捉。事实上，我们最初认为原始代码是正确的，直到我们写下正确性定理的正式证明时陷入困境。我们最初试图证明正确性的失败导致我们确定了一个定理成立所需的缺失前提(即，一个附加的先决条件)，从中我们可以找到上面的错误行为场景，并提出了<a class="ae kq" href="https://github.com/ethereum/deposit_contract/commit/e357f3797bd37116564fb1e41605864d6fffb45f#diff-0b42db22e6da8cca278c93c388249c68R78" rel="noopener ugc nofollow" target="_blank">错误修复</a>。这一经验再次证实了形式验证的重要性。虽然我们并不“幸运”地在审查代码时发现了这个bug，这是所有传统安全审计员都会做的，但是正式的验证过程<em class="ls">彻底地</em>引导甚至“迫使”我们最终找到了它。</p><h2 id="2963" class="ks kt ht bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated">下一步是什么？</h2><p id="ba79" class="pw-post-body-paragraph ju jv ht jw b jx ln iu jz ka lo ix kc kd lp kf kg kh lq kj kk kl lr kn ko kp hm dt translated">因此，现在我们确信增量Merkle树算法及其存款契约的实现在源代码级别是正确的，我们正在前进，正式验证其编译的EVM字节码的行为是否符合预期。我们将在故事的第二部分完成后发布。敬请期待！</p><h2 id="c0de" class="ks kt ht bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated">感谢</h2><p id="61b0" class="pw-post-body-paragraph ju jv ht jw b jx ln iu jz ka lo ix kc kd lp kf kg kh lq kj kk kl lr kn ko kp hm dt translated">我们要衷心感谢以太坊基金会对这项工作的资助，以及丹尼·瑞安、卡尔·贝克休斯和林暐的讨论和及时解决报告的问题。</p><blockquote class="lx"><p id="628c" class="ly lz ht bd ma mb mc md me mf mg kp ek translated"><a class="ae kq" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="mi mj mk ml mm jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff mh"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div><div class="ab cl mn mo hb mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hm hn ho hp hq"><p id="1084" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><em class="ls">原载于2019年6月12日</em><a class="ae kq" href="https://runtimeverification.com/blog/formal-verification-of-ethereum-2-0-deposit-contract-part-1/" rel="noopener ugc nofollow" target="_blank"><em class="ls">https://runtimeverification.com</em></a><em class="ls">。</em></p></div></div>    
</body>
</html>