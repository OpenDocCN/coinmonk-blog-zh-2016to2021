<html>
<head>
<title>Understanding Maps in Ligo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Ligo中的地图</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/understanding-maps-in-ligo-c271c768e424?source=collection_archive---------0-----------------------#2020-03-25">https://medium.com/coinmonks/understanding-maps-in-ligo-c271c768e424?source=collection_archive---------0-----------------------#2020-03-25</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="e2fe" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">在Ligo中创建和操作地图和大地图</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/248542f74485a4089d76cdaf09153f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iK2V04YQ5EcIToxyR3WsbQ.jpeg"/></div></div></figure><p id="7968" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><em class="kq">这篇文章也可以在我的IPFS博客</em> <a class="ae kr" href="https://decentradev.netlify.com/#/post/ligo-lesson-4" rel="noopener ugc nofollow" target="_blank"> <em class="kq">上看到。</em></a></p><p id="52e2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">区块链就是以一种分散的方式在线保存数据。您不希望在区块链上保存大量数据(因为这很昂贵)，但是您希望保存正确的数据，希望数据组织有序，并且希望能够快速访问这些数据。</p><p id="8cd4" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">因此，在Ligo中编写智能合同时，地图将是您最好的盟友之一。如果你来自固体，你已经知道什么是地图，你只需要学习新的语法。如果你是<a class="ae kr" href="https://blog.coincodecap.com/tag/smart-contact/" rel="noopener ugc nofollow" target="_blank">智能合约</a>开发的新手，地图是一种非常容易理解的数据结构。</p><p id="6022" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在本教程中，我们将看到什么是地图和大地图，如何创建它们，更新它们和删除它们的内容。照例我会用Ligo的理智味。</p><h1 id="471f" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">什么是地图？</h1><p id="9d2f" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">世界上很多孩子都有一本降临节日历来计算圣诞节前的天数。降临节日历的原理非常简单:一个印有数字的扁平盒子，每个数字代表一天。每个数字后面都有一块巧克力🍫</p><p id="06b3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">地图就像一个降临节日历:它们是一个大盒子，你可以用任何可比较的类型(整数、地址、字符串等)代替数字。，<a class="ae kr" href="https://michelson.nomadic-labs.com/#types" rel="noopener ugc nofollow" target="_blank">参见表格中的第一列作为参考</a>)称为<strong class="jw hu">键</strong>除了巧克力，你几乎可以拥有任何你想要的东西，称为<strong class="jw hu">值</strong>。这个键/值对被称为<strong class="jw hu">绑定</strong>。就像降临节日历一样，键的类型在整个地图中必须相同，值的类型也必须相同。例如，你可以有一个<code class="eh lp lq lr ls b">integer/string</code>或<code class="eh lp lq lr ls b">address/record</code>绑定，而不是像日历中那样有一个<code class="eh lp lq lr ls b">number/chocolate</code>绑定。如果要检索值，只需要知道它的键就可以找到它。</p><h1 id="c9b1" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">大地图呢？</h1><p id="a435" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">与区块链上的任何其他操作一样，检索与地图中的键相关联的值需要耗费大量的时间。如果你要加载一个有数千或数百万绑定的地图，它会变得非常昂贵和缓慢。这时候就可以用大地图了。大地图只是为您考虑了比例问题的地图。把它们用于你的下一个<a class="ae kr" href="https://blog.coincodecap.com/tag/dapps/" rel="noopener ugc nofollow" target="_blank"> dapp </a>来搭载你的数百万潜在用户😊</p><h1 id="23ac" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">创建地图</h1><p id="f1f2" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">当需要在代码中使用映射时，有两种方法可以用来声明映射:</p><ol class=""><li id="ed67" class="lt lu ht jw b jx jy ka kb kd lv kh lw kl lx kp ly lz ma mb dt translated">你可以先声明类型，然后声明变量。</li><li id="4a57" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp ly lz ma mb dt translated">您可以将两个声明连接成一个。</li></ol><p id="ed22" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">让我们看看它是什么样子的:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mh"><img src="../Images/5ef1c7a29ec87be37c2e0c3032d67042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5TN6kJKL8QKQn0hpYN9ZdQ.png"/></div></div></figure><p id="b044" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这两种方法的主要区别在于，在第二种情况下，您不能为另一个变量重用该类型。在这两种情况下，声明一个映射都非常简单:使用<strong class="jw hu"> map </strong>关键字，在括号之间，首先放置键的类型、一个逗号和值的类型。然后，您可以创建一个空地图:</p><pre class="jj jk jl jm fq mi ls mj mk aw ml dt"><span id="b9c5" class="mm kt ht ls b fv mn mo l mp mq">let new_map: map (address, string) = <strong class="ls hu">Map.empty</strong></span></pre><p id="0fef" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">或者您可以在地图中初始化一些绑定:</p><pre class="jj jk jl jm fq mi ls mj mk aw ml dt"><span id="0441" class="mm kt ht ls b fv mn mo l mp mq">let new_map: map (address, string) = <strong class="ls hu">Map.literal</strong>([<br/>  ("tz1...": address, "John"),<br/>  ("tz1...": address, "Jane")<br/>]);</span></pre><blockquote class="mr ms mt"><p id="255b" class="ju jv kq jw b jx jy iu jz ka kb ix kc mu ke kf kg mv ki kj kk mw km kn ko kp hm dt translated">📝初始化映射时，请注意绑定的语法。</p></blockquote><h1 id="f6b7" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">访问地图绑定</h1><p id="7e28" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">一旦您的地图被数以千计的绑定填充，您希望能够找到其中的一个。该操作将需要<strong class="jw hu"> Map.find_opt </strong>函数。顾名思义，当你使用一个键来查找相关的值时，这个函数将返回一个可选值，这就是为什么它非常适合与模式匹配一起使用！</p><p id="4f03" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">语法如下:<code class="eh lp lq lr ls b">Map.find_opt(the_key_to_find, the_map)</code>。</p><p id="4332" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在让我们使用模式匹配来获取值:</p><pre class="jj jk jl jm fq mi ls mj mk aw ml dt"><span id="fb8f" class="mm kt ht ls b fv mn mo l mp mq">switch (<strong class="ls hu">Map.find_opt</strong>("tz1...", new_map)){<br/>  | <strong class="ls hu">None</strong> =&gt; failwith("No match found!");<br/>  | <strong class="ls hu">Some (name)</strong> =&gt; /* We get here the value we found! */<br/>}</span></pre><p id="4297" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><strong class="jw hu"> Map.find_opt </strong>函数将返回一个可选值，它可以接受两个可能的值:如果没有找到匹配，则为<strong class="jw hu"> None </strong>，如果找到匹配，则为<strong class="jw hu"> Some </strong>以及与映射中的键相关联的<em class="kq">值</em>。</p><p id="a834" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这是一个非常强大的设计！不像JavaScript这样的语言，它不会返回一个未定义的值，也不会使你的dapp崩溃。如果没有找到值，您可以抛出一个错误或做其他事情。与Solidity等其他智能合约语言不同，默认情况下，所有键都不存在，搜索键不会返回默认值。模式匹配让你远离意想不到的错误！</p><h1 id="0df9" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">更新地图</h1><p id="28dd" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">现在让我们填充我们的地图！使用<strong class="jw hu"> Map.add </strong>向映射添加新的绑定非常简单。该函数有3个参数:新的键、新的关联值和要添加它们的映射:</p><pre class="jj jk jl jm fq mi ls mj mk aw ml dt"><span id="affe" class="mm kt ht ls b fv mn mo l mp mq">let mymap = <strong class="ls hu">Map.add</strong>((<em class="kq">"tz1..."</em>: address), "<em class="kq">Kevin</em>", <em class="kq">new_map</em>);</span></pre><p id="4e71" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果您想更改与映射中某个绑定的键相关联的值，该怎么办？这其实是一个很简单的操作！您可以使用接受3个参数的<code class="eh lp lq lr ls b">Map.update</code>:您想要更新的键，新值和映射的可选参数，例如:</p><pre class="jj jk jl jm fq mi ls mj mk aw ml dt"><span id="4e8f" class="mm kt ht ls b fv mn mo l mp mq">let mymap = <strong class="ls hu">Map.update</strong>((<em class="kq">"tz1..."</em>: address), <em class="kq">Some("Bob")</em>, <em class="kq">new_map</em>);</span></pre><p id="f488" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这里的可选性非常重要，因为你也可以使用<strong class="jw hu"> None </strong>来移除绑定，就像这样:</p><pre class="jj jk jl jm fq mi ls mj mk aw ml dt"><span id="2398" class="mm kt ht ls b fv mn mo l mp mq">let mymap = <strong class="ls hu">Map.update</strong>((<em class="kq">"tz1..."</em>: address), <em class="kq">None(string)</em>, <em class="kq">new_map</em>);</span></pre><p id="c733" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果您想删除一个绑定，您也可以使用<strong class="jw hu"> Map.remove </strong>函数，它有两个参数:要删除的键和Map:</p><pre class="jj jk jl jm fq mi ls mj mk aw ml dt"><span id="ce1d" class="mm kt ht ls b fv mn mo l mp mq">let mymap = <strong class="ls hu">Map.remove</strong>((<em class="kq">"tz1..."</em>: address), <em class="kq">new_map</em>);</span></pre><h1 id="3004" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">地图上的迭代</h1><p id="c878" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">在某些情况下，您可能希望遍历地图，要么更新它的一些值，要么使用这些值产生一些副作用。Ligo提供了3个不同的函数，你可以根据你想要的结果来使用。</p><h2 id="bed0" class="mm kt ht bd ku mx my mz ky na nb nc lc kd nd ne le kh nf ng lg kl nh ni li nj dt translated">Map.iter()</h2><p id="ab3b" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">假设我们有一个地图，其中包含与用户拥有的令牌数量相关联的用户地址。我们想遍历列表，检查它们是否都有10个或更多的令牌。这是我们将要做的:</p><pre class="jj jk jl jm fq mi ls mj mk aw ml dt"><span id="096c" class="mm kt ht ls b fv mn mo l mp mq"><em class="kq">[declared earlier =&gt; let new_map = map (address, nat)]</em></span><span id="901d" class="mm kt ht ls b fv nk mo l mp mq">let check_tokens = <br/>  ((<strong class="ls hu">key</strong>, <strong class="ls hu">value</strong>): (address, nat)) =&gt; <strong class="ls hu">assert(value &gt; 10n)</strong>;</span><span id="b55d" class="mm kt ht ls b fv nk mo l mp mq"><strong class="ls hu">Map.iter</strong>(check_tokens, new_map);</span></pre><p id="cb60" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果一切顺利，Map.iter返回一个类型为<em class="kq"> unit </em>的值。<br/>如果其中一个值不大于或等于10，<em class="kq">断言</em>功能将抛出错误，操作将停止。</p><h2 id="4c33" class="mm kt ht bd ku mx my mz ky na nb nc lc kd nd ne le kh nf ng lg kl nh ni li nj dt translated">Map.map()</h2><p id="d05c" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">现在让我们继续上面的例子，想象我们想要空投，给地图上的所有用户10个免费的代币。我们可以使用<strong class="jw hu"> Map.map </strong>函数轻松实现。它有两个参数:应用于映射的函数(接收键/值对并返回新值)和映射。然后，它返回更新后的地图:</p><pre class="jj jk jl jm fq mi ls mj mk aw ml dt"><span id="e232" class="mm kt ht ls b fv mn mo l mp mq">let <em class="kq">free_tokens</em> = ((<strong class="ls hu">key</strong>, <strong class="ls hu">value</strong>): (address, nat)) =&gt; <strong class="ls hu">value + 10n</strong>;</span><span id="d93f" class="mm kt ht ls b fv nk mo l mp mq"><strong class="ls hu">Map.map</strong>(<em class="kq">free_tokens</em>, new_map);</span></pre><h2 id="c494" class="mm kt ht bd ku mx my mz ky na nb nc lc kd nd ne le kh nf ng lg kl nh ni li nj dt translated">Map.fold()</h2><p id="12fe" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">现在，假设我们想知道我们的用户总共拥有多少令牌。如果您想要检索地图中的所有值，并通过以某种方式将它们相加或分组来使用它们，您可以使用<strong class="jw hu"> Map.fold </strong>。这个函数有3个参数:累加函数、映射和累加器的初始值。accumulating函数接收两个参数:第一个是累加器的当前值，第二个是包含映射的当前键(在第一个位置)和值(在第二个位置)的元组:</p><pre class="jj jk jl jm fq mi ls mj mk aw ml dt"><span id="c7c6" class="mm kt ht ls b fv mn mo l mp mq"><em class="kq">[will return the total amount of token as an integer]</em></span><span id="1dff" class="mm kt ht ls b fv nk mo l mp mq">let <em class="kq">accumulate</em> = <br/>  ((<strong class="ls hu">accumulator</strong>, <strong class="ls hu">binding</strong>): (int, (string, int))): int =&gt; <br/>    <strong class="ls hu">accumulator</strong> + <strong class="ls hu">binding[1]</strong>;</span><span id="0376" class="mm kt ht ls b fv nk mo l mp mq"><strong class="ls hu">Map.fold</strong>(<em class="kq">accumulate</em>, <em class="kq">new_map</em>, <em class="kq">0</em>);</span></pre><h1 id="aac3" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">附加功能</h1><p id="ee32" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">最后，让我们介绍一些有用的函数，让您可以获得一些关于地图的信息:</p><ul class=""><li id="be7e" class="lt lu ht jw b jx jy ka kb kd lv kh lw kl lx kp nl lz ma mb dt translated"><code class="eh lp lq lr ls b">Map.size(my_map: map(key, value))</code> = &gt; <strong class="jw hu"> Map.size </strong>以地图为参数，以<em class="kq"> nat </em>的形式返回地图的大小。</li><li id="8184" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><code class="eh lp lq lr ls b">Map.mem(my_map: map(key, value))</code> = &gt;</li></ul><h1 id="39b6" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">大地图呢？</h1><p id="6d02" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">除了<code class="eh lp lq lr ls b">size</code>和<code class="eh lp lq lr ls b">mem</code>之外，我们刚刚看到的所有用于地图的功能也适用于大地图。你唯一需要做的就是用<strong class="jw hu"> Big_map </strong>替换<strong class="jw hu"> Map </strong>关键字。</p><h1 id="dd88" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">概述</h1><p id="4bd8" class="pw-post-body-paragraph ju jv ht jw b jx lk iu jz ka ll ix kc kd lm kf kg kh ln kj kk kl lo kn ko kp hm dt translated">在Ligo中，地图是一种非常有用的数据结构，用于存储和检索数据，这就是为什么知道如何操作它们以释放它们的全部能量是非常重要的。记住一些与地图相关的重要词汇:</p><ul class=""><li id="d983" class="lt lu ht jw b jx jy ka kb kd lv kh lw kl lx kp nl lz ma mb dt translated"><strong class="jw hu"> KEY </strong> = &gt;映射的左侧，您将使用它来访问值，通常是字符串、地址或数字类型(int、nat)。</li><li id="b1d2" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><strong class="jw hu"> VALUE </strong> = &gt;地图的右边，你要保存的数据，可以通过它的键访问。</li><li id="e886" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><strong class="jw hu">绑定</strong> = &gt;键/值对，如果映射是两列电子表格，这将是一行。</li><li id="9cee" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><strong class="jw hu">迭代</strong> = &gt;循环遍历地图而不修改它。</li><li id="2528" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><strong class="jw hu">映射</strong> = &gt;遍历一个地图并修改其绑定。</li><li id="8b2f" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><strong class="jw hu">折叠</strong> = &gt;遍历一个地图并使用它的绑定来产生一个最终值。</li></ul><p id="1e25" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">以下是地图和大地图的所有可用功能列表:</p><ul class=""><li id="45fc" class="lt lu ht jw b jx jy ka kb kd lv kh lw kl lx kp nl lz ma mb dt translated">宣布一张新地图</li><li id="f821" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated">创建一个空地图</li><li id="92c9" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><code class="eh lp lq lr ls b"><strong class="jw hu">Map.literal([(first_binding), (second_binding), ...])</strong></code> = &gt;创建一个非空地图</li><li id="7b09" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><code class="eh lp lq lr ls b"><strong class="jw hu">Map.find_opt(key, map)</strong></code> = &gt;查找与指定键相关的值，如果找不到值，则返回可选的等于<strong class="jw hu"> None </strong>的值，如果值存在，则返回<strong class="jw hu"> Some (value) </strong>的值。</li><li id="2f14" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><code class="eh lp lq lr ls b"><strong class="jw hu">Map.add(key, value, map)</strong></code> = &gt;向现有地图添加新绑定</li><li id="5c60" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><code class="eh lp lq lr ls b"><strong class="jw hu">Map.update(key, Some (value), map)</strong></code> = &gt;更新给定映射中绑定的值。请注意，该值必须是可选类型，因为传递等于<em class="kq"> None </em>的值与移除绑定是一样的。</li><li id="fd9e" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><code class="eh lp lq lr ls b"><strong class="jw hu">Map.remove(key, map)</strong></code> = &gt;删除映射中与提供的键匹配的绑定。</li><li id="c9b3" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><code class="eh lp lq lr ls b"><strong class="jw hu">Map.iter(function_to_be_called, map)</strong></code> = &gt;循环遍历所提供地图的绑定，并将给定函数应用于每个绑定。<em class="kq"> Map.iter </em>返回一个单元(或者更简单地说就是没有)。</li><li id="12cf" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><code class="eh lp lq lr ls b"><strong class="jw hu">Map.map(function_to_be_called, map)</strong></code> = &gt;遍历所提供地图的绑定，并应用函数修改它们。<em class="kq"> Map.map </em>返回相同类型的新地图。</li><li id="ab0f" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><code class="eh lp lq lr ls b"><strong class="jw hu">Map.fold(function_to_be_called, map, accumulator)</strong></code> = &gt;遍历所提供映射的绑定，将键/值“折叠”在一起，以产生累加值(或“累加器”)，并在每次循环中更新它。</li><li id="2dc4" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><code class="eh lp lq lr ls b"><strong class="jw hu">Map.size(map)</strong></code> = &gt; <em class="kq">(仅适用于地图，不适用于大地图)</em>输出给定地图的大小。</li><li id="5819" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><code class="eh lp lq lr ls b"><strong class="jw hu">Map.mem(key, map)</strong></code> = &gt; <em class="kq">(仅适用于地图，不适用于大地图)</em>输出一个布尔值，指示一个键在地图中是存在(真)还是不存在(假)。</li></ul><p id="35b6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">来源:<a class="ae kr" href="https://ligolang.org/docs/language-basics/maps-records" rel="noopener ugc nofollow" target="_blank"> Ligo文档</a>和<a class="ae kr" href="https://ligolang.org/docs/reference/map-reference" rel="noopener ugc nofollow" target="_blank">地图参考</a>。</p><p id="6b61" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果你喜欢这个教程，考虑发送一些tezzies到<strong class="jw hu">tz 1 sjr neue 4 zypgszpogdz D5 tvryixndsd 2v</strong>，不要犹豫留下你的意见或建议！</p><h2 id="5e59" class="mm kt ht bd ku mx my mz ky na nb nc lc kd nd ne le kh nf ng lg kl nh ni li nj dt translated"><strong class="ak">也读作:</strong></h2><ul class=""><li id="3f01" class="lt lu ht jw b jx lk ka ll kd nm kh nn kl no kp nl lz ma mb dt translated"><a class="ae kr" rel="noopener" href="/coinmonks/build-your-first-dapp-on-tezos-270c568d4fe9"> <strong class="jw hu">在Tezos </strong> </a>上建立你的第一个Dapp</li><li id="0cc3" class="lt lu ht jw b jx mc ka md kd me kh mf kl mg kp nl lz ma mb dt translated"><a class="ae kr" rel="noopener" href="/coinmonks/getting-started-with-ligo-13ea2c4e844e"><strong class="jw hu">Ligo入门</strong> </a></li></ul><blockquote class="np"><p id="9e54" class="nq nr ht bd ns nt nu nv nw nx ny kp ek translated"><a class="ae kr" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="oa ob oc od oe jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nz"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff of"><img src="../Images/e9dbce386c4f90837b5db529a4c87766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fZu_SfnNF6m_BGbXlsl-A@2x.png"/></div></div></figure></div></div>    
</body>
</html>