# 了解以太坊黄皮书

> 原文：<https://medium.com/coinmonks/understanding-the-ethereum-yellow-paper-f280800df590?source=collection_archive---------0----------------------->

在多次阅读以太坊黄皮书(YP)后，就像大多数人一样，我真的没有理解它。以下是我对理解它的一点浅显尝试，希望对你有所帮助。

“所以，我从那些在我之前的人那里借来了笔记和图表，希望我能给那些在我之后的人留下一条线索。”

(声明:本帖基于当前版本的黄皮书，彼得堡版本 fa 00 ff 1–2021-05-12)。

## **简介**

在这一节中，作者强调以太坊是一个状态机。在计算机科学中，状态机是指能够读取一系列输入并根据这些输入转换到新状态的东西(即计算机)。因此，以太坊被解释为一种新的分散式计算机，任何人都可以参与其中。

作者还写了以太坊背后的驱动因素。以太坊**的一个关键目标是促进自愿的个人之间的交易，否则他们将无法信任彼此。**还有，生态系统所做的前期工作。

这也许是最容易理解的黄皮书(请不要太舒服！).

## **区块链范式**

以太坊作为一个整体可以被视为一个基于事务的状态机:它从一个起源状态开始，并逐步执行事务以将其转变为某个当前状态。

![](img/1747d4c07ffa28e6577bae137ce7ac5f.png)

从公式上讲，这可以表示为:

σT+1≠υ(σT，T)其中；

σt =是当前的世界状态

T =是交易

υ=是以太坊状态转移函数

这将导致σt+1，称为下一个世界状态

基本上，它可以被视为一个状态转移机器，其中事务“T”是当前状态和下一个世界状态之间的弧。

![](img/80434a694fbd2d799be54855a3d7b626.png)

事务被整理成块:使用加密散列作为引用方式将块链接在一起。这些*块*充当日志，记录一系列事务以及之前的块和最终状态的标识符。

![](img/ef4761de714b856d042f6f913248a1e0.png)

**B =是一个包含(…，(T0，T1，…)，…)一系列事务的块**

交易被节点挖掘的激励所打断。这种激励作为一种状态转换功能发生，为指定账户(即矿工)增加价值

矿工参与采矿，这是通过称为工作证明(POW)的加密安全证明来支持一系列交易(一个区块)胜过任何其他潜在竞争对手区块的过程。这可以正式扩展为；

b≦(...，(T0，T1，...), ...)

π(σ，B)≡ω(B，υ(υ(σ，T0)，T1)…)

哪里；

ω=是块终结状态转移函数(奖励指定方的函数)

B =是包含一些其他组件之间的一系列事务的块。

π=是模块级状态转换函数。

这是形成区块链范式的基础，这一模型不仅是以太坊的支柱，也是迄今为止所有分散的基于共识的交易系统的支柱。

**价值:**网络设计了一种激励计算和用自己的货币传递价值的方式，叫做 **ETH** 。这个值可以分解成单位，卫最小，以太最高。

![](img/ead21c212a1ffca82d0bf4e907ed776c.png)

## **哪个历史？**

通过称为区块链的树结构，从根(起源块)到叶(包含最近事务的块)存在块上的事务历史。

区块链必须保持每个人都必须接受的单一的真理来源，否则，没有人会相信这个系统，并挫败它的目的。有一个规范链，每个人都接受它为主链，正确的主链，它包含相同或兼容的事务。

必须避免多重状态(或者链、路径)，因为几乎不可能确定哪个是正确的、有效的。在关于哪个是正确的链存在分歧的场景中，会出现一个*分支*。我们通常希望避免分叉，因为它们会扰乱系统。

当分叉发生时，为了产生关于哪个是规范块(即正确的或真正的块)的一致意见，我们使用一个称为 **GHOST 协议**的方案，它代表**贪婪最重观察子树**。它说我们必须选择计算量最大的路径。

![](img/8f07dd66e4b29a92c371d1bf1f876b3c.png)

## **惯例**

黄皮书(YP)中使用的正式符号有许多印刷约定，其中一些是:

世界状态:σ

机器状态:μ

以太坊状态转移函数:υ

成本函数:C 例如用于 SSTORE 存储操作的成本函数 CSSTORE。

[Keccak 散列函数](https://steemit.com/etc/@cseberino/why-ethereum-classic-uses-an-incorrect-sha3-implementation)(有时是 SHA-3，出于本文的目的):是一个通用的加密函数，用于认证、加密和伪随机数生成。在计算数据结构的 Keccak 256 哈希之前，必须使用[递归长度前缀(RLP)编码将它们转换为位串。](/coinmonks/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919)

元组:是元素的有限有序序列列表。通常将 *Tn* 表示为 n 个元素的顺序列表，其中 *n* 为非负整数。还可以有表示为 0 元组的空元组。

T *n* 也用于表示交易随机数，即交易列表。

δ给定操作所需的堆栈上的项目数。

标量和固定大小的字节:被假定为非负整数 n。所有字节序列的集合是 b。如果这样的序列集合被限制为特定长度的序列，则用下标表示(即 B32 表示长度为 32 的字节序列集合)。

## **块、状态和事务**

世界状态(state)是地址(160 位标识符)和账户状态(序列化为 [RLP](/coinmonks/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919) 的数据结构，即递归长度前缀)之间的映射。

![](img/fa9e5b0ee382cfad171afe53790c65a4.png)

假设实现将在修改的 Merkle Patricia 树中维护该映射。

一个 [Merkle Patricia Trie](https://steemit.com/ethereumclassic/@cseberino/merkle-patricia-tries-made-easy) (也称为二进制哈希树)是以太坊存储层的关键数据结构之一。本质上，它是一个键值映射。它允许我们验证数据的完整性。

可以用散列函数计算 trie 的 Merkle 根散列，使得如果任何键值被更新，trie 的 Merkle 根散列将会不同。底部行的散列被称为“叶子”，中间的散列被称为“分支”，顶部的散列被称为“根”。

![](img/0018f7739dae0d759cc206292941352d.png)

*哈希 0–0 和 0–1 分别是数据块 L1 和 L2 的哈希值，哈希 0 是哈希 0–0 和 0–1 的串联哈希值。*

## **账户状态**

有两种类型的帐户；外部拥有的账户(即钱包)和合约账户。

![](img/e62cb6061f76b6e103d9a2f6c4328ec1.png)

外部所有账户(eoa)可以向其他 eoa 或合同账户(CA)发送消息，以使用其私钥执行交易/代码。在两个 eoa 之间发送的消息只是一个值的传递(即互相发送以太网)。但是从 EOA 发送到合同账户的消息激活 CA 内的代码(例如，创建新合同、铸造代币、转移代币等)。

此外，合同账户不能自行发起交易，必须由 EOAs 发起。相反，CA 触发由 eoa 发起的事务。

存在账户状态σ[a],其包括以下四个字段；

*   nonce:对于外部拥有的帐户，它列出了从原始地址发送的交易数量，或者对于具有关联代码的帐户(即合同帐户)，列出了该帐户创建的合同数量。
*   余额:该地址拥有的卫数。
*   storageRoot:帐户存储 trie 的根节点的哈希。默认情况下，这是空的。
*   codeHash:此帐户的 EVM 代码的散列，用于合约帐户。对于 EOAs，这将是一个空字符串。

**事务**是以太坊范围之外的参与者构建的单密码签名指令，参与者被假定为人类，但在指令的构建和传播中使用软件工具。在以太坊中，记得我们说过，事务是使状态从当前状态变为下一个状态的东西。

有两种类型的事务:一种导致消息调用，另一种导致使用相关代码创建新帐户(也称为契约创建)。

![](img/4a15e4300ede4d2ec54dd063f9b82b16.png)

​

## **街区**

以太坊中的块是相关信息的集合，包括块头和块体(即关于块中包含的一组事务的信息，以及当前块的一组其他块头)。

**Ommer** 是一个块，其父块等于当前块的父块的父块。

在挖掘的时候，有很多挖掘者试图同时挖掘同一套交易。由于区块开采时间非常短(约 15 秒。在以太坊的情况下)，有可能在很短的时间间隔内开采一个以上的区块。首先开采的区块被添加到主链中，但是开采另一个区块的矿工的努力不会被放过。这些其他块被称为“**孤立块**”。

ommers 的目的是帮助奖励矿工将这些孤立的块包含在主链中。采矿者包括的 ommers 必须是“有效的”，意思是在当前区块的第六代以内或更小。六个子块之后，过时的孤立块将不再被引用。

矿工获得的小块奖励比满块少。

块标题由以下内容组成:

*   括号:父块头的散列。
*   ommersHash:当前块的 ommers 列表的散列。
*   受益人:将获得该区块开采费用的账户地址。
*   stateRoot:在事务被执行和终结之后，状态 trie 的根节点的散列。
*   transactions root:trie 的根节点的哈希，包含块中列出的所有事务
*   receiptsRoot:每当执行交易时，都会生成交易收据。这是交易收据 trie 的根节点的散列。
*   logsBloom:一个 [bloom filter](https://ethereum.stackexchange.com/questions/34/what-is-an-uncle-ommer-block) (一个数据结构)，由块中事务生成的日志信息组成。
*   难度:该区块的难度等级。这是对开采该区块难度的衡量。难度总是根据挖掘前一个区块所花费的时间而变化。
*   number:祖先块的数量。从零开始，从起始块开始，随后的每个块递增 1。
*   gasLimit:当前每个区块的天然气消耗极限
*   gasUsed:区块交易中使用的天然气总量。
*   时间戳:这个块开始时的 unix 时间戳
*   extraData:这是与该块相关的额外数据。当矿工创建区块时，可以选择在该字段中添加任何内容。
*   mixHash:一个 Hash，结合 nonce 证明在这个块上已经执行了足够的计算量。它用于验证一个区块已被适当开采
*   nonce:一个 hash，当与 mixhash 结合时，证明在这个块上已经执行了足够的计算量。

每个块头包含三个 trie 结构，用于:

*   state (stateRoot)，这是 state trie:它存储了关于帐户的所有信息，您可以通过查询来检索信息。
*   transactions (transactionsRoot)，这是事务 trie:它记录以太坊中的事务
*   收据(receiptsRoot)，即交易收据 trie:它记录交易的收据(结果)。收据是成功执行交易的结果。

![](img/000bcd47a82c3ae23152a546c1e82739.png)

整体有效性:我们可以断言一个块的有效性，当且仅当它满足几个条件:它必须在内部与 ommer 和 transaction 块散列和给定的事务一致。父母的 Hr，Hr，Ho，Ht，He，Hb。

## **汽油和付款**

以太坊的所有可编程计算都要收费(以燃气计价)。气体对以太坊网络至关重要。是燃料让它运转，就像汽车需要汽油才能行驶一样。

![](img/89afabd811c9ad46aaedd3680fc7b71e.png)

在执行操作时，gas 中的成本是执行操作(按时间测量)和该操作所需的永久存储量(写入存储时)的计算表示。

gasLimit:每笔交易都有一个特定数量的汽油与之相关联。它是发送方愿意支付的执行交易的最大汽油量。

gasPrice:这是交易发送者愿意支付的每单位汽油的价值。

汽油用完:当没有必要的汽油来运行交易时，就会出现这种情况。

挖掘:挖掘是创建要添加到以太坊区块链的交易块的过程。采矿是一个昂贵的过程，所以如果矿工没有从采矿中获得任何回报，就没有人会去做。因此，矿商从区块中包含的所有交易中收取费用。采矿者倾向于设定并公布他们的最低费用，因此可以自由拒绝不符合最低费用的采矿区块。

## **交易执行**

事务的执行是以太坊协议中最复杂的部分:它定义了状态函数 y。假设任何被执行的事务首先通过内在有效性的初始测试。这些包括:

*   该事务是一个格式良好的 RLP，没有额外的尾随字节。
*   交易签名有效。
*   交易随机数是有效的(相当于发送者帐户的当前随机数)。
*   气体限制不小于交易使用的固有气体。
*   发送者账户余额至少包含预付汽油费用所需的费用。

还有一个规则没有作为内在有效性测试的一部分被提及。它规定*“如果通过包含该交易，该区块中所有交易的总 gas 限制不超过该区块的 gas 限制，则该交易不得包含在该区块中”*。

这是由[普瑞蒂·卡西伦迪](https://www.preethikasireddy.com/)创作的一个很好的演练例子。

*   执行交易的预定汽油费用
*   与交易一起发送的数据的 gas 费用(数据或代码的每个字节 4 gas 等于零，数据或代码的每个非零字节 gas)
*   如果交易是创建合同的交易，额外的 32，000 gas。

![](img/1479e1e7c7f3da562ee79d34e4726afc.png)

*   发送方账户余额必须至少包含用于执行的“预付”气体的成本。为了计算预付天然气，交易的天然气价格乘以交易的天然气限额，以确定最大天然气成本。然后，这将被添加到从发送方转移到接收方的总价值中。

![](img/b5e8671a33b091cb7d25ad7b7e8cee94.png)

如果交易满足上述所有有效性要求，那么我们进入下一步。

首先，从发送者的余额中扣除执行的前期成本，并将发送者账户的现时值增加 1，以说明当前交易。在这一点上，我们可以将剩余的天然气计算为交易的**总天然气限额减去使用的固有天然气。**

![](img/a26f86aa6c3f61ef1f196edf04eba551.png)

接下来，事务开始执行。在交易的整个执行过程中，以太坊跟踪“**子状态**”该子状态是一种记录交易过程中积累的信息的方式，交易完成后将立即对这些信息采取行动。具体来说，它包含:

*   自毁集:交易完成后将被丢弃的一组账户(如果有的话)。
*   日志系列:虚拟机代码执行的归档和可索引检查点。
*   退款余额:交易后要退还给发送方帐户的金额。以太坊的存储是要花钱的，所以以太坊会对清理存储的发送者进行退款/奖励。以太坊使用退款计数器对此进行跟踪。退款计数器从零开始，并且每当合同删除存储中的某些内容时就递增。

接下来，处理事务所需的各种计算。

一旦处理了交易所需的所有步骤，并且假设没有无效状态，则通过确定要退还给发送者的未使用的气体量来最终确定状态。除了未使用的气体之外，还从上面描述的“退款余额”中向发送者退还一些津贴。

一旦发件人退款。

*   瓦斯乙醚给了矿工。
*   事务使用的气体被添加到块气体计数器(跟踪块中所有事务使用的总气体，在验证块时很有用)。
*   自毁设置中的所有账户(如果有的话)都被删除。

最后，我们剩下新的状态和一组由事务创建的日志。

​​

**合同创建**

请记住，我们有两种类型的帐户，EOAs 和 CAs。合约账户交易的目的是创建新合约。创建帐户时会用到许多固有参数。

*   发报机
*   原始交易者
*   可用气体
*   天然气价格
*   捐助
*   任意长度字节数组
*   初始化 EVM 代码
*   消息调用/协定创建堆栈的父深度
*   新帐户地址的 salt，最后是修改状态的权限。

代码执行会耗尽气体，在执行完成之前，气体不能低于零。如果 gas 在执行前低于零，事务将在代码因**gas**情况(OOG)而进入自然停止状态之前退出。如果执行以异常方式停止(即由于耗尽气体供应、堆栈下溢、无效跳转目的地或无效指令)，则没有气体退还给调用者(即发送者)，并且状态恢复到余额转移之前的点。

在一切顺利并且代码执行(即创建了契约)的情况下，任何剩余的未使用的 gas 被退还给事务的原始发送者，并且改变的状态被允许持续。

请注意，其意图是，结果要么是成功创建一个带有捐赠的新合同，要么是没有价值转移的新合同。

**消息呼叫**

为了执行消息调用，需要几个参数，就像契约创建一样，但也有一些例外。

*   发报机
*   交易发起人
*   收件人
*   要执行其代码的帐户，通常与接收方相同
*   可用气体
*   价值和汽油价格以及任意长度的字节数组
*   呼叫的输入数据
*   消息调用/协定创建堆栈的当前深度
*   对状态进行修改的权限。

**执行模式**

执行模型着眼于事务在虚拟机(VM)中的实际执行方式。它指定了在给定一系列字节码指令和一个小的环境数据元组的情况下，系统状态是如何改变的。这是通过虚拟状态机的正式模型来指定的，称为以太坊虚拟机(EVM)。

基础知识:EVM 是一个简单的基于堆栈的架构。以太坊虚拟机是以太坊中智能合约的运行时环境。EVM 代码在以太坊虚拟机(EVM)上执行。EVM 是一个图灵完全虚拟机，与其他图灵完全机的不同之处在于它本质上受 gas 约束。即所有的计算都限于所提供或可用的气体量。

![](img/66e34fb7a7f55a2b5aaeff4b57f28051.png)

机器的字长(以及堆栈项目的大小)是 256 位。内存模型是一个简单的字寻址字节数组。堆栈的最大大小为 1024。此外，存储模型是一个字数组，而不是字节数组。与易失性的内存不同，存储是非易失性的，是作为系统状态的一部分来维护的。并且两者最初都被明确定义为 0。

像气体耗尽异常一样，机器不会保持状态变化不变。相反，机器立即停止，并向执行代理(事务处理器或递归地，生成执行环境)报告该问题，执行代理将单独处理该问题。

**费用概述:**费用(以天然气计价)在三种不同的情况下收取，这三种情况都是执行作业的先决条件。第一个也是最常见的是运算计算的固有费用。第二，为了形成对从属消息呼叫或合同创建的支付，可以扣除汽油费；这构成了 CREATE、CREATE2、CALL 和 CALL 代码费用的一部分。最后，由于内存使用量的增加，可能需要支付汽油费。

为了激励存储器使用的最小化(这直接对应于所有节点上的更大的状态数据库)，清除存储器中的条目的操作的执行费用不仅被免除，还被给予有资格的退款；事实上，这种退款实际上是预先支付的，因为存储位置的初始使用成本远远高于正常使用。

**区块最终确定**

块终结可能意味着两种不同的东西；如果该块是新块或者是现有块。如果是新区块，则表示开采该区块所需的过程。如果是现有块，则意味着验证块的过程。

最终确定区块的过程包括四个阶段:

*   验证(或者，如果采矿，确定)ommers

BH 和 PH 分别是相应报头 H 的块和父块(即每个 ommer 块必须有效并且在当前块的第六代内)。

*   验证(如果是挖掘，则确定)交易；

给定的汽油必须与所列交易相符。根据最终交易，区块中使用的总天然气量必须等于累计使用的天然气量。

*   应用奖励；

对一个区块应用奖励包括将该区块的受益人地址和每个成员的账户余额提高一定的数量。此外，对于每一个 ommer，当前块的受益者将额外获得当前块奖励的 1/32。

*   验证(或者如果挖掘，则计算有效的)状态和块随机数；

将不完整的块 B 映射到完整的块 B1 的块转移函数。确保应用所有事务和结果状态更改，并将新块定义为应用块奖励后的状态。

**挖掘工作证明**:挖掘(PoW)作为一种密码安全的随机数存在，它证明在确定某个令牌值 *n* 时已经花费了特定的计算量。由于开采新区块会带来附加奖励，工作证明不仅是一种确保区块链在未来保持规范的信心的方法，也是一种财富分配机制。

出于这两个原因，工作证明功能有两个重要目标；

*   首先，应该让尽可能多的人能够接触到它。每个人都可以参加，应该尽量减少使用特殊和不常见的硬件。
*   其次，单个当事方(即矿商)不应该有可能获得超线性利润。

采矿权既是一种安全机制，也是一种财富分配机制。

注意:以太坊正在从工作证明(PoW)共识机制过渡到利益证明(PoS)共识机制。PoS 是一个完全不同的主题，可能会在以后的帖子中探讨。

在黄皮书中，还有**实施契约** & **以太坊生态系统未来方向**等话题。这将是一本轻松的读物。

哇！学习和撰写以太坊黄皮书(YP)是一件令人兴奋的事情。如果你需要多次阅读才能完全理解发生了什么，我完全理解。我花了很多时间阅读，与有经验的人交谈，查看代码库，我仍然发现自己要回到 YP 去仔细检查一些东西。

无论如何，我希望这能对你有所帮助。如果你发现了错误和失误(你很可能会发现)，请不要犹豫，给[我](https://twitter.com/owanikin) & [我](https://www.linkedin.com/in/oderinde-ifeoluwa-86a382149/)写信，希望我们能改正它们。

谢谢你，再见！

[https://ethereum.github.io/yellowpaper/paper.pdf](https://ethereum.github.io/yellowpaper/paper.pdf)

[https://ethereum.org/en/whitepaper/](https://ethereum.org/en/whitepaper/)

https://www.lucassaldanha.com/

[https://takenobu-hs . github . io/downloads/ether eum _ EVM _ illustrated . pdf](https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf)

[https://medium . com/code chain/modified-merkle-Patricia-trie-how-ether eum-saves-a-state-e6d 7555078 DD](/codechain/modified-merkle-patricia-trie-how-ethereum-saves-a-state-e6d7555078dd)

[https://ethereum.org/en/developers/docs/gas/](https://ethereum.org/en/developers/docs/gas/)

[https://www . preethikasireddy . com/post/how-do-ether eum-work-anyway](https://www.preethikasireddy.com/post/how-does-ethereum-work-anyway)