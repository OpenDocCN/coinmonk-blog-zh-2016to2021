<html>
<head>
<title>Obfuscating EOSIO smart contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">混淆EOSIO智能合同</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/obfuscating-eosio-smart-contracts-72756ac3dc96?source=collection_archive---------1-----------------------#2020-07-12">https://medium.com/coinmonks/obfuscating-eosio-smart-contracts-72756ac3dc96?source=collection_archive---------1-----------------------#2020-07-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="5cde" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有几类智能合约，人们不愿透露它们的内部运作方式。这是私人智能合约的一个共同主题，例如，交易机器人智能合约，因为套利交易是一个非常竞争的零和游戏。</p><blockquote class="jo jp jq"><p id="2720" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hm dt translated">在软件开发中，<a class="ae jv" href="https://en.wikipedia.org/wiki/Obfuscation_(software)" rel="noopener ugc nofollow" target="_blank">混淆</a>是指故意创建人类难以理解的源代码或机器代码的行为。<a class="ae jv" href="https://en.wikipedia.org/wiki/Obfuscation_(software)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="43c2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通常，这是指将源代码更改为难以逆向工程的不可读的混乱状态，就像只使用<code class="eh jw jx jy jz b"><a class="ae jv" href="http://www.jsfuck.com/" rel="noopener ugc nofollow" target="_blank">[]()+!</a></code>字符编写JavaScript一样。EOSIO智能合同被编译为WebAssembly，并以这种格式存储在链上。也就是说，混淆也需要发生在WebAssembly级别。请记住，这只会使攻击者更难对合同进行逆向工程，但并非不可能——只要有足够的时间，攻击者仍然会成功(晦涩难懂的“安全性”)。</p><blockquote class="jo jp jq"><p id="f6ab" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hm dt translated">这里我们不是在讨论<em class="ht">不可区分性混淆</em>的加密领域，它可以将一个程序转换成一个新的程序，这个新的程序被<strong class="is hu">证明</strong>除了它的输入输出行为之外不会泄露任何东西。这实际上将允许你在程序中包含私钥，并在智能合同中实现签名创建，但截至2020年，这是不可行的(即使在智能合同之外)。</p></blockquote><p id="e686" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在第一部分中，我们将看看最简单的混淆形式:改变合同的ABI。这很容易实现，并且已经产生了很大的效果，因为它在块探索者上显示十六进制值，迫使某人深入WASM代码来破译动作参数和表结构。让我们看看一些方法。</p><h2 id="a311" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated">1.名字模糊的ABI</h2><p id="01f7" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">这是我见过的最常见的方法。人们没有为动作参数使用有意义的名称，而是简单地将它们命名为<code class="eh jw jx jy jz b">a</code>、<code class="eh jw jx jy jz b">b</code>、<code class="eh jw jx jy jz b">c</code>或类似的名称。这也是最糟糕的混淆，因为它保留了动作参数和表结构的所有类型信息。</p><p id="43d5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我相信它仍然如此受欢迎的原因是它允许与智能合约轻松交互，因为正确的ABI在链上，并且像<code class="eh jw jx jy jz b">cleos</code>、<code class="eh jw jx jy jz b">eosjs</code>或任何钱包这样的工具仍然可以与这种方法一起工作，因为它们可以序列化操作。</p><h2 id="4f8e" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated">2.没有ABI</h2><p id="779e" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">另一种方法是根本不上传ABI。这会导致块管理器无法反序列化数据，而是显示普通的十六进制数据，从而丢失所有类型信息以及一个操作有多少个参数。让我们用这个示例契约来测试它:</p><pre class="la lb lc ld fq le jz lf lg aw lh dt"><span id="e521" class="ka kb ht jz b fv li lj l lk ll">CONTRACT obfuscate : public contract {<br/>public:<br/>  using contract::contract;<br/>  obfuscate(eosio::name receiver, eosio::name code,<br/>            eosio::datastream&lt;const char *&gt; ds)<br/>      : contract(receiver, code, ds), _storages(receiver, receiver.value) {}<br/><br/>  TABLE storage {<br/>    name account;<br/>    uint64_t value;<br/>    std::string message;<br/><br/>    uint64_t primary_key() const { return account.value; }<br/>  };<br/>  typedef eosio::multi_index&lt;"storages"_n, storage&gt; storage_t;<br/><br/>  storage_t _storages;<br/><br/>  ACTION test(const name &amp;account, const uint64_t &amp;value, const string &amp;message) {<br/>    auto storage = _storages.find(account.value);<br/>    if (storage == _storages.end()) {<br/>      _storages.emplace(get_self(), [&amp;](auto &amp;x) {<br/>        x.account = account;<br/>        x.value = value;<br/>        x.message = message;<br/>      });<br/>    } else {<br/>      _storages.modify(storage, get_self(), [&amp;](auto &amp;x) {<br/>        x.value += value;<br/>        x.message = message;<br/>      });<br/>    }<br/>  }<br/>};</span></pre><p id="6b6b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们现在可以使用<code class="eh jw jx jy jz b">eosio::setcode</code>动作来设置这个合同代码，但是不能上传ABI。在eosq上，调用<code class="eh jw jx jy jz b">test</code>动作将如下所示:</p><figure class="la lb lc ld fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff lm"><img src="../Images/7ed1ad51686f5d7311326aa781d9e95e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*flKlqrLPWhVaRPQc.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek"><em class="ly">Invoking an action on a contract with no ABI</em></figcaption></figure><p id="5be0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">动作数据和表格行只是显示普通的十六进制数据，这比前面的方法好得多。但是，如果没有ABI，我们实际上如何调用契约动作呢？我们需要自己序列化动作数据。与这样的契约交互的最简单的方法是使用<code class="eh jw jx jy jz b">eosjs</code>并定义一个自定义<code class="eh jw jx jy jz b">AbiProvider</code>。</p><p id="ae5d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">AbiProvider负责获取任何契约的ABI，然后用于在用<code class="eh jw jx jy jz b">api.transact</code>发送事务时序列化动作数据。我们可以编写自己的AbiProvider，从文件系统中读取我们的合同的ABI，并尝试从任何其他合同的链中获取ABI。</p><pre class="la lb lc ld fq le jz lf lg aw lh dt"><span id="d268" class="ka kb ht jz b fv li lj l lk ll">import { JsonRpc, Api, Serialize } from "eosjs";<br/>import { AbiProvider, BinaryAbi } from "eosjs/dist/eosjs-api-interfaces";<br/>import { TextEncoder, TextDecoder } from "util";<br/><br/>// converts JS object ABI to serialized ABI<br/>const jsonToRawAbi = (json) =&gt; {<br/>  // ...<br/>};<br/><br/>const privateAbis: { [key: string]: Buffer } = {};<br/>// load obfuscator ABI from file<br/>privateAbis[`obfuscator11`] = jsonToRawAbi(require(`./obfuscate.abi.json`));<br/><br/>export default class PrivateAbiProvider implements AbiProvider {<br/>  rpc: JsonRpc;<br/><br/>  constructor(rpc) {<br/>    this.rpc = rpc;<br/>  }<br/><br/>  async getRawAbi(account): Promise&lt;BinaryAbi&gt; {<br/>    // if we're interacting with the obfuscator contract use local ABI<br/>    if (privateAbis[account])<br/>      return {<br/>        accountName: account,<br/>        abi: privateAbis[account],<br/>      };<br/><br/>    return (await this.rpc.getRawAbi(account)).abi as any;<br/>  }<br/>}</span></pre><p id="56b3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在eosjs的API对象中使用这个自定义的AbiProvider很简单:</p><pre class="la lb lc ld fq le jz lf lg aw lh dt"><span id="b54d" class="ka kb ht jz b fv li lj l lk ll">const signatureProvider = new JsSignatureProvider(keys)<br/>const customAbiProvider = new PrivateAbiProvider(rpc)<br/>const api = new Api({<br/>  rpc: rpc,<br/>  signatureProvider,<br/>  abiProvider: customAbiProvider,<br/>  textDecoder: new TextDecoder(),<br/>  textEncoder: new TextEncoder(),<br/>})<br/><br/>// send test action<br/>const actions = [<br/>  {<br/>    account: `obfuscator11`,<br/>    name: `test`,<br/>    data: {<br/>      account: `obfuscator11`,<br/>      value: 23,<br/>      message: `hello this is just a string`,<br/>    },<br/>    authorization: [{ actor: `obfuscator11`, permission: `active` }],<br/>  },<br/>]<br/><br/>await api.transact(<br/>  {<br/>    actions,<br/>  },<br/>  {<br/>    broadcast: true,<br/>    sign: true,<br/>    blocksBehind: 3,<br/>    expireSeconds: 300,<br/>  }<br/>)</span></pre><h2 id="3568" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated">3.假ABI</h2><p id="c2ea" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">我们可以更进一步，迷惑任何在块浏览器中查看动作的人。我们没有上传ABI，而是创建了一个假的ABI，其中的动作参数和表结构类型与原始的不匹配。我们可以自己编写ABI文件，或者让<code class="eh jw jx jy jz b">eosio-cpp</code>为我们完成:</p><pre class="la lb lc ld fq le jz lf lg aw lh dt"><span id="ce3b" class="ka kb ht jz b fv li lj l lk ll">CONTRACT obfuscate : public contract {<br/>// ...<br/><br/>  // no TABLE anymore<br/>  struct storage {<br/>    // ... same as before<br/>  };<br/>  typedef eosio::multi_index&lt;"storages"_n, storage&gt; storage_t;<br/>  storage_t _storages;<br/><br/>  // no ACTION anymore<br/>  void test(const name &amp;account, const uint64_t &amp;value, const string &amp;message) {<br/>    // ... same as before<br/>  }<br/><br/>  // this will just be used to create the fake ABI<br/>  struct [[eosio::table("storages")]] fake_storage {<br/>    bool stored;<br/><br/>    uint64_t primary_key() const { return 0; }<br/>  };<br/>  [[eosio::action("test")]] void fake_test(const uint8_t &amp;id) {}<br/>};<br/><br/>extern "C" {<br/>void apply(uint64_t receiver, uint64_t code, uint64_t action) {<br/>  if (code == receiver) {<br/>    switch (action) { EOSIO_DISPATCH_HELPER(obfuscate, (test)) }<br/>  }<br/>  eosio_exit(0);<br/>}<br/>}</span></pre><p id="01dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们从原始动作中删除了<code class="eh jw jx jy jz b">ACTION</code>宏(因此必须实现一个定制的<code class="eh jw jx jy jz b">apply</code>函数),并创建一个具有相同动作名称的假动作。桌子也一样。这导致ABI生成器为正确的动作/表名选择假类型，块浏览器将使用这些动作/表名来反序列化数据。</p><p id="190f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我们的eosjs ' AbiProvider中，我们仍然使用正确的ABI。在eosq上产生的操作如下所示:</p><figure class="la lb lc ld fq ln fe ff paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="fe ff lz"><img src="../Images/db11d2934bb35f8fb85c34e5526d1566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DPIVdmArpPLT5OZq.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek"><em class="ly">Invoking an action on a contract with a fake ABI</em></figcaption></figure><p id="8b81" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">看起来我们发送了一个带有单个<code class="eh jw jx jy jz b">uint8_t id</code>参数的<code class="eh jw jx jy jz b">test</code>动作，就好像我们存储了一个单个布尔值<code class="eh jw jx jy jz b">stored</code>。我们使用的其余字节没有被反序列化，也没有显示出来。用这种方式欺骗某人是非常容易的，除非他们检查动作痕迹并查看实际的十六进制数据。</p><p id="53bd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这已经很好地保护了您的契约，防止有人试图通过查看块浏览器中的动作或表来理解它。在下一篇文章中，我们将看看混淆WebAssembly代码。</p><figure class="la lb lc ld fq ln fe ff paragraph-image"><a href="https://learneos.dev"><div class="fe ff ma"><img src="../Images/95b829ebe7a6ced00fb83c11b0768b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XtAIKIBbN6EZ5vgN.png"/></div></a></figure></div><div class="ab cl mb mc hb md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hm hn ho hp hq"><p id="265c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最初发表于<a class="ae jv" href="https://cmichel.io/obfuscating-eosio-smart-contracts/" rel="noopener ugc nofollow" target="_blank">https://cmichel.io/obfuscating-eosio-smart-contracts/</a></p><blockquote class="mi"><p id="ec09" class="mj mk ht bd ml mm mn mo mp mq mr jn ek translated"><a class="ae jv" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="mt mu mv mw mx ln fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ms"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>