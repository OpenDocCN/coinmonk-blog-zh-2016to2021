<html>
<head>
<title>Starting with Polkadot Development (Part III)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Polkadot开发开始(第三部分)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/starting-with-polkadot-development-part-iii-234fc5e13687?source=collection_archive---------2-----------------------#2021-05-25">https://medium.com/coinmonks/starting-with-polkadot-development-part-iii-234fc5e13687?source=collection_archive---------2-----------------------#2021-05-25</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/913b84befc1a373e18b82086d2c694ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dm80D3wlWOk3CiufgySbsQ.jpeg"/></div></div></figure><div class=""/><p id="249c" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我们教程的最后一部分<a class="ae jz" rel="noopener" href="/coinmonks/starting-with-polkadot-development-part-ii-53c36be5556c">，我们看到了如何创建地址以及这对Polkadot网络意味着什么。我们还通过Polkadot.js用户界面转移了一些资金，当我们通过Node.js脚本查询地址时，看到了相同的金额。现在来看一些更令人兴奋的事情:以编程方式创建我们自己的传输！</a></p><h1 id="3f91" class="ka kb ie bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">创建交易</h1><p id="6d33" class="pw-post-body-paragraph jb jc ie jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">创建交易很容易。我们需要一个“from”和“to”地址，以及一个要传输的值。就像银行帐户一样，只有发送者需要在他的帐户中拥有特殊权限，接收者只能向网络上的任何人公开他们的地址，以便向他们发送一些钱。因此，用编程术语来说，这意味着发送者需要是一个<strong class="jd if"> KeyringPair </strong>对象(正如我们从本教程第二部分的<a class="ae jz" rel="noopener" href="/coinmonks/starting-with-polkadot-development-part-ii-53c36be5556c">中看到的)，而接收者可以是一个简单的字符串(尽管传递一个KeyringPair也是有效的)。在我们之前的教程中，我们向<strong class="jd if"> MEDIUM_1 </strong>账户进行了转账，我们将从该账户向一个新账户进行另一次转账。按照我们刚才所说的，我们需要使用相同的助记符在我们的代码中重新创建发送者帐户。</a></p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="9a3a" class="lm kb ie li b fv ln lo l lp lq"><strong class="li if"><em class="lr">const</em> MEDIUM_1</strong> = 'cruel leader remember night skill clump question focus nurse neck battle federal';</span><span id="e647" class="lm kb ie li b fv ls lo l lp lq"><strong class="li if"><em class="lr">const</em></strong> { account: <strong class="li if">medium1</strong> } = createAccount(<strong class="li if">MEDIUM_1</strong>);<br/><strong class="li if"><em class="lr">const</em></strong> { account: <strong class="li if">medium2</strong>, mnemonic } = createAccount();</span><span id="9188" class="lm kb ie li b fv ls lo l lp lq"><strong class="li if"><em class="lr">console</em></strong>.log(`"${mnemonic}"`);</span><span id="8831" class="lm kb ie li b fv ls lo l lp lq"><strong class="li if"><em class="lr">const</em></strong> amount = 15 * (10 ** api.registry.chainDecimals)</span><span id="ecb8" class="lm kb ie li b fv ls lo l lp lq"><strong class="li if"><em class="lr">const</em></strong> transfer = api.tx.balances<br/>    .transfer(<strong class="li if">medium2</strong>.address, amount)<br/>    .signAndSend(<strong class="li if">medium1</strong>);</span></pre><p id="1373" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">注意，转账只需要地址，而<code class="eh lt lu lv li b"><strong class="jd if">.signAndSend()</strong></code>需要完整的账户。您还可以看到，要发送的数量是在<a class="ae jz" href="https://wiki.polkadot.network/docs/en/learn-DOT" rel="noopener ugc nofollow" target="_blank"> <em class="lr">普朗克</em> </a>中定义的，因此我们必须将所需的点数乘以<strong class="jd if"> 10 </strong>。运行代码后，我们希望看到:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="9ed1" class="lm kb ie li b fv ln lo l lp lq">"aunt picnic where oak result bid patch load teach cable giraffe service"<br/>0xdbc934c6577ae4ee0d95065953731be943cf7c20aefac1149717db4fe75fbedf</span></pre><p id="60d5" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第一个是助记符，第二个是事务散列。回到Polkadot界面，用这个助记符创建一个账户。称之为<strong class="jd if"> MEDIUM_2 </strong>。您应该看到这15个点数被记入该账户，同时从<strong class="jd if"> MEDIUM_1 </strong>账户中扣除。<strong class="jd if">成功了！</strong></p><h1 id="a3aa" class="ka kb ie bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">大数字</h1><p id="d92b" class="pw-post-body-paragraph jb jc ie jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">到目前为止，我们一直在处理普通数字，在Javascript中，(不幸的是)<a class="ae jz" href="https://www.w3schools.com/js/js_numbers.asp" rel="noopener ugc nofollow" target="_blank">总是存储为64位浮点</a>。浮点运算可能会有损失，当涉及到金钱时，我们不能承受“损失！”所以在Polkadot中，特别是当涉及到Javascript代码时，我们使用一种叫做“大数”的东西，简称为<strong class="jd if"> BN </strong>。这是一种对象类型，它将整数值存储为一个小数组(通常是2个)值。在内部，它将组合这些元素并重新创建它存储的值，以便将其打印给用户，但在此之前，它将公开常见操作的方法，如加法、减法等。使用现成的<strong class="jd if"> Polkadot API客户端</strong>将返回<strong class="jd if"> BN </strong>中的所有值，因此，我们需要有工具来处理它们</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="7159" class="lm kb ie li b fv ln lo l lp lq">npm i bn.js --save</span></pre><p id="58b6" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我们可以重复上述过程，将变量amount定义为:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="a57b" class="lm kb ie li b fv ln lo l lp lq"><strong class="li if"><em class="lr">const</em></strong> factor = <strong class="li if"><em class="lr">new</em></strong> <strong class="li if">BN</strong>(10).pow(<strong class="li if"><em class="lr">new</em></strong> BN(api.registry.chainDecimals));<br/><strong class="li if"><em class="lr">const</em></strong> amount = <strong class="li if"><em class="lr">new</em></strong> <strong class="li if">BN</strong>(15).mul(factor);</span></pre><p id="dd7a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们将10(作为BigNumber)提升到<strong class="jd if"> chainDecimals </strong>的幂，通常是12，然后我们将我们的数量乘以这个因子。</p><p id="d447" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，在我们进行下一笔交易之前，我们应该首先确保我们有想要的资金。我们可以像在上一篇文章中那样查询余额，并执行一些简单的计算。但是首先，我们需要将我们的事务分成两部分:<strong class="jd if">创建</strong>和<strong class="jd if">签名</strong>。第一步，我们获得一个事务对象，通过它我们可以查询网络的潜在费用:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="9b7f" class="lm kb ie li b fv ln lo l lp lq"><strong class="li if"><em class="lr">const</em></strong> balance = <strong class="li if">await</strong> api.derive.balances.all(<strong class="li if">medium1</strong>.address);<br/><strong class="li if"><em class="lr">const</em></strong> available = balance.<strong class="li if">availableBalance</strong>;</span><span id="783c" class="lm kb ie li b fv ls lo l lp lq"><strong class="li if"><em class="lr">const</em></strong> transfer = api.tx.balances.transfer(<strong class="li if">medium2</strong>.address, amount)<br/><br/><strong class="li if"><em class="lr">const</em></strong> { <strong class="li if">partialFee</strong> } = await transfer.paymentInfo(<strong class="li if">medium1</strong>);<br/><strong class="li if"><em class="lr">const</em></strong> fees = partialFee.muln(<strong class="li if">110</strong>).divn(<strong class="li if">100</strong>);</span><span id="9644" class="lm kb ie li b fv ls lo l lp lq"><strong class="li if"><em class="lr">const</em></strong> total = amount<br/>    .add(fees)<br/>    .add(api.consts.balances.<strong class="li if">existentialDeposit</strong>);<br/><br/><strong class="li if">if</strong> (total.gt(<strong class="li if">available</strong>)) {<br/>    <strong class="li if"><em class="lr">console</em></strong>.error(`Cannot transfer ${<strong class="li if">amount</strong>} with ${<strong class="li if">available</strong>}`);<br/>} <br/><strong class="li if">else</strong> {<br/>    <strong class="li if"><em class="lr">const</em></strong> txId = <strong class="li if">await</strong> transfer.signAndSend(<strong class="li if">medium1</strong>);<br/>    <strong class="li if"><em class="lr">console</em></strong>.log(`Created transfer: ${txId}`)<br/>}</span></pre><p id="32ce" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们得到交易的费用，并将它们加到我们希望转账的金额上。我们还添加了所谓的<em class="lr">“存在金额”</em>，这是一个帐户在网络中可见所需的最低金额。请注意，当我们查询余额时，API返回的原生类型是<strong class="jd if"> BN </strong>，由于我们也在使用这种类型，所以从现在开始不需要转换它<code class="eh lt lu lv li b"><strong class="jd if">.toNumber()</strong></code>。</p><blockquote class="lw lx ly"><p id="639e" class="jb jc lr jd b je jf jg jh ji jj jk jl lz jn jo jp ma jr js jt mb jv jw jx jy hm dt translated">旁注:大多数BN操作都有一个“n”版本，比如<strong class="jd if"> div </strong>和<strong class="jd if"> divn </strong>、<strong class="jd if"> mul </strong>和<strong class="jd if"> muln </strong>。Theis需要一个数字，而standard需要一个实例。</p></blockquote><p id="39c7" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，唯一可能看起来奇怪的一行是<code class="eh lt lu lv li b"><strong class="jd if">.muln(110).divn(100)</strong></code> <strong class="jd if"> </strong>，我们似乎将最终值乘以<strong class="jd if"> 110 </strong>并除以<strong class="jd if"> 100 </strong>，这实际上是将其乘以<strong class="jd if"> 1.1 </strong>。这直接取自Polkadot.js源代码，这是一个很好的资源，我们将探索如何使用这个API。</p><h1 id="8f52" class="ka kb ie bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">阅读Polkadot.js代码库</h1><p id="52ee" class="pw-post-body-paragraph jb jc ie jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">就从这个开始吧。如果你从<a class="ae jz" rel="noopener" href="/coinmonks/starting-with-polkadot-development-92bba9c993ec">第1部分</a>就开始学习本教程，你应该在本地运行UI。所以去波尔卡多特回购。</p><figure class="ld le lf lg fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mc"><img src="../Images/a18a853cd8042d69a81efd16dde0f457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5d-dK0oYGtg0tkGycElyig.png"/></div></div></figure><p id="2bc4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这个项目中的文件夹是根据URL中定义的页面命名的。当我们从UI创建我们的帐户时，我们处于<strong class="jd if"><em class="lr">#/帐户</em> </strong>页面，因此，从该页面执行的所有功能都可以在page-accounts文件夹中找到。这些动作也是语义命名的，所以<strong class="jd if"> Transfer.tsx </strong>包含了我们想要的代码，如上所示</p><blockquote class="lw lx ly"><p id="1e21" class="jb jc lr jd b je jf jg jh ji jj jk jl lz jn jo jp ma jr js jt mb jv jw jx jy hm dt translated">警告:这个repo中的代码是非常优化的，并且大量基于<a class="ae jz" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React钩子</a>。它可能很难阅读和理解，但我可以向你保证它写得很好，美学上很优雅(是的，有美丽的代码这种东西)。</p></blockquote><p id="7f79" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">本质上，我认为他们所做的是在费用中增加一个任意的分数以确保万无一失。我相信他们的准则。</p><p id="1cb0" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该传输的最终代码如下所示</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="a2d8" class="lm kb ie li b fv ln lo l lp lq"><strong class="li if"><em class="lr">const</em></strong> { ApiPromise, WsProvider } = require('@polkadot/api');</span><span id="a99e" class="lm kb ie li b fv ls lo l lp lq"><strong class="li if"><em class="lr">const</em></strong> { <br/>    mnemonicGenerate, <br/>    mnemonicValidate <br/>} = require('@polkadot/util-crypto');</span><span id="aa8e" class="lm kb ie li b fv ls lo l lp lq"><strong class="li if"><em class="lr">const</em></strong> { Keyring } = require('@polkadot/keyring');<br/><strong class="li if"><em class="lr">const</em></strong> BN = require('bn.js');<br/><br/><strong class="li if">const</strong> connect = async () =&gt; {<br/>    const wsProvider = new WsProvider('ws://127.0.0.1:9944');<br/>    const api = new ApiPromise({ provider: wsProvider });<br/>    return api.isReady;<br/>};<br/><br/><strong class="li if"><em class="lr">const</em></strong> keyring = <strong class="li if"><em class="lr">new</em></strong> Keyring({type: 'sr25519'});<br/><br/><strong class="li if"><em class="lr">const</em></strong> MEDIUM_1 = 'cruel leader remember night skill clump question focus nurse neck battle federal';<br/><br/><strong class="li if"><em class="lr">const</em></strong> createAccount = (mnemonic) =&gt; {<br/>    mnemonic = mnemonic &amp;&amp; mnemonicValidate(mnemonic) <br/>        ? mnemonic <br/>        : mnemonicGenerate();<br/>    const account = keyring.addFromMnemonic(mnemonic);<br/>    return { account, mnemonic };<br/>}<br/><br/><strong class="li if"><em class="lr">const</em></strong> main = async (api) =&gt; {<br/>    <strong class="li if"><em class="lr">console</em></strong>.log(`Our client is connected: ${api.isConnected}`);<br/><br/>    <strong class="li if"><em class="lr">const</em></strong> { account: <strong class="li if">m1</strong> } = createAccount(MEDIUM_1);<br/>    <strong class="li if"><em class="lr">const</em></strong> { account: <strong class="li if">m2</strong>, mnemonic } = createAccount();<br/>    <strong class="li if">console</strong>.log(`New account created with: "${mnemonic}"`);</span><span id="a36f" class="lm kb ie li b fv ls lo l lp lq"><strong class="li if"><em class="lr">    const</em></strong> balance = await api.derive.balances.all(<strong class="li if">m1</strong>.address);</span><span id="eee6" class="lm kb ie li b fv ls lo l lp lq"><strong class="li if"><em class="lr">    const</em></strong> available = balance.<strong class="li if">availableBalance</strong>;</span><span id="f138" class="lm kb ie li b fv ls lo l lp lq">    <strong class="li if"><em class="lr">const</em></strong> decims = new <strong class="li if">BN</strong>(api.registry.chainDecimals);<br/>    <strong class="li if"><em class="lr">const</em></strong> factor = new <strong class="li if">BN</strong>(10).pow(decims);<br/>    <strong class="li if"><em class="lr">const</em></strong> amount = new <strong class="li if">BN</strong>(15).mul(factor);</span><span id="0073" class="lm kb ie li b fv ls lo l lp lq"><strong class="li if"><em class="lr">    const</em></strong> transfer = api.tx.balances.transfer(<strong class="li if">m2</strong>.address, amount)<br/><br/>    <strong class="li if"><em class="lr">const</em></strong> { partialFee } = await transfer.paymentInfo(<strong class="li if">m1</strong>);<br/>    <strong class="li if"><em class="lr">const</em></strong> fees = partialFee.muln(110).divn(100);<br/>    <br/>    <strong class="li if"><em class="lr">const</em></strong> total = amount<br/>        .add(fees)<br/>        .add(api.consts.balances.<strong class="li if">existentialDeposit</strong>);<br/><br/>    if (total.gt(available)) {<br/>        <strong class="li if"><em class="lr">console</em></strong>.error(<br/>            `Cannot transfer ${amount} with ${available} left`<br/>        );<br/>    }<br/>    else {<br/>        <strong class="li if"><em class="lr">const</em></strong> tx = await transfer.signAndSend(<strong class="li if">m1</strong>);<br/>        <strong class="li if"><em class="lr">console</em></strong>.log(`Created transfer: ${tx}`);<br/>    }<br/>};<br/><br/>connect().then(main).catch((err) =&gt; {<br/>    <strong class="li if"><em class="lr">console</em></strong>.error(err)<br/>}).finally(() =&gt; <strong class="li if"><em class="lr">process</em></strong>.exit());</span></pre></div></div>    
</body>
</html>