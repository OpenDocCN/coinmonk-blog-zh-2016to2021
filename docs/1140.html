<html>
<head>
<title>Understanding and creating Blockchains</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解和创造区块链</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/understanding-and-creating-blockchains-86662c8e7516?source=collection_archive---------2-----------------------#2018-07-26">https://medium.com/coinmonks/understanding-and-creating-blockchains-86662c8e7516?source=collection_archive---------2-----------------------#2018-07-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/68c205b80bd9af7b1b2ee04b497a400d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1vcARkQcbNmHa_2m.jpg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Taken from: <a class="ae jf" href="https://www.zdnet.com/article/what-is-the-future-of-blockchain/" rel="noopener ugc nofollow" target="_blank">https://www.zdnet.com/article/what-is-the-future-of-blockchain/</a></figcaption></figure><p id="4504" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我看到很多博客和人们在谈论区块链，但都是以一种非常肤浅的方式。好吧，他们解释说，区块链就像一个分类账，以如此安全方式处理交易，违反它将是一项非常痛苦的任务，但对于一个软件工程师来说，这离很好地理解区块链太远了。</p><p id="b9e3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我有点像杰克，脱衣舞娘，所以让我们按<strong class="ji hu">部分进行:</strong>首先，我们将尝试理解区块链的基本核心<strong class="ji hu">概念</strong>，如交易、采矿和工作证明。然后，我们将<strong class="ji hu">实现</strong> one来看看这些概念在实践中的表现。</p><h1 id="6e60" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">核心概念</h1><p id="f875" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">如果你学过计算机科学，你可能知道一种叫做<strong class="ji hu">链表</strong>的基本数据结构。这种数据结构由节点<strong class="ji hu">、</strong>或<strong class="ji hu">块、</strong>的集合构成，这些节点通过引用相互链接，它们存储某种数据，如整数、字符串等。</p><figure class="li lj lk ll fq iu fe ff paragraph-image"><div class="fe ff lh"><img src="../Images/2a1a5e265ee03b6fcc23d4d083d0a7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/0*Jmya9Ex9eILO0bNC"/></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Taken from: <a class="ae jf" href="http://www.rubyguides.com/2017/08/ruby-linked-list/" rel="noopener ugc nofollow" target="_blank">http://www.rubyguides.com/2017/08/ruby-linked-list/</a></figcaption></figure><p id="bb08" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">区块链与喜欢的列表非常相似:它是彼此链接的节点的集合，但与链表不同，它们通过一种<strong class="ji hu">键</strong>(哈希)链接。也就是说，每个节点都有自己的哈希和邻居节点的哈希。正如那首帕拉摩尔的歌所说，<strong class="ji hu">唯一的例外</strong>是链的第一个节点，叫做<strong class="ji hu">创世纪块</strong>。</p><figure class="li lj lk ll fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lm"><img src="../Images/1604b361a482f78901df65fcfa6c5413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sjwFgVViZzAR3DoL.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Taken from: <a class="ae jf" href="http://racenext.com/blockchain.html" rel="noopener ugc nofollow" target="_blank">http://racenext.com/blockchain.html</a></figcaption></figure><p id="3ace" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">每当一个新的区块链被创建，创世区块也应该被创建。而那些块存储的主要信息是<strong class="ji hu">事务</strong>。交易可以是餐馆付款、银行转账、酒店预订或任何其他期望的情况。</p><p id="1b2f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">回到链表，要在链表中插入数据，我们只需要创建一个新的节点，将一些数据放入该节点，并将其添加到链表中。与区块链的过程也非常相似，不同的是<strong class="ji hu">你不能只是创建一个新的区块</strong>，你必须确保创建的区块需要做很多工作，也就是说，这个过程是困难的。这个过程确保了一个<strong class="ji hu">工作证明</strong>到区块，它被称为<strong class="ji hu">采矿</strong>，因为我们不仅要创建一个区块，还要找到一个合适的区块。很快你就会在实践中看到为什么它需要如此强大的计算能力。</p><p id="2084" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如前所述，存储在块中的主要数据是事务，这里有一些有趣的事情:事务应该在一定的时间间隔内创建，而不是每次都创建，因为这样做有可能实现一种对矿工的奖励系统，当一个新的块被开采时，他们获得一些点，而其他事务被推到一个列表中进行处理。</p><h1 id="221f" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">履行</h1><p id="43e0" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">没有任何实践就阅读这些概念没有多大意义，所以让我们使用ES6特性创建一个Java Script项目并深入研究一下。首先，创建名为区块链的项目:</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="fb3b" class="lt kf ht lp b fv lu lv l lw lx">mkdir blockchain<br/>cd blockchain<br/>npm init -y<br/>touch index.js<br/>npm install --save babel-register<br/>npm install --save-dev babel-preset-es2015<br/>npm install crypto-js<br/>touch .babelrc</span></pre><p id="0ffe" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在里面。babelrc文件增加以下内容:</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="693e" class="lt kf ht lp b fv lu lv l lw lx">{ “presets”:[“es2015”] }</span></pre><p id="f6f8" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在package.json文件的脚本区域添加它:</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="5905" class="lt kf ht lp b fv lu lv l lw lx">"start": "babel-node index.js"</span></pre><p id="31e7" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在我们已经在项目中启用了ES6。</p><p id="b827" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">本质上，我们在这个项目中只有三种模式:交易、区块和区块链。第一个是一个可能的真实世界交易的蓝图，其中某人向另一个人汇款。</p><figure class="li lj lk ll fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="5b55" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">街区是区块链的一个组成部分。I具有从它被创建的时刻起的时间戳、前一节点的散列、它自己的散列和事务列表。</p><figure class="li lj lk ll fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="8660" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">方法<em class="ln"> getHash </em>()只是使用块属性来创建散列。由于我们无法控制它的回报，我们可以利用它来增加采矿工作的证明。如果你查看一下<em class="ln">的mine </em>方法，你会在第17行看到一个名为<strong class="ji hu"> patternOfDifficulty </strong>的变量，这个想法非常简单:我们用一些hash值创建一个块，getHash()方法的返回，然后我们检查第一个<strong class="ji hu"> " <em class="ln">难度</em> " </strong>数字(在我们的例子中是一个数量为9的字符串等于难度)是否等于定义的<strong class="ji hu"> patternOfDifficulty。</strong>如果不是，我们继续运行，直到条件为假，即第一个<strong class="ji hu"><em class="ln">难度</em></strong>数字等于<strong class="ji hu">模式难度。</strong>例如，假设我们得到以下散列:</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="1ffa" class="lt kf ht lp b fv lu lv l lw lx">232#4533829jmz-2038282s21332dshjaxjhajhuaghahdkvacadhakhdkahdk338283</span></pre><p id="1519" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我们的困难等于4，困难的模式是:</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="d900" class="lt kf ht lp b fv lu lv l lw lx">9999</span></pre><p id="e83e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我们得到散列的第一个"<em class="ln">难度"</em>字符，我们得到:</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="b44a" class="lt kf ht lp b fv lu lv l lw lx">232#</span></pre><p id="3c14" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">与模式难度相比:</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="1b66" class="lt kf ht lp b fv lu lv l lw lx">9999 != 232#</span></pre><p id="897a" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们会犯错。所以我们需要重新制作。如果现在得到的散列是:</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="b430" class="lt kf ht lp b fv lu lv l lw lx">9999jfknejfwhfkwnfkwhkfihiemht7et97-29u3oh38hfoahgufgaouyf7g7g7g7g</span></pre><p id="7cc2" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">第一个“<em class="ln">难度”</em>字符现在是:</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="23f0" class="lt kf ht lp b fv lu lv l lw lx">9999 </span></pre><p id="d02d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我们比较模式的困难:</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="2511" class="lt kf ht lp b fv lu lv l lw lx">9999 == 9999</span></pre><p id="952b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">它们匹配，因此我们脱离了循环，开采了一个区块。<strong class="ji hu">难度越高，开采一块的时间就越高。</strong>如果你再看一下Block类，你会在第9行看到属性variable，该属性负责改变<strong class="ji hu"> SHA256 </strong>函数的输出，因为所有其他属性在循环中从不改变。因此，为了激发该函数的不同输出，changeable的值在每次迭代中都会递增。</p><p id="8801" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一旦我们有了事务和块类，我们就可以实现区块链类:</p><figure class="li lj lk ll fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="c066" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如您所见，该类保存了一个块和未决事务的列表。它还有一个属性来指定挖掘难度和对矿工的奖励。</p><p id="5e88" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在构造函数内部，在第3行，当我们声明blocks列表时，我们已经添加了一个块，原因已经在上面说过了，那是genesis块。该块由第9行定义的<em class="ln"> getGenesisBlock() </em>方法创建。该方法只返回一个没有prevHash属性的块实例。</p><p id="4f47" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">有了这些东西，我们就可以开始玩了:让我们创建一个难度为2、采矿奖励为100的名为fancyChain的区块链。然后，我们将在该链中插入两个交易，id为505的人向id为40的人发送100，0美元的金额，他们发送150，0美元的金额。假设有人从他的朋友那里买东西，我们的连锁店正在登记交易。</p><figure class="li lj lk ll fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="800b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我们将fancyChain打印为JSON:</p><figure class="li lj lk ll fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="62e1" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如您所见，它按预期工作:我们的链是用genesis块创建的，两个事务放在那里。现在让我们假设id为31的人试图挖掘一些未决事务，并在挖掘后查看其余额:</p><figure class="li lj lk ll fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="358c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通过这样做，我们的输出将是:</p><figure class="li lj lk ll fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="9bcf" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果看一下这些散列，你会看到前两个字符(难度= 2)是99，就像我们之前定义创建区块链实例一样。再次打印链条，我们得到:</p><figure class="li lj lk ll fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="1079" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">再看一下，你会发现所有这些块，除了来自创世纪的，都存储了前一个块的散列。</p><p id="fed7" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">现在是时候看看为什么区块链注册交易如此安全了。</strong>假设id为40的朋友实际上是一个暴徒，他试图将交易值更改为更高的值，就像这样:</p><figure class="li lj lk ll fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="48a0" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">区块链发生了有趣的事情:<strong class="ji hu">所有的链都失效了。</strong>您可以通过以下方式进行检查:</p><pre class="li lj lk ll fq lo lp lq lr aw ls dt"><span id="ad79" class="lt kf ht lp b fv lu lv l lw lx">console.log(“Is fancyChain valid? “ + fancyChain.isChainValid());</span></pre><p id="7ba7" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果你回头看看区块链类，方法isChainValid()将解释:<strong class="ji hu">一旦事务的值被改变，第49行的If语句将得到false，因为方法getHash()被调用，它使用事务数组来获得它的散列。</strong>因此，只要改变这个值，所有的链都会失效。</p><p id="dd7f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这就是为什么区块链是一个非常安全的注册交易和建立智能合约的工具。</p><h1 id="868c" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">总结</h1><p id="b8e6" class="pw-post-body-paragraph jg jh ht ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hm dt translated">如果你想创建自己的加密硬币、智能合同或以安全的方式处理交易，区块链会非常有用。</p><p id="4115" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如您所见，区块链基本上是存储交易的块的集合，人们可以挖掘这些交易并获得某种积分。</p><p id="92b6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">作为建议，我应该告诉你不要把这个例子用于一个真正的加密系统，这里的意图只是告诉你关于区块链的更深层次的软件理解。给你一个提示，我建议你改变区块链的难度，看看你在电脑里挖一个方块要花多少时间: )</p><p id="c263" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">就这些了，下次见！</p><p id="fda4" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">GitHub上的代码:<a class="ae jf" href="https://github.com/ABuarque/BlockchainArticle" rel="noopener ugc nofollow" target="_blank">https://github.com/ABuarque/BlockchainArticle</a></p></div></div>    
</body>
</html>