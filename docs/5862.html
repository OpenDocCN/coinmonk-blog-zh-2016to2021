<html>
<head>
<title>Blockchain Implementation From Scratch and in a Functional Programming Style</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始以函数式编程风格实现区块链</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/blockchain-implementation-from-scratch-and-in-a-functional-programming-style-ad8d0c424b30?source=collection_archive---------6-----------------------#2021-10-26">https://medium.com/coinmonks/blockchain-implementation-from-scratch-and-in-a-functional-programming-style-ad8d0c424b30?source=collection_archive---------6-----------------------#2021-10-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/32e306a836a1718ad5c0a0bc84d830d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PLJhmA1vZr6uEhK4CfrOCA.gif"/></div></div></figure><p id="e900" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">本文旨在带您从零开始，以函数式编程风格一步步实现区块链和智能契约语言。我们将使用编程语言<a class="ae ka" href="http://www.ats-lang.org/" rel="noopener ugc nofollow" target="_blank"><em class="jz"/></a><em class="jz">。</em></p><p id="aa14" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="jz">完整代码可以在</em> <a class="ae ka" href="https://github.com/gallettilance/ATS-blockchain" rel="noopener ugc nofollow" target="_blank"> <em class="jz">这里找到</em> </a> <em class="jz">。</em></p></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h1 id="488e" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">什么是智能合约？</h1><p id="80e8" class="pw-post-body-paragraph jb jc ht jd b je lg jg jh ji lh jk jl jm li jo jp jq lj js jt ju lk jw jx jy hm dt translated">智能合同允许规避对第三方实体的需要，第三方实体的作用是确保和执行合同得到尊重。例如，考虑用户A想要在区块链上创建一个老虎机，以便用户可以用他们的加密货币赌博。如果没有智能合约，参与这场赌博的风险将超过机器设定的赔率。考虑吃角子老虎只是一个随机数发生器(RNG)。用户B必须相信向A发送硬币将导致运行良好校准的(即，按照玩游戏所达成的心照不宣的契约中指定的那样校准的)RNG。并且，如果B赢了，适当的奖励(如果有的话)将被送过去。</p><p id="fc5b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">用户A可以编写所谓的智能合同来指定投币机的校准和语义，以供用户B在决定参与游戏之前查看。为了确保这些合同得到遵守，它们是用区块链的矿工执行的一种编程语言写成的。此代码的效果和结果在区块链中持续存在(如同普通交易一样),供所有人查看和验证。在这种情况下，用户B不再需要信任任何第三方，并且可以简单地阅读智能合同(就像任何人阅读任何普通合同一样)来理解条款和/或条件。</p></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h1 id="1a76" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">定义区块链类型</h1><p id="df14" class="pw-post-body-paragraph jb jc ht jd b je lg jg jh ji lh jk jl jm li jo jp jq lj js jt ju lk jw jx jy hm dt translated">ATS中的元组是不可变的，由它们的大小静态定义。通过将<strong class="jd hu">块</strong>定义为各种类型的元组，如果我们希望以后扩展我们的区块链数据类型(通过向元组添加一些元素)，类型检查器将很容易捕捉到我们忘记更新的函数。这将使我们代码的未来增强变得非常高效！</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="7249" class="lu kj ht lq b fv lv lw l lx ly">typedef hash = string</span><span id="cb48" class="lu kj ht lq b fv lz lw l lx ly">typedef transaction = (string (* from *), string (* to *), int (* amount *))<br/>typedef data = list0(transaction)</span><span id="4c37" class="lu kj ht lq b fv lz lw l lx ly">typedef contract = (string (* id *), string (* value *))<br/>typedef result = list0(contract)</span><span id="b8ec" class="lu kj ht lq b fv lz lw l lx ly">typedef header = ( <br/>                    (* index *) int, <br/>                    (* nonce *) int, <br/>                    (* transaction data *) data, <br/>                    (* code result *) result, <br/>                    (* prevhash *) hash<br/>                 )</span><span id="91e4" class="lu kj ht lq b fv lz lw l lx ly">typedef block = ( header, (* currhash *) hash, (* timestamp *) string)<br/>typedef chain = list0(block)</span></pre><p id="85de" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一个单独的块将看起来像这样:</p><figure class="ll lm ln lo fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ma"><img src="../Images/68a6809ddd99cbe364c47186ad5eac0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rmp0w1Myt0OziKb-_jLUtw.jpeg"/></div></div></figure><h1 id="929f" class="ki kj ht bd kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb mf ld le lf dt translated">与区块链对接</h1><p id="c10f" class="pw-post-body-paragraph jb jc ht jd b je lg jg jh ji lh jk jl jm li jo jp jq lj js jt ju lk jw jx jy hm dt translated">为了与区块链接口，我们将创建一个简单的CLI。我们希望我们的CLI易于扩展，以包含与区块链交互的新方式。目前，我们希望我们的CLI能够这样工作:</p><ol class=""><li id="414a" class="mg mh ht jd b je jf ji jj jm mi jq mj ju mk jy ml mm mn mo dt translated">定义矿工/用户</li><li id="f4d0" class="mg mh ht jd b je mp ji mq jm mr jq ms ju mt jy ml mm mn mo dt translated">进行交易(有效或无效)</li><li id="14b7" class="mg mh ht jd b je mp ji mq jm mr jq ms ju mt jy ml mm mn mo dt translated">撰写/执行智能合同</li><li id="80a6" class="mg mh ht jd b je mp ji mq jm mr jq ms ju mt jy ml mm mn mo dt translated">决定谁将开采下一个街区</li><li id="dd76" class="mg mh ht jd b je mp ji mq jm mr jq ms ju mt jy ml mm mn mo dt translated">挖掘上面的(它执行事务和代码)</li><li id="64cb" class="mg mh ht jd b je mp ji mq jm mr jq ms ju mt jy ml mm mn mo dt translated">查看用户余额和交易结果</li><li id="3a8a" class="mg mh ht jd b je mp ji mq jm mr jq ms ju mt jy ml mm mn mo dt translated">从1/2开始重复</li></ol><p id="763d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，我们将CLI实现如下:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="ff9f" class="lu kj ht lq b fv lv lw l lx ly">extern<br/>fun<br/>cli_start(lines: stream_vt(string)): void</span><span id="a363" class="lu kj ht lq b fv lz lw l lx ly">extern<br/>fun<br/>cli_do(args: list0(string)): void</span><span id="4e46" class="lu kj ht lq b fv lz lw l lx ly">extern<br/>fun<br/>cli_stop(): void</span><span id="2dd4" class="lu kj ht lq b fv lz lw l lx ly">extern<br/>fun<br/>print_cmds(): void</span><span id="cc20" class="lu kj ht lq b fv lz lw l lx ly">extern<br/>fun<br/>read_loop(lines: stream_vt(string)): void</span><span id="7c55" class="lu kj ht lq b fv lz lw l lx ly">implement<br/>cli_start(lines) = let<br/>  val () = print_cmds()<br/>in<br/>  read_loop(lines)<br/>end</span><span id="7fbe" class="lu kj ht lq b fv lz lw l lx ly">implement<br/>read_loop(lines) = let<br/>  val () = fprint!(stdout_ref,"blockchain&gt; ")<br/>  val-~stream_vt_cons(l, lines) = !lines<br/>  val args = parse_args(l)<br/>in<br/>  case+ args of<br/>  | list0_nil() =&gt; read_loop(lines)<br/>  | list0_cons(a, _) =&gt;<br/>      case+ a of<br/>      | "exit" =&gt; (~lines; ())<br/>      | _ =&gt; (cli_do(args); read_loop(lines))<br/>end</span><span id="b44f" class="lu kj ht lq b fv lz lw l lx ly">implement<br/>cli_do(args) = <br/>  case+ args of<br/>  | list0_nil() =&gt; ()<br/>  | list0_cons(a, args) =&gt;<br/>      case+ a of<br/>      | "balance"       =&gt; do_balance(args)<br/>      | "blockchain"    =&gt; do_blockchain(args)<br/>      | "code"          =&gt; do_code(args)<br/>      | "define"        =&gt; do_define(args)<br/>      | "execute"       =&gt; do_execute(args)<br/>      | "mine"          =&gt; do_mine(args)<br/>      | "transact"      =&gt; do_transact(args)<br/>      | _               =&gt; ()</span></pre><p id="83b1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">用户输入被视为线性流，因此我们的CLI非常节省内存，并保证在CLI终止后不会泄漏任何用户输入。你可以在这里阅读更多关于线性流<a class="ae ka" href="http://ats-lang.github.io/DOCUMENT/INT2PROGINATS/HTML/INT2PROGINATS-BOOK-onechunk.html#programming-with-linear-views-and-types" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="3cb8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">浏览代码，我们看到大部分工作是在<strong class="jd hu"> read_loop </strong>函数中完成的。如果输入是“退出”，那么我们调用<strong class="jd hu"> cli_stop() </strong>并从内存中释放作为输入流的资源。否则，我们调用<strong class="jd hu"> cli_do() </strong>，然后递归调用<strong class="jd hu"> read_loop() </strong>。<strong class="jd hu"> cli_do() </strong>函数非常简单——我们希望尽可能简单地添加功能。这些“do_”函数中的每一个都应该要么在本地写，要么向对等体发送消息。</p><h1 id="4719" class="ki kj ht bd kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb mf ld le lf dt translated">采矿</h1><p id="c8db" class="pw-post-body-paragraph jb jc ht jd b je lg jg jh ji lh jk jl jm li jo jp jq lj js jt ju lk jw jx jy hm dt translated">挖掘包括验证事务和查找使报头散列有效的nonce。</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="bf49" class="lu kj ht lq b fv lv lw l lx ly">extern<br/>fun<br/>mine(hd: header): block</span><span id="f49d" class="lu kj ht lq b fv lz lw l lx ly">(* ****** ****** *)</span><span id="35bf" class="lu kj ht lq b fv lz lw l lx ly">implement<br/>mine(hd) = let <br/>  val (ind, nonce, trns, code, h) = hd<br/>  val theValids = list0_filter(trns, lam(t) =&gt; is_valid_transact(t))<br/>  <br/>  fun aux(hd: header): block = let<br/>      val currh = sha256(encode_header(hd))<br/>    in<br/>      if valid_hash(currh) then (hd, currh, get_time())<br/>      else let<br/>        val (ind, nonce, data, res, prevh) = hd<br/>      in<br/>        aux((ind, nonce + 1, data, res, prevh))<br/>      end<br/>    end<br/>in<br/>  aux((ind, nonce, theValids, code, h))<br/>end</span></pre><p id="da42" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">注意，在递归挖掘块之前，我们使用<strong class="jd hu"> list0_filter </strong>过滤掉无效的事务。<strong class="jd hu"> is_valid_transact() </strong>函数的预期副作用是在验证事务时执行事务。这对于以下情况是必要的:</p><p id="568b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">用户A有2美元，进行了两笔交易:</p><ol class=""><li id="e737" class="mg mh ht jd b je jf ji jj jm mi jq mj ju mk jy ml mm mn mo dt translated">甲给乙寄去1美元</li><li id="9959" class="mg mh ht jd b je mp ji mq jm mr jq ms ju mt jy ml mm mn mo dt translated">甲给丙寄了2美元</li></ol><p id="fa7b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">每笔交易都是有效的，但是两笔交易不能一起执行——否则A的账户将出现负余额。<strong class="jd hu">的副作用是_valid_transact() </strong>一旦事务1被执行，事务2就会失效。我们可以很容易地修改这些交易的执行顺序，以最小化或最大化所需的数量。例如，采矿者可以决定最小化无效交易的数量，或者最大化转移的总量，或者甚至最大化交易的费用总和。</p><p id="bbd1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> mine() </strong>的<a class="ae ka" href="http://ats-lang.github.io/DOCUMENT/INT2PROGINATS/HTML/INT2PROGINATS-BOOK-onechunk.html#tail-call-and-tail-recursion" rel="noopener ugc nofollow" target="_blank">尾递归</a>实现与CLI的内存效率是内联的。此外，请注意，挖掘者希望达到的目标散列在这里是一个以4个零开始的散列，但很容易调整。</p><h1 id="c2b8" class="ki kj ht bd kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb mf ld le lf dt translated">智能合同</h1><p id="ffae" class="pw-post-body-paragraph jb jc ht jd b je lg jg jh ji lh jk jl jm li jo jp jq lj js jt ju lk jw jx jy hm dt translated"><strong class="jd hu">λ演算</strong></p><p id="a46b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们将设计用来创建智能合约的编程语言将基于<a class="ae ka" href="http://www.cs.bu.edu/~hwxi/academic/courses/CS520/Spring18/notes/utlc.pdf" rel="noopener ugc nofollow" target="_blank">非类型化的λ演算</a>。因此，我们的语言将是图灵完备的，但是，正如你将看到的，这将是非常不切实际的，因为定义复杂的函数将是乏味的。</p><p id="6f44" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，让我们定义一个称为“term”的数据类型来表示lambda演算术语。</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="ef0d" class="lu kj ht lq b fv lv lw l lx ly">datatype term =<br/>  | TMint  of  (int)<br/>  | TMstr  of  string<br/>  | TMtup  of  termlst<br/>  | TMproj of  (term, int)<br/>  | TMvar  of  string<br/>  | TMlam  of  (string, term(*body*))<br/>  | TMapp  of  (term(*fun*), term(*arg*))<br/>  | TMfix  of  (string(*f*), string(*x*), term)<br/>  | TMopr  of  (string(*opr*), termlst)<br/>  | TMifnz of  (term(*test*), term(*then*), term(*else*))<br/>  | TMseq  of  (term, term)<br/>  <br/>where termlst = list0(term)</span></pre><p id="2078" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了便于解析我们的语言，我们决定给它以下类似lisp的语法:</p><p id="9220" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">整数</strong> <br/> 1表示为<strong class="jd hu"> (TMint 1) </strong>，2表示为<strong class="jd hu">(TMint 2)</strong>…等等。</p><p id="62ca" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> Bool </strong> <br/>真为<strong class="jd hu"> (TMint 1) </strong>假为<strong class="jd hu"> (TMint 0) </strong></p><p id="50ce" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">字符串</strong> <br/>“你好，世界！”被定义为<strong class="jd hu"> (TMstr你好，世界！)</strong></p><p id="5dc2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">变量</strong> <br/>一个变量x被声明为<strong class="jd hu"> (TMvar x) </strong></p><p id="de4e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">元组</strong> <br/>一个元组(t0，t1，T2)例如被定义为<strong class="jd hu"> (TMtup t0 t1 t2) </strong></p><p id="7bf0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">运算</strong>运算<br/> 2 + 3 + 4定义为</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="945a" class="lu kj ht lq b fv lv lw l lx ly">(TMopr + (TMint 2) (TMint 3) (TMint 4))</span></pre><p id="4eb1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">λ函数</strong> <br/> <em class="jz"> λ </em> x.x + x可以定义为</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="f1d2" class="lu kj ht lq b fv lv lw l lx ly">(TMlam x (TMopr + (TMvar x) (TMvar x)))</span></pre><p id="cea1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">函数应用</strong></p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="830e" class="lu kj ht lq b fv lv lw l lx ly">(TMapp (TMlam x (TMopr + (TMvar x) (TMvar x))) (TMint 1))</span></pre><p id="25cd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">定点</strong> <br/>斐波那契函数可以写成</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="4413" class="lu kj ht lq b fv lv lw l lx ly">(TMfix f x (TMifnz (TMvar x) (TMifnz (TMopr — (TMvar x) (TMint 1)) (TMopr + (TMapp (TMvar f) (TMopr — (TMvar x) (TMint 1))) (TMapp (TMvar f) (TMopr — (TMvar x) (TMint 2))) ) (TMint 1)) (TMint 0)) )</span></pre><p id="91e5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">顺序操作</strong></p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="6ae9" class="lu kj ht lq b fv lv lw l lx ly">let val () = println!(“hello, world!”) in add(2, 3) end</span></pre><p id="6dde" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可以编码为</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="7b23" class="lu kj ht lq b fv lv lw l lx ly">(TMseq (TMopr println (TMstr hello, world!)) (TMapp (TMapp (TMlam y (TMlam x (TMopr + (TMvar x) (TMvar y)) ) ) (TMint 2)) (TMint 3)) )</span></pre><p id="7af5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如你所见，这种语言不适合编码复杂的函数——尽管由于图灵完备性，它是可能的。因此，不鼓励直接用这种语言编写，相反，我们建议从ATS生成lambda代码。这允许扩展lambda语言以允许更简洁的冗长，除此之外，还可以利用ATS的类型检查器和编译器进行静态语法调试。例如，我们可以重载+符号，使两个整数相加的语法更加实用:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="04cd" class="lu kj ht lq b fv lv lw l lx ly">extern<br/>fun<br/>add_term_term<br/>(t1: term, i2: term): term</span><span id="4d08" class="lu kj ht lq b fv lz lw l lx ly">overload + with add_term_term</span></pre><p id="501c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在ATS中，我们现在可以把<strong class="jd hu"> TMint(1) + TMint(1) </strong>写成<strong class="jd hu">(TMopr+(TMint 1)(TMint 1))</strong>。</p><h1 id="24f3" class="ki kj ht bd kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb mf ld le lf dt translated"><strong class="ak">解析器</strong></h1><p id="28f1" class="pw-post-body-paragraph jb jc ht jd b je lg jg jh ji lh jk jl jm li jo jp jq lj js jt ju lk jw jx jy hm dt translated">我们的解析器也非常节省内存，因为它对待解析的文件内容是字符的线性流。一个<strong class="jd hu"> tokenize() </strong>函数将字符流映射到一个字符串流，该字符串流又可以映射到一个术语(通过我们的<strong class="jd hu"> parse_tokens() </strong>函数)，该术语将通过我们将在下面实现的<strong class="jd hu"> interp </strong>函数解释为一个值。</p><p id="dbe7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你可以在这里查看完整的解析实现。</p><h1 id="1830" class="ki kj ht bd kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb mf ld le lf dt translated"><strong class="ak">翻译</strong></h1><p id="febe" class="pw-post-body-paragraph jb jc ht jd b je lg jg jh ji lh jk jl jm li jo jp jq lj js jt ju lk jw jx jy hm dt translated">在我们为lambda语言设计解释器之前，我们需要定义一个<strong class="jd hu">值</strong>数据类型——即被解释的<strong class="jd hu">项</strong>的值。与我们定义lambda term数据类型的方式类似，我们可以将value数据类型定义如下:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="84a8" class="lu kj ht lq b fv lv lw l lx ly">datatype value =<br/>  | VALunit of ()<br/>  | VALint of int<br/>  | VALstr of string<br/>  | VALtup of valuelst<br/>  | VALfix of (term, envir)<br/>  | VALlam of (term, envir)</span><span id="0ec3" class="lu kj ht lq b fv lz lw l lx ly">where<br/>envir = list0($tup(string, value))<br/>and<br/>valuelst = list0(value)</span></pre><p id="5482" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的内容应该是直观的，因为在ATS中，一个整数项的计算结果应该是一个int类型的整数值。</p><p id="548f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在高层次上，我们的解释器将需要评估一个术语的值，而且还要跟踪环境中定义的术语(以便您可以定义变量和函数)。再次使用ATS的模式匹配功能，我们可以如下实现<strong class="jd hu"> interp </strong>功能:</p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="1978" class="lu kj ht lq b fv lv lw l lx ly">implement<br/>interp(t0, env) =<br/>(<br/>case t0 of<br/>| TMint(i) =&gt; VALint(i)<br/>| TMstr(s) =&gt; VALstr(s)<br/>| TMvar(x) =&gt; envir_find(env, x)<br/>| TMlam _ =&gt; VALlam(t0, env)<br/>| TMfix _ =&gt; VALfix(t0, env)<br/>| TMtup(ts) =&gt; VALtup(interp_list(ts, env))<br/>| TMproj(t_tup, i) =&gt; interp_proj(t_tup, env)<br/>| TMapp(t1, t2) =&gt; interp_app(t1, t2, env)<br/>| TMopr _ =&gt; interp_opr(t0, env)<br/>| TMifnz (t1, t2, t3) =&gt; interp_ifnz(t1, t2, t3, env)<br/>| TMseq(t1, t2) =&gt; let val _ = interp(t1, env) in interp(t2, env)<br/>)<br/>end</span></pre><p id="2f27" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">其中<strong class="jd hu"> interp_app </strong>需要添加到环境中。下面是一个TMopr的解释器的例子，<strong class="jd hu"> interp_oper: </strong></p><pre class="ll lm ln lo fq lp lq lr ls aw lt dt"><span id="68f0" class="lu kj ht lq b fv lv lw l lx ly">fun<br/>interp_opr<br/>( t0: term, env: envir): value =<br/>let<br/>val-TMopr(opr, ts) = t0<br/>val vs = list0_map&lt;term&gt;&lt;value&gt;(ts, lam(t) =&gt; interp(t, env))<br/>in<br/>case- opr of<br/>| "+" =&gt;<br/>  (<br/>    case- vs of<br/>    | VALint(i1)::VALint(i2)::nil() =&gt; VALint(i1+i2)<br/>  )</span><span id="809b" class="lu kj ht lq b fv lz lw l lx ly">| "-" =&gt;<br/>  (<br/>    case- vs of<br/>    | VALint(i1)::VALint(i2)::nil() =&gt; VALint(i1-i2)<br/>  )</span><span id="edfc" class="lu kj ht lq b fv lz lw l lx ly">| "print" =&gt;<br/>  (<br/>    case- vs of v0::nil() =&gt;<br/>      (<br/>      let val () =<br/>        case+ v0 of<br/>        | VALunit() =&gt; print("")<br/>        | VALint(i) =&gt; print(i)<br/>        | VALstr(s) =&gt; print(s)<br/>        | VALtup(vs) =&gt; print("VALtup(...)")<br/>        | VALlam(_,_) =&gt; print("VALlam(...)")<br/>        | VALfix(_,_) =&gt; print("VALfix(...)")<br/>      in<br/>        VALunit()<br/>      end<br/>      )<br/>  )</span></pre><p id="33cb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们的TMopr术语解释器可以很容易地扩展，以包含更多的操作符(" * "，" ")等。)和区块链上的事务性操作，或者便于用这种语言编写代码。</p><p id="f534" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这个<strong class="jd hu"> interp </strong>函数的下一步是将术语解释成一个<strong class="jd hu">选项(值)</strong>，其中<strong class="jd hu">选项</strong>是一个具有两个构造函数的数据类型:<strong class="jd hu"> None() </strong>和<strong class="jd hu"> Some(值)</strong>。这样，我们可以为我们的lambda语言实现错误消息。也就是说，如果没有<strong class="jd hu">选项</strong>数据类型，所提供的术语不能被解释为一个值，程序将报告一个运行时类型错误(因为一些期望值的函数将被给定一个术语)。在这种情况下，如果我们期望一个<strong class="jd hu">选项</strong>类型，我们可以使用模式匹配来处理<strong class="jd hu">选项</strong>类型为<strong class="jd hu"> None() </strong>的情况(这是解释器未能将术语转换为值的情况)。</p><p id="de4c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果您认为还可以为此使用异常处理，那么您是正确的。但在这种情况下，不建议这样做，因为不同的lambda误差会产生相同的ATS误差。这意味着要么代码的复杂性会增加，要么从lambda语言接收到的错误消息的质量会降低。</p><h2 id="efc7" class="lu kj ht bd kk mu mv mw ko mx my mz ks jm na nb kw jq nc nd la ju ne nf le ng dt translated">代码生成</h2><p id="9fbb" class="pw-post-body-paragraph jb jc ht jd b je lg jg jh ji lh jk jl jm li jo jp jq lj js jt ju lk jw jx jy hm dt translated">为了好玩，我们用这种lambda语言实现了各种函数，比如斐波那契、阶乘、8皇后等等。每一个。dats文件<a class="ae ka" href="https://github.com/galletti94/ATS-blockchain/tree/master/lambda/example" rel="noopener ugc nofollow" target="_blank">这里的</a>将生成一个. txt文件，其中的代码是用我们的lambda语言编写的，可以被解析和解释以产生一个值。这些文件可以通过<strong class="jd hu"> do_execute() </strong>函数在CLI中访问。目前只有<strong class="jd hu"> do_execute() </strong>执行的文件的返回值存储在区块链上。将来，我们希望将编译后的字节码和结果一起存储到区块链上，以便进行验证。</p></div><div class="ab cl kb kc hb kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hm hn ho hp hq"><h1 id="f1ac" class="ki kj ht bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">结论</h1><p id="63bf" class="pw-post-body-paragraph jb jc ht jd b je lg jg jh ji lh jk jl jm li jo jp jq lj js jt ju lk jw jx jy hm dt translated">许多非常有趣的研究正在区块链的编程语言上进行。一般来说，尤其是在区块链应用程序中，我们希望绝对确定代码会完全按照我们的预期运行——而且是在第一次执行的时候。这是由于</p><ol class=""><li id="d1d4" class="mg mh ht jd b je jf ji jj jm mi jq mj ju mk jy ml mm mn mo dt translated">区块链的不变性，以及代码的无限持久性(及其潜在的错误)</li><li id="35e9" class="mg mh ht jd b je mp ji mq jm mr jq ms ju mt jy ml mm mn mo dt translated">在完全分散的网络上执行运行时测试的困难</li></ol><p id="a540" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">回到吃角子老虎机的例子，如果你误校准了吃角子老虎机，除了为你丢失的硬币哭泣，你什么也做不了——这个错误将永远存在于区块链上，供用户自由利用。为了解决这个问题，许多语言试图将定理证明与编程结合起来。例如，<a class="ae ka" href="http://www.ats-lang.org/" rel="noopener ugc nofollow" target="_blank"> ATS </a>使用类型(更准确地说是<a class="ae ka" href="http://ats-lang.github.io/DOCUMENT/INT2PROGINATS/HTML/INT2PROGINATS-BOOK-onechunk.html#programming-with-dependent-types" rel="noopener ugc nofollow" target="_blank">依赖类型</a>)在编译时(即在运行代码之前)清除潜在的bug。通过特殊的动态函数构造关于代码的数学证明的能力增强了这一点，这些函数只作为编译时的助手存在。这样，可以提供可证明的保证，而不需要运行时测试，并且不影响运行时效率。你可以在ATS <a class="ae ka" href="https://github.com/galletti94/magnificATS/tree/master/INTRO/DepTypesIntro" rel="noopener ugc nofollow" target="_blank">这里</a>找到一些关于依赖类型的介绍性例子，在ATS <a class="ae ka" href="http://ats-lang.github.io/DOCUMENT/INT2PROGINATS/HTML/INT2PROGINATS-BOOK-onechunk.html#theorem-proving_in_ats_lf" rel="noopener ugc nofollow" target="_blank">这里</a>找到一些关于定理证明的介绍性例子。</p><blockquote class="nh"><p id="6eae" class="ni nj ht bd nk nl nm nn no np nq jy ek translated">加入Coinmonks <a class="ae ka" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ka" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h2 id="6048" class="lu kj ht bd kk mu nr mw ko mx ns mz ks jm nt nb kw jq nu nd la ju nv nf le ng dt translated">也阅读</h2><div class="nw nx fm fo ny nz"><a href="https://blog.coincodecap.com/crypto-exchange" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab ej"><div class="ob ab oc cl cj od"><h2 class="bd hu fv z el oe eo ep of er et hs dt translated">最佳加密交易所| 2021年十大加密货币交易所</h2><div class="og l"><h3 class="bd b fv z el oe eo ep of er et ek translated">ICON _ PLACEHOLDEREstimated预计阅读时间:28分钟加密货币交易所的加密交易需要知识…</h3></div><div class="oh l"><p class="bd b gc z el oe eo ep of er et ek translated">blog.coincodecap.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on iz nz"/></div></div></a></div><div class="nw nx fm fo ny nz"><a href="https://blog.coincodecap.com/crypto-lending" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab ej"><div class="ob ab oc cl cj od"><h2 class="bd hu fv z el oe eo ep of er et hs dt translated">2021年10大最佳加密贷款平台| CoinCodeCap</h2><div class="og l"><h3 class="bd b fv z el oe eo ep of er et ek translated">当谈到加密货币贷款时，大量因素等同于良好的收入状况。此外，借款的一部分…</h3></div><div class="oh l"><p class="bd b gc z el oe eo ep of er et ek translated">blog.coincodecap.com</p></div></div><div class="oi l"><div class="oo l ok ol om oi on iz nz"/></div></div></a></div><div class="nw nx fm fo ny nz"><a rel="noopener follow" target="_blank" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a"><div class="oa ab ej"><div class="ob ab oc cl cj od"><h2 class="bd hu fv z el oe eo ep of er et hs dt translated">2021年最佳免费加密交易机器人</h2><div class="og l"><h3 class="bd b fv z el oe eo ep of er et ek translated">2021年币安、比特币基地、库币和其他密码交易所的最佳密码交易机器人。四进制，位间隙…</h3></div><div class="oh l"><p class="bd b gc z el oe eo ep of er et ek translated">medium.com</p></div></div><div class="oi l"><div class="op l ok ol om oi on iz nz"/></div></div></a></div><div class="nw nx fm fo ny nz"><a rel="noopener follow" target="_blank" href="/coinmonks/best-crypto-signals-telegram-5785cdbc4b2b"><div class="oa ab ej"><div class="ob ab oc cl cj od"><h2 class="bd hu fv z el oe eo ep of er et hs dt translated">最佳4个加密交易信号电报通道</h2><div class="og l"><h3 class="bd b fv z el oe eo ep of er et ek translated">这是乏味的找到正确的加密交易信号提供商。因此，在本文中，我们将讨论最好的…</h3></div><div class="oh l"><p class="bd b gc z el oe eo ep of er et ek translated">medium.com</p></div></div><div class="oi l"><div class="oq l ok ol om oi on iz nz"/></div></div></a></div><div class="nw nx fm fo ny nz"><a href="https://blog.coincodecap.com/blockfi-review" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab ej"><div class="ob ab oc cl cj od"><h2 class="bd hu fv z el oe eo ep of er et hs dt translated">BlockFi评论2021:利弊和利率| CoinCodeCap</h2><div class="og l"><h3 class="bd b fv z el oe eo ep of er et ek translated">今天，我们提出了一个全面的BlockFi评论，这是一个成立于2017年的加密贷款平台，拥有其…</h3></div><div class="oh l"><p class="bd b gc z el oe eo ep of er et ek translated">blog.coincodecap.com</p></div></div><div class="oi l"><div class="or l ok ol om oi on iz nz"/></div></div></a></div><div class="nw nx fm fo ny nz"><a rel="noopener follow" target="_blank" href="/coinmonks/buy-bitcoin-in-india-feb50ddfef94"><div class="oa ab ej"><div class="ob ab oc cl cj od"><h2 class="bd hu fv z el oe eo ep of er et hs dt translated">如何在印度购买比特币？2021年购买比特币的7款最佳应用[手机版]</h2><div class="og l"><h3 class="bd b fv z el oe eo ep of er et ek translated">如何使用移动应用程序购买比特币印度</h3></div><div class="oh l"><p class="bd b gc z el oe eo ep of er et ek translated">medium.com</p></div></div><div class="oi l"><div class="os l ok ol om oi on iz nz"/></div></div></a></div><div class="nw nx fm fo ny nz"><a rel="noopener follow" target="_blank" href="/coinmonks/best-crypto-tax-tool-for-my-money-72d4b430816b"><div class="oa ab ej"><div class="ob ab oc cl cj od"><h2 class="bd hu fv z el oe eo ep of er et hs dt translated">加密税务软件——五大最佳比特币税务计算器[2021]</h2><div class="og l"><h3 class="bd b fv z el oe eo ep of er et ek translated">不管你是刚接触加密还是已经在这个领域呆了一段时间，你都需要交税。</h3></div><div class="oh l"><p class="bd b gc z el oe eo ep of er et ek translated">medium.com</p></div></div><div class="oi l"><div class="ot l ok ol om oi on iz nz"/></div></div></a></div><div class="nw nx fm fo ny nz"><a href="https://blog.coincodecap.com/best-hardware-wallet-bitcoin" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab ej"><div class="ob ab oc cl cj od"><h2 class="bd hu fv z el oe eo ep of er et hs dt translated">存储比特币的最佳加密硬件钱包[2021] | CoinCodeCap</h2><div class="og l"><h3 class="bd b fv z el oe eo ep of er et ek translated">保管您的数字资产很容易，但找到正确的存储方式却是一项繁琐的任务。在线钱包有一个风险…</h3></div><div class="oh l"><p class="bd b gc z el oe eo ep of er et ek translated">blog.coincodecap.com</p></div></div><div class="oi l"><div class="ou l ok ol om oi on iz nz"/></div></div></a></div><div class="nw nx fm fo ny nz"><a href="https://blog.coincodecap.com/bitsgap-review" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab ej"><div class="ob ab oc cl cj od"><h2 class="bd hu fv z el oe eo ep of er et hs dt translated">获取信号、交易机器人和套利</h2><div class="og l"><h3 class="bd b fv z el oe eo ep of er et ek translated">在本文中，我们将回顾Bitsgap，这是一个满足您所有交易需求的一站式加密交易平台。它…</h3></div><div class="oh l"><p class="bd b gc z el oe eo ep of er et ek translated">blog.coincodecap.com</p></div></div><div class="oi l"><div class="ov l ok ol om oi on iz nz"/></div></div></a></div></div></div>    
</body>
</html>