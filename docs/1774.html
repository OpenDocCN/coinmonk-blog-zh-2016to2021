<html>
<head>
<title>Encoding Adjustment Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码调整算法</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/encoding-adjustment-algorithm-a-market-driven-script-scaling-solution-54960fe24f2c?source=collection_archive---------4-----------------------#2018-11-12">https://medium.com/coinmonks/encoding-adjustment-algorithm-a-market-driven-script-scaling-solution-54960fe24f2c?source=collection_archive---------4-----------------------#2018-11-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="b9f8" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">市场驱动的脚本扩展解决方案</h2></div><p id="e291" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">比特币现金即将实现强大的操作码OP_CHECKDATASIG，为广泛的新的优秀应用程序打开大门，以促进采用。</p><p id="79e2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一些反对操作码实现的论点不攻自破，而另一些则暗示了关于操作码实现的基本原理的有效问题:</p><ul class=""><li id="83b2" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km dt translated">操作码应该是小的计算原子块还是应该包括大的复杂操作？</li><li id="6446" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated">一个特定的函数在实现为操作码之前应该满足什么标准？</li><li id="174d" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km dt translated">无限期地硬分支添加更多的操作码可行吗？</li></ul><h1 id="883c" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">RISC vs CISC</h1><p id="50e6" class="pw-post-body-paragraph ji jj ht jk b jl lk iu jn jo ll ix jq jr lm jt ju jv ln jx jy jz lo kb kc kd hm dt translated">在完美的世界中，操作码将像处理器指令集一样工作，高级语言将在这个指令集的基础上开发，以创建应用程序。唉，现实世界并不那么美好——操作码有一种持久性，处理器指令没有负担；操作码不仅要执行，还要远距离传播，并无限期地存储在硬盘上。它们受制于带宽和存储的开销。</p><p id="15e3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我们同意像签名验证这样的应用程序应该是廉价和可访问的，那么我们就不可能让它们负担一个兆字节大小的脚本来展开一个复杂的程序。考虑到当前的网络瓶颈，这不仅会给这类应用带来巨大的开销，还会在相当长的一段时间内阻止它们发生。</p><p id="5d68" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">复杂的指令精神在这里获得了彻底的胜利——我们应该实现一个操作码来消除这种荒谬的开销，因为它是签名验证的障碍。</p><p id="a8e6" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然而，同样的恶魔潜伏在下一个角落:当下一个应用程序，例如SNARK验证，开始受到追捧时会发生什么？当用户喜欢新的SNARK操作码，但渴望下一个10，000操作码脚本时，会发生什么？正如许多人正确指出的那样——随着网络规模的增长，它将变得越来越难以硬分叉。不断引入新的操作码是不可行的。一个人必须在某处划清界限，或者逐渐减少他们介绍的频率。</p><h1 id="2f9c" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">编码和压缩</h1><p id="2e64" class="pw-post-body-paragraph ji jj ht jk b jl lk iu jn jo ll ix jq jr lm jt ju jv ln jx jy jz lo kb kc kd hm dt translated">编码是重写数据的一种方式，压缩是减少数据大小的一种编码。解码和解压缩是它们的逆过程。</p><p id="57fd" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在许多压缩方案中，有两个可分离的操作:</p><ol class=""><li id="045d" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd lp kk kl km dt translated">创建代码<a class="ae lq" href="https://en.wikipedia.org/wiki/Dictionary_coder" rel="noopener ugc nofollow" target="_blank">字典</a>。</li><li id="516c" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd lp kk kl km dt translated">将字典应用于数据进行编码。</li></ol><p id="d264" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通常，第一步的计算量很大，而第二步很快。</p><p id="4aa8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">许多压缩方案在算法遍历数据时动态创建字典，这是一个“动态”字典。或者，压缩方案可以利用预先计算的字典。许多人将两者结合使用。</p><p id="1466" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果没有一个预先计算的字典，对小项目的压缩至少可以说是无力的。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff lr"><img src="../Images/b66d3413487262d31c038c12f08b8d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-nWrWxCHTH10_J9GK8LGdw.png"/></div></div><figcaption class="md me fg fe ff mf mg bd b be z ek">7zip on highest settings “compressing” a 518 byte transaction to 634 bytes</figcaption></figure><p id="83c3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在它们适用的情况下，预计算字典的引入比完全动态字典具有优势。</p><ol class=""><li id="af78" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd lp kk kl km dt translated">较小数据(如事务)的压缩有所改进。</li><li id="79f5" class="ke kf ht jk b jl kn jo ko jr kp jv kq jz kr kd lp kk kl km dt translated">压缩/解压缩期间运行时间的减少。</li></ol><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff mh"><img src="../Images/753b127f7122b152066d877a38b79eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZyLDts6IilFIRZoA0tihw.png"/></div></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Example from <a class="ae lq" href="https://github.com/facebook/zstd#the-case-for-small-data-compression" rel="noopener ugc nofollow" target="_blank">Zstandard</a></figcaption></figure><p id="9c19" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">对于那些有技术倾向并且对强大的字典构造技术感兴趣的人，我推荐廖的<a class="ae lq" href="http://gdac.uqam.ca/WWW2016-Proceedings/proceedings/p807.pdf" rel="noopener ugc nofollow" target="_blank">有效构造相关的伦佩尔-齐夫字典</a>。以及其他人</p><h1 id="cc75" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">编码调整算法</h1><p id="d49f" class="pw-post-body-paragraph ji jj ht jk b jl lk iu jn jo ll ix jq jr lm jt ju jv ln jx jy jz lo kb kc kd hm dt translated">在BTC，难度调整算法(DAA)获取开采最后2016个区块所用的时间，并使用它来计算接下来2016个区块的难度(和目标)。由于节点对块有共识，它们也对难度有共识。更一般地，从块中确定性地生成的任何值还可以跨节点一致。</p><p id="55aa" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一个<em class="mi">编码调整算法</em> (EAA)将以这种方式工作。节点将在每N个块的最后N个块的某个确定性样本上训练压缩字典，并因此同意所述字典。</p><p id="2284" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Alice使用她的字典来压缩事务/块，然后通过网络将数据发送给Bob。鲍勃用他的同样的字典解码它。</p><p id="72b3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通过利用Alice和Bob有一个共同的预计算字典这一事实，我们确保了更快的压缩和解压缩以及更高的压缩比。</p><h2 id="bc78" class="mj kt ht bd ku mk ml mm ky mn mo mp lc jr mq mr le jv ms mt lg jz mu mv li mw dt translated">第二层共识</h2><p id="45bb" class="pw-post-body-paragraph ji jj ht jk b jl lk iu jn jo ll ix jq jr lm jt ju jv ln jx jy jz lo kb kc kd hm dt translated">这样的系统不需要(也不应该)在基础协议上实现。压缩和解压缩可以发生在节点软件的边缘。它可以完全选择加入，并且压缩的事务可以被如此标记。</p><h2 id="3ba8" class="mj kt ht bd ku mk ml mm ky mn mo mp lc jr mq mr le jv ms mt lg jz mu mv li mw dt translated">供应、需求和代理代码</h2><p id="f397" class="pw-post-body-paragraph ji jj ht jk b jl lk iu jn jo ll ix jq jr lm jt ju jv ln jx jy jz lo kb kc kd hm dt translated">目前，几乎每个事务在每个输出中都包含一个P2PKH。任何压缩字典肯定会标记这种模式，因此压缩会用单个<em class="mi">代理代码</em>替换操作码的5个字节。在未来，同样的原则将适用于更复杂的操作码模式，大量的脚本将被简化为少数编码频繁出现的模式的代理代码。</p><p id="6a21" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这些代理代码不需要集中管理，它们是通过训练算法根据需求完全自主实现的。也就是说，如果发明了需要特定操作码模式的新应用程序，字典将提供代理代码来满足这一需求。类似地，如果对操作码的特定模式的需求下降，那么字典将停止提供相关的代理代码。</p><p id="f7d8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果一种高级语言是为创建脚本而开发的，并且变得流行，那么它将由字典来补充。</p><h2 id="2569" class="mj kt ht bd ku mk ml mm ky mn mo mp lc jr mq mr le jv ms mt lg jz mu mv li mw dt translated">简短密码学</h2><p id="853f" class="pw-post-body-paragraph ji jj ht jk b jl lk iu jn jo ll ix jq jr lm jt ju jv ln jx jy jz lo kb kc kd hm dt translated">不只是操作码的模式会享受缩短的表示。当孤立地考虑时，加密字符串是非常高熵的(散列通过构造最大化地如此)，跨块，加密字符串将重复。例如，在特定的oracle用pubkey重复签署脚本或者大公司用特定的标识符标记它们的OP_RETURNS的情况下，这些字符串将保证字典中的“快速拨号”。</p><h2 id="06b0" class="mj kt ht bd ku mk ml mm ky mn mo mp lc jr mq mr le jv ms mt lg jz mu mv li mw dt translated">辅之以治理</h2><p id="ef92" class="pw-post-body-paragraph ji jj ht jk b jl lk iu jn jo ll ix jq jr lm jt ju jv ln jx jy jz lo kb kc kd hm dt translated">如果一个人的路线图坚持的话，这个模型仍然与开发团队引入操作码兼容。假设对特定功能的即时需求出现，EAA将允许市场在共识级操作码的发布日期之前开始实现该功能，而没有大量开销。</p><h2 id="475f" class="mj kt ht bd ku mk ml mm ky mn mo mp lc jr mq mr le jv ms mt lg jz mu mv li mw dt translated">定价启发法的补充</h2><p id="9cdd" class="pw-post-body-paragraph ji jj ht jk b jl lk iu jn jo ll ix jq jr lm jt ju jv ln jx jy jz lo kb kc kd hm dt translated">随着脚本大小的增长，satoshi/byte脚本定价方法将越来越难以估计执行的真实价格。可以针对代理代码字典来设计定价试探法。对编码字典的调整可以与定价的可预测的重新计算相匹配(由函数式编程/范畴理论爱好者的某种仿函数实例化)。这将使定价试探法自然发展，同时最小化开销并最大化适用性。</p><h2 id="5f0a" class="mj kt ht bd ku mk ml mm ky mn mo mp lc jr mq mr le jv ms mt lg jz mu mv li mw dt translated">孤儿和重组</h2><p id="0c1a" class="pw-post-body-paragraph ji jj ht jk b jl lk iu jn jo ll ix jq jr lm jt ju jv ln jx jy jz lo kb kc kd hm dt translated">如果两个节点不能在N块采样窗口内就块达成一致，那么它们将不能在字典上达成一致，并因此向彼此发送乱码事务。</p><p id="12ae" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这很容易通过防止从N块窗口中的最近块中采样训练集来纠正。这个填充应该选择得足够大，以允许字典上一致性失败的概率可以忽略不计。</p><h2 id="c787" class="mj kt ht bd ku mk ml mm ky mn mo mp lc jr mq mr le jv ms mt lg jz mu mv li mw dt translated">仅压缩一次</h2><p id="e662" class="pw-post-body-paragraph ji jj ht jk b jl lk iu jn jo ll ix jq jr lm jt ju jv ln jx jy jz lo kb kc kd hm dt translated">只有发起者需要压缩事务/块，其他人只需要解压缩它。这就需要考虑数据压缩的对称性。作为参考点，Zstandard的解压速度是压缩速度的3倍左右。</p><h2 id="c0af" class="mj kt ht bd ku mk ml mm ky mn mo mp lc jr mq mr le jv ms mt lg jz mu mv li mw dt translated">SPV兼容性</h2><p id="1845" class="pw-post-body-paragraph ji jj ht jk b jl lk iu jn jo ll ix jq jr lm jt ju jv ln jx jy jz lo kb kc kd hm dt translated">该方案与SPV兼容——当钱包的字典过期时，钱包会发送请求以获取最新的字典。不像块头，整个字典链不需要被转移。</p><p id="f05a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">交易的编码应该足够快，即使是移动钱包也能在几毫秒内完成。字典应该足够大，以确保良好的压缩，但也要足够小，以每N个块传输到钱包，而不会有很大的开销。字典可以做得很小(字节/千字节)，同时仍然保证很大的压缩率。</p><p id="59ef" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">可以使用不同的词典来满足特定的需要。可以想象一个节点根据钱包活动向SPV用户提供特定的字典。同样，必须考虑数据压缩的对称性。</p><h2 id="e5e8" class="mj kt ht bd ku mk ml mm ky mn mo mp lc jr mq mr le jv ms mt lg jz mu mv li mw dt translated">块是过滤器和一些事务</h2><p id="7de6" class="pw-post-body-paragraph ji jj ht jk b jl lk iu jn jo ll ix jq jr lm jt ju jv ln jx jy jz lo kb kc kd hm dt translated">借助紧凑块、Xthin和Graphene等集合协调技术，节点不再需要中继整个块，而是中继接收者mempool中丢失的少量事务以及订单信息。</p><p id="415a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">假设爱丽丝正试图通过石墨烯给鲍勃发送一个块。在“打开”IBLT时，发现Bob从他的mempool中丢失了很少的事务(可能的情况)。这几个事务需要从Alice转发给Bob，并且很可能在所有转发的数据中占相当大的百分比。鉴于这些事务的高熵，没有预先计算的字典的压缩将是蹩脚的，因此EAA也可以对块传播有相当大的帮助。</p><h1 id="9ea5" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">结束语</h1><p id="4e9c" class="pw-post-body-paragraph ji jj ht jk b jl lk iu jn jo ll ix jq jr lm jt ju jv ln jx jy jz lo kb kc kd hm dt translated">我们已经为降低网络/存储开销的方案奠定了基础，该方案以交易和块内特定模式的市场需求为导向。</p><p id="9c1d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">下一步是建立这样一个系统的模型，以测量压缩比以及压缩和解压速度。我们的目标是在各种区块链上进行这些测试，以评估其性能。任何愿意从他们的完整节点捐赠数据的人都会受到感谢。</p><blockquote class="mx"><p id="6344" class="my mz ht bd na nb nc nd ne nf ng kd ek translated"><a class="ae lq" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="ni nj nk nl nm lw fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nh"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>