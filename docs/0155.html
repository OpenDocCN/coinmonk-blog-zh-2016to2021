<html>
<head>
<title>A Gentle Introduction to Building a Full Stack DApp on Ethereum — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊上构建全栈DApp的温和介绍—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-gentle-intro-to-building-a-full-stack-dapp-on-ethereum-part-3-c48e99b4d3e8?source=collection_archive---------2-----------------------#2018-03-10">https://medium.com/coinmonks/a-gentle-intro-to-building-a-full-stack-dapp-on-ethereum-part-3-c48e99b4d3e8?source=collection_archive---------2-----------------------#2018-03-10</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="8717" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">在第2部分中，我们将使用React和uPort与智能合约进行交互，并使用IPFS进行数据存储。</h2></div><blockquote class="ji jj jk"><p id="8648" class="jl jm jn jo b jp jq iu jr js jt ix ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">这是系列文章的第2部分。第一部分可以在这里找到<a class="ae ki" rel="noopener" href="/p/c1aedb11fcd2">。</a></p></blockquote><p id="bb29" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">React应用程序的结构相当简单。主要的React组件是包含登录功能的<code class="eh km kn ko kp b">App.js</code>和可以输入和查看数据的<code class="eh km kn ko kp b">Dashboard.js</code>。</p><h1 id="f5dc" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">关于uPort:</h1><p id="93e7" class="pw-post-body-paragraph jl jm ht jo b jp li iu jr js lj ix ju kj lk jx jy kk ll kb kc kl lm kf kg kh hm dt translated">uPort是一个身份管理系统，它也使得登录和与以太坊dapps交互变得容易。uPort将您的私钥安全地存储在您的手机上，并使用它来签署交易。在这里阅读更多<a class="ae ki" href="https://www.uport.me/" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ln"><img src="../Images/316c51ed975e1ea6ca21493b80db21ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5xrNAWXMPT2x8XBBaT88g.jpeg"/></div></div></figure><p id="e518" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">要开始使用uPort，请在您的移动设备上下载uPort应用程序并创建您的身份。</p><p id="370d" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">回到项目文件中。看看文件:util/Uport.js这是让我们与Uport通信、获取用户身份并登录应用程序的代码。</p><p id="868f" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">uPort使用已经通过以下方式导入的<code class="eh km kn ko kp b">uport-connect</code> npm包:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="261c" class="md kr ht kp b fv me mf l mg mh">npm install uport-connect --save</span></pre><p id="bd4c" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">在<code class="eh km kn ko kp b">Uport.js</code>的顶部，我们导入<code class="eh km kn ko kp b">uport-connect</code>，然后创建一个uPort的实例:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="6c00" class="md kr ht kp b fv me mf l mg mh">import { Connect, SimpleSigner, MNID } from 'uport-connect'</span><span id="478b" class="md kr ht kp b fv mi mf l mg mh">const uport = new Connect('React uPort IPFS DApp', {<br/>    clientId: '2omYPjiPUiR6jyNdSZRHgbpn9PxiVqbtVsR',<br/>   network:'rinkeby',<br/> signer:SimpleSigner('ab1d56711bcf6f7ded8a8b7f768d59e8f3d3a168b75b037848aa142b93e4998f')})</span></pre><p id="64c3" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">上面的密钥来自我在uPort注册的一个示例应用程序，但是你会想要在这里为你的应用程序创建你自己的身份:<a class="ae ki" href="https://developer.uport.me/myapps.html" rel="noopener ugc nofollow" target="_blank">https://developer.uport.me/myapps.html</a>。添加您的应用程序后，您将看到类似上面的代码，其中包含您的应用程序密钥。您可以复制并粘贴上面的代码。</p><p id="afc4" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">为了简单起见，我们将这些密钥存储在前端应用程序中，但在生产中，您可以将它们安全地存储在服务器上。参见<a class="ae ki" href="https://developer.uport.me/guides.html" rel="noopener ugc nofollow" target="_blank">升级文档</a>了解如何操作。</p><p id="3be1" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">下一个代码块用于请求凭证:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="478a" class="md kr ht kp b fv me mf l mg mh">const initAccount = async () =&gt; {</span><span id="f893" class="md kr ht kp b fv mi mf l mg mh">   const user = await uport.requestCredentials({<br/>      requested: ['name', 'country', 'avatar'],<br/>      notifications: true<br/>   })</span><span id="84dc" class="md kr ht kp b fv mi mf l mg mh">    // get user details<br/>   const decodedId = MNID.decode(user.address)<br/>   const specificNetworkAddress = decodedId.address<br/>   return { specificNetworkAddress, user }</span><span id="a6d7" class="md kr ht kp b fv mi mf l mg mh">}</span></pre><p id="720f" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">当调用<code class="eh km kn ko kp b">initAccount()</code>时，uPort会将html注入到包含二维码的页面中。你用uPort手机app扫描二维码。完成后，用户对象将被填充您所请求的uPort身份详细信息。这还会在您的手机和应用程序之间建立推送通知连接，因此无论何时从应用程序发起交易，您的移动设备都会提示您接受交易。</p><p id="8398" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">还要注意底部的出口。uPort使用自己的web3实现，通过uPort检测和处理事务。</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="c82b" class="md kr ht kp b fv me mf l mg mh">const web3 = uport.getWeb3()<br/>export { web3, uport, MNID, initAccount }</span></pre><p id="b52f" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">点击登录按钮时，从<code class="eh km kn ko kp b">App.js</code>调用<code class="eh km kn ko kp b">initAccount()</code>。如下面的代码所示，React状态随后被用户身份数据填充。<code class="eh km kn ko kp b">specificNetworkAddress</code>是我们将用来传递给智能合同的用户地址。<code class="eh km kn ko kp b">Avatar</code>是在uPort中设置的用户图像。<code class="eh km kn ko kp b">userName</code>是uport中设置的名称。</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="1005" class="md kr ht kp b fv me mf l mg mh">handleLogin = async (e) =&gt; {<br/>   e.preventDefault();<br/>   const identity = await initAccount();<br/>   this.setState({<br/>      specificNetworkAddress: identity.specificNetworkAddress,<br/>      userName: identity.user.name,<br/>      avatar: identity.user.avatar.uri<br/>   })<br/>}</span></pre><p id="b009" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">调用<code class="eh km kn ko kp b">handleLogin</code>并返回身份后，用户名和地址出现在屏幕上，并出现仪表板屏幕。</p><p id="d749" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">另外，看看App.js中的这段代码:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="08b0" class="md kr ht kp b fv me mf l mg mh">{this.state.userName ? (<br/>  &lt;Dashboard<br/>  specificNetworkAddress={this.state.specificNetworkAddress} /&gt;<br/>)</span></pre><p id="14ed" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">这表示当<code class="eh km kn ko kp b">userName</code>设置为状态时，显示仪表板组件并传入用户地址。</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ln"><img src="../Images/95af74267a6f35a6c2de69d91bfef451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-PIZCBjloRGfqbRGjQkeLw.jpeg"/></div></div></figure><h2 id="1cc7" class="md kr ht bd ks mj mk ml kw mm mn mo la kj mp mq lc kk mr ms le kl mt mu lg mv dt translated">在我们继续学习仪表板组件之前，让我们回顾一下IPFS:</h2><p id="e368" class="pw-post-body-paragraph jl jm ht jo b jp li iu jr js lj ix ju kj lk jx jy kk ll kb kc kl lm kf kg kh hm dt translated">IPFS是一个对等超媒体协议。可以把它想象成一个分散的http协议，在这里你可以存储http可以存储的任何东西:文件、图像、html等等。任何人都可以轻松地将一个节点设置为IPFS主机。在我们的例子中，我们将使用一个远程节点，Infura已经慷慨地向公众提供了这个节点。</p><p id="c492" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">IPFS文件是用一个散列存储的，我们也可以用它来检索这些文件。哈希是基于文件内容创建的。如果文件中的任何内容发生变化，就会返回一个不同的散列值，实际上使文件防篡改。</p><p id="cc32" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">IPFS是以太坊dapps的完美搭配。以太坊上的存储很贵。我们可以通过存储可以连接到无限量数据的IPFS哈希来缓解这一问题。</p><p id="8a89" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">请记住，任何人都可以阅读IPFS的文件。如果你需要隐私，你需要在保存到IPFS之前以某种方式加密你的数据。</p><p id="d9a7" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">我们将利用方便的npm库<code class="eh km kn ko kp b">ipfs-mini</code>来简化IPFS文件的存储和检索。在项目文件中，打开文件:<code class="eh km kn ko kp b">util/IPFS.js</code></p><p id="c279" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">在第1行，我们要求<code class="eh km kn ko kp b">ipfs-mini</code>使用以下方式安装:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="601c" class="md kr ht kp b fv me mf l mg mh">npm install ipfs-mini --save</span></pre><p id="f8b6" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">第2行创建了一个ipfs-mini实例，并传入了我们将与之交互的ipfs地址。在我们的例子中，这是使用<code class="eh km kn ko kp b">https</code>协议的端口<code class="eh km kn ko kp b">5001</code>上的<code class="eh km kn ko kp b">ipfs.infura.io</code>。</p><p id="9fe6" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">两个主要的函数<code class="eh km kn ko kp b">setJSON</code>和<code class="eh km kn ko kp b">getJSON</code>顾名思义使用了承诺，所以我们稍后可以用async/await调用它们，如后面所见。</p><p id="cbfc" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">IPFS.js的完整代码在这里:</p><p id="ee92" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated"><a class="ae ki" href="https://gist.github.com/zerostatic/3bcde0ca318386c1b09fa0dfec74bd17" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/zero static/3 bcde 0 ca 318386 C1 b 09 fa 0 dfec 74 BD 17</a></p><h2 id="c1ef" class="md kr ht bd ks mj mk ml kw mm mn mo la kj mp mq lc kk mr ms le kl mt mu lg mv dt translated">接下来是最后一个组件:仪表板</h2><p id="5523" class="pw-post-body-paragraph jl jm ht jo b jp li iu jr js lj ix ju kj lk jx jy kk ll kb kc kl lm kf kg kh hm dt translated">打开文件:<code class="eh km kn ko kp b">Dashboard.js</code>在导入中，您会看到我们正在导入上面刚刚描述的两个函数:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="d8ff" class="md kr ht kp b fv me mf l mg mh">import { setJSON, getJSON } from './util/IPFS.js'</span></pre><p id="bb37" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">我们还导入了一个组件，该组件在挖掘事务时显示加载动画。我不会详细说明加载器是如何创建的，但是当用户在以太坊上进行交易时，你应该总是有一个加载动画和/或消息，因为交易可能需要15秒或更长时间。</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="3f4e" class="md kr ht kp b fv me mf l mg mh">import Loader from "./Loader"</span></pre><p id="ecbc" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">接下来，为了与智能合约进行交互，我们将从之前讨论过的<code class="eh km kn ko kp b">DetailsService.js</code>中导入两个函数:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="fdcf" class="md kr ht kp b fv me mf l mg mh">import { setContractHash, getContractHash } from './services/DetailsService';</span></pre><p id="830b" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">在构造函数中，您将看到我们将使用的状态属性。带内嵌注释:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="4f4f" class="md kr ht kp b fv me mf l mg mh">this.state = {<br/>   myData: "", // The text the user enters in the textfeild<br/>   ipfsData: "", // The text returned from IPFS<br/>   timestamp: "", // Timestamp returned from the contract<br/>   loading: false // Boolean to used to display loading animation<br/>}</span></pre><p id="8399" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">接下来，看看点击提交时调用的<code class="eh km kn ko kp b">handleSubmit</code>函数。我们将回顾下面的重要内容:</p><figure class="lo lp lq lr fq ls"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="3faf" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">首先，我们将通过将<code class="eh km kn ko kp b">loading</code>状态设置为true来为用户显示加载动画:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="b1f7" class="md kr ht kp b fv me mf l mg mh">this.setState({ loading: true });</span></pre><p id="a172" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">然后，我们将数据存储在IPFS，并获取与该数据相关的哈希:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="5365" class="md kr ht kp b fv me mf l mg mh">const hash = await setJSON({ myData: this.state.myData });</span></pre><p id="1561" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">该行调用前面解释的<code class="eh km kn ko kp b">IPFS.js</code>中的<code class="eh km kn ko kp b">setJSON</code>函数。我们传递给它一个简单的对象，带有一个键<code class="eh km kn ko kp b">myData</code>和一个来自输入字段的文本值:<code class="eh km kn ko kp b">this.state.myData</code>因为我们使用的是async/await，这个函数将在这里等待，直到从IPFS服务返回一个散列字符串或错误。</p><p id="72d4" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">一旦返回一个散列，我们将把该散列存储在用户地址下的合同中，如下行所示:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="ca4f" class="md kr ht kp b fv me mf l mg mh">await setContractHash(this.props.specificNetworkAddress, hash);</span></pre><p id="4286" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">如果有任何错误，我们将提醒用户并删除加载动画:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="2a5a" class="md kr ht kp b fv me mf l mg mh">this.setState({ loading: false });<br/>alert("There was an error with the transaction.");</span></pre><p id="eb25" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">在函数的最后，我们将调用<code class="eh km kn ko kp b">this.fetchData()</code>来显示我们刚刚通过IPS hash保存到以太坊的数据。让我们来看看这个函数:</p><figure class="lo lp lq lr fq ls"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="7a82" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">函数中的第一行，我们调用<code class="eh km kn ko kp b">getContractHash</code>并传递给它我们的以太坊地址，等待它返回我们的数据。一旦数据从智能契约返回，我们将把它存储到<code class="eh km kn ko kp b">contractDetails</code>变量中。</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="6aba" class="md kr ht kp b fv me mf l mg mh">const contractDetails = await getContractHash(this.props.specificNetworkAddress);</span></pre><p id="bf57" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">接下来，我们将IPFS散列和时间戳存储到变量中:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="7bfd" class="md kr ht kp b fv me mf l mg mh">const ipfsHash = contractDetails[0];<br/>if (!ipfsHash) { return } //  if no hash store at this address<br/>const timestamp = contractDetails[1].c[0];</span></pre><p id="5d13" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">然后我们获取与IPFS散列相关的数据:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="1df7" class="md kr ht kp b fv me mf l mg mh">const details = await getJSON(ipfsHash);</span></pre><p id="8bf6" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">一旦有了这些，我们就将用户数据和时间戳设置到状态中，然后将这些数据显示在屏幕上:</p><pre class="lo lp lq lr fq lz kp ma mb aw mc dt"><span id="ba16" class="md kr ht kp b fv me mf l mg mh">this.setState({ ipfsData: details, loading: false, timestamp })</span></pre><h2 id="95a4" class="md kr ht bd ks mj mk ml kw mm mn mo la kj mp mq lc kk mr ms le kl mt mu lg mv dt translated">就这样结束了！</h2><p id="f8cb" class="pw-post-body-paragraph jl jm ht jo b jp li iu jr js lj ix ju kj lk jx jy kk ll kb kc kl lm kf kg kh hm dt translated">你现在已经有了开始你自己的以太坊dapp的基础工作知识！</p><p id="19df" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated">要深入了解这些技术，请访问以下链接:</p><p id="e7d2" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated"><a class="ae ki" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a> —前端库<br/> <a class="ae ki" href="https://solidity.readthedocs.io/en/develop/" rel="noopener ugc nofollow" target="_blank"> Solidity </a> —用于构建运行在以太坊<br/> <a class="ae ki" href="http://truffleframework.com/" rel="noopener ugc nofollow" target="_blank"> Truffle </a>上的智能合约的语言——编译、迁移和测试智能合约的框架。<br/> I <a class="ae ki" href="https://ipfs.io/" rel="noopener ugc nofollow" target="_blank"> PFS </a> —分散存储<br/> <a class="ae ki" href="https://www.uport.me/" rel="noopener ugc nofollow" target="_blank"> uPort </a> —身份管理、数字签名交易和轻松登录dapps。</p><p id="42ef" class="pw-post-body-paragraph jl jm ht jo b jp jq iu jr js jt ix ju kj jw jx jy kk ka kb kc kl ke kf kg kh hm dt translated"><em class="jn">此处表达的所有代码和观点</em><em class="jn">都是我自己的，而不是我雇主的观点。</em></p><blockquote class="my"><p id="dc6a" class="mz na ht bd nb nc nd ne nf ng nh kh ek translated"><a class="ae ki" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nj nk nl nm nn ls fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ni"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>