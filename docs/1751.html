<html>
<head>
<title>Merkle tree 101!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">默克尔树101！</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/merkle-tree-101-a3ca025dc318?source=collection_archive---------0-----------------------#2018-11-04">https://medium.com/coinmonks/merkle-tree-101-a3ca025dc318?source=collection_archive---------0-----------------------#2018-11-04</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="5cde" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我遇到术语<strong class="is hu">‘区块链’，</strong>时，第一件引起我兴趣的事情是，“<strong class="is hu">为什么区块链为数据</strong>提供安全性和不变性？”。所以，找到答案的最好方法就是做一些研究。</p><p id="0bd0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">研究时间:</strong>当我浏览不同的文章时，每次弹出的术语都是Merkle tree以及它如何使用密码学的力量和<strong class="is hu">“树”</strong>数据结构来为区块链提供不变性。但是在理解Merkle树如何工作之前，我们首先需要熟悉Hash指针。我们在c语言中学习指针的时候一定都挠过头，指针是存储其他变量地址的简单变量。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/1f20ccf08fcded92df409d26ba8296e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*79czQT-H5HRaSgZpksnIug.png"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Pointer P1 stores the address of value 8000 i.e. 5000(address of 8000)</figcaption></figure><p id="e8c8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">那么，散列指针到底是什么？</strong></p><p id="94c4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，哈希指针是一个具有加密哈希附加属性的指针。哈希指针由两部分组成:</p><ul class=""><li id="decc" class="ka kb ht is b it iu ix iy jb kc jf kd jj ke jn kf kg kh ki dt translated">指向某些数据存储位置的指针。</li><li id="7d63" class="ka kb ht is b it kj ix kk jb kl jf km jj kn jn kf kg kh ki dt translated">数据块的加密哈希(由数据和哈希指针组成)。</li></ul><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff ko"><img src="../Images/626a18f05c5d862ef8902b953b98400b.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*31yg7cpXI7iAv808ro2OGw.png"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Hash Pointer</figcaption></figure><p id="9432" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">那又怎样？现在是最精彩的部分。哈希指针有助于检测数据篡改。让我们来看看:</strong></p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="fe ff kp"><img src="../Images/6c5764095c5b7224edd8d79692ca3aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*roZB3Qf61_5kLSigNdHPYg.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Use Case: Hash pointer for detection of data tampering.</figcaption></figure><p id="9f2e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt ku translated"><span class="l kv kw kx bm ky kz la lb lc di">T</span>T<strong class="is hu">终端学</strong></p><ul class=""><li id="cb5b" class="ka kb ht is b it iu ix iy jb kc jf kd jj ke jn kf kg kh ki dt translated"><strong class="is hu"> H( ): </strong> hash指针，包含第一个块(即最右边的块)的地址和存储在那里的整个块的加密哈希(数据+hash指针)。</li><li id="086f" class="ka kb ht is b it kj ix kk jb kl jf km jj kn jn kf kg kh ki dt translated"><strong class="is hu"> H1、H2、H3 </strong>:散列指针存储在从右向左移动的块中。</li><li id="31f7" class="ka kb ht is b it kj ix kk jb kl jf km jj kn jn kf kg kh ki dt translated">块1、块2、块3:数据块，从右向左移动。</li></ul><p id="6a1b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在假设我们改变了块3中的一些数据。</p><ul class=""><li id="3fcc" class="ka kb ht is b it iu ix iy jb kc jf kd jj ke jn kf kg kh ki dt translated">因为H2存储了block3的加密哈希。H2的值也改变，并且随后其它散列指针的值也改变。</li><li id="2a96" class="ka kb ht is b it kj ix kk jb kl jf km jj kn jn kf kg kh ki dt translated">现在，我们如何检查数据是否被篡改了？我们需要验证的只是头指针的散列指针值(在本例中，最右边的H()指向block1)。如果值不匹配，则意味着数据已被篡改。</li></ul></div><div class="ab cl ld le hb lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hm hn ho hp hq"><p id="70cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">最后Merkle树</strong></p><p id="5009" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们有了理解Merkle树的工具。什么是merkle树？让我们来看看:</p><blockquote class="lk ll lm"><p id="70c3" class="iq ir ln is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hm dt translated">根据维基百科:在密码学和计算机科学中，哈希树或Merkle树是这样一种树，其中每个叶节点都用数据块的哈希来标记，每个非叶节点都用其子节点标签的密码哈希来标记。</p></blockquote><p id="63ab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">简单的树数据结构使用指针来指向它的子节点，但是在Merkle树的情况下，我们使用散列指针来存储它的子节点的地址以及子节点的散列。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="fe ff lr"><img src="../Images/fccd9acfca00baaeeb14e5ef679daf8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GM8IMQ6KZ0mkQJmj1fIGFA.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Blockchain using merkle tree to store transaction.</figcaption></figure><p id="da22" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Merkle树是如何提供不变性的？</p><ul class=""><li id="2e7c" class="ka kb ht is b it iu ix iy jb kc jf kd jj ke jn kf kg kh ki dt translated">假设我更改了叶节点中的任何事务。然后，其父节点中的哈希指针也需要更改，随后根节点中的哈希指针也需要更改，这需要大量的计算，我们检测区块链中的任何篡改所需要做的就是验证起源块(区块链中的第一个块)的哈希指针。</li><li id="676b" class="ka kb ht is b it kj ix kk jb kl jf km jj kn jn kf kg kh ki dt translated">Merkle树还用于通过检查特定块中事务的加密散列的存在来验证该块中事务的成员资格。</li></ul><p id="e556" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">优势部分:</strong></p><ul class=""><li id="05f7" class="ka kb ht is b it iu ix iy jb kc jf kd jj ke jn kf kg kh ki dt translated">树包含许多条目，但是你只需要记住根节点的加密散列。</li><li id="f750" class="ka kb ht is b it kj ix kk jb kl jf km jj kn jn kf kg kh ki dt translated">可以在0(log n)时间/空间复杂度内验证事务的成员资格。</li><li id="0353" class="ka kb ht is b it kj ix kk jb kl jf km jj kn jn kf kg kh ki dt translated">可以在0(log n)时间内在排序的merkle树中验证非成员资格(检查丢失项前后的项)。</li></ul><blockquote class="ls"><p id="5472" class="lt lu ht bd lv lw lx ly lz ma mb jn ek translated"><a class="ae mc" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="me mf mg mh mi jt fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff md"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>