<html>
<head>
<title>Chain replication : how to build an effective KV-storage (part 1/2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链式复制:如何构建有效的KV存储(第1/2部分)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/chain-replication-how-to-build-an-effective-kv-storage-part-1-2-b0ce10d5afc3?source=collection_archive---------1-----------------------#2018-11-22">https://medium.com/coinmonks/chain-replication-how-to-build-an-effective-kv-storage-part-1-2-b0ce10d5afc3?source=collection_archive---------1-----------------------#2018-11-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="7115" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这篇文章中，我将考虑一个使用链式复制的简单有效的KV存储系统设计。链式复制(CR)已被证明具有良好的性能，正在积极研究中。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/43626c57bb1fa5165abfcc1fd6fb2bdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yHzNrDRZHvSeVTdqYcngIQ.png"/></div></div></figure><p id="2f55" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是这篇大文章的第一部分(这里是第二部分),组织如下:首先，我们将讨论一般方法，然后我们将考虑实现:</p><ol class=""><li id="2195" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">陈述问题，并将CR与主要/备用方法进行比较。</li><li id="ceea" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">CR —基本方法。</li><li id="2c99" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">CR —分摊查询。</li><li id="349c" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">FAWN:一组快速排列的弱节点。</li></ol><h1 id="d41a" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">1.介绍</h1><h2 id="71cd" class="ln kq ht bd kr lo lp lq kv lr ls lt kz jb lu lv ld jf lw lx lh jj ly lz ll ma dt translated">1.1问题</h2><p id="75d3" class="pw-post-body-paragraph iq ir ht is b it mb iv iw ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn hm dt translated">假设我们想要设计一个非常简单的键值存储系统。存储应具有简约的界面:</p><ul class=""><li id="1967" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">write(key，object):保存/更新键值。</li><li id="a5e3" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">read(key):返回键值。</li></ul><p id="6a7a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还知道数据集的大小相对较小——它完全适合一台服务器(因此我们不需要考虑分片),并且我们预计会有大量的读/写查询。</p><p id="82dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的目标是设计这样一个存储系统，它能够处理大量的查询<strong class="is hu">(高吞吐量，HT) </strong>，满足<strong class="is hu">高可用性，HA </strong>标准，并具有<strong class="is hu">强一致性，SC </strong>。</p><p id="27a4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">许多系统为了HA + HT而牺牲SC，因为满足所有这三个条件是非常复杂任务。亚马逊迪纳摩在这类系统中取得了巨大的成功，并推动了迪纳摩风格的数据库，如卡珊德拉，Riak，伏地魔等。</p><h2 id="334d" class="ln kq ht bd kr lo lp lq kv lr ls lt kz jb lu lv ld jf lw lx lh jj ly lz ll ma dt translated">1.2主/备份</h2><p id="9cb3" class="pw-post-body-paragraph iq ir ht is b it mb iv iw ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn hm dt translated">付款交单是解决我们问题的最普遍的方式。P/B有一个主服务器，N个备份服务器。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mh"><img src="../Images/5b4b6d459a1ebd799aefd9aa7d6e8b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xH1j6Zh9tclI5ax7GD18uw.png"/></div></div></figure><p id="3a84" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">上图显示了一种P/B方法，即主节点在向客户端发送ACK之前等待所有备份的ACK。P/B设置还有许多其他变化:</p><ul class=""><li id="a54f" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">主节点对所有写请求进行总体排序。</li><li id="ab05" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">一旦其中一个备份发送了ACK，主备份就向客户端发送ACK。</li><li id="3a21" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">草率的法定人数和暗示的移交。</li><li id="c5a9" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">等等</li></ul><p id="bf1e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">需要一个独立、稳定的流程来监控集群状态并提供集群配置。在主节点失败的情况下，该过程发起新的选举，并且该过程决定在裂脑的情况下做什么。根据需求，这个过程可以部分地作为复制算法的一部分或者作为一个附加工具(比如zookeeper)来实现。</p><p id="d405" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">很明显，P/B方法的性能迟早会受到两个限制的约束:</p><ul class=""><li id="bd23" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">主节点的性能。</li><li id="26ee" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">备份节点的数量。</li></ul><p id="ab13" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们越快达到这些限制，就越需要“更强”的一致性和耐久性。</p><p id="20f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">替代方法呢？</p><h2 id="b881" class="ln kq ht bd kr lo lp lq kv lr ls lt kz jb lu lv ld jf lw lx lh jj ly lz ll ma dt translated">1.3链式复制</h2><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mi"><img src="../Images/a0fdfc98bdec26a1a9779b8876ca7efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DHnbz4PSmNarW6o04_-yDg.png"/></div></div></figure><p id="0b14" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">CR的基本组件是:具有两个特殊节点的节点序列(链)——头(接收来自客户端的请求)和尾(链的末端，提供一致性保证)。这种链至少具有以下特性:</p><ul class=""><li id="757a" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">容许多达n-1个节点的故障。</li><li id="45da" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">写性能大约是P/B方法的写性能。</li><li id="0dba" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">对于其他节点，如果磁头出现故障，群集重新配置的速度会快得多，大约与P/B的时间相同</li></ul><p id="3889" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">值得注意的是，链复制需要节点之间<strong class="is hu">强大而可靠的FIFO链接。</strong></p><p id="d009" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们考虑一下CR的不同实现。</p><h1 id="7849" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">2.链式复制—基本方法</h1><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mj"><img src="../Images/dd0bb6ba4980de142fb35da9faa483f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YonvFvOuDE-Rk8LffnBkDA.png"/></div></div></figure><h2 id="000e" class="ln kq ht bd kr lo lp lq kv lr ls lt kz jb lu lv ld jf lw lx lh jj ly lz ll ma dt translated">2.1架构</h2><p id="2e08" class="pw-post-body-paragraph iq ir ht is b it mb iv iw ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn hm dt translated">客户端向头部发送写请求，向尾部发送读请求。回应总是来自尾部。当头部接收到请求时，它计算状态的增量，应用更改并将增量沿链向下传播。一旦tail收到增量，它就通过每个节点向head发回ACK。如您所见，如果读取请求返回某个值X，这意味着它已经保存在所有节点上。</p><h2 id="e4e9" class="ln kq ht bd kr lo lp lq kv lr ls lt kz jb lu lv ld jf lw lx lh jj ly lz ll ma dt translated">2.2复制协议</h2><p id="f3e6" class="pw-post-body-paragraph iq ir ht is b it mb iv iw ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn hm dt translated">让我们从头开始枚举所有节点，然后在每个节点上<em class="mk"> i </em>我们将存储以下数据:</p><ul class=""><li id="41f3" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated"><em class="mk">Pending(I)</em>—tail已收到但尚未处理的请求列表。</li><li id="c6a2" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated"><em class="mk"> Sent(i) </em> —尚未由tail请求处理的列表，发送到节点的<em class="mk"> i </em>后继节点。</li><li id="1514" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated"><em class="mk"> History(i，key) </em> —键的变更列表。它可以是完整的历史记录，也可以是最后一个值。</li></ul><p id="14bf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff ml"><img src="../Images/d672999b44561b1e78433ff9821710d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*asDlXdmiSzg_e62vm2Bwpw.png"/></div></div></figure><p id="e964" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">并且:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mm"><img src="../Images/ee2203758aa3b301227013d49a42a008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uXUCJOQN-9Hvd4itGJePTw.png"/></div></div></figure><h2 id="e868" class="ln kq ht bd kr lo lp lq kv lr ls lt kz jb lu lv ld jf lw lx lh jj ly lz ll ma dt translated">2.3应对失败</h2><p id="6361" class="pw-post-body-paragraph iq ir ht is b it mb iv iw ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn hm dt translated">如前所述，我们需要一个特殊的主流程，它将:</p><ul class=""><li id="243a" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">检测故障节点。</li><li id="147a" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">通知失败节点的前趋和后继节点。</li><li id="3a7f" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">通知客户端故障节点是头部还是尾部。</li></ul><p id="111c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们假设主进程从不失败。</p><p id="d190" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还假设我们的节点是故障停止的，这意味着:</p><ul class=""><li id="c77c" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">服务器在其失败的情况下停止工作，即它从不发送不正确的响应。</li><li id="af28" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">这种故障总是可以被主进程检测到。</li></ul><p id="377c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们考虑如何添加一个新节点:理论上，一个新节点可以被添加到链中的任何位置，然而添加到尾部似乎是最简单的方法——我们只需要将当前尾部的状态复制到新节点，并通知旧尾部它需要将请求进一步传输到新尾部。</p><p id="a15b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，让我们考虑可能的失败:</p><ul class=""><li id="6172" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">脑袋失灵。<br/>从链中删除该节点，并指定其继任者作为新的头。只有来自<em class="mk"> Pending(head) </em>的未进一步发送的请求才会丢失，即<em class="mk">Pending(head)\ Sent(head)</em>。</li><li id="07ab" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">尾部故障。<br/>从链中删除该节点，并将它的前一个节点指定为新的尾部。在此之前<em class="mk">已发送(tail-1)</em>变空(标记为已由tail处理)，这使得<em class="mk">待处理(tail-1)</em>变小。</li><li id="a192" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">另一个节点<em class="mk"> k </em>故障。<br/>主进程通知节点<em class="mk">k-1</em>和<em class="mk"> k + 1 </em>失败。可能会丢失来自<em class="mk">Sent(k-1)</em>的请求，这些请求实际上尚未到达节点<em class="mk"> k + 1 </em>，因此我们再次重新发送<em class="mk">Sent(k-1)</em>，并且仅在此之后使<em class="mk"> k + 1 </em>成为<em class="mk">k-1</em>的后继。</li></ul><h2 id="c865" class="ln kq ht bd kr lo lp lq kv lr ls lt kz jb lu lv ld jf lw lx lh jj ly lz ll ma dt translated">2.4与主要/备用方法的比较</h2><ul class=""><li id="b95d" class="kb kc ht is b it mb ix mc jb mn jf mo jj mp jn mg kh ki kj dt translated">在CR中，读取请求仅由一个节点处理，并立即得到响应，而在P/B中，主节点从所有备份接收写入确认可能会有延迟。</li><li id="f348" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">在这两种方法中，写请求在所有节点上执行，但是，由于并行执行，P/B的速度稍快一些。</li></ul><p id="8dbf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">CR方法失败时的延迟:</p><ul class=""><li id="2593" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">磁头故障:读取请求仍然得到处理。存在两个消息的延迟——从主进程到关于新头节点的所有节点，以及从主进程到所有客户端。</li><li id="9ccb" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">尾部故障:读写请求的两个消息的延迟——通知<br/>tail——1关于新的尾部以及通知所有客户端。</li><li id="7b8c" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">任何其他节点的故障:读取请求没有延迟。写请求可能被延迟，直到发送(is)被重新发送。</li></ul><p id="8254" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">P/B进近失败时的延误:</p><ul class=""><li id="4954" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">主节点故障:选择新的主节点和同步状态的消息延迟多达5条。</li><li id="5787" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">备份失败:读取请求没有延迟，但只有在没有写入请求的情况下。否则，最多会延迟1条消息。</li></ul><p id="a814" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如您所见，CR(尾部)的最严重故障比P/B(主要)的最严重故障更快。</p><p id="d87f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最初研究的作者进行了广泛的测试，并得出结论，CR性能与P/B相同。</p><h1 id="2448" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">3.具有分配查询的链式复制— CRAQ</h1><p id="eaf8" class="pw-post-body-paragraph iq ir ht is b it mb iv iw ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn hm dt translated">很明显，这种基本方法有一个弱点——尾部，它处理所有的读请求。这可能会导致以下问题:</p><ul class=""><li id="8d6c" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">尾部成为热点，即处理大多数请求的节点。</li><li id="4436" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">如果放在另一个数据中心，Tail会降低写请求的速度。</li></ul><p id="d740" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">CRAQ提出了一个非常简单的想法:让我们允许所有节点处理读请求，除了尾部。为了保持一致性，我们将为写请求维护一个版本向量，并且我们将对尾部进行请求，以在不明确的情况下获得最新提交的版本。</p><h2 id="ea2f" class="ln kq ht bd kr lo lp lq kv lr ls lt kz jb lu lv ld jf lw lx lh jj ly lz ll ma dt translated">3.1架构</h2><p id="c33e" class="pw-post-body-paragraph iq ir ht is b it mb iv iw ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn hm dt translated">因此，除了tail以外的每个节点都处理读请求并将值返回给客户机。Head在出现写请求时向客户端返回响应(与基本方法相比)。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mq"><img src="../Images/6f08c4c44927af8ccee61417051a5d2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElAZtJxqk7xxlo6ZmuqLJw.png"/></div></div></figure><p id="7699" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每个非尾节点可以维护同一密钥的多个版本，并且这些版本是单调递增的。每个版本可以是“干净的”或“脏的”，在开始时所有版本都是干净的。</p><p id="4207" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当节点接收到写请求时，它将接收到的版本添加到该密钥的本地版本列表中；</p><ul class=""><li id="ceb9" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">如果该节点是尾部，则它将该版本标记为干净，该版本现在被<strong class="is hu">提交</strong>，并且尾部将ACK发送回头部。</li><li id="5008" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">否则—该节点将该版本标记为脏，并传递给下一个节点。</li></ul><p id="e05f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当一个节点从它的后继节点收到ACK时，它将该版本标记为干净的，并删除所有旧版本。</p><p id="d5a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当节点收到读取请求时:</p><ul class=""><li id="469d" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">如果节点已知的最新版本是干净的，则将其返回。</li><li id="d409" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">否则—要求tail获取给定密钥的最后提交版本，并将其发送回客户端。(这样的版本会一直存在于尾部被设计)。</li></ul><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mq"><img src="../Images/fa98f0f6b941353a14d4451cd29d750a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9LZTzs-pwJtYdPc5LlDzFg.png"/></div></div></figure><p id="b075" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">CRAQ的性能随着工作负载中主要是读取请求的节点数量而线性增长。对于主要是写请求的工作负载，性能将优于或等于基本方法。</p><p id="6127" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">CRAQ可以部署在多个数据中心。这为客户端提供了选择最近的节点来加速读取请求的机会。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mr"><img src="../Images/578b8b0b92f185ca36858c55d4bbec7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TL6frkbEMlLOwuo6VTL5TA.png"/></div></div></figure><h2 id="8b73" class="ln kq ht bd kr lo lp lq kv lr ls lt kz jb lu lv ld jf lw lx lh jj ly lz ll ma dt translated">3.2 CRAQ的一致性</h2><p id="dbfc" class="pw-post-body-paragraph iq ir ht is b it mb iv iw ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn hm dt translated">CRAQ提供了很强的一致性，但有一种情况除外:当一个节点从tail接收到最后提交的版本时，tail可能会在节点向客户机发送响应之前提交最新的版本。在这个场景中，CRAQ在整个链上提供<strong class="is hu">单调读取</strong>(后续读取请求不会过去)<strong class="is hu">。</strong></p><p id="13ae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这种情况下，还可以提供其他较弱的一致性来提高性能:</p><ul class=""><li id="3484" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">最终一致性:节点不会从尾部请求最新提交的版本。这仍将提供单调读取，但仅在一个节点上。(后续读取请求必须命中同一节点)。此外，这允许CRAQ <strong class="is hu">容忍网络分区。</strong></li><li id="97aa" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">有限最终一致性:只允许在某些条件下返回脏版本，比如不超过N次修订或T分钟。</li></ul><h2 id="59d3" class="ln kq ht bd kr lo lp lq kv lr ls lt kz jb lu lv ld jf lw lx lh jj ly lz ll ma dt translated">3.3应对失败</h2><p id="9a08" class="pw-post-body-paragraph iq ir ht is b it mb iv iw ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn hm dt translated">与基本方法相同。</p><h2 id="5edd" class="ln kq ht bd kr lo lp lq kv lr ls lt kz jb lu lv ld jf lw lx lh jj ly lz ll ma dt translated">3.4可能的改进</h2><p id="9bbb" class="pw-post-body-paragraph iq ir ht is b it mb iv iw ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn hm dt translated">CRAQ有一个非常有趣的特性——写请求时可以通过组播发送更新。当写请求命中head时，head可以向所有节点多播更改，然后沿链向下发送“修复”事件。一旦接收到固定事件，节点就等待接收多播更新。同样，tail可以多播ACK，并通过链将固定事件发送回head。</p><h1 id="a49c" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">4.FAWN:一组快速排列的弱节点</h1><p id="611e" class="pw-post-body-paragraph iq ir ht is b it mb iv iw ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn hm dt translated">这是一个非常有趣的研究，与本文不完全相关，但是给出了一个如何使用链复制的很好的例子。</p><p id="933f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">高性能KV存储(Dynamo、memcached、Voldemort)具有相同的特征:大量I/O(非计算性的)需要并行访问随机密钥，数千个并发请求，数据大小相对较低，最多1Kb。</p><p id="c4b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于寻道操作(随机存取)缓慢，带HDD的节点不是此类系统的好选择，另一方面，带大量RAM的节点消耗的功率惊人地多，2GB DRAM相当于1Tb HDD。</p><p id="89de" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最初研究的目标是以最小的能耗构建一个高吞吐量的高效集群。三年后，50%的服务器成本是能源成本，现代节能模式并不真正有效-在进行的测试中，在20%的系统负载下，CPU功耗约为50%。此外，其他组件可能根本没有节能模式，例如DRAM，它已经在最低电压下工作。必须注意的是，在这样的集群中，我们还可以观察到CPU和I/O之间的差距——强大的CPU必须等待I/O操作完成。</p><h2 id="0199" class="ln kq ht bd kr lo lp lq kv lr ls lt kz jb lu lv ld jf lw lx lh jj ly lz ll ma dt translated">4.1架构</h2><p id="5d43" class="pw-post-body-paragraph iq ir ht is b it mb iv iw ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn hm dt translated">FAWN集群建立在旧服务器上，每台服务器250美元(2009年)，嵌入式CPU 500MHz，512Mb内存，32Gb固态硬盘。如果你熟悉Amazon Dynamo或consistent hashing，你会发现FAWN架构与它们非常相似:</p><ul class=""><li id="99e5" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">每个物理服务器由多个虚拟节点组成，每个节点都有自己唯一的VID。</li><li id="d407" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">VID形成一个环，每个VI负责它“后面”的范围(例如，A1负责R1范围中的键)。</li><li id="388d" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">为了提高容错能力，数据以顺时针方向在R个下一个虚拟节点上复制(例如，如果R=2，则A1的键被复制到B1和C1)。因此，我们得到一个链式复制(基本方法)。</li><li id="685b" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">读取请求被路由到尾部，即来自A1的读取将被路由到C1。</li><li id="c95e" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">写请求被路由到头部，并被传播到尾部。</li></ul><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff ms"><img src="../Images/c19c139f621d50a8c2b3f3e06b7faa2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*369Znc90JqKrVYvYBQCEjw.png"/></div></div></figure><p id="5032" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">服务器映射存储在前端集群上，其中的每个服务器负责特定范围的vid，并可以将请求重新路由到适当的前端服务器。</p><h2 id="bc23" class="ln kq ht bd kr lo lp lq kv lr ls lt kz jb lu lv ld jf lw lx lh jj ly lz ll ma dt translated">4.2评估</h2><p id="d1b4" class="pw-post-body-paragraph iq ir ht is b it mb iv iw ix mc iz ja jb md jd je jf me jh ji jj mf jl jm jn hm dt translated">在压力测试中，FAWN cluster达到了QPS(每秒查询数),即闪存驱动器上90%的QPS随机读取。</p><p id="9d28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在下表中，我们比较了不同系统的总拥有成本(TCO)。传统系统的基本设置是1000美元的服务器(与2009年相同)，功耗为200瓦:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mt"><img src="../Images/280ce752e9d155425404b8ca64ba6858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rCLTe_zhwXZ1VRqny4s17Q.png"/></div></div></figure><p id="c13a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">总之，如果您的工作负载包括:</p><ul class=""><li id="6388" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn mg kh ki kj dt translated">海量数据，低请求量—选择FAWN + 2Tb 7200 RPM，</li><li id="ff49" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">数据量小，请求量大—选择FAWN + 2GB DRAM，</li><li id="cf33" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated">平均值—选择风扇+ 32GB固态硬盘。</li></ul><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mu"><img src="../Images/b692379ba5a178cb3fc0e5e8bb9e5a17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRRjquToXdYbOWvHmB9bbQ.png"/></div></div></figure><h1 id="c8f0" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">参考</h1><ul class=""><li id="47ce" class="kb kc ht is b it mb ix mc jb mn jf mo jj mp jn mg kh ki kj dt translated"><a class="ae ka" href="https://dl.acm.org/citation.cfm?id=1251261" rel="noopener ugc nofollow" target="_blank">支持高吞吐量和高可用性的链式复制</a></li><li id="4c54" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated"><a class="ae ka" href="https://dl.acm.org/citation.cfm?id=1855818" rel="noopener ugc nofollow" target="_blank">CRAQ上的对象存储:以读取为主的工作负载的高吞吐量链复制</a></li><li id="464c" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn mg kh ki kj dt translated"><a class="ae ka" href="http://www.sigops.org/s/conferences/sosp/2009/papers/andersen-sosp09.pdf" rel="noopener ugc nofollow" target="_blank">小鹿:一个由懦弱节点组成的快速阵列</a></li></ul><blockquote class="mv"><p id="c1d6" class="mw mx ht bd my mz na nb nc nd ne jn ek translated"><a class="ae ka" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="ng nh ni nj nk jt fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nf"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>