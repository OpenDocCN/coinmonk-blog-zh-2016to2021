<html>
<head>
<title>Using Apache Kafka to implement event-driven microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Apache Kafka实现事件驱动的微服务</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/using-apache-kafka-to-implement-event-driven-microservices-810a26f1418f?source=collection_archive---------1-----------------------#2019-08-18">https://medium.com/coinmonks/using-apache-kafka-to-implement-event-driven-microservices-810a26f1418f?source=collection_archive---------1-----------------------#2019-08-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div class="fe ff hr"><img src="../Images/9ca56ff21fc79d8ae338fea50cf35b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*BfZR9mOT1p9fSr_DyWfyhg.png"/></div><figcaption class="hy hz fg fe ff ia ib bd b be z ek">Diagram of the example/PoC Kafka Streams application</figcaption></figure><div class=""/><p id="011b" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当谈到微服务架构时，大多数人会想到一个通过HTTP进行通信的无状态服务网络(可以称之为RESTful，也可以不称之为RESTful，这取决于一个人的挑剔程度)。<br/>但是有另一种方式，根据手头的用例可能更合适。</p><p id="b7c9" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我说的是事件驱动的微服务，除了经典的请求-响应模式，服务还发布表示事件(事实)的消息，并订阅主题(或队列，取决于所用的术语)来接收事件/消息。</p><p id="debd" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要完全理解并接受这种新的软件设计范例并不简单，但这是完全值得的(至少深入研究一下)。<br/>有几个相互关联的概念需要探究，以便发现事件驱动设计的优势以及导致它的进化路径，例如:</p><ul class=""><li id="7a3d" class="jz ka ie jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated">日志(包括日志结构存储引擎和预写日志)</li><li id="5a15" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">物化视图</li><li id="6068" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">活动采购</li><li id="5fe9" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">命令查询责任分离(CQRS)</li><li id="1d5b" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">流处理</li><li id="094b" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">“由内而外”的数据库(也称为“非捆绑”数据库)</li></ul><p id="cc88" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我想向您推荐以下书籍来熟悉这些主题:</p><ul class=""><li id="92f4" class="jz ka ie jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated"><a class="ae kn" href="https://amzn.to/31S2Trb" rel="noopener ugc nofollow" target="_blank"> <strong class="jd if">设计数据密集型应用</strong> </a> <strong class="jd if"> </strong>作者:Martin Kleppmann这是一本非常全面的书，它从单节点应用程序概念开始，然后是分布式系统，最后是批处理和流处理。</li><li id="0a5f" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">Ben Stopford的<a class="ae kn" href="https://www.confluent.io/designing-event-driven-systems" rel="noopener ugc nofollow" target="_blank"> <strong class="jd if">设计事件驱动系统</strong></a>——它关注的是作为事件驱动系统支柱的Apache Kafka。</li><li id="9192" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">《卡夫卡:权威指南》  <strong class="jd if"> </strong>作者:Neha Narkhede、Gwen Shapira等人——比另外两本更实用的书。</li></ul><p id="8d53" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我读了这三本书，然后我开始构建一个简单的概念验证，因为学习新的设计理念是很棒的，但是直到你将它们付诸实践，它才算完成。<br/>此外，我对网上提供的事件驱动应用/服务的例子并不满意，我发现它们过于简单，也没有得到恰当的解释，所以我决定创建一个。</p><h1 id="d99d" class="ko kp ie bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">概念证明</h1><p id="a7b2" class="pw-post-body-paragraph jb jc ie jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">源代码被分成两个GitHub库(按照<a class="ae kn" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">清洁架构</a>):</p><ul class=""><li id="14f5" class="jz ka ie jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated"><a class="ae kn" href="https://github.com/VictorGil/transfers_api" rel="noopener ugc nofollow" target="_blank"> transfers_api </a> →包含Java实体和Avro数据定义文件</li><li id="3a05" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated"><a class="ae kn" href="https://github.com/VictorGil/transfers_recording_service" rel="noopener ugc nofollow" target="_blank">transfers _ recording _ service</a>→包含业务逻辑和Kafka相关代码</li></ul><p id="ff49" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">概念验证服务跟踪银行账户中的可用余额(类似于分类账)。<br/>它监听关于Kafka主题的<a class="ae kn" href="https://github.com/VictorGil/transfers_api/blob/1e7e4519dce6a6d1bf7628738e3358490c706d6f/src/main/resources/avro/transfer.avsc" rel="noopener ugc nofollow" target="_blank">转账</a>消息，当收到一条消息时，它通过发布关于另一个Kafka主题的新<a class="ae kn" href="https://github.com/VictorGil/transfers_api/blob/1e7e4519dce6a6d1bf7628738e3358490c706d6f/src/main/resources/avro/accountBalance.avsc" rel="noopener ugc nofollow" target="_blank">账户余额</a>消息来更新相关账户的余额。<br/>请注意，每个实体类型由两个不同的类表示:</p><ul class=""><li id="55ba" class="jz ka ie jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated">一个由Apache Avro生成，用于序列化和反序列化(因此它们可以从Kafka发送和接收)→参见<a class="ae kn" href="https://github.com/VictorGil/transfers_api/tree/1e7e4519dce6a6d1bf7628738e3358490c706d6f/src/main/resources/avro" rel="noopener ugc nofollow" target="_blank"> avro </a>目录。</li><li id="b4ae" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">另一个是POJO，可能包含一些方便的构造函数，不依赖于Avro →见<a class="ae kn" href="https://github.com/VictorGil/transfers_api/blob/1e7e4519dce6a6d1bf7628738e3358490c706d6f/src/main/java/net/devaction/entity" rel="noopener ugc nofollow" target="_blank"> net.devaction.entity </a>包。</li></ul><p id="ee56" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae kn" href="https://github.com/VictorGil/transfers_api/tree/1e7e4519dce6a6d1bf7628738e3358490c706d6f/src/main/java/net/devaction/kafka/avro/util" rel="noopener ugc nofollow" target="_blank">net . devaction . Kafka . avro . util</a>包包含了从一种数据表示到另一种数据表示来回移动的转换器。<br/>一开始，Apache Kafka可能看起来势不可挡，尽管它类似于ActiveMQ或RabbitMQ之类的经典消息传递代理，但它远不止于此，它的内部工作方式也非常不同。此外，还有几个Kafka客户端API，这给学习者增加了更多的困惑。<br/>我们将重点关注以下三点:</p><ul class=""><li id="67a4" class="jz ka ie jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated"><a class="ae kn" href="https://kafka.apache.org/documentation/#producerapi" rel="noopener ugc nofollow" target="_blank">生产者API </a>和<a class="ae kn" href="https://kafka.apache.org/documentation/#consumerapi" rel="noopener ugc nofollow" target="_blank">消费者API </a></li><li id="3044" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated"><a class="ae kn" href="https://kafka.apache.org/documentation/#streamsapi" rel="noopener ugc nofollow" target="_blank">流API </a></li></ul><p id="939e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">生产者和消费者API是较低的级别，而流API构建在它们之上。两套API各有利弊。<br/>生产者/消费者API以更高的复杂性为代价，为应用开发者提供了更好的控制。<br/>另一方面，Streams API没有那么灵活，但是它允许更容易地实现一些标准操作，并且需要更少的代码。</p><p id="7c5a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">“传输记录”示例/PoC服务可以以下两种模式之一启动:</p><ul class=""><li id="d664" class="jz ka ie jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated">(显式)<strong class="jd if">轮询</strong>模式，使用生产者API、消费者API和流API(创建一个由本地数据存储支持的可查询物化视图，稍后会详细介绍)→参见<a class="ae kn" href="https://github.com/VictorGil/transfers_recording_service/blob/eecd02b7f893afcb7d96a32907a968713b7534ca/src/main/java/net/devaction/kafka/transfersrecordingservice/main/TransfersRecordingServicePolling.java" rel="noopener ugc nofollow" target="_blank">TransfersRecordingServicePolling.java</a></li><li id="5061" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">仅使用流API的“<strong class="jd if">加入流</strong>”模式→参见<a class="ae kn" href="https://github.com/VictorGil/transfers_recording_service/blob/eecd02b7f893afcb7d96a32907a968713b7534ca/src/main/java/net/devaction/kafka/transfersrecordingservice/joinstreams/TransfersRecordingServiceJoinStreams.java" rel="noopener ugc nofollow" target="_blank">TransfersRecordingServiceJoinStreams.java</a></li></ul><p id="2b2a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这两种模式提供完全相同的功能，非常便于比较。</p><h1 id="dbc7" class="ko kp ie bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">(显式)轮询模式</h1><p id="2372" class="pw-post-body-paragraph jb jc ie jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">它有四个主要组成部分:</p><ul class=""><li id="7a49" class="jz ka ie jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated">收听“<em class="lr">转账</em>话题的<a class="ae kn" href="https://kafka.apache.org/23/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html" rel="noopener ugc nofollow" target="_blank">消费者</a>→参见<a class="ae kn" href="https://github.com/VictorGil/transfers_recording_service/blob/eecd02b7f893afcb7d96a32907a968713b7534ca/src/main/java/net/devaction/kafka/transfersrecordingservice/transferconsumer/TransferConsumer.java#L103" rel="noopener ugc nofollow" target="_blank">TransferConsumer.java</a></li><li id="7faa" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">一个<a class="ae kn" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html" rel="noopener ugc nofollow" target="_blank"> ReadOnlyKeyValueStore </a>(它是Streams API的一部分)将“<em class="lr">账户余额</em>”主题数据具体化为一个可查询的视图，因此我们可以使用accountId值来检索特定账户的最新/当前余额→参见AccountBalanceRetrieverImpl.java<a class="ae kn" href="https://github.com/VictorGil/transfers_recording_service/blob/eecd02b7f893afcb7d96a32907a968713b7534ca/src/main/java/net/devaction/kafka/transfersrecordingservice/accountbalanceproducer/AccountBalanceRetrieverImpl.java#L93" rel="noopener ugc nofollow" target="_blank">。<br/>请注意，<em class="lr"> accountId </em>值是从消费者收到的“<em class="lr"> transfer </em>”数据报文中提取的。</a></li><li id="f0ee" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">从接收到的<em class="lr"> TransferEntity </em>对象和Kafka中存在的当前<em class="lr"> AccountBalanceEntity </em>创建新的/更新的<em class="lr"> AccountBalanceEntity </em>对象的业务逻辑→参见<a class="ae kn" href="https://github.com/VictorGil/transfers_recording_service/blob/eecd02b7f893afcb7d96a32907a968713b7534ca/src/main/java/net/devaction/kafka/transfersrecordingservice/core/NewAccountBalanceProvider.java#L15" rel="noopener ugc nofollow" target="_blank">NewAccountBalanceProvider.java</a></li><li id="d2ab" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">一个<a class="ae kn" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/clients/producer/KafkaProducer.html" rel="noopener ugc nofollow" target="_blank">生成器</a>，它通过向“<em class="lr">账户-余额</em>”主题发送消息来发布更新后的余额→本地数据存储将相应地得到更新。</li></ul><h1 id="ad94" class="ko kp ie bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">“加入流”模式</h1><p id="8f86" class="pw-post-body-paragraph jb jc ie jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">如前所述，第二种操作模式仅使用Streams API/DSL，利用它，我们可以在更高的抽象级别进行编码:</p><ul class=""><li id="b014" class="jz ka ie jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated">我们使用的是一个KStream，而不是一个消费者</li><li id="66f7" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">代替<a class="ae kn" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/state/ReadOnlyKeyValueStore.html" rel="noopener ugc nofollow" target="_blank"> ReadOnlyKeyValueStore </a>，我们使用一个<a class="ae kn" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/kstream/KTable.html" rel="noopener ugc nofollow" target="_blank"> KTable </a> →参见<a class="ae kn" href="https://github.com/VictorGil/transfers_recording_service/blob/271f1e7716b0298e18b90578eed6d978e0cd1d5f/src/main/java/net/devaction/kafka/transfersrecordingservice/joinstreams/TransfersRecordingServiceJoinStreams.java#L69" rel="noopener ugc nofollow" target="_blank">TransfersRecordingServiceJoinStreams</a>。又是java。</li><li id="c3b8" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">业务逻辑保持不变，但现在我们称之为从<a class="ae kn" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/streams/kstream/ValueJoiner.html" rel="noopener ugc nofollow" target="_blank">估价员</a> →见<a class="ae kn" href="https://github.com/VictorGil/transfers_recording_service/blob/eecd02b7f893afcb7d96a32907a968713b7534ca/src/main/java/net/devaction/kafka/transfersrecordingservice/joinstreams/TransferAndAccountBalanceJoiner.java#L40" rel="noopener ugc nofollow" target="_blank">TransferAndAccountBalanceJoiner.java</a></li><li id="4615" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">代替<a class="ae kn" href="https://kafka.apache.org/23/javadoc/org/apache/kafka/clients/producer/KafkaProducer.html" rel="noopener ugc nofollow" target="_blank">生产者</a>，我们将streams join的输出重定向到期望的主题(即“<em class="lr">账户余额</em>”)→再次查看<a class="ae kn" href="https://github.com/VictorGil/transfers_recording_service/blob/271f1e7716b0298e18b90578eed6d978e0cd1d5f/src/main/java/net/devaction/kafka/transfersrecordingservice/joinstreams/TransfersRecordingServiceJoinStreams.java#L75" rel="noopener ugc nofollow" target="_blank">TransfersRecordingServiceJoinStreams.java</a>→KTable将随着每条消息更新，从而结束循环。</li></ul><p id="88d2" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以看到代码比前一种模式要紧凑得多。<br/>我们不需要显式地将<em class="lr"> KStream </em>键映射到<em class="lr"> KTable </em>键，这正是<em class="lr"> join </em>所做的事情(参见下面代码片段中的第11行)。因此，我们需要相应地选择卡夫卡式的基调。在这种情况下，两个消息键都代表账户id 。</p><figure class="ls lt lu lv fq hv"><div class="bz el l di"><div class="lw lx l"/></div></figure><h1 id="5b2a" class="ko kp ie bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">图表</h1><figure class="ls lt lu lv fq hv fe ff paragraph-image"><div class="fe ff hr"><img src="../Images/bd87b8a6651f6fb6282710e42b2cf63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*6ayv8RCXS1eDfvfe.png"/></div><figcaption class="hy hz fg fe ff ia ib bd b be z ek">Diagram of the example/PoC Kafka Streams application</figcaption></figure><h1 id="5c1c" class="ko kp ie bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">运行代码</h1><p id="62f4" class="pw-post-body-paragraph jb jc ie jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">要构建和运行PoC应用程序，除了Maven和Java，我们还需要一个Kafka代理。<br/>我决定安装<a class="ae kn" href="https://www.confluent.io/product/confluent-platform" rel="noopener ugc nofollow" target="_blank">融合平台</a>，它包括一个Kafka代理(或者一个集群，取决于所选的配置)，带有一些示例主题，并预先配置了与ElasticSearch和Kibana的集成。但更重要的是，它还包括一个名为“<em class="lr">控制中心</em>的管理Web UI，非常方便。</p><p id="a146" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我第一次在Fedora 30电脑上运行合流平台时遇到了一些困难。也就是说，我必须手动安装几个软件包(即“<em class="lr"> jot </em>”和“<em class="lr"> jq </em>”)。<br/>和我不得不分别安装<a class="ae kn" href="https://docs.confluent.io/current/cli/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="lr">汇合命令行界面</em> </a>。<br/>我还必须对一些属性文件和bash脚本进行一些更改，以便能够使用非根用户运行融合平台，<a class="ae kn" href="https://gist.github.com/VictorGil/5866f90dc626126897a76dbee53deeec" rel="noopener ugc nofollow" target="_blank">这里的</a>是更改，请根据您的环境修改配置值。</p><p id="4dda" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">观看下面的<a class="ae kn" href="https://youtu.be/w-Vy6_0buYo" rel="noopener ugc nofollow" target="_blank"> YouTube视频</a>了解所有细节，包括启动合流平台和运行示例流应用程序:</p><figure class="ls lt lu lv fq hv"><div class="bz el l di"><div class="ly lx l"/></div></figure></div><div class="ab cl lz ma hb mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hm hn ho hp hq"><p id="fe35" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="lr">原载于2019年8月23日</em><a class="ae kn" href="https://www.devaction.net/2019/08/event-driven-microservices.html" rel="noopener ugc nofollow" target="_blank"><em class="lr">www.devaction.net</em></a><em class="lr">。</em></p></div></div>    
</body>
</html>