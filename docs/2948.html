<html>
<head>
<title>How To Use AccessControl.sol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用AccessControl.sol</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-use-accesscontrol-sol-9ea3a57f4b15?source=collection_archive---------0-----------------------#2020-04-24">https://medium.com/coinmonks/how-to-use-accesscontrol-sol-9ea3a57f4b15?source=collection_archive---------0-----------------------#2020-04-24</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="9a4c" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">新的OpenZeppelin访问控制合同的三个配置示例。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/ac882caecbe2172a7d1644175fa79679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEDi6xiGeMRDS6UybbOVIw.jpeg"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Photo by <a class="ae jy" href="https://www.pexels.com/@scottwebb?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Scott Webb</a> from <a class="ae jy" href="https://www.pexels.com/photo/bloom-book-botanical-cactus-403571/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="31e1" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">在智能合约中，限制授权用户的访问非常重要。10亿美元被锁定在DeFi申请中，你真的希望每个人都知道他们在做什么。</p><p id="dc69" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">最近，我与OpenZeppelin合作重构了他们广泛使用的<a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-contracts" rel="noopener ugc nofollow" target="_blank"> openzeppelin-contracts </a>存储库中的访问控制。如果您曾经编写过智能契约，那么您很可能继承了它们的代码。</p><p id="2250" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">在本文中，我将向您展示如何使用改进后的<a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol" rel="noopener ugc nofollow" target="_blank"> AccessControl.sol </a>来限制对您的智能合约的访问。我将通过三个例子来说明这一点。</p><p id="8752" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">但首先，让我告诉你我们是如何来到这里的。如果你对这个合同是如何产生的不感兴趣，只想学习如何使用它，请随意跳过下一部分。</p><h1 id="8b4c" class="kv kw ht bd kx ky kz la lb lc ld le lf iz lg ja lh jc li jd lj jf lk jg ll lm dt translated">我们是如何来到这里的</h1><p id="333c" class="pw-post-body-paragraph jz ka ht kb b kc ln iu ke kf lo ix kh ki lp kk kl km lq ko kp kq lr ks kt ku hm dt translated">来到这里对我来说是一个花了一年时间的过程。2019年5月，我第一次有了基于角色的分层控制合同的想法。我<a class="ae jy" rel="noopener" href="/hackernoon/role-based-access-control-for-the-ethereum-blockchain-bcc9dfbcfe5c">在Medium </a>上发布了代码，以及一些关于OpenZeppelin当时在做什么的参考资料。</p><p id="0885" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">我为<a class="ae jy" href="https://www.allianceblock.io/" rel="noopener ugc nofollow" target="_blank"> AllianceBlock </a>和<a class="ae jy" href="https://www.techhq.io/" rel="noopener ugc nofollow" target="_blank"> Insig </a>重用了这些代码，开始确信这个实现提供了一些独特而强大的东西。从这些经验中，我写了第二篇文章，展示何时使用Ownable.sol、Whitelist.sol和RBAC.sol。</p><p id="b9c6" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">为了写那篇文章，我需要深入研究OpenZeppelin在访问控制方面做了什么。你不做功课就不会挑战最分叉的可靠性存储库。</p><p id="ad39" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">OpenZeppelin团队的人真的很热情，在发表第二篇文章后不久，他们<a class="ae jy" href="https://forum.openzeppelin.com/t/redesigning-access-control-for-the-openzeppelin-contracts/2177" rel="noopener ugc nofollow" target="_blank">邀请我参与</a>他们访问控制合同的重构。通过合作，我们创建了一个访问控制契约，它比他们以前的方法更灵活，也比我以前的方法更健壮。</p><p id="8d10" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol" rel="noopener ugc nofollow" target="_blank"> AccessControl.sol </a>可以从<a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol" rel="noopener ugc nofollow" target="_blank"> openzeppelin-contracts </a>库获得，我不再保留不同的代码库。</p><p id="32fa" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">有趣的是，作为访问控制有多重要的进一步证明，一个版本的<a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/694d1afe1e6050d01b54f6c27e915e33a8630c99/contracts/Ownable.sol" rel="noopener ugc nofollow" target="_blank"> Ownable.sol </a>早在2016年就存在了。这是Manuel Araoz的第九次承诺，也就是后来的openzeppelin合同。</p><p id="df5b" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">在solidity years，这就像挖掘恐龙的骨头，证明了访问控制是你在编写智能合同时应该首先考虑的事情之一。尤其是如果您打算编写健壮的代码。</p><p id="064c" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">故事时间结束了，让我们深入代码。</p><h1 id="dfe9" class="kv kw ht bd kx ky kz la lb lc ld le lf iz lg ja lh jc li jd lj jf lk jg ll lm dt translated">AccessControl.sol如何工作</h1><p id="a3ca" class="pw-post-body-paragraph jz ka ht kb b kc ln iu ke kf lo ix kh ki lp kk kl km lq ko kp kq lr ks kt ku hm dt translated"><a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol" rel="noopener ugc nofollow" target="_blank"> AccessControl.sol </a>中的角色是一个包含一组地址的结构，代表承担该角色的帐户。所有角色都存储在由字节32标识符索引的映射中，对于每个角色都是唯一的。</p><p id="6e53" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">每个角色还包含另一个角色的bytes32标识符，我们称之为其管理角色。</p><p id="0c52" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">有一些内部函数可以授予和撤销角色，以及将一个角色设置为另一个角色的管理员。这些内部函数没有任何限制，如果您正在扩展AccessControl.sol，您就可以使用它们，我们将在本文的后面进行扩展。</p><p id="8f92" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">还有一些外部函数限制授予和撤销角色，以及将角色设置为其他人的管理员。这些函数只能由被授予被修改角色的管理员角色的帐户从外部调用。</p><p id="c832" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">例如，假设我们有两个角色，DEFAULT_ADMIN_ROLE和USER_ROLE。默认管理员角色是用户角色的管理员角色。</p><p id="b92d" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">只有被授予DEFAULT_ADMIN_ROLE的帐户才能授予或撤销帐户的USER_ROLE。</p><p id="73e6" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">同样，只有被授予DEFAULT_ADMIN_ROLE的帐户才能重新定义USER_ROLE的管理员角色。</p><p id="f6d5" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">在这里，<a class="ae jy" href="https://github.com/nventuro" rel="noopener ugc nofollow" target="_blank"> nventuro </a>使用了一点魔法，将DEFAULT_ADMIN_ROLE定义为未初始化的bytes32变量。这意味着默认情况下，所有角色都将DEFAULT_ADMIN_ROLE作为管理员角色。</p><p id="06d9" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">就这样吧，我用例子更详细的给你看。</p><h2 id="df09" class="ls kw ht bd kx lt lu lv lb lw lx ly lf ki lz ma lh km mb mc lj kq md me ll mf dt translated">社区</h2><p id="07c0" class="pw-post-body-paragraph jz ka ht kb b kc ln iu ke kf lo ix kh ki lp kk kl km lq ko kp kq lr ks kt ku hm dt translated"><a class="ae jy" href="https://github.com/HQ20/contracts/blob/master/contracts/access/Community.sol" rel="noopener ugc nofollow" target="_blank">这个契约</a>复制了之前存在于OpenZeppelin <a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58a3368215581509d05bd3ec4d53cd381c9bb40e/contracts/access/Roles.sol" rel="noopener ugc nofollow" target="_blank"> Roles.sol </a>中的功能。</p><ul class=""><li id="4da0" class="mg mh ht kb b kc kd kf kg ki mi km mj kq mk ku ml mm mn mo dt translated">只有一个角色(默认管理员角色)</li><li id="b8e2" class="mg mh ht kb b kc mp kf mq ki mr km ms kq mt ku ml mm mn mo dt translated">任何拥有该角色的人都可以将其授予其他人。</li><li id="1bf9" class="mg mh ht kb b kc mp kf mq ki mr km ms kq mt ku ml mm mn mo dt translated">在<a class="ae jy" href="https://github.com/HQ20/contracts/blob/master/contracts/access/Community.sol" rel="noopener ugc nofollow" target="_blank"> Community.sol </a>中，角色不能从不同的帐户中撤销，但是帐户可以放弃他们拥有的角色。</li><li id="5bd5" class="mg mh ht kb b kc mp kf mq ki mr km ms kq mt ku ml mm mn mo dt translated">传递给构造函数的地址是第一个被授予角色的帐户。</li></ul><pre class="jj jk jl jm fq mu mv mw mx aw my dt"><span id="6986" class="ls kw ht mv b fv mz na l nb nc">pragma solidity ^0.6.0;<br/>import "@openzeppelin/contracts/access/AccessControl.sol";</span><span id="3b72" class="ls kw ht mv b fv nd na l nb nc"><em class="ne">/// </em><strong class="mv hu">@dev</strong><em class="ne"> Implements a single role access control contract.<br/></em><strong class="mv hu">contract</strong> Community <strong class="mv hu">is</strong> AccessControl {</span><span id="7960" class="ls kw ht mv b fv nd na l nb nc"><em class="ne">  /// </em><strong class="mv hu">@dev</strong><em class="ne"> Create the community role, with `root` as a member.<br/>  </em><strong class="mv hu">constructor</strong> (address root) <strong class="mv hu">public</strong> {<br/>    _setupRole(DEFAULT_ADMIN_ROLE, root);<br/>  }</span><span id="2396" class="ls kw ht mv b fv nd na l nb nc"><em class="ne">  /// </em><strong class="mv hu">@dev</strong><em class="ne"> Restricted to members of the community.<br/>  </em><strong class="mv hu">modifier</strong> onlyMember() {<br/>    require(isMember(msg.sender), "Restricted to members.");<br/>    _;<br/>  }</span><span id="0a4f" class="ls kw ht mv b fv nd na l nb nc"><em class="ne">  /// </em><strong class="mv hu">@dev</strong><em class="ne"> Return `true` if the `account` belongs to the community.<br/>  </em><strong class="mv hu">function</strong> isMember(address account)<br/>    <strong class="mv hu">public</strong> <strong class="mv hu">virtual</strong> <strong class="mv hu">view</strong> returns (bool)<br/>  {<br/>    return hasRole(DEFAULT_ADMIN_ROLE, account);<br/>  }</span><span id="bfcf" class="ls kw ht mv b fv nd na l nb nc"><em class="ne">  /// </em><strong class="mv hu">@dev</strong><em class="ne"> Add a member of the community.<br/>  </em><strong class="mv hu">function</strong> addMember(address account) <strong class="mv hu">public</strong> <strong class="mv hu">virtual</strong> onlyMember {<br/>    grantRole(DEFAULT_ADMIN_ROLE, account);<br/>  }</span><span id="b505" class="ls kw ht mv b fv nd na l nb nc"><em class="ne">  /// </em><strong class="mv hu">@dev</strong><em class="ne"> Remove oneself as a member of the community.<br/>  </em><strong class="mv hu">function</strong> leaveCommunity() <strong class="mv hu">public</strong> <strong class="mv hu">virtual</strong> {<em class="ne"><br/>    </em>renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);<br/>  }<br/>}</span></pre><h2 id="f162" class="ls kw ht bd kx lt lu lv lb lw lx ly lf ki lz ma lh km mb mc lj kq md me ll mf dt translated">治理</h2><p id="c6e8" class="pw-post-body-paragraph jz ka ht kb b kc ln iu ke kf lo ix kh ki lp kk kl km lq ko kp kq lr ks kt ku hm dt translated"><a class="ae jy" href="https://github.com/HQ20/contracts/blob/master/contracts/access/Administered.sol" rel="noopener ugc nofollow" target="_blank">这个智能合同</a>实现了管理员和用户的传统设置。</p><ul class=""><li id="72b4" class="mg mh ht kb b kc kd kf kg ki mi km mj kq mk ku ml mm mn mo dt translated">默认管理员角色是用户的管理员角色(默认情况下)。</li><li id="af3b" class="mg mh ht kb b kc mp kf mq ki mr km ms kq mt ku ml mm mn mo dt translated">传递给构造函数的地址是初始管理员。</li><li id="65f9" class="mg mh ht kb b kc mp kf mq ki mr km ms kq mt ku ml mm mn mo dt translated">管理员可以添加其他管理员。</li><li id="f0aa" class="mg mh ht kb b kc mp kf mq ki mr km ms kq mt ku ml mm mn mo dt translated">管理员可以授予和撤销任何帐户的用户权限。</li><li id="908d" class="mg mh ht kb b kc mp kf mq ki mr km ms kq mt ku ml mm mn mo dt translated">管理员失去管理员角色的唯一方法是放弃它。</li></ul><pre class="jj jk jl jm fq mu mv mw mx aw my dt"><span id="ba07" class="ls kw ht mv b fv mz na l nb nc"><strong class="mv hu">pragma</strong> solidity ^0.6.0;<br/><strong class="mv hu">import</strong> “@openzeppelin/contracts/access/AccessControl.sol”;</span><span id="9925" class="ls kw ht mv b fv nd na l nb nc">/**<br/> * @title Administered<br/> * @author Alberto Cuesta Canada<br/> * @notice Implements Admin and User roles.<br/> */<br/><strong class="mv hu">contract</strong> Administered is AccessControl {<br/>  bytes32 public constant USER_ROLE = keccak256(“USER”);</span><span id="6961" class="ls kw ht mv b fv nd na l nb nc">  /// @dev Add `root` to the admin role as a member.<br/>  <strong class="mv hu">constructor</strong> (address root)<br/>    public<br/>  {<br/>    _setupRole(DEFAULT_ADMIN_ROLE, root);<br/>    _setRoleAdmin(USER_ROLE, DEFAULT_ADMIN_ROLE);<br/>  }</span><span id="cc48" class="ls kw ht mv b fv nd na l nb nc">  /// @dev Restricted to members of the admin role.<br/>  <strong class="mv hu">modifier</strong> onlyAdmin()<br/>  {<br/>    require(isAdmin(msg.sender), “Restricted to admins.”);<br/>    _;<br/>  }</span><span id="bec5" class="ls kw ht mv b fv nd na l nb nc">  /// @dev Restricted to members of the user role.<br/>  <strong class="mv hu">modifier</strong> onlyUser()<br/>  {<br/>    require(isUser(msg.sender), “Restricted to users.”);<br/>    _;<br/>  }</span><span id="c21b" class="ls kw ht mv b fv nd na l nb nc">  /// @dev Return `true` if the account belongs to the admin role.<br/>  <strong class="mv hu">function</strong> isAdmin(address account)<br/>    public virtual view returns (bool)<br/>  {<br/>    return hasRole(DEFAULT_ADMIN_ROLE, account);<br/>  }</span><span id="2010" class="ls kw ht mv b fv nd na l nb nc">  /// @dev Return `true` if the account belongs to the user role.<br/>  <strong class="mv hu">function</strong> isUser(address account)<br/>    public virtual view returns (bool)<br/>  {<br/>    return hasRole(USER_ROLE, account);<br/>  }</span><span id="55e3" class="ls kw ht mv b fv nd na l nb nc">  /// @dev Add an account to the user role. Restricted to admins.<br/>  <strong class="mv hu">function</strong> addUser(address account)<br/>    public virtual onlyAdmin<br/>  {<br/>    grantRole(USER_ROLE, account);<br/>  }</span><span id="9513" class="ls kw ht mv b fv nd na l nb nc">  /// @dev Add an account to the admin role. Restricted to admins.<br/>  <strong class="mv hu">function</strong> addAdmin(address account)<br/>    public virtual onlyAdmin<br/>  {<br/>    grantRole(DEFAULT_ADMIN_ROLE, account);<br/>  }</span><span id="6d60" class="ls kw ht mv b fv nd na l nb nc">  /// @dev Remove an account from the user role. Restricted to admins.<br/>  <strong class="mv hu">function</strong> removeUser(address account)<br/>    public virtual onlyAdmin<br/>  {<br/>    revokeRole(USER_ROLE, account);<br/>  }</span><span id="3bb9" class="ls kw ht mv b fv nd na l nb nc">  /// @dev Remove oneself from the admin role.<br/>  <strong class="mv hu">function</strong> renounceAdmin()<br/>    public virtual<br/>  {<br/>    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);<br/>  }<br/>}</span></pre><h2 id="a200" class="ls kw ht bd kx lt lu lv lb lw lx ly lf ki lz ma lh km mb mc lj kq md me ll mf dt translated">等级制度</h2><p id="dbbd" class="pw-post-body-paragraph jz ka ht kb b kc ln iu ke kf lo ix kh ki lp kk kl km lq ko kp kq lr ks kt ku hm dt translated">这是在<a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol" rel="noopener ugc nofollow" target="_blank"> AccessControl.sol </a>中实现的结构，只需做最小的修改就可以安全地构建角色层次。</p><ul class=""><li id="e036" class="mg mh ht kb b kc kd kf kg ki mi km mj kq mk ku ml mm mn mo dt translated">传递给构造函数的地址具有DEFAULT_ADMIN_ROLE，默认情况下是所有角色的ADMIN。我将把那个地址称为root。</li><li id="c68c" class="mg mh ht kb b kc mp kf mq ki mr km ms kq mt ku ml mm mn mo dt translated">Root可以将DEFAULT_ADMIN_ROLE授予任何帐户。</li><li id="21ae" class="mg mh ht kb b kc mp kf mq ki mr km ms kq mt ku ml mm mn mo dt translated">任何根帐户都可以从任何其他帐户撤销DEFAULT_ADMIN_ROLE角色，所以最好不要一开始就授予它，除非您知道自己在做什么。</li><li id="3b2e" class="mg mh ht kb b kc mp kf mq ki mr km ms kq mt ku ml mm mn mo dt translated">所有角色从一开始就存在，作为映射中的键。DEFAULT_ADMIN_ROLE中的帐户可以授予或撤销任何角色。</li><li id="e813" class="mg mh ht kb b kc mp kf mq ki mr km ms kq mt ku ml mm mn mo dt translated">在<a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol" rel="noopener ugc nofollow" target="_blank"> AccessControl.sol </a>中，每个角色都有一个管理员角色(默认为DEFAULT_ADMIN_ROLE)。在<a class="ae jy" href="https://github.com/HQ20/contracts/blob/master/contracts/access/Hierarchy.sol" rel="noopener ugc nofollow" target="_blank"> Hierarchy.sol </a>中，我们允许任何具有该管理员角色的帐户可以更改关系并选择新的管理员角色。这可以用来建立角色的层次结构，例如:默认管理员角色- &gt;用户管理员- &gt;用户。</li></ul><pre class="jj jk jl jm fq mu mv mw mx aw my dt"><span id="b1c8" class="ls kw ht mv b fv mz na l nb nc"><strong class="mv hu">contract</strong> Hierarchy <strong class="mv hu">is</strong> AccessControl {<br/>  <strong class="mv hu">event</strong> AdminRoleSet(bytes32 roleId, bytes32 adminRoleId);</span><span id="5481" class="ls kw ht mv b fv nd na l nb nc"><em class="ne">  /// </em><strong class="mv hu">@dev</strong><em class="ne"> Add `root` as a member of the root role.<br/>  </em><strong class="mv hu">constructor</strong> (address root) <strong class="mv hu">public</strong> {<br/>    _setupRole(DEFAULT_ADMIN_ROLE, root);<br/>  }</span><span id="e261" class="ls kw ht mv b fv nd na l nb nc"><em class="ne">  /// </em><strong class="mv hu">@dev</strong><em class="ne"> Restricted to members of the role passed as a parameter.<br/>  </em><strong class="mv hu">modifier</strong> onlyMember(bytes32 roleId) {<br/>    require(hasRole(roleId, msg.sender), "Restricted to members.");<br/>    _;<br/>  }</span><span id="2efb" class="ls kw ht mv b fv nd na l nb nc"><em class="ne">  /// </em><strong class="mv hu">@dev</strong><em class="ne"> Create a new role with the specified admin role.<br/></em><strong class="mv hu">  function</strong> addRole(bytes32 roleId, bytes32 adminRoleId)<br/>    <strong class="mv hu">public</strong> onlyMember(adminRoleId)<br/>  {<br/>    _setRoleAdmin(roleId, adminRoleId);<br/>  }<br/>}</span></pre><p id="8ba3" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">手头有AccessControl.sol相关代码对于理解正在发生的事情很有用。</p><pre class="jj jk jl jm fq mu mv mw mx aw my dt"><span id="4078" class="ls kw ht mv b fv mz na l nb nc"><strong class="mv hu">abstract</strong> <strong class="mv hu">contract</strong> AccessControl <strong class="mv hu">is</strong> Context {<br/>…</span><span id="9e7c" class="ls kw ht mv b fv nd na l nb nc"><em class="ne">  /// </em><strong class="mv hu">@dev</strong><em class="ne"> Grants `role` to `account`.<br/>  </em><strong class="mv hu">function</strong> grantRole(bytes32 role, address account)<br/>    <strong class="mv hu">external</strong> <strong class="mv hu">virtual<br/>  </strong>{<br/>    require(<br/>      hasRole(_roles[role].adminRole, _msgSender()),<br/>      “AccessControl: sender must be an admin to grant”);<br/>    _grantRole(role, account);<br/>  }</span><span id="b5cc" class="ls kw ht mv b fv nd na l nb nc"><em class="ne">  /// </em><strong class="mv hu">@dev</strong><em class="ne"> Revokes `role` from `account`.<br/>  </em><strong class="mv hu">function</strong> revokeRole(bytes32 role, address account)<br/>    <strong class="mv hu">external</strong> <strong class="mv hu">virtual<br/>  </strong>{<br/>    require(<br/>      hasRole(_roles[role].adminRole, _msgSender()),<br/>      “AccessControl: sender must be an admin to revoke”);<br/>    _revokeRole(role, account);<br/>  }</span><span id="7a86" class="ls kw ht mv b fv nd na l nb nc"><em class="ne">  /// </em><strong class="mv hu">@dev</strong><em class="ne"> Revokes `role` from the calling account.<br/>  </em><strong class="mv hu">function</strong> renounceRole(bytes32 role, address account)<br/>    <strong class="mv hu">external</strong> <strong class="mv hu">virtual<br/>  </strong>{<br/>    require(<br/>      account == _msgSender(),<br/>      “AccessControl: can only renounce roles for self”);<br/>    _revokeRole(role, account);<br/>  }<br/>  …<br/>}</span></pre><h1 id="36b4" class="kv kw ht bd kx ky kz la lb lc ld le lf iz lg ja lh jc li jd lj jf lk jg ll lm dt translated">结论</h1><p id="c240" class="pw-post-body-paragraph jz ka ht kb b kc ln iu ke kf lo ix kh ki lp kk kl km lq ko kp kq lr ks kt ku hm dt translated">我真的很开心，也很自豪能走到这一步。</p><p id="d40a" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">真的很自豪，因为为<a class="ae jy" href="https://github.com/OpenZeppelin/openzeppelin-contracts" rel="noopener ugc nofollow" target="_blank"> openzeppelin-contracts </a>贡献代码和想法是对一个聪明的合同开发者最强有力的验证。</p><p id="c253" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">真的很高兴，因为我一直使用的访问控制合同现在终于通过了彻底的审核，并由他们领域的大师们进行了完善。我现在可以完全自信地使用它们，相信它们是正确的。</p><p id="c024" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">为社区做贡献感到自豪和高兴。回馈是最好的礼物。</p><p id="975b" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">现在由你来继续。像往常一样，如果你有一个有趣的项目，需要一些关于使用这些功能的建议，<a class="ae jy" href="http://www.albertocuesta.es" rel="noopener ugc nofollow" target="_blank">请联系</a>。BUIDL！</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="https://coincodecap.com"><div class="fe ff nf"><img src="../Images/e9dbce386c4f90837b5db529a4c87766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fZu_SfnNF6m_BGbXlsl-A@2x.png"/></div></a></figure><blockquote class="ng"><p id="82e8" class="nh ni ht bd nj nk nl nm nn no np ku ek translated"><a class="ae jy" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">直接在您的收件箱中获得最佳软件交易</a></p></blockquote><figure class="nr ns nt nu nv jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff nq"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>