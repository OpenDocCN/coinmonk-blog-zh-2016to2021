<html>
<head>
<title>Hyperledger Fabric smart contract data model: protobuf to chaincode state mapping</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hyperledger结构智能合同数据模型:protobuf到chaincode状态映射</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/hyperledger-fabric-smart-contract-data-model-protobuf-to-chaincode-state-mapping-191cdcfa0b78?source=collection_archive---------0-----------------------#2019-02-20">https://medium.com/coinmonks/hyperledger-fabric-smart-contract-data-model-protobuf-to-chaincode-state-mapping-191cdcfa0b78?source=collection_archive---------0-----------------------#2019-02-20</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="8126" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated"><code class="eh ji jj jk jl b"><strong class="ak">How specifying world state data model with protocol buffers can help in developing smart contracts</strong></code></h2></div><figure class="jn jo jp jq fq jr fe ff paragraph-image"><div class="fe ff jm"><img src="../Images/1083e7a412fee6880f4409d2fb9aacc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VDmt2_wVTyHnB1jN"/></div></figure><p id="a95a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">Chaincode是一个与特定业务流程相关的特定领域程序。它以编程方式访问两个不同的分类帐——一个区块链，它不变地记录所有事务的历史；一个世界状态，它保存这些状态的当前值的缓存。智能合约开发人员的工作是获取可能控制金融价格或交付条件的现有业务流程，并用编程语言将其表达为智能合约。<code class="eh ji jj jk jl b">Protobuf</code>(协议缓冲区的缩写)是语言中立、平台中立、可扩展的机制，用于序列化结构化数据。使用协议缓冲区有助于一次定义数据模型，然后轻松地从各种数据源读写结构化数据。</p><h1 id="1459" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">链码状态</h1><p id="f35f" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">分类帐的当前状态数据表示链交易日志中包含的所有关键字的最新值。因为当前状态表示通道已知的所有最新键值，所以它有时被称为世界状态。</p><p id="4dd8" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">链代码调用针对当前状态数据执行事务。为了使这些链码交互非常有效，所有键的最新值都存储在状态数据库中。</p><p id="d7fb" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">智能合约主要是<code class="eh ji jj jk jl b">put</code>、<code class="eh ji jj jk jl b">get</code>和<code class="eh ji jj jk jl b">delete</code>世界状态，并且还可以查询状态变化历史。Chaincode“shim”API实现了<a class="ae ln" href="https://godoc.org/github.com/hyperledger/fabric/core/chaincode/shim#ChaincodeStubInterface" rel="noopener ugc nofollow" target="_blank"> ChaincodeStubInterface </a>，其中包含访问和修改分类帐的方法，以及在chain code之间进行调用的方法。主要方法有:</p><p id="3391" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh ji jj jk jl b"><strong class="jw hu">*</strong> GetState(key string) ([]byte, error) </code>执行查询以检索关于对象当前状态的信息</p><p id="d107" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh ji jj jk jl b">* PutState(key string, value []byte) error</code>在分类帐世界状态下创建新对象或修改现有对象</p><p id="6651" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh ji jj jk jl b">* DelState(key string) error</code>从分类帐的当前状态中删除对象，但不删除其历史记录</p><p id="bdae" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh ji jj jk jl b">* GetStateByPartialCompositeKey(objectType string, keys []string) (StateQueryIteratorInterface, error)</code>根据给定的部分组合键查询总账中的状态</p><p id="70e6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh ji jj jk jl b">* GetHistoryForKey(key string) (HistoryQueryIteratorInterface, error)</code>返回键值的历史记录。</p><p id="7521" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">所有这些方法都使用字符串键作为记录标识符，使用字节片作为状态值。大多数例子使用序列化为字节的JSON文档作为链码状态值。Hyperledger Fabric支持LevelDB as CouchDB作为状态数据库，保存每个对象的最新状态。LevelDB是嵌入在每个对等体中的默认键值状态数据库。CouchDB是一个可选的替代外部状态数据库，具有更多特性——它支持针对链码状态的JSON文档的丰富查询，而LevelDB只支持针对键的查询。</p><h2 id="059c" class="lo kr ht bd ks lp lq lr kw ls lt lu la kd lv lw lc kh lx ly le kl lz ma lg mb dt translated">使用ChaincodeStubInterface方法查询和更新状态</h2><p id="cdaa" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">如许多示例所示，资产可以表示为复杂的结构——Golang structs，在进入chaincode状态之前，需要将这些结构封送到JSON string <br/>,在从状态接收之后，需要将其解组。</p><p id="1c64" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">用<code class="eh ji jj jk jl b">ChaincodeStubInterface</code>方法这些操作可以看起来像<br/> <a class="ae ln" href="https://github.com/IBM/build-blockchain-insurance-app/blob/master/web/chaincode/src/bcins/invoke_insurance.go" rel="noopener ugc nofollow" target="_blank">这个</a>:</p><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="2867" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在上面的示例中，智能合约代码显式执行许多辅助操作:</p><ul class=""><li id="fca4" class="me mf ht jw b jx jy ka kb kd mg kh mh kl mi kp mj mk ml mm dt translated">创建组合键</li><li id="50d3" class="me mf ht jw b jx mn ka mo kd mp kh mq kl mr kp mj mk ml mm dt translated">从state接收数据后解组数据</li><li id="198b" class="me mf ht jw b jx mn ka mo kd mp kh mq kl mr kp mj mk ml mm dt translated">在将数据置于状态之前对其进行编组</li></ul><h1 id="d223" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">使用CCKit进行链码状态操作</h1><h2 id="3534" class="lo kr ht bd ks lp lq lr kw ls lt lu la kd lv lw lc kh lx ly le kl lz ma lg mb dt translated">状态方法包装</h2><p id="d32b" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated"><a class="ae ln" href="https://github.com/s7techlab/cckit" rel="noopener ugc nofollow" target="_blank"> CCKit </a>，用于创建和测试Hyperledger Fabric golang chaincode的库，包含用于处理chain code状态的<code class="eh ji jj jk jl b">ChaincodeStubInteface</code>方法的<a class="ae ln" href="https://github.com/s7techlab/cckit/blob/master/state/state.go#L48" rel="noopener ugc nofollow" target="_blank">包装器</a>。该方法<a class="ae ln" rel="noopener" href="/coinmonks/erc20-token-as-hyperledger-fabric-golang-chaincode-d09dfd16a339">简化了</a>链码状态下的链码键创建和数据转换。</p><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="mc md l"/></div></figure><h2 id="aaff" class="lo kr ht bd ks lp lq lr kw ls lt lu la kd lv lw lc kh lx ly le kl lz ma lg mb dt translated">在链码状态下操作时进行字节转换</h2><p id="d67e" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">状态包装器允许自动将golang类型封送到/来自字节片。这种类型可以是:</p><ul class=""><li id="fba1" class="me mf ht jw b jx jy ka kb kd mg kh mh kl mi kp mj mk ml mm dt translated">实现<a class="ae ln" href="https://github.com/s7techlab/cckit/blob/master/convert/convert.go#L22" rel="noopener ugc nofollow" target="_blank"> ToByter和FromByter </a>接口的任何类型</li></ul><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="mc md l"/></div></figure><ul class=""><li id="1798" class="me mf ht jw b jx jy ka kb kd mg kh mh kl mi kp mj mk ml mm dt translated">Golang结构或支持的类型之一(<code class="eh ji jj jk jl b">int</code>、<code class="eh ji jj jk jl b">string</code>、<code class="eh ji jj jk jl b">[]string</code>)</li><li id="c106" class="me mf ht jw b jx mn ka mo kd mp kh mq kl mr kp mj mk ml mm dt translated"><a class="ae ln" href="https://developers.google.com/protocol-buffers/docs/gotutorial" rel="noopener ugc nofollow" target="_blank">协议缓冲报文</a></li></ul><p id="9375" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">Golang structs <a class="ae ln" href="https://github.com/s7techlab/cckit/tree/master/convert" rel="noopener ugc nofollow" target="_blank">使用<a class="ae ln" href="https://golang.org/pkg/encoding/json/#Marshal" rel="noopener ugc nofollow" target="_blank"> json自动</a>编组/解组。编组</a>和<br/>以及<a class="ae ln" href="https://golang.org/pkg/encoding/json/#Unmarshal" rel="noopener ugc nofollow" target="_blank"> json。Umarshal </a>方法。<a class="ae ln" href="https://godoc.org/github.com/golang/protobuf/proto#Marshal" rel="noopener ugc nofollow" target="_blank">原型。玛莎</a> l和<a class="ae ln" href="https://godoc.org/github.com/golang/protobuf/proto#Unmarshal" rel="noopener ugc nofollow" target="_blank"> proto。解组</a>用于转换protobuf。</p><h2 id="7134" class="lo kr ht bd ks lp lq lr kw ls lt lu la kd lv lw lc kh lx ly le kl lz ma lg mb dt translated">创建状态密钥</h2><p id="ab15" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">在chaincode数据模型中，我们经常需要在分类帐中存储一种类型的许多实例，例如多份商业票据、信用证等等。在这种情况下，这些实例的唯一键通常由属性组合构成，例如:</p><blockquote class="ms mt mu"><p id="07af" class="ju jv mv jw b jx jy iu jz ka kb ix kc mw ke kf kg mx ki kj kk my km kn ko kp hm dt translated"><code class="eh ji jj jk jl b">`CommercialPaper`</code> + <code class="eh ji jj jk jl b">{Issuer}</code> + <code class="eh ji jj jk jl b">{PaperId}</code></p></blockquote><p id="5c99" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">产生一系列链码状态条目密钥</p><blockquote class="ms mt mu"><p id="a5f4" class="ju jv mv jw b jx jy iu jz ka kb ix kc mw ke kf kg mx ki kj kk my km kn ko kp hm dt translated">[ <code class="eh ji jj jk jl b">`CommercialPaperIssuer1Id1`</code>，<code class="eh ji jj jk jl b">`CommercialPaperIssuer2Id2`</code>，…]</p></blockquote><p id="7ba2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">可以在代码中定制创建实例主键的逻辑，基于几个属性的组合构造实例的组合键。然后，组合键可以用作普通的字符串键，使用<code class="eh ji jj jk jl b">PutState()</code>和<code class="eh ji jj jk jl b">GetState()</code>函数记录和检索值。</p><p id="b32d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">下面的代码片段显示了在<code class="eh ji jj jk jl b">ChaincodeStubInterface</code>中创建和使用组合键的函数列表:</p><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="aeb6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">将数据放入链码状态或从链码状态获取数据时，必须提供密钥。<a class="ae ln" href="https://github.com/s7techlab/cckit" rel="noopener ugc nofollow" target="_blank"> CCKit </a>有3个选项用于处理条目键:</p><ul class=""><li id="39e7" class="me mf ht jw b jx jy ka kb kd mg kh mh kl mi kp mj mk ml mm dt translated">键可以显式传递给<code class="eh ji jj jk jl b">Put</code>方法</li></ul><pre class="jn jo jp jq fq mz jl na nb aw nc dt"><span id="18bb" class="lo kr ht jl b fv nd ne l nf ng">c.State().Put ( `my-key`, &amp;myStructInstance)</span></pre><ul class=""><li id="61dd" class="me mf ht jw b jx jy ka kb kd mg kh mh kl mi kp mj mk ml mm dt translated">按键类型可以实现<code class="eh ji jj jk jl b">Keyer</code>接口</li></ul><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="mc md l"/></div></figure><ul class=""><li id="1b04" class="me mf ht jw b jx jy ka kb kd mg kh mh kl mi kp mj mk ml mm dt translated">关键字可以是<code class="eh ji jj jk jl b">Key</code>类型——本质上是字符串的切片，该切片将使用<code class="eh ji jj jk jl b">shim.CreateCompositeKey </code>方法自动转换为字符串。</li></ul><p id="5a8e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">而在chaincode中你只需要提供类型实例，key就会自动创建:</p><pre class="jn jo jp jq fq mz jl na nb aw nc dt"><span id="4c83" class="lo kr ht jl b fv nd ne l nf ng">c.State().Put (&amp;myStructInstance)</span></pre><ul class=""><li id="daa0" class="me mf ht jw b jx jy ka kb kd mg kh mh kl mi kp mj mk ml mm dt translated">条目类型可以有关联映射</li></ul><p id="a3cd" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">映射为实体的名称空间(键的前缀)、主键和其他唯一键和非唯一键定义规则。映射主要与<code class="eh ji jj jk jl b">protobuf </code>状态模式一起使用。</p><h2 id="17a1" class="lo kr ht bd ks lp lq lr kw ls lt lu la kd lv lw lc kh lx ly le kl lz ma lg mb dt translated">范围查询</h2><p id="f6bf" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">除了使用惟一键检索资产之外，<code class="eh ji jj jk jl b">ChaincodeStubInterface</code>还为函数提供了根据一个范围标准检索资产集的机会。<br/>此外，可以构建组合键，以支持针对键的多个组成部分的查询。</p><p id="b2c5" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">range函数返回一个迭代器<code class="eh ji jj jk jl b">StateQueryIteratorInterface</code>，遍历一组匹配查询标准的键。返回的键按词法顺序排列。<br/>此外，当组合键有多个属性时，范围查询功能<code class="eh ji jj jk jl b">GetStateByPartialCompositeKey()</code>可用于搜索匹配属性子集的键。</p><p id="7433" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">例如，由<code class="eh ji jj jk jl b">Issuer</code>和<code class="eh ji jj jk jl b">PaperId </code>属性组成的<code class="eh ji jj jk jl b">CommercialPaper</code>的关键字，只能从一个<code class="eh ji jj jk jl b"> Issuer</code>中搜索条目。</p><h1 id="6b9c" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">Protobuf状态模型示例</h1><p id="c820" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">CCKit协议缓冲区<a class="ae ln" href="http://../examples/cpaper" rel="noopener ugc nofollow" target="_blank">示例</a>使用<a class="ae ln" href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/developapps/scenario.htm" rel="noopener ugc nofollow" target="_blank">商业票据场景</a>和<br/>实现与<a class="ae ln" href="https://github.com/hyperledger/fabric-samples/tree/release-1.4/commercial-paper/organization/digibank/contract" rel="noopener ugc nofollow" target="_blank">节点相同的功能。来自官方文档的链码样本。Protobuf是一种以高效且可扩展的格式编码结构化数据的方式。</a></p><h2 id="cc27" class="lo kr ht bd ks lp lq lr kw ls lt lu la kd lv lw lc kh lx ly le kl lz ma lg mb dt translated"><strong class="ak"> Protobuf模式优势:</strong></h2><ol class=""><li id="28d2" class="me mf ht jw b jx li ka lj kd nh kh ni kl nj kp nk mk ml mm dt translated"><strong class="jw hu">模式抽象层</strong></li></ol><p id="c789" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">以<code class="eh ji jj jk jl b">.proto</code>格式对业务对象的语义编码一次，就足以帮助确保消息不会在应用程序之间丢失，<br/>并且您创建的边界会强制实施您的业务规则。</p><p id="5113" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">2.<strong class="jw hu">扩展——验证器等</strong></p><p id="605f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">Protobuf v3不支持验证所需参数，但有第三方项目进行proto验证，例如<br/><a class="ae ln" href="https://github.com/mwitkow/go-proto-validators" rel="noopener ugc nofollow" target="_blank">https://github.com/mwitkow/go-proto-validators</a>。它允许在模式级别对数据结构的形状和有效性规则进行编码。</p><p id="0f49" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">3.<strong class="jw hu">简单的语言互操作性</strong> <br/>因为协议缓冲区是以多种语言实现的，它们使您的架构中多语言应用程序之间的互操作性变得更加简单。如果您使用Java Fabric SDK或Node引入新服务。Js Fabric SDK您只需将<code class="eh ji jj jk jl b">.proto</code>文件交给用目标语言编写的代码生成器，就可以保证这些架构之间的安全性和互操作性。</p><h2 id="8195" class="lo kr ht bd ks lp lq lr kw ls lt lu la kd lv lw lc kh lx ly le kl lz ma lg mb dt translated">定义模型</h2><p id="2ac7" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">使用协议缓冲区，您编写一个您希望存储的数据结构的<code class="eh ji jj jk jl b">.proto</code>描述。由此，协议缓冲区编译器创建了一个golang结构，该结构使用有效的二进制格式(或<code class="eh ji jj jk jl b">json</code>)实现了协议缓冲区数据的自动编码和解析。生成的类为组成协议缓冲区的字段提供getters和setters，并作为一个单元处理协议缓冲区的读写细节。</p><p id="cade" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在<a class="ae ln" href="https://github.com/s7techlab/cckit/tree/master/examples/cpaper" rel="noopener ugc nofollow" target="_blank">商业票据示例</a>中，我们首先定义消息，这些消息将以链码状态存储或用作事件:</p><ul class=""><li id="0b07" class="me mf ht jw b jx jy ka kb kd mg kh mh kl mi kp mj mk ml mm dt translated"><code class="eh ji jj jk jl b">CommercialPaper</code>将以链码状态存储</li><li id="4b9e" class="me mf ht jw b jx mn ka mo kd mp kh mq kl mr kp mj mk ml mm dt translated"><code class="eh ji jj jk jl b">CommercialPaperId</code>定义商业票据报文的唯一标识部分</li><li id="35ff" class="me mf ht jw b jx mn ka mo kd mp kh mq kl mr kp mj mk ml mm dt translated"><code class="eh ji jj jk jl b">IssueCommercialPaper</code>新商业票据发行时触发<code class="eh ji jj jk jl b">issue</code>交易及事件有效载荷</li><li id="95aa" class="me mf ht jw b jx mn ka mo kd mp kh mq kl mr kp mj mk ml mm dt translated"><code class="eh ji jj jk jl b">BuyCommercialPaper</code>商业票据变更主时触发<code class="eh ji jj jk jl b">buy</code>交易事件有效载荷</li><li id="691f" class="me mf ht jw b jx mn ka mo kd mp kh mq kl mr kp mj mk ml mm dt translated"><code class="eh ji jj jk jl b">RedeemCommercialPaper</code>商业票据兑付时触发<code class="eh ji jj jk jl b">redeem</code>交易和事件的有效负载</li></ul><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="mc md l"/></div></figure><h2 id="15c1" class="lo kr ht bd ks lp lq lr kw ls lt lu la kd lv lw lc kh lx ly le kl lz ma lg mb dt translated">定义protobuf到链代码的状态映射</h2><p id="07d2" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">协议缓冲区消息到链码映射器可用于在链码状态下存储模式实例。每个模式类型(protobuf或struct)都可以有映射规则:</p><ul class=""><li id="1c87" class="me mf ht jw b jx jy ka kb kd mg kh mh kl mi kp mj mk ml mm dt translated">主键创建逻辑</li><li id="3464" class="me mf ht jw b jx mn ka mo kd mp kh mq kl mr kp mj mk ml mm dt translated">命名空间逻辑</li><li id="1c9a" class="me mf ht jw b jx mn ka mo kd mp kh mq kl mr kp mj mk ml mm dt translated">二级密钥创建逻辑</li></ul><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="mc md l"/></div></figure><h2 id="ea2f" class="lo kr ht bd ks lp lq lr kw ls lt lu la kd lv lw lc kh lx ly le kl lz ma lg mb dt translated">链码</h2><p id="9b64" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">在<a class="ae ln" href="https://github.com/s7techlab/cckit/blob/master/examples/cpaper/chaincode.go" rel="noopener ugc nofollow" target="_blank">链码</a>中，我们简单地使用从<code class="eh ji jj jk jl b">.proto</code>文件中生成的结构，链码状态创建在映射中预定义。链代码实现使用<a class="ae ln" rel="noopener" href="/coinmonks/routing-and-middleware-for-developing-hyperledger-fabric-chaincode-written-in-go-90913951bf08"> CCKit路由和中间件特性</a>来构建代码。</p><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="mc md l"/></div></figure><h2 id="cc2f" class="lo kr ht bd ks lp lq lr kw ls lt lu la kd lv lw lc kh lx ly le kl lz ma lg mb dt translated">试验</h2><p id="5e13" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">我们可以使用<a class="ae ln" href="https://github.com/s7techlab/cckit/tree/master/testing" rel="noopener ugc nofollow" target="_blank"> MockStub </a>测试所有链代码用例场景:</p><figure class="jn jo jp jq fq jr"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="b080" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">关于链码单元测试和测试驱动开发的更多信息，你可以在这里阅读:</p><blockquote class="ms mt mu"><p id="17cc" class="ju jv mv jw b jx jy iu jz ka kb ix kc mw ke kf kg mx ki kj kk my km kn ko kp hm dt translated"><a class="ae ln" rel="noopener" href="/coinmonks/test-driven-hyperledger-fabric-golang-chaincode-development-dbec4cb78049">https://medium . com/coin monks/test-driven-hyperledger-fabric-golang-chain code-development-dbec 4c b 78049</a></p></blockquote><p id="37bc" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">链码也可以用IDL规范实现为服务。这允许为chaincode自动生成SDK、REST API、swagger规范和文档</p><blockquote class="ms mt mu"><p id="1158" class="ju jv mv jw b jx jy iu jz ka kb ix kc mw ke kf kg mx ki kj kk my km kn ko kp hm dt translated"><a class="ae ln" rel="noopener" href="/coinmonks/service-oriented-hyperledger-fabric-application-development-32e66f578f9a">https://medium . com/coin monks/service-oriented-hyperledger-fabric-application-development-32 e 66 f 578 F9 a</a></p></blockquote></div></div>    
</body>
</html>