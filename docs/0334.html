<html>
<head>
<title>Using APIs in Your Ethereum Smart Contract with Oraclize</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在带有Oraclize的以太坊智能合约中使用API</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/using-apis-in-your-ethereum-smart-contract-with-oraclize-95656434292e?source=collection_archive---------0-----------------------#2018-04-20">https://medium.com/coinmonks/using-apis-in-your-ethereum-smart-contract-with-oraclize-95656434292e?source=collection_archive---------0-----------------------#2018-04-20</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="ffd0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从外部数据源获取数据到区块链是一个不小的问题，一个解决方案是使用<a class="ae jo" href="http://www.oraclize.it/" rel="noopener ugc nofollow" target="_blank">或</a>。关于神谕的利与弊及其背后的技术细节，已经有很多<a class="ae jo" href="https://blog.ethereum.org/2014/07/22/ethereum-and-oracles/" rel="noopener ugc nofollow" target="_blank"/><a class="ae jo" href="https://blog.oraclize.it/" rel="noopener ugc nofollow" target="_blank"/><a class="ae jo" href="https://www.reddit.com/r/ethereum/comments/6d7j7x/how_can_i_trust_smart_contracts_that_use_oraclize/" rel="noopener ugc nofollow" target="_blank">的信息</a>了，所以我们不会深入探讨。相反，我们将介绍如何使用Oraclize将任何web API连接到智能合约。</p><p id="654c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我开始尝试学习如何使用Oraclize时，我遇到了一些障碍，并且在网上找不到太多可用的信息。我希望找到一个简单、全面的教程，涵盖基本查询、验证证据、加密API密钥和设置测试，但结果却是空的。因此，我决定写这个教程来帮助其他人寻找同样的东西。</p><p id="a200" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本文中，我们将首先设置Remix来使用Oraclize，然后我们将讨论编写和加密查询。之后，将讨论在契约中实现和验证Oraclize查询。最后，我们将使用Truffle为这些Oraclize查询编写测试。希望这对您有所帮助！</p><p id="f4c4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">注:下面的大部分信息来自于</em> <a class="ae jo" href="http://docs.oraclize.it/" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> Oraclize文档</em> </a> <em class="jp">以及对他们的</em><a class="ae jo" href="https://gitter.im/oraclize/ethereum-api" rel="noopener ugc nofollow" target="_blank"><em class="jp">Gitter</em></a><em class="jp">的挖掘。根据需要提供其他参考资料。本教程假设了JavaScript、Solidity、Remix和Truffle的基础知识。</em></p><blockquote class="jq"><p id="d90d" class="jr js ht bd jt ju jv jw jx jy jz jn ek translated"><a class="ae jo" href="https://coincodecap.com/category/blockchain-node-and-api" rel="noopener ugc nofollow" target="_blank">发现并回顾最佳区块链api和节点产品</a></p></blockquote><h1 id="5ddf" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">第0步:等等，Oraclize是什么？</h1><p id="cd52" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">我们不会在这里详细讨论Oraclize是如何工作的，因为在他们的网站上有详细介绍。对于这篇文章，您只需要知道:</p><ul class=""><li id="4916" class="ld le ht is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll dt translated">Oraclize提供了一种从任何web API获取外部数据到区块链的方法</li><li id="159b" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">要使用它，您将使用Oraclize的智能契约通过API调用向Oraclize发送查询。一旦它们从API获得结果，它们就调用智能契约中名为<code class="eh lr ls lt lu b">__callback</code>的函数，并将结果作为输入传递给它。</li></ul><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/f67cccb875c20e593711605ccd8d3baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*ycCwcd8bE5tQhxojpKIrBA.png"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Oraclize (<a class="ae jo" href="https://blog.oraclize.it/new-blockchain-integrations-and-beyond-e1a6d92bda85" rel="noopener ugc nofollow" target="_blank">source</a>)</figcaption></figure><h1 id="25d4" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx dt translated">步骤1:使用混音进行设置</h1><p id="fbd4" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">首先，让我们建立我们的开发环境。设置使用Oraclize编写合同的环境有一些注意事项，因为Oraclize与Remix上的JavaScript VM不兼容。它与mainnet、Rinkeby、Ropsten和Kovan兼容，但是使用testnet进行开发当然会非常痛苦，所以不推荐使用。</p><p id="800e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">幸运的是，Oraclize拥有他们自己的<a class="ae jo" href="http://dapps.oraclize.it/browser-solidity/" rel="noopener ugc nofollow" target="_blank">补丁版本的Remix IDE </a>，它“增加了一个插件，可以直接从浏览器测试基于以太坊或Oraclize的合同”。让我们以此为起点。</p><h2 id="58a2" class="mk kb ht bd kc ml mm mn kg mo mp mq kk jb mr ms ko jf mt mu ks jj mv mw kw mx dt translated">配置混音</h2><p id="c641" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">打开Remix的Oraclize版本后，您会看到多个示例文件。您还会注意到右边的列有许多导航图标，左边第四个(Oraclize选项卡)可能有一个红色的感叹号。如果是的话，点击这个，你会看到下图。</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff my"><img src="../Images/10f5a725f2104507b5885d27a3675aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLDY4rEbPqlm17agI6e3-A.png"/></div></div><figcaption class="md me fg fe ff mf mg bd b be z ek">If you see this, you must configure the environment to use Oraclize</figcaption></figure><p id="84f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是一个简单的修复方法:只需单击左边第三个立方体图标(Environment选项卡)并选择JavaScript VM选项。这与标准Remix IDE相反——要在标准Remix IDE中使用Oraclize，您必须使用injected Web3，而要在Oraclize Remix IDE中使用Oraclize，您必须使用JavaScript VM。</p><p id="0b4e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您现在尝试部署和使用这些示例契约中的一个，您可能会得到一个无用的错误，显示<em class="jp"> VM异常:耗尽</em>。如果是这样，单击左边的齿轮图标(Settings选项卡)并查看正在使用的编译器。从这个关于GitHub问题的<a class="ae jo" href="https://github.com/oraclize/ethereum-api/issues/21#issuecomment-373746546" rel="noopener ugc nofollow" target="_blank">评论</a>来看，似乎Solidity版本0.4.21可能有一些与Oraclize不兼容的突破性变化，所以将其更改为版本0.4.20或更低。版本0.4.20+commit.3155dd80一直在为我工作，也是我将在整篇文章中使用的。</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff nd"><img src="../Images/a19c02b90365b8931ac98a8e2f3fac1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ximx5BdXW-19uAwEbUjSgw.png"/></div></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Change the compiler to version 0.4.20 or lower</figcaption></figure><p id="c9ee" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用红色的“Create”按钮，您现在应该能够在JavaScript VM上部署任何示例契约了！这些示例契约都被配置为在部署后查询Oraclize，因此，如果您在部署后等待几秒钟，您会看到在右侧记录了一个事件。此事件将显示从API调用返回的值。</p><h2 id="17a5" class="mk kb ht bd kc ml mm mn kg mo mp mq kk jb mr ms ko jf mt mu ks jj mv mw kw mx dt translated">使用Oraclize查询</h2><p id="91ba" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">现在是解释一些关于Oraclize如何处理气体的简单事情的好时机。您可能已经注意到，您不能再次调用<code class="eh lr ls lt lu b">update</code>函数来进行额外的API调用，除非您在事务中发送Ether。这是因为使用Oraclize支付汽油费用的方式。以下是你需要了解的关于天然气的一切，直接来自<a class="ae jo" href="http://docs.oraclize.it/#ethereum-quick-start-custom-gas-limit-and-gas-price" rel="noopener ugc nofollow" target="_blank">的文档</a>:</p><ul class=""><li id="928f" class="ld le ht is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll dt translated">对于任何合同，使用默认gas参数的第一个Oraclize查询都是免费的(gas参数可以更改，如第3步末尾所述)</li><li id="eef7" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">所有后续请求都要求合同支付(1)使用Oraclize的费用，以及(2)支付回调交易的汽油费用</li><li id="2e8b" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">付款将自动从合同余额中扣除</li><li id="1fdd" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">如果合同余额不足以支付天然气费用，请求将失败，Oraclize将不会返回任何数据(请确保在您的合同中处理这种情况！)</li><li id="974a" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">除非另有规定，否则默认气价为20 Gwei，回拨交易的默认气限为200，000</li><li id="d43d" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">未用完的汽油将退还给Oraclize，不会退还给你的合同</li><li id="dcde" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">价格适用于mainnet和所有testnet，但由于价格是以以太网支付的，testnet的使用实际上是免费的</li><li id="99b2" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">使用Oraclize的费用如下表所示，但请查看文档的<a class="ae jo" href="http://docs.oraclize.it/#pricing" rel="noopener ugc nofollow" target="_blank">定价部分</a>了解最新价格</li></ul><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff ne"><img src="../Images/60258834fecb3f57253f3ea6e27e4af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zgoM6FRorau9SW0ZAyts4g.png"/></div></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Oraclize pricing</figcaption></figure><p id="4935" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为简单起见，在本文中，我们将始终使查询Oraclize的函数至少需要0.004 ETH —这来自默认值200，000 gas和20 Gwei ( <code class="eh lr ls lt lu b">200,000 gas * 20 Gwei = 4,000,000 Gwei = 0.004 ETH</code>)。另一种方法是要求构造函数中有足够数量的ETH。请记住，多余的汽油是不退款的，所以这些默认值应该根据您的具体查询进行定制，以最大限度地减少未使用的汽油。</p><p id="2835" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">可能对以后有帮助的快速补充说明:我发现自己经常犯的一个小错误是不小心将值发送给了一个没有指定为payable的函数，反之亦然。使用左起第二个图标(交易选项卡)指定交易气体限值和值。</p><h1 id="d4be" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx dt translated">步骤2:让您的查询工作起来</h1><p id="2140" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">您可以在样本契约中看到一些示例查询，但是这些查询对于许多现实情况来说太简单了。例如，看看这个由<a class="ae jo" href="https://etheroll.com/" rel="noopener ugc nofollow" target="_blank">Etheroll.com</a>使用的巨大查询(不要担心，当我们建立它时，你很快就会明白)。</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="nf ng l"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Etheroll’s Oraclize query (in this article, code snippets with the .sol.js extension are Solidity, and the .js is just there so GitHub applies syntax highlighting)</figcaption></figure><p id="5823" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这一节中，我们将使用<a class="ae jo" href="https://www.random.org/" rel="noopener ugc nofollow" target="_blank">random.org</a>API来逐步理解和使用我们自己版本的上述Etheroll查询。这里介绍的步骤应该适用于许多其他API。本小节的其余部分只是关于随机数生成的注释。如果您打算将Oraclize与其他类型的API一起使用，请随意跳过这一步。</p><p id="1d40" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">注:Oraclize说</em> <a class="ae jo" href="http://docs.oraclize.it/#data-sources-random" rel="noopener ugc nofollow" target="_blank"> <em class="jp">随机数据源</em> </a> <em class="jp">使用s a Ledger Nano S比random.org API更好地生成随机数(完整白皮书</em> <a class="ae jo" href="http://www.oraclize.it/papers/random_datasource-rev1.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="jp">此处</em> </a> <em class="jp">)。另一方面，random.org API在返回值的范围、数量和分布方面更加灵活。要知道，随机数据源</em> <a class="ae jo" href="https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/README.md" rel="noopener ugc nofollow" target="_blank"> <em class="jp">在JavaScript VM </em> </a> <em class="jp">上是不可用的，只在mainnet和公共testnets上起作用。</em></p><p id="834a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">以下是Oraclize在Gitter上关于随机数据源(random DS)的评论。出于某种原因，你无法链接到Gitter上的特定评论，除非你通过谷歌找到它们，所以我在下面粘贴了这条评论。</em></p><blockquote class="nh ni nj"><p id="a05d" class="iq ir jp is b it iu iv iw ix iy iz ja nk jc jd je nl jg jh ji nm jk jl jm jn hm dt translated">random DS非常可靠，在出现故障的情况下，这些故障是建立在强有力的保证之上的，所以如果它不时出现故障，不要将其视为一件坏事。失败率目前取决于网络质量/孤立率。</p><p id="7a48" class="iq ir jp is b it iu iv iw ix iy iz ja nk jc jd je nl jg jh ji nm jk jl jm jn hm dt translated">关于随机DS vs Random.org web；他们有不同的保障。我们可以让我们的一位研究人员回答哪个更好(但最终这只是不同人的意见[原文])，或者您可以参考分类帐/随机DS证明白皮书，如果有兴趣，我们可以链接。</p><p id="9d5c" class="iq ir jp is b it iu iv iw ix iy iz ja nk jc jd je nl jg jh ji nm jk jl jm jn hm dt translated">总之，Random DS给了你一个非常强大的能力，因为它给出了一个可以在链上验证的证明，这应该提供了更大的保证，没有欺骗发生。一个缺点是，它使用了Ledger的内部PRNG，但如果它被破坏或被后门，就会有更大的风险，因为人们使用Ledger设备持有数百万美元，到目前为止，没有一个明显由于糟糕的RNG而受到损害。</p><p id="a32d" class="iq ir jp is b it iu iv iw ix iy iz ja nk jc jd je nl jg jh ji nm jk jl jm jn hm dt translated">Random.org声称真正的RNG，但你必须记住，他们仍然是一个中央权威，你信任他们只是基于他们的声誉。伴随而来的证据对于事后核实是有用的，但它不会阻止ETH在此刻被转让，即使与Random.org或任何其他参与者之间存在妥协(尽管随着新技术的引入，这可能成为可能[参见<a class="ae jo" href="http://docs.oraclize.it/#ethereum-advanced-topics-proofshield" rel="noopener ugc nofollow" target="_blank"> ProofShield </a> ])。随机DS证明已经可以做到这一点。</p><p id="41f2" class="iq ir jp is b it iu iv iw ix iy iz ja nk jc jd je nl jg jh ji nm jk jl jm jn hm dt translated">使用随机DS可能也是一种让自己与众不同的好方法，但是最终，由你来决定什么最适合你的项目和客户。</p></blockquote><h2 id="62d5" class="mk kb ht bd kc ml mm mn kg mo mp mq kk jb mr ms ko jf mt mu ks jj mv mw kw mx dt translated">初始查询设置</h2><p id="3b99" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">下面是Etheroll查询，所以你不需要滚动那么远。</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="nf ng l"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Etheroll’s Oraclize query (again)</figcaption></figure><p id="a3d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">先从简单的开始:在上面的查询中，<code class="eh lr ls lt lu b">bytes32 rngID = oraclize_query(…)</code>部分就是如何调用Oraclize，其中<code class="eh lr ls lt lu b">bytes32</code>是<code class="eh lr ls lt lu b">rngID</code>的类型，<code class="eh lr ls lt lu b">rngID</code>对应于<a class="ae jo" href="http://docs.oraclize.it/#ethereum-quick-start-the-query-id" rel="noopener ugc nofollow" target="_blank">查询ID </a>。查询ID是Oraclize提供的返回值，用于帮助验证回调结果，并确保回调函数只被调用一次。为了确保给定查询的回调不会被无意中调用两次，建议在发送查询时将该ID存储在映射中，并在收到回调时将其删除。这将显示在步骤3中的样本契约中。</p><p id="6376" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">好了，现在让我们为他们的<a class="ae jo" href="https://api.random.org/json-rpc/1/" rel="noopener ugc nofollow" target="_blank"> JSON-RPC API </a>获取一个random.org<a class="ae jo" href="https://api.random.org/api-keys/beta" rel="noopener ugc nofollow" target="_blank">API键</a>。跟踪您的密钥，并记住您不希望共享此密钥或允许任何其他人使用它。或者，您应该能够使用API键<code class="eh lr ls lt lu b">00000000–0000–0000–0000–000000000000</code>来跟进。</p><p id="5e28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">注意:请注意，random.org API的JSON-RPC版本仍处于公开测试阶段。</em></p><p id="cfdb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，从链接的最后一个URL点击<em class="jp">简介</em>，您将看到API是使用URL <code class="eh lr ls lt lu b"><a class="ae jo" href="https://api.random.org/json-rpc/1/invoke" rel="noopener ugc nofollow" target="_blank">https://api.random.org/json-rpc/1/invoke</a></code>调用的。然后回到上一页，点击<em class="jp">数字签名</em>，在这里你会发现已签名的API方法可供使用。在这种情况下，我们将假设随机数用于我们想要生成一个随机数的彩票或抽彩类型的合同，因此<code class="eh lr ls lt lu b">generateSignedIntegers</code>是我们想要的方法。</p><p id="cdc1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">方便的是，Oraclize有一个<a class="ae jo" href="http://app.oraclize.it/home/test_query" rel="noopener ugc nofollow" target="_blank">测试查询工具</a>来帮助在开发过程中测试您的查询，所以我们将使用它来让我们的random.org查询工作。一旦进入该页面，您需要将查询类型更改为URL(POST)，并在字段中输入<code class="eh lr ls lt lu b">json(https://api.random.org/json-rpc/1/invoke).result</code>。从<code class="eh lr ls lt lu b">generateSignedIntegers</code>文档中，我们知道POST数据的一组有效参数如下:</p><pre class="lw lx ly lz fq nn lu no np aw nq dt"><span id="906a" class="mk kb ht lu b fv nr ns l nt nu">{<br/>    "jsonrpc": "2.0",<br/>    "method": "generateSignedIntegers",<br/>    "params": {<br/>        "apiKey": "00000000-0000-0000-0000-000000000000",<br/>        "n": 1,<br/>        "min": 1,<br/>        "max": 1000,<br/>        "replacement": true,<br/>        "base": 10<br/>    },<br/>    "id": 14215<br/>}</span></pre><p id="2551" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">将此输入标记为“发布数据”的字段。现在，即使您尝试删除所有保留的空格，您的测试查询仍然不会返回任何内容。这是因为你需要把<code class="eh lr ls lt lu b">\n</code>放在文章数据的左括号之前。这是"<a class="ae jo" href="https://github.com/oraclize/ethereum-examples/issues/2#issuecomment-234308953" rel="noopener ugc nofollow" target="_blank">让Oraclize知道您想要发送一个JSON POST主体请求，而不是一个POST url编码请求</a>"所必需的。之后，您的POST数据字段应该如下所示:</p><pre class="lw lx ly lz fq nn lu no np aw nq dt"><span id="bded" class="mk kb ht lu b fv nr ns l nt nu">\n{"jsonrpc": "2.0", "method": "generateSignedIntegers", "params": { "apiKey": "00000000-0000-0000-0000-000000000000", "n": 1, "min": 1, "max": 1000, "replacement": true, "base": 10 }, "id": 14215 }</span></pre><p id="3819" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在您的测试查询可以工作了！(即使您没有更新API密钥，它也应该可以工作)。</p><p id="5a95" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">注意:测试查询工具确实会在一段时间后超时，请注意，如果使用c </em> <a class="ae jo" href="http://docs.oraclize.it/#data-sources-computation" rel="noopener ugc nofollow" target="_blank"> <em class="jp">计算数据源</em> </a> <em class="jp">，可能需要几分钟才能完成。</em></p><p id="9412" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您会注意到查询返回的不仅仅是一个随机数。我们不需要返回的所有内容—我们只需要随机数—所以让我们更新查询以反映这一点。现在应该是:</p><pre class="lw lx ly lz fq nn lu no np aw nq dt"><span id="5292" class="mk kb ht lu b fv nr ns l nt nu">json(https://api.random.org/json-rpc/1/invoke).result.random["data"]</span></pre><p id="9b91" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">不使用<code class="eh lr ls lt lu b">.random["data”]</code>，我们可以使用<code class="eh lr ls lt lu b">.random.data.0</code>，因为我们只返回一个数字。然而，<code class="eh lr ls lt lu b">.random["data"]</code>格式也很容易适用于返回其他参数，比如后面解释的<code class="eh lr ls lt lu b">serialNumber</code>字段。请随意使用查询来测试这一点，例如:</p><pre class="lw lx ly lz fq nn lu no np aw nq dt"><span id="cd09" class="mk kb ht lu b fv nr ns l nt nu">json(https://api.random.org/json-rpc/1/invoke).result.random["serialNumber","data"]</span></pre><h2 id="d9ed" class="mk kb ht bd kc ml mm mn kg mo mp mq kk jb mr ms ko jf mt mu ks jj mv mw kw mx dt translated">准备添加加密</h2><p id="5e9b" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">Oraclize允许您加密整个查询，或者只加密某些参数。加密完整的查询意味着用户必须相信您确实在使用您声称正在使用的API，因此我们只加密API密钥。这就是所谓的部分加密。</p><p id="61e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了加密你的密钥，Oraclize提供了一个<a class="ae jo" href="https://github.com/oraclize/encrypted-queries/tree/master/tools" rel="noopener ugc nofollow" target="_blank"> Python脚本</a>，你可以在文档的<a class="ae jo" href="http://docs.oraclize.it/#ethereum-advanced-topics-encrypted-queries" rel="noopener ugc nofollow" target="_blank">加密查询</a>部分找到它。点击该链接，下载脚本，并使用<a class="ae jo" href="https://pip.pypa.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> pip </a>安装任何您没有的所需Python包(可能是<em class="jp">密码术</em>和<em class="jp"> base58 </em>包)。脚本<a class="ae jo" href="https://github.com/oraclize/encrypted-queries/issues/2#issuecomment-333160340" rel="noopener ugc nofollow" target="_blank">是为Python 2 </a>制作的，所以我建议用Python 2而不是Python 3来运行。要运行它，请在终端中输入以下命令:</p><pre class="lw lx ly lz fq nn lu no np aw nq dt"><span id="0b7d" class="mk kb ht lu b fv nr ns l nt nu">python encrypted_queries_tools.py -e -p 044992e9473b7d90ca54d2886c7addd14a61109af202f1c95e218b0c99eb060c7134c4ae46345d0383ac996185762f04997d6fd6c393c86e4325c469741e64eca9 "PASTE YOUR QUERY HERE"</span></pre><p id="5e1c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您粘贴的查询可以是完整的查询，或者只是API键，就像我们的例子一样。出于稍后将变得清楚的原因，我更喜欢粘贴不带引号的键，尽管这两种方法都可以。因此，您的查询应该如下所示:</p><pre class="lw lx ly lz fq nn lu no np aw nq dt"><span id="374f" class="mk kb ht lu b fv nr ns l nt nu">python encrypted_queries_tools.py -e -p 044992e9473b7d90ca54d2886c7addd14a61109af202f1c95e218b0c99eb060c7134c4ae46345d0383ac996185762f04997d6fd6c393c86e4325c469741e64eca9 00000000-0000-0000-0000-000000000000</span></pre><p id="b3f8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行它将输出加密的密钥。不幸的是，测试查询站点似乎不支持部分加密的查询(或者如果支持，那是我做错了什么)，所以现在只需将加密的密钥放在手边。</p><p id="9369" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">需要注意的是，第一个使用加密查询或参数进行查询或查询的契约将成为该加密查询的“所有者”。如果另一个协定尝试使用相同的加密查询，它将收到一个空结果。这样做是为了防止“重放攻击”，即其他用户使用您的精确加密查询或密钥。因此，每当重新部署使用加密查询的协定时，都需要生成新的加密密钥。</p><h1 id="6646" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx dt translated">步骤3:将查询实现到契约中</h1><p id="b166" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">还和我在一起吗？很好！因为我们的查询现在已经准备好实现到契约中了。</p><h2 id="f87a" class="mk kb ht bd kc ml mm mn kg mo mp mq kk jb mr ms ko jf mt mu ks jj mv mw kw mx dt translated">设置</h2><p id="4e2d" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">从第1步回到Oraclize的Remix IDE，确保它仍然配置正确，并创建一个如下所示的新契约。</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="nf ng l"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Initial setup of our Template.sol contract</figcaption></figure><p id="ff33" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在第二行中，我们导入Oraclize契约。您可能会注意到这与文档不同，在文档中他们导入了<code class="eh lr ls lt lu b">oraclizeAPI.sol</code>。这是可以的，因为两个版本非常相似，但是v0.5是针对新的编译器版本的，因此删除了许多警告。要知道在Remix之外，可能不支持从GitHub直接导入。相反，您需要使用本地导入，或者直接从GitHub上的<a class="ae jo" href="https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol" rel="noopener ugc nofollow" target="_blank"> oraclizeAPI_0.5.sol契约</a>中粘贴Oraclize代码。</p><p id="a484" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你熟悉Oraclize，合同应该很清楚，但是我们将为那些不熟悉的人简单回顾一下。在<code class="eh lr ls lt lu b">getRandomNumber</code>中，我们确保发送了最少量的乙醚来支付汽油费用，然后我们将API查询发送给Oraclize(其中<code class="eh lr ls lt lu b">...</code>是查询的占位符)。</p><p id="3941" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一旦Oraclize处理了我们的查询并从API中检索到所需的数据，它就会调用我们的契约的<code class="eh lr ls lt lu b">__callback</code>函数。任何依赖于API调用结果的逻辑都应该在这个函数中完成。我们不希望除了Oraclize之外的任何人调用这个函数，所以我们首先必须检查调用者。之后，我们可以保存我们的随机数，并做任何其他需要的事情。我们目前没有使用<code class="eh lr ls lt lu b">__callback</code>中的所有输入，但是我们将在下一节中使用。</p><h2 id="a8c6" class="mk kb ht bd kc ml mm mn kg mo mp mq kk jb mr ms ko jf mt mu ks jj mv mw kw mx dt translated">添加事件和验证</h2><p id="2c32" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">在添加查询之前，让我们向契约添加一些<a class="ae jo" href="http://solidity.readthedocs.io/en/v0.4.20/contracts.html#events" rel="noopener ugc nofollow" target="_blank">事件</a>。使用事件有两个主要好处:</p><ol class=""><li id="5271" class="ld le ht is b it iu ix iy jb lf jf lg jj lh jn nv lj lk ll dt translated">我们可以在测试期间和部署之后监听事件，以确保一切正常运行</li><li id="2d0e" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn nv lj lk ll dt translated">我们使用的random.org API会返回一个序列号，每次调用该API都会增加1。将此记录为事件有助于防止this <a class="ae jo" href="https://gist.github.com/pipermerriam/7c580b9f07eb7ae2d49038a795279ee5#heading-4.2.2" rel="noopener ugc nofollow" target="_blank"> Etheroll审计报告</a>中描述的攻击，从而保持诚实。</li></ol><p id="ba1c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果在mainnet上使用这个，步骤2变得非常重要，您肯定会想要记录<code class="eh lr ls lt lu b">serialNumber</code>字段。我们不会在这里这样做，但这样做不会太难。如上所述，只需将查询的适当部分修改为<code class="eh lr ls lt lu b">....result.random["serialNumber","data"]</code>，然后使用Nick Johnson的<a class="ae jo" href="https://github.com/Arachnid/solidity-stringutils" rel="noopener ugc nofollow" target="_blank"> stringutils </a>库等库来有效地解析返回的字符串。</p><p id="fa3e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你熟悉Solidity，添加事件是非常简单的。我们将在发送查询后添加一个事件，在收到结果后添加另一个事件。</p><p id="c01d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来我们将添加第一个验证检查，这是使用导入的<code class="eh lr ls lt lu b">oraclizeAPI_0.5.sol</code>契约的<code class="eh lr ls lt lu b">oraclize_setProof</code>函数向Oraclize请求一个<a class="ae jo" href="http://docs.oraclize.it/#ethereum-quick-start-authenticity-proofs" rel="noopener ugc nofollow" target="_blank">真实性证明</a>。默认配置不要求证明，因此Oraclize不会计算证明。我们不会在这里深入讨论证明的细节，我们将简单地使用Oraclize文档中的示例中显示的证明类型。(如果感兴趣，您可以在此阅读更多关于证明类型的信息<a class="ae jo" href="http://docs.oraclize.it/#security-deepdive-authenticity-proofs-types" rel="noopener ugc nofollow" target="_blank">)。要使用回调请求证明，只需将下面一行添加到构造函数中:</a></p><pre class="lw lx ly lz fq nn lu no np aw nq dt"><span id="b0a2" class="mk kb ht lu b fv nr ns l nt nu">oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);</span></pre><p id="65e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这一行告诉Oraclize我们想要一个TLSNotary证明作为一个base58解码的IPFS多重散列返回给我们。字节必须编码为base58以获得IPFS多重散列。</p><p id="50ae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果我们要求不设置IPFS存储的TLSNotary proof，成本会高得多，你需要提供更多的气体。目前没有理由不使用IPFS，因为没有<a class="ae jo" href="http://docs.oraclize.it/#ethereum-advanced-topics-proofshield" rel="noopener ugc nofollow" target="_blank">proof shield</a>TLS notary是无法在链上验证的。通过IPFS，可以使用<a class="ae jo" href="https://github.com/oraclize/proof-verification-tool" rel="noopener ugc nofollow" target="_blank">证明验证工具</a>离线保存和验证multihash。<a class="ae jo" href="http://app.oraclize.it/service/monitor" rel="noopener ugc nofollow" target="_blank">网络监视器</a>也可以用来确保Oraclize诚实行事。</p><p id="75f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果Oraclize由于技术原因无法提供真实性证明，该函数仍将执行，但没有所请求的证明。如何处理这一点取决于您，尽管Oraclize建议丢弃结果并创建一个新的查询。如果您愿意，一种想法是获取我们的API返回的随机数，将其与证明结果散列，并使用它来生成最终的随机数。这是以太网合同采取的方法。</p><p id="14ab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">虽然除了请求生成此证明之外，我们目前不会对此证明做任何事情，但您很快就可以使用它和<a class="ae jo" href="http://docs.oraclize.it/#ethereum-advanced-topics-proofshield" rel="noopener ugc nofollow" target="_blank"> ProofShield </a>来验证链上提供的真实性证明。这将允许您确保您收到的结果没有被篡改，并且可以安全地用于您的合同中。</p><p id="f40e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jp">注意:在撰写本文时，testnets上的证明由于一些滥用已经被禁用，所以现在你可能会看到一个空的证明。此外，请记住前面显示的价格图表，申请证明是有成本的。</em></p><p id="82d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下一个验证步骤是利用查询ID。回想一下，我们想要使用映射来跟踪每个请求的查询ID，以确保每个查询只调用一次<code class="eh lr ls lt lu b">__callback</code>函数。一个名为<code class="eh lr ls lt lu b">validIds</code>的变量被添加到我们的契约中来跟踪这个。这个过程很简单，在下面更新的合同中可以很容易地看到。该契约还包括前面提到的事件，并将证据类型设置为刚才讨论的那样。</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="nf ng l"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Updated contract with events and query verification</figcaption></figure><h2 id="5b62" class="mk kb ht bd kc ml mm mn kg mo mp mq kk jb mr ms ko jf mt mu ks jj mv mw kw mx dt translated">添加查询</h2><p id="3983" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">现在，让我们根据之前生成的测试查询来填充查询。该查询将采用以下形式:</p><pre class="lw lx ly lz fq nn lu no np aw nq dt"><span id="67cc" class="mk kb ht lu b fv nr ns l nt nu">oraclize_query( "nested", <br/>                "[URL] ['POST URL', 'POST Data']",<br/>                customGasLimit);</span></pre><p id="90e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">需要<code class="eh lr ls lt lu b">nested</code> <a class="ae jo" href="http://docs.oraclize.it/#data-sources-nested" rel="noopener ugc nofollow" target="_blank">数据源</a>来允许部分加密(即仅加密API密钥，而非完整查询)。第二个参数由一个<code class="eh lr ls lt lu b">[URL]</code>标志组成，表示我们的数据源是一个HTTP API。然后，我们需要指定测试查询中使用的POST URL，以及测试查询中使用的JSON POST数据对象。这里的最后一个参数允许我们使用不同于默认值的气体限制。它是可选的，所以我们现在忽略它。</p><p id="b321" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们正在使用Solidity，您需要对URL中的所有引号和之前测试查询中使用的JSON POST数据进行转义。因此，从所示的测试查询开始，您应该以下面的代码片段结束。</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff nw"><img src="../Images/410c6db4084d0ebb7e77a160f016659b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7VFKi4b5rfdGBT8pw7b-FA.png"/></div></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Successful test query, with resulting function below</figcaption></figure><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="nf ng l"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Function implementing our random.org API call, with corresponding test query above</figcaption></figure><p id="9e93" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">更新上面的测试合同，并对其进行一些修改，以确保一切正常。您应该会在右边的列中看到记录的事件。如果没有，您可能在查询中遇到了问题。导航到左起第四个选项卡(Oraclize选项卡)，然后单击一个查询。这将打开一个选项卡，显示该查询的详细信息，包括任何错误消息。</p><h2 id="010b" class="mk kb ht bd kc ml mm mn kg mo mp mq kk jb mr ms ko jf mt mu ks jj mv mw kw mx dt translated">加密查询</h2><p id="5df6" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">接下来，挖掘我们之前制作的加密API密钥，因为我们现在将把它添加进去。我们将使用<code class="eh lr ls lt lu b">decrypt</code> <a class="ae jo" href="http://docs.oraclize.it/#data-sources-decrypt" rel="noopener ugc nofollow" target="_blank">数据源</a>用它的加密副本替换API密钥。这采用了<code class="eh lr ls lt lu b">${[decrypt] EncryptedAPIKey}</code>的形式，产生了下面的更新函数。注意我们的<code class="eh lr ls lt lu b">${[decrypt] ...}</code>部分是如何被引号包围的。这是必要的，因为我们之前在没有引号的情况下加密了我们的API密钥。如果我们使用转义引号来加密密钥，这些就没有必要了。</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="nf ng l"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Encrypted Oraclize query</figcaption></figure><p id="0900" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">除了添加了<code class="eh lr ls lt lu b">decrypt</code>参数之外，您会注意到POST数据中还有一个新的字符串— <code class="eh lr ls lt lu b">${[identity] \"}\"}</code>。这个<a class="ae jo" href="http://docs.oraclize.it/#general-concepts-data-source-types" rel="noopener ugc nofollow" target="_blank">数据源</a>在文档中没有很好的解释，但是Oraclize团队能够在<a class="ae jo" href="https://gitter.im/oraclize/ethereum-api" rel="noopener ugc nofollow" target="_blank"> Gitter </a>上帮助我。我将在这里重复解释:注意对于<code class="eh lr ls lt lu b">decrypt</code>数据源，我们必须使用<code class="eh lr ls lt lu b">}</code>作为子查询的分隔符。但是我们也需要在JSON POST数据中使用相同类型的右括号。由于<code class="eh lr ls lt lu b">}</code>是用于分隔子查询的特殊字符，我们需要对想要包含在JSON中的大括号进行转义。因此<code class="eh lr ls lt lu b">${[identity] \"}\"}</code>段确保引号内的所有内容(即本例中只有<code class="eh lr ls lt lu b">}</code>)都作为JSON POST数据本身的一部分包含在内，而不是限定子查询。希望我解释清楚了。</p><p id="7d0d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">多试验一下，确保一切正常，一旦你启动并运行了，我们将通过修改气体参数来结束。</p><h2 id="39cb" class="mk kb ht bd kc ml mm mn kg mo mp mq kk jb mr ms ko jf mt mu ks jj mv mw kw mx dt translated">定制气体参数</h2><p id="e719" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">随着更难的部分的方式，让我们结束这一节的一些简单的东西，简单地修改气体参数，以尽量减少浪费气体。20 Gwei是一个合理的天然气价格，可以确保在网络拥塞时查询仍然能够快速完成，但也许我们并不关心这一点。在撰写本文时，<a class="ae jo" href="https://ethgasstation.info/" rel="noopener ugc nofollow" target="_blank"> ETH Gas Station </a>告诉我们，1 Gwei的天然气价格仍能给我们合理快速的确认时间，所以让我们使用这个价格。</p><p id="b8b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通过在Remix上玩一些测试查询，似乎我们应该可以将气体限制降低到175，000。我们将定义一个名为<code class="eh lr ls lt lu b">gasLimitForOraclize</code>的常数，并将这个值传递给<code class="eh lr ls lt lu b">oraclize_query</code>函数来改变气体限制。为了更改天然气价格，我们使用Oraclize合同中的一个名为<code class="eh lr ls lt lu b">oraclize_setCustomGasPrice</code>的函数，并在构造函数中调用它。我们模板的最终版本如下所示，添加了更新的气体参数。请注意，<code class="eh lr ls lt lu b">getRandomNumber</code>功能中的<code class="eh lr ls lt lu b">require</code>语句也被更新，以反映新的气体设置。</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="nf ng l"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Final Oraclize template contract!</figcaption></figure><p id="4142" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">就是这样！如果您已经做到了这一步，那么您应该对Oraclize有一个非常扎实的了解，并且知道如何在任何API中正确而安全地使用它。最后一步是为自动化测试配置您的本地环境。</p><h1 id="6a52" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx dt translated">步骤4:配置您的本地环境</h1><p id="7116" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">随着我们的智能合约准备就绪，我们现在将把一切都转移到本地环境中进行测试。我将使用<a class="ae jo" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VSCode </a>，但是任何编辑器都足够了。</p><h2 id="375b" class="mk kb ht bd kc ml mm mn kg mo mp mq kk jb mr ms ko jf mt mu ks jj mv mw kw mx dt translated">初始设置</h2><p id="42ba" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">下面是我们需要的包的简要描述，然后是安装它们的npm命令。将使用<a class="ae jo" href="http://truffleframework.com/" rel="noopener ugc nofollow" target="_blank">松露</a>、<a class="ae jo" href="https://github.com/trufflesuite/ganache-cli" rel="noopener ugc nofollow" target="_blank"> Ganache-CLI </a>、<a class="ae jo" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a>和<a class="ae jo" href="http://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank">柴</a>，以及<a class="ae jo" href="http://web3js.readthedocs.io/en/1.0/" rel="noopener ugc nofollow" target="_blank"> web3 1.0.0 </a>的测试版。我们还需要一个叫做<a class="ae jo" href="https://github.com/oraclize/ethereum-bridge" rel="noopener ugc nofollow" target="_blank">以太坊桥</a>的设施来连接我们当地的加纳切区块链和奥拉基泽。</p><ul class=""><li id="3dee" class="ld le ht is b it iu ix iy jb lf jf lg jj lh jn li lj lk ll dt translated"><code class="eh lr ls lt lu b">truffle</code>:以太坊开发框架，用于编译和部署智能合约</li><li id="d674" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><code class="eh lr ls lt lu b">ganache-cli</code>:运行个人的本地以太坊区块链进行测试</li><li id="c54a" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><code class="eh lr ls lt lu b">mocha</code> : JavaScript测试框架</li><li id="63af" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><code class="eh lr ls lt lu b">chai</code>:可与任何测试框架配对的断言库</li><li id="a095" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><code class="eh lr ls lt lu b">web3</code>:用于与测试和前端开发的区块链交互(我更喜欢使用1.0.0测试版，但是如果你愿意，也可以随意使用不同的版本)</li><li id="67e2" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><code class="eh lr ls lt lu b">ethereum-bridge</code>:使我们的个人以太坊区块链能够与Oraclize进行交互</li></ul><p id="71a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，用命令<code class="eh lr ls lt lu b">npm install -g truffle ganache-cli</code>确保Truffle和Ganache-CLI被全局安装。</p><p id="1629" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后在您的项目根目录中，使用命令<code class="eh lr ls lt lu b">npm install --save mocha chai web3@1.0.0-beta.33</code>安装Mocha、Chai和web3。</p><p id="c550" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在唯一剩下的就是以太坊桥了。前往<a class="ae jo" href="https://github.com/oraclize/ethereum-bridge" rel="noopener ugc nofollow" target="_blank">以太坊桥</a>库，并<code class="eh lr ls lt lu b">git clone</code>(或下载)到你电脑上的其他地方，完全独立于这个项目，并在新的以太坊桥文件夹中运行<code class="eh lr ls lt lu b">npm install</code>。这个以太坊-bridge文件夹现在可以用于您正在处理的任何项目，而不仅仅是这个项目。</p><p id="58cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们将合同添加到我们的文件夹结构中，并确保它们被正确配置，以便我们的<code class="eh lr ls lt lu b">Template.sol</code>合同可以使用Oraclize合同。在您的项目中，您应该有如下所示的文件夹结构(但是如果您还没有编译合同，则没有<code class="eh lr ls lt lu b">build</code>文件夹)。<code class="eh lr ls lt lu b">Migrations.sol</code>将由Truffle创建，您应该为显示的其他两个合同创建空白文件，其中<code class="eh lr ls lt lu b">Template.sol</code>是来自Remix IDE的我们的合同，<code class="eh lr ls lt lu b">OraclizeAPI_0.5.sol</code>是直接从<a class="ae jo" href="https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol" rel="noopener ugc nofollow" target="_blank">源代码</a>复制的。</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div class="fe ff nx"><img src="../Images/5218dc5b7dcc9b113467a62f73409325.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*mSqWZGhnnF8sp6Hqelgs1A.png"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Truffle folder structure for Oraclize testing</figcaption></figure><p id="9b7b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你不熟悉truffle，我建议学习一些基础知识来理解这里显示的文件以及应该如何配置一切。为了确保我们在同一页上，下面显示了<code class="eh lr ls lt lu b">2_deploy_contracts.js</code>和<code class="eh lr ls lt lu b">truffle.js</code>的内容。</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="nf ng l"/></div></figure><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="nf ng l"/></div></figure><p id="76ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在回到<code class="eh lr ls lt lu b">Template.sol</code>合同，因为我们需要做一个快速的改变。与Remix IDE不同，我们不再能够直接从GitHub导入契约，这就是为什么我们需要将Oraclize契约的内容粘贴到它自己的<code class="eh lr ls lt lu b">.sol</code>文件中。所以只需将import语句从:</p><pre class="lw lx ly lz fq nn lu no np aw nq dt"><span id="4692" class="mk kb ht lu b fv nr ns l nt nu">import "github.com/oraclize/ethereum-api/oraclizeAPI_0.5.sol";</span></pre><p id="a105" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">到</p><pre class="lw lx ly lz fq nn lu no np aw nq dt"><span id="3e9f" class="mk kb ht lu b fv nr ns l nt nu">import "./oraclizeAPI_0.5.sol";</span></pre><p id="6ec0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因为我使用的是web3 1.0.0测试版，而Truffle捆绑了一个具有不同API的早期web3版本，所以我的项目有一个<code class="eh lr ls lt lu b">web3.js</code>文件，稍后您会看到它被导入到<code class="eh lr ls lt lu b">Template.test.js</code>文件中。为了完整起见，下面还提供了<code class="eh lr ls lt lu b">web3.js</code>的源代码，以备您使用。</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="nf ng l"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Source code of web3.js</figcaption></figure><p id="7edd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">此时，您应该编译模板契约，以确保到目前为止一切都设置正确。如果使用松露，<code class="eh lr ls lt lu b">cd</code>到<code class="eh lr ls lt lu b">truffle</code>文件夹，在终端输入<code class="eh lr ls lt lu b">truffle compile</code>。之后，你会有一个包含各种<code class="eh lr ls lt lu b">.json</code>文件的<code class="eh lr ls lt lu b">truffle/build/contracts</code>文件夹。</p><h2 id="cf30" class="mk kb ht bd kc ml mm mn kg mo mp mq kk jb mr ms ko jf mt mu ks jj mv mw kw mx dt translated">测试准备</h2><p id="555b" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">接下来，我们将编写测试，这样在下一步中，我们可以简单地运行测试，以确保Oraclize设置和运行正常。我们不会深入测试设置文件的细节，所以如果你对测试不熟悉，你可能想查看一下<a class="ae jo" href="https://mochajs.org/#installation" rel="noopener ugc nofollow" target="_blank"> Mocha文档</a>。</p><p id="fcca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<code class="eh lr ls lt lu b">truffle/test</code>文件夹中创建一个名为<code class="eh lr ls lt lu b">Template.test.js</code>的文件。下面，你会看到我们的测试文件是什么样子的。重要的是不要在任何地方使用<code class="eh lr ls lt lu b">accounts[9]</code>进行这些测试，因为我们将告诉Oraclize使用这个帐户来部署和调用Oraclize事务。所以一定要只用<code class="eh lr ls lt lu b">accounts[0]</code>、<code class="eh lr ls lt lu b">accounts[1]</code>等。</p><p id="2994" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在下面的文件中，你会看到我们使用两种不同的方法来测试Oraclize。在第一种方法中，我们利用由line <code class="eh lr ls lt lu b">const result = await template.getRandomNumber(...)</code>函数输出的<code class="eh lr ls lt lu b">result</code>变量。我们在这个变量的日志中搜索在发送查询时触发的日志事件。如果我们找到了这个事件，那么我们就知道我们的查询被成功地发送到了Oraclize，因为这个事件只有在查询被发送之后才会发出。</p><p id="4cef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们必须以不同的方式测试<code class="eh lr ls lt lu b">__callback</code>函数，这将我们带到第二种方法。因为Oraclize——不是我们——调用了<code class="eh lr ls lt lu b">__callback</code>函数，所以我们不能循环通过一个类似的<code class="eh lr ls lt lu b">result</code>变量来检查事件是否被触发。相反，我们使用定义我们感兴趣的事件并使用<code class="eh lr ls lt lu b">.watch</code>方法。然后我们将它包装在一个承诺中，这迫使Mocha在完成测试之前等待事件被触发。因为我们不想永远等待，以防出错，所以我们在<code class="eh lr ls lt lu b">it</code>函数的开始使用<code class="eh lr ls lt lu b">this.timeout</code>来限制这个测试的执行时间。一旦我们找到事件，我们就停止使用<code class="eh lr ls lt lu b">.stopWatching()</code>方法来观看它。这些方法的API可以在<a class="ae jo" href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events" rel="noopener ugc nofollow" target="_blank">web 3 JavaScript API for 0.2x . x</a>中找到(注意这不是1.0.0版的API，因为契约实例是用Truffle实例化的，它使用0.2.x.x)。</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="nf ng l"/></div><figcaption class="md me fg fe ff mf mg bd b be z ek">Our Template.sol testing script</figcaption></figure><p id="0daf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，从<code class="eh lr ls lt lu b">truffle</code>文件夹运行<code class="eh lr ls lt lu b">truffle test</code>——您的测试应该会运行，但是由于我们还没有设置以太坊桥，它们将会失败。</p><h2 id="5a93" class="mk kb ht bd kc ml mm mn kg mo mp mq kk jb mr ms ko jf mt mu ks jj mv mw kw mx dt translated">以太坊-桥接设置</h2><p id="8289" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">现在我们需要在本地Ganache-CLI开发区块链和Oraclize之间建立一座桥梁。</p><p id="3410" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，只需在终端输入<code class="eh lr ls lt lu b">ganache-cli</code>，从项目根目录启动Ganache-CLI。然后在单独的终端窗口中，导航到我们之前创建的<code class="eh lr ls lt lu b">ethereum-bridge</code>文件夹，并运行以下命令:</p><pre class="lw lx ly lz fq nn lu no np aw nq dt"><span id="f4f4" class="mk kb ht lu b fv nr ns l nt nu">node bridge -H localhost:8545 -a 9 --dev</span></pre><p id="7f4e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要分解这个命令:<code class="eh lr ls lt lu b">node bridge</code>是主命令，<code class="eh lr ls lt lu b">-H localhost:8545</code>将网桥设置为使用端口8545(这对应于Ganache-CLI使用的默认端口，因此如果您使用不同的端口，请更改该端口)。<code class="eh lr ls lt lu b">-a 9</code>部分将网桥设置为在该端口上使用帐号9，这就是为什么我们在测试中不能使用<code class="eh lr ls lt lu b">accounts[9]</code>的原因。您可以更改这个数字，但是我建议使用9，因为您的测试可能不需要使用Ganache生成的所有10个帐户(记住第一个帐户是index 0)。如果需要，您可以配置Ganache来生成50个帐户，然后将这个数字增加到49。最后，<code class="eh lr ls lt lu b">--dev</code>标志跳过查询ID检查和未决查询，而<a class="ae jo" href="https://github.com/oraclize/ethereum-bridge/issues/44#issuecomment-379316343" rel="noopener ugc nofollow" target="_blank">应该用于测试</a>，或者每当Ganache可能恢复区块链状态时使用。</p><p id="abf8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行该命令后，终端中输出的一部分将类似于以下内容:</p><pre class="lw lx ly lz fq nn lu no np aw nq dt"><span id="f4c2" class="mk kb ht lu b fv nr ns l nt nu">Please add this line to your contract constructor:</span><span id="60d5" class="mk kb ht lu b fv ny ns l nt nu">OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);</span></pre><p id="9ab9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，你不需要那样做！正如在这个<a class="ae jo" href="https://github.com/oraclize/ethereum-bridge/issues/27" rel="noopener ugc nofollow" target="_blank"> GitHub问题</a>中看到的，这已经过时了。默认情况下，“网桥自动生成OAR并将其部署在一个确定的地址。”</p><p id="91a6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">确保Ganache-CLI和ethereum-bridge都在运行。如果是这样的话，Ganche终端现在应该会显示无数被称为<code class="eh lr ls lt lu b">eth_getFilterChanges</code>的事件，这些事件正在不断地被生成。这是意料之中的，因为它表明以太坊桥正在工作并监视查询。</p><p id="edfe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您现在可以再次运行<code class="eh lr ls lt lu b">truffle test</code>命令，如果一切设置正确，测试应该会通过！呜哇！给自己一个鼓励。如果你遇到了问题或者遇到了困难，欢迎在评论中提问。</p><p id="026b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">祝你好运！</p><blockquote class="jq"><p id="dcc0" class="jr js ht bd jt ju jv jw jx jy jz jn ek translated">加入Coinmonks <a class="ae jo" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jo" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae jo" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="mk kb ht bd kc ml nz mn kg mo oa mq kk jb ob ms ko jf oc mu ks jj od mw kw mx dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="ld le ht is b it ky ix kz jb oe jf of jj og jn li lj lk ll dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae jo" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><a class="ae jo" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">电网交易</a> | <a class="ae jo" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><a class="ae jo" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae jo" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="450c" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><a class="ae jo" href="https://coincodecap.com/pionex-dual-investment" rel="noopener ugc nofollow" target="_blank"> Pionex双重投资</a> | <a class="ae jo" href="https://coincodecap.com/advcash-review" rel="noopener ugc nofollow" target="_blank"> AdvCash审查</a> | <a class="ae jo" href="https://coincodecap.com/uphold-review" rel="noopener ugc nofollow" target="_blank">支持审查</a></li><li id="4c48" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><a class="ae jo" href="https://coincodecap.com/best-cryptocurrency-apis" rel="noopener ugc nofollow" target="_blank">面向开发者的8个最佳加密货币API</a></li><li id="db49" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><a class="ae jo" href="https://coincodecap.com/uphold-card-review" rel="noopener ugc nofollow" target="_blank">支持卡审核</a> | <a class="ae jo" href="https://coincodecap.com/trust-wallet-vs-metamask" rel="noopener ugc nofollow" target="_blank">信任钱包vs元掩码</a></li><li id="0843" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><a class="ae jo" href="https://coincodecap.com/earn-sign-up-bonus" rel="noopener ugc nofollow" target="_blank">赢取注册奖金——10大最佳加密平台</a></li><li id="f33b" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae jo" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">开发人员的最佳加密API</li><li id="b359" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated">最佳<a class="ae jo" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="ld le ht is b it lm ix ln jb lo jf lp jj lq jn li lj lk ll dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li></ul></div></div>    
</body>
</html>