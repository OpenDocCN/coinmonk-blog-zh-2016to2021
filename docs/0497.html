<html>
<head>
<title>Unit testing Solidity contracts on Ethereum with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go对以太坊上的可靠性契约进行单元测试</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/unit-testing-solidity-contracts-on-ethereum-with-go-3cc924091281?source=collection_archive---------1-----------------------#2018-05-13">https://medium.com/coinmonks/unit-testing-solidity-contracts-on-ethereum-with-go-3cc924091281?source=collection_archive---------1-----------------------#2018-05-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="2623" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">以太坊区块链上的智能合约可以用Solidity语言编写。有几种工具和框架可用于测试这些智能合约。本文演示了如何在不牺牲并发性的情况下，以类型安全的方式对这些契约进行单元测试。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ji"><img src="../Images/6a5b33cfcab6a21e0fb53cebcfd13499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*UXlS0fw0AkvSeJKNDiRvng.jpeg"/></div></figure><p id="b94f" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我的朋友最近向我介绍了使用<a class="ae km" href="https://github.com/ethereum/solidity" rel="noopener ugc nofollow" target="_blank"> Solidity </a>编程语言为<a class="ae km" href="https://github.com/ethereum" rel="noopener ugc nofollow" target="_blank">以太坊</a>区块链编写用于去中心化应用的<a class="ae km" href="https://en.wikipedia.org/wiki/Smart_contract" rel="noopener ugc nofollow" target="_blank">智能契约</a>(或简称为<a class="ae km" href="https://blockgeeks.com/guides/dapps/" rel="noopener ugc nofollow" target="_blank"> dapps </a>)。他向我提到了他一直在用<a class="ae km" href="https://github.com/trufflesuite/truffle" rel="noopener ugc nofollow" target="_blank"> Truffle </a>框架开发的一个项目。从我所听到的和看到的来看，这是一个非常受欢迎的工具，它由一系列相关工具组成，这些工具有着令人愉快的名字，如<a class="ae km" href="http://truffleframework.com/ganache/" rel="noopener ugc nofollow" target="_blank"> Ganache </a>和<a class="ae km" href="http://truffleframework.com/docs/drizzle/getting-started" rel="noopener ugc nofollow" target="_blank">毛毛雨</a>。除了一旦我开始真正咬一口，它们不会留下令人愉快的回味。<a class="ae km" href="https://ethereum.stackexchange.com/questions/607/how-to-unit-test-smart-contracts/649#649" rel="noopener ugc nofollow" target="_blank">其他测试框架</a>如<a class="ae km" href="https://iurimatias.github.io/embark-framework/" rel="noopener ugc nofollow" target="_blank"> Embark </a>、<a class="ae km" href="https://github.com/NexusDevelopment/dapple" rel="noopener ugc nofollow" target="_blank"> dapple </a>和<a class="ae km" href="http://populus.readthedocs.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> Populus </a>也存在于不同的图书馆生态系统中。但是都是用<a class="ae km" rel="noopener" href="/@natemurthy/all-the-things-i-hate-about-python-5c5ff5fda95e"> Python </a>或者JavaScript写的。</p><p id="b68a" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我来自一个<a class="ae km" href="https://en.wikipedia.org/wiki/Java_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Java </a> / <a class="ae km" href="https://github.com/scala/scala" rel="noopener ugc nofollow" target="_blank"> Scala </a>背景，最近一直在为<a class="ae km" href="http://www.tesla.com/" rel="noopener ugc nofollow" target="_blank"> Tesla </a>的软件开发大量用<a class="ae km" href="https://github.com/golang/go" rel="noopener ugc nofollow" target="_blank"> Go </a>编程语言编写的服务。所以类型安全和并发对我来说很重要。出于这些原因，Python和JavaScript是我最不喜欢用来编写和维护可伸缩代码的编程语言。在写这篇文章的几个月前，我花了一些时间浏览区块链实现的源代码库，如比特币、莱特币、以太坊、Ripple和Monero。在我真正看过的所有代码中，<a class="ae km" href="https://github.com/ethereum/go-ethereum" rel="noopener ugc nofollow" target="_blank"> go-ethereum </a>的实现对我来说就像一颗闪亮的星星。代码易于阅读，易于构建，并且有很好的文档记录。它实际上是<em class="kn">领先以太坊的</em>实现。我在网上找到的许多测试Solidity契约的例子都是基于以太坊JSON-RPC规范的<a class="ae km" href="https://github.com/ethereum/web3.js/" rel="noopener ugc nofollow" target="_blank"> web3.js </a>工具包，这对于开始使用<code class="eh ko kp kq kr b">geth console</code>来说是很棒的，但是我想要更简单的东西。我想要的是直接与<code class="eh ko kp kq kr b">geth</code>进行进程间交互的东西，而不是包裹在各种各样的软毛层中的东西，或者需要我针对一个活动节点测试契约的东西。</p><h1 id="d069" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">围棋以太坊中的区块链模拟器</h1><p id="f5ba" class="pw-post-body-paragraph jq jr ht js b jt lk iu jv jw ll ix jy jz lm kb kc kd ln kf kg kh lo kj kk kl hm dt translated">我去搜索用Go编写的Solidity单元测试库，很高兴地发现了一个关于以太坊契约的Go绑定的wiki页面。在这篇报道中，我特别激动地发现<code class="eh ko kp kq kr b">go-ethereum</code>配备了一个<a class="ae km" href="https://github.com/ethereum/go-ethereum/wiki/Native-DApps:-Go-bindings-to-Ethereum-contracts#blockchain-simulator" rel="noopener ugc nofollow" target="_blank">区块链模拟器</a>。让我重复一下:<strong class="js hu"> <em class="kn">以太坊飞船的Go实现带有区块链模拟器！“那是个相当糟糕的屁股，”我心想。</em></strong></p><p id="bfb4" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">但是当我一行一行地遵循wiki中的示例时，我有点沮丧地遇到了与我从Github克隆的go-ethereum源代码版本(<code class="eh ko kp kq kr b">master@d2fe83d</code>)不兼容的代码片段。现在，如果我对wiki示例进行故障排除的细节让您感到厌烦，请随意跳到下一节，只要知道我最终让它们工作了:)但是对于更好奇的读者来说，破坏我的构建的特定代码是:</p><pre class="jj jk jl jm fq lp kr lq lr aw ls dt"><span id="6300" class="lt kt ht kr b fv lu lv l lw lx">sim := backends.NewSimulatedBackend(<br/>        core.GenesisAccount{<br/>                Address: auth.From,<br/>                Balance: big.NewInt(10000000000),<br/>        })</span></pre><p id="51e0" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">这会导致编译错误:</p><pre class="jj jk jl jm fq lp kr lq lr aw ls dt"><span id="f30d" class="lt kt ht kr b fv lu lv l lw lx">cannot use core.GenesisAccount literal (type core.GenesisAccount) as type core.GenesisAlloc in argument to backends.NewSimulatedBackend</span></pre><p id="1f90" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">一定喜欢编译器，对吧？好了，这个版本的问题是genesis处理在<a class="ae km" href="https://github.com/ethereum/go-ethereum/commit/37dd9086ec491900311fc39837f4a62ef5fd3a4a" rel="noopener ugc nofollow" target="_blank"> geth 1.6.0 </a>中被重构了，上面来自<a class="ae km" href="https://github.com/karalabe" rel="noopener ugc nofollow" target="_blank"> @karalabe </a>的文章是在那个版本发布前几个月创作的。<code class="eh ko kp kq kr b">NewSimulatedBackend</code>构造函数方法的类型签名现在看起来像这样:</p><pre class="jj jk jl jm fq lp kr lq lr aw ls dt"><span id="f862" class="lt kt ht kr b fv lu lv l lw lx"><strong class="kr hu">type</strong> GenesisAlloc <strong class="kr hu">map</strong>[common.Address]GenesisAccount</span><span id="67c0" class="lt kt ht kr b fv ly lv l lw lx"><strong class="kr hu">func</strong> NewSimulatedBackend(alloc core.GenesisAlloc) *SimulatedBackend</span></pre><p id="1faf" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">这意味着从<a class="ae km" href="https://github.com/ethereum/go-ethereum/releases/tag/v1.6.0" rel="noopener ugc nofollow" target="_blank"> 1.6.0 </a>开始，创建一个模拟以太坊区块链的正确方法是:</p><pre class="jj jk jl jm fq lp kr lq lr aw ls dt"><span id="d847" class="lt kt ht kr b fv lu lv l lw lx">gAlloc := <strong class="kr hu">map</strong>[common.Address]core.GenesisAccount{<br/>        auth.From: {Balance: big.NewInt(10000000000)},<br/>}</span><span id="bae9" class="lt kt ht kr b fv ly lv l lw lx">sim := backends.NewSimulatedBackend(gAlloc)</span></pre><p id="ccbe" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我喜欢这种推理。想象一下，尝试用Ruby、Python或JavaScript解决这些问题。不是说做不到，只是不好看。好了，这样就可以使用上面链接的wiki页面中提供的绑定了，这让我开始使用这个包。现在让我们用一个更简单、更新的例子来编写一些测试。</p><h1 id="548c" class="ks kt ht bd ku kv kw kx ky kz la lb lc iz ld ja le jc lf jd lg jf lh jg li lj dt translated">单元测试:Hello World</h1><p id="f96b" class="pw-post-body-paragraph jq jr ht js b jt lk iu jv jw ll ix jy jz lm kb kc kd ln kf kg kh lo kj kk kl hm dt translated">首先，我鼓励每个软件开发人员学习一些围棋。几年前，我不愿意学习另一种语言，尤其是在对Java和Scala投入了大量资金之后，那时我最初只是把它当作谷歌规定的一种时尚。但是随着我阅读和编写Go的越来越多，我对用Go编写的软件的质量、成功的Go项目的复杂性(例如<a class="ae km" href="https://github.com/docker" rel="noopener ugc nofollow" target="_blank"> Docker </a>、<a class="ae km" href="https://github.com/kubernetes/kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>等)印象越来越深刻。)，Go开发者的社区，它的采用率，它的库的多样性，它的使用的简单性。我们将下载、安装和构建以下依赖项，作为Hello World智能合约的先决条件:</p><ul class=""><li id="4075" class="lz ma ht js b jt ju jw jx jz mb kd mc kh md kl me mf mg mh dt translated">去</li><li id="a463" class="lz ma ht js b jt mi jw mj jz mk kd ml kh mm kl me mf mg mh dt translated">去以太坊</li><li id="6090" class="lz ma ht js b jt mi jw mj jz mk kd ml kh mm kl me mf mg mh dt translated"><code class="eh ko kp kq kr b"><a class="ae km" href="https://github.com/ethereum/go-ethereum/tree/master/cmd/abigen" rel="noopener ugc nofollow" target="_blank">abigen</a></code></li><li id="0b81" class="lz ma ht js b jt mi jw mj jz mk kd ml kh mm kl me mf mg mh dt translated"><code class="eh ko kp kq kr b"><a class="ae km" href="http://solidity.readthedocs.io/en/latest/installing-solidity.html" rel="noopener ugc nofollow" target="_blank">solc</a></code></li></ul><p id="21ae" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">如果这是你第一次使用Go，你可以从<a class="ae km" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank"> golang“入门”页面</a>下载并安装任何最新的发行版。我下面准备的例子适用于Go 1.9.2。一旦你安装了Go，克隆go-ethereum源代码并签出最新的标签(在撰写本文时是<code class="eh ko kp kq kr b">v1.8.7</code>)，这样我们就可以构建最新的稳定版本了:</p><pre class="jj jk jl jm fq lp kr lq lr aw ls dt"><span id="a689" class="lt kt ht kr b fv lu lv l lw lx">$ <strong class="kr hu">cd</strong> $GOPATH/src/github.com/ethereum<br/>$ <strong class="kr hu">git</strong> clone <a class="ae km" href="https://github.com/ethereum/go-ethereum.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ethereum/go-ethereum.git</a> <br/>$ <strong class="kr hu">cd</strong> go-ethereum<br/>$<strong class="kr hu"> git</strong> checkout v1.8.7</span></pre><p id="9588" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">接下来，我们要安装必要的工具来编译我们的Solidity文件。大多数已经在使用Solidity的人将会熟悉web服务，比如用于从<code class="eh ko kp kq kr b">*.sol</code>文件编译和生成以太坊绑定的<a class="ae km" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a>或<a class="ae km" href="https://solc-docs.smartcontract.com/" rel="noopener ugc nofollow" target="_blank"> SolC API </a>。为了编写我们的单元测试，我们希望在本地编译和生成这些绑定。为此，我们将从go-ethereum的源文件夹中安装附带的<code class="eh ko kp kq kr b">abigen</code>工具:</p><pre class="jj jk jl jm fq lp kr lq lr aw ls dt"><span id="b72a" class="lt kt ht kr b fv lu lv l lw lx">$ <strong class="kr hu">go</strong> install ./cmd/abigen</span></pre><p id="1a98" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">还有<code class="eh ko kp kq kr b">solc</code>工具，你可以按照<a class="ae km" href="http://solidity.readthedocs.io/en/latest/installing-solidity.html" rel="noopener ugc nofollow" target="_blank">solidity . readthedocs . io</a>上的说明来做——不过如果你是在Mac OS X上开发，而不是在NPM上，我建议你用自制软件安装Solidity编译器:</p><pre class="jj jk jl jm fq lp kr lq lr aw ls dt"><span id="7193" class="lt kt ht kr b fv lu lv l lw lx">$ <strong class="kr hu">brew</strong> tap ethereum/ethereum<br/>$ <strong class="kr hu">brew</strong> install solidity</span></pre><p id="244b" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在，在您选择的工作目录中，让我们将“Hello World”智能合约写入一个名为<code class="eh ko kp kq kr b">helloworld.sol</code>的文件:</p><pre class="jj jk jl jm fq lp kr lq lr aw ls dt"><span id="880b" class="lt kt ht kr b fv lu lv l lw lx"><strong class="kr hu">pragma</strong> solidity ^0.4.23;</span><span id="6d08" class="lt kt ht kr b fv ly lv l lw lx"><strong class="kr hu">contract</strong> helloworld {</span><span id="4950" class="lt kt ht kr b fv ly lv l lw lx">    <strong class="kr hu">function</strong> say() <strong class="kr hu">public</strong> <strong class="kr hu">pure</strong> <strong class="kr hu">returns</strong> (string) {<br/>        <strong class="kr hu">return</strong> 'hello etherworld';<br/>    }</span><span id="3683" class="lt kt ht kr b fv ly lv l lw lx">}</span></pre><p id="2f78" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">接下来，我们将使用以下命令为这个简单的契约生成Go绑定:</p><pre class="jj jk jl jm fq lp kr lq lr aw ls dt"><span id="7ad7" class="lt kt ht kr b fv lu lv l lw lx">$ <strong class="kr hu">abigen</strong> --sol helloworld.sol --pkg main --out helloworld.go</span></pre><p id="8c3f" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><code class="eh ko kp kq kr b">abigen</code>工具不仅会为你的Solidity契约生成本地Go绑定，它还会调用<code class="eh ko kp kq kr b">solc</code>命令来生成一个应用二进制接口(<a class="ae km" href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI" rel="noopener ugc nofollow" target="_blank"> ABI </a>)字符串(在<code class="eh ko kp kq kr b">helloworld.go</code>中标记为常量<code class="eh ko kp kq kr b">HelloworldABI</code>)以及将在我们模拟的以太坊虚拟机中运行的字节码(标记为<code class="eh ko kp kq kr b">HelloworldBin</code>)。我已经将<a class="ae km" href="https://gist.github.com/natemurthy/50415bdac7bd5a1194c39c10aa4a7c94" rel="noopener ugc nofollow" target="_blank">要点</a>附加到我用上面的命令代码生成的输出文件中，以供参考，但是我建议您自己尝试codegen来验证您的工具在您的本地开发机器上设置正确。有了这个Go绑定，我们现在可以为我们的<code class="eh ko kp kq kr b">Say()</code>单元编写一个测试，它只需要这个函数的输出字符串<code class="eh ko kp kq kr b">"hello etherworld"</code>:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="a785" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在让我们继续运行我们新创建的智能契约单元测试，使用:</p><pre class="jj jk jl jm fq lp kr lq lr aw ls dt"><span id="5b7c" class="lt kt ht kr b fv lu lv l lw lx">$ <strong class="kr hu">go</strong> test -v helloworld*.go</span><span id="1846" class="lt kt ht kr b fv ly lv l lw lx">=== RUN   TestRunHelloworldSuite<br/>=== RUN   TestRunHelloworldSuite/TestSay<br/>--- PASS: TestRunHelloworldSuite (0.00s)<br/>--- PASS: TestRunHelloworldSuite/TestSay (0.00s)<br/>PASS<br/>ok   command-line-arguments 0.041s</span></pre><p id="d12f" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">然后<em class="kn">瞧！</em>我们所有的智能合约单元测试都通过了，无需运行或配置专用网络，也无需下载和安装任何附加软件。</p><p id="8902" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在上面的测试代码中，我使用了一个名为<code class="eh ko kp kq kr b"><a class="ae km" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">testify</a></code>的Go包，我发现它非常有助于将大量相似的单元测试组织成套件——例如，每个契约都可以有一个为其编写测试的套件。单元间重用的所有测试状态都封装在<code class="eh ko kp kq kr b">HelloworldTestSuite</code>中，然后在<code class="eh ko kp kq kr b">SetupTest</code>中连接起来，用区块链模拟器进行配置。首先，我们用<code class="eh ko kp kq kr b">crypto.GenerateKey()</code>创建一个私钥，它将被用来填充一个signer函数，以便在我们的模拟以太坊后端中授权交易。函数<code class="eh ko kp kq kr b">bind.NewKeyedTransactor</code>返回一个<code class="eh ko kp kq kr b">*TransactOpts</code>，它指向一个我们可以进行交易的地址。我们将使用这个地址创建一个带有资金分配帐户的genesis块，然后通过前面描述的重构的genesis处理机制用这个帐户创建我们的模拟区块链。然后，我们使用<code class="eh ko kp kq kr b">DeployHelloworld</code>部署我们的“hello world”契约，其中<code class="eh ko kp kq kr b">s.auth</code>指向从生成的帐户进行交易所需的所有授权数据，而<code class="eh ko kp kq kr b">s.sim</code>指向由内存数据库支持的完全模拟的区块链。部署该契约的事务保持在“待定”状态，直到我们将它<code class="eh ko kp kq kr b">s.sim.Commit()</code>给区块链，这使得契约代码在给定的地址可用。最后，我们可以调用并测试我们的<code class="eh ko kp kq kr b">s.helloworld.Say</code>函数的输出，这个函数可以用非零契约调用者选项进行微调。</p><p id="6dfa" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">现在我们有了:一份用Solidity编写的智能合同，在Go中经过测试，无需启动节点或连接到网络。</p></div><div class="ab cl mp mq hb mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hm hn ho hp hq"><p id="4329" class="pw-post-body-paragraph jq jr ht js b jt ju iu jv jw jx ix jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><strong class="js hu"> <em class="kn">鸣谢</em> </strong> <em class="kn">:特别感谢我的朋友</em> <a class="ae km" rel="noopener" href="/@jfviray7"> <em class="kn">乔纳森·维雷</em> </a> <em class="kn">总是提供新鲜的想法。</em></p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><a href="http://bit.ly/2G71Sp7"><div class="fe ff mw"><img src="../Images/449450761cd76f44f9ae574333f9e9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKX2mtg7p1lOs7JmosPLsA.png"/></div></a></figure></div></div>    
</body>
</html>