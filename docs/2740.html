<html>
<head>
<title>What’s new in Solidity 0.6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity 0.6的新特性</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/whats-new-in-solidity-0-6-56fa76198ec7?source=collection_archive---------0-----------------------#2020-02-15">https://medium.com/coinmonks/whats-new-in-solidity-0-6-56fa76198ec7?source=collection_archive---------0-----------------------#2020-02-15</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="b4c8" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">坚固性最新改进的快速入门</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/d8f50191b9f7d9d57ed8b84ae8770654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FdA4IsnKyOPr_QyL9so3oQ.png"/></div></div></figure><p id="786c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">最近发布了Solidity 0.6 ，带来了一些语法变化和非向后兼容的变化。</p><p id="7c08" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们将讨论Solidity的一些主要变化，包括:</p><ul class=""><li id="5d74" class="kr ks ht jw b jx jy ka kb kd kt kh ku kl kv kp kw kx ky kz dt translated">功能覆盖</li><li id="9329" class="kr ks ht jw b jx la ka lb kd lc kh ld kl le kp kw kx ky kz dt translated">抽象合同</li><li id="d9c3" class="kr ks ht jw b jx la ka lb kd lc kh ld kl le kp kw kx ky kz dt translated">尝试/抓住</li><li id="54ea" class="kr ks ht jw b jx la ka lb kd lc kh ld kl le kp kw kx ky kz dt translated">接收以太网/回退功能分离</li><li id="d137" class="kr ks ht jw b jx la ka lb kd lc kh ld kl le kp kw kx ky kz dt translated">数组大小调整</li><li id="86f7" class="kr ks ht jw b jx la ka lb kd lc kh ld kl le kp kw kx ky kz dt translated">状态变量阴影</li></ul><h1 id="396a" class="lf lg ht bd lh li lj lk ll lm ln lo lp iz lq ja lr jc ls jd lt jf lu jg lv lw dt translated">功能覆盖</h1><p id="6fae" class="pw-post-body-paragraph ju jv ht jw b jx lx iu jz ka ly ix kc kd lz kf kg kh ma kj kk kl mb kn ko kp hm dt translated">在以前的Solidity版本中，没有明确的方法知道继承契约应该覆盖哪些函数。Solidity 0.6带来了一个改进，它清楚地表明了继承契约可以覆盖哪些函数。</p><p id="06a2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">只有当它们被标记为<strong class="jw hu">虚拟</strong>时，继承契约才能覆盖其基础契约函数行为。然后，覆盖函数必须在函数头中使用<code class="eh mc md me mf b"><strong class="jw hu">override</strong></code>关键字，如下所示。</p><pre class="jj jk jl jm fq mg mf mh mi aw mj dt"><span id="db85" class="mk lg ht mf b fv ml mm l mn mo"><strong class="mf hu">pragma solidity</strong> ^0.6.0;</span><span id="e1f4" class="mk lg ht mf b fv mp mm l mn mo"><strong class="mf hu">contract</strong> Base<br/>{<br/>    <strong class="mf hu">function</strong> foo() <strong class="mf hu">virtual</strong> <strong class="mf hu">public</strong> {}<br/>}</span><span id="c010" class="mk lg ht mf b fv mp mm l mn mo"><strong class="mf hu">contract</strong> Middle <strong class="mf hu">is</strong> Base {}</span><span id="b712" class="mk lg ht mf b fv mp mm l mn mo"><strong class="mf hu">contract</strong> Inherited <strong class="mf hu">is</strong> Middle<br/>{<br/>    <strong class="mf hu">function</strong> foo() <strong class="mf hu">public</strong> <strong class="mf hu">override</strong> {}<br/>}</span></pre><p id="fb1a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">有了这个改进，就不用再检查OpenZeppelin文档中哪些函数可以被覆盖，因为Solidity编译器本身可以让你知道继承契约何时覆盖了一个非“虚拟”函数。</p><h1 id="3f31" class="lf lg ht bd lh li lj lk ll lm ln lo lp iz lq ja lr jc ls jd lt jf lu jg lv lw dt translated">抽象合同</h1><p id="23cd" class="pw-post-body-paragraph ju jv ht jw b jx lx iu jz ka ly ix kc kd lz kf kg kh ma kj kk kl mb kn ko kp hm dt translated">Solidity 0.6中引入了一个新的关键字<code class="eh mc md me mf b">abstract</code>。它用于标记未实现其所有功能的合同。</p><p id="f1fb" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">当合同中至少有一个功能没有实现时，合同将被标记为<code class="eh mc md me mf b">abstract</code>。没有在接口外实现的函数必须标记为<strong class="jw hu"> <em class="mq">虚拟的。</em> </strong>即使所有的功能都实现了，契约也可以标记为抽象的。</p><pre class="jj jk jl jm fq mg mf mh mi aw mj dt"><span id="46a5" class="mk lg ht mf b fv ml mm l mn mo"><strong class="mf hu">abstract</strong> <strong class="mf hu">contract</strong> Feline {<br/>    <strong class="mf hu">function</strong> utterance() <strong class="mf hu">public</strong> virtual <strong class="mf hu">returns</strong> (bytes32);<br/>}</span><span id="29bc" class="mk lg ht mf b fv mp mm l mn mo"><strong class="mf hu">contract</strong> Cat <strong class="mf hu">is</strong> Feline, Token {<br/>    <strong class="mf hu">function</strong> utterance() <strong class="mf hu">public</strong> override <strong class="mf hu">returns</strong> (bytes32) {<br/>        <strong class="mf hu">return</strong> "miaow"; <br/>     }<br/>}</span></pre><h1 id="2294" class="lf lg ht bd lh li lj lk ll lm ln lo lp iz lq ja lr jc ls jd lt jf lu jg lv lw dt translated">尝试/抓住</h1><p id="732c" class="pw-post-body-paragraph ju jv ht jw b jx lx iu jz ka ly ix kc kd lz kf kg kh ma kj kk kl mb kn ko kp hm dt translated">Solidity 0.6引入了一个<code class="eh mc md me mf b">try/catch</code>语句，用于处理失败的契约调用错误。它允许您对失败的外部呼叫做出反应。</p><p id="1a86" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">使用try/catch语句可以捕获外部约定调用中的失败，如下所示:</p><pre class="jj jk jl jm fq mg mf mh mi aw mj dt"><span id="3002" class="mk lg ht mf b fv ml mm l mn mo"><strong class="mf hu">pragma solidity</strong> ^0.6.0;</span><span id="7bc6" class="mk lg ht mf b fv mp mm l mn mo"><strong class="mf hu">interface</strong> DataFeed { <br/>      <strong class="mf hu">function</strong> getData(address token) <strong class="mf hu">external</strong> <strong class="mf hu">returns</strong> (uint value); <br/>}</span><span id="b3bb" class="mk lg ht mf b fv mp mm l mn mo"><strong class="mf hu">contract</strong> FeedConsumer {<br/>    DataFeed feed;<br/>    uint errorCount;<br/>    <strong class="mf hu">function</strong> rate(address token) <strong class="mf hu">public</strong> <strong class="mf hu">returns</strong> (uint value, bool success) {<br/>        <em class="mq">// Permanently disable the mechanism if there are</em><br/>        <em class="mq">// more than 10 errors.</em><br/>        require(errorCount &lt; 10);<br/>        try feed.getData(token) <strong class="mf hu">returns</strong> (uint v) {<br/>            <strong class="mf hu">return</strong> (v, <strong class="mf hu">true</strong>);<br/>        } catch Error(string <strong class="mf hu">memory</strong> <em class="mq">/*reason*/</em>) {<br/>            <em class="mq">// This is executed in case</em><br/>            <em class="mq">// revert was called inside getData</em><br/>            <em class="mq">// and a reason string was provided.</em><br/>            errorCount++;<br/>            <strong class="mf hu">return</strong> (0, <strong class="mf hu">false</strong>);<br/>        } catch (bytes <strong class="mf hu">memory</strong> <em class="mq">/*lowLevelData*/</em>) {<br/>            <em class="mq">// This is executed in case revert() was used</em><br/>            <em class="mq">// or there was a failing assertion, division</em><br/>            <em class="mq">// by zero, etc. inside getData.</em><br/>            errorCount++;<br/>            <strong class="mf hu">return</strong> (0, <strong class="mf hu">false</strong>);<br/>        }<br/>    }<br/>}</span></pre><p id="2b77" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">根据错误的类型，Solidity支持不同种类的catch块。如果错误是由<code class="eh mc md me mf b">revert("reasonString")</code>或<code class="eh mc md me mf b">require(false, "reasonString")</code>(或导致这种异常的内部错误)引起的，那么<code class="eh mc md me mf b">catch Error(string memory reason)</code>类型的catch子句将被执行。</p><h1 id="fd19" class="lf lg ht bd lh li lj lk ll lm ln lo lp iz lq ja lr jc ls jd lt jf lu jg lv lw dt translated">接收以太网/回退功能分离</h1><h2 id="9cf3" class="mk lg ht bd lh mr ms mt ll mu mv mw lp kd mx my lr kh mz na lt kl nb nc lv nd dt translated">接受乙醚</h2><p id="be32" class="pw-post-body-paragraph ju jv ht jw b jx lx iu jz ka ly ix kc kd lz kf kg kh ma kj kk kl mb kn ko kp hm dt translated">要使合同能够接收以太，它必须实现<code class="eh mc md me mf b"><strong class="jw hu">receive()</strong></code> <strong class="jw hu"> </strong>功能。一个契约最多可以有一个<code class="eh mc md me mf b">receive</code>函数，使用<code class="eh mc md me mf b">receive() external payable { ... }</code>(没有<code class="eh mc md me mf b">function</code>关键字)声明，如下例所示:</p><pre class="jj jk jl jm fq mg mf mh mi aw mj dt"><span id="e09d" class="mk lg ht mf b fv ml mm l mn mo"><strong class="mf hu">pragma solidity</strong> ^0.6.0;</span><span id="8a4a" class="mk lg ht mf b fv mp mm l mn mo"><em class="mq">// This contract keeps all Ether sent to it with no way</em><br/><em class="mq">// to get it back.</em><br/><strong class="mf hu">contract</strong> Sink {<br/>    <strong class="mf hu">event</strong> Received(address, uint);<br/>    <strong class="mf hu">receive</strong>() <strong class="mf hu">external</strong> <strong class="mf hu">payable</strong> {<br/>        <strong class="mf hu">emit</strong> Received(msg.sender, msg.value);<br/>    }<br/>}</span></pre><h2 id="9c7f" class="mk lg ht bd lh mr ms mt ll mu mv mw lp kd mx my lr kh mz na lt kl nb nc lv nd dt translated">后退功能</h2><p id="99ea" class="pw-post-body-paragraph ju jv ht jw b jx lx iu jz ka ly ix kc kd lz kf kg kh ma kj kk kl mb kn ko kp hm dt translated">一个契约最多可以有一个<code class="eh mc md me mf b">fallback</code>函数，使用<code class="eh mc md me mf b">fallback () external [payable]</code>(没有<code class="eh mc md me mf b">function</code>关键字)声明。这个函数不能有参数，不能返回任何东西，并且必须有<code class="eh mc md me mf b">external</code>可见性。如果其他函数都不匹配给定的函数签名，或者如果根本没有提供数据，并且没有<a class="ae kq" href="https://solidity.readthedocs.io/en/v0.6.2/contracts.html#receive-ether-function" rel="noopener ugc nofollow" target="_blank">接收以太函数</a>，则在调用契约时执行。回退功能总是接收数据，但为了也接收数据，必须将其标记为<code class="eh mc md me mf b">payable</code>。</p><pre class="jj jk jl jm fq mg mf mh mi aw mj dt"><span id="c162" class="mk lg ht mf b fv ml mm l mn mo"><strong class="mf hu">pragma solidity</strong> &gt;0.6.1 &lt;0.7.0;</span><span id="ea47" class="mk lg ht mf b fv mp mm l mn mo"><strong class="mf hu">contract</strong> Test {<br/>    <em class="mq">// This function is called for all messages sent to</em><br/>    <em class="mq">// this contract (there is no other function).</em><br/>    <em class="mq">// Sending Ether to this contract will cause an exception,</em><br/>    <em class="mq">// because the fallback function does not have the `payable`</em><br/>    <em class="mq">// modifier.</em><br/>    <strong class="mf hu">fallback</strong>() <strong class="mf hu">external</strong> { x = 1; }<br/>    uint x;<br/>}</span><span id="8089" class="mk lg ht mf b fv mp mm l mn mo"><strong class="mf hu">contract</strong> TestPayable {<br/>    <em class="mq">// This function is called for all messages sent to</em><br/>    <em class="mq">// this contract, except plain Ether transfers</em><br/>    <em class="mq">// (there is no other function except the receive function).</em><br/>    <em class="mq">// Any call with non-empty calldata to this contract will execute</em><br/>    <em class="mq">// the fallback function (even if Ether is sent along with the call).</em><br/>    <strong class="mf hu">fallback</strong>() <strong class="mf hu">external</strong> <strong class="mf hu">payable</strong> { x = 1; y = msg.value; }</span><span id="404a" class="mk lg ht mf b fv mp mm l mn mo"><em class="mq">// This function is called for plain Ether transfers, i.e.</em><br/>    <em class="mq">// for every call with empty calldata.</em><br/>    <strong class="mf hu">receive</strong>() <strong class="mf hu">external</strong> <strong class="mf hu">payable</strong> { x = 2; y = msg.value; }<br/>    uint x;<br/>    uint y;<br/>}</span></pre><h1 id="5ae0" class="lf lg ht bd lh li lj lk ll lm ln lo lp iz lq ja lr jc ls jd lt jf lu jg lv lw dt translated">数组大小调整</h1><p id="f76b" class="pw-post-body-paragraph ju jv ht jw b jx lx iu jz ka ly ix kc kd lz kf kg kh ma kj kk kl mb kn ko kp hm dt translated">现在，对阵列<code class="eh mc md me mf b">length</code>的访问始终是只读的，即使对于存储阵列也是如此。不再可能通过为存储阵列的长度指定新值来调整其大小。用<code class="eh mc md me mf b">push()</code>、<code class="eh mc md me mf b">push(value)</code>或<code class="eh mc md me mf b">pop()</code>代替，或者分配一个全数组，</p><ul class=""><li id="32cd" class="kr ks ht jw b jx jy ka kb kd kt kh ku kl kv kp kw kx ky kz dt translated">将<code class="eh mc md me mf b">uint length = array.push(value)</code>改为<code class="eh mc md me mf b">array.push(value);</code>。可以通过<code class="eh mc md me mf b">array.length</code>访问新长度。</li><li id="2cf4" class="kr ks ht jw b jx la ka lb kd lc kh ld kl le kp kw kx ky kz dt translated">将<code class="eh mc md me mf b">array.length++</code>改为<code class="eh mc md me mf b">array.push()</code>增加，使用<code class="eh mc md me mf b">pop()</code>减少存储阵列的长度。</li></ul><pre class="jj jk jl jm fq mg mf mh mi aw mj dt"><span id="a5c9" class="mk lg ht mf b fv ml mm l mn mo"><strong class="mf hu">contract</strong> Test {<br/>  <strong class="mf hu">string</strong>[] <strong class="mf hu">public</strong> names_A_to_F;</span><span id="7b54" class="mk lg ht mf b fv mp mm l mn mo"><strong class="mf hu">function</strong> test() <strong class="mf hu">public</strong> {<br/>    // invalid syntax</span><span id="4e68" class="mk lg ht mf b fv mp mm l mn mo">uint length = names_A_to_F.push("Alice"); // invalid<br/>    names_A_to_F.length++; // invalid as length is now read only</span><span id="dfeb" class="mk lg ht mf b fv mp mm l mn mo">// correct syntax <br/>    names_A_to_F.push(); // increase array length<br/>    names_A_to_F.push("Alice"); // add item to array<br/>    names_A_to_F.pop(); // reduce array length by removing item<br/>    uint length = names_A_to_F.length; // access array length</span><span id="4119" class="mk lg ht mf b fv mp mm l mn mo">}</span><span id="e57c" class="mk lg ht mf b fv mp mm l mn mo">}</span></pre><h1 id="8d12" class="lf lg ht bd lh li lj lk ll lm ln lo lp iz lq ja lr jc ls jd lt jf lu jg lv lw dt translated">现在不允许状态变量隐藏</h1><p id="9bb1" class="pw-post-body-paragraph ju jv ht jw b jx lx iu jz ka ly ix kc kd lz kf kg kh ma kj kk kl mb kn ko kp hm dt translated">状态变量阴影被认为是一个错误。派生契约只能声明一个状态变量<code class="eh mc md me mf b"><strong class="jw hu">x</strong></code>，如果在其任何基中没有同名的可见状态变量。</p><p id="e04f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">下面显示了一个示例:</p><pre class="jj jk jl jm fq mg mf mh mi aw mj dt"><span id="51f9" class="mk lg ht mf b fv ml mm l mn mo"><strong class="mf hu">contract</strong> Test {<br/>    <strong class="mf hu">address</strong> x <strong class="mf hu">payable</strong>;<br/>}</span><span id="2fa1" class="mk lg ht mf b fv mp mm l mn mo"><strong class="mf hu">contract</strong> TestOverride <strong class="mf hu">is</strong> Test {</span><span id="1485" class="mk lg ht mf b fv mp mm l mn mo">// This declaration would throw an error because its shadowing a                    // state variable already in its base inherited contract Test<br/>    <strong class="mf hu">address</strong> x <strong class="mf hu">payable</strong>;</span><span id="3642" class="mk lg ht mf b fv mp mm l mn mo">}</span></pre><p id="bf2e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这是一个明确的要求，有助于阅读和理解Solidity代码库。</p><h1 id="558f" class="lf lg ht bd lh li lj lk ll lm ln lo lp iz lq ja lr jc ls jd lt jf lu jg lv lw dt translated">结论</h1><p id="8b71" class="pw-post-body-paragraph ju jv ht jw b jx lx iu jz ka ly ix kc kd lz kf kg kh ma kj kk kl mb kn ko kp hm dt translated">Solidity 0.6带来了急需的改进和明确性要求，使得阅读和理解Solidity代码库更加容易。</p><h1 id="b5c0" class="lf lg ht bd lh li lj lk ll lm ln lo lp iz lq ja lr jc ls jd lt jf lu jg lv lw dt translated">进一步阅读</h1><div class="ne nf fm fo ng nh"><a href="https://solidity.readthedocs.io/en/v0.6.2/060-breaking-changes.html" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab ej"><div class="nj ab nk cl cj nl"><h2 class="bd hu fv z el nm eo ep nn er et hs dt translated">Solidity v0.6.0重大变更— Solidity 0.6.2文档</h2><div class="no l"><h3 class="bd b fv z el nm eo ep nn er et ek translated">函数现在只能在用关键字标记或在接口中定义时被重写。功能…</h3></div><div class="np l"><p class="bd b gc z el nm eo ep nn er et ek translated">solidity.readthedocs.io</p></div></div></div></a></div><div class="ne nf fm fo ng nh"><a href="https://blog.ethereum.org/2020/01/29/solidity-0.6-try-catch/" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab ej"><div class="nj ab nk cl cj nl"><h2 class="bd hu fv z el nm eo ep nn er et hs dt translated">Solidity 0.6.x特性:try/catch语句</h2><div class="no l"><h3 class="bd b fv z el nm eo ep nn er et ek translated">0.6.0中引入的try/catch语法可以说是可靠性中错误处理能力的最大飞跃，因为…</h3></div><div class="np l"><p class="bd b gc z el nm eo ep nn er et ek translated">blog.ethereum.org</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv js nh"/></div></div></a></div><blockquote class="nw"><p id="1f32" class="nx ny ht bd nz oa ob oc od oe of kp ek translated"><a class="ae kq" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="oh oi oj ok ol jn fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff og"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff om"><img src="../Images/e9dbce386c4f90837b5db529a4c87766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fZu_SfnNF6m_BGbXlsl-A@2x.png"/></div></div></figure></div></div>    
</body>
</html>