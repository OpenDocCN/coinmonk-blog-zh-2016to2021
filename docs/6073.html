<html>
<head>
<title>How to write an upgradeable Solidity Smart Contract for a react dapp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为react dapp编写可升级的Solidity智能合约</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-write-an-upgradeable-solidity-smart-contract-for-a-react-dapp-ebb570f86cce?source=collection_archive---------2-----------------------#2021-11-13">https://medium.com/coinmonks/how-to-write-an-upgradeable-solidity-smart-contract-for-a-react-dapp-ebb570f86cce?source=collection_archive---------2-----------------------#2021-11-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/bb728e047d00030a088f845b5ec1b01f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xHx4-arVtMNDGdUINHrjJA.png"/></div></div></figure><div class=""/><p id="c803" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">智能合约是在区块链上编写和发布的一组代码(通常在单个文件中)。当您在浏览器中使用分散式应用程序(d app)时，该应用程序会通过智能合约与区块链进行交互。关于智能合约，有两点需要了解:</p><ul class=""><li id="01b2" class="jz ka ie jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated">发布的每个智能合约都是公开的(代码可以被任何人查阅)，并且有唯一的公开地址。因此，每个想要与智能合约交互的应用程序都将使用这个唯一的地址。</li><li id="ff53" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">本质上，为了用户的安全，在一个地址发布的代码不能被更新。这是区块链的特性:不变性。</li></ul><p id="60e3" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于智能合约是不可变的，并且智能合约地址的改变将需要使用该合约的所有应用程序的代码的改变，如果开发人员注意到错误或安全问题，他/她如何更新已发布的代码？</p><p id="0bee" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">答案是通过<strong class="jd if">可升级智能合同</strong>:帮助你升级一个<code class="eh kn ko kp kq b">Contract1</code>到<code class="eh kn ko kp kq b">Contract2</code>，保持它的状态(数据&amp;平衡)和之前的地址相同。</p><p id="ed2a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有许多方法可以实现这个目标，但是在本教程中，我们将选择成熟且易于使用的<a class="ae kr" href="https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable" rel="noopener ugc nofollow" target="_blank"> openzeppelin升级</a>库。</p><p id="1a09" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你将通过这篇文章了解到:</p><ul class=""><li id="f87f" class="jz ka ie jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated">如何启动react dapp，编写和部署经典(不可升级)合同</li><li id="93fe" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">如何将您的合同更新为可升级</li><li id="4ddf" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">如何部署可升级合同</li><li id="07d7" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">如何升级已部署的可升级合同</li><li id="0a2a" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">如何为可升级契约编写测试</li></ul><h1 id="f785" class="ks kt ie bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">启动我们的反应dapp</h1><p id="b7c9" class="pw-post-body-paragraph jb jc ie jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">Nader Dabit的博客文章很好地完成了这一部分，所以我们将跟随它。</p><h2 id="be57" class="lv kt ie bd ku lw lx ly ky lz ma mb lc jm mc md lg jq me mf lk ju mg mh lo mi dt translated">先决条件</h2><ol class=""><li id="fa02" class="jz ka ie jd b je lq ji lr jm mj jq mk ju ml jy mm kf kg kh dt translated">安装在本地计算机上的Node.js</li><li id="2b41" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy mm kf kg kh dt translated"><a class="ae kr" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> MetaMask </a>浏览器中安装的Chrome扩展</li></ol><p id="6471" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于本指南，您不需要拥有任何以太坊，因为我们将在整个教程中使用测试网络上的假以太。</p><p id="f0c4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，我们将创建一个新的React应用程序:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="357c" class="lv kt ie kq b fv mv mw l mx my">npx create-react-app react-dapp</span></pre><p id="13f9" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，进入新目录，使用<strong class="jd if"> NPM </strong>或<strong class="jd if">纱线</strong>安装<code class="eh kn ko kp kq b"><a class="ae kr" href="https://docs.ethers.io/v5/" rel="noopener ugc nofollow" target="_blank">ethers.js</a></code>和<code class="eh kn ko kp kq b"><a class="ae kr" href="https://github.com/nomiclabs/hardhat" rel="noopener ugc nofollow" target="_blank">hardhat</a></code>:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="395a" class="lv kt ie kq b fv mv mw l mx my">npm install ethers hardhat @nomiclabs/hardhat-waffle ethereum-waffle chai @nomiclabs/hardhat-ethers</span></pre><h2 id="c725" class="lv kt ie bd ku lw lx ly ky lz ma mb lc jm mc md lg jq me mf lk ju mg mh lo mi dt translated">安装和配置以太坊开发环境</h2><p id="8c24" class="pw-post-body-paragraph jb jc ie jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">接下来，用Hardhat初始化一个新的以太坊开发环境:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="8b64" class="lv kt ie kq b fv mv mw l mx my">npx hardhat</span><span id="ff6e" class="lv kt ie kq b fv mz mw l mx my">? What do you want to do? Create a sample project<br/>? Hardhat project root: &lt;Choose default path&gt;</span></pre><p id="eba1" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，您应该可以在根目录中看到为您创建的以下工件:</p><p id="1053" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if"> hardhat.config.js </strong> —您的整个hardhat设置(即您的配置、插件和自定义任务)都包含在这个文件中。<br/> <strong class="jd if">脚本</strong> —包含名为<strong class="jd if"> sample-script.js </strong>的脚本的文件夹，该脚本将在执行<br/> <strong class="jd if">测试</strong>时部署您的智能合约—包含示例测试脚本<br/> <strong class="jd if">合约</strong>的文件夹—包含示例Solidity智能合约的文件夹</p><p id="40aa" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于<a class="ae kr" href="https://hardhat.org/metamask-issue.html" rel="noopener ugc nofollow" target="_blank">一个元掩码配置问题</a>，我们需要将我们的安全帽配置上的链ID更新为<strong class="jd if"> 1337 </strong>。我们还需要为我们编译的契约更新<a class="ae kr" href="https://hardhat.org/guides/compile-contracts.html#artifacts" rel="noopener ugc nofollow" target="_blank">工件</a>的位置，使其位于React应用程序的<strong class="jd if"> src </strong>目录中。</p><p id="da5d" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要进行这些更新，打开<strong class="jd if"> hardhat.config.js </strong>并更新<code class="eh kn ko kp kq b">module.exports</code>如下所示:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="afe1" class="lv kt ie kq b fv mv mw l mx my">module.exports = {<br/>  solidity: "0.8.4",<br/>  paths: {<br/>    artifacts: './src/artifacts',<br/>  },<br/>  networks: {<br/>    hardhat: {<br/>      chainId: 1337<br/>    }<br/>  }<br/>};</span></pre><h2 id="ba78" class="lv kt ie bd ku lw lx ly ky lz ma mb lc jm mc md lg jq me mf lk ju mg mh lo mi dt translated">我们的智能合同</h2><p id="63b2" class="pw-post-body-paragraph jb jc ie jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">接下来，让我们看看<strong class="jd if"> contracts/Greeter.sol </strong>上提供给我们的合同示例:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="c55e" class="lv kt ie kq b fv mv mw l mx my">//SPDX-License-Identifier: MIT<br/>pragma solidity ^0.8.0;</span><span id="a625" class="lv kt ie kq b fv mz mw l mx my">import "hardhat/console.sol";<br/></span><span id="95e1" class="lv kt ie kq b fv mz mw l mx my">contract Greeter {<br/>  string greeting;</span><span id="134a" class="lv kt ie kq b fv mz mw l mx my">  constructor(string memory _greeting) {<br/>    console.log("Deploying a Greeter with greeting:", _greeting);<br/>    greeting = _greeting;<br/>  }</span><span id="3b6f" class="lv kt ie kq b fv mz mw l mx my">  function greet() public view returns (string memory) {<br/>    return greeting;<br/>  }</span><span id="0b3a" class="lv kt ie kq b fv mz mw l mx my">  function setGreeting(string memory _greeting) public {<br/>    console.log("Changing greeting from '%s' to '%s'", greeting, _greeting);<br/>    greeting = _greeting;<br/>  }<br/>}</span></pre><p id="21fc" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是一个非常基本的智能合约。部署时，它设置一个问候变量并公开一个函数(<code class="eh kn ko kp kq b">greet</code>)，可以调用该函数返回问候。</p><p id="c355" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">它还公开了一个允许用户更新问候语的功能(<code class="eh kn ko kp kq b">setGreeting</code>)。当部署到以太坊区块链时，用户可以使用这些方法进行交互。</p><h2 id="43ab" class="lv kt ie bd ku lw lx ly ky lz ma mb lc jm mc md lg jq me mf lk ju mg mh lo mi dt translated">区块链以太坊的阅读和写作</h2><p id="7ce6" class="pw-post-body-paragraph jb jc ie jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">与智能合约交互有两种方式，读或写/交易。在我们的合同中，<code class="eh kn ko kp kq b">greet</code>可以认为是阅读，<code class="eh kn ko kp kq b">setGreeting</code>可以认为是写作/事务性的。</p><p id="012d" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当写入或初始化一个交易时，您必须为要写入区块链的交易付费。要做到这一点，你需要支付<a class="ae kr" href="https://www.investopedia.com/terms/g/gas-ethereum.asp#:~:text=What%20Is%20Gas%20(Ethereum)%3F,on%20the%20Ethereum%20blockchain%20platform" rel="noopener ugc nofollow" target="_blank">汽油</a>，这是在以太坊区块链成功进行交易和执行合同所需的费用或价格。</p><p id="2946" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">只要你只是从区块链中读取数据，而不改变或更新任何东西，你就不需要进行交易，这样做也没有任何代价。然后你调用的功能只由你连接的节点执行，所以你不需要付任何煤气费，读取也是免费的。</p><p id="3373" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我们的React应用程序中，我们与智能合约交互的方式是使用由hardhat根据合约创建的<code class="eh kn ko kp kq b">ethers.js</code>库、合约地址和<a class="ae kr" href="https://docs.soliditylang.org/en/v0.5.3/abi-spec.html" rel="noopener ugc nofollow" target="_blank"> ABI </a>的组合。</p><p id="fa01" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">什么是ABI？ABI代表应用程序二进制接口。您可以将其视为客户端应用程序和以太坊区块链之间的接口，您将要与之交互的智能合约部署在以太坊中。</p><p id="4cb4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">ABI通常由像HardHat这样的开发框架从Solidity smart contracts编译而来。你也可以在<a class="ae kr" href="https://etherscan.io/" rel="noopener ugc nofollow" target="_blank"> Etherscan </a>上找到智能合约的ABI</p><h2 id="2240" class="lv kt ie bd ku lw lx ly ky lz ma mb lc jm mc md lg jq me mf lk ju mg mh lo mi dt translated">编纂ABI</h2><p id="4392" class="pw-post-body-paragraph jb jc ie jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">现在，我们已经学习了基本的智能合同，并知道ABI是什么，让我们为我们的项目编译一个ABI。</p><p id="cd96" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为此，请转到命令行并运行以下命令:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="0887" class="lv kt ie kq b fv mv mw l mx my">npx hardhat compile</span></pre><p id="faf2" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，您应该在<strong class="jd if"> src </strong>目录中看到一个名为<strong class="jd if">工件</strong>的新文件夹。<strong class="jd if">工件/合同/Greeter.json </strong>文件包含作为属性之一的ABI。当我们需要使用ABI时，我们可以从JavaScript文件中导入它:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="33e8" class="lv kt ie kq b fv mv mw l mx my">import Greeter from './artifacts/contracts/Greeter.sol/Greeter.json'</span></pre><p id="32e1" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以这样引用ABI:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="ed51" class="lv kt ie kq b fv mv mw l mx my">console.log("Greeter ABI: ", Greeter.abi)</span></pre><blockquote class="na nb nc"><p id="35cb" class="jb jc nd jd b je jf jg jh ji jj jk jl ne jn jo jp nf jr js jt ng jv jw jx jy hm dt translated"><em class="ie">请注意，Ethers.js还支持</em> <a class="ae kr" href="https://blog.ricmoo.com/human-readable-contract-abis-in-ethers-js-141902f4d917" rel="noopener ugc nofollow" target="_blank"> <em class="ie">人类可读ABIs </em> </a> <em class="ie">，但在本教程中不会深入讨论。</em></p></blockquote><h2 id="7a4d" class="lv kt ie bd ku lw lx ly ky lz ma mb lc jm mc md lg jq me mf lk ju mg mh lo mi dt translated">部署和使用本地网络/区块链</h2><p id="4a14" class="pw-post-body-paragraph jb jc ie jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">接下来，让我们将智能合约部署到本地区块链，以便进行测试。</p><p id="dacc" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要部署到本地网络，首先需要启动本地测试节点。为此，请打开CLI并运行以下命令:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="df92" class="lv kt ie kq b fv mv mw l mx my">npx hardhat node</span></pre><p id="c0da" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当我们运行这个命令时，您应该会看到一个地址和私钥列表。</p><figure class="mn mo mp mq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff nh"><img src="../Images/178b83d5310cf123fac216cadb09c1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E6-Q6wmeY0F4rRwg.jpg"/></div></div></figure><p id="e47a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是为我们创建的20个测试帐户和地址，我们可以使用它们来部署和测试我们的智能合同。每个账户还装了一万个假乙醚。稍后，我们将学习如何将测试帐户导入MetaMask，以便我们可以使用它。</p><p id="d077" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，我们需要将合同部署到测试网络。首先将<strong class="jd if">脚本/sample-script.js </strong>的名称更新为<strong class="jd if">脚本/deploy.js </strong>。</p><p id="10ec" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我们可以运行部署脚本，并为希望部署到本地网络的CLI提供一个标记:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="2e4b" class="lv kt ie kq b fv mv mw l mx my">npx hardhat run scripts/deploy.js --network localhost</span></pre><p id="7626" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦这个脚本被执行，智能契约应该被部署到本地测试网络，然后我们应该能够开始与它进行交互。</p><blockquote class="na nb nc"><p id="522c" class="jb jc nd jd b je jf jg jh ji jj jk jl ne jn jo jp nf jr js jt ng jv jw jx jy hm dt translated"><em class="ie">部署合同时，它使用了我们启动本地网络时创建的第一个帐户。</em></p></blockquote><p id="a9c8" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果您查看CLI的输出，您应该能够看到如下内容:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="b12a" class="lv kt ie kq b fv mv mw l mx my">Greeter deployed to: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0</span></pre><p id="17af" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这个地址是我们将在客户端应用程序中用来与智能合约对话的地址。保持该地址可用，因为我们将需要在从客户端应用程序连接到它时使用它。</p><p id="2ad9" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要将交易发送到智能合约，我们需要使用运行<code class="eh kn ko kp kq b">npx hardhat node</code>时创建的帐户之一连接MetaMask钱包。在CLI注销的合同列表中，您应该会看到一个<strong class="jd if">帐号</strong>和一个<strong class="jd if">私钥</strong>:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="bb1b" class="lv kt ie kq b fv mv mw l mx my">➜  react-dapp git:(main) npx hardhat node<br/>Started HTTP and WebSocket JSON-RPC server at http://127.0.0.1:8545/</span><span id="fc92" class="lv kt ie kq b fv mz mw l mx my">Accounts<br/>========<br/>Account #0: 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 (10000 ETH)<br/>Private Key: 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80</span><span id="1378" class="lv kt ie kq b fv mz mw l mx my">...</span></pre><p id="bf86" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以将这个帐号导入MetaMask，以便开始使用那里的一些假Eth。为此，首先打开元掩码，并将网络更新为Localhost 8545:</p><figure class="mn mo mp mq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff nh"><img src="../Images/a2be8364d35fd9a6924db4a32b602ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qOSp7yFXL1-hMiR6.jpg"/></div></div></figure><p id="d2b1" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，在MetaMask中点击账户菜单中的<strong class="jd if">导入账户</strong>:</p><figure class="mn mo mp mq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff nh"><img src="../Images/ec03e6a43278d9c32c3453c2bceb29ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AkFgQROjEGm4XbQb.jpg"/></div></div></figure><p id="15d2" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">复制然后粘贴CLI注销的<strong class="jd if">私钥</strong>之一，并点击<strong class="jd if">导入</strong>。帐户导入后，您应该会看到帐户中的Eth:</p><figure class="mn mo mp mq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff nh"><img src="../Images/d1098f9831b62341e25d57388659dad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UiHoB1FpBlzl80I4.jpg"/></div></div></figure><p id="d695" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们已经部署了一个智能合约，并且有一个帐户可以使用，我们可以开始从React应用程序与它进行交互。</p><h2 id="6a04" class="lv kt ie bd ku lw lx ly ky lz ma mb lc jm mc md lg jq me mf lk ju mg mh lo mi dt translated">连接React客户端</h2><p id="e995" class="pw-post-body-paragraph jb jc ie jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">在本教程中，我们不会担心用CSS构建一个漂亮的用户界面，我们会100%关注核心功能，让你启动并运行。从那里，你可以把它拿走，如果你愿意，可以把它弄得好看些。</p><p id="c82d" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">话虽如此，让我们回顾一下我们希望React应用程序实现的两个目标:</p><ol class=""><li id="4f44" class="jz ka ie jd b je jf ji jj jm kb jq kc ju kd jy mm kf kg kh dt translated">从智能合约中获取<code class="eh kn ko kp kq b">greeting</code>的当前值</li><li id="e05d" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy mm kf kg kh dt translated">允许用户更新<code class="eh kn ko kp kq b">greeting</code>的值</li></ol><p id="cc32" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">了解了这些事情之后，我们该如何完成呢？为了实现这一目标，我们需要做以下事情:</p><ol class=""><li id="1a63" class="jz ka ie jd b je jf ji jj jm kb jq kc ju kd jy mm kf kg kh dt translated">创建一个输入字段和一些本地状态来管理输入的值(更新<code class="eh kn ko kp kq b">greeting</code></li><li id="d2d0" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy mm kf kg kh dt translated">允许应用程序连接到用户的元掩码帐户以签署交易</li><li id="e9d4" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy mm kf kg kh dt translated">创建读取和写入智能合同的函数</li></ol><p id="d392" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为此，打开<code class="eh kn ko kp kq b">src/App.js</code>，用下面的代码更新它，将<code class="eh kn ko kp kq b">greeterAddress</code>的值设置为智能契约的地址。：</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="1634" class="lv kt ie kq b fv mv mw l mx my">import './App.css';<br/>import { useState } from 'react';<br/>import { ethers } from 'ethers'<br/>import Greeter from './artifacts/contracts/Greeter.sol/Greeter.json'</span><span id="e392" class="lv kt ie kq b fv mz mw l mx my">// Update with the contract address logged out to the CLI when it was deployed <br/>const greeterAddress = "your-contract-address"</span><span id="6dec" class="lv kt ie kq b fv mz mw l mx my">function App() {<br/>  // store greeting in local state<br/>  const [greeting, setGreetingValue] = useState()</span><span id="7478" class="lv kt ie kq b fv mz mw l mx my">  // request access to the user's MetaMask account<br/>  async function requestAccount() {<br/>    await window.ethereum.request({ method: 'eth_requestAccounts' });<br/>  }</span><span id="7127" class="lv kt ie kq b fv mz mw l mx my">  // call the smart contract, read the current greeting value<br/>  async function fetchGreeting() {<br/>    if (typeof window.ethereum !== 'undefined') {<br/>      const provider = new ethers.providers.Web3Provider(window.ethereum)<br/>      const contract = new ethers.Contract(greeterAddress, Greeter.abi, provider)<br/>      try {<br/>        const data = await contract.greet()<br/>        console.log('data: ', data)<br/>      } catch (err) {<br/>        console.log("Error: ", err)<br/>      }<br/>    }    <br/>  }</span><span id="19ad" class="lv kt ie kq b fv mz mw l mx my">  // call the smart contract, send an update<br/>  async function setGreeting() {<br/>    if (!greeting) return<br/>    if (typeof window.ethereum !== 'undefined') {<br/>      await requestAccount()<br/>      const provider = new ethers.providers.Web3Provider(window.ethereum);<br/>      const signer = provider.getSigner()<br/>      const contract = new ethers.Contract(greeterAddress, Greeter.abi, signer)<br/>      const transaction = await contract.setGreeting(greeting)<br/>      await transaction.wait()<br/>      fetchGreeting()<br/>    }<br/>  }</span><span id="6ca4" class="lv kt ie kq b fv mz mw l mx my">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;header className="App-header"&gt;<br/>        &lt;button onClick={fetchGreeting}&gt;Fetch Greeting&lt;/button&gt;<br/>        &lt;button onClick={setGreeting}&gt;Set Greeting&lt;/button&gt;<br/>        &lt;input onChange={e =&gt; setGreetingValue(e.target.value)} placeholder="Set greeting" /&gt;<br/>      &lt;/header&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="4206" class="lv kt ie kq b fv mz mw l mx my">export default App;</span></pre><p id="6412" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要进行测试，请启动React服务器:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="17dd" class="lv kt ie kq b fv mv mw l mx my">npm start</span></pre><p id="58a4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当应用程序加载时，您应该能够获取当前的问候并将其注销到控制台。你也应该能够通过用你的MetaMask钱包签合同和花费假乙醚来更新问候。</p><figure class="mn mo mp mq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff nh"><img src="../Images/ededf38030e7b698abff7e95326b177f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8uTcY8Mt2SbyrdBX.png"/></div></div></figure><h1 id="d19d" class="ks kt ie bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">将合同更新为可升级</h1><p id="f039" class="pw-post-body-paragraph jb jc ie jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">正如本教程开头所述，我们将使用需要安装的<a class="ae kr" href="https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin升级</a>库:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="bf95" class="lv kt ie kq b fv mv mw l mx my">$ npm install --save-dev @openzeppelin/hardhat-upgrades</span></pre><p id="c1d3" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">并在您的<code class="eh kn ko kp kq b">hardhat.config.js</code>中注册插件。为此，您只需要在<code class="eh kn ko kp kq b">hardhat.config.js</code>文件的顶部添加下面一行。</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="2fc2" class="lv kt ie kq b fv mv mw l mx my">require('@openzeppelin/hardhat-upgrades');</span></pre><p id="76f6" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">除了它们的<em class="nd">构造器</em>之外，你可以在不做任何修改的情况下使用你的Solidity契约。由于OpenZeppelin使用的基于代理的可升级性系统的要求，在可升级契约中不能使用构造函数。如果您想了解更多信息，请参见此处的<a class="ae kr" href="https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies#the-constructor-caveat" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="c5cb" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">相反，我们的合同需要</p><ul class=""><li id="5071" class="jz ka ie jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated">继承OpenZeppelin提供的<code class="eh kn ko kp kq b">Initializable</code>基地契约</li><li id="f15f" class="jz ka ie jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">拥有一个带有<code class="eh kn ko kp kq b">intializer</code>修饰符的<code class="eh kn ko kp kq b">initialize</code>函数，而不是一个构造函数</li></ul><p id="1532" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，我们需要将我们的<code class="eh kn ko kp kq b">Greeter.sol</code>文件改为如下</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="ba5b" class="lv kt ie kq b fv mv mw l mx my">//SPDX-License-Identifier: Unlicense<br/>pragma solidity ^0.8.4;</span><span id="c0a4" class="lv kt ie kq b fv mz mw l mx my">import "hardhat/console.sol";<br/>import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";</span><span id="848c" class="lv kt ie kq b fv mz mw l mx my">contract Greeter is Initializable {<br/>    string private greeting;</span><span id="f6f4" class="lv kt ie kq b fv mz mw l mx my">function initialize(string memory _greeting) public initializer {<br/>        console.log("Deploying a Greeter with greeting:", _greeting);<br/>        greeting = _greeting;<br/>    }</span><span id="0ff7" class="lv kt ie kq b fv mz mw l mx my">function greet() public view returns (string memory) {<br/>        console.log("Fetching greeting");<br/>        return greeting;<br/>    }</span><span id="741c" class="lv kt ie kq b fv mz mw l mx my">function setGreeting(string memory _greeting) public {<br/>        console.log("New Changing greeting from '%s' to '%s'", greeting, _greeting);<br/>        greeting = _greeting;<br/>    }<br/>}</span></pre><p id="dfb1" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后，您需要将部署脚本更新为以下内容</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="45c5" class="lv kt ie kq b fv mv mw l mx my">const { ethers, upgrades } = require("hardhat");</span><span id="4a32" class="lv kt ie kq b fv mz mw l mx my">async function main() {</span><span id="bc7b" class="lv kt ie kq b fv mz mw l mx my">// We get the contract to deploy<br/>  const Greeter = await ethers.getContractFactory("Greeter");<br/>  const greeter = await upgrades.deployProxy(Greeter,["Hello, Hardhat!"]);</span><span id="b18c" class="lv kt ie kq b fv mz mw l mx my">  await greeter.deployed();<br/>  console.log("Greeter deployed to:", greeter.address);<br/>}</span><span id="f10d" class="lv kt ie kq b fv mz mw l mx my">// We recommend this pattern to be able to use async/await everywhere<br/>// and properly handle errors.<br/>main()<br/>  .then(() =&gt; process.exit(0))<br/>  .catch((error) =&gt; {<br/>    console.error(error);<br/>    process.exit(1);<br/>  });</span></pre><p id="bc18" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我们编译更新的智能合同:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="8302" class="lv kt ie kq b fv mv mw l mx my">npx hardhat compile</span></pre><p id="d85e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后，我们可以运行部署脚本来部署到我们的本地网络:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="6ebc" class="lv kt ie kq b fv mv mw l mx my">npx hardhat run scripts/deploy.js --network localhost</span></pre><p id="099b" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦这个脚本被执行，新的可升级智能合同应该被部署，然后我们应该能够开始与它进行交互。</p><p id="a600" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果您查看CLI的输出，您应该能够看到如下内容:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="4ccb" class="lv kt ie kq b fv mv mw l mx my">Greeter deployed to: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0</span></pre><p id="963e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">记得用这个新地址更新<strong class="jd if"> src/App.js </strong>文件中的<code class="eh kn ko kp kq b">greeterAdrress</code>变量。然后，您应该能够从dapp与契约进行交互。</p><h1 id="7aa4" class="ks kt ie bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">升级已部署的可升级合同</h1><p id="a018" class="pw-post-body-paragraph jb jc ie jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">现在，我们将修改我们的智能合约并在区块链上升级它，这样我们的dapp将与新编写的智能合约的代码进行交互，而无需我们更改dapp代码中的智能合约地址。</p><p id="fc14" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们通过改变初始化中的行为来修改契约代码</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="72f3" class="lv kt ie kq b fv mv mw l mx my">//SPDX-License-Identifier: Unlicense<br/>pragma solidity ^0.8.4;</span><span id="42d7" class="lv kt ie kq b fv mz mw l mx my">import "hardhat/console.sol";<br/>import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";</span><span id="988d" class="lv kt ie kq b fv mz mw l mx my">contract Greeter is Initializable {<br/>    string private greeting;</span><span id="32f1" class="lv kt ie kq b fv mz mw l mx my">function initialize(string memory _greeting) public initializer {<br/>        console.log("Deploying an <strong class="kq if">Upgrade of </strong>Greeter with greeting:", _greeting);<br/>        greeting = _greeting;<br/>    }</span><span id="f581" class="lv kt ie kq b fv mz mw l mx my">function greet() public view returns (string memory) {<br/>        console.log("Fetching <strong class="kq if">Upgraded of</strong> greeting");<br/>        return greeting;<br/>    }</span><span id="df0c" class="lv kt ie kq b fv mz mw l mx my">function setGreeting(string memory _greeting) public {<br/>        console.log("Changing <strong class="kq if">Upgraded of </strong>greeting from '%s' to '%s'", greeting, _greeting);<br/>        greeting = _greeting;<br/>    }<br/>}</span></pre><p id="e738" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后我们编译更新后的文件:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="0b2c" class="lv kt ie kq b fv mv mw l mx my">npx hardhat compile</span></pre><p id="4616" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我们需要编写一个升级脚本，它将在与旧版本相同的地址部署新版本的合同。</p><p id="708b" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们只需创建一个包含以下内容的文件<strong class="jd if"> scripts/upgrade.js </strong></p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="79be" class="lv kt ie kq b fv mv mw l mx my">const { ethers, upgrades } = require("hardhat");</span><span id="c7cc" class="lv kt ie kq b fv mz mw l mx my">async function main() {<br/>  const Greeter = await ethers.getContractFactory("Greeter");<br/>  const greeter = await upgrades.upgradeProxy("your-upgradeable-contract-address", Greeter);<br/>  console.log("Greeter upgraded to:", greeter.address);<br/>}</span><span id="bcf2" class="lv kt ie kq b fv mz mw l mx my">// We recommend this pattern to be able to use async/await everywhere<br/>// and properly handle errors.<br/>main()<br/>  .then(() =&gt; process.exit(0))<br/>  .catch((error) =&gt; {<br/>    console.error(error);<br/>    process.exit(1);<br/>  });</span></pre><p id="b56f" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">其中字符串<code class="eh kn ko kp kq b">your-upgradeable-contract-address</code>应该被替换为已部署的可升级契约的地址。</p><p id="ef76" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们可以升级合同了</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="1a6f" class="lv kt ie kq b fv mv mw l mx my">npx hardhat run scripts/upgrade.js --network localhost</span></pre><h1 id="72f9" class="ks kt ie bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">为我们的可升级合同编写测试</h1><p id="a8e0" class="pw-post-body-paragraph jb jc ie jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">在我们的项目主文件夹中，有一个名为<code class="eh kn ko kp kq b">test/</code>的子文件夹，在其中您会发现一个名为<code class="eh kn ko kp kq b">sample-test.js</code>的样本测试文件，其内容如下:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="882d" class="lv kt ie kq b fv mv mw l mx my">const { expect } = require("chai");<br/>const { ethers } = require("hardhat");</span><span id="4907" class="lv kt ie kq b fv mz mw l mx my">describe("Greeter", function () {<br/>  it("Should return the new greeting once it's changed", async function () {<br/>    const Greeter = await ethers.getContractFactory("Greeter");<br/>    const greeter = await Greeter.deploy("Hello, world!");<br/>    await greeter.deployed();</span><span id="7e04" class="lv kt ie kq b fv mz mw l mx my">expect(await greeter.greet()).to.equal("Hello, world!");</span><span id="af6e" class="lv kt ie kq b fv mz mw l mx my">const setGreetingTx = await greeter.setGreeting("Hola, mundo!");</span><span id="947c" class="lv kt ie kq b fv mz mw l mx my">// wait until the transaction is mined<br/>    await setGreetingTx.wait();</span><span id="7867" class="lv kt ie kq b fv mz mw l mx my">expect(await greeter.greet()).to.equal("Hola, mundo!");<br/>  });<br/>});</span></pre><p id="ee62" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们只需要对这个常规测试文件做一件事情:我们如何部署我们的智能契约。</p><p id="b1cc" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于普通契约，我们使用智能契约实例的<code class="eh kn ko kp kq b">deploy()</code>函数来部署契约。这个<code class="eh kn ko kp kq b">deploy()</code>函数使用契约的构造函数。如果你还记得的话，你会注意到在Openzeppelin中，可升级的智能契约没有构造函数，而是有一个初始化函数。</p><p id="15b7" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要处理它，你只需要改变路线</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="04ee" class="lv kt ie kq b fv mv mw l mx my">const greeter = await Greeter.deploy("Hello, world!");</span></pre><p id="7b20" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">到…里面</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="bc73" class="lv kt ie kq b fv mv mw l mx my">const greeter = await upgrades.deployProxy(Greeter,["Hello, world!"]);</span></pre><p id="fa23" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们的测试文件已经准备好了。要启动测试，您只需执行以下操作:</p><pre class="mn mo mp mq fq mr kq ms mt aw mu dt"><span id="082d" class="lv kt ie kq b fv mv mw l mx my">npx hardhat test</span></pre><p id="85f7" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您将得到以下结果:</p><figure class="mn mo mp mq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff ni"><img src="../Images/ac92449e45cf52dab0ff57293c7fa79e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVFqwxaec8G_9e1Rzb_7aA.png"/></div></div></figure><h1 id="4281" class="ks kt ie bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">我们到了！</h1><p id="c7e3" class="pw-post-body-paragraph jb jc ie jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">您刚刚完成了一个编写dapp的端到端示例，该dapp与solidity中的可升级智能合约进行交互。你正走在构建坚实可靠的项目的正确道路上。</p><p id="2680" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果你有问题，请在下面的评论区提出。</p><p id="0926" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">花</p><p id="c742" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你可以在推特上写我:<a class="ae kr" href="http://twitter.com/BloomVerga" rel="noopener ugc nofollow" target="_blank">布鲁姆韦尔加</a></p><p id="72d6" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">BSC &amp; ETH钱包:0xd6e 4948 B3 a 098075052 df 419 a 06 BDD 4036 a9 BD 6d</p></div></div>    
</body>
</html>