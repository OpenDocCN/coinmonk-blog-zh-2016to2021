<html>
<head>
<title>Math in Solidity (Part 3: Percents and Proportions)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实的数学(第三部分:百分比和比例)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1?source=collection_archive---------0-----------------------#2020-02-26">https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1?source=collection_archive---------0-----------------------#2020-02-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="e234" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">这篇文章是关于在Solidity中做数学的系列文章的第三篇。这次的题目是:<strong class="ak">百分比和比例</strong>。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ji"><img src="../Images/4d3c75bf6866593cb733cc467e4f52c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*v8fR0dp_cycKcP0d_PjVSw.jpeg"/></div></figure><h1 id="8fe2" class="jq jr ht bd js jt ju jv jw jx jy jz ka iz kb ja kc jc kd jd ke jf kf jg kg kh dt translated">介绍</h1><p id="2df3" class="pw-post-body-paragraph ki kj ht kk b kl km iu kn ko kp ix kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">金融数学从百分比开始。<em class="le"> x </em>占<em class="le"> y </em>的百分比是多少？<em class="le"> x </em>等于<em class="le"> y </em>的百分之多少？答案我们都知道:<em class="le"> x </em>百分之<em class="le"> y </em>是<em class="le">x</em>×<em class="le">y</em>÷100<em class="le">y</em>是<em class="le">y</em>×100÷x百分之x，这是学校数学。</p><p id="9a21" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">上面的公式是求解比例的特例。一般来说，比例是以下形式的方程:<em class="le">a</em><em class="le">b</em>=<em class="le">c</em><em class="le">d</em>，求解比例就是在已知其他三个的情况下求其中一个值。例如，<em class="le"> d </em>可以从<em class="le"> a </em>、<em class="le"> b </em>和<em class="le"> c </em>中找到，如下:<em class="le">d</em>=<em class="le">b</em>×<em class="le">c</em><em class="le">a</em>。</p><p id="2d64" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">在主流编程语言中简单明了，在Solidity中，这种简单的计算令人惊讶地具有挑战性，正如我们在<a class="ae lk" rel="noopener" href="/coinmonks/math-in-solidity-part-2-overflow-3cd7283714b4#8b23">上一篇文章</a>中所示。原因有二:I)实性不支持分数；以及ii)Solidity中的数字类型可能溢出。</p><p id="7d92" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">在Javascript中，可以这样简单地计算<em class="le">x</em>×<em class="le">y</em><em class="le">z</em>:<code class="eh ll lm ln lo b">x*y/z</code>。实际上这样的表达式不会通过安全审核，因为对于足够大的x<em class="le">和y<em class="le">的乘法运算可能会溢出，从而导致计算结果不正确。使用SafeMath没有太大帮助，因为它可能会使交易失败，即使最终计算结果适合256位。在前一篇文章中，我们将这种情况称为“幻影溢出”。像<code class="eh ll lm ln lo b">x/z*y</code>或<code class="eh ll lm ln lo b">y/z*x</code>那样先做除法再做乘法解决了幻影溢出问题，但可能导致精度下降。</em></em></p><p id="abcd" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">在这篇文章中，我们发现在Solidity中有什么更好的方法来处理<strong class="kk hu">百分比和比例</strong>。</p><h1 id="bfed" class="jq jr ht bd js jt ju jv jw jx jy jz ka iz kb ja kc jc kd jd ke jf kf jg kg kh dt translated">接近全部比例</h1><p id="73a1" class="pw-post-body-paragraph ki kj ht kk b kl km iu kn ko kp ix kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">本文的目标是可靠地实现以下功能:</p><pre class="jj jk jl jm fq lp lo lq lr aw ls dt"><span id="021f" class="lt jr ht lo b fv lu lv l lw lx">function mulDiv (uint x, uint y, uint z)<br/>public pure returns (uint)</span></pre><p id="34cf" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">它计算<em class="le">x</em>×<em class="le">y</em><em class="le">z</em>，将结果向下舍入，并在<em class="le"> z </em>为零或结果不符合<code class="eh ll lm ln lo b">uint</code>时抛出。让我们从以下简单的解决方案开始:</p><pre class="jj jk jl jm fq lp lo lq lr aw ls dt"><span id="16c4" class="lt jr ht lo b fv lu lv l lw lx">function mulDiv (uint x, uint y, uint z)<br/>public pure returns (uint)<br/>{<br/>  return x * y / z;<br/>}</span></pre><p id="492a" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">这个解决方案基本上满足了大部分要求:它好像是计算<em class="le">x</em>×<em class="le">y</em><em class="le">z</em>，向下舍入结果，如果<em class="le"> z </em>为零就抛出。但是有一个问题:它实际计算的是<em class="le">x</em>×<em class="le">y</em><strong class="kk hu">mod</strong><em class="le">2⁵⁶</em><em class="le">z</em>。这就是乘法溢出在Solidity中的工作原理。当乘法结果不适合256位时，仅返回结果的最低256位。对于小数值的<em class="le"> x </em>和<em class="le"> y </em>，当<em class="le">x</em>×<em class="le">y</em>t130】2⁵⁶时，没有区别，但是对于大数值的<em class="le"> x </em>和<em class="le"> y </em>会产生不正确的结果。所以第一个问题是:</p><h2 id="f425" class="lt jr ht bd js ly lz ma jw mb mc md ka kr me mf kc kv mg mh ke kz mi mj kg mk dt translated">我们如何防止溢出？</h2><blockquote class="ml mm mn"><p id="b6a3" class="ki kj le kk b kl lf iu kn ko lg ix kq mo lh kt ku mp li kx ky mq lj lb lc ld hm dt translated">剧透:我们不应该。</p></blockquote><p id="2795" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">防止Solidity中乘法溢出的常见方法是使用SafeMath库中的<code class="eh ll lm ln lo b">mul</code>函数:</p><pre class="jj jk jl jm fq lp lo lq lr aw ls dt"><span id="4dfd" class="lt jr ht lo b fv lu lv l lw lx">function mulDiv (uint x, uint y, uint z)<br/>public pure returns (uint)<br/>{<br/>  return mul (x, y) / z;<br/>}</span></pre><p id="e1e6" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">这段代码保证了正确的结果，所以现在所有的需求都满足了，对吗？没那么快。</p><p id="5221" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">需求是在结果不符合<code class="eh ll lm ln lo b">uint</code>的情况下进行恢复，这个实现似乎满足了需求。然而，当<em class="le"> x </em> × <em class="le"> y </em>不符合<code class="eh ll lm ln lo b">uint</code>时，即使最终结果符合，该实现也会恢复。我们称这种情况为“幻影溢出”。在上一篇文章中，我们展示了如何以精度为代价来解决幻影溢出，但是这个解决方案在这里不起作用，因为我们想要精确的结果。</p><p id="cb50" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">因为仅仅恢复幻像溢出是不可行的，那么</p><h2 id="4821" class="lt jr ht bd js ly lz ma jw mb mc md ka kr me mf kc kv mg mh ke kz mi mj kg mk dt translated">我们如何避免幻影溢出保持精度？</h2><blockquote class="ml mm mn"><p id="3893" class="ki kj le kk b kl lf iu kn ko lg ix kq mo lh kt ku mp li kx ky mq lj lb lc ld hm dt translated">剧透:简单的数学把戏。</p></blockquote><p id="698d" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">我们来做如下替换:<em class="le">x</em>=<em class="le">a</em>×<em class="le">z</em>+<em class="le">b</em>和<em class="le">y</em>=<em class="le">c</em>×<em class="le">z</em>+<em class="le">d</em>，其中<em class="le"> a </em>、<em class="le"> b </em>、<em class="le"> c </em>和<em class="le">d<em class="le">然后:</em></em></p><p id="df26" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated"><em class="le">x</em>×<em class="le">y</em><em class="le">z</em>=<br/>(<em class="le">a</em>×<em class="le">z</em>+<em class="le">b</em>)×(<em class="le">c</em>×<em class="le">z</em>+<em class="le">d</em>)<em class="le">z</em>=<br/> z=<br/><em class="le">a</em>×c×<em class="le">z</em>+<em class="le">a</em>×<em class="le">d</em>+<em class="le">b</em>×<em class="le">c</em>+<em class="le">b</em>×<em class="le">d</em><em class="le">z</em></p><p id="6424" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">值<em class="le"> a </em>、<em class="le"> b </em>、<em class="le"> c </em>和<em class="le"> d </em>可以分别通过将<em class="le"> x </em>和<em class="le"> y </em>除以<em class="le"> z </em>计算为商数和提醒数。</p><p id="bf2e" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">因此，该函数可以重写如下:</p><pre class="jj jk jl jm fq lp lo lq lr aw ls dt"><span id="c4f6" class="lt jr ht lo b fv lu lv l lw lx">function mulDiv (uint x, uint y, uint z)<br/>public pure returns (uint)<br/>{<br/>  uint a = x / z; uint b = x % z; // x = a * z + b<br/>  uint c = y / z; uint d = y % z; // y = c * z + d</span><span id="40cf" class="lt jr ht lo b fv mr lv l lw lx">  return a * b * z + a * d + b * c + b * d / z;<br/>}</span></pre><p id="ec79" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">这里我们使用普通的<code class="eh ll lm ln lo b">+</code>和<code class="eh ll lm ln lo b">*</code>操作符来提高可读性，而真实的代码应该使用SafeMath函数来防止真实的(即非幻像的)溢出。</p><p id="3abd" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">在这个实现中，幻像溢出仍然是可能的，但只是在最后一个术语:<code class="eh ll lm ln lo b">b * d / z</code>。但是，当<em class="le"> z </em> ≤2 ⁸时，该代码保证正确工作，因为<em class="le"> b </em>和<em class="le"> d </em>都小于<em class="le"> z </em>，因此<em class="le"> b </em> × <em class="le"> d </em>保证适合256位。因此，这种实现可以用于已知<em class="le"> z </em>不超过2 ⁸.的情况一个常见的例子就是18位小数的定点乘法:<em class="le"> x </em> × <em class="le"> y </em> ÷10 ⁸.但是，</p><h2 id="5f04" class="lt jr ht bd js ly lz ma jw mb mc md ka kr me mf kc kv mg mh ke kz mi mj kg mk dt translated">如何才能完全避免幻影溢出？</h2><blockquote class="ml mm mn"><p id="2bb4" class="ki kj le kk b kl lf iu kn ko lg ix kq mo lh kt ku mp li kx ky mq lj lb lc ld hm dt translated">剧透:用更宽的数字。</p></blockquote><p id="2fa6" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">幻像溢出问题的根源是中间乘法结果不适合256位。所以，让我们用更宽的字体。Solidity本身不支持宽度超过256位的数值类型，所以我们必须模拟它们。我们基本上需要两个操作:<em class="le">uint</em>×<em class="le">uint</em>→<em class="le">宽</em>和<em class="le">宽</em><em class="le">uint</em>→<em class="le">uint</em>。</p><p id="f285" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">由于两个256位无符号整数的乘积不能超过512位，因此更宽的类型必须至少为512位宽。我们可以通过一对256位无符号整数来模拟512位无符号整数，这两个256位无符号整数分别保存整个512位数的较低和较高256位部分。</p><p id="8559" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">因此，代码可能如下所示:</p><pre class="jj jk jl jm fq lp lo lq lr aw ls dt"><span id="95d9" class="lt jr ht lo b fv lu lv l lw lx">function mulDiv (uint x, uint y, uint z)<br/>public pure returns (uint)<br/>{<br/>  (uint l, uint h) = fullMul (x, y);<br/>  return fullDiv (l, h, z);<br/>}</span></pre><p id="9019" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">这里<code class="eh ll lm ln lo b">fullMul</code>函数将两个256位无符号整数相乘，并将结果作为512位无符号整数分成两个256位部分返回。函数<code class="eh ll lm ln lo b">fullDiv</code>将作为两个256位部分传递的512位无符号整数除以256位无符号整数，并将结果作为256位无符号整数返回。</p><p id="fcc6" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">让我们用学校数学的方法实现这两个函数:</p><pre class="jj jk jl jm fq lp lo lq lr aw ls dt"><span id="c4e1" class="lt jr ht lo b fv lu lv l lw lx">function fullMul (uint x, uint y)<br/>public pure returns (uint l, uint h)<br/>{<br/>  uint xl = uint128 (x); uint xh = x &gt;&gt; 128;<br/>  uint yl = uint128 (y); uint yh = y &gt;&gt; 128;</span><span id="3f82" class="lt jr ht lo b fv mr lv l lw lx">  uint xlyl = xl * yl; uint xlyh = xl * yh;<br/>  uint xhyl = xh * yl; uint xhyh = xh * yh;<br/><br/>  uint ll = uint128 (xlyl);<br/>  uint lh = (xlyl &gt;&gt; 128) + uint128 (xlyh) + uint128 (xhyl);<br/>  uint hl = uint128 (xhyh) + (xlyh &gt;&gt; 128) + (xhyl &gt;&gt; 128);<br/>  uint hh = (xhyh &gt;&gt; 128);</span><span id="694f" class="lt jr ht lo b fv mr lv l lw lx">  l = ll + (lh &lt;&lt; 128);<br/>  h = (lh &gt;&gt; 128) + hl + (hh &lt;&lt; 128);<br/>}</span></pre><p id="be9f" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">和</p><pre class="jj jk jl jm fq lp lo lq lr aw ls dt"><span id="ea49" class="lt jr ht lo b fv lu lv l lw lx">function fullDiv (uint l, uint h, uint z)<br/>public pure returns (uint r) {<br/>  require (h &lt; z);</span><span id="78fa" class="lt jr ht lo b fv mr lv l lw lx">  uint zShift = mostSignificantBit (z);<br/>  uint shiftedZ = z;<br/>  if (zShift &lt;= 127) zShift = 0;<br/>  else<br/>  {<br/>    zShift -= 127;<br/>    shiftedZ = (shiftedZ - 1 &gt;&gt; zShift) + 1;<br/>  }</span><span id="ed7b" class="lt jr ht lo b fv mr lv l lw lx">  while (h &gt; 0)<br/>  {<br/>    uint lShift = mostSignificantBit (h) + 1;<br/>    uint hShift = 256 - lShift;</span><span id="fb2d" class="lt jr ht lo b fv mr lv l lw lx">    uint e = ((h &lt;&lt; hShift) + (l &gt;&gt; lShift)) / shiftedZ;<br/>    if (lShift &gt; zShift) e &lt;&lt;= (lShift - zShift);<br/>    else e &gt;&gt;= (zShift - lShift);</span><span id="3e06" class="lt jr ht lo b fv mr lv l lw lx">    r += e;</span><span id="454b" class="lt jr ht lo b fv mr lv l lw lx">    (uint tl, uint th) = fullMul (e, z);<br/>    h -= th;<br/>    if (tl &gt; l) h -= 1;<br/>    l -= tl;<br/>  }</span><span id="30d8" class="lt jr ht lo b fv mr lv l lw lx">  r += l / z;<br/>}</span></pre><p id="62d1" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">这里的<code class="eh ll lm ln lo b">mostSignificantBit</code>是一个函数，它返回自变量最高有效位的从零开始的索引。该功能可以如下实现:</p><pre class="jj jk jl jm fq lp lo lq lr aw ls dt"><span id="bbbb" class="lt jr ht lo b fv lu lv l lw lx">function mostSignificantBit (uint x) public pure returns (uint r) {<br/>  require (x &gt; 0);</span><span id="b62d" class="lt jr ht lo b fv mr lv l lw lx">  if (x &gt;= 2**128) { x &gt;&gt;= 128; r += 128; }<br/>  if (x &gt;= 2**64) { x &gt;&gt;= 64; r += 64; }<br/>  if (x &gt;= 2**32) { x &gt;&gt;= 32; r += 32; }<br/>  if (x &gt;= 2**16) { x &gt;&gt;= 16; r += 16; }<br/>  if (x &gt;= 2**8) { x &gt;&gt;= 8; r += 8; }<br/>  if (x &gt;= 2**4) { x &gt;&gt;= 4; r += 4; }<br/>  if (x &gt;= 2**2) { x &gt;&gt;= 2; r += 2; }<br/>  if (x &gt;= 2**1) { x &gt;&gt;= 1; r += 1; }<br/>}</span></pre><p id="0c3b" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">上面的代码非常复杂，可能应该解释一下，但是我们现在将跳过解释，专注于不同的问题。这段代码的问题是每次调用<code class="eh ll lm ln lo b">mulDiv</code>函数大约消耗2.5K的gas，相当多。所以，</p><h2 id="fe5c" class="lt jr ht bd js ly lz ma jw mb mc md ka kr me mf kc kv mg mh ke kz mi mj kg mk dt translated">我们能便宜点吗？</h2><blockquote class="ml mm mn"><p id="4896" class="ki kj le kk b kl lf iu kn ko lg ix kq mo lh kt ku mp li kx ky mq lj lb lc ld hm dt translated">剧透:mathemagic！</p></blockquote><p id="08b2" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">下面的代码是基于Remco Bloemen 描述的令人兴奋的数学发现。如果你喜欢这段代码，请点击他的“数学魔术”文章。</p><p id="71b3" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">首先，我们重写<code class="eh ll lm ln lo b">fullMul</code>函数:</p><pre class="jj jk jl jm fq lp lo lq lr aw ls dt"><span id="ac61" class="lt jr ht lo b fv lu lv l lw lx">function fullMul (uint x, uint y)<br/>public pure returns (uint l, uint h)<br/>{<br/>  uint mm = mulmod (x, y, uint (-1));<br/>  l = x * y;<br/>  h = mm - l;<br/>  if (mm &lt; l) h -= 1;<br/>}</span></pre><p id="06dc" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">每次调用<code class="eh ll lm ln lo b">fullMul</code>可以节省大约250点汽油。</p><p id="393c" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">然后我们重写<code class="eh ll lm ln lo b">mulDiv</code>函数:</p><pre class="jj jk jl jm fq lp lo lq lr aw ls dt"><span id="0d43" class="lt jr ht lo b fv lu lv l lw lx">function mulDiv (uint x, uint y, uint z)<br/>public pure returns (uint) {<br/>  (uint l, uint h) = fullMul (x, y);<br/>  require (h &lt; z);</span><span id="59c7" class="lt jr ht lo b fv mr lv l lw lx">  uint mm = mulmod (x, y, z);<br/>  if (mm &gt; l) h -= 1;<br/>  l -= mm;</span><span id="21c6" class="lt jr ht lo b fv mr lv l lw lx">  uint pow2 = z &amp; -z;<br/>  z /= pow2;<br/>  l /= pow2;<br/>  l += h * ((-pow2) / pow2 + 1);</span><span id="2bf5" class="lt jr ht lo b fv mr lv l lw lx">  uint r = 1;<br/>  r *= 2 - z * r;<br/>  r *= 2 - z * r;<br/>  r *= 2 - z * r;<br/>  r *= 2 - z * r;<br/>  r *= 2 - z * r;<br/>  r *= 2 - z * r;<br/>  r *= 2 - z * r;<br/>  r *= 2 - z * r;</span><span id="8dea" class="lt jr ht lo b fv mr lv l lw lx">  return l * r;<br/>}</span></pre><p id="eab2" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">这个实现每次<code class="eh ll lm ln lo b">mulDiv</code>调用只消耗大约550 gas，还可以进一步优化。比学校数学方法好5倍。非常好！但是一个人真的必须获得数学博士学位才能写出这样的代码，而且不是每个问题都有这样的数学魔法解决方案。如果可以，事情会简单得多</p><h1 id="e6ca" class="jq jr ht bd js jt ju jv jw jx jy jz ka iz kb ja kc jc kd jd ke jf kf jg kg kh dt translated">在可靠性中使用浮点数</h1><p id="8947" class="pw-post-body-paragraph ki kj ht kk b kl km iu kn ko kp ix kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">正如我们在本文开头已经说过的，在JavaScript中，人们只需简单地写下<code class="eh ll lm ln lo b">a * b / c</code>，语言会处理剩下的事情。如果我们能在可靠性方面做同样的事情会怎么样？</p><p id="ca6f" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">事实上我们可以。虽然核心语言不支持浮点，但有一些库支持浮点。例如，使用<a class="ae lk" href="https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.md" rel="noopener ugc nofollow" target="_blank"> ABDKMathQuad </a>库，可以编写:</p><pre class="jj jk jl jm fq lp lo lq lr aw ls dt"><span id="03b4" class="lt jr ht lo b fv lu lv l lw lx">function mulDiv (uint x, uint y, uint z)<br/>public pure returns (uint) {<br/>  return<br/>    ABDKMathQuad<!-- -->.toUInt (<br/>      <!-- -->ABDKMathQuad<!-- -->.div (<br/>        <!-- -->ABDKMathQuad.mul (<br/>          ABDKMathQuad.fromUInt (x),<br/>          ABDKMathQuad.fromUInt (y)<br/>        ),<br/>        ABDKMathQuad.fromUInt (z)<br/>      )<br/>    );<br/>}</span></pre><p id="56b5" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">不像JavaScript那样优雅，不像mathemagic solution那样便宜(甚至比学校的数学方法更具扩展性)，但是简单明了而且相当精确，因为这里使用的四倍精度浮点数有大约33位有效小数。</p><p id="0e2b" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">该实现一半以上的气体消耗用于将<code class="eh ll lm ln lo b">uint</code>值转换为浮点值并返回，比例计算本身仅消耗约1.4K气体。因此，在所有智能合约中使用浮点数比混合使用整数和浮点数要便宜得多。</p><h1 id="e25f" class="jq jr ht bd js jt ju jv jw jx jy jz ka iz kb ja kc jc kd jd ke jf kf jg kg kh dt translated">结论</h1><p id="e507" class="pw-post-body-paragraph ki kj ht kk b kl km iu kn ko kp ix kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">由于溢出和缺乏分数支持，百分比和比例在可靠性方面具有挑战性。然而，各种数学技巧允许正确和有效地解决比例。</p><p id="eee1" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">库支持的浮点数可能会让生活变得更美好，但代价是气体和精度。</p><p id="2d22" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">在我们的下一篇文章中，我们将深入金融数学，因为下一个主题将是:<a class="ae lk" rel="noopener" href="/coinmonks/math-in-solidity-part-4-compound-interest-512d9e13041b"> <strong class="kk hu">复利</strong> </a>。</p></div><div class="ab cl mu mv hb mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hm hn ho hp hq"><p id="371c" class="pw-post-body-paragraph ki kj ht kk b kl lf iu kn ko lg ix kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">本系列的其他文章:</p><ul class=""><li id="8503" class="nb nc ht kk b kl lf ko lg kr nd kv ne kz nf ld ng nh ni nj dt translated"><a class="ae lk" rel="noopener" href="/coinmonks/math-in-solidity-part-1-numbers-384c8377f26d">第1部分:数字</a></li><li id="765e" class="nb nc ht kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj dt translated"><a class="ae lk" rel="noopener" href="/coinmonks/math-in-solidity-part-2-overflow-3cd7283714b4">第二部分:溢出</a></li><li id="f2bb" class="nb nc ht kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj dt translated"><a class="ae lk" rel="noopener" href="/coinmonks/math-in-solidity-part-4-compound-interest-512d9e13041b">第四部分:复利</a></li><li id="4024" class="nb nc ht kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj dt translated"><a class="ae lk" rel="noopener" href="/coinmonks/math-in-solidity-part-5-exponent-and-logarithm-9aef8515136e">第五部分:指数和对数</a></li></ul><blockquote class="np"><p id="afd5" class="nq nr ht bd ns nt nu nv nw nx ny ld ek translated">加入Coinmonks <a class="ae lk" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae lk" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae lk" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="lt jr ht bd js ly nz ma jw mb oa md ka kr ob mf kc kv oc mh ke kz od mj kg mk dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="nb nc ht kk b kl km ko kp kr oe kv of kz og ld ng nh ni nj dt translated"><a class="ae lk" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae lk" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="nb nc ht kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj dt translated"><a class="ae lk" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae lk" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="nb nc ht kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj dt translated"><a class="ae lk" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae lk" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="nb nc ht kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj dt translated"><a class="ae lk" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae lk" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="nb nc ht kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj dt translated">开发人员的最佳加密API</li><li id="b359" class="nb nc ht kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj dt translated">最佳<a class="ae lk" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="nb nc ht kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj dt translated"><a class="ae lk" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> |加密交易机器人</li><li id="9487" class="nb nc ht kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj dt translated"><a class="ae lk" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a>终极指南</li></ul></div></div>    
</body>
</html>