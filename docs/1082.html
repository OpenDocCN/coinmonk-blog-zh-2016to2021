<html>
<head>
<title>Visually Understanding Worker Pool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">直观了解员工池</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/visually-understanding-worker-pool-48a83b7fc1f5?source=collection_archive---------0-----------------------#2018-07-19">https://medium.com/coinmonks/visually-understanding-worker-pool-48a83b7fc1f5?source=collection_archive---------0-----------------------#2018-07-19</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/202a0f3870dbbc35c752d0b2a107e298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJj8RpGPCkiWHot2R8m0KA.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Example diagram of a worker pool process in Go using goRoutines</figcaption></figure><p id="54a1" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们需要关注的问题是创建一个更加<strong class="jh hu">可视化的</strong>方法来理解模式和一些其他<strong class="jh hu">解决方案架构</strong>，如果它们没有被正确理解，可能会在你的内部团队中产生一个黑箱情况。</p><p id="8609" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">通常，我们倾向于“复制和粘贴”代码，甚至没有意识到底层是如何工作的。今天，我们将回顾著名的(然而<strong class="jh hu">被低估的</strong>)工人池(又名线程池)。在<strong class="jh hu"> <em class="kd"> Go、</em> </strong>中，通常使用<a class="ae ke" href="https://tour.golang.org/concurrency/3" rel="noopener ugc nofollow" target="_blank">缓冲通道</a>作为goRoutines之间的主队列和通信通道。为了更清楚地理解，在继续这篇文章之前，先了解<a class="ae ke" href="https://tour.golang.org/concurrency/2" rel="noopener ugc nofollow" target="_blank">频道</a>。</p><h2 id="2c65" class="kf kg ht bd kh ki kj kk kl km kn ko kp jq kq kr ks ju kt ku kv jy kw kx ky kz dt translated">理解图表</h2><p id="4a55" class="pw-post-body-paragraph jf jg ht jh b ji la jk jl jm lb jo jp jq lc js jt ju ld jw jx jy le ka kb kc hm dt translated">我们在这篇文章开始时展示了一个工人池在<strong class="jh hu"> <em class="kd"> Go </em> </strong>中实现的高层图。它恢复了需要在任何工作池实现中发生的主要操作:</p><ul class=""><li id="e20b" class="lf lg ht jh b ji jj jm jn jq lh ju li jy lj kc lk ll lm ln dt translated">“分配”要处理的资源</li><li id="e917" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated">“工作”(或处理)那些资源</li><li id="f485" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated">并且“收集”结果用于进一步的后处理</li></ul><p id="79fb" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这些操作可以以不同的方式完成，甚至是具有迭代行的单个脚本，但今天我们将在<strong class="jh hu"><em class="kd"/></strong>Go中使用并发和并行设计，以最大化可用的硬件资源，尽可能快地获得结果，并继续向<a class="ae ke" href="https://en.wikipedia.org/wiki/Microservices" rel="noopener ugc nofollow" target="_blank">微服务</a>架构发展的趋势。</p><p id="dba6" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">让我们以更详细的“放大”方式查看每个组件:</p><figure class="lu lv lw lx fq iu fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/c4b2de5048a0f059158ef0ef6dbb14d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*92DJtQvn97l9laNSSgySIw.png"/></div></figure><p id="def6" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">主GoRoutine是正常的程序执行</strong>，在这种情况下，我们的程序没有做什么特别的事情，因为我们关注的是工人池，要执行的唯一具体任务是生成和控制与工人池的正确执行相关的其他go routine</p><figure class="lu lv lw lx fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><figure class="lu lv lw lx fq iu fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/277bfc42cd48f698371f3ea2f1c78a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:236/format:webp/1*sRILIAI_vdePF-I5SeoWHA.png"/></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Boolean Channel “Done”</figcaption></figure><p id="a1ae" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><a class="ae ke" href="https://tour.golang.org/concurrency/2" rel="noopener ugc nofollow" target="_blank">通道</a>“完成”(<code class="eh mb mc md me b">done chan bool</code>)作为主程序控制，表示所有任务已经执行，所有程序已经完成。与“主循环”设计不同，主GoRoutine等待通过此通道发送的信号来停止和结束程序。为什么我们使用一个通道来控制程序的执行并等待所有的程序很容易回答:<strong class="jh hu">简单性</strong></p><figure class="lu lv lw lx fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="b1b1" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在前面的例子中，我们的程序等待继续执行，直到通道变量“done”(<code class="eh mb mc md me b">&lt;-m.done</code>)收到一个值。这使得代码更小，更易于阅读。</p><h2 id="f9de" class="kf kg ht bd kh ki kj kk kl km kn ko kp jq kq kr ks ju kt ku kv jy kw kx ky kz dt translated">分配资源</h2><figure class="lu lv lw lx fq iu fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/68cc92be95d78c79da2fa62f4c6021b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*-ceu-kkvm8ScoZ4qSUA6Aw.png"/></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">“Allocate” goRoutine</figcaption></figure><p id="1bc4" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">“分配”goRoutine是从主goRoutine派生出来的一个子程序，它的目的是<strong class="jh hu">分配将被工人池使用的资源</strong>。它有一个生命周期有限的主循环:直到所有的资源都被分配。为了更好地理解这一点，让我们看一下下图:</p><figure class="lu lv lw lx fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mg"><img src="../Images/bceb2799bbb324e2c58db744ba9b786c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AkEMYppxgaHEvExDQgRGbw.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">“Allocate” goRoutine tasks</figcaption></figure><p id="bf02" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">“<em class="kd">只要有资源可以分配，goRoutine就会继续它的操作</em>”是更好地描述上图的表达方式。分配执行接收一个未知大小的资源数组，并遍历该数组，将其转换为一个结构“作业”,该作业稍后可以由另一个goRountine处理。被转换为“作业”的资源被发送到具有有限大小/维度的缓冲通道“作业”。您可能已经注意到，在示例中，资源数组大于通道中可以缓冲/发送的元素，这是通过设计实现的<strong class="jh hu">，它控制可以同时执行的并行作业的数量</strong>。就是这样，如果“Jobs”通道已满，那么对资源的<strong class="jh hu">迭代将停止</strong>，直到它可以再次在Jobs通道中分配作业。</p><p id="b93f" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">为什么我们将资源转换为渠道工作遵循<a class="ae ke" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"> <strong class="jh hu">关注点分离</strong> </a> <strong class="jh hu">的设计原则。</strong>发送到作业通道的资源将被另一个goRoutine拾取，以进行后续处理，从而将分配限制为仅接收、转换和分配。以下代码代表了所讨论的图表:</p><figure class="lu lv lw lx fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><h2 id="8088" class="kf kg ht bd kh ki kj kk kl km kn ko kp jq kq kr ks ju kt ku kv jy kw kx ky kz dt translated">处理作业通道(待完成的作业)</h2><figure class="lu lv lw lx fq iu fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/0d259ebf75d0d7a359de5fe62302b1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*RnZEbhtvkqEPHl4k7-yBkQ.png"/></div></figure><p id="08a3" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">“工作池”的日常存在是由“作业”通道定义的:只要有作业需要处理，就继续做下去。继续<a class="ae ke" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"> <strong class="jh hu">关注点分离</strong> </a> <strong class="jh hu"> </strong>这个例程的目的是作业的实际处理，并且在大多数情况下，它以并发和并行的方式工作。这是<strong class="jh hu">我们讨论的最关键部分</strong>，因为它涵盖了<strong class="jh hu">工人池</strong>的创建和工作分配。</p><figure class="lu lv lw lx fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mi"><img src="../Images/dc70985b505d221def4b95e1b9ad0129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSAs6yzp2CZrN4rY0Qp6cw.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Worker Pool using Sync.WaitGroup to control spawning new GoRoutines</figcaption></figure><p id="9017" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在这种情况下，工人池goRoutine产生新的“工作”(或“工人”)goRoutine，多少to <a class="ae ke" href="https://gobyexample.com/goroutines" rel="noopener ugc nofollow" target="_blank"> spawn </a>由配置定义或注入到我们的解决方案中，现在让我们将“3”定义为池中工人的数量。任何工作池(或线程池)的一个关键因素是控制池的大小，如果你不这样做，硬件资源很可能会耗尽，甚至你的程序会死锁。</p><p id="3ee2" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们将通过使用<a class="ae ke" href="https://nanxiao.me/en/use-sync-waitgroup-in-golang/" rel="noopener ugc nofollow" target="_blank"> Sync来简化我们的解决方案。WaitGroup </a>基本上是一个结构，我们可以随时询问它，看是否所有的goRoutines都已完成。类似于我们的“Done”通道，<a class="ae ke" href="https://golang.org/pkg/sync/#WaitGroup" rel="noopener ugc nofollow" target="_blank"> WaitGroup </a>包公开了一个<a class="ae ke" href="https://golang.org/pkg/sync/#Cond.Wait" rel="noopener ugc nofollow" target="_blank"> Wait </a>方法，该方法将暂停执行，直到接收到一个值。代码看起来类似于:</p><figure class="lu lv lw lx fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="9d09" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">您可能已经注意到了，同步只是一个原子计数器，我们在每个子例程中递增(<code class="eh mb mc md me b">Add</code>)然后递减(<code class="eh mb mc md me b">Done</code>)。然后，workerPool停止执行，直到满足<code class="eh mb mc md me b">wg.Wait()</code>条件。</p><p id="a105" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">现在让我们看看每个“工作”(或工作者)的实际执行，以便更好地理解所有的同步和作业的实际处理。</p><figure class="lu lv lw lx fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mi"><img src="../Images/b03547f2eefc51036af55a19eb5ee28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6H0OifPErk1Hxzv4I1Esg.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">“Work” goRoutine process</figcaption></figure><p id="06ed" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在WokerPool goRoutine中，我们看到了如何通过调用<code class="eh mb mc md me b">go m.work</code>来创建新的goRoutine，从而在for循环中生成新的“工作”goRoutine。</p><p id="d7a5" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在这个新的goRoutine内部，是作业的实际<strong class="jh hu">处理和分配结果</strong>，为此，每个新的“工作”goRoutine将在通道“作业”上执行一个<code class="eh mb mc md me b">for range jobs</code>循环。这样做的效果是，每个工作例程将获得一个<strong class="jh hu">唯一的</strong>作业，因为Go中实现了使用锁的通道，并确保通道中只有一个项目可以被goRoutine获取，这也定义了“工作”goRoutine的<strong class="jh hu">生存期</strong>:<strong class="jh hu">只要作业通道中有工作要做，就继续迭代</strong>。这种技术可以更好地阅读和理解代码，它隐藏了所有锁定和解锁进程间共享结构的机制。</p><p id="42ab" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">一旦我们从通道“Jobs”中选择了一个作业，我们就处理它并创建一个“Result”对象，然后将它发送到“Results”通道。这是我们采用的<a class="ae ke" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"> <strong class="jh hu">关注点分离</strong> </a> <strong class="jh hu"> </strong>设计的延续，一个“工作”的生命周期由处理一个“作业”和将结果发送到“结果”通道所花费的时间来定义，如果它还没有关闭，它将再次迭代“作业”通道。</p><figure class="lu lv lw lx fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="a2df" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">前面的代码代表了这一章，正如你所看到的，变量<code class="eh mb mc md me b">wg</code> ( <code class="eh mb mc md me b">sync.WaitGroup</code>)作为方法的引用被传递，所以当我们处理完所有的“作业”时，我们可以调用<code class="eh mb mc md me b">wg.Done()</code>让父goRoutine (workerPool)知道这个特定的goRoutine已经完成。</p><p id="5d70" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu"/></p><h2 id="5880" class="kf kg ht bd kh ki kj kk kl km kn ko kp jq kq kr ks ju kt ku kv jy kw kx ky kz dt translated">收集结果</h2><figure class="lu lv lw lx fq iu fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/af9eeb5d78c0406353b9951175ac3f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*ZNZOa8-wu_TVd-NrC7MKbQ.png"/></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">“Collect” goRoutine</figcaption></figure><p id="4954" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">那么，一旦结果被发送到“结果”通道，我们应该做什么呢？答案很简单:<strong class="jh hu">收集，处理，委托结果</strong>。</p><figure class="lu lv lw lx fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mk"><img src="../Images/2f64778ae19bee975ee5fbc595ea1614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AjACyrNcUPelxltqj6Qlcg.png"/></div></div></figure><p id="fd7c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们的缓冲通道“Results”保存了来自所有workers的所有结果，因此我们有一种不同的方法来处理这个“queue”(在本例中，我们只是对它们进行迭代)。关于这个实现的重要部分是<strong class="jh hu">理解处理一个作业与处理它的结果有不同的关注点</strong>。人们可以根据结果采取不同的行动。</p><figure class="lu lv lw lx fq iu"><div class="bz el l di"><div class="ly lz l"/></div></figure><p id="fe3d" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">从前面的代码中很重要的理解了与图表相关的几个因素:</p><ul class=""><li id="6db4" class="lf lg ht jh b ji jj jm jn jq lh ju li jy lj kc lk ll lm ln dt translated"><a class="ae ke" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>再次用于将结果注入到“后处理器”中，这在池上下文之外创建了结果的<strong class="jh hu">委托</strong>，其中注入的函数可以采取不同的动作。<br/>这种类型的签名类似于:<br/> <code class="eh mb mc md me b">type ResultProcessorFunc func(result Result) error</code></li><li id="0e30" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated">我们只是在通道上迭代，<strong class="jh hu">这定义了收集例程</strong>的生命周期。我们可以交换这种方法，创建另一个工作池来加速结果的后处理，但是从设计上来说，这是不必要的，因为在“work”go routines中处理一个“Job”理论上应该比后处理结果花费更多的时间。如果后者对您的设计不满意，这意味着您的结果中可能有许多值得研究的业务逻辑规则，并被转移到“作业”处理中。</li><li id="534a" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated">最后的<code class="eh mb mc md me b">m.done &lt;- true</code>向“Done”通道发出信号，让主goRoutine知道工作池已经完成。</li></ul><h2 id="5bb4" class="kf kg ht bd kh ki kj kk kl km kn ko kp jq kq kr ks ju kt ku kv jy kw kx ky kz dt translated">下一步是什么？</h2><p id="cb5e" class="pw-post-body-paragraph jf jg ht jh b ji la jk jl jm lb jo jp jq lc js jt ju ld jw jx jy le ka kb kc hm dt translated">至此，我们已经在<strong class="jh hu"> Go </strong>中设计、理解并实现了一个完全并发、并行和抽象的工人池。自从信息时代开始以来，为我们的问题解决方案创建<strong class="jh hu">视觉表示和/或图表的实践受到了高度重视。它帮助你抽象、发现模式和机会来改进你的解决方案，并且有希望为更好的文档创造肥沃的土壤。</strong></p><p id="d3c0" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">请随意在此获取完整的代码和一些示例:</p><div class="ml mm fm fo mn mo"><a href="https://github.com/dmora/workerpool" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab ej"><div class="mq ab mr cl cj ms"><h2 class="bd hu fv z el mt eo ep mu er et hs dt translated">dmora/工人池</h2><div class="mv l"><h3 class="bd b fv z el mt eo ep mu er et ek translated">这个小的Go-Lang包实现了工人池模式</h3></div><div class="mw l"><p class="bd b gc z el mt eo ep mu er et ek translated">github.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc iz mo"/></div></div></a></div><blockquote class="nd"><p id="2fb3" class="ne nf ht bd ng nh ni nj nk nl nm kc ek translated">加入Coinmonks <a class="ae ke" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ke" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae ke" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="kf kg ht bd kh ki nn kk kl km no ko kp jq np kr ks ju nq ku kv jy nr kx ky kz dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="lf lg ht jh b ji la jm lb jq ns ju nt jy nu kc lk ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae ke" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated"><a class="ae ke" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae ke" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="6065" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/binance-vs-bitstamp" rel="noopener ugc nofollow" target="_blank">币安vs Bitstamp </a> | <a class="ae ke" href="https://coincodecap.com/bitpanda-coinbase-coinsbit" rel="noopener ugc nofollow" target="_blank"> Bitpanda vs比特币基地vs Coinsbit </a></li><li id="5711" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/buy-ripple-india" rel="noopener ugc nofollow" target="_blank">如何购买瑞波(XRP) </a> | <a class="ae ke" href="https://coincodecap.com/crypto-exchange-africa" rel="noopener ugc nofollow" target="_blank">非洲最好的加密交易所</a></li><li id="861b" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/crypto-exchange-africa" rel="noopener ugc nofollow" target="_blank">非洲最佳加密交易所</a> | <a class="ae ke" href="https://coincodecap.com/hoo-exchange-review" rel="noopener ugc nofollow" target="_blank"> Hoo交易所评论</a></li><li id="452c" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated"><a class="ae ke" href="https://coincodecap.com/etoro-robinhood" rel="noopener ugc nofollow" target="_blank">eToro vs robin hood</a>|<a class="ae ke" href="https://coincodecap.com/bybit-bityard-moonxbt" rel="noopener ugc nofollow" target="_blank">MoonXBT vs by bit vs Bityard</a></li><li id="47a8" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">开发人员的最佳加密API</a></li><li id="b359" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated">最佳<a class="ae ke" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated"><a class="ae ke" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae ke" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="lf lg ht jh b ji lo jm lp jq lq ju lr jy ls kc lk ll lm ln dt translated">杠杆代币的终极指南</li></ul></div></div>    
</body>
</html>