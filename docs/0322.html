<html>
<head>
<title>Serverless application with AWS Lambda and Kotlin. Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS Lambda和Kotlin的无服务器应用程序。第二部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/serverless-application-with-aws-lambda-and-kotlin-part-2-26c06dc62099?source=collection_archive---------3-----------------------#2018-04-18">https://medium.com/coinmonks/serverless-application-with-aws-lambda-and-kotlin-part-2-26c06dc62099?source=collection_archive---------3-----------------------#2018-04-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/69ab82d692a900f89eaaddcf4e1e5c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YOqkpglGAh-5hSZ9vUmzww.png"/></div></div></figure><h1 id="a22f" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">第2部分—第一滴血:Java + Kotlin + AWS Lambda</h1></div><div class="ab cl jz ka hb kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hm hn ho hp hq"><p id="4263" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">本系列文章由4部分组成:</p><ol class=""><li id="1fc7" class="le lf ht ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm dt translated"><a class="ae ln" rel="noopener" href="/@sulevsky/serverless-application-with-aws-lambda-and-kotlin-part-1-62d12ce7d64f">无服务器应用和功能即服务简介</a></li><li id="762f" class="le lf ht ki b kj lo kn lp kr lq kv lr kz ls ld lj lk ll lm dt translated">第一滴血:用Kotlin为AWS Lambda上的Java平台编写函数(你在这里)</li><li id="b72c" class="le lf ht ki b kj lo kn lp kr lq kv lr kz ls ld lj lk ll lm dt translated"><a class="ae ln" rel="noopener" href="/@sulevsky/serverless-application-with-aws-lambda-and-kotlin-part-3-f733511f1326">预热优化:在AWS Lambda上为Node.js平台编写Kotlin函数</a></li><li id="dcb8" class="le lf ht ki b kj lo kn lp kr lq kv lr kz ls ld lj lk ll lm dt translated"><a class="ae ln" rel="noopener" href="/@sulevsky/serverless-application-with-aws-lambda-and-kotlin-part-4-b364f9dfd9cd">使用熟悉的工具:使用AWS Lambda上的Spring Cloud函数为Java平台编写Kotlin函数</a></li></ol><p id="5790" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">这部分系列的目的是展示如何使用Kotlin编程语言在基于Java平台的AWS lambda上创建Lambda函数。</p></div><div class="ab cl jz ka hb kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hm hn ho hp hq"><p id="bb11" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">所有源代码可以从<a class="ae ln" href="https://github.com/sulevsky/aws-lambda-java/tree/master/lambda-kotlin-java" rel="noopener ugc nofollow" target="_blank"> <strong class="ki hu"> Github </strong> </a>下载</p></div><div class="ab cl jz ka hb kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hm hn ho hp hq"><p id="890b" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">创建和测试功能分为5个阶段。</p><ol class=""><li id="748a" class="le lf ht ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm dt translated"><strong class="ki hu">设置项目</strong></li></ol><p id="d7dd" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">为了构建和部署工件，我们将使用Gradle和插件将Lambda函数部署到AWS Cloud。</p><p id="cb6d" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">首先，我们需要建立一个Kotlin项目——添加<code class="eh lt lu lv lw b">kotlin-gradle-plugin</code></p><figure class="lx ly lz ma fq iu"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="9ddd" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">有了这个设置，我们可以编译和测试用Kotlin编写的代码。但是对于部署，我们必须构建一个包含所有依赖项的大容器。使用Gradle插件<code class="eh lt lu lv lw b">com.github.johnrengelman.shadow</code>创建fat jar只需一个命令<code class="eh lt lu lv lw b">gradle shadowJar</code>。</p><figure class="lx ly lz ma fq iu"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="f4e4" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">有了这个设置，我们可以编译和测试用Kotlin编写的代码。但是对于部署，我们必须构建一个包含所有依赖项的大容器。使用Gradle插件<code class="eh lt lu lv lw b">com.github.johnrengelman.shadow</code>创建fat jar只需一个命令<code class="eh lt lu lv lw b">gradle shadowJar</code>。</p><p id="0d93" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">基本上，这足以开始开发和测试我们的应用程序。我们可以创建一个fat jar并手动将其部署到AWS Lambda。但是这种解决方案容易出错，并且需要开发人员的时间，所以我们可以用Gradle脚本来设置deploy以摆脱手工工作。需要两个额外的插件<code class="eh lt lu lv lw b">jp.classmethod.aws</code>和<code class="eh lt lu lv lw b">jp.classmethod.aws.lambda</code> <strong class="ki hu">。用于部署和功能调用的任务易于配置。</strong></p><figure class="lx ly lz ma fq iu"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="5c18" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated"><a class="ae ln" href="https://github.com/sulevsky/aws-lambda-java/blob/master/lambda-kotlin-java/build.gradle" rel="noopener ugc nofollow" target="_blank">完整的格拉德剧本。</a></p><p id="383c" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated"><strong class="ki hu"> 2。</strong> <strong class="ki hu">创建功能</strong></p><p id="4ecb" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">对于这个例子，我们将创建一个简单的函数。它将负责从HTTP请求中读取数据(它需要API网关设置)并将数据存储到S3。当然，这个例子中没有太多的功能，但是它非常适合展示如何引导一个项目。</p><figure class="lx ly lz ma fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff md"><img src="../Images/100b3e1c09dd058e2b356a38f9ca63f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7e08bQhfLTcWuBP6ew3Stw.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">Dataflow</figcaption></figure><p id="553c" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">Kotlin是一种非常简洁的描述性编程语言。并且非常适合函数实现，因为具有强大的方面，如类型检查、可空性，但比Java更具表现力，并且不需要复杂的简单任务的仪式(例如，数据对象的创建是用已经实现了hashCode()、equals()、toString()方法的数据类来完成的，这与Java类不同)。</p><p id="733b" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">对于函数创建，我们必须实现<code class="eh lt lu lv lw b">RequestHandler</code>接口。</p><figure class="lx ly lz ma fq iu"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="b766" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated"><code class="eh lt lu lv lw b">handleRequest()</code>每次从API网关接收到事件时，方法都会执行。</p><p id="da53" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated"><strong class="ki hu"> 3。为功能创建角色</strong></p><p id="2a05" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">为了使函数可以执行，我们需要创建一个具有适当权限的角色，并将该角色分配给一个函数。我们将授予权限:</p><ul class=""><li id="3a14" class="le lf ht ki b kj kk kn ko kr lg kv lh kz li ld mi lk ll lm dt translated">将数据存储到S3(必需)</li><li id="5d60" class="le lf ht ki b kj lo kn lp kr lq kv lr kz ls ld mi lk ll lm dt translated">将日志写入Amazon Cloud Watch(很高兴有这样的功能用于调试)</li></ul><p id="7597" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">在我们的示例中，角色名为<code class="eh lt lu lv lw b">testDemoRole</code>，如果您为角色指定了另一个名称，请相应地更新Gradle脚本。</p><p id="df43" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated"><strong class="ki hu"> 4。部署功能</strong></p><p id="69df" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">对于功能部署，我们必须运行梯度任务部署功能—命令— <code class="eh lt lu lv lw b">gradle deployFunction</code>。是的，很简单。</p><p id="223a" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated"><strong class="ki hu"> 5。测试</strong></p><p id="c583" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">现在我们准备测试功能。第一种选择是用AWS控制台调用函数。登录AWS控制台，在Lambda dashboard中，您可以选择新创建的函数(名称— <code class="eh lt lu lv lw b"><a class="ae ln" href="https://console.aws.amazon.com/lambda/home?region=us-east-1#/functions/lambda-kotlin-java" rel="noopener ugc nofollow" target="_blank">lambda-kotlin-java</a></code>)并测试它。</p><figure class="lx ly lz ma fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mj"><img src="../Images/ec05bdc350cbf7091d2b75123c65ac99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65ceruPubaOs2IXVQLS2ZA.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">Testing Lambda function from AWS console</figcaption></figure><p id="07e1" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">我们必须在基于API Gateway AWS代理模板的控制台中配置测试事件。在<code class="eh lt lu lv lw b">body</code>字段中，我们可以将数据保存在S3上。</p><p id="4d18" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated"><strong class="ki hu"> 4。设置API网关</strong></p><p id="ad67" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">直接函数调用通常用于Lambda通信，但更常见的方法是公开HTTP端点进行通信。API网关的救援！</p><p id="1147" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">我们需要在API Gateway中创建新的API，创建资源，创建方法并使用新的Lambda连接方法。不要忘记标记<strong class="ki hu">使用Lambda代理集成标志</strong>来接收完整的HTTP请求，而不仅仅是主体。</p><figure class="lx ly lz ma fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mk"><img src="../Images/df6c921075e8ab8254c382efc9a3bbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UKQaOu3NTFV_xXMbZU1xXg.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">Setting up API Gateway to invoke Lambda function</figcaption></figure><p id="9538" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">当创建时，系统会询问你是否授予API网关调用Lambda的权限，不要忘记授予API网关调用Lambda的权限。成功创建API后，我们可以测试API GW集成。</p><figure class="lx ly lz ma fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ml"><img src="../Images/3bb9d35ac1609f82cf5b7d4ddc768266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Wi2VStA8S5r748t7SFdbQ.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">Testing Lambda from API Gateway</figcaption></figure><p id="c9ac" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">如果一切设置正确，我们将得到响应代码200-OK，并在S3桶中创建新文件。</p><figure class="lx ly lz ma fq iu fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/918c0f7c0ec66da8d4978484fd9c6d2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*xcdk-HrmvJd43GH9NSQU_Q.png"/></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">Content of file in S3 bucket</figcaption></figure><p id="156e" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">测试后，我们应该部署API和AWS将提供一个调用API的URL。</p><p id="2c98" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated"><strong class="ki hu"> 5。测试设置</strong></p><p id="98cd" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">因此，我们终于可以测试我们简单的无服务器应用程序的完全集成了。</p><p id="ed75" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">为此，我们应该对API网关进行HTTP调用(例如使用Postman ),并检查S3上是否存在具有正确内容的文件。</p><figure class="lx ly lz ma fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mn"><img src="../Images/8dfcb4a7c60ec6a74359befc4f3f8e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l1yySurVHvyX-napBIOlvw.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">Testing Lambda with Postman</figcaption></figure><p id="b24a" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated"><strong class="ki hu">概要:</strong></p><p id="a8aa" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">在本文中，我们构建了最简单的无服务器应用程序。我们使用了:</p><ul class=""><li id="391b" class="le lf ht ki b kj kk kn ko kr lg kv lh kz li ld mi lk ll lm dt translated">用于创建工件以部署到AWS Lambda、部署和Lambda调用的Gradle</li><li id="0040" class="le lf ht ki b kj lo kn lp kr lq kv lr kz ls ld mi lk ll lm dt translated">基于Java平台处理的AWS lambda</li><li id="3594" class="le lf ht ki b kj lo kn lp kr lq kv lr kz ls ld mi lk ll lm dt translated">内部lambda逻辑的Kotlin</li><li id="3d38" class="le lf ht ki b kj lo kn lp kr lq kv lr kz ls ld mi lk ll lm dt translated">API网关作为Lambda的网关，S3作为文件存储</li></ul><p id="59f1" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated"><strong class="ki hu">额外但重要的信息<br/> </strong>我相信在测试Lambda期间，你已经注意到第一次调用比后续调用花费更多的时间——这被称为<strong class="ki hu">冷启动</strong>，它可能相当大。</p><p id="4c06" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">在我对512MB内存和我们刚刚构建的函数的测量中，冷启动通常需要8秒以上。</p><figure class="lx ly lz ma fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mo"><img src="../Images/d7b5afd826582b9cbd86d02f4a4925b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZMSsmwOHUn1t6Ej8tw3asg.png"/></div></div><figcaption class="me mf fg fe ff mg mh bd b be z ek">Lambda execution duration on Java platform, RAM 512MB</figcaption></figure><p id="1fef" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">为了解决这个问题，我们将使用Kotlin编写Lambda函数，但将其部署在Node.js平台上。下一篇文章再见。</p></div></div>    
</body>
</html>