<html>
<head>
<title>Keccak Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">凯克函数</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/keccak-function-5bbb6981bdce?source=collection_archive---------4-----------------------#2020-01-05">https://medium.com/coinmonks/keccak-function-5bbb6981bdce?source=collection_archive---------4-----------------------#2020-01-05</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="f4bd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">SHA是由NSA设计的一系列加密哈希函数，但SHA-0、SHA-1容易受到攻击，因此在2007年，NIST宣布了一项确定SHA-3的竞赛。Keccak团队是2012年比赛的获胜者。2014年，NIST在keccak提交中做了一些更改，并发布了FIPS 202(联邦信息处理标准)，它在2015年成为官方的SHA3。</p><p id="fbee" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">除了加密哈希函数之外，Keccak的其他用途还有身份验证、加密和伪随机数生成。以太坊也使用相同的Keccak算法，但它的协议使用的是该算法的一个版本。</p><p id="fc5b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Keccak函数基于海绵函数。海绵函数基本上提供了一种概括散列函数的特殊方法。它是一个函数，其输入是可变长度的字符串，输出是基于固定长度排列的可变长度。海绵结构由一些术语组成。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/02ac61a20facf2a17862069c109f9adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*ngV3GEPu66CtAUqT.png"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Figure 1: Sponge Construction</figcaption></figure><p id="7f96" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里，</p><p id="10e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">r:rate {写入和读取的状态部分的大小}</p><p id="ccdd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">b:比特块的宽度{由(5×5×w)计算，其中w=pow(2，l)。这里我们取l=6，这使得b=1600}</p><p id="05ef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">c:容量= b-r {输入和输出未触及的状态部分的大小}</p><p id="b238" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">d:输出字符串的长度</p><p id="694b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">n:输入字符串的长度</p><p id="5ad3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">f:置换函数(吸收相)，态转换函数(压缩相)</p><p id="e099" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">z:位串(将组合形成长度为d的输出串)</p><p id="2671" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">z =海绵[f，pad，r](N，d)</p><p id="8691" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">s:由b位组成的状态，由r和c组成</p><h2 id="c31f" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated"><strong class="ak">获得输出的步骤</strong>:</h2><p id="359d" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">在吸收阶段:</p><ol class=""><li id="f1aa" class="la lb ht is b it iu ix iy jb lc jf ld jj le jn lf lg lh li dt translated">假设输入字符串为n。使用填充函数填充输入，并将结果表示为P。我们将输入填充到长度，其中P的长度为n，其中n = length(P)/r以整数形式获得结果。</li></ol><p id="0336" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里，填充函数是10*1模式，即类似于1000…01，其中填充函数的长度可以从0到(r-1)变化。</p><p id="4ce8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2.现在把P分成n个连续的部分。将这些字符串表示为P(0)，P(1)，…，P(N-1)。</p><p id="2966" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3.现在我们将状态S初始化为一串b '0 '位。在这种情况下，它将是1600位。</p><p id="f2f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">4.现在对于每个P(i):</p><p id="a1cd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">I .将c个“0”位加到P(i)上，使P(i)的最终长度为b。</p><p id="8586" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">二。异或(P(i)，S)。</p><p id="8c51" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">三。将块置换函数应用于步骤II。结果是S(新)。</p><p id="50e1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">进入挤压阶段:</p><p id="ccb1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">5.初始化空字符串z。</p><p id="68d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">6.而长度(Z)<d:/></p><p id="2a33" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">I .将S的前r位追加到z。</p><p id="f114" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">二。如果Z<d/></p><p id="d94f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">7.截断Z到d位。</p><p id="eae7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在来看看置换块内部发生了什么。这里使用的函数是SHA3的f= Keccak-f[1600]。它使用由AND、NOT和XOR运算组成的置换。状态是一个5x5xw位的数组，其中w定义为w=power(2，l)。这里我们使用l=6，因此w=1600。所以，我们用1600位作为输入s的长度，设<em class="lj">a</em>[<em class="lj">I</em>[<em class="lj">j</em>[<em class="lj">k</em>]为输入的bit(5<em class="lj">I</em>+<em class="lj">j</em>)×<em class="lj">w</em>+<em class="lj">k</em>。这个块置换函数使用12+2l轮五个步骤。这五步分别是<em class="lj">θ</em>(theta)<em class="lj">ρ</em>(rho)<em class="lj">π</em>(pi)<em class="lj">χ</em>(chi)<em class="lj">ι</em>(iota)。</p><h2 id="b424" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated"><strong class="ak">结论</strong></h2><p id="91ee" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">对原始Keccak算法所做的改变包括填充改变，其允许未来的树散列模式以及当前的SHAKE输出在给定相同的安全参数和消息输入的情况下生成不同的摘要。</p><p id="767f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">快乐学习:)</p></div></div>    
</body>
</html>