<html>
<head>
<title>Ethereum Under The Hood Part 3 (RLP Decoding)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引擎盖下的以太坊第三部分(RLP解码)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethereum-under-the-hood-part-3-rlp-decoding-df236dc13e58?source=collection_archive---------2-----------------------#2021-02-25">https://medium.com/coinmonks/ethereum-under-the-hood-part-3-rlp-decoding-df236dc13e58?source=collection_archive---------2-----------------------#2021-02-25</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/b920e96c9d45a53f7096bba7cf898fef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6cTWRfIlxnSTjyPwPUGlA.png"/></div></div></figure><div class=""/><p id="3b35" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if"> <em class="jz">更新:语法修正</em> </strong></p><p id="8ab3" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="jz">递归链接前缀的Part-3(RLP解码)，</em> <strong class="jd if"> <em class="jz">如果没有经历过Part-1，Part-2，请做</em> </strong> <em class="jz">。在本节中，我们使用</em> <strong class="jd if"> <em class="jz"> RLP解码规范</em> </strong> <em class="jz">解决解码以太坊数据。</em></p><p id="a195" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们简单回顾一下到目前为止我们所学的内容:</p><blockquote class="ka kb kc"><p id="464d" class="jb jc jz jd b je jf jg jh ji jj jk jl kd jn jo jp ke jr js jt kf jv jw jx jy hm dt translated"><em class="ie">以太坊是世界计算机(全局状态+一个虚拟机(VM))。VM可以向全局状态机添加新的状态。状态是块的集合，块包含一组事务。以太坊使用RLP来序列化/反序列化数据。RLP规范只理解两种数据原语(项目、项目列表)。世界状态存储为</em> <a class="ae kg" href="https://github.com/ethereum/wiki/wiki/Patricia-Tree" rel="noopener ugc nofollow" target="_blank"> <em class="ie">以太坊</em> </a> <em class="ie">(注:如果这听起来不熟悉请再读一遍</em> <a class="ae kg" rel="noopener" href="/@deepakraous/ethereum-under-the-hood-part-i-ver-0-1-4f2fb24b3d68"> <em class="ie">部分</em> </a> <em class="ie"> 1。)</em></p></blockquote><p id="afea" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们直接进入主题，<strong class="jd if"> RLP解码</strong>很简单，“解码”是一个花哨的词，意思是我要将这些信息转换成它的原始格式。</p><p id="dbd8" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if"> RLP解码规则:</strong></p><ol class=""><li id="63c3" class="kh ki ie jd b je jf ji jj jm kj jq kk ju kl jy km kn ko kp dt translated">看第一个字节，第一个字节应该落在以下范围之一:<em class="jz"> [ [0x00..0x7f]，[0x80..0xb7]、[0xb8..0xbf ]，[0xc0..0xf7]，[0xf8..0xff] </em> ]如果字节在以下范围内，则使用以下规则解密数据类型:</li></ol><blockquote class="ka kb kc"><p id="8341" class="jb jc jz jd b je jf jg jh ji jj jk jl kd jn jo jp ke jr js jt kf jv jw jx jy hm dt translated"><em class="ie">【0x 00..0x7f]:数据是类型</em> <strong class="jd if"> <em class="ie">字符串</em> </strong> <em class="ie">并且应该按原样解码。</em></p><p id="e978" class="jb jc jz jd b je jf jg jh ji jj jk jl kd jn jo jp ke jr js jt kf jv jw jx jy hm dt translated"><em class="ie">【0x 80..0xb7] : </em> <strong class="jd if"> <em class="ie">字符串</em> </strong> <em class="ie">及其一个</em> <strong class="jd if"> <em class="ie">短</em> </strong> <em class="ie">字符串</em></p><p id="8efb" class="jb jc jz jd b je jf jg jh ji jj jk jl kd jn jo jp ke jr js jt kf jv jw jx jy hm dt translated"><em class="ie">【0xb 8..0xbf ] : </em> <strong class="jd if"> <em class="ie">字符串</em> </strong> <em class="ie">及其一个</em> <strong class="jd if"> <em class="ie">长</em> </strong> <em class="ie">字符串</em></p><p id="ceeb" class="jb jc jz jd b je jf jg jh ji jj jk jl kd jn jo jp ke jr js jt kf jv jw jx jy hm dt translated"><em class="ie">【0xc 0..0xf7] : </em> <strong class="jd if"> <em class="ie">列表</em> </strong> <em class="ie">和</em> <strong class="jd if"> <em class="ie">简称</em> </strong> <em class="ie">列表</em></p><p id="f0f7" class="jb jc jz jd b je jf jg jh ji jj jk jl kd jn jo jp ke jr js jt kf jv jw jx jy hm dt translated"><em class="ie">【0x F8..0xff] : </em> <strong class="jd if"> <em class="ie">列表</em> </strong> <em class="ie">并且是一个</em> <strong class="jd if"> <em class="ie">长</em> </strong> <em class="ie">列表</em></p></blockquote><p id="91b6" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">2.获取字节数组的<strong class="jd if">长度</strong>:</p><p id="2777" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="jz">【第一个字节—字节范围的第一个字节】=数据的长度，例如:</em> <code class="eh kq kr ks kt b"><em class="jz">0x83–0x80 = 3</em></code> <em class="jz">，3是字节数组</em>的长度</p><p id="f92a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">3.重复第一步和第二步，直到字节数组结束。</p><p id="d864" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们举一个简单的例子，将一个字符串<strong class="jd if">“dog”</strong>编码成RLP，如下所示:</p><pre class="ku kv kw kx fq ky kt kz la aw lb dt"><span id="7d06" class="lc ld ie kt b fv le lf l lg lh">"dog" = [<strong class="kt if">0x83</strong>, 0x64, 0x6f, 0x67]</span></pre><figure class="ku kv kw kx fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff li"><img src="../Images/c6c60d170cadcdc45741021d999ef186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2JjSpUYDJqgV7UVUgPJynQ.png"/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek"><a class="ae kg" href="https://www.asciitable.com/" rel="noopener ugc nofollow" target="_blank">Ascii</a> Chart for handy reference</figcaption></figure><p id="69c8" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们<strong class="jd if">按照我们的规则解码</strong>输入，因此给定一个字节数组作为输入</p><p id="7d8c" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kq kr ks kt b"><strong class="jd if">0x83 '</strong><em class="jz">d' 'o' 'g'</em></code></p><ol class=""><li id="c6d2" class="kh ki ie jd b je jf ji jj jm kj jq kk ju kl jy km kn ko kp dt translated">检索第一个字节:<strong class="jd if"> 0x83 </strong></li><li id="1379" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">检查范围是否在设定的指定范围内，在这种情况下，范围在<strong class="jd if"> [0x80..0xb7] </strong>因为第一个字节是<strong class="jd if"> 0x83。</strong></li><li id="56ce" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">计算长度:第一个字节- <strong class="jd if">字节范围内的第一个字节</strong>，<strong class="jd if">0x 83</strong>-<strong class="jd if">0x 80</strong>= 3</li><li id="04b2" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">数据类型为字符串，长度为<strong class="jd if"> 3 </strong></li><li id="874b" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">有了这些事实，解析直到字符串结束:<strong class="jd if"> 0x64，0x6f，0x67 </strong></li></ol><p id="ac86" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们再举一个处理<strong class="jd if">列表的例子；前面的例子是一个简单的数据结构字符串“dog”。解码列表稍微复杂一些；我们需要计算列表的总长度，并用列表破译元素。对于可重复的任务，我们还需要通过使用<a class="ae kg" href="https://en.wikipedia.org/wiki/Recursion#In_computer_science" rel="noopener ugc nofollow" target="_blank">递归</a>技术对列表进行解码，直到结束。</strong></p><p id="5673" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kq kr ks kt b"><strong class="jd if"><em class="jz">[“cat”, “dog” ] -&gt; C8 83</em></strong><em class="jz"> 636174 </em><strong class="jd if"><em class="jz">83</em></strong><em class="jz"> 646F67 </em></code> <em class="jz">，</em>在这里暂停一秒钟，让我们通过看结构来破译。我在这里看到几个项目，这是一个列表，它有两个元素，这些元素的数据类型是一个字符串，解码我们得到的列表<code class="eh kq kr ks kt b"><a class="ae kg" href="https://github.com/ethereum/wiki/wiki/RLP" rel="noopener ugc nofollow" target="_blank"><strong class="jd if"><em class="jz">C8 83 </em></strong><em class="jz">63 61 74 </em><strong class="jd if"><em class="jz">83</em></strong><em class="jz"> 64 6F 67</em></a><em class="jz"> (tip: refer to the ascii chart above)</em></code></p><ol class=""><li id="c288" class="kh ki ie jd b je jf ji jj jm kj jq kk ju kl jy km kn ko kp dt translated">检索第一个字节:<code class="eh kq kr ks kt b"><strong class="jd if">0xc8</strong></code></li><li id="cf17" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">找到第一个字节所在的最近的字节范围；在这种情况下，第一个字节落在范围<code class="eh kq kr ks kt b"><strong class="jd if">[0xc0 .. 0xf7]</strong></code>内，因此数据是一个<strong class="jd if">列表。</strong></li><li id="7b6a" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">创建一个空列表<code class="eh kq kr ks kt b"><strong class="jd if">[]</strong></code> <strong class="jd if"> </strong>进行累加</li><li id="09cd" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">列表长度，[0xc8 -0xc0] = <code class="eh kq kr ks kt b"><strong class="jd if">8</strong></code></li><li id="6aaf" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">开始破译<code class="eh kq kr ks kt b">c8 to get the encoded data from the List until end of List.</code>后</li><li id="b912" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated"><code class="eh kq kr ks kt b"><strong class="jd if"><em class="jz">C8 83</em></strong><em class="jz"> 63 61 74 </em><strong class="jd if"><em class="jz">83</em></strong><em class="jz"> 64 6F 67</em></code></li><li id="a2d8" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">我们知道我们有一个列表[它有八个元素]，现在让我们看看列表里面有什么。</li><li id="a7c5" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">算出长度是:第一个字节范围，<code class="eh kq kr ks kt b"> 0x83–0x80</code> = <code class="eh kq kr ks kt b">3</code></li><li id="1239" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">数据类型为<strong class="jd if">字符串，</strong>，长度为<code class="eh kq kr ks kt b">3</code></li><li id="7c66" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">解析并解密下一个<strong class="jd if"> 3 </strong>字节<code class="eh kq kr ks kt b"><em class="jz">0x63, 0x61, 0x74</em></code></li><li id="c429" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">重复步骤8至11，直到下一组字节的列表结束，结果为<code class="eh kq kr ks kt b"><strong class="jd if">0x83</strong>, 0x64, 0x6f, 0x67</code></li><li id="67bd" class="kh ki ie jd b je ln ji lo jm lp jq lq ju lr jy km kn ko kp dt translated">计算长度并解释数据，在这种情况下，数据是<code class="eh kq kr ks kt b"><strong class="jd if">0x64,0x6f,0x67.</strong></code></li></ol><p id="b72c" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">嗯，所涉及的步骤是可重复的，并且<strong class="jd if"> <em class="jz">递归</em> </strong>将是解码整个字节数组的有用模式。看看实现RLP解码规范的代码框架。<em class="jz">注意下面代码中转换成小数的字节范围。</em></p><figure class="ku kv kw kx fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff ls"><img src="../Images/44587f1dec996499c516318393d2f09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIpxG4jdDazlbBAEYHkhqg.png"/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek"><em class="lt">RLP Decoding </em><a class="ae kg" href="https://github.com/deepakraous/elixir_rlp" rel="noopener ugc nofollow" target="_blank"><em class="lt">Skeleton</em></a><em class="lt"> Code in Elixir</em></figcaption></figure><figure class="ku kv kw kx fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff lu"><img src="../Images/732992977d2cbc2a456cb68843132619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yBIEfARx5fGByFdSh5Jt1g.png"/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">Encoding/Decoding RLP for a Small String.</figcaption></figure><p id="14e6" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我选择Elixir有各种原因，包括它的列表操作和原始数据类型。除此之外，我强烈推荐阅读其他语言中包含的许多示例，请查看下面的参考资料。</p><p id="4c15" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我们结束这一部分之前，我们还需要花一点时间研究一下编码和解码规范。我们学习了处理价值观的RLP。为了检索数据，我们需要一个<strong class="jd if">键</strong>，它提供了一个找到值的路径。因此，让我们快速浏览一下黄皮书中的<a class="ae kg" href="https://ethereum.github.io/yellowpaper/paper.pdf." rel="noopener ugc nofollow" target="_blank">十六进制前缀(附录C) </a>。</p><p id="788b" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">十六进制前缀:</strong></p><p id="f99c" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">用简单的英语来说，把十六进制前缀想象成以太网中给定<strong class="jd if">值</strong>的“路径”的编码/解码机制；这意味着<em class="jz">我知道去这个房子的方法，这是存放房子地图的方法。</em>我认为这是{Key，Value}元组中的“键”,我将整个数据结构设想为:</p><p id="3a85" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kq kr ks kt b">[{key1, value1}, {key2, value2}, {key2, value2} ]</code></p><p id="bef8" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kq kr ks kt b">[ {hp1, rlp1}, {hp2, rlp2}, {hp3, rlp3} ]</code></p><p id="572a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">大概就是这样；我强烈推荐<a class="lv lw gr" href="https://medium.com/u/2d1e5cc8c1db?source=post_page-----df236dc13e58--------------------------------" rel="noopener" target="_blank">phan sơntự</a>T3】medium关于十六进制前缀的帖子，以供进一步参考。在<a class="ae kg" rel="noopener" href="/coinmonks/ethereum-under-the-hood-part-4-the-trie-a3f71f8dbef8"> <strong class="jd if"> Part-4 </strong> </a>中，我们在谈论Trie时将一些片段连接起来，并联系到我们目前所学的内容。再见，直到那时。</p><h1 id="6dcb" class="lx ld ie bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt dt translated">参考资料:</h1><div class="hs ht fm fo hu mu"><a rel="noopener follow" target="_blank" href="/codechain/test-4245f1fd1bb3"><div class="mv ab ej"><div class="mw ab mx cl cj my"><h2 class="bd if fv z el mz eo ep na er et id dt translated">代码链序列化</h2><div class="nb l"><h3 class="bd b fv z el mz eo ep na er et ek translated">我们都知道每个区块链都需要序列化和反序列化块。块存储在磁盘上，然后发送…</h3></div><div class="nc l"><p class="bd b gc z el mz eo ep na er et ek translated">medium.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ia mu"/></div></div></a></div><div class="hs ht fm fo hu mu"><a href="https://www.badykov.com/elixir/2018/05/06/rlp/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab ej"><div class="mw ab mx cl cj my"><h2 class="bd if fv z el mz eo ep na er et id dt translated">Elixir中以太坊的递归长度前缀编码</h2><div class="nb l"><h3 class="bd b fv z el mz eo ep na er et ek translated">本周，我们在Mana项目，重写了以太坊的递归长度前缀(RLP)编码的实现，所以现在…</h3></div><div class="nc l"><p class="bd b gc z el mz eo ep na er et ek translated">www.badykov.com</p></div></div><div class="nd l"><div class="nj l nf ng nh nd ni ia mu"/></div></div></a></div><div class="hs ht fm fo hu mu"><a rel="noopener follow" target="_blank" href="/coinmonks/data-structure-in-ethereum-episode-1-compact-hex-prefix-encoding-12558ae02791"><div class="mv ab ej"><div class="mw ab mx cl cj my"><h2 class="bd if fv z el mz eo ep na er et id dt translated">以太坊中的数据结构。第1集+:压缩(十六进制前缀)编码。</h2><div class="nb l"><h3 class="bd b fv z el mz eo ep na er et ek translated">在第一集，我们讨论了RLP编码/解码，然而以太坊还有另一种编码叫做压缩…</h3></div><div class="nc l"><p class="bd b gc z el mz eo ep na er et ek translated">medium.com</p></div></div><div class="nd l"><div class="nk l nf ng nh nd ni ia mu"/></div></div></a></div><div class="hs ht fm fo hu mu"><a href="https://ethereum.stackexchange.com/questions/12941/in-the-ethereum-modified-merkle-particia-tree-what-do-the-prefix-key-and-value/12942#12942" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab ej"><div class="mw ab mx cl cj my"><h2 class="bd if fv z el mz eo ep na er et id dt translated">在以太坊改进的Merkle-Particia树中，前缀、键和值表示什么？</h2><div class="nb l"><h3 class="bd b fv z el mz eo ep na er et ek translated">黄皮书的附录D在定义节点类型时指出(斜体是我的):Leaf:一个两项结构，其…</h3></div><div class="nc l"><p class="bd b gc z el mz eo ep na er et ek translated">ethereum.stackexchange.com</p></div></div><div class="nd l"><div class="nl l nf ng nh nd ni ia mu"/></div></div></a></div><div class="hs ht fm fo hu mu"><a href="https://github.com/ethereum/wiki/wiki/Patricia-Tree" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab ej"><div class="mw ab mx cl cj my"><h2 class="bd if fv z el mz eo ep na er et id dt translated">以太坊/维基</h2><div class="nb l"><h3 class="bd b fv z el mz eo ep na er et ek translated">维基——以太坊维基</h3></div><div class="nc l"><p class="bd b gc z el mz eo ep na er et ek translated">github.com</p></div></div><div class="nd l"><div class="nm l nf ng nh nd ni ia mu"/></div></div></a></div></div></div>    
</body>
</html>