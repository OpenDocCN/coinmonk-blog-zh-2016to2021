<html>
<head>
<title>Crypto Cheque! Introduction to Message Signing in Ethereum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加密支票！以太坊中的消息签名介绍</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/crypto-cheque-introduction-to-message-signing-in-ethereum-1d14c8c42e21?source=collection_archive---------0-----------------------#2019-07-30">https://medium.com/coinmonks/crypto-cheque-introduction-to-message-signing-in-ethereum-1d14c8c42e21?source=collection_archive---------0-----------------------#2019-07-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/59744ede721c8224fe4a3e0848734e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r1ScUIlGBrMyKZNPc5KIlA.jpeg"/></div></div></figure><p id="1093" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">假设我想授权我的朋友在未来的某个时间从我的银行账户中提取预定金额的钱。我们通过使用支票来完成这项工作。我只需写下金额、收款人、日期，然后在交给我的朋友之前签名，朋友再把钱存入银行以换取资金。在实践中，支票被认为是一种欠条，作为一种更通用的支付形式，而不是直接交钱。支票也预先刻有全息金箔和热敏墨水等元素，作为安全措施。每张支票都是独一无二的，就像钞票一样:它们无法复制。</p><p id="c65e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">支票很重要，原因有很多，但它与以太坊中的签名消息有什么关系呢？尽管消息签名是一种多功能的工具，但让我们把它想象成等同于签发支票的加密货币。用支票做类比，明显的相似和不同之处就显现出来了。我们通过软件输入收款人/金额/标牌的详细信息，而不是写在纸上。最显著的区别是标记的方法，这涉及到使用以太坊私人钱包密钥而不是钢笔签名。还值得注意的是，这一过程将中介从一个可以在幕后拖延、扣留或冻结资金的私人实体(银行)转变为一个智能合同，该合同以书面代码的形式基于一组预先确定的规则释放资金。</p><blockquote class="jz ka kb"><p id="a8ee" class="jb jc kc jd b je jf jg jh ji jj jk jl kd jn jo jp ke jr js jt kf jv jw jx jy hm dt translated">这是金钱的未来，我们今天就要建造它。</p></blockquote><p id="7824" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是一个入门到中级教程。先决条件是对坚实、松露和NodeJS的基本理解。在本教程中，强烈建议在键入代码时跟随，而不是复制+粘贴。这个过程有助于减缓思维，让它能够吸收正在发生的事情。如果你实际上是一个<a class="ae kg" rel="noopener" href="/coinmonks/introduction-to-solidity-programming-and-smart-contracts-for-complete-beginners-eb46472058cf">完全初学者</a>，一定要看看我以前的面向完全初学者的教程。继续前进…</p><h1 id="eb2f" class="kh ki ht bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated"><strong class="ak">设置环境</strong></h1><ol class=""><li id="92af" class="lf lg ht jd b je lh ji li jm lj jq lk ju ll jy lm ln lo lp dt translated">确保安装了NodeJS。将以下内容复制并粘贴到您的终端中:</li></ol><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="cac4" class="lz ki ht lv b fv ma mb l mc md">brew install node</span></pre><p id="43e4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">2.创建一个新的项目目录并输入它。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="a901" class="lz ki ht lv b fv ma mb l mc md">mkdir message_signing<br/>cd message_signing</span></pre><p id="3f30" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">3.确保您安装了<a class="ae kg" href="https://code.visualstudio.com/download" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a>或您喜欢的文本编辑器。在编辑器中打开项目。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="94ca" class="lz ki ht lv b fv ma mb l mc md">code .</span></pre><p id="78a0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">4.在你的机器上全局安装Truffle并初始化一个新项目。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="ce77" class="lz ki ht lv b fv ma mb l mc md">npm install -g truffle<br/>truffle init</span></pre><p id="907d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">5.创建一个<code class="eh me mf mg lv b">index.js</code>文件。这将保存用于签署消息的javascript代码。进入合同目录并创建<code class="eh me mf mg lv b">cheque.sol</code>。这将是智能合同，它验证签名的消息并向收款人释放资金。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="a4f9" class="lz ki ht lv b fv ma mb l mc md">touch index.js<br/>cd Contracts<br/>touch Cheque.sol<br/>cd ..</span></pre><p id="888b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">6.创建package.json文件并安装web3。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="8215" class="lz ki ht lv b fv ma mb l mc md">npm init -y <br/>npm install web3 </span></pre><p id="4417" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">7.安装并打开<a class="ae kg" href="https://www.trufflesuite.com/docs/ganache/quickstart" rel="noopener ugc nofollow" target="_blank"> Ganache </a>。这是一个模仿真实以太网行为的私人区块链。它将作为我们部署合同的平台。</p><p id="e3ec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您的文件夹结构应该如下所示:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="4648" class="lz ki ht lv b fv ma mb l mc md">/message_signing<br/>    /contracts<br/>        Migrations.sol<br/>        Cheque.sol</span><span id="9d7e" class="lz ki ht lv b fv mh mb l mc md">    /migrations<br/>        1_initial_migrations.js</span><span id="936c" class="lz ki ht lv b fv mh mb l mc md">    /test</span><span id="393e" class="lz ki ht lv b fv mh mb l mc md">    index.js<br/>    package.json<br/>    truffle-config.js</span></pre><p id="0b9a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我们开始之前，整个计划总结如下:</p><ol class=""><li id="f506" class="lf lg ht jd b je jf ji jj jm mi jq mj ju mk jy lm ln lo lp dt translated">付款人通过使用他们的以太坊私钥签署消息来预先授权支付。</li><li id="36a1" class="lf lg ht jd b je ml ji mm jm mn jq mo ju mp jy lm ln lo lp dt translated">付款人部署智能合同，向收款人发送所需的乙醚量。</li><li id="3b05" class="lf lg ht jd b je ml ji mm jm mn jq mo ju mp jy lm ln lo lp dt translated">付款人通过期望的媒介(例如电子邮件)将签名的消息发送给收款人。</li><li id="2109" class="lf lg ht jd b je ml ji mm jm mn jq mo ju mp jy lm ln lo lp dt translated">收款人通过向智能合同提交签名的消息来要求付款，智能合同验证真实性并释放资金。</li></ol><h1 id="f557" class="kh ki ht bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">书写支票合同</h1><ul class=""><li id="40f7" class="lf lg ht jd b je lh ji li jm lj jq lk ju ll jy mq ln lo lp dt translated">警告:这一部分相当复杂，所以请密切注意。每个代码块将被彻底解释，以确保正确的理解。</li><li id="7007" class="lf lg ht jd b je ml ji mm jm mn jq mo ju mp jy mq ln lo lp dt translated">对于那些感兴趣的人，这里是这个项目的github链接。</li></ul><p id="472b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">头撞向<code class="eh me mf mg lv b">Cheque.sol</code>，写着:</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="af2d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里发生了一些事情。</p><p id="152d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第1行</strong>声明了Solidity版本，这是每个智能合约的标准。要找出你的编译器使用的是哪一个版本的Solidity，</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="87bc" class="lz ki ht lv b fv ma mb l mc md">truffle version</span></pre><p id="a4b4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在终端应该输出:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="4fbf" class="lz ki ht lv b fv ma mb l mc md">Truffle v5.0.0 (core: 5.0.0)<br/>Solidity v0.5.0 (solc-js)<br/>Node v11.13.0</span></pre><p id="4282" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在本例中，我们使用的是v0.5.0。</p><p id="bfda" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第3行</strong>创建存储随机数有效性的映射。随机数用于防止重放攻击，在重放攻击中，接收者可以多次重新提交相同的签名并提取资金。付款人将把这个随机数嵌入要签名的消息中。</p><p id="5691" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第4行</strong>声明了一个公共变量<code class="eh me mf mg lv b">owner</code> <em class="kc">。</em>用于跟踪部署合同的付款人的地址。它的唯一目的是根据消息恢复函数的结果进行验证，该函数将返回签名者的公钥。如果钥匙与<code class="eh me mf mg lv b">owner</code>匹配，资金将被释放。</p><p id="2ac5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第5–7行</strong>损害了构造函数。它被标记为<code class="eh me mf mg lv b">payable</code>，因此我们可以在部署它时将以太网发送到合同。这是我们为将来提款预授权的金额。部署后，它将<code class="eh me mf mg lv b">owner</code>设置为部署者的以太坊地址。</p><p id="a03d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我们将编写第一个函数:</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="5fe7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第11行</strong>实例化<code class="eh me mf mg lv b">splitSignature</code>。它接受一个参数<code class="eh me mf mg lv b">sig</code>，该参数代表签署消息的所有者/付款人产生的签名。这是一个效用函数，只能在合同中执行，如<code class="eh me mf mg lv b">internal</code>所示。此外，它不会修改合同的状态，因此不会花费任何额外的天然气，如<code class="eh me mf mg lv b">pure</code>所示。简单来说，没有变量被修改，这只是一个简单的计算。</p><p id="b195" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以太坊使用<a class="ae kg" rel="noopener" href="/coinmonks/ecdsa-the-art-of-cryptographic-signatures-d0bb254c8b96">椭圆曲线数字签名算法</a>来方便数字签名。每个ECDSA签名由三个参数r、s和v组成。该函数的目的是将签名分解为这三个部分，并返回它们以在恢复函数中使用，从而确定原始签名地址——稍后将详细介绍。</p><p id="c138" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第12行</strong>确保签名长度为65字节。如果不是，则不是有效的签名。</p><p id="7ef2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第14-16行</strong>声明<code class="eh me mf mg lv b">r</code>、<code class="eh me mf mg lv b">s</code>和<code class="eh me mf mg lv b">v</code>。<code class="eh me mf mg lv b">r</code>和<code class="eh me mf mg lv b">s</code>是固定长度32字节数组的形式。<code class="eh me mf mg lv b">v</code>采取基本整数的形式。</p><p id="7b5c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第18–25行是主要功能出现的地方。这里，我们使用内联汇编将签名分解成3个部分。如代码注释所示，<code class="eh me mf mg lv b">r</code>由签名的前32个字节组成，<code class="eh me mf mg lv b">s</code>由后32个字节组成，<code class="eh me mf mg lv b">v</code>由最后一个字节(后32个字节的第一个)组成，总共65个字节。</p><p id="8cbc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第27行</strong>返回3个组件。</p><p id="739f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">概括地说，<code class="eh me mf mg lv b">splitSignature</code>将一个签名作为输入，将它分解成它的组成部分，并将它们作为输出值返回。下一个帮助器函数将使用它来返回原始签名者的钱包地址:</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="de4c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第30行</strong>创建<code class="eh me mf mg lv b">recoverSigner</code>，接受2个参数。</p><ol class=""><li id="33bd" class="lf lg ht jd b je jf ji jj jm mi jq mj ju mk jy lm ln lo lp dt translated"><code class="eh me mf mg lv b">message</code>是由所有者/支付者创建的原始散列消息，我们将很快演示。</li><li id="2c8f" class="lf lg ht jd b je ml ji mm jm mn jq mo ju mp jy lm ln lo lp dt translated"><code class="eh me mf mg lv b">sig</code> <strong class="jd hu"> </strong>是<strong class="jd hu"/><strong class="jd hu"/>所有人/付款人签署消息时创建的签名。</li></ol><p id="97b4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">就像<code class="eh me mf mg lv b">splitSignature</code>一样，这是一个不修改契约状态的内部效用函数。这个函数的目的是发现签署消息的个人的钱包地址，并将其返回用于另一个函数。</p><p id="fbd3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第31–33行</strong>声明变量<code class="eh me mf mg lv b">r</code>、<code class="eh me mf mg lv b">s</code>和<code class="eh me mf mg lv b">v</code>，就像<code class="eh me mf mg lv b">splitSignature</code>一样。</p><p id="d0cf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第35行</strong>将<code class="eh me mf mg lv b">r</code>、<code class="eh me mf mg lv b">s</code>和<code class="eh me mf mg lv b">v</code>赋值给<code class="eh me mf mg lv b">splitSignature</code> <strong class="jd hu">的返回值。</strong></p><p id="990c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第37行</strong>用结果<code class="eh me mf mg lv b">r</code>、<code class="eh me mf mg lv b">s</code>和<code class="eh me mf mg lv b">v</code>值以及<code class="eh me mf mg lv b">message</code>参数调用<code class="eh me mf mg lv b">ecrecover</code>。<code class="eh me mf mg lv b">ecrecover</code>是一种全球可用的可靠性方法，用于确定散列消息的签名地址，给定散列消息本身和分成3个部分的签名。</p><p id="edd4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">概括地说，<code class="eh me mf mg lv b">recoverSigner</code>接收原始的散列消息和签名，将签名送入<code class="eh me mf mg lv b">splitSignature</code>，捕获返回值并将其与散列消息一起送入<code class="eh me mf mg lv b">ecrecover</code>，以获得原始签名地址。</p><p id="1c82" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第40行</strong>是我们智能合约的最后一个效用函数<code class="eh me mf mg lv b">prefixed</code>。我们一直在谈论“散列信息”，但这到底是什么意思呢？当拥有者/支付者创建消息时，它必须通过以太坊常用的散列算法<code class="eh me mf mg lv b">keccak256</code>(以前称为SHA3)，然后才能被签名。这个函数接受这个散列作为输入参数，并将其转换成一个“带前缀的”散列，然后输入到<code class="eh me mf mg lv b">recoverSigner</code>。</p><blockquote class="jz ka kb"><p id="edc8" class="jb jc kc jd b je jf jg jh ji jj jk jl kd jn jo jp ke jr js jt kf jv jw jx jy hm dt translated">以太坊中的所有交易都使用<a class="ae kg" href="https://github.com/ethers-io/ethers.js/blob/master/utils/rlp.js" rel="noopener ugc nofollow" target="_blank">递归长度前缀</a> (RLP)编码。不需要深入了解RLP的细节，开头的<code class="eh me mf mg lv b">\x19</code>是一个事务开始时故意设置的无效字节。这可以防止应用程序欺骗您对看似消息，但实际上是伪装的事务进行签名。<code class="eh me mf mg lv b">Ethereum Signed Message:\n</code>使消息的内容可读。</p></blockquote><ul class=""><li id="05d5" class="lf lg ht jd b je jf ji jj jm mi jq mj ju mk jy mq ln lo lp dt translated">感谢<a class="ae kg" href="https://blog.ricmoo.com/@ricmoo" rel="noopener ugc nofollow" target="_blank"> RicMoo </a>发表的关于数字签名的<a class="ae kg" href="https://blog.ricmoo.com/verifying-messages-in-solidity-50a94f82b2ca" rel="noopener ugc nofollow" target="_blank">文章</a>！</li></ul><p id="27aa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关于支票合同的最后一部分:</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="8172" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第44行</strong>为<code class="eh me mf mg lv b">claimPayment</code>，将作为<code class="eh me mf mg lv b">public</code>表示的合同的切入点。这意味着该函数可以(在我们的例子中将会)从契约(我们的javascript代码)之外被调用。它接受3个参数:</p><ol class=""><li id="1d38" class="lf lg ht jd b je jf ji jj jm mi jq mj ju mk jy lm ln lo lp dt translated"><code class="eh me mf mg lv b">amount</code>是业主/付款人约定的交易金额。</li><li id="1606" class="lf lg ht jd b je ml ji mm jm mn jq mo ju mp jy lm ln lo lp dt translated"><code class="eh me mf mg lv b">nonce</code>是由拥有者/支付者提供的随机数，他/她将该随机数嵌入到消息中。</li><li id="1e38" class="lf lg ht jd b je ml ji mm jm mn jq mo ju mp jy lm ln lo lp dt translated"><code class="eh me mf mg lv b">sig</code>是签名消息产生的签名。</li></ol><p id="b3a9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第45号线将乙醚提供的<code class="eh me mf mg lv b">amount</code>转化为魏。以太坊智能合约总是以卫为单位读取以太量。1乙醚= 1e18卫。更多关于面额的信息请点击。</p><p id="12b4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第46–47行</strong>确保提供的<code class="eh me mf mg lv b">nonce</code>尚未被使用。如果提供的<code class="eh me mf mg lv b">nonce</code>有效，它会将其标记为在下次调用该函数时使用。</p><p id="6fd2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第49行</strong>负责重新创建所有人/付款人发出的信息。该消息包括:</p><ol class=""><li id="df1a" class="lf lg ht jd b je jf ji jj jm mi jq mj ju mk jy lm ln lo lp dt translated"><code class="eh me mf mg lv b">msg.sender</code> <strong class="jd hu"> </strong> —接收者(呼叫者)的以太坊地址</li><li id="3813" class="lf lg ht jd b je ml ji mm jm mn jq mo ju mp jy lm ln lo lp dt translated"><code class="eh me mf mg lv b">amountWei</code> —业主/付款人提交的商定金额</li><li id="f0d1" class="lf lg ht jd b je ml ji mm jm mn jq mo ju mp jy lm ln lo lp dt translated"><code class="eh me mf mg lv b">nonce</code> —在功能参数中提供</li><li id="52d4" class="lf lg ht jd b je ml ji mm jm mn jq mo ju mp jy lm ln lo lp dt translated"><code class="eh me mf mg lv b">this</code> —合同地址。这对于防止重放攻击是必要的，在重放攻击中，创建一个新的契约实例(清除旧的随机数),使收款人能够再次调用<code class="eh me mf mg lv b">claimPayment</code>。在新创建的合同中，所有者将拒绝引用旧地址的所有签名。</li></ol><p id="2df9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上述4个参数被封装在<code class="eh me mf mg lv b">abi.encodePacked</code>中，它将信息转换为“紧密封装”形式的字节。查看<a class="ae kg" rel="noopener" href="/@libertylocked/what-are-abi-encoding-functions-in-solidity-0-4-24-c1a90b5ddce8">这篇</a>文章，了解有关abi功能的更多信息。</p><p id="8d0a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后使用<code class="eh me mf mg lv b">keccak256</code>(以前称为SHA3)函数对这些数据进行哈希处理。哈希以<code class="eh me mf mg lv b">prefixed</code> <strong class="jd hu"> </strong>为前缀，存储为<code class="eh me mf mg lv b">message</code>。此时，消息已准备好用于签名者恢复。</p><p id="8360" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第51行是整个合同的关键。它以<code class="eh me mf mg lv b">message</code>和<code class="eh me mf mg lv b">signature</code>为参数调用<code class="eh me mf mg lv b">recoverSigner</code> <strong class="jd hu"> </strong>，并将返回值(一个地址)与契约的<code class="eh me mf mg lv b">owner</code>进行比较。如果这两个地址匹配，我们可以确定付款人已经批准调用这个函数并提取资金。</p><p id="12d0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第53行</strong>简单地将<code class="eh me mf mg lv b">amountWei</code>转移到函数调用方/收款方的地址。</p><h1 id="070f" class="kh ki ht bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">创建和签名邮件</h1><p id="c92b" class="pw-post-body-paragraph jb jc ht jd b je lh jg jh ji li jk jl jm mt jo jp jq mu js jt ju mv jw jx jy hm dt translated">现在，我们已经完成了我们专业编写的智能合同，让我们创建我们可以验证的签名消息。</p><p id="3b6a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">打开<code class="eh me mf mg lv b">index.js</code>并键入以下内容:</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="2534" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第1–2行导入<strong class="jd hu"> </strong> Web3并使用我们的私有Ganache区块链创建一个实例。这允许我们使用Ganache上的帐户来签署消息和调用函数。Web3还包含实用函数，其中一个我们将用来签署我们的消息。在第2行，<strong class="jd hu"> </strong> <code class="eh me mf mg lv b">localhost:8545</code>是指Ganache正在使用的地址和端口，可以在RPC SERVER下查看。(本地主机= 127.0.0.1)</p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mw"><img src="../Images/7c40df58b38a496f27f61282cac4f767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YWv6937m9Kdk1be6Ta9nDQ.png"/></div></div></figure><p id="9405" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第5行</strong>使用NodeJs <code class="eh me mf mg lv b">fs</code>(文件系统)模块检索由Truffle在迁移时创建的JSON契约表示。我们将很快详细介绍这一点。</p><p id="4a1f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第6行解析JSON，这样我们的程序就可以读取它了。</p><p id="50b2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第7行</strong>从JSON中提取合同地址并存储为<code class="eh me mf mg lv b">contractAddress</code>。</p><p id="c8fe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第9行</strong>声明支付签名功能<code class="eh me mf mg lv b">signPayment</code>。它接受<code class="eh me mf mg lv b">recipient</code>(收款人)地址和约定的<code class="eh me mf mg lv b">amount</code>。它被标记为<code class="eh me mf mg lv b">async</code>，所以我们可以利用Javascript的async/await模式来异步检索数据。</p><p id="f9ad" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第10行</strong>使用web3检索与给定区块链(Ganache)关联的所有账户，并将它们存储在一个列表中，如<code class="eh me mf mg lv b">accounts</code></p><p id="aefb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第11行</strong>将列表中的第一个账户分配给<code class="eh me mf mg lv b">payer</code>。</p><p id="5996" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第12行</strong>检索给定地址(<code class="eh me mf mg lv b">payer</code>)的交易计数。我们将把它作为随机数嵌入到我们的消息中。</p><p id="bcf7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第13行</strong>使用web3的<code class="eh me mf mg lv b">soliditySha3()</code>散列函数来创建我们消息的散列。我们的消息包含<code class="eh me mf mg lv b">recipient</code>(收款人)、<code class="eh me mf mg lv b">amount</code>、<code class="eh me mf mg lv b">txCount</code> (nonce)和合同地址(<code class="eh me mf mg lv b">contractAddress</code>)。这个特殊的散列函数在可靠性方面模仿了<code class="eh me mf mg lv b">keccak256()</code>函数的行为。</p><p id="a0d0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">线15 &amp; 18 </strong>为试/抓块。代码将尝试执行<code class="eh me mf mg lv b">try</code>块的内容，如果失败，返回到<code class="eh me mf mg lv b">catch</code>块。这种语法对于async/await模式很有用，因为与承诺相比，它没有固有的错误捕获功能。</p><p id="c53f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第16行</strong>使用来自一个Ganache帐户的私钥对我们创建的消息哈希进行签名。用来自Ganache中第一个帐户的实际私钥替换<code class="eh me mf mg lv b">&lt;GANACHE_PRIVATE_KEY&gt;</code>。通过单击帐户框右侧的钥匙图标来检索它。</p><p id="d6de" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">* *重要:</strong>在代码中粘贴私钥后，确保在前面加上<code class="eh me mf mg lv b">0x</code>，否则程序不会将其识别为有效密钥。示例:<code class="eh me mf mg lv b">0x6efc5ffc3ec7609736a2299a4a80e8f4377039b947c310ffa6f9ddf7a1fd5398</code></p><p id="edb8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">值得注意的是，<code class="eh me mf mg lv b">web3.eth.accounts.sign</code>在签名前会自动给消息加上前缀<code class="eh me mf mg lv b"><em class="kc">\x19Ethereum Signed Message:\n </em></code>。如果我们使用另一种签名方法，比如<code class="eh me mf mg lv b">web3.eth.sign</code>，我们必须手动添加前缀。查看<a class="ae kg" href="https://web3js.readthedocs.io/en/1.0/web3-eth.html" rel="noopener ugc nofollow" target="_blank">文档</a>了解这些方法之间差异的更多信息。</p><p id="0261" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh me mf mg lv b">web3.eth.accounts.sign</code>的输出值是一个包含签名的对象，我们稍后将对其进行研究。</p><p id="7677" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第17行</strong>将<code class="eh me mf mg lv b">amount</code>、<code class="eh me mf mg lv b">txCount</code>、&amp;、<code class="eh me mf mg lv b">sigObject</code>输出到控制台，以便我们在与合同交互时使用它们。</p><p id="8309" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第23行</strong>用Ganache列表上的第二个地址(收款人)和发送金额调用<code class="eh me mf mg lv b">signPayment</code>。只需从ganache复制+粘贴地址。第二个参数是金额(<code class="eh me mf mg lv b">10e18</code>)。记住，【魏】= 1以太，同我们在契约中所写的一样。</p><p id="789c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在终端中，运行:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="3e80" class="lz ki ht lv b fv ma mb l mc md">node index.js</span></pre><p id="f594" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">输出应该如下所示:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="f2ed" class="lz ki ht lv b fv ma mb l mc md">100000000000000 4 {<br/>    message:<br/>    [170,<br/>        80,<br/>        21,<br/>        140,<br/>        32,<br/>        200,<br/>        163,<br/>        173,<br/>        111,<br/>        250,<br/>        155,<br/>        168,<br/>        13,<br/>        9,<br/>        72,<br/>        192,<br/>        32,<br/>        64,<br/>        156,<br/>        14,<br/>        40,<br/>        109,<br/>        210,<br/>        180,<br/>        50,<br/>        126,<br/>        191,<br/>        205,<br/>        93,<br/>        137,<br/>        29,<br/>        30],<br/>        messageHash: '0xb6d4e6021a8eece755ee78881bb64a8ad35777f868ec6ceed13fbfb91f7ae9c6,<br/>        v: '0x1c',<br/>        r: '0xe94a8699fec3b955192921925a7a2d5aeeeca15af05e010f0633fef296a054a9,<br/>        s: '0x6a2fef0e41c9f150564f4e7c4f476dcdcc75605580f0c8ac39885a806d07b924,<br/>        signature: '0xe94a8699fec3b955192921925a7a2d5aeeeca15af05e010f0633fef296a054a96a2fef0e41c9f150564f4e7c4f476dcdcc75605580f0c8ac39885a806d07b9241c'<br/>}</span></pre><p id="b05b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">前两个数字是<code class="eh me mf mg lv b">amount</code>和<code class="eh me mf mg lv b">nonce</code>(事务计数)，它们对于验证消息签名者很重要。</p><p id="3e4e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">签名对象不仅包括我们将使用的底部的<code class="eh me mf mg lv b">signature</code>，还包括一些其他有趣的数据。还记得在我们的智能契约中，我们是如何将签名分成<code class="eh me mf mg lv b">v</code>、<code class="eh me mf mg lv b">r</code>和<code class="eh me mf mg lv b">s</code>部分的吗？这些是上面输出的相同组件。我们还可以看到不同格式的<code class="eh me mf mg lv b">message</code>和<code class="eh me mf mg lv b">messageHash</code>。</p><h1 id="6b32" class="kh ki ht bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">要求付款</h1><p id="9b4c" class="pw-post-body-paragraph jb jc ht jd b je lh jg jh ji li jk jl jm mt jo jp jq mu js jt ju mv jw jx jy hm dt translated">现在，我们已经创建了支票合同，并作为付款人签署了一条消息以批准提款，让我们部署合同并与之交互，以作为收款人要求付款。</p><p id="1f3a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，打开位于项目根目录的<code class="eh me mf mg lv b">truffle-config.js</code>。删除文件内容，并用以下内容替换:</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="5b78" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这种配置是必要的，以便Truffle知道当我们部署智能合约时使用哪个区块链网络。在这里，我们建立了一个名为<code class="eh me mf mg lv b">development</code>的网络，虽然名字很简单。<code class="eh me mf mg lv b">host</code>和<code class="eh me mf mg lv b">port</code>直接来自Ganache。由于这是我们唯一合作的网络，当我们部署智能合约并与之交互时，Truffle将默认使用它。</p><p id="2649" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，在<code class="eh me mf mg lv b">migrations</code>目录下创建一个名为<code class="eh me mf mg lv b">2_cheque.js</code>的新文件。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="6d1e" class="lz ki ht lv b fv ma mb l mc md">cd migrations<br/>touch cheque.js<br/>cd ..</span></pre><p id="3faf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">打开它并键入:</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="f0c7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">1号线</strong>使用Truffle Artifactor导入智能合约。这将原始实体转换为Truffle可以读取的JSON表示。</p><p id="17a4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">第3–5行</strong>使用Truffle Deployer将契约实例部署到Ganache，它在幕后处理一切。<code class="eh me mf mg lv b">{value: 1e18 }</code>表示作为参数传递给部署的元数据。在这种情况下，它是我们以卫的形式发送到合同中的乙醚量。</p><p id="99cb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">回想一下我们是如何在契约中将构造函数标记为<code class="eh me mf mg lv b">payable</code>的。这允许在调用构造函数时，在部署时将以太发送到协定。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="c2cd" class="lz ki ht lv b fv ma mb l mc md">constructor() public payable {<br/>  owner = <em class="kc">msg</em>.sender;<br/>}</span></pre><p id="fec9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们已经设置了配置和部署设置，是时候玩我们的新玩具了。在控制台中，键入以下内容:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="e6a6" class="lz ki ht lv b fv ma mb l mc md">truffle migrate </span></pre><p id="9be8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这个命令告诉Truffle完成两件事:</p><ol class=""><li id="a717" class="lf lg ht jd b je jf ji jj jm mi jq mj ju mk jy lm ln lo lp dt translated">将原始实体编译成JSON可读的契约表示。使用<code class="eh me mf mg lv b">truffle compile</code>作为别名。</li><li id="c348" class="lf lg ht jd b je ml ji mm jm mn jq mo ju mp jy lm ln lo lp dt translated">根据我们提供的配置，将JSON抽象部署到网络上。目前，Truffle将默认使用列表中的第一个地址在我们的<code class="eh me mf mg lv b">development</code> (Ganache)网络上部署这个契约，使用1e18 Ether。使用<code class="eh me mf mg lv b">truffle deploy</code>作为别名。</li></ol><p id="4818" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">运行该命令后，打开Ganache。注意列表中的第一个帐户余额是如何下降的。差额是部署成本+我们发送给合同的金额。</p><p id="276c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您还会注意到在项目根目录下创建的包含JSON文件的新目录<code class="eh me mf mg lv b">build</code>。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="3701" class="lz ki ht lv b fv ma mb l mc md">truffle console</span></pre><p id="f683" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">打开默认网络的松露控制台(<code class="eh me mf mg lv b">development</code>)。这是一个javascript运行时环境，包含Truffle使用的模块。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="4858" class="lz ki ht lv b fv ma mb l mc md">let app;<br/>Cheque.deployed().then((instance) =&gt; {<br/>  app = instance<br/>})</span></pre><p id="dbb7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里，我们将<code class="eh me mf mg lv b">app</code>分配给我们已部署的<code class="eh me mf mg lv b">Cheque</code>实例。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="5bb7" class="lz ki ht lv b fv ma mb l mc md">let accounts;<br/>web3.eth.getAccounts().then((result) =&gt; {<br/>  accounts = result<br/>})</span></pre><p id="299a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这将使用web3作为数组从Ganache检索帐户，并将它们分配给<code class="eh me mf mg lv b">accounts</code>。尝试在控制台中运行<code class="eh me mf mg lv b">accounts</code>，您将看到输出列表:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="4d67" class="lz ki ht lv b fv ma mb l mc md">[ '0x2642269FCDDbB58f76124b7f4a98Df93E99ae803',<br/>  '0xd09D4cF222ef0B4D5623815aE9a01682a1d17E88',<br/>  '0x66e0249709b4dD1A30Ab3E18cBcb6F944a95d48b',<br/>  '0xe15bcb2964339dF76341cAF10977F84CBd036ef1',<br/>  '0xa485b07b9C149757acA6c0B29F051fAAe84364f0',<br/>  '0x5bC383FB28F52a4aE42c5b4caD682163c0FE0654',<br/>  '0x8a8da609576A3Bd1ab6018285Ef1F020467F9ECB',<br/>  '0xebe47e36F5343e733917bd652d156B0005d2eb50',<br/>  '0x6A3C002BC49A1fE1a895a152CeF3c29831E8d46b',<br/>  '0xae9086C3A251D55bd5491E1Af1898608a788F263' ]</span></pre><p id="8f24" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，我们将作为合法收款人要求付款:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="dd61" class="lz ki ht lv b fv ma mb l mc md">app.claimPayment(1, NONCE, SIGNATURE, {from: accounts[1]})</span></pre><p id="2336" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因为我们将部署的契约实例存储在app中，所以我们可以用它来调用它的函数。这里，我们称<code class="eh me mf mg lv b">claimPayment</code>为收款人。<code class="eh me mf mg lv b">1</code>参数是指乙醚中的量。这里用Ether表示，因为智能合约负责将其转换回Wei。将<code class="eh me mf mg lv b">NONCE</code>替换为<code class="eh me mf mg lv b">txCount</code>输出，将<code class="eh me mf mg lv b">SIGNATURE</code>替换为<code class="eh me mf mg lv b">sig</code>输出，均来自运行<code class="eh me mf mg lv b">index.js</code>。<code class="eh me mf mg lv b">{from: accounts[1]}</code>告诉程序使用<code class="eh me mf mg lv b">accounts</code>列表中的第二个地址作为函数的调用者(收款人！).您应该会看到如下输出:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="4f75" class="lz ki ht lv b fv ma mb l mc md">{ tx:<br/>   '0xb5e6703667cdb222fecdbb23c9be1515f2553e00a092b0968393a51d0be15a9e,<br/>  receipt:<br/>   { transactionHash:<br/>      '0xb5e6703667cdb222fecdbb23c9be1515f2553e00a092b0968393a51d0be15a9e,<br/>     transactionIndex: 0,<br/>     blockHash:<br/>   '0xf888af1ad05caefd17a8b3c1f4d1e1449b58b65f4ad1453b519bacba22fc68ee,<br/>     blockNumber: 5,<br/>     gasUsed: 60691,<br/>     cumulativeGasUsed: 60691,<br/>     contractAddress: null,<br/>     logs: [],<br/>     status: true,<br/>     logsBloom:<br/>      '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',<br/>     rawLogs: [] },<br/>  logs: [] }</span></pre><p id="a3af" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，如果我们看一下Ganache，第一个帐户被扣除1.02 ETH(部署成本+发送的ETH)，第二个帐户被记入1 ETH，用于要求付款。</p><figure class="lq lr ls lt fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mx"><img src="../Images/29478381b7095558374e4c1f6a1e35ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L3fwW2WbOF-W6QXH9BiyrQ.png"/></div></div></figure><p id="1fb1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">恭喜你！如果你坚持到现在，你已经学会了如何在以太坊上创建一张智能支票！</p><p id="4e49" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在现实世界中，付款人会发送</p><p id="a341" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">🎉🎉敬请关注更多教育文章。关于如何编写以太坊区块链的完整视频课程也即将推出！🎉🎉</p><blockquote class="my"><p id="f333" class="mz na ht bd nb nc nd ne nf ng nh jy ek translated"><a class="ae kg" href="https://coincodecap.com/?utm_source=coinmonks" rel="noopener ugc nofollow" target="_blank">在您的收件箱中直接获得最佳软件交易</a></p></blockquote><figure class="nj nk nl nm nn iu fe ff paragraph-image"><a href="https://coincodecap.com/?utm_source=coinmonks"><div class="fe ff ni"><img src="../Images/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*OJ-qb5G6i863msBB.png"/></div></a></figure></div></div>    
</body>
</html>