# 天秤座(LBR)——快速介绍

> 原文：<https://medium.com/coinmonks/libra-quick-introduction-6ce2c51d703c?source=collection_archive---------4----------------------->

## Libra 的使命是建立一个简单的全球货币和金融基础设施，为数十亿人提供支持。

**假设**。以下文章要求对比特币协议有基本的了解。

![](img/d922ca24e000f1c660853bd021415c3f.png)

天秤座是脸书提出的一个被允许的区块链。天秤座于 2019 年 6 月 18 日正式宣布成立。

# 属性、术语、定义

*   出生于~2019 年
*   目前，该项目是一个原型
*   快速[技术白皮书](https://developers.libra.org/docs/assets/papers/the-libra-blockchain.pdf)
*   Microlibra =最小数量的 LBR，即 10^-6(即与[比特币](https://blog.coincodecap.com/tag/bitcoin/)中的 Satoshi 概念相同)
*   1 个微资料库= 0.000001 磅(10^−6)
*   分类帐版本(没有块，只有交易)
*   [Rust](https://github.com/libra/libra) 用于实现服务器
*   [RocksDB](https://rocksdb.org/) 用作其物理存储引擎
*   无固定供应
*   10 秒完成交易
*   吞吐量高达每秒 1000 笔交易(1000 tx/s 与 Visa 的 50k tx/s 相比)
*   可信验证器集
*   稳定币
*   共识算法:[Libra bft](https://developers.libra.org/docs/assets/papers/libra-consensus-state-machine-replication-in-the-libra-blockchain.pdf)(hot stuff 和 [BFT](https://en.wikipedia.org/wiki/Byzantine_fault) 的变种)
*   基于帐户的数据模型
*   [移动](https://developers.libra.org/docs/assets/papers/libra-move-a-language-with-programmable-resources.pdf)(智能合同语言)

# 介绍

Libra 建立在安全、可伸缩和可靠的区块链之上。它由旨在赋予其内在价值的资产储备支持，并由独立的 Libra 协会管理，该协会的任务是发展生态系统。Libra 区块链是一个加密认证的分布式数据库，它基于 Libra 协议。Libra 协议的核心是两个基本概念— **事务**和**状态**。在任何时间点，[区块链](https://blog.coincodecap.com/tag/blockchain/)都有一个“状态”状态(或分类帐状态)表示链上数据的当前快照。执行事务会改变区块链的状态。Libra 区块链的分类帐状态或全局状态由区块链中所有账户的状态组成。

![](img/b775d76d314bf0228507a3d6b433b144.png)

Figure 1\. An example global state with three accounts.

Libra Blockchain 是一个去中心化、可编程的数据库，旨在支持一种低波动性的加密货币，这种货币将有能力成为全球数十亿人的高效交易媒介。Libra 协议实现了 Libra [区块链](https://blog.coincodecap.com/tag/blockchain/)，旨在创建一个能够促进创新、降低准入门槛、改善金融服务获取的金融基础设施。Libra 协议允许来自不同机构的一组复制品(称为验证器)共同维护可编程资源的数据库。这些资源由经过公钥加密验证的不同用户帐户所拥有，并且遵守这些资源的开发人员指定的自定义规则。验证器处理事务并相互交互，以就数据库的状态达成共识。交易是基于预定义的，在未来的版本中，用户定义的[智能合约](https://blog.coincodecap.com/tag/smart-contact/)使用一种新的编程语言 Move。

Libra 区块链中的所有数据都存储在一个版本化的数据库中。版本号是一个无符号的 64 位整数，对应于系统已经执行的事务数量。在每个版本 *i* ，数据库包含一个元组 *(Ti，Oi，Si)* ，表示交易 *(Ti)* ，交易输出 *(Oi)* ，以及分类帐状态 *(Si)* 。系统中每个执行的事务都是确定的。Libra 协议使用 Move 语言来实现确定性执行功能。

> 也可阅读:[天秤座货币——脸书的加密货币](https://blog.coincodecap.com/libra-currency-a-cryptocurrency-by-facebook/)

一个版本在区块链文学中也被称为“高度”。**Libra 区块链没有明确的区块概念**——它只使用区块来批处理和执行交易。高度为 0 的事务是第一个事务(起源事务)，高度为 100 的事务是事务存储中的第 101 个事务。

![](img/99ba183b946485bc63b19e4db6b511b6.png)

Figure 2\. Transactions Change State

# 账户

Libra 协议使用基于帐户的数据模型。Libra 帐户是移动模块和移动资源的容器。它由帐户地址来标识。这实质上意味着每个账户的状态由代码和数据组成:

*   移动**模块**包含代码(类型和过程声明)，但不包含数据。一个模块的程序编码了更新[区块链](https://blog.coincodecap.com/tag/blockchain/)全局状态的规则。
*   移动**资源**包含数据，但不包含代码。每个资源值都有一个在区块链分布式数据库中发布的模块中声明的类型。

![](img/b3b3e7d8a73a18923e8cd725a0edd721.png)

Figure 3\. An example ledger state with four accounts.

一个帐户可以包含任意数量的移动资源和移动模块。

# 地址

Libra 帐户的地址是一个 256 位的值。用户可以使用数字签名来声明地址。帐户地址是用户公共验证密钥的加密散列。Libra 用户可以申请的地址数量没有限制。Account 被视为访问路径到字节数组值的有序映射。

# 交易

天秤座[区块链](https://blog.coincodecap.com/tag/blockchain/)的客户通过提交交易来更新账本状态。在高层次上，一个事务由一个事务脚本(用 Move 字节码编写)和事务脚本的参数(例如，一个接收者帐户地址或要发送的 Libra 号)组成。

![](img/94dbdeacb846924db0c8aa39ebdae7d2.png)

Figure 4\. The flow of a write transaction through the internal components of Libra Core.

**交易输出**

执行交易 *Ti* 产生新的分类帐状态 *Si* 以及执行状态代码、气体使用和事件列表(在输出 *Oi* 中汇总)。事件列表是执行事务产生的一组副作用。移动代码可以通过事件结构触发事件发射。每个事件都与一个唯一的键和一个有效负载相关联，唯一的键标识发出事件所通过的结构，有效负载提供关于事件的详细信息。事务执行没有外部影响。

当提交交易时，用户支付交易费。该费用的唯一目的是在系统负载高于规定负载时减少需求(例如，由于拒绝服务攻击)。费用由两个因素决定:气价和气费。

**交易结构**是包含以下数据的签名消息:

*   **汇款人地址**:交易汇款人的账户地址。虚拟机从 *LibraAccount 中读取序列号、认证密钥和余额。存储在该地址下的资源。*
*   **发送方公钥**:对应于用于签署交易的私钥的公钥。该公钥的散列必须与发送方的 *LibraAccount 下存储的认证密钥相匹配。T* 资源。
*   **程序**:要执行的移动字节码事务脚本，脚本输入的可选列表，以及要发布的移动字节码模块的可选列表。
*   **气价**:发送方为了执行这笔交易，愿意支付的每单位气的天秤币数量。
*   **最大用气量**:交易停止前允许消耗的最大用气量。
*   **序列号**:无符号整数，必须等于发送方 *LibraAccount 中的序列号。T* 资源。该事务执行后，序列号增加 1。因为对于给定的序列号，只能提交一个事务，所以事务不能重放。

一旦一个事务命中 VM 组件，它将按照六个步骤进行验证。

1.  检查签名。
2.  运行序言。序言验证交易发送者，确保发送者有足够的 Libra 硬币来支付交易中指定的最大数量的 gas 单位，并检查该交易不是先前交易的重演。
3.  验证交易脚本和模块。
4.  发布模块。
5.  运行事务脚本。
6.  运行尾声。最后，VM 运行交易尾声，向用户收取所用的汽油费用，并增加发送者的账户序列号。

# 分类帐历史

分类帐历史记录的目的是记录最新的分类帐状态是如何计算的。**分类账历史**中没有交易块的概念。然而，在逻辑数据模型中，事务按顺序发生，而不区分哪个块包含每个事务。

所有验证者必须同意系统的初始或起源分类帐状态。系统的初始状态表示为空状态。然后通过一个特殊的事务 *T0* 创建起源状态，该事务定义了要创建的特定模块和资源，而不是通过正常的事务处理。客户端和验证器被配置为只接受以特定的*到*开始的分类账历史。

# 移动

“Move”是一种新的编程语言，用于在 Libra 区块链上实现定制交易逻辑和“智能合约”。由于 Libra 的目标是有一天服务数十亿人，Move 的设计以安全和保障为最高优先级。主要的移动设计目标是:一流的资产、灵活性、安全性和可验证性。用资产进行编程的健壮而优雅的方法需要保留这些特征的表示。

Move 在系统中有三个重要角色:

1.  通过交易脚本实现灵活的交易。
2.  允许用户定义的代码和数据类型，包括通过模块的“智能合同”。
3.  支持 Libra 协议的配置和可扩展性。

![](img/3dafbc5787a608ad4e7f484c8ebd577a.png)

Figure 5\. Peer-to-Peer Payment Transaction Script.

Move 的关键特性是能够用受线性逻辑启发的语义定义自定义资源类型:资源永远不能被复制或隐式丢弃，只能在程序存储位置之间移动。这些安全保证由 Move 的类型系统静态实施。

此外，对资源类型 T 的关键操作只能在定义 T 的模块内部执行。

Move 通过事务脚本增加了 Libra 的灵活性。每个 Libra 事务都包含一个事务脚本，它实际上是事务的主要过程。

理想情况下，我们会通过链上字节码分析或运行时检查来检查移动程序的每个安全属性。不幸的是，这是不可行的。我们必须仔细权衡安全保证的重要性和一般性，以及通过链上验证实施保证的计算成本和增加的协议复杂性，例如，类型系统确保资源永远不会被复制、重用或丢失。

Move 是静态验证友好的，即:

1.  **没有动态调度**。每个调用点的目标可以静态确定。这使得验证工具无需执行复杂的调用图构造分析就可以很容易地精确推断过程调用的效果。
2.  **有限可变性**。移动值的每个变化都是通过引用发生的。引用是临时值，必须在单个事务脚本的范围内创建和销毁。Move 的字节码验证器使用类似 Rust 的“借用检查”方案来确保在任何时间点至多存在一个对值的可变引用。此外，该语言确保全局存储始终是一棵树，而不是一个任意的图形。这允许验证工具模块化关于写操作效果的推理。
3.  **模块化**。移动模块执行数据抽象，并将资源上的关键操作本地化。模块启用的封装与移动类型系统实施的保护相结合，确保为模块类型建立的属性不会被模块外部的代码破坏。我们希望这种设计能够通过孤立地看待一个模块而不考虑它的客户来实现对重要模块不变量的详尽的功能验证。

Move，继 Rust 和 C++之后，实现了 move 语义。每次读取移动变量 *x* 时，必须指定是将 *x* 的值移出变量(使 *x* 不可用)还是复制该值(使 *x* 可供继续使用)。像 u64 和 address 这样不受限制的值可以被复制和移动。但是资源价值只能移动。试图复制资源值(例如，使用 copy(coin))将在字节码验证时导致错误。

资源安全禁止其他模块复制、破坏或双重移动资源。

Move 的目标是使程序员能够定义全局区块链状态，并安全地实现更新全局状态的操作。

未来的 Move 源语言和 Move IR 都被编译成 Move 字节码，这是 Libra 协议使用的格式。

该协议通过字节码验证强制执行 Move 的所有安全保证来避免信任编译器:类型安全、引用安全和资源安全。

Move 模块与[以太坊](https://blog.coincodecap.com/tag/ethereum/)和其他区块链平台中的“智能合约”概念相关，但并不相同。以太坊[智能合约](https://blog.coincodecap.com/tag/smart-contact/)包含在分类帐状态下发布的代码和数据。在 Libra 中，模块包含代码值，资源包含数据值。

物理资产有两个难以在数字资产中编码的属性:

*   **稀缺性**。应该控制系统中的资产供应。应该禁止复制现有资产，创建新资产应该是特权操作。
*   **门禁**。系统中的参与者应该能够通过访问控制策略来保护自己的资产

Move 中 Libra 协议的重要部分，包括 Libra coin、交易处理和验证器管理都是在 Move 中实现的。

# Merkle 树

Libra [区块链](https://blog.coincodecap.com/tag/blockchain/)中的所有数据都存储在单一版本的分布式数据库中。该存储用于持久保存一致同意的事务块及其执行结果。区块链被描绘成一棵不断增长的交易 Merkle 树。对于在区块链上执行的每个事务，将“叶子”附加到树中。具体来说，分类帐历史使用 Merkle 树累加器方法来形成 Merkle 树，这也提供了高效的追加操作。

![](img/9b1d8d9150ef68f6d8e09c0a6e972cd4.png)

# 共识；一致

验证器节点是 Libra 生态系统中的实体，它们共同决定哪些交易将被添加到 Libra 区块链中。使用的共识算法是 LibraBFT，这是一个为 Libra 区块链设计的健壮、高效的状态机复制系统。LibraBFT 基于 HotStuff，这是一种最新的协议，利用了拜占庭容错(BFT)方面几十年的科学进步，实现了互联网设置所需的强大可扩展性和安全属性。LibraBFT 进一步细化了 HotStuff 协议，引入了显式的活跃度机制，并提供了具体的延迟分析。只要一致性协议确保事务之间的总顺序，并且状态转换方案是确定的，组件就可以和谐地交互。

![](img/ccecfa82058ebed3c680a961699880df.png)

Figure 6\. Overview of the LibraBFT protocol (simplified, excluding round synchronization).

LibraBFT 提供了以下对分散信任至关重要的关键属性:

*   安全:LibraBFT 保持诚实验证者之间的一致性，即使有三分之一的验证者是腐败的。
*   **异步**:即使在网络异步的情况下，也能保证一致性(例如，在无限制的通信延迟或网络中断期间)。这反映了我们的信念，即构建其安全性依赖于同步性的互联网规模的共识协议本质上既复杂又容易受到网络上的拒绝服务(DoS)攻击。
*   **终结性** : LibraBFT 支持终结性的概念，即一个事务变得不可逆转。它提供了向最终用户验证分类账查询结果的简明承诺。
*   线性度和响应度 : LibraBFT 有两个可取的特性，是 HotStuff 之前的 BFT 共识协议无法同时支持的——线性度和响应度。这两个技术概念与领导者的概念相关联，领导者是推动进步对抗部分同步的关键方法。非正式地说，线性保证了即使领导者轮换，驱动事务提交也只会导致线性通信(这是最佳的)；响应性意味着领导者没有内置的延迟步骤，只要从验证者那里收集到响应就可以前进。
*   **简单性和模块化**:Libra bft 的核心逻辑允许简单而健壮的实现，与基于 Nakamoto consensus 的公共区块链相类似。值得注意的是，该协议是围绕单个通信阶段组织的，并允许简明的安全论证。
*   **可持续性**:目前的公共区块链，信任是基于计算能力，据报道消耗了大量的能源，并可能受到集中。LibraBFT 被设计为一个利益相关证明系统，在该系统中，根据已知成员的财务参与情况授予他们参与特权。LibraBFT 可以支持经济激励，以奖励良好的行为和/或惩罚利益相关者的错误行为。LibraBFT 中的计算成本主要由加密签名组成，这是一个高效实现的标准概念。

Lamport 等人提出的解决方案的安全性依赖于同步性，这是实际系统希望避免的一种依赖性，这既是因为复杂性，也是因为它使系统在安全性上暴露于 DoS 攻击。LibraBFT 利用 HotStuff，并拥有上述四十年工作中取得的许多好处。

状态机复制(SMR)协议旨在提供分布在网络上的抽象状态机，并在许多进程(也称为节点)之间复制。历史上，容错协议旨在解决常见的故障，如崩溃。在区块链的情况下，SMR 共识协议用于限制系统中单个节点的功率。

**领袖、回合、阻止、投票**

验证器从客户端接收事务，并通过共享内存池协议相互共享。LibraBFT 是一个按轮进行的共识协议，在每一轮中，在验证者中选择一个领导者。LibraBFT 属于基于领导者的共识协议家族。在基于领导者的协议中，节点按轮进行，每轮有一个指定的节点称为领导者。领导者负责提出新的命令，并从提案的其他节点获得签名，称为投票。LibraBFT 遵循 HotStuff 的链式变体，其中一轮是与单个指定领导者的通信阶段，领导者提案使用加密哈希组织成一系列块。

当前的共识协议最初将支持**至少 100 个验证器**，并且能够随着时间的推移发展到支持 500–1000 个验证器。Libra 协议的初始启动应该支持**每秒 1，000 笔支付交易**，交易提交和提交之间有 **10 秒的结束时间**。

网络层被设计成通用的，并从 libp2p 项目中汲取灵感。它目前提供了两个主要接口:(1)远程过程调用(RPC)和(2) DirectSend，它实现了向单个接收者发送一劳永逸式的消息。

验证器间网络被实现为对等系统，使用多地址方案进行对等体寻址，使用 TCP 进行可靠传输，使用 Noise 进行认证和完整的端到端加密，使用 Yamux 在单个连接上多路复用子流，使用 push 风格的 gossip 进行对等体发现。每个新的子流被分配一个发送方和接收方都支持的协议。每个 RPC 和 DirectSend 类型对应一个这样的协议。

Libra 团队考虑到并行化和分片，选择了协议的元素。计算授权码的稀疏 Merkle 树方法允许在多台机器上分割数据库(这增加了容量)或并行处理更新(这增加了吞吐量)。

我们的目标是让 Libra 区块链完全不受限制。为了做到这一点，该团队计划逐步过渡到利害关系证明。

# 验证器节点

Libra 区块链的客户端创建交易，并将其提交给验证器节点。验证器节点运行一致协议(与其他验证器节点一起)，执行事务，并将事务和执行结果存储在区块链中。验证器节点决定将哪些事务添加到区块链中，以及添加的顺序。

![](img/8c467d9546dd882be03dc76e08a36804.png)

Figure 7\. Overview of the Libra protocol and of a validator node.

验证器节点的逻辑组件是:准入控制、内存池、共识、执行、虚拟机和存储。存储模块使用 RocksDB 作为其物理存储引擎。准入控制组件是客户端与节点通信的入口。

![](img/f4b1d277787501646c6ce5e847e856b4.png)

Figure 8\. Logical components of a validator node.

# 系统结构

在更高的层次上，我们可以描述如下图所示的系统架构(即图 9)。

网络描述了一个协议，该协议使验证者能够按照共识的要求安全地相互通信。网络组件在 [Actor](https://en.wikipedia.org/wiki/Actor_model) 编程模型中实现——也就是说，它使用消息传递在作为独立“任务”运行的不同子组件之间进行通信使用 [tokio](https://tokio.rs/) 框架作为任务运行时。

![](img/63fecc14113ec6909e9b1c0d54d0928b.png)

Figure 9\. System Architecture.

# 天秤座协会

该协会的作用是:

*   管理技术的发展。虽然开源结构有助于推动关于 Libra 核心和 Libra 协议的日常技术决策，但 Libra 协会理事会为项目的治理提供了一个框架。理事会作为一个检查机构，确保开源社区做出的决策与 Libra 生态系统整体保持一致。
*   定义开源治理过程。开源决策过程将随着项目社区的发展而发展。
*   定义如何提议、讨论和接受变更。在早期阶段，随着技术的成熟，快速开发会过渡到更正式的过程。

Libra 被设计成一种货币，任何用户都知道 Libra 今天的价值将接近其明天和将来的价值。储备是实现保值的关键机制。通过储备，每一枚硬币都有一套稳定和流动的资产作为充分支持。

最初，Libra 区块链只向创始成员授予投票权，这些实体:(1)满足一组预定义的创始成员资格标准，以及(2)向项目投入一定金额。这些规则有助于确保拥有一个安全、有效的验证器集的安全性要求。使用创始成员资格标准可确保创始成员是拥有良好声誉的组织，使他们不太可能恶意行事，并建议他们将努力保护其验证器免受外部攻击。

# 结论

关于协议的内部还有很多要说的。目前，该项目只是一个原型，目前的设计可能会随着时间的推移而改变，实施起来更加困难。简而言之，Libra 协议是一个分布式数据库，它使用 Merkle 树数据结构来存储状态，通过提交事务，您可以更改状态，通过使用 Move 语言可以定制事务语义，通过使用 BFT 共识算法来维护参与者之间的状态一致性。

**免责声明**。本文的图片和文本是官方学术论文和开发人员文档的有序和略微修改的拼贴。

# 参考

*   https://developers.libra.org/docs/reference/glossary
*   【https://libra.org 
*   [https://github.com/libra/libra](https://github.com/libra/libra)
*   [https://www.calibra.com/](https://www.calibra.com/)

最后修改日期:2020 年 1 月 29 日

> [直接在您的收件箱中获得最佳软件交易](https://coincodecap.com/?utm_source=coinmonks)

[![](img/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png)](https://coincodecap.com/?utm_source=coinmonks)[![](img/e9dbce386c4f90837b5db529a4c87766.png)](https://coincodecap.com)