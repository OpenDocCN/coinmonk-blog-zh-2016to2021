# 探索作为参与者的智能合同

> 原文：<https://medium.com/coinmonks/exploring-smart-contracts-as-actors-eee23499a59d?source=collection_archive---------2----------------------->

智能合约背后的[并发](https://blog.coincodecap.com/tag/cryptocurrency/)模型到目前为止已经有很多方面的讨论和分析。在 2017 年发表的一篇漂亮的[论文](https://arxiv.org/pdf/1702.05511.pdf)中，Ilya Sergey 和 Aquinas Hobor 探索了智能合约和共享内存并发之间的相似之处。在 Medium 上发表的另一篇[文章](/spadebuilders/actor-factor-2b0005fde786)中，Brooklyn Zelenka 做了同样的事情，使用演员模型作为比较术语。

在这篇文章中，我将继续 Brooklyn 的想法，并进一步探索[智能契约](https://blog.coincodecap.com/tag/smart-contact/)和 actors 之间的差异和相似之处，重点关注这两种方法的类型安全性。

![](img/97b81c32ea5caf394c0e0ba75a98b318.png)

Photo by [Nick Youngson](http://www.nyphotographic.com/) on [Picpedia](https://www.picpedia.org/highway-signs/p/protocol.html)

# 演员模型的简短说明

卡尔·休伊特、彼得·毕晓普和理查德·施泰格在 1973 年发表的一篇论文中首次将演员模型理论化:

> “Actor Model 受到高度并行计算
> 机器前景的推动，这些机器由数十、数百甚至数千个独立的
> 微处理器组成，每个微处理器都有自己的本地存储器和通信处理器，T10 通过高性能通信网络进行通信。”
> 卡尔·休伊特

**演员和物体很相似。因此，它们可能拥有也可能不拥有内部状态(可能是可变的或不可变的)并公开方法来与之交互和修改它。然而，与对象不同的是，这样的方法不能被直接调用。事实上，与演员互动的唯一方式是向其发送信息。**

**参与者模型中的消息有四个主要特征:**

*   **它们是**异步**(即发送方不阻塞等待响应)；**
*   **它们是**不可变的**(即发送后不可修改)；**
*   **它们被放入 actor 的邮箱，这个邮箱只是一个待处理消息的队列；**
*   **actor 一次检查其邮箱中的一条消息，并在其线程中进行处理。**

**这四个特征确保不会发生竞争情况。事实上，消息是交互和修改参与者内部状态的唯一方式。然而，由于这种消息是由参与者本身一次处理一个(在一个线程中)，所以不可能出现争用情况(除非将状态的引用作为消息的参数传递，在这种情况下，参与者将失去对其状态的控制)。**

**最后，参与者和线程之间没有一一对应的关系。事实上，演员只是从池中“借用”线程。**

# **智能合同和参与者**

## **一点术语**

***智能合同*是使用[区块链](https://blog.coincodecap.com/tag/blockchain/)平台来执行特定操作的应用程序，例如在不依赖可信第三方实体的情况下交换信息或金钱。**

**智能契约非常像面向对象编程范式中的一个类，因此，它有一个状态并公开一组函数。调用函数是“激活”一个[智能契约](https://blog.coincodecap.com/tag/smart-contact/)的唯一方式，通常发生在事务的上下文中。**

## **并行的观点**

**乍一看，智能合同和参与者有许多相似之处:**

*   **状态突变是消息/事务的结果；**
*   **消息被序列化，一次处理一条消息；**
*   **消息是不可变的；**
*   **需要一个地址来与一个演员或一个合同进行交互，并且地址是唯一的；**
*   **参与者和契约可以决定如何处理一个消息，可能会拒绝它；**
*   **它们都可以产生新的参与者/合同；**
*   **他们都必须被杀死和再生，以修复他们行为中的错误。不过，对于合约来说，这就更加微妙了，因为它们也需要保持平衡。**

**然而，也有一些显著的差异:**

*   **一个智能契约很可能公开它的状态，任何引用它的其他契约都可以很容易地修改它的状态。这通常是通过生成状态变量`public`来完成的；**
*   **契约有一种平衡，必须小心处理，以免招致不愉快的情况(读道)；**
*   **默认情况下，参与者是并发和异步的，而智能合约不是(在一个事务中)。这意味着只有第一次函数调用(发起事务的那个)是异步运行的，但是从那时起，该事务中发生的任何函数调用都将是同步的；**
*   **联系到前面的要点，参与者系统中的事务边界是单个参与者。这对于智能契约来说是不正确的，因为一个事务可以跨越不同契约的多次调用；**
*   **事务和状态变化保证在[区块链](https://blog.coincodecap.com/tag/blockchain/)中持久化(对于智能契约)，然而对于参与者来说这可能不是真的；**
*   **智能合约的执行，在[以太坊](https://blog.coincodecap.com/tag/ethereum/)被所谓的 gas 所束缚。**

**正如我们刚刚看到的，actors 和 smart contracts 在处理传入消息的方式上非常相似，但是在并发行为和保持内部状态一致的影响上有很大的不同。事实上，Ilya Sergey 在他的论文中描述了*并发对象*和智能契约之间的相似之处，强调了由于前者常见的笨拙实现而导致的错误可能会影响后者。**

# **符合协议**

## **“神谕”如何让事情变得更糟**

**当处理区块链之外的程序时，智能合约的“双重”并发行为也带来了一些挑战。在[以太坊](https://blog.coincodecap.com/tag/ethereum/)中，常见的解决方案是所谓的“ [oracle 模式](https://blog.coincodecap.com/ethereum-smart-contracts-and-the-oracle-problem/)”，oracle 是被授权向契约发送数据的实体(通过调用它的一个函数)。区块链并不验证数据的真实性，但是所有节点都同意这一点。**

**这在理论上听起来不错，但天堂里有麻烦。在调用 oracle 和回调契约之间可能会经过任意长的时间。在此期间，合同可能会更改其状态，这可能会影响 oracle 输出的处理方式。**

**这个问题不仅与神谕有关。您可能还记得，智能契约一直受到可重入性问题的困扰，例如，那些涉及到 DAO 的问题。**

**在这两种情况下，问题都源于这样一个事实，即坚固性对执行**协议**没有任何帮助。**

# **参与者、合同和协议**

**参与者模型的最初表述没有提到协议或者如何实施它们。以太坊和实性也是一样。**

**我特别喜欢的一个“协议”的同义词是“约定”:协议就是两方或多方之间，关于如何执行某事的协议。在 oracle 的情况下，它可能涉及 Oracle 回调契约时的预期状态。这通常通过将参与方建模为状态机来完成，每个状态机在每个状态中公开特定的功能(即接受特定的消息)。**

**通常的例子是一个文件:**

1.  **初始状态为`Close`；**
2.  **只有在`Close`状态下才能`open`ed；**
3.  **一旦为`Open`，可用于`read`和`write`操作，也可再次为`close` d。**

**所谓的“面向类型状态”编程允许在面向对象编程语言中定义协议，而不需要太多样板代码。当涉及到类型系统时，它们应该跟踪对象所处的状态，拒绝(即代码不编译)对该特定状态不支持的方法或操作的调用。这种方法应该更容易正确地推理协议，而不会迷失在笨拙的语法中。**

**现在，actor 模型的许多实现都内置了对协议的支持。Akka 就是一个例子，尤其是随着 Akka Typed 的出现。另一方面，Solidity 没有提供任何显式的方法来将契约建模为状态机并定义协议。为了克服这个“限制”，一些语言被设计成支持面向类型状态的编程。其中最著名的是 Obsidian，它是专门为提供更强的类型安全保证而设计的，并允许协议的规范。**

# **摘要**

**交互契约——oracle 可以从协议的引入中受益:契约可以忽略所有会修改其状态的方法调用，使 Oracle 假定的先决条件无效。**

**稳固性转向可能为时已晚，但黑曜石背后的想法可以帮助其他区块链使用面向协议的智能合同。**

# **参考资料和进一步阅读**

*   **智能合同的并行观点，伊利亚·谢尔盖和阿奎那·霍博尔，[https://arxiv.org/pdf/1702.05511.pdf](https://arxiv.org/pdf/1702.05511.pdf)**
*   **演员因素，布鲁克林泽伦卡，【https://medium.com/spadebuilders/actor-factor-2b0005fde786 **
*   **人工智能的通用模块演员形式主义，卡尔·休伊特，彼得·毕晓普，理查德·施泰格，【https://www.ijcai.org/Proceedings/73/Papers/027B.pdf】T4**
*   **黑曜石，更安全的区块链编程的类型状态和资产，[https://arxiv.org/pdf/1909.03523.pdf](https://arxiv.org/pdf/1909.03523.pdf)**

> **[直接在您的收件箱中获得最佳软件交易](https://coincodecap.com/?utm_source=coinmonks)**

**[![](img/7c0b3dfdcbfea594cc0ae7d4f9bf6fcb.png)](https://coincodecap.com/?utm_source=coinmonks)**