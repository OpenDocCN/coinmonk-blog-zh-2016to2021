<html>
<head>
<title>Test A Smart Contract With Truffle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用松露测试智能合同</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/test-a-smart-contract-with-truffle-3eb8e1929370?source=collection_archive---------0-----------------------#2018-05-04">https://medium.com/coinmonks/test-a-smart-contract-with-truffle-3eb8e1929370?source=collection_archive---------0-----------------------#2018-05-04</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="83f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<a class="ae jo" rel="noopener" href="/coinmonks/write-a-simple-contract-on-top-of-ethereum-92b543594e84">之前的文章</a>中，我向您展示了如何在Remix编辑器中编写智能契约。但是把智能合同直接写在web上不太方便。出于学习的目的，直接在网上写代码是可以的。对于博客来说，直接在网上写文章是可以的。但是当你为严肃的目的编码时，它通常是离线的。因此，我将向您展示如何使用普通文本编辑器编写智能合同。</p><p id="053e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Truffle就像一个构建智能合约的框架。你不必用松露来写智能合同。但是Truffle对于编写智能合约就像Ruby on Rails对于web编程一样。</p><p id="dead" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，你需要NodeJs。去它的主页，安装推荐的版本(写这篇文章的时候，版本是8)。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/d1284d5eec9865c0c33a4a08ace92d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9A8wqVyZuok366_PuKlcqg.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">NodeJs homepage</figcaption></figure><p id="a952" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">安装NodeJs给你<em class="kf">节点</em>和<em class="kf"> npm </em>程序。Node是类似java，python，ruby的程序。它运行JavaScript应用程序。Npm是包管理器。它类似于pip，apt-get，gem。</p><p id="7009" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后你需要安装松露:</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="2c8e" class="kl km ht kh b fv kn ko l kp kq">npm install -g truffle</span></pre><p id="d61c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您在MacOSX或Ubuntu Linux中，您可能需要在命令前面添加<em class="kf"> sudo </em>来获得在系统范围内安装truffle命令的权限。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/641a6e4f04ff9c46683676d578f376b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ENMil9QonEoEueKPTMuSAw.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Truffle homepage</figcaption></figure><p id="1482" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们创建一个目录并用Truffle初始化它。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="dc29" class="kl km ht kh b fv kn ko l kp kq">mkdir Auction</span><span id="2ca9" class="kl km ht kh b fv kr ko l kp kq">cd Auction</span><span id="a6c7" class="kl km ht kh b fv kr ko l kp kq">truffle init</span></pre><p id="17de" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在目录中，您将智能合同放在合同目录中。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="3ac0" class="kl km ht kh b fv kn ko l kp kq">edit contracts/Auction.sol</span></pre><p id="9941" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您可以用命令替换<em class="kf"> edit </em>来启动您喜爱的文本编辑器，如vim、code、sublime、emacs或atom。</p><p id="4afb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">将此代码复制到Auction.sol。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="5438" class="kl km ht kh b fv kn ko l kp kq">pragma solidity ^0.4.19;</span><span id="4590" class="kl km ht kh b fv kr ko l kp kq">contract Auction {<br/>  address public manager;<br/>  address public seller;<br/>  uint public latestBid;<br/>  address public latestBidder;<br/> <br/>  constructor() public {<br/>    manager = msg.sender;<br/>  }<br/> <br/>  function auction(uint bid) public {<br/>    latestBid = bid * 1 ether; //1000000000000000000;<br/>    seller = msg.sender;<br/>  }<br/> <br/>  function bid() public payable {<br/>    require(msg.value &gt; latestBid);<br/> <br/>    if (latestBidder != 0x0) {<br/>      latestBidder.transfer(latestBid);<br/>    }<br/>    latestBidder = msg.sender;<br/>    latestBid = msg.value;<br/>  }<br/> <br/>  function finishAuction() restricted public {<br/>    seller.transfer(address(this).balance);<br/>  }<br/> <br/>  modifier restricted() {<br/>    require(msg.sender == manager);<br/>    _;<br/>  }<br/>}</span></pre><p id="4a9c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你想知道这段代码是做什么的，可以查看我的<a class="ae jo" rel="noopener" href="/coinmonks/write-a-simple-contract-on-top-of-ethereum-92b543594e84">上一篇文章</a>。</p><p id="d9b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您可以通过启动此命令来编译智能合约。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="7814" class="kl km ht kh b fv kn ko l kp kq">truffle compile</span></pre><p id="a66b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">默认情况下，编译过程的输出在<em class="kf">build/contracts/auction . JSON</em>文件中。你可以打开看看里面是什么。这是一个json文件。这个json对象有两个键非常重要，分别是<em class="kf"> abi </em>和<em class="kf">字节码</em>。</p><p id="4108" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="kf">字节码</em>是以太坊虚拟机理解的内容。这就像二进制文件。abi 是我们可以与智能合同交互的接口。所以如果<em class="kf">字节码</em>是房子，<em class="kf"> abi </em>就是房子的地图(门所在的位置)。</p><p id="2f97" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你不能就这样执行这个字节码。这与你编译C/C++代码并能够直接执行二进制代码是不同的。你必须先把智能合同放在区块链里。</p><p id="a2e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为简单起见，您将把这个智能合约部署到本地区块链。向真实以太坊所在的以太坊主网发起智能合约的方式类似。但首先你要用松露推出当地的区块链。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="3a95" class="kl km ht kh b fv kn ko l kp kq">truffle develop</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff ks"><img src="../Images/a63e50f13b733aa8a4c78fbf7508ccc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJUMZBsIKHTZdvqFpiVSqw.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Truffle develop</figcaption></figure><p id="b150" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你知道默认情况下它在本地主机的9545端口启动服务吗？记住这一点。</p><p id="707d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在部署您心爱的智能合约之前，您需要告诉Truffle项目在哪里可以找到区块链。编辑truffle配置文件。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="5dbb" class="kl km ht kh b fv kn ko l kp kq">edit truffle.js</span></pre><p id="b4e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">将该内容复制到该文件中。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="c31e" class="kl km ht kh b fv kn ko l kp kq">module.exports = {<br/>  // See &lt;<a class="ae jo" href="http://truffleframework.com/docs/advanced/configuration" rel="noopener ugc nofollow" target="_blank">http://truffleframework.com/docs/advanced/configuration</a>&gt;<br/>  // to customize your Truffle configuration!<br/>  networks: {<br/>    “development”: {<br/>      network_id: 2,<br/>      host: “localhost”,<br/>      port: 9545<br/>    },<br/>  }<br/>};</span></pre><p id="ca4c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后我们需要写迁移。对于一些熟悉Ruby on Rails等框架的人来说，这种情况下的迁移不同于数据库迁移。这里，迁移意味着部署特定智能合约的过程。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="8449" class="kl km ht kh b fv kn ko l kp kq">edit migrations/2_deploy_contracts.js</span></pre><p id="2d45" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">将该内容复制到该文件中。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="a188" class="kl km ht kh b fv kn ko l kp kq">var Auction = artifacts.require(“Auction”);</span><span id="a80c" class="kl km ht kh b fv kr ko l kp kq">module.exports = function(deployer) {<br/>  deployer.deploy(Auction);<br/>};</span></pre><p id="a770" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，您可以部署智能合约了。打开一个新的终端，进入项目目录。不要破坏你启动<em class="kf">松露开发</em>的终端。我们以后会用到它。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="5299" class="kl km ht kh b fv kn ko l kp kq">truffle migrate</span></pre><p id="cca0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您将得到如下输出:</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="8b2e" class="kl km ht kh b fv kn ko l kp kq">Using network ‘development’.</span><span id="9d79" class="kl km ht kh b fv kr ko l kp kq">Running migration: 1_initial_migration.js<br/> Replacing Migrations…<br/> … 0x3a8f8c4379f1d7269b9d931a088984f4ccfeec797bbb6e128582e2915c8f3ea1<br/> Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0<br/>Saving successful migration to network…<br/> … 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956<br/>Saving artifacts…<br/>Running migration: 2_deploy_contracts.js<br/> Replacing Auction…<br/> … 0xf0b10908aeb415b8b13fe60aeed8ade6769679572a44cf679b5616e38670329d<br/> Auction: 0x345ca3e014aaf5dca488057592ee47305d9b3e10<br/>Saving artifacts…</span></pre><p id="6ed7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你的输出不会和我的100%一样。地址会有所不同。看看部署的地址。这很重要。在我的例子中，部署的拍卖智能合约的地址是0x 345 ca 3 e 014 AAF 5 DCA 488057592 ee 47305d 9 B3 e 10。</p><p id="14b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，去松露控制台。就是在你启动<em class="kf">松露开发</em>的航站楼。看看第一个公钥。注意这一点。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff ks"><img src="../Images/a0cf17af291efd22adebd06d0f44dd61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ErhYi71BKePGmBGg74kvRw.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Look at the first account</figcaption></figure><p id="e1ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们找出这个智能合同的经理。在Truffle开发控制台中键入此内容。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="016f" class="kl km ht kh b fv kn ko l kp kq">Auction.at(“0x345ca3e014aaf5dca488057592ee47305d9b3e10”).manager.call();</span></pre><p id="4b5a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">随机数0x 345 ca 3 e 014 AAF 5 DCA 488057592 ee 47305d 9 B3 e 10来自<em class="kf">松露迁移</em>命令的输出。您刚才在Truffle develop控制台中输入的这条语句的输出是我要求您注意的第一个帐户地址。看起来<em class="kf"> truffle migrate </em>命令将使用Truffle develop中的第一个帐户部署智能合同。</p><p id="8722" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，让我们执行拍卖方法，但使用不同的帐户。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="be28" class="kl km ht kh b fv kn ko l kp kq">Auction.at(“0x345ca3e014aaf5dca488057592ee47305d9b3e10”).auction(3, {from: “0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e” });</span></pre><p id="b543" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你可以检查这个方法是否有效。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="8525" class="kl km ht kh b fv kn ko l kp kq">truffle(develop)&gt; Auction.at(“0x345ca3e014aaf5dca488057592ee47305d9b3e10”).seller.call();<br/>‘0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e’</span></pre><p id="2ea4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">顺便说一句，你这样做可以使它变得更简单。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="d044" class="kl km ht kh b fv kn ko l kp kq">truffle(develop)&gt; Auction.at(“0x345ca3e014aaf5dca488057592ee47305d9b3e10”).seller();<br/>‘0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e’</span></pre><p id="43d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，让我们为智能契约编写单元测试。坏消息是。我无法在Truffle框架内成功编写测试。我必须手动操作。要么是我做错了，要么是松露框架有bug。一旦我想通了，我会把它写在以后的文章里。现在，我们只需要手动编写测试。先用<em class="kf"> npm </em>装一些东西。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="677c" class="kl km ht kh b fv kn ko l kp kq">npm install --save ganache-cli mocha web3@1.0.0-beta.34</span></pre><p id="4730" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是本地安装。它会将这些库保存到这个项目中，但不是系统范围的。Ganache就像Truffle develop，一个用于智能合约单元测试的本地区块链。Mocha是单元测试框架。web3是我们连接到已部署的智能合同的方式。这里，web3的1.0版本还没有准备好投入生产。生产版本低于1.0版，但我们需要1.0版，因为有一些方法我们非常需要。因此，我们使用测试版。</p><p id="f4b7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">将测试文件放在测试目录中，并将其命名为Auction.test.js。</p><p id="0a19" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">写下这几行。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="bb49" class="kl km ht kh b fv kn ko l kp kq">const assert = require(‘assert’);</span><span id="549e" class="kl km ht kh b fv kr ko l kp kq">const ganache = require(‘ganache-cli’);</span><span id="10f9" class="kl km ht kh b fv kr ko l kp kq">const Web3 = require(‘web3’);</span><span id="6786" class="kl km ht kh b fv kr ko l kp kq">const web3 = new Web3(ganache.provider());</span><span id="b9e0" class="kl km ht kh b fv kr ko l kp kq">const json = require(‘./../build/contracts/Auction.json’);</span></pre><p id="c83a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这里，我们从刚刚安装的库中导入重要的东西。<em class="kf">断言</em>是检查该方法是否正常工作。<em class="kf">加纳切</em>是我们当地的区块链。<em class="kf"> web3 </em>是我们联系当地区块链的方式。<em class="kf"> json </em>是一个Auction.sol文件的编译输出。</p><p id="d552" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在那下面，写下这几行。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="0a03" class="kl km ht kh b fv kn ko l kp kq">let accounts;</span><span id="1184" class="kl km ht kh b fv kr ko l kp kq">let auction;</span><span id="b9d9" class="kl km ht kh b fv kr ko l kp kq">let manager;</span><span id="ca14" class="kl km ht kh b fv kr ko l kp kq">const interface = json[‘abi’];</span><span id="4100" class="kl km ht kh b fv kr ko l kp kq">const bytecode = json[‘bytecode’];</span></pre><p id="0731" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们初始化一些变量。如上所述，我们只关心输出json文件的两个部分，字节码和接口(abi)。</p><p id="ee36" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">继续说这些台词。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="1c05" class="kl km ht kh b fv kn ko l kp kq">beforeEach(async () =&gt; {</span><span id="1f59" class="kl km ht kh b fv kr ko l kp kq">  accounts = await web3.eth.getAccounts();</span><span id="6e9f" class="kl km ht kh b fv kr ko l kp kq">  manager = accounts[0];</span><span id="9fe6" class="kl km ht kh b fv kr ko l kp kq">  auction = await new web3.eth.Contract(interface)</span><span id="8c49" class="kl km ht kh b fv kr ko l kp kq">      .deploy({ data: bytecode })</span><span id="d971" class="kl km ht kh b fv kr ko l kp kq">      .send({ from: manager, gas: ‘1000000’ });</span><span id="30d8" class="kl km ht kh b fv kr ko l kp kq">});</span></pre><p id="977c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">单元测试中的beforeEach意味着每次执行单元测试时都要运行此方法。连接到区块链是一个异步过程，所以我们必须声明我们的函数async。我们要做的第一件事是得到所有的客户。加纳切给了我们一些可玩的账户。但是我们在进行其他步骤之前需要这些帐户，所以我们在这里使用<em class="kf">wait</em>来同步语句。我们使用第一个帐户作为经理。然后我们部署合同。为了部署契约，我们需要接口、字节码、地址和一些gas(部署契约不是免费的)。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="d8fd" class="kl km ht kh b fv kn ko l kp kq">describe(‘Auction’, () =&gt; {</span><span id="1686" class="kl km ht kh b fv kr ko l kp kq">  it(‘deploys a contract’, async () =&gt; {</span><span id="5376" class="kl km ht kh b fv kr ko l kp kq">    const auctionManager = await auction.methods.manager().call();</span><span id="84bc" class="kl km ht kh b fv kr ko l kp kq">    assert.equal(manager, auctionManager, “The manager is the one who   launches the smart contract.”);</span><span id="6c80" class="kl km ht kh b fv kr ko l kp kq">  });</span><span id="9b1c" class="kl km ht kh b fv kr ko l kp kq">  //Continue from this line from now on...</span><span id="8d4d" class="kl km ht kh b fv kr ko l kp kq">});</span></pre><p id="d528" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是我们的第一次测试。<em class="kf">描述</em>是分组测试的一种方式。第一个测试是检查部署契约的地址是否保存到智能契约内的manager变量中。在这里，我们正在与智能合同进行交互，而不是与可靠性进行交互。因此，访问智能协定的方法或属性存在一些差异。要访问智能合约的manager属性，可以使用以下语句。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="52d0" class="kl km ht kh b fv kn ko l kp kq">auction.methods.manager().call()</span></pre><p id="7817" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们继续我们的另一个测试。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="2a84" class="kl km ht kh b fv kn ko l kp kq">it(‘auctions the item’, async () =&gt; {</span><span id="0963" class="kl km ht kh b fv kr ko l kp kq">  seller = accounts[1];</span><span id="f7c5" class="kl km ht kh b fv kr ko l kp kq">  await auction.methods.auction(2).send({ from: seller });</span><span id="1678" class="kl km ht kh b fv kr ko l kp kq">  auctionSeller = await auction.methods.seller().call();</span><span id="a9a2" class="kl km ht kh b fv kr ko l kp kq">  assert.equal(auctionSeller, seller,</span><span id="cc5a" class="kl km ht kh b fv kr ko l kp kq">“The seller is the one who called the auction method.”);</span><span id="5673" class="kl km ht kh b fv kr ko l kp kq">  auctionBid = await auction.methods.latestBid().call();</span><span id="f795" class="kl km ht kh b fv kr ko l kp kq">  assert.equal(auctionBid, web3.utils.toWei(‘2’, ‘ether’),</span><span id="5776" class="kl km ht kh b fv kr ko l kp kq">“The latest bid is the argument sent to auction method converted into wei.”);</span><span id="2ba0" class="kl km ht kh b fv kr ko l kp kq">});</span></pre><p id="aba5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这个测试中，我们对卖家使用不同的账户。若要使用特定地址执行智能协定的方法，请使用以下语句:</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="ac4e" class="kl km ht kh b fv kn ko l kp kq">auction.methods.auction(2).send({ from: seller });</span></pre><p id="364b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们继续进行其他测试。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="678b" class="kl km ht kh b fv kn ko l kp kq">it(‘bids the item’, async () =&gt; {</span><span id="f8ae" class="kl km ht kh b fv kr ko l kp kq">  bidder = accounts[2];</span><span id="4238" class="kl km ht kh b fv kr ko l kp kq">  await auction.methods.bid().send({ from: bidder, value: web3.utils.toWei(‘3’, ‘ether’) });</span><span id="b4df" class="kl km ht kh b fv kr ko l kp kq">  auctionBid = await auction.methods.latestBid().call();</span><span id="944e" class="kl km ht kh b fv kr ko l kp kq">  assert.equal(auctionBid, web3.utils.toWei(‘3’, ‘ether’),</span><span id="608f" class="kl km ht kh b fv kr ko l kp kq">“The latest bid is the payment sent to bid method converted into wei.”);</span><span id="6333" class="kl km ht kh b fv kr ko l kp kq">});</span></pre><p id="d651" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里，在这个测试中，我们在执行智能合约的方法时测试发送付款。我们使用<em class="kf">值</em>关键字自变量。默认情况下，它接受魏数。但是我们正在处理以太数字，所以我们必须用web3辅助函数来转换它。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="d36b" class="kl km ht kh b fv kn ko l kp kq">auction.methods.bid().send({ from: bidder, value: web3.utils.toWei(‘3’, ‘ether’) });</span></pre><p id="bacd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们继续进行其他测试。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="7ef4" class="kl km ht kh b fv kn ko l kp kq">it(‘must bid above the latest bid amount’, async () =&gt; {</span><span id="7a6f" class="kl km ht kh b fv kr ko l kp kq">  bidder = accounts[2];</span><span id="f0a2" class="kl km ht kh b fv kr ko l kp kq">  try {</span><span id="c99e" class="kl km ht kh b fv kr ko l kp kq">    await auction.methods.bid().send({ from: bidder, value: web3.utils.toWei(‘1’, ‘ether’) });</span><span id="2fc5" class="kl km ht kh b fv kr ko l kp kq">    assert(false);</span><span id="a08a" class="kl km ht kh b fv kr ko l kp kq">  } catch (err) {</span><span id="194b" class="kl km ht kh b fv kr ko l kp kq">    assert(err);</span><span id="bdd0" class="kl km ht kh b fv kr ko l kp kq">  }</span><span id="005e" class="kl km ht kh b fv kr ko l kp kq">});</span></pre><p id="7d3d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里，在这个测试中，我们测试当我们在智能契约中的<em class="kf"> require </em>语句失败时抛出的异常。还记得智能合约里的这个方法吗？</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="c300" class="kl km ht kh b fv kn ko l kp kq">function bid() public payable {<br/>  require(msg.value &gt; latestBid);<br/> <br/>  if (latestBidder != 0x0) {<br/>    latestBidder.transfer(latestBid);<br/>  }<br/>  latestBidder = msg.sender;<br/>  latestBid = msg.value;<br/>}</span></pre><p id="0570" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们必须支付高于上次出价的金额。所以在这个测试中，我们想要测试失败的情况。我们使用try catch来测试失败案例。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="6968" class="kl km ht kh b fv kn ko l kp kq">try {</span><span id="070b" class="kl km ht kh b fv kr ko l kp kq">  await auction.methods.bid().send({ from: bidder, value: web3.utils.toWei(‘1’, ‘ether’) });</span><span id="9fb6" class="kl km ht kh b fv kr ko l kp kq">  assert(false);</span><span id="8847" class="kl km ht kh b fv kr ko l kp kq">} catch (err) {</span><span id="1302" class="kl km ht kh b fv kr ko l kp kq">  assert(err);</span><span id="6707" class="kl km ht kh b fv kr ko l kp kq">}</span></pre><p id="6f86" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们继续最后的测试。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="329f" class="kl km ht kh b fv kn ko l kp kq">it(‘only manager can finish the auction’, async () =&gt; {</span><span id="bff8" class="kl km ht kh b fv kr ko l kp kq">  nonmanager = accounts[1];</span><span id="4481" class="kl km ht kh b fv kr ko l kp kq">  try {</span><span id="9eb6" class="kl km ht kh b fv kr ko l kp kq">    await auction.methods.finishAuction().send({ from: nonmanager });</span><span id="9d93" class="kl km ht kh b fv kr ko l kp kq">    assert(false);</span><span id="3ea2" class="kl km ht kh b fv kr ko l kp kq">  } catch (err) {</span><span id="2a26" class="kl km ht kh b fv kr ko l kp kq">    assert(err);</span><span id="e99a" class="kl km ht kh b fv kr ko l kp kq">  }</span><span id="4043" class="kl km ht kh b fv kr ko l kp kq">});</span><span id="1c8d" class="kl km ht kh b fv kr ko l kp kq">it(‘finishes the auction as manager’, async () =&gt; {</span><span id="9079" class="kl km ht kh b fv kr ko l kp kq">  manager = accounts[0];</span><span id="e4df" class="kl km ht kh b fv kr ko l kp kq">  await auction.methods.finishAuction().send({ from: manager });</span><span id="acca" class="kl km ht kh b fv kr ko l kp kq">  assert(true);</span><span id="9456" class="kl km ht kh b fv kr ko l kp kq">});</span></pre><p id="844b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">完整的测试文件代码在这里。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="3cc7" class="kl km ht kh b fv kn ko l kp kq">const assert = require(‘assert’);</span><span id="9e53" class="kl km ht kh b fv kr ko l kp kq">const ganache = require(‘ganache-cli’);</span><span id="6c4e" class="kl km ht kh b fv kr ko l kp kq">const Web3 = require(‘web3’);</span><span id="b081" class="kl km ht kh b fv kr ko l kp kq">const web3 = new Web3(ganache.provider());</span><span id="1928" class="kl km ht kh b fv kr ko l kp kq">const json = require(‘./../build/contracts/Auction.json’);</span><span id="9b22" class="kl km ht kh b fv kr ko l kp kq">let accounts;</span><span id="4586" class="kl km ht kh b fv kr ko l kp kq">let auction;</span><span id="eff0" class="kl km ht kh b fv kr ko l kp kq">let manager;</span><span id="fd21" class="kl km ht kh b fv kr ko l kp kq">const interface = json[‘abi’];</span><span id="e8fc" class="kl km ht kh b fv kr ko l kp kq">const bytecode = json[‘bytecode’];</span><span id="1439" class="kl km ht kh b fv kr ko l kp kq">beforeEach(async () =&gt; {</span><span id="34ca" class="kl km ht kh b fv kr ko l kp kq">  accounts = await web3.eth.getAccounts();</span><span id="c3f1" class="kl km ht kh b fv kr ko l kp kq">  manager = accounts[0];</span><span id="a8ef" class="kl km ht kh b fv kr ko l kp kq">  auction = await new web3.eth.Contract(interface)</span><span id="04fb" class="kl km ht kh b fv kr ko l kp kq">      .deploy({ data: bytecode })</span><span id="93ff" class="kl km ht kh b fv kr ko l kp kq">      .send({ from: manager, gas: ‘1000000’ });</span><span id="eec6" class="kl km ht kh b fv kr ko l kp kq">});</span><span id="ac37" class="kl km ht kh b fv kr ko l kp kq">describe(‘Auction’, () =&gt; {</span><span id="3249" class="kl km ht kh b fv kr ko l kp kq">  it(‘deploys a contract’, async () =&gt; {</span><span id="53e4" class="kl km ht kh b fv kr ko l kp kq">    const auctionManager = await auction.methods.manager().call();</span><span id="5b7c" class="kl km ht kh b fv kr ko l kp kq">    assert.equal(manager, auctionManager, “The manager is the one who launched the smart contract.”);</span><span id="f76e" class="kl km ht kh b fv kr ko l kp kq">  });</span><span id="bc3f" class="kl km ht kh b fv kr ko l kp kq">  it(‘auctions the item’, async () =&gt; {</span><span id="529a" class="kl km ht kh b fv kr ko l kp kq">    seller = accounts[1];</span><span id="ba44" class="kl km ht kh b fv kr ko l kp kq">    await auction.methods.auction(2).send({ from: seller });</span><span id="7701" class="kl km ht kh b fv kr ko l kp kq">    auctionSeller = await auction.methods.seller().call();</span><span id="7b39" class="kl km ht kh b fv kr ko l kp kq">    assert.equal(auctionSeller, seller, “The seller is the one who called the auction method.”);</span><span id="5439" class="kl km ht kh b fv kr ko l kp kq">    auctionBid = await auction.methods.latestBid().call();</span><span id="75a3" class="kl km ht kh b fv kr ko l kp kq">    assert.equal(auctionBid, web3.utils.toWei(‘2’, ‘ether’), “The latest bid is the argument sent to auction method converted into wei.”);</span><span id="86f4" class="kl km ht kh b fv kr ko l kp kq">  });</span><span id="5d83" class="kl km ht kh b fv kr ko l kp kq">  it(‘bids the item’, async () =&gt; {</span><span id="e397" class="kl km ht kh b fv kr ko l kp kq">    bidder = accounts[2];</span><span id="c82d" class="kl km ht kh b fv kr ko l kp kq">    await auction.methods.bid().send({ from: bidder, value: web3.utils.toWei(‘3’, ‘ether’) });</span><span id="ec43" class="kl km ht kh b fv kr ko l kp kq">    auctionBid = await auction.methods.latestBid().call();</span><span id="222b" class="kl km ht kh b fv kr ko l kp kq">    assert.equal(auctionBid, web3.utils.toWei(‘3’, ‘ether’), “The latest bid is the payment sent to bid method converted into wei.”);</span><span id="8e34" class="kl km ht kh b fv kr ko l kp kq">  });</span><span id="dc3d" class="kl km ht kh b fv kr ko l kp kq">  it(‘must bid above the latest bid amount’, async () =&gt; {</span><span id="9b25" class="kl km ht kh b fv kr ko l kp kq">    bidder = accounts[2];</span><span id="3113" class="kl km ht kh b fv kr ko l kp kq">    try {</span><span id="4345" class="kl km ht kh b fv kr ko l kp kq">      await auction.methods.bid().send({ from: bidder, value: web3.utils.toWei(‘1’, ‘ether’) });</span><span id="d9cf" class="kl km ht kh b fv kr ko l kp kq">      assert(false);</span><span id="d18e" class="kl km ht kh b fv kr ko l kp kq">    } catch (err) {</span><span id="3d2f" class="kl km ht kh b fv kr ko l kp kq">      assert(err);</span><span id="5c97" class="kl km ht kh b fv kr ko l kp kq">    }</span><span id="7574" class="kl km ht kh b fv kr ko l kp kq">  });</span><span id="affe" class="kl km ht kh b fv kr ko l kp kq">  it(‘only manager can finish the auction’, async () =&gt; {</span><span id="de2e" class="kl km ht kh b fv kr ko l kp kq">    nonmanager = accounts[1];</span><span id="e4c9" class="kl km ht kh b fv kr ko l kp kq">    try {</span><span id="15cc" class="kl km ht kh b fv kr ko l kp kq">      await auction.methods.finishAuction().send({ from: nonmanager    });</span><span id="b537" class="kl km ht kh b fv kr ko l kp kq">      assert(false);</span><span id="c69f" class="kl km ht kh b fv kr ko l kp kq">    } catch (err) {</span><span id="92a7" class="kl km ht kh b fv kr ko l kp kq">      assert(err);</span><span id="d143" class="kl km ht kh b fv kr ko l kp kq">    }</span><span id="dddc" class="kl km ht kh b fv kr ko l kp kq">  });</span><span id="796b" class="kl km ht kh b fv kr ko l kp kq">  it(‘finishes the auction as manager’, async () =&gt; {</span><span id="7825" class="kl km ht kh b fv kr ko l kp kq">    manager = accounts[0];</span><span id="ebfa" class="kl km ht kh b fv kr ko l kp kq">    await auction.methods.finishAuction().send({ from: manager });</span><span id="6568" class="kl km ht kh b fv kr ko l kp kq">    assert(true);</span><span id="6d05" class="kl km ht kh b fv kr ko l kp kq">  });</span><span id="54c1" class="kl km ht kh b fv kr ko l kp kq">});</span></pre><p id="11d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这就是你执行测试的方式。</p><pre class="jq jr js jt fq kg kh ki kj aw kk dt"><span id="e95e" class="kl km ht kh b fv kn ko l kp kq">npm run test</span></pre><p id="aa84" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你会得到这样的输出。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff kt"><img src="../Images/4f7ae9d07d7daf559224f139ff785566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9hwBYIA6h0twhpSLaOaz7A.png"/></div></div></figure><blockquote class="ku"><p id="89ce" class="kv kw ht bd kx ky kz la lb lc ld jn ek translated">加入Coinmonks <a class="ae jo" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jo" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae jo" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="kl km ht bd le lf lg lh li lj lk ll lm jb ln lo lp jf lq lr ls jj lt lu lv lw dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="lx ly ht is b it lz ix ma jb mb jf mc jj md jn me mf mg mh dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae jo" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="lx ly ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh dt translated"><a class="ae jo" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae jo" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="lx ly ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh dt translated"><a class="ae jo" href="http://Top 4 Telegram Channels for Crypto Traders" rel="noopener ugc nofollow" target="_blank">密码电报信号</a> | <a class="ae jo" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="lx ly ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae jo" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="lx ly ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh dt translated">开发人员的最佳加密API</li><li id="b359" class="lx ly ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh dt translated">最佳<a class="ae jo" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="9487" class="lx ly ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh dt translated">杠杆代币的终极指南</li><li id="f1ee" class="lx ly ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh dt translated"><a class="ae jo" href="https://coincodecap.com/zero-fee-crypto-exchanges" rel="noopener ugc nofollow" target="_blank"> 7个最佳零费用加密交易平台</a></li><li id="5aa5" class="lx ly ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh dt translated"><a class="ae jo" href="https://coincodecap.com/best-online-casinos" rel="noopener ugc nofollow" target="_blank">最佳网上赌场</a> | <a class="ae jo" rel="noopener" href="/coinmonks/futures-trading-bots-5a282ccee3f5">期货交易机器人</a></li><li id="3d0e" class="lx ly ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh dt translated"><a class="ae jo" href="https://coincodecap.com/what-are-decentralized-exchanges" rel="noopener ugc nofollow" target="_blank">分散交易所</a> | <a class="ae jo" href="https://coincodecap.com/bitbns-fip" rel="noopener ugc nofollow" target="_blank">比特FIP </a></li><li id="5cf9" class="lx ly ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh dt translated"><a class="ae jo" href="https://coincodecap.com/buy-crypto-with-credit-card" rel="noopener ugc nofollow" target="_blank">用信用卡购买密码的10个最佳地点</a></li><li id="3d13" class="lx ly ht is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh dt translated"><a class="ae jo" href="https://coincodecap.com/5-best-crypto-trading-bots-in-canada" rel="noopener ugc nofollow" target="_blank">加拿大最佳加密交易机器人</a> | <a class="ae jo" href="https://coincodecap.com/bybit-binance-moonxbt" rel="noopener ugc nofollow" target="_blank"> Bybit vs币安</a></li></ul></div></div>    
</body>
</html>