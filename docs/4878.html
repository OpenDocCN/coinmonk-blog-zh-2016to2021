<html>
<head>
<title>Building an Ether DEX Price Aggregator with Fluence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Fluence构建以太指数价格聚合器</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/building-an-ether-dex-price-aggregator-with-fluence-65fb0e31a802?source=collection_archive---------0-----------------------#2021-06-29">https://medium.com/coinmonks/building-an-ether-dex-price-aggregator-with-fluence-65fb0e31a802?source=collection_archive---------0-----------------------#2021-06-29</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="1529" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">分散式应用程序开发教程</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/56472e087d8ac8ccbde216d0ebdc583e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CdOOx6Jddf-Ma7yPhD5k3g.jpeg"/></div></div></figure><p id="2104" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">自从我的上一篇帖子以来已经过去了很长时间，因为最近的工作量非常大，但现在事情正在恢复正常，所以我想重新开始我的博客活动，围绕我最近工作的一个非常有趣的技术栈发布一篇教程博客。</p><p id="6c37" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在<a class="ae kq" href="https://www.encode.club/hack-the-system" rel="noopener ugc nofollow" target="_blank"> Hack The System </a> hackathon的背景下，一个中等难度的公开挑战是使用Fluence stack构建以太价格发现服务。事实上，这个挑战似乎很容易，因为所需的大部分部件已经在Fluence的一个研讨会上实现并展示了。因此，我主动将此提升一个档次，从DEX(分散式交易所)实现以太价格聚合器，而不仅仅是获取以太价格。</p><p id="c36f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">假设这对于你来说是一项新技术(就像我在黑客马拉松时一样)，我在下面写了几个常见问题来涵盖一些基本的背景知识。</p><h1 id="aec7" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">什么是Fluence？</h1><p id="a7ad" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">Fluence(Fluence Labs)是一个<strong class="jw hu">的开放应用平台。</strong>为了更好地理解这个术语，让我们首先澄清什么是开放平台。</p><blockquote class="lo"><p id="7573" class="lp lq ht bd lr ls lt lu lv lw lx kp ek translated">通俗地说，开放平台就是一个软件系统，它是基于一些已发布/文档化的编程接口/标准来实现开放的外部开发。</p></blockquote><p id="d86f" class="pw-post-body-paragraph ju jv ht jw b jx ly iu jz ka lz ix kc kd ma kf kg kh mb kj kk kl mc kn ko kp hm dt translated">也就是说，允许外部各方在上述平台之上构建。回到最初的术语，开放应用程序平台允许开放开发符合平台规定的标准的应用程序。</p><blockquote class="md me mf"><p id="281b" class="ju jv mg jw b jx jy iu jz ka kb ix kc mh ke kf kg mi ki kj kk mj km kn ko kp hm dt translated">这种平台的一个例子是Heroku。它支持在平台上部署一个应用程序(假设它是用一个受支持的框架构建的),然后每个人都可以访问它。</p></blockquote><p id="5c78" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">然而，在Fluence的情况下，有一些特征使它在其他应用程序平台中脱颖而出。直接引自官方<a class="ae kq" href="https://fluence.network/" rel="noopener ugc nofollow" target="_blank">流量页面</a>的是:</p><ol class=""><li id="fa96" class="mk ml ht jw b jx jy ka kb kd mm kh mn kl mo kp mp mq mr ms dt translated"><strong class="jw hu">分散化:</strong>充满信心地构建，因为访问不会被禁用，集成不会被破坏。</li><li id="8999" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp mp mq mr ms dt translated"><strong class="jw hu">可组合</strong>:重用代码和数据，在现有应用程序的基础上构建新功能。</li><li id="9444" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp mp mq mr ms dt translated"><strong class="jw hu">加速</strong>:通过抽象复杂的后端，从根本上加快进入市场的速度。</li><li id="1a4b" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp mp mq mr ms dt translated"><strong class="jw hu">奖励:</strong>应用程序和低级组件将根据其使用情况进行货币化。打造流行元素，赚。</li></ol><p id="d3ec" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我承认前两个特征(去中心化的、可组合的)吸引了我，假设剩下的是可以实现的<strong class="jw hu">当且仅当</strong>前两个都到位了。为了保持这篇文章的简洁，读者可以在他们的官方<a class="ae kq" href="https://fluence.network/manifesto.html" rel="noopener ugc nofollow" target="_blank">宣言</a>中找到关于为什么这些属性是未来应用程序开发的关键元素的更全面的观点。</p><h1 id="8472" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">积分通量堆栈由什么组成？</h1><p id="7901" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">Fluence堆栈由四个基本层组成:<strong class="jw hu">执行、组合、拓扑和安全&amp;记账。</strong>下表总结了每一层的技术。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff my"><img src="../Images/2c191e130fc2417c7d5aecc3507526cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xBSruKdeeJ22aj3fQQ2ww.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Source: <a class="ae kq" href="https://github.com/fluencelabs/fldist" rel="noopener ugc nofollow" target="_blank">https://github.com/fluencelabs/fldist</a> — Due to rapid development of the Fluence stack, keep in mind that figure is a slightly outdated.</figcaption></figure><p id="5ad9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">除了这些层，Fluence Labs还开发了支持工具，如docker local nodes/ <a class="ae kq" href="https://github.com/fluencelabs/devcontainer" rel="noopener ugc nofollow" target="_blank">开发环境</a>，一个<a class="ae kq" href="https://crates.io/crates/mrepl" rel="noopener ugc nofollow" target="_blank">交互式repl </a>和<a class="ae kq" href="https://www.npmjs.com/package/@fluencelabs/fldist" rel="noopener ugc nofollow" target="_blank"> Fluence-Distributor </a>来支持Fluence开发。</p><blockquote class="md me mf"><p id="82a1" class="ju jv mg jw b jx jy iu jz ka kb ix kc mh ke kf kg mi ki kj kk mj km kn ko kp hm dt translated">注:<strong class="jw hu"> FCE </strong>已更名为<strong class="jw hu">海洋。</strong></p></blockquote><p id="0605" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">然而不幸的是，在写这篇文章的时候，最后一层<strong class="jw hu">持久化&amp;会计</strong>还在开发中，因此这篇教程实际上只包含了前三层。</p><h1 id="33d6" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">什么是粒子？</h1><p id="3bd0" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">直观上，Fluence堆栈非常类似于微服务架构，其中每个服务都有一个单独的职责，并且没有任何外部依赖性。这也被称为<a class="ae kq" href="https://en.wikipedia.org/wiki/Shared-nothing_architecture" rel="noopener ugc nofollow" target="_blank">无共享架构</a>。</p><p id="d37c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">为了提炼粒子的意义，我们需要理解分布式系统中的通信。嗯，通常一堆微服务通过一个协议相互通信。无论是HTTP、gRPC还是其他，在链式交互的情况下，每个服务都要按顺序执行交互，以实现其最初的目的。<strong class="jw hu">在Fluence stack中，这是使用海蓝宝石中间表示法(AIR)从服务中抽象出来的。从这个意义上说，Fluence stack允许您通过AIR脚本对服务交互进行编程(编排)!<em class="mg">这是极其重要的一点。花点时间消化这个吧！</em> </strong></p><p id="3a8d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">为了更清楚，让我们看一个例子，并将其与传统的分布式微服务架构进行比较。</p><p id="0412" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><strong class="jw hu">考虑一个现代电子商店应用的场景</strong></p><p id="d1c5" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在构建电子商店系统的过程中，可以设计4种微服务，它们相互作用以实现所需的功能。这些是:</p><ul class=""><li id="3db6" class="mk ml ht jw b jx jy ka kb kd mm kh mn kl mo kp nd mq mr ms dt translated"><strong class="jw hu">用户服务:</strong>管理用户账户。</li><li id="55fa" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><strong class="jw hu">库存服务:</strong>管理产品的库存(可用数量等)</li><li id="9634" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><strong class="jw hu">订单服务:</strong>管理客户订单。</li><li id="70f6" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><strong class="jw hu">运输服务:</strong>管理任何与运输有关的事情。(计划、跟踪等)</li></ul><p id="89bf" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">当用户下订单时，客户端通过一个协议(通常是HTTP)与<strong class="jw hu">订单服务</strong>交互以下订单。作为回报，订单服务与<strong class="jw hu">用户服务</strong>一起检查用户是否确实被认证，然后与<strong class="jw hu">库存服务</strong>一起检查以确保商品的可用性并从产品的可用数量中扣除数量，最后它指示<strong class="jw hu">运输服务</strong>安排运输并通知客户。注意，在整个通信链中，所有这些服务的业务逻辑负责响应<strong class="jw hu">订单服务。</strong></p><p id="7fca" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">正如你所看到的，有一系列的事件发生，这是由每个服务单独决定的。如果将来我想让<strong class="jw hu">库存服务</strong>(而不是<strong class="jw hu">订单服务</strong>)直接与<strong class="jw hu">运输服务</strong>交互，那么我必须修改<strong class="jw hu">库存</strong>和<strong class="jw hu">订单</strong>服务。</p></div><div class="ab cl ne nf hb ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hm hn ho hp hq"><p id="ab0c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在，让我们想象在Fluence堆栈上构建相同的场景。在这种情况下，客户端将利用一个AIR脚本(顺便说一下，在这个脚本中，您可以控制身份验证)，该脚本编排了一个网络请求，该请求指示ping什么服务、以什么顺序、调用什么函数以及在哪里返回结果！<strong class="jw hu">考虑到上面描述的变化，只需要对AIR脚本进行微小的修改就可以实现了！</strong></p><p id="e0ea" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">回到最初的问题，这个被编程的网络请求被称为<strong class="jw hu">粒子</strong>。更技术性的定义是包含(应用)数据+脚本+元数据的无冲突复制数据结构，并在Aqua VM上评估和执行，Aqua VM本身是运行在Marine上的Wasm模块。</p><p id="4ff6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">值得一提的是，FluenceLabs也一直在开发Aqua，这是一种编译低级AIR的高级编程语言。</p><h1 id="5bec" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">Ether DEX价格汇总教程</h1><p id="37cc" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">这篇文章的其余部分将带您了解应用程序的开发过程。这包括执行<em class="mg">卷曲</em>请求的简单流量服务和有角度的11前端。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff nl"><img src="../Images/edeb01ae20952e7751f054eae592ca96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kWwG-eBnRs-LSI9l.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Screenshot of the application</figcaption></figure><p id="1b08" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">该项目的完整代码在<strong class="jw hu">博客【https://github.com/apogiatzis/fluence-ether-dex-price】分支<a class="ae kq" href="https://github.com/apogiatzis/fluence-ether-dex-price" rel="noopener ugc nofollow" target="_blank">的</a></strong>中提供</p><p id="12bf" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">为了使文章简洁明了，我将只引用代码的重要部分，因此鼓励您在阅读时参考GitHub <a class="ae kq" href="https://github.com/apogiatzis/fluence-ether-dex-price" rel="noopener ugc nofollow" target="_blank">库</a>以更好地理解代码。</p><h2 id="5f8c" class="nm ks ht bd kt nn no np kx nq nr ns lb kd nt nu ld kh nv nw lf kl nx ny lh nz dt translated">要求</h2><p id="22f0" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">首先，让我们定义我们的DEX价格聚合器的范围。应该有一个接受以下输入的用户界面:</p><ol class=""><li id="b247" class="mk ml ht jw b jx jy ka kb kd mm kh mn kl mo kp mp mq mr ms dt translated">代币报价器(戴、、任等)</li><li id="c145" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp mp mq mr ms dt translated"><strong class="jw hu">动作</strong>(买入或卖出)</li></ol><p id="da24" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在价格查询时，前端必须向Fluence服务发送一个粒子，该服务基于所选择的令牌和动作来查询以太指数价格。AirSwap <a class="ae kq" href="https://ethereum-dex-prices-service.production.airswap.io/" rel="noopener ugc nofollow" target="_blank">在这里</a>提供了一个已经制作好的HTTP API，用于在各种指数之间聚集以太网价格。因此，不重新发明轮子，直接使用轮子是有意义的。请注意，在Fluence服务中查询交换而不是使用API是完全可行的(也更具挑战性)。</p><p id="64b1" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">最后，Fluence服务的结果需要通过表格直观地显示给用户。</p><h2 id="3dbe" class="nm ks ht bd kt nn no np kx nq nr ns lb kd nt nu ld kh nv nw lf kl nx ny lh nz dt translated">发展</h2><p id="1fef" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">在开始开发应用程序之前，必须正确设置环境。最初，确保<a class="ae kq" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>、<a class="ae kq" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>(至少v14)和<a class="ae kq" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>安装在您的系统上。然后需要下载<em class="mg">船用编译器</em>和<em class="mg">船用REPL </em>来辅助开发。为此，您可以使用Rust的板条箱管理器<code class="eh oa ob oc od b">cargo</code>:</p><ul class=""><li id="ffc1" class="mk ml ht jw b jx jy ka kb kd mm kh mn kl mo kp nd mq mr ms dt translated"><code class="eh oa ob oc od b">cargo install mrepl</code></li><li id="24ee" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><code class="eh oa ob oc od b">cargo install marine</code></li></ul><p id="21fd" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">FluenceLabs也提供了一个已经设置好的开发docker容器<a class="ae kq" href="https://github.com/fluencelabs/devcontainer" rel="noopener ugc nofollow" target="_blank">在这里</a>，但是我鼓励你继续设置环境，以便更好地理解Fluence的工具。</p><p id="e2e1" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">有了以上这些，你就可以开始编程了！</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff oe"><img src="../Images/3ad35701e6ea68575a414770d4f67ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/0*t6AFlr28oUkmRNOe"/></div></figure><p id="d748" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">下图所示的文件夹结构是自以为是的，但我觉得这种结构有助于保持东西的组织性。对于其他Fluence项目，请随意采用不同的结构，但我建议遵循这一条。</p><pre class="jj jk jl jm fq of od og oh aw oi dt"><span id="0072" class="nm ks ht od b fv oj ok l ol om">- project_name<br/>|--- ng-app                 # Angular application root folder<br/>|      |--- ....<br/>|<br/>|--- services               # Fluence services<br/>|      |--- curl            # curl Fluence service root folder<br/>|      |--- ....            # other services...<br/>|<br/>|--- artifacts<br/>|      |--- *.wasm          # Build wasm moduel<br/>|<br/>|--- app-&lt;env&gt;.config.json  # environment Fluence app config<br/>|--- repl.toml              # Marine REPL config<br/>|--- package.json           # defines root dependencies and scripts<br/>|--- package-lock.json      # Auto generated<br/>|--- README.md</span></pre><p id="6fed" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">首先创建一个文件夹并初始化一个NodeJS项目:<code class="eh oa ob oc od b">npm init</code></p><p id="dbab" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">安装<code class="eh oa ob oc od b">fldist</code>根依赖:<code class="eh oa ob oc od b">npm install --save fldist</code>。<em class="mg"> Fluence-Distributor </em>(简称fldist)是另一个Fluence工具，帮助在Fluence网络上部署服务和应用。这可以在全球范围内安装，但是当作为根项目依赖项的一部分安装时，任何下载该项目的人都可以查看、安装和使用正确的<em class="mg">流量分配器</em>版本。</p><p id="e155" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">此外，我们可以将以下脚本别名添加到根<code class="eh oa ob oc od b">package.json</code>文件中，以帮助开发:</p><pre class="jj jk jl jm fq of od og oh aw oi dt"><span id="6ea0" class="nm ks ht od b fv oj ok l ol om">"scripts": {</span><span id="c14a" class="nm ks ht od b fv on ok l ol om">     "fluence-build": "rm -rf artifacts &amp;&amp; for D in services/*; do if [ -d \"${D}\" ]; then (echo \"[+] Compiling ${D}\" &amp;&amp; cd \"${D}\" &amp;&amp; marine build --release &amp;&amp; mkdir -p ../../artifacts/ &amp;&amp; cp t arget/wasm32-wasi/release/*.wasm ../../artifacts/); fi; done",</span><span id="04cd" class="nm ks ht od b fv on ok l ol om">     "fluence-deploy": "fldist deploy_app --env ${FLUENCE_ENV} -i app-${FLUENCE_ENV}.config.json -o ng-app/src/fluence/deployment.${FLUENCE_ENV}.json",</span><span id="eec9" class="nm ks ht od b fv on ok l ol om">     "fluence-node": "docker run --rm --name fluence_node -e RUST_LOG=\"info\" -p 1210:1210 -p 4310:4310 -d fluencelabs/fluence:latest -t 1210 -w 4310 -k gKdiCSUr1TFGFEgu2t8Ch1XEUsrN5A2UfBLjSZvfci9SPR3NvZpACfcpPGC3eY4zma1pk7UvYv5zb1VjvPHwCjj --local",</span><span id="ecc6" class="nm ks ht od b fv on ok l ol om">     "fluence-node-peerid": "docker logs fluence_node 2&gt;&amp;1 | grep \"server peer id\" | rev | cut -d' ' -f1 | rev"</span><span id="a03b" class="nm ks ht od b fv on ok l ol om">}</span></pre><p id="e515" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在下面找到每个脚本的描述:</p><ul class=""><li id="ee0a" class="mk ml ht jw b jx jy ka kb kd mm kh mn kl mo kp nd mq mr ms dt translated"><code class="eh oa ob oc od b">fluence-build</code>:构建驻留在<code class="eh oa ob oc od b">services</code>文件夹中的任何Fluence服务，并将wasm工件转储到<code class="eh oa ob oc od b">artifacts</code>文件夹中。</li><li id="bcf3" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><code class="eh oa ob oc od b">fluence-deploy</code>:查找<code class="eh oa ob oc od b">app-&lt;env&gt;.config.json</code>配置文件，在Fluence network上部署定义好的app。环境由<code class="eh oa ob oc od b">FLUENCE_ENV</code>变量设置。</li><li id="2f4a" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><code class="eh oa ob oc od b">fluence-node</code>:运行本地docker节点进行本地测试。</li><li id="24ba" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><code class="eh oa ob oc od b">fluence-node-peerid</code>:检索正在运行的本地节点的对等id。</li></ul><h2 id="efb3" class="nm ks ht bd kt nn no np kx nq nr ns lb kd nt nu ld kh nv nw lf kl nx ny lh nz dt translated">流量卷曲服务</h2><p id="feb6" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">希望你现在已经理解了提议的文件夹结构的细微差别，所以让我们开始构建Fluence curl服务吧！为了使事情更清楚，有必要澄清一个<strong class="jw hu">服务</strong>是一个或多个WebAssembly模块的集合。在这种情况下，上述服务仅由一个模块组成，因此您可能会看到术语<em class="mg">服务</em>和<em class="mg">模块</em>在整篇文章中互换使用。</p><p id="2ea5" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在根<code class="eh oa ob oc od b">services</code>文件夹中创建一个名为<code class="eh oa ob oc od b">curl</code>的文件夹，并在其中运行<code class="eh oa ob oc od b">cargo init</code>。这将创建一个子文件夹<code class="eh oa ob oc od b">src</code>和一个<code class="eh oa ob oc od b">Cargo.toml</code>文件。你只需要知道这是Rust包的基本文件夹结构。</p><p id="3be9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在<code class="eh oa ob oc od b">curl</code>文件夹中添加另一个文件<code class="eh oa ob oc od b">config.json </code>，该文件包含以下内容:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oo op l"/></div></figure><p id="999d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">该文件定义了服务的配置。为了澄清起见，<code class="eh oa ob oc od b">mountedBinaries</code>在这里仅提供从Fluence服务内部对<code class="eh oa ob oc od b">/usr/bin/curl</code>的访问。</p><blockquote class="md me mf"><p id="12a1" class="ju jv mg jw b jx jy iu jz ka kb ix kc mh ke kf kg mi ki kj kk mj km kn ko kp hm dt translated">这是必要的，因为WebAssembly没有任何内置的IO功能，否则我们将无法执行HTTP请求。</p></blockquote><p id="6d49" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">关于服务如何配置和工作的精彩介绍可以在这里找到:<a class="ae kq" href="https://www.youtube.com/watch?v=om038Mnzj_w" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=om038Mnzj_w</a></p><p id="69a3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">继续，用下面的内容替换<code class="eh oa ob oc od b">src/main.rs</code>文件的内容:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oo op l"/></div></figure><p id="2fea" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">注意<code class="eh oa ob oc od b">curl</code>是如何被用来创建<code class="eh oa ob oc od b">post_request</code>和<code class="eh oa ob oc od b">get_request</code>函数的，这些函数通过<code class="eh oa ob oc od b">#[marine]</code>宏暴露给Fluence服务！</p><blockquote class="lo"><p id="181a" class="lp lq ht bd lr ls lt lu lv lw lx kp ek translated">干得好！您刚刚编写了一个Fluence服务。</p></blockquote><p id="3ce0" class="pw-post-body-paragraph ju jv ht jw b jx ly iu jz ka lz ix kc kd ma kf kg kh mb kj kk kl mc kn ko kp hm dt translated">让我们继续进行测试吧！回想一下，在创建<code class="eh oa ob oc od b">package.json</code>文件时，我们已经创建了一些快捷方式脚本。是时候派上用场了！</p><p id="1cd2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">要使用海洋REPL测试服务，我们需要首先构建它。导航回根文件夹，<code class="eh oa ob oc od b">npm run fluence-build</code>将填充<code class="eh oa ob oc od b">services</code>文件夹中的所有文件夹，并尝试将其构建为Fluence服务。所有的构建工件(WASM模块)将被转储到<code class="eh oa ob oc od b">artifacts</code>文件夹中。</p><p id="bf4a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">开始测试前的最后一件事是配置我们的REPL。也就是说，指定加载什么模块以及在哪里可以找到它们。在项目的根文件夹中创建一个<code class="eh oa ob oc od b">repl.toml</code>,并添加以下内容:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oo op l"/></div></figure><p id="6b40" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在通过执行<code class="eh oa ob oc od b">marine repl repl.toml</code>运行REPL。您应该会看到下面的消息:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff oq"><img src="../Images/eab8f58f61f4f7e6fab1d5a8bf4f5769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQNDAO4979OBdkmpl9HIeQ.png"/></div></div></figure><p id="17b7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这是已经装载了<code class="eh oa ob oc od b">curl</code>模块的REPL。请记住，在多服务场景中，<code class="eh oa ob oc od b">repl.toml</code>文件可以扩展更多的模块，这样所有的模块都可以一次加载。</p><p id="ab4d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在REPL中运行<code class="eh oa ob oc od b">interface curl</code>以获得模块可用功能的列表:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ca"><img src="../Images/b445def4a04411723e81816e7fa0efe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZSG0v7TB11srZY9Nb2VHA.png"/></div></div></figure><p id="34d7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">从REPL中，我们直接调用模块函数，就像这样:</p><p id="cabd" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh oa ob oc od b">call &lt;module&gt; &lt;function&gt; [&lt;params&gt;]</code></p><p id="02ea" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">继续测试<code class="eh oa ob oc od b">get_request</code>功能:</p><p id="e3e3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated"><code class="eh oa ob oc od b">call curl get_request "https://random-data-api.com/api/bank/random_bank?size=3"</code></p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff or"><img src="../Images/75d32e3be47b84f196d1dbe1b8f880e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zDqqWSAmsnxwvMVHUews3w.png"/></div></div></figure><p id="969d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">作品如魅！将<code class="eh oa ob oc od b">post_request</code>测试视为读者的一个练习！去试试吧！</p><h2 id="8668" class="nm ks ht bd kt nn no np kx nq nr ns lb kd nt nu ld kh nv nw lf kl nx ny lh nz dt translated">本地部署</h2><p id="3ed2" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">下一步是在本地部署Fluence服务，以便前端Angular应用程序可以通过AIR脚本调用它。</p><p id="c68f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">确保您安装了docker，并通过执行:<code class="eh oa ob oc od b">npm run fluence-node</code>启动本地Fluence节点</p><p id="721f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">通过运行<code class="eh oa ob oc od b">npm run fluence-node-peerid</code>获取新创建的节点的对等ID。</p><blockquote class="md me mf"><p id="a234" class="ju jv mg jw b jx jy iu jz ka kb ix kc mh ke kf kg mi ki kj kk mj km kn ko kp hm dt translated">回想一下，所有的<code class="eh oa ob oc od b">npm run ...</code>脚本都是在<code class="eh oa ob oc od b">package.json</code>中定义的。如果您对这些别名所对应的确切bash命令感兴趣，请随意参考。</p></blockquote><p id="b745" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">为了让<code class="eh oa ob oc od b">fldist</code>知道在哪里部署服务，您必须创建一个应用程序配置。您可以为每个环境配置一个应用程序。用下面所示的格式创建一个<code class="eh oa ob oc od b">app-local.config.json</code>文件，其中<code class="eh oa ob oc od b">&lt;peed-id&gt;</code>是要部署到的节点的对等ID。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oo op l"/></div></figure><p id="2a67" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">您的本地流量节点对等ID应该是:</p><pre class="jj jk jl jm fq of od og oh aw oi dt"><span id="cd1f" class="nm ks ht od b fv oj ok l ol om">12D3KooWKEprYXUXqoV5xSBeyqrWLpQLLH4PXfvVkDJtmcqmh5V3</span></pre><blockquote class="md me mf"><p id="f49f" class="ju jv mg jw b jx jy iu jz ka kb ix kc mh ke kf kg mi ki kj kk mj km kn ko kp hm dt translated">这是固定的，因为在本地节点的部署过程中，私钥是作为docker容器创建命令的一部分给出的(见<code class="eh oa ob oc od b">package.json</code></p></blockquote><p id="b446" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在Fluence节点准备好托管curl Fluence服务后，继续重建curl服务<code class="eh oa ob oc od b">npm run fluence-build</code>。</p><p id="fa72" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在，在运行<code class="eh oa ob oc od b">npm run fluence-deploy</code>命令之前，检查这个别名背后的实际命令是有见地的:</p><pre class="jj jk jl jm fq of od og oh aw oi dt"><span id="c902" class="nm ks ht od b fv oj ok l ol om">fldist deploy_app --env ${FLUENCE_ENV} -i app-${FLUENCE_ENV}.config.json -o ng-app/src/fluence/deployment.${FLUENCE_ENV}.json</span></pre><p id="002a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如您所见，环境变量<code class="eh oa ob oc od b">FLUENCE_ENV</code>用于指定环境并找到相应的应用程序配置文件，但是，包含部署细节的json文件也会被转储到<code class="eh oa ob oc od b">ng-app/src/fluence/deployment.&lt;FLUENCE_ENV&gt;.json</code>。该文件由Angular应用程序获取，以便Fluence客户端知道正确的节点和服务ID。(参见<code class="eh oa ob oc od b">ng-app/src/environments/..</code>)</p><p id="2c5d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在这个阶段，你应该下载我提供的全部代码的<a class="ae kq" href="https://github.com/apogiatzis/fluence-ether-dex-price/tree/blogpost" rel="noopener ugc nofollow" target="_blank">库</a>，并把<code class="eh oa ob oc od b">ng-app</code>文件夹复制到你的项目文件夹中。这是为了避免花费时间构建UI，事实上这已经超出了这篇博文的范围，但是这也是为了确保部署工件的文件夹目标存在。现在，您已经准备好部署Fluence服务，使用:</p><pre class="jj jk jl jm fq of od og oh aw oi dt"><span id="0d47" class="nm ks ht od b fv oj ok l ol om">FLUENCE_ENV=local npm run fluence-deploy</span></pre><p id="95f9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">部署完成后，您应该会看到类似这样的内容:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff os"><img src="../Images/aa95d53df95315c6831277f5fb2bda42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kyvf8UFlWKDyGXOy1roRyQ.png"/></div></div></figure><p id="0047" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">将<code class="eh oa ob oc od b">service-id</code>(卷曲字段)存放在某个地方，因为下面会用到它。</p><p id="a81e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">恭喜你！您已经部署了Fluence服务！</p><h2 id="22ef" class="nm ks ht bd kt nn no np kx nq nr ns lb kd nt nu ld kh nv nw lf kl nx ny lh nz dt translated">测试AIR脚本</h2><p id="7df9" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">有了这个，现在您可以测试一个AIR脚本(这是前端查询服务的方式)来查看整个Fluence堆栈的运行情况！</p><p id="ad41" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">查看以下AIR脚本:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="oo op l"/></div></figure><p id="bd1b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">对于函数式编程爱好者来说，<a class="ae kq" href="https://en.wikipedia.org/wiki/S-expression" rel="noopener ugc nofollow" target="_blank"> S-expression </a>语法在LISP、Clojure等中可能看起来很熟悉……对于其他人来说，它可能看起来很混乱，但实际上非常简单。通俗地说，上面的脚本试图用URL“https://ether eum-dex-prices-service . production . air swap . io/sell？amount = 1&amp;symbol = DAI&amp;decimals = "作为参数，使用由<code class="eh oa ob oc od b">service</code>变量设置的id，并返回结果。如果出现错误，它将返回错误。有关空气的更多信息，请参考<a class="ae kq" href="https://doc.fluence.dev/docs/knowledge_knowledge/knowledge_aquamarine/hll/knowledge_aquamarine_air" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="212f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">将上面的AIR脚本保存在一个名为<code class="eh oa ob oc od b">request.air</code>的文件中，并使用<code class="eh oa ob oc od b">fldist</code>对部署的服务进行测试:</p><pre class="jj jk jl jm fq of od og oh aw oi dt"><span id="4795" class="nm ks ht od b fv oj ok l ol om">fldist run_air -p req.air -d '{"service": "07e91bc8-273e-4fdf-9a58-4409a292746a"}' --env local --node-id 12D3KooWKEprYXUXqoV5xSBeyqrWLpQLLH4PXfvVkDJtmcqmh5V3</span></pre><p id="bcfb" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">上面的命令利用子命令<code class="eh oa ob oc od b">run_air</code>对id为07e 91 BC 8–273 e-4 fdf-9a 58–4409 a 292746 a的服务运行给定的AIR脚本，该服务托管在id为12 D3 koowwkepryxuxqov 5 xsbeyqrwlpqlh 4 pxfvvkdjtmcqmh 5 v3的节点(我们的本地节点)上。</p><p id="db9f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">应该会收到类似下面的响应:</p><pre class="jj jk jl jm fq of od og oh aw oi dt"><span id="6d5b" class="nm ks ht od b fv oj ok l ol om">[<br/>  {<br/>    "error": "",<br/>    "ret_code": 0,<br/>    "stderr": "",<br/>    "stdout": "[{\"Bamboo Relay\":{\"exchangeName\":\"Bamboo Relay\",\"totalPrice\":0.0008333333333333334,\"tokenAmount\":\"1\",\"tokenSymbol\":\"DAI\",\"avgPrice\":0.0008333333333333334,\"timestamp\":1624287973500,\"error\":null}},{\"Kyber\":{\"exchangeName\":\"Kyber\",\"totalPrice\":0.000500727994965449,\"tokenAmount\":1,\"tokenSymbol\":\"DAI\",\"avgPrice\":0.000500727994965449,\"timestamp\":1624287973339,\"error\":null}},{\"Uniswap\":{\"exchangeName\":\"Uniswap\",\"totalPrice\":0.0004982218341102291,\"tokenAmount\":\"1\",\"tokenSymbol\":\"DAI\",\"avgPrice\":0.0004982218341102291,\"timestamp\":1624287973701,\"error\":null}},{\"Switcheo\":{\"exchangeName\":\"Switcheo\",\"totalPrice\":0.00035138145619503076,\"tokenAmount\":\"1\",\"tokenSymbol\":\"DAI\",\"avgPrice\":0.00035138145619503076,\"timestamp\":1624287973491,\"error\":null}},{\"Eth2Dai\":{\"exchangeName\":\"Eth2Dai\",\"totalPrice\":0.000250187640730547,\"tokenAmount\":\"1\",\"tokenSymbol\":\"DAI\",\"avgPrice\":0.000250187640730547,\"timestamp\":1624287973767,\"error\":null}},{\"Ethfinex\":{\"exchangeName\":\"Ethfinex\",\"timestamp\":1624287973364,\"tokenSymbol\":\"DAI\",\"tokenAmount\":\"1\",\"error\":\"no price data found on Ethfinex for DAI\"}},{\"Bancor\":{\"exchangeName\":\"Bancor\",\"timestamp\":1624287975588,\"error\":\"Error: ESOCKETTIMEDOUT\",\"tokenAmount\":1,\"tokenSymbol\":\"DAI\"}},{\"IDEX\":{\"exchangeName\":\"IDEX\",\"timestamp\":1624287972614,\"tokenSymbol\":\"DAI\",\"tokenAmount\":\"1\",\"error\":\"no price data found on IDEX for DAI\"}},{\"DDEX\":{\"exchangeName\":\"DDEX\",\"timestamp\":1624287974841,\"tokenSymbol\":\"DAI\",\"tokenAmount\":\"1\",\"error\":\"no price data found on DDEX for DAI\"}},{\"Radar Relay\":{\"exchangeName\":\"Radar Relay\",\"timestamp\":1624287972593,\"tokenSymbol\":\"DAI\",\"tokenAmount\":\"1\",\"error\":\"no price data found on Radar Relay for DAI\"}},{\"Saturn Network\":{\"exchangeName\":\"Saturn Network\",\"timestamp\":1624287977826,\"tokenSymbol\":\"DAI\",\"tokenAmount\":\"1\",\"error\":\"no price data found on Saturn Network for DAI\"}},{\"AirSwap\":{\"exchangeName\":\"AirSwap\",\"timestamp\":1624287977674,\"error\":\"No quotes returned by any AirSwap maker\",\"tokenSymbol\":\"DAI\",\"tokenAmount\":\"1\"}},{\"Forkdelta\":{\"exchangeName\":\"Forkdelta\",\"timestamp\":1624287979173,\"tokenSymbol\":\"DAI\",\"tokenAmount\":\"1\",\"error\":\"no price data found on Forkdelta for DAI\"}}]"<br/>  }<br/>] </span></pre><p id="9ba2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">以上确认了AIR脚本按预期工作！</p><h2 id="5b39" class="nm ks ht bd kt nn no np kx nq nr ns lb kd nt nu ld kh nv nw lf kl nx ny lh nz dt translated"><strong class="ak">运行角度应用</strong></h2><p id="7f4a" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">是时候通过运行Angular应用程序来查看整个应用程序的运行情况了。为了保持这篇文章的简短，我不会深入讨论如何构建有角度的前端。然而，如果你复制了<code class="eh oa ob oc od b">ng-app</code>文件夹，你应该已经有了你需要的所有东西，如上面的步骤所述。</p><p id="8a32" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">简而言之，Angular应用程序使用类似于您之前测试的AIR脚本，并使用Fluence JavaScript SDK将粒子发送到指定的Fluence节点和服务id(基于环境)。</p><p id="81a9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">要启动angular应用程序，导航到ng-app文件夹运行<code class="eh oa ob oc od b">npm install</code>安装所有NodeJS依赖项，然后:</p><pre class="jj jk jl jm fq of od og oh aw oi dt"><span id="7e18" class="nm ks ht od b fv oj ok l ol om">npm start -- --configuration=local</span></pre><p id="f8df" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">等待开发服务器启动并运行，然后访问<a class="ae kq" href="http://localhost:4200/" rel="noopener ugc nofollow" target="_blank"> http://localhost:4200/ </a></p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ot"><img src="../Images/943acda17bbe0b06fa34c90c3dd04150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F0gdlDhKBE8r7VkJGDXs-w.png"/></div></div></figure><p id="35f2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">您应该会看到一个简单的界面，其中有一个针对特定令牌和动作搜索以太网价格的表单。尝试一下，并验证它的工作！</p><h1 id="da8a" class="kr ks ht bd kt ku kv kw kx ky kz la lb iz lc ja ld jc le jd lf jf lg jg lh li dt translated">结论</h1><p id="fb8e" class="pw-post-body-paragraph ju jv ht jw b jx lj iu jz ka lk ix kc kd ll kf kg kh lm kj kk kl ln kn ko kp hm dt translated">这都是我送的！虽然这是一个非常简单的项目，但Fluence stack的可能性是无限的。在以后的文章中，我将尝试演示更多的高级概念，如多服务应用程序和身份验证。请随意叉，扩展或试验该项目，并请在这篇文章下面的评论中留下任何反馈或可能出现的问题！👍</p><blockquote class="lo"><p id="2f24" class="lp lq ht bd lr ls lt lu lv lw lx kp ek translated">加入<a class="ae kq" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank"> Coinmonks电报频道</a>，了解加密交易和投资</p></blockquote><h2 id="3e0c" class="nm ks ht bd kt nn ou np kx nq ov ns lb kd ow nu ld kh ox nw lf kl oy ny lh nz dt translated">另外，阅读</h2><ul class=""><li id="6c6b" class="mk ml ht jw b jx lj ka lk kd oz kh pa kl pb kp nd mq mr ms dt translated"><a class="ae kq" href="https://blog.coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">电网交易机器人</a> | <a class="ae kq" rel="noopener" href="/coinmonks/cryptohopper-review-a388ff5bae88">加密交易机器人</a> | <a class="ae kq" href="https://blog.coincodecap.com/best-crypto-trading-bots" rel="noopener ugc nofollow" target="_blank">加密交易机器人</a></li><li id="06fb" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">加密复制交易平台</a> | <a class="ae kq" rel="noopener" href="/coinmonks/buy-bitcoin-on-wazirx-2d12b7989af1">如何在WazirX上购买比特币</a></li><li id="8769" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/coinloan-review-18128b9badc4"> CoinLoan审核</a>|<a class="ae kq" rel="noopener" href="/coinmonks/crypto-com-review-f143dca1f74c">Crypto.com审核</a> | <a class="ae kq" rel="noopener" href="/coinmonks/huobi-margin-trading-b3b06cdc1519">火币保证金交易</a></li><li id="7cd5" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/youhodler-vs-coinloan-vs-hodlnaut-b1050acde55a">尤霍德勒vs考尼洛vs霍德诺特</a> | <a class="ae kq" href="https://blog.coincodecap.com/cryptohopper-vs-haasbot" rel="noopener ugc nofollow" target="_blank"> Cryptohopper vs哈斯博特</a></li><li id="65b3" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><a class="ae kq" href="https://blog.coincodecap.com/blockchain-courses" rel="noopener ugc nofollow" target="_blank">顶级付费加密货币和区块链课程</a> | <a class="ae kq" rel="noopener" href="/coinmonks/binance-review-ee10d3bf3b6e">币安评论</a></li><li id="c1d3" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/mxc-exchange-review-3af0ec1cba8c"> MXC交易所评论</a> | <a class="ae kq" href="https://blog.coincodecap.com/pionex-vs-binance" rel="noopener ugc nofollow" target="_blank"> Pionex vs币安</a> | <a class="ae kq" href="https://blog.coincodecap.com/pionex-arbitrage-bot" rel="noopener ugc nofollow" target="_blank"> Pionex套利机器人</a></li><li id="28f5" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/buy-bitcoin-in-india-feb50ddfef94">如何在印度购买比特币？</a> | <a class="ae kq" rel="noopener" href="/coinmonks/wazirx-review-5c811b074f5b"> WazirX审核</a> | <a class="ae kq" href="https://blog.coincodecap.com/bitmex-review" rel="noopener ugc nofollow" target="_blank"> BitMEX审核</a></li><li id="c02f" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度的加密交易所</a> | <a class="ae kq" rel="noopener" href="/coinmonks/bitcoin-savings-account-e65b13f92451">比特币储蓄账户</a> | <a class="ae kq" rel="noopener" href="/coinmonks/hitbtc-review-c5143c5d53c2"> HitBTC审查</a></li><li id="5c74" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/binance-fees-8588ec17965">币安收费</a> | <a class="ae kq" rel="noopener" href="/coinmonks/botcrypto-review-2021-build-your-own-trading-bot-coincodecap-6b8332d736c7"> Botcrypto审查</a> | <a class="ae kq" rel="noopener" href="/coinmonks/hotbit-review-cd5bec41dafb"> Hotbit审查</a> | <a class="ae kq" href="https://blog.coincodecap.com/kucoin-review" rel="noopener ugc nofollow" target="_blank"> KuCoin审查</a></li><li id="390e" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/my-experience-with-crypto-copy-trading-d6feb2ce3ac5">我的加密副本交易经历</a> | <a class="ae kq" rel="noopener" href="/coinmonks/aax-exchange-review-2021-67c5ea09330c"> AAX交易所评论</a></li><li id="98d1" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/bybit-margin-trading-e5071676244e"> Bybit融资融券交易</a> | <a class="ae kq" rel="noopener" href="/coinmonks/binance-margin-trading-c9eb5e9d2116">币安融资融券交易</a> | <a class="ae kq" rel="noopener" href="/coinmonks/overbit-review-9446ed4f2188"> Overbit审核</a></li><li id="7883" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/cryptocurrency-savings-accounts-be3bc0feffbf">加密货币储蓄账户</a> | <a class="ae kq" rel="noopener" href="/coinmonks/yobit-review-175464162c62"> YoBit审查</a> | <a class="ae kq" rel="noopener" href="/coinmonks/bitbns-review-38256a07e161"> Bitbns审查</a></li><li id="f652" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/botsfolio-vs-napbots-vs-mudrex-c81344970c02">Botsfolio vs nap bots vs Mudrex</a>|<a class="ae kq" rel="noopener" href="/coinmonks/gate-io-exchange-review-61bf87b7078f">gate . io交流回顾</a></li><li id="1bcd" class="mk ml ht jw b jx mt ka mu kd mv kh mw kl mx kp nd mq mr ms dt translated"><a class="ae kq" rel="noopener" href="/coinmonks/godex-io-review-7366086519fb"> Godex.io评审</a> | <a class="ae kq" rel="noopener" href="/coinmonks/invity-review-70f3030c0502">邀请评审</a> | <a class="ae kq" rel="noopener" href="/coinmonks/bitforex-review-c4bb28d9e271"> BitForex评审</a> | <a class="ae kq" rel="noopener" href="/coinmonks/kraken-review-6165fc1056ac">北海巨妖评审</a></li></ul></div></div>    
</body>
</html>