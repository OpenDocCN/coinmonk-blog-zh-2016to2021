<html>
<head>
<title>How To Secure Messages On EOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何保护EOS上的消息</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-secure-messages-on-eos-ebb869a459ea?source=collection_archive---------3-----------------------#2018-08-31">https://medium.com/coinmonks/how-to-secure-messages-on-eos-ebb869a459ea?source=collection_archive---------3-----------------------#2018-08-31</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/cbb23d8c74d5349b15f6f1307cce4a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VsEX90pmTNFApXmwH8_bcg.png"/></div></div></figure><p id="7445" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">区块链是一个分布式账本，每个数据块都是公开的，每个人都可以看到。你可能想知道，如果我想加密区块链上的消息，特别是EOS上的消息怎么办？</p><h1 id="e51e" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">区块链上保护消息的工作原理</h1><p id="ce68" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">我们可以加入<a class="ae lc" href="https://www.nucypher.com/" rel="noopener ugc nofollow" target="_blank"> NuCypher </a>。NuCypher通过分散式代理重加密服务，帮助dApp开发人员在公共区块链上存储、共享和管理私有数据。</p><p id="2647" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是它的工作原理。</p><ol class=""><li id="b13f" class="ld le ht jd b je jf ji jj jm lf jq lg ju lh jy li lj lk ll dt translated">Alice拥有敏感数据，她希望能够委派访问权限。</li><li id="e382" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">Alice使用她自己的公钥加密她的数据，并将其存储在云中，或分散存储中。</li><li id="b34d" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">Alice将访问权委托给Bob。数据在存储器中被重置为Bob的密钥。</li><li id="2970" class="ld le ht jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">Bob下载数据并用他的私钥解密。</li></ol><h1 id="2502" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">保护EOS上的消息</h1><p id="0f32" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">我们将从这样一个场景开始，Alice和Bob都可以访问私钥，Alice希望将敏感数据发送给Bob，并利用<a class="ae lc" href="https://github.com/nucypher/pyUmbral" rel="noopener ugc nofollow" target="_blank"> pyUmbral </a>，这是NuCypher对<a class="ae lc" href="https://github.com/nucypher/umbral-doc/blob/master/umbral-doc.pdf" rel="noopener ugc nofollow" target="_blank"> Umbral </a>(分割密钥阈值代理重新加密)的参考实现。</p><p id="23d1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们先在EOS上构建一个消息队列智能合约。</p><p id="1fc4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">它构建了一个名为<strong class="jd hu"> messages、</strong>表，其中包含uint64_t消息id、帐户名称from、帐户名称to、字符串密文和字符串封装。msg_id是主键。</p><p id="ae57" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">它提供了两个动作:<code class="eh lr ls lt lu b">sendmsg</code>和<code class="eh lr ls lt lu b">deletemsg</code>。<code class="eh lr ls lt lu b">sendmsg</code>需要account_name from和to，msg_id，密文和胶囊。密文是加密的消息，胶囊是Umbral中的概念，使用pyUmbral生成。<code class="eh lr ls lt lu b">deletemsg</code>基本上接受一个消息id，验证给定的<code class="eh lr ls lt lu b">to</code>帐户名，然后删除记录。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="a7e9" class="md ka ht lu b fv me mf l mg mh">class queue: public eosio::contract {</span><span id="e45b" class="md ka ht lu b fv mi mf l mg mh">    public:<br/>        using contract::contract;</span><span id="cbad" class="md ka ht lu b fv mi mf l mg mh">        //@abi action<br/>        void sendmsg( account_name from, account_name to, uint64_t msg_id, const std::string &amp; ciphertext, const std::string &amp; capsule) {<br/>            require_auth( from );<br/>            messages_index messages( _self, _self );<br/>            auto itr = messages.find(msg_id);<br/>            if (itr != messages.end()) {<br/>                std::string error = "msg_id already exists: " + std::to_string(msg_id);<br/>                eosio_assert(false, error.c_str());</span><span id="bfb3" class="md ka ht lu b fv mi mf l mg mh">            }<br/>            messages.emplace( from, [&amp;](auto&amp; msg){<br/>                msg.msg_id = msg_id;<br/>                msg.from = from;<br/>                msg.to = to; <br/>                msg.ciphertext = ciphertext;<br/>                msg.capsule = capsule;<br/>            });</span><span id="5f2d" class="md ka ht lu b fv mi mf l mg mh">        }</span><span id="3726" class="md ka ht lu b fv mi mf l mg mh">        // @abi action<br/>        void deletemsg( account_name to, uint64_t msg_id) {<br/>            require_auth( to );<br/>            messages_index messages(_self, _self);<br/>            auto itr = messages.find(msg_id);<br/>            if ( itr == messages.end() ) {<br/>                std::string error = "msg_id does not exist: " + std::to_string(msg_id);<br/>                eosio_assert(false, error.c_str());<br/>            }<br/>            <br/>            if ( itr-&gt;to != to ) {<br/>                std::string error = "Receipient not correct: " + eosio::name{itr-&gt;to}.to_string();<br/>                eosio_assert( false, error.c_str());<br/>            }<br/>          <br/>            messages.erase(itr);<br/>         }</span><span id="68ef" class="md ka ht lu b fv mi mf l mg mh">    private:<br/>        //@abi table messages i64<br/>        struct messages {<br/>            uint64_t msg_id;<br/>            account_name from;<br/>            account_name to;<br/>            std::string ciphertext;<br/>            std::string capsule;</span><span id="be2e" class="md ka ht lu b fv mi mf l mg mh">            uint64_t primary_key() const { return msg_id;}<br/>        };<br/>        <br/>        typedef eosio::multi_index&lt;N(messages), messages&gt; messages_index;</span><span id="6032" class="md ka ht lu b fv mi mf l mg mh">};</span><span id="a363" class="md ka ht lu b fv mi mf l mg mh">EOSIO_ABI( queue, (sendmsg)(deletemsg) )</span></pre><p id="09a6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">编译它:</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="7091" class="md ka ht lu b fv me mf l mg mh">eosiocpp -o queue.wast queue.cpp<br/>eosiocpp -g queue.abi queue.cpp</span></pre><p id="28d5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">创建一个帐户来上传智能合同:</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="775c" class="md ka ht lu b fv me mf l mg mh">$ cleos create account eosio queue EOS5aEqZf22dfThTR8GGMnD8oFvsyzssQnhawNwPzfPv4fwDWhf7H<br/>executed transaction: a767af2c66857...  200 bytes  3309 us<br/># eosio &lt;= eosio::newaccount            {"creator":"eosio","name":"queue","owner":{"threshold":1,"keys":[{"key":"EOS5aEqZf22dfThTR8GGMnD8oFv...</span><span id="6e07" class="md ka ht lu b fv mi mf l mg mh">$ cleos set contract queue ../queue<br/>Reading WAST/WASM from ../queue/queue.wasm...<br/>Using already assembled WASM...<br/>Publishing contract...<br/>executed transaction: 38e94741c...  13824 bytes  9561 us<br/># eosio &lt;= eosio::setcode               {"account":"queue","vmtype":0,"vmversion":0,"code":"00617ee7e...<br/># eosio &lt;= eosio::setabi                {"account":"queue","abi":"0e656f73696f3a3a6162692f9640675...</span></pre><p id="b4a9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">创建测试帐户alice和bob:</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="f14c" class="md ka ht lu b fv me mf l mg mh">$ cleos create account eosio alice EOS6NU3XEvosgRVEbhrBHrkbYVteW7DDVewhjo9jgiYoSqUZamnZe<br/>executed transaction: f0c42065f6d9fc...  200 bytes  243 us<br/># eosio &lt;= eosio::newaccount            {"creator":"eosio","name":"alice","owner":{"threshold":1,"keys":[{"key":"EOS6NU3XEvosgRVEbhrBHrkbYVt...</span><span id="70d9" class="md ka ht lu b fv mi mf l mg mh">$ cleos create account eosio bob EOS7cX17CZ8V7yFobaVejAN7sMG39iiC5BmFk7b1NB1NNYcrEu1Go<br/>executed transaction: 51d45916fa252e...  200 bytes  194 us<br/># eosio &lt;= eosio::newaccount            {"creator":"eosio","name":"bob","owner":{"threshold":1,"keys":[{"key":"EOS7cX17CZ8V7yFobaVejAN7sMG39...</span></pre></div><div class="ab cl mj mk hb ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hm hn ho hp hq"><p id="0bfe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们继续构建一个客户端来加密/解密消息，并与智能合约进行交互。</p><ol class=""><li id="246a" class="ld le ht jd b je jf ji jj jm lf jq lg ju lh jy li lj lk ll dt translated">生成私钥并写入文件。</li></ol><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="f006" class="md ka ht lu b fv me mf l mg mh">from umbral import config, keys</span><span id="927b" class="md ka ht lu b fv mi mf l mg mh">config.set_default_curve(SECP256K1)<br/>private_key = keys.UmbralPrivateKey.gen_key()<br/>f = open('priv.key', 'wb')<br/>f.write(private_key.to_bytes())<br/>f.close()</span></pre><p id="ee6d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">2.构建解析器</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="0e82" class="md ka ht lu b fv me mf l mg mh">def create_parser():<br/>    parser = argparse.ArgumentParser(description = 'messenger')<br/>    parser.add_argument('--private-key-file', type = str, dest = 'private_key_file', required = False, help = 'Path to the private key file.')<br/>    parser.add_argument('--send-msg-id', type = str, dest = 'send_msg_id', required = False, help = 'Send a message, msg_id')<br/>    parser.add_argument('--send-msg-from', type = str, dest = 'send_msg_from', required = False, help = 'Send a message, from which EOS account')<br/>    parser.add_argument('--send-msg-to', type = str, dest = 'send_msg_to', required = False, help = 'Send a message, to which EOS account')<br/>    parser.add_argument('--send-msg', type = str, dest = 'send_msg', required = False, help = 'Message to be sent')<br/>    parser.add_argument('--read-msg-to', type = str, dest = 'read_msg_to', required = False, help = 'Read a message, to which EOS account')<br/>    return parser</span><span id="8545" class="md ka ht lu b fv mi mf l mg mh">parser = create_parser()<br/>args = parser.parse_args(argv)</span></pre><p id="f23e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">3.从privkey文件中读取。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="ae50" class="md ka ht lu b fv me mf l mg mh">def read_privkey_file(privkey_file):<br/>    if os.path.exists(privkey_file):<br/>        with open(privkey_file, 'rb') as f:<br/>            try:<br/>                privkey = f.read()<br/>            except Exception as e:<br/>                print("Cannot read: {}".format(e))<br/>                sys.exit(1)<br/>            f.close()<br/>            return privkey<br/>    else:<br/>        print('Cannot find file: {}'.format(privkey_file))<br/>        sys.exit(1)</span></pre><p id="c126" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">3.加密邮件并发送。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="ac89" class="md ka ht lu b fv me mf l mg mh">def send_msg(private_key_file, msg, send_msg_from, send_msg_to, send_msg_id):<br/>    privkey_bytes = read_privkey_file(private_key_file)<br/>    privkey = keys.UmbralPrivateKey.from_bytes(privkey_bytes)<br/>    pubkey = privkey.get_pubkey()</span><span id="9492" class="md ka ht lu b fv mi mf l mg mh">    plaintext = msg.encode()<br/>    ciphertext, capsule = pre.encrypt(pubkey, plaintext)</span><span id="820f" class="md ka ht lu b fv mi mf l mg mh">    data = '{"from":"' + send_msg_from + '", "to":"' + send_msg_to + '", "msg_id":"' + send_msg_id + '", "ciphertext": "' + ciphertext.hex() + '", "capsule": "' + capsule.to_bytes().hex() + '"}'<br/>    subprocess.call(['cleos', 'push', 'action', DEFAULT_ACCOUNT, 'sendmsg', data , '-p', send_msg_from])</span></pre><p id="1710" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">3.从<code class="eh lr ls lt lu b">messages</code>表中读取，如果<code class="eh lr ls lt lu b">to</code>匹配<code class="eh lr ls lt lu b">read_msg_to</code>，解密一条消息，然后删除。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="c1ea" class="md ka ht lu b fv me mf l mg mh">def read_and_delete_msg(private_key_file, read_msg_to):<br/>    privkey_bytes = read_privkey_file(private_key_file)<br/>    privkey = keys.UmbralPrivateKey.from_bytes(privkey_bytes)<br/>    <br/>    payload = '{"scope":"' + DEFAULT_ACCOUNT + '","code":"' + DEFAULT_ACCOUNT + '","table": "' + DEFAULT_TABLE+ '", "json":"true"}'<br/>    response = requests.request("POST", DEFAULT_URL, data=payload)   <br/>    <br/>    found = False<br/>    for msg in response.json()['rows']:<br/>        if msg['to'] == read_msg_to:<br/>            ciphertext = msg['ciphertext']<br/>            capsule = msg['capsule']<br/>            msg_id = msg['msg_id']<br/>            found = True<br/>            break</span><span id="81ad" class="md ka ht lu b fv mi mf l mg mh">    if found:        <br/>        capule = pre.Capsule.from_bytes(bytes.fromhex(capsule), privkey.params)<br/>        cleartext = pre.decrypt(<br/>                          ciphertext = bytes.fromhex(ciphertext),<br/>                          capsule = capule,<br/>                          decrypting_key = privkey)<br/>        print('Cleartext: {}'.format(cleartext))</span><span id="b906" class="md ka ht lu b fv mi mf l mg mh">        print('Deleting msg_id: {}'.format(msg_id))<br/>        data = '{"to":"' + read_msg_to + '", "msg_id":"' + str(msg_id) + '"}'<br/>        subprocess.call(['cleos', 'push', 'action', DEFAULT_ACCOUNT, 'deletemsg', data , '-p', read_msg_to])</span></pre><p id="6498" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">4.默认值。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="fe13" class="md ka ht lu b fv me mf l mg mh">DEFAULT_ACCOUNT = 'queue'</span><span id="6612" class="md ka ht lu b fv mi mf l mg mh">DEFAULT_TABLE = 'messages'</span><span id="332d" class="md ka ht lu b fv mi mf l mg mh">DEFAULT_URL= "http://127.0.0.1:8888/v1/chain/get_table_rows"</span></pre><p id="ad9e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们把它们包起来测试！</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="bae2" class="md ka ht lu b fv me mf l mg mh">$ python3 messenger.py --private-key-file priv.key --send-msg-id 1 --send-msg-from alice --send-msg-to bob --send-msg hello,bob</span><span id="51b0" class="md ka ht lu b fv mi mf l mg mh">executed transaction: dfe17144e105c54d192...  392 bytes  648 us<br/>#         queue &lt;= queue::sendmsg               {"from":"alice","to":"bob","msg_id":1,"ciphertext":"8c53a656c9...</span></pre><p id="9828" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">检查<code class="eh lr ls lt lu b">messages</code>工作台。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="5ec8" class="md ka ht lu b fv me mf l mg mh">$ cleos get table queue queue messages   <br/>{<br/>  "rows": [{<br/>      "msg_id": 1,<br/>      "from": "alice",<br/>      "to": "bob",<br/>      "ciphertext": "8c8aa24196152b53da35d9fbf9e3c4d8e10f6b7153a656c9921cb440cc69a782c2ba0c2cf2",<br/>      "capsule": "028c4e8279c0919bdec4ea98b4251f15a74868d2ea7554ab796230af8f88e62cd9031c07e90c6183152e140c43a370f2c12526b6d62269f8673a35e6a19fc6ff78ac2f3a28dbed868858ec71228644f277c8ecfb691aa41dab863072e6f39c55d294"<br/>    }<br/>  ],<br/>  "more": false<br/>}</span></pre><p id="3a8e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">加密的信息在那里。那我们来读吧。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="7417" class="md ka ht lu b fv me mf l mg mh">$ python3 messenger.py --private-key-file priv.key --read-msg-to bob</span><span id="9acd" class="md ka ht lu b fv mi mf l mg mh">Cleartext: b'hello,bob'<br/>Deleting msg_id: 1</span><span id="1249" class="md ka ht lu b fv mi mf l mg mh">executed transaction: 6cdad7694f3fe6c8...112 bytes  566 us<br/>#         queue &lt;= queue::deletemsg    {"to":"bob","msg_id":1}</span></pre><p id="defe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">查一下<code class="eh lr ls lt lu b">messages</code>表，消息没了。</p><pre class="lv lw lx ly fq lz lu ma mb aw mc dt"><span id="1ab0" class="md ka ht lu b fv me mf l mg mh">$ cleos get table queue queue messages   <br/>{<br/>  "rows": [],<br/>  "more": false<br/>}</span></pre><p id="9aaf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，我们探索了如何保护EOS上的消息。接下来，我们可以处理Alice和Bob拥有自己的密钥或者发送给多个用户的场景。</p><h2 id="8605" class="md ka ht bd kb mq mr ms kf mt mu mv kj jm mw mx kn jq my mz kr ju na nb kv nc dt translated">我们的社交</h2><p id="03d6" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated"><a class="ae lc" href="https://blockgenic.website/" rel="noopener ugc nofollow" target="_blank">网站</a> <br/> <a class="ae lc" href="https://twitter.com/blockgenic" rel="noopener ugc nofollow" target="_blank">推特</a><br/><a class="ae lc" href="https://www.youtube.com/channel/UCXTaehuAs3UWKnMVnT71MMQ" rel="noopener ugc nofollow" target="_blank">Youtube</a><br/><a class="ae lc" href="https://www.meetup.com/nl-NL/Seattle-EOS/" rel="noopener ugc nofollow" target="_blank">Meetup</a><br/><a class="ae lc" href="https://steemit.com/@block21" rel="noopener ugc nofollow" target="_blank">Steem</a></p><p id="2d62" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="nd">由</em> <a class="ae lc" href="https://www.linkedin.com/in/yannick-slenter/" rel="noopener ugc nofollow" target="_blank">写成<em class="nd">由</em> </a> <em class="nd">为</em> <a class="ae lc" href="https://blockgenic.website/" rel="noopener ugc nofollow" target="_blank"> <em class="nd">为</em> </a></p></div></div>    
</body>
</html>